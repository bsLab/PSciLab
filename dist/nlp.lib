var CoreModule = {};
CoreModule['com/io']='com/io';
CoreModule['com/pwgen']='com/pwgen.lw';
CoreModule['assert']='os/assert';
CoreModule['crypto']='os/crypto.rand';
CoreModule['events']='os/events';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['util']='util';
CoreModule['http']='http';
CoreModule['deasync']='deasync';
CoreModule['os']='os';
CoreModule['net']='net';
CoreModule['fs']='fs';
CoreModule['stream']='';
CoreModule['url']='';
CoreModule['zlib']='';
CoreModule['child_process']='';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
var Fs = require("fs");
if (typeof __dirname == 'undefined') __dirname = '';
if (typeof __filename == 'undefined') __filename = 'plugins/nlp/nlp.js';
//From compat.js
var any = undefined;
var empty = null;
var none = null;
var _ = undefined;
var int = function (v) {return v|0};
var div = function (a,b) {return a/b|0};
var print = function (msg) {console.log(msg)};
if (typeof global == 'undefined') global={};
PATH=[process.cwd(),".","/home/sbosse/proj/workbook/src",""];
function _isdir(path) {
  var stats=Fs.statSync(path);
  return stats && stats.isDirectory()};
function _search(index,file) {
  if (PATH.length==index) return file;
  var path=PATH[index];
  if (Fs.existsSync(path+"/"+file+".js")) return path+"/"+file+".js";
  else if (Fs.existsSync(path+"/"+file) && !_isdir(path+"/"+file)) return path+"/"+file;
  else return _search(index+1,file);
 }
var __library=arguments&&arguments[3];
function Require(modupath) { 
  var file,filepath;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}; var module={exports:exports};
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,global,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,global,process);
  else { try { file=_search(0,modupath); module = require(file)}
  catch (e) { var more="";
   if ((e.name==="SyntaxError"||e.name==="TypeError") && file) {
      var src=Fs.readFileSync(file,"utf8");
      var Esprima = Require("parser/esprima");
      try {
        var ast = Esprima.parse(src, { tolerant: true, loc:true });
        if (ast.errors && ast.errors.length>0) more = ", "+ast.errors[0];
      } catch (e) {
        if (e.lineNumber) more = ", in line "+e.lineNumber;
      }
   }
   console.log("Require import of "+modupath+" ("+file+") failed: "+e+more);
   // if (e.stack) console.log(e.stack);
   throw e; // process.exit(-1);
  }}
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
FilesEmbedded=global.FilesEmbedded = {};
FileEmbedd=global.FileEmbedd = function (path,format) {};
FileEmbedded=global.FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='node';

BundleModuleCode['com/io']=function (module,exports,global,process){
/**
 **      ==================================
 **      OOOO   OOOO OOOO  O      O   OOOO
 **      O   O  O    O     O     O O  O   O
 **      O   O  O    O     O     O O  O   O
 **      OOOO   OOOO OOOO  O     OOO  OOOO
 **      O   O     O    O  O    O   O O   O
 **      O   O     O    O  O    O   O O   O
 **      OOOO   OOOO OOOO  OOOO O   O OOOO
 **      ==================================
 **      BSSLAB, Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR.
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2020 BSSLAB
 **    $CREATED:     sbosse on 3/28/15.
 **    $VERSION:     1.7.1X
 **
 **    $INFO:
 *
 * This module encapsulates all IO operations (except networking) supporting
 * node.js applications.
 *
 **    $ENDOFINFO
 */

if (global.TARGET=='node')  { 

 /*
  ************
  ** Node.js
  ************
  */
 var util = require('util');
 var GetEnv = Require('os/getenv');
 var Base64 = Require('os/base64');
 var Fs = require('fs');
 var os = require('os');
 var child = require('child_process');

 var stderr_fun = function (str) { process.stderr.write(str); };
 var stdout_fun = function (str) { process.stdout.write(str); };

 /*
  ** node.js specific
  */

 var tracefile = undefined;
 var tracing = true;

 /**
 * Open a module and append all exported properties to the current global object.
 * (top-level scope)
 */
 global.open = function(name,as) {
   var module = Require(name);
   for (var p in module) {
     global[p] = module[p];
   };
   if (as) global[as]=module;
 }

/*
 ** node.js
 */
var io = {
    checkOptions : function(options,defaultOptions) {
      return Object.assign({}, defaultOptions||{}, options) },
      
    checkOption : function (option,defaultOption) { 
      return option==undefined? defaultOption:option },

    config: {
        columns:undefined,
        rows:undefined
    },
    /**************
     ** FILE IO
     ***************/
    /**
     *
     * @param fd
     */
    close: function (fd) {
        Fs.closeSync(fd);
    },
    /**
     *
     * @param path
     */
    exists: function (path) {
        return Fs.existsSync(path);
    },
    /**
     *
     * @param path
     */
    file_exists: function (path) {
        return Fs.existsSync(path);
    },
    /** Search a file by iterating global PATH variable.
     *
     * @param name  File name or partial (relative) path
     */
    file_search: function (name) {
        // Expecting global PATH variable !?
        if (this.file_exists(name)) return name; 
        else if (typeof PATH !== 'undefined') {
          for (var p in PATH) {
            if (this.file_exists(PATH[p]+'/'+name)) return (PATH[p]+'/'+name);
          }
          return undefined;
        } else return undefined;
    },
    /**
     *
     * @param path
     * @returns {number}
     */
    file_size: function (path) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            return stat.size;
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param timekind a c m
     * @returns {number}
     */
    file_time: function (path,timekind) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            switch (timekind) {
                case 'a': return stat.atime.getTime()/1000;
                case 'c': return stat.ctime.getTime()/1000;
                case 'm': return stat.mtime.getTime()/1000;
                default: return stat.mtime.getTime()/1000;
            }
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param mode
     * @returns {*}
     */
    open: function (path, mode) {
        return Fs.openSync(path, mode);
    },
    /**
     *
     * @param fd
     * @param len
     * @param foff
     */
    read: function (fd, len, foff) {
        // TODO
    },
    /**
     *
     * @param path
     * @returns {string|undefined}
     */
    read_file: function (path) {
        try {
            return Fs.readFileSync(path,'utf8');
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    read_file_bin: function (path) {
        try {
            return Fs.readFileSync(path);
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param fd
     */
    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {number}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return Fs.readSync(fd, buf, boff, len, foff);
    },
    /**
     *
     * @param fd
     */
    sync: function (fd) {
        Fs.fsyncSync(fd);
    },
    
    time: function () {
      return Date.now()
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {number}
     */
    write: function (fd, data, foff) {
        return Fs.writeSync(fd, data, foff);
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {number}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return Fs.writeSync(fd, buf, bpos, blen, foff);
    },
    /**
     *
     * @param path
     * @param {string} buf
     */
    write_file: function (path,str) {
        try {
            Fs.writeFileSync(path, str, 'utf8');
            return str.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param path
     * @param buf
     * @returns {*}
     */
    write_file_bin: function (path,buf) {
        try {
            Fs.writeFileSync(path, buf, 'binary');
            return buf.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param fd
     * @param {string} str
     * @returns {number}
     */
    write_line: function (fd, str) {
        return Fs.writeSync(fd, str+NL);
    },

    /****************
     ** CONSOLE IO
     ****************/
    /**
     *
     * @param msg
     */
    debug: function (msg) {
        console.error('Debug: ' + msg);
    },
    /**
     *
     * @param msg
     */
    err: function (msg) {
        console.error('Error: ' + msg);
        throw Error(msg);
    },
    /**
     *
     * @param msg
     */
    fail: function (msg) {
        console.error('Fatal Error: ' + msg);
        process.exit(0);
    },
    /**
     *
     * @param obj
     */
    inspect: function (obj,depth) {return util.inspect(obj,{showHidden: false, 
                                                            depth: depth?depth:2})},

    /**
     * 
     */
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (!e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        if (where==undefined) this.out(e);
        else this.out(where+': '+e);
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
     /**
     *
     * @param e
     * @param where
     */
    sprintstack: function (e) {
        var str='';
        if (e==_ || !e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .replace(/^Object.eval\s*\(/gm, '')
            .split('\n');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                if (str!='') str += '\n';
                str += '  at '+line;
            }
        }
        return str;
    },
   /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    /**
     *
     * @param msg
     */
    out: function (msg) {
        console.warn(msg)
    },
    /**
     *
     * @param msg
     */
    warn: function (msg) {
        console.warn('Warning: ' + msg);
    },
    /**
     *
     * @param fun
     */
    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    /**
     *
     * @param fun
     */
    set_stdout: function(fun) {
        stdout_fun=fun;
    },
    /**
     *
     * @param msg
     */
    stderr: function (msg) {
        stderr_fun(msg);
    },
    /**
     *
     * @param msg
     */
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            Fs.writeSync(tracefile, '[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        tracefile = Fs.openSync(path, 'w+');
        if (tracefile != undefined) this.tracing = false;
    },

    /**************
     ** Process control
     ***************/
    exit: function (n) {
        process.exit(n);
    },
    /**
     *
     * @returns {*} RSS HEAP in kBytes {data,heap}
     */
    mem: function () {
        var mem = process.memoryUsage();
        return {data:(mem.rss/1024)|0,heap:(mem.heapUsed/1024)|0};
    },
    /****************************
     ** Environment and Arguments
     ****************************/
    getenv: function (name, def) {
        return GetEnv(name, def);
    },
    workdir: function () {
        return this.getenv('PWD','');
    },

    /**
     *  @return {string []}
     */
    getargs: function () {
        return process.argv;
    },

    sleep: function(delay) {
      var start = new Date().getTime();
      while (new Date().getTime() < start + delay);
    },
    
    /**
     *  Process management
     */
    fork: child.fork,
    exec: child.exec,
    spawn: child.spawn,

    /**
     * OS
     */
    hostname: os.hostname

  };
} else {
 /*
  ************
  ** Browser
  ************
  */
  var tracing = true;
  var stderr_fun = function (str) { console.log(str); };
  var stdout_fun = function (str) { console.log(str); };
  var args=[];

  /**
  * Open a module and append all exported properties to the current global object.
  * (top-level scope)
  */
  global.open = function(name,as) {
    var module = Require(name);
    for (var p in module) {
      global[p] = module[p];
    };
    if (as) global[as]=module;
  }
  
  var io = {
    /*
    ************
    ** Browser
    ************
    */
    /*
     ** FILE IO
     * TODO WebStorage
     */
    close: function (fd) {
        return;
    },
    exists: function (path) {
        return false;
    },
    open: function (path, mode) {
        var fd = Fs.openSync(path, mode);
        return fd;
    },

    read: function (fd, len, foff) {
        // TODO
    },
    read_file: function (path) {
        return '';
    },

    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {*}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return -1;
    },
    sync: function (fd) {
        return;
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {*}
     */
    write: function (fd, data, foff) {
        return -1;
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {*}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return -1;
    },

    /*
     ** CONSOLE IO
     */
    debug: function (msg) {
        stderr_fun('Debug: ' + msg);
    },
    err: function (msg) {
        stderr_fun('Error: ' + msg);
        throw Error(msg);
    },
    fail: function (msg) {
        stderr_fun('Fatal Error: ' + msg);
    },
    inspect: function (obj) {
        return;
    },
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        stderr_fun('Stack Trace');
        stderr_fun('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                stderr_fun(line);
            }
        }
        stderr_fun('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (where==undefined) stderr_fun(e);
        else stderr_fun(where+': '+e);
    },
    /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    out: function (msg) {
        stdout_fun(msg)
    },
    warn: function (msg) {
        stderr_fun('Warning: ' + msg);
    },


    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    set_stdout: function(fun) {
        stdout_fun=fun;
    },

    stderr: function (msg) {
        stderr_fun(msg);
    },
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            this.log('[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        return undefined;
    },

    exit: function (n) {
        return;
    },
    getenv: function (name, def) {
        return def;
    },
    workdir: function () {
        return '';
    },
    /**
     *  @return {string []}
     */
    getargs: function () {
        return args;
    },
    set_args: function (argv) {
        args=argv;
    },
    inspect: function (o) {return '?'}
  };
}  
module.exports = io;
};
BundleModuleCode['os/getenv']=function (module,exports,global,process){
var util = require("util");
var url = require("url");

var fallbacksDisabled = false;

function _value(varName, fallback) {
  var value = process.env[varName];
  if (value === undefined) {
    if (fallback === undefined) {
      throw new Error('GetEnv.Nonexistent: ' + varName + ' does not exist ' +
                      'and no fallback value provided.');
    }
    if (fallbacksDisabled) {
      throw new Error('GetEnv.DisabledFallbacks: ' + varName + ' relying on fallback ' + 
                      'when fallbacks have been disabled');
    }
    return '' + fallback;
  }
  return value;
}

var convert = {
  string: function(value) {
    return '' + value;
  },
  int: function(value) {
    var isInt = value.match(/^-?\d+$/);
    if (!isInt) {
      throw new Error('GetEnv.NoInteger: ' + value + ' is not an integer.');
    }

    return +value;
  },
  float: function(value) {
    var isInfinity = (+value === Infinity || +value === -Infinity);
    if (isInfinity) {
      throw new Error('GetEnv.Infinity: ' + value + ' is set to +/-Infinity.');
    }

    var isFloat = !(isNaN(value) || value === '');
    if (!isFloat) {
      throw new Error('GetEnv.NoFloat: ' + value + ' is not a number.');
    }

    return +value;
  },
  bool: function(value) {
    var isBool = (value === 'true' || value === 'false');
    if (!isBool) {
      throw new Error('GetEnv.NoBoolean: ' + value + ' is not a boolean.');
    }

    return (value === 'true');
  },
  url: url.parse
};

function converter(type) {
  return function(varName, fallback) {
    if(typeof varName == 'string') { // default
      var value = _value(varName, fallback);
      return convert[type](value);
    } else { // multibert!
      return getenv.multi(varName);
    }
  };
};

var getenv = converter('string');

Object.keys(convert).forEach(function(type) {
  getenv[type] = converter(type);
});

getenv.array = function array(varName, type, fallback) {
  type = type || 'string';
  if (Object.keys(convert).indexOf(type) === -1) {
    throw new Error('GetEnv.ArrayUndefinedType: Unknown array type ' + type);
  }
  var value = _value(varName, fallback);
  return value.split(/\s*,\s*/).map(convert[type]);
};

getenv.multi = function multi(spec) {
  var key, value;
  var result = {};
  for(var key in spec) {
    var value = spec[key];
    if(util.isArray(value)) { // default value & typecast
      switch(value.length) {
        case 1: // no default value
        case 2: // no type casting
          result[key] = getenv(value[0], value[1]); // dirty, when case 1: value[1] is undefined
        break;
        case 3: // with typecast
          result[key] = getenv[value[2]](value[0], value[1]);
          break;
        default: // wtf?
          throw('getenv.multi(): invalid spec');
          break;
      }
    } else { // value or throw
      result[key] = getenv(value);
    }
  }
  return result;
};

getenv.disableFallbacks = function() {
  fallbacksDisabled = true;
};

getenv.enableFallbacks = function() {
  fallbacksDisabled = false;
};

module.exports = getenv;
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['plugins/nlp/nlp.js']=function (module,exports,global,process){
var nlp = Require('plugins/nlp/compromise');
nlp.extend(Require('plugins/nlp/compromise-adjectives'));
nlp.extend(Require('plugins/nlp/compromise-dates'));
nlp.extend(Require('plugins/nlp/compromise-numbers'));
nlp.extend(Require('plugins/nlp/compromise-sentences'));
var efrt = Require('plugins/nlp/efrt');
nlp.lexer = efrt.lexer;
nlp.pack = efrt.pack;
nlp.unpack = efrt.unpack;
nlp.version = '1.2.2';
module.exports=nlp;
};
BundleModuleCode['plugins/nlp/compromise']=function (module,exports,global,process){
/* compromise 13.5.0X003 MIT/blab */
/* https://github.com/spencermountain/compromise */

/* polyfills */
Object.addProperty(Array,'findIndex', function(callback) {
  if (this === null) {
    throw new TypeError('Array.prototype.findIndex called on null or undefined');
  } else if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }
  var list = Object(this);
  // Makes sures is always has an positive integer as length.
  var length = list.length >>> 0;
  var thisArg = arguments[1];
  for (var i = 0; i < length; i++) {
    if ( callback.call(thisArg, list[i], i, list) ) {
      return i;
    }
  }
  return -1;
});

/* NLP module */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.nlp = factory());
}(this, (function () { 'use strict';
  function similar_text (first, second, percent) {
    // http://kevin.vanzonneveld.net
    // +   original by: Rafa Kukawski (http://blog.kukawski.pl)
    // +   bugfixed by: Chris McMacken
    // +   added percent parameter by: Markus Padourek (taken from http://www.kevinhq.com/2012/06/php-similartext-function-in-javascript_16.html)
    // *     example 1: similar_text('Hello World!', 'Hello phpjs!');
    // *     returns 1: 7
    // *     example 2: similar_text('Hello World!', null);
    // *     returns 2: 0
    // *     example 3: similar_text('Hello World!', null, 1);
    // *     returns 3: 58.33
    if (first === null || second === null || typeof first === 'undefined' || typeof second === 'undefined') {
      return 0;
    }

    first += '';
    second += '';

    var pos1 = 0,
      pos2 = 0,
      max = 0,
      firstLength = first.length,
      secondLength = second.length,
      p, q, l, sum;

    max = 0;

    for (p = 0; p < firstLength; p++) {
      for (q = 0; q < secondLength; q++) {
        for (l = 0;
        (p + l < firstLength) && (q + l < secondLength) && (first.charAt(p + l) === second.charAt(q + l)); l++);
        if (l > max) {
          max = l;
          pos1 = p;
          pos2 = q;
        }
      }
    }

    sum = max;

    if (sum) {
      if (pos1 && pos2) {
        sum += similar_text(first.substr(0, pos2), second.substr(0, pos2));
      }

      if ((pos1 + max < firstLength) && (pos2 + max < secondLength)) {
        sum += similar_text(first.substr(pos1 + max, firstLength - pos1 - max), second.substr(pos2 + max, secondLength - pos2 - max));
      }
    }

    if (!percent) {
      return sum;
    } else {
      return (sum * 200) / (firstLength + secondLength);
    }
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  //this is a not-well-thought-out way to reduce our dependence on `object===object` stuff
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split(''); //generates a unique id for this term

  function makeId(str) {
    str = str || '_';
    var text = str + '-';

    for (var i = 0; i < 7; i++) {
      text += chars[Math.floor(Math.random() * chars.length)];
    }

    return text;
  }

  var _id = makeId;

  //a hugely-ignorant, and widely subjective transliteration of latin, cryllic, greek unicode characters to english ascii.
  //approximate visual (not semantic or phonetic) relationship between unicode and ascii characters
  //http://en.wikipedia.org/wiki/List_of_Unicode_characters
  //https://docs.google.com/spreadsheet/ccc?key=0Ah46z755j7cVdFRDM1A2YVpwa1ZYWlpJM2pQZ003M0E
  var compact = {
    '!': '',
    '?': '',
    '"': '"',
    "'": '',
    '-': '',
    a: '',
    b: '',
    c: '',
    d: '',
    e: '',
    f: '',
    g: '',
    h: '',
    I: '',
    i: '',
    j: '',
    k: '',
    l: '',
    m: '',
    n: '',
    o: '',
    p: '',
    q: '',
    r: '',
    s: '',
    t: '',
    u: '',
    v: '',
    w: '',
    x: '',
    y: '',
    z: ''
  }; //decompress data into two hashes

  var unicode = {};
  Object.keys(compact).forEach(function (k) {
    compact[k].split('').forEach(function (s) {
      unicode[s] = k;
    });
  });

  var killUnicode = function killUnicode(str) {
    var chars = str.split('');
    chars.forEach(function (s, i) {
      if (unicode[s]) {
        chars[i] = unicode[s];
      }
    });
    return chars.join('');
  };

  var unicode_1 = killUnicode; // console.log(killUnicode('bjk'));

  var periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
  var oneLetterAcronym = /^[A-Z]\.,?$/;
  var noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
  var lowerCaseAcronym = /([a-z]\.){2,}[a-z]\.?$/;

  var isAcronym = function isAcronym(str) {
    //like N.D.A
    if (periodAcronym.test(str) === true) {
      return true;
    } //like c.e.o


    if (lowerCaseAcronym.test(str) === true) {
      return true;
    } //like 'F.'


    if (oneLetterAcronym.test(str) === true) {
      return true;
    } //like NDA


    if (noPeriodAcronym.test(str) === true) {
      return true;
    }

    return false;
  };

  var isAcronym_1 = isAcronym;

  var hasSlash = /[a-z\u00C0-\u00FF] ?\/ ?[a-z\u00C0-\u00FF]/;
  /** some basic operations on a string to reduce noise */

  var clean = function clean(str) {
    str = str || '';
    str = str.toLowerCase();
    str = str.trim();
    var original = str; //(very) rough ASCII transliteration -  bjrk -> bjork

    str = unicode_1(str); //rough handling of slashes - 'see/saw'

    if (hasSlash.test(str) === true) {
      str = str.replace(/\/.*/, '');
    } //#tags, @mentions


    str = str.replace(/^[#@]/, ''); //punctuation

    str = str.replace(/[,;.!?]+$/, ''); // coerce single curly quotes

    str = str.replace(/[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]+/g, "'"); // coerce double curly quotes

    str = str.replace(/[\u0022\u00AB\u00BB\u201C\u201D\u201E\u201F\u2033\u2034\u2036\u2037\u2E42\u301D\u301E\u301F\uFF02]+/g, '"'); //coerce Unicode ellipses

    str = str.replace(/\u2026/g, '...'); //en-dash

    str = str.replace(/\u2013/g, '-'); //lookin'->looking (make it easier for conjugation)

    str = str.replace(/([aeiou][ktrp])in$/, '$1ing'); //turn re-enactment to reenactment

    if (/^(re|un)-?[^aeiou]./.test(str) === true) {
      str = str.replace('-', '');
    } //strip leading & trailing grammatical punctuation


    if (/^[:;]/.test(str) === false) {
      str = str.replace(/\.{3,}$/g, '');
      str = str.replace(/[",\.!:;\?\)]+$/g, '');
      str = str.replace(/^['"\(]+/g, '');
    } //do this again..


    str = str.trim(); //oh shucks,

    if (str === '') {
      str = original;
    } //compact acronyms


    if (isAcronym_1(str)) {
      str = str.replace(/\./g, '');
    } //nice-numbers


    str = str.replace(/([0-9]),([0-9])/g, '$1$2');
    return str;
  };

  var clean_1 = clean; // console.log(normalize('Dr. V Cooper'));

  /** reduced is one step further than clean */
  var reduced = function reduced(str) {
    // remove apostrophes
    str = str.replace(/[']s$/, '');
    str = str.replace(/s[']$/, 's');
    return str;
  };

  var reduce = reduced;

  //all punctuation marks, from https://en.wikipedia.org/wiki/Punctuation
  //we have slightly different rules for start/end - like #hashtags.

  var startings = /^[ \n\t\.'\[\](){}:,!.\-?;\/&*^%+=~|\u0022|\uFF02|\u0027|\u201C|\u2018|\u201F|\u201B|\u201E|\u2E42|\u201A|\u00AB|\u2039|\u2035|\u2036|\u2037|\u301D|\u0060|\u301F]+/;
  var endings = /[ \n\t\.'\[\](){}:,!.\-?;\/&*@^#+=~|\u0022|\uFF02|\u0027|\u201D|\u2019|\u201D|\u2019|\u201D|\u201D|\u2019|\u00BB|\u203A|\u2032|\u2033|\u2034|\u301E|\u00B4|\u301E]+$/; //money = $

  var hasSlash$1 = /\//;
  var hasApostrophe = /[']/;
  var hasAcronym = /^[a-z]\.([a-z]\.)+/i;
  var minusNumber = /^[-+\.][0-9]/;
  /** turn given text into a parsed-up object
   * seperate the 'meat' of the word from the whitespace+punctuation
   */

  var parseTerm = function parseTerm(str) {
    var original = str;
    var pre = '';
    var post = '';
    str = str.replace(startings, function (found) {
      pre = found; // support '-40'

      if ((pre === '-' || pre === '+' || pre === '.') && minusNumber.test(str)) {
        pre = '';
        return found;
      }

      return '';
    });
    str = str.replace(endings, function (found) {
      post = found; // keep s-apostrophe - "flanders'" or "chillin'"

      if (hasApostrophe.test(found) && /[sn][']$/.test(original) && hasApostrophe.test(pre) === false) {
        post = post.replace(hasApostrophe, '');
        return "'";
      } //keep end-period in acronym


      if (hasAcronym.test(str) === true) {
        post = post.replace(/\./, '');
        return '.';
      }

      return '';
    }); //we went too far..

    if (str === '') {
      // do a very mild parse, and hope for the best.
      original = original.replace(/ *$/, function (after) {
        post = after || '';
        return '';
      });
      str = original;
      pre = '';
      post = post;
    } // create the various forms of our text,


    var clean = clean_1(str);
    var parsed = {
      text: str,
      clean: clean,
      reduced: reduce(clean),
      pre: pre,
      post: post
    }; // support aliases for slashes

    if (hasSlash$1.test(str)) {
      str.split(hasSlash$1).forEach(function (word) {
        parsed.alias = parsed.alias || {};
        parsed.alias[word.trim()] = true;
      });
    }

    return parsed;
  };

  var parse = parseTerm;

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var _01Case = createCommonjsModule(function (module, exports) {
    var titleCase = /^[A-Z][a-z'\u00C0-\u00FF]/;
    var upperCase = /^[A-Z]+s?$/;
    /** convert all text to uppercase */

    exports.toUpperCase = function () {
      this.text = this.text.toUpperCase();
      return this;
    };
    /** convert all text to lowercase */


    exports.toLowerCase = function () {
      this.text = this.text.toLowerCase();
      return this;
    };
    /** only set the first letter to uppercase
     * leave any existing uppercase alone
     */


    exports.toTitleCase = function () {
      this.text = this.text.replace(/^ *[a-z\u00C0-\u00FF]/, function (x) {
        return x.toUpperCase();
      }); //support unicode?

      return this;
    };
    /** if all letters are uppercase */


    exports.isUpperCase = function () {
      return upperCase.test(this.text);
    };
    /** if the first letter is uppercase, and the rest are lowercase */


    exports.isTitleCase = function () {
      return titleCase.test(this.text);
    };

    exports.titleCase = exports.isTitleCase;
  });

  var _02Punctuation = createCommonjsModule(function (module, exports) {
    // these methods are called with '@hasComma' in the match syntax
    // various unicode quotation-mark formats
    var startQuote = /(\u0022|\uFF02|\u0027|\u201C|\u2018|\u201F|\u201B|\u201E|\u2E42|\u201A|\u00AB|\u2039|\u2035|\u2036|\u2037|\u301D|\u0060|\u301F)/;
    var endQuote = /(\u0022|\uFF02|\u0027|\u201D|\u2019|\u201D|\u2019|\u201D|\u201D|\u2019|\u00BB|\u203A|\u2032|\u2033|\u2034|\u301E|\u00B4|\u301E)/;
    /** search the term's 'post' punctuation  */

    exports.hasPost = function (punct) {
      return this.post.indexOf(punct) !== -1;
    };
    /** search the term's 'pre' punctuation  */


    exports.hasPre = function (punct) {
      return this.pre.indexOf(punct) !== -1;
    };
    /** does it have a quotation symbol?  */


    exports.hasQuote = function () {
      return startQuote.test(this.pre) || endQuote.test(this.post);
    };

    exports.hasQuotation = exports.hasQuote;
    /** does it have a comma?  */

    exports.hasComma = function () {
      return this.hasPost(',');
    };
    /** does it end in a period? */


    exports.hasPeriod = function () {
      return this.hasPost('.') === true && this.hasPost('...') === false;
    };
    /** does it end in an exclamation */


    exports.hasExclamation = function () {
      return this.hasPost('!');
    };
    /** does it end with a question mark? */


    exports.hasQuestionMark = function () {
      return this.hasPost('?') || this.hasPost('');
    };
    /** is there a ... at the end? */


    exports.hasEllipses = function () {
      return this.hasPost('..') || this.hasPost('') || this.hasPre('..') || this.hasPre('');
    };
    /** is there a semicolon after this word? */


    exports.hasSemicolon = function () {
      return this.hasPost(';');
    };
    /** is there a slash '/' in this word? */


    exports.hasSlash = function () {
      var slash = /\//;
      return slash.test(this.text);
    };
    /** a hyphen connects two words like-this */


    exports.hasHyphen = function () {
      var hyphen = /(-||)/;
      return hyphen.test(this.post) || hyphen.test(this.pre);
    };
    /** a dash separates words - like that */


    exports.hasDash = function () {
      var hyphen = / (-||) /;
      return hyphen.test(this.post) || hyphen.test(this.pre);
    };
    /** is it multiple words combinded */


    exports.hasContraction = function () {
      return Boolean(this.implicit);
    };
    /** try to sensibly put this punctuation mark into the term */


    exports.addPunctuation = function (punct) {
      // dont add doubles
      if (punct === ',' || punct === ';') {
        this.post = this.post.replace(punct, '');
      }

      this.post = punct + this.post;
      return this;
    };
  });

  //declare it up here
  var wrapMatch = function wrapMatch() {};
  /** ignore optional/greedy logic, straight-up term match*/


  var doesMatch = function doesMatch(t, reg, index, length) {
    // support id matches
    if (reg.id === t.id) {
      return true;
    } // support '.'


    if (reg.anything === true) {
      return true;
    } // support '^' (in parentheses)


    if (reg.start === true && index !== 0) {
      return false;
    } // support '$' (in parentheses)


    if (reg.end === true && index !== length - 1) {
      return false;
    } //support a text match


    if (reg.word !== undefined) {
      //match contractions
      if (t.implicit !== null && t.implicit === reg.word) {
        return true;
      } // term aliases for slashes and things


      if (t.alias !== undefined && t.alias.hasOwnProperty(reg.word)) {
        return true;
      } // support ~ match


      if (reg.soft === true && reg.word === t.root) {
        return true;
      } //match either .clean or .text


      return reg.word === t.clean || reg.word === t.text || reg.word === t.reduced;
    } //support #Tag


    if (reg.tag !== undefined) {
      return t.tags[reg.tag] === true;
    } //support @method


    if (reg.method !== undefined) {
      if (typeof t[reg.method] === 'function' && t[reg.method]() === true) {
        return true;
      }

      return false;
    } //support /reg/


    if (reg.regex !== undefined) {
      return reg.regex.test(t.clean);
    } // support optimized (one|two)


    if (reg.oneOf !== undefined) {
      return reg.oneOf.hasOwnProperty(t.reduced) || reg.oneOf.hasOwnProperty(t.text);
    } //support (one|two)


    if (reg.choices !== undefined) {
      // try to support && operator
      if (reg.operator === 'and') {
        // must match them all
        return reg.choices.every(function (r) {
          return wrapMatch(t, r, index, length);
        });
      } // or must match one


      return reg.choices.some(function (r) {
        return wrapMatch(t, r, index, length);
      });
    }

    return false;
  }; // wrap result for !negative match logic


  wrapMatch = function wrapMatch(t, reg, index, length) {
    var result = doesMatch(t, reg, index, length);

    if (reg.negative === true) {
      return !result;
    }

    return result;
  };

  var _doesMatch = wrapMatch;

  var boring = {};
  /** check a match object against this term */

  var doesMatch_1 = function doesMatch_1(reg, index, length) {
    return _doesMatch(this, reg, index, length);
  };
  /** does this term look like an acronym? */


  var isAcronym_1$1 = function isAcronym_1$1() {
    return isAcronym_1(this.text);
  };
  /** is this term implied by a contraction? */


  var isImplicit = function isImplicit() {
    return this.text === '' && Boolean(this.implicit);
  };
  /** does the term have at least one good tag? */


  var isKnown = function isKnown() {
    return Object.keys(this.tags).some(function (t) {
      return boring[t] !== true;
    });
  };
  /** cache the root property of the term */


  var setRoot = function setRoot(world) {
    var transform = world.transforms;
    var str = this.implicit || this.clean;

    if (this.tags.Plural) {
      str = transform.toSingular(str, world);
    }

    if (this.tags.Verb && !this.tags.Negative && !this.tags.Infinitive) {
      var tense = null;

      if (this.tags.PastTense) {
        tense = 'PastTense';
      } else if (this.tags.Gerund) {
        tense = 'Gerund';
      } else if (this.tags.PresentTense) {
        tense = 'PresentTense';
      } else if (this.tags.Participle) {
        tense = 'Participle';
      } else if (this.tags.Actor) {
        tense = 'Actor';
      }

      str = transform.toInfinitive(str, world, tense);
    }

    this.root = str;
  };

  var _03Misc = {
    doesMatch: doesMatch_1,
    isAcronym: isAcronym_1$1,
    isImplicit: isImplicit,
    isKnown: isKnown,
    setRoot: setRoot
  };

  var hasSpace = /[\s-]/;
  var isUpperCase = /^[A-Z-]+$/; // const titleCase = str => {
  //   return str.charAt(0).toUpperCase() + str.substr(1)
  // }

  /** return various text formats of this term */

  var textOut = function textOut(options, showPre, showPost) {
    options = options || {};
    var word = this.text;
    var before = this.pre;
    var after = this.post; // -word-

    if (options.reduced === true) {
      word = this.reduced || '';
    }

    if (options.root === true) {
      word = this.root || '';
    }

    if (options.implicit === true && this.implicit) {
      word = this.implicit || '';
    }

    if (options.normal === true) {
      word = this.clean || this.text || '';
    }

    if (options.root === true) {
      word = this.root || this.reduced || '';
    }

    if (options.unicode === true) {
      word = unicode_1(word);
    } // cleanup case


    if (options.titlecase === true) {
      if (this.tags.ProperNoun && !this.titleCase()) ; else if (this.tags.Acronym) {
        word = word.toUpperCase(); //uppercase acronyms
      } else if (isUpperCase.test(word) && !this.tags.Acronym) {
        // lowercase everything else
        word = word.toLowerCase();
      }
    }

    if (options.lowercase === true) {
      word = word.toLowerCase();
    } // remove the '.'s from 'F.B.I.' (safely)


    if (options.acronyms === true && this.tags.Acronym) {
      word = word.replace(/\./g, '');
    } // -before/after-


    if (options.whitespace === true || options.root === true) {
      before = '';
      after = ' ';

      if ((hasSpace.test(this.post) === false || options.last) && !this.implicit) {
        after = '';
      }
    }

    if (options.punctuation === true && !options.root) {
      //normalized end punctuation
      if (this.hasPost('.') === true) {
        after = '.' + after;
      } else if (this.hasPost('?') === true) {
        after = '?' + after;
      } else if (this.hasPost('!') === true) {
        after = '!' + after;
      } else if (this.hasPost(',') === true) {
        after = ',' + after;
      } else if (this.hasEllipses() === true) {
        after = '...' + after;
      }
    }

    if (showPre !== true) {
      before = '';
    }

    if (showPost !== true) {
      // let keep = after.match(/\)/) || ''
      after = ''; //keep //after.replace(/[ .?!,]+/, '')
    } // remove the '.' from 'Mrs.' (safely)


    if (options.abbreviations === true && this.tags.Abbreviation) {
      after = after.replace(/^\./, '');
    }

    return before + word + after;
  };

  var _04Text = {
    textOut: textOut
  };

  var boringTags = {
    Auxiliary: 1,
    Possessive: 1
  };
  /** a subjective ranking of tags kinda tfidf-based */

  var rankTags = function rankTags(term, world) {
    var tags = Object.keys(term.tags);
    var tagSet = world.tags;
    tags = tags.sort(function (a, b) {
      //bury the tags we dont want
      if (boringTags[b] || !tagSet[b]) {
        return -1;
      } // unknown tags are interesting


      if (!tagSet[b]) {
        return 1;
      }

      if (!tagSet[a]) {
        return 0;
      } // then sort by #of parent tags (most-specific tags first)


      if (tagSet[a].lineage.length > tagSet[b].lineage.length) {
        return 1;
      }

      if (tagSet[a].isA.length > tagSet[b].isA.length) {
        return -1;
      }

      return 0;
    });
    return tags;
  };

  var _bestTag = rankTags;

  var jsonDefault = {
    text: true,
    tags: true,
    implicit: true,
    whitespace: true,
    clean: false,
    id: false,
    index: false,
    offset: false,
    bestTag: false
  };
  /** return various metadata for this term */

  var json = function json(options, world) {
    options = options || {};
    options = Object.assign({}, jsonDefault, options);
    var result = {}; // default on

    if (options.text) {
      result.text = this.text;
    }

    if (options.normal) {
      result.normal = this.normal;
    }

    if (options.tags) {
      result.tags = Object.keys(this.tags);
    } // default off


    if (options.clean) {
      result.clean = this.clean;
    }

    if (options.id || options.offset) {
      result.id = this.id;
    }

    if (options.implicit && this.implicit !== null) {
      result.implicit = this.implicit;
    }

    if (options.whitespace) {
      result.pre = this.pre;
      result.post = this.post;
    }

    if (options.bestTag) {
      result.bestTag = _bestTag(this, world)[0];
    }

    return result;
  };

  var _05Json = {
    json: json
  };

  var methods = Object.assign({}, _01Case, _02Punctuation, _03Misc, _04Text, _05Json);

  function isClientSide() {
    return typeof window !== 'undefined' && window.document;
  }
  /** add spaces at the end */


  var padEnd = function padEnd(str, width) {
    str = str.toString();

    while (str.length < width) {
      str += ' ';
    }

    return str;
  };
  /** output for verbose-mode */


  var logTag = function logTag(t, tag, reason) {
    if (isClientSide()) {
      console.log('%c' + padEnd(t.clean, 3) + '  + ' + tag + ' ', 'color: #6accb2;');
      return;
    } //server-side


    var log = '\x1b[33m' + padEnd(t.clean, 15) + '\x1b[0m + \x1b[32m' + tag + '\x1b[0m ';

    if (reason) {
      log = padEnd(log, 35) + ' ' + reason + '';
    }

    console.log(log);
  };
  /** output for verbose mode  */


  var logUntag = function logUntag(t, tag, reason) {
    if (isClientSide()) {
      console.log('%c' + padEnd(t.clean, 3) + '  - ' + tag + ' ', 'color: #AB5850;');
      return;
    } //server-side


    var log = '\x1b[33m' + padEnd(t.clean, 3) + ' \x1b[31m - #' + tag + '\x1b[0m ';

    if (reason) {
      log = padEnd(log, 35) + ' ' + reason;
    }

    console.log(log);
  };

  var isArray = function isArray(arr) {
    return Object.prototype.toString.call(arr) === '[object Array]';
  };

  var titleCase = function titleCase(str) {
    return str.charAt(0).toUpperCase() + str.substr(1);
  };

  var fns = {
    logTag: logTag,
    logUntag: logUntag,
    isArray: isArray,
    titleCase: titleCase
  };

  /** add a tag, and its descendents, to a term */

  var addTag = function addTag(t, tag, reason, world) {
    var tagset = world.tags; //support '.' or '-' notation for skipping the tag

    if (tag === '' || tag === '.' || tag === '-') {
      return;
    }

    if (tag[0] === '#') {
      tag = tag.replace(/^#/, '');
    }

    tag = fns.titleCase(tag); //if we already got this one

    if (t.tags[tag] === true) {
      return;
    } // log it?


    var isVerbose = world.isVerbose();

    if (isVerbose === true) {
      fns.logTag(t, tag, reason);
    } //add tag


    t.tags[tag] = true; //whee!
    //check tagset for any additional things to do...

    if (tagset.hasOwnProperty(tag) === true) {
      //add parent Tags
      tagset[tag].isA.forEach(function (down) {
        t.tags[down] = true;

        if (isVerbose === true) {
          fns.logTag(t, ' ' + down);
        }
      }); //remove any contrary tags

      t.unTag(tagset[tag].notA, '', world);
    }
  };
  /** support an array of tags */


  var addTags = function addTags(term, tags, reason, world) {
    if (typeof tags !== 'string') {
      for (var i = 0; i < tags.length; i++) {
        addTag(term, tags[i], reason, world);
      } // tags.forEach(tag => addTag(term, tag, reason, world))

    } else {
      addTag(term, tags, reason, world);
    }
  };

  var add = addTags;

  var lowerCase = /^[a-z]/;

  var titleCase$1 = function titleCase(str) {
    return str.charAt(0).toUpperCase() + str.substr(1);
  };
  /** remove this tag, and its descentents from the term */


  var unTag = function unTag(t, tag, reason, world) {
    var isVerbose = world.isVerbose(); //support '*' for removing all tags

    if (tag === '*') {
      t.tags = {};
      return t;
    }

    tag = tag.replace(/^#/, '');

    if (lowerCase.test(tag) === true) {
      tag = titleCase$1(tag);
    } // remove the tag


    if (t.tags[tag] === true) {
      delete t.tags[tag]; //log in verbose-mode

      if (isVerbose === true) {
        fns.logUntag(t, tag, reason);
      }
    } //delete downstream tags too


    var tagset = world.tags;

    if (tagset[tag]) {
      var lineage = tagset[tag].lineage;

      for (var i = 0; i < lineage.length; i++) {
        if (t.tags[lineage[i]] === true) {
          delete t.tags[lineage[i]];

          if (isVerbose === true) {
            fns.logUntag(t, ' - ' + lineage[i]);
          }
        }
      }
    }

    return t;
  }; //handle an array of tags


  var untagAll = function untagAll(term, tags, reason, world) {
    if (typeof tags !== 'string' && tags) {
      for (var i = 0; i < tags.length; i++) {
        unTag(term, tags[i], reason, world);
      }

      return;
    }

    unTag(term, tags, reason, world);
  };

  var unTag_1 = untagAll;

  var canBe = function canBe(term, tag, world) {
    var tagset = world.tags; // cleanup tag

    if (tag[0] === '#') {
      tag = tag.replace(/^#/, '');
    } //fail-fast


    if (tagset[tag] === undefined) {
      return true;
    } //loop through tag's contradictory tags


    var enemies = tagset[tag].notA || [];

    for (var i = 0; i < enemies.length; i++) {
      if (term.tags[enemies[i]] === true) {
        return false;
      }
    }

    if (tagset[tag].isA !== undefined) {
      return canBe(term, tagset[tag].isA, world); //recursive
    }

    return true;
  };

  var canBe_1 = canBe;

  /** add a tag or tags, and their descendents to this term
   * @param  {string | string[]} tags - a tag or tags
   * @param {string?} [reason] a clue for debugging
   */

  var tag_1 = function tag_1(tags, reason, world) {
    add(this, tags, reason, world);
    return this;
  };
  /** only tag this term if it's consistent with it's current tags */


  var tagSafe = function tagSafe(tags, reason, world) {
    if (canBe_1(this, tags, world)) {
      add(this, tags, reason, world);
    }

    return this;
  };
  /** remove a tag or tags, and their descendents from this term
   * @param {string | string[]} tags  - a tag or tags
   * @param {string?} [reason] a clue for debugging
   */


  var unTag_1$1 = function unTag_1$1(tags, reason, world) {
    unTag_1(this, tags, reason, world);
    return this;
  };
  /** is this tag consistent with the word's current tags?
   * @param {string | string[]} tags - a tag or tags
   * @returns {boolean}
   */


  var canBe_1$1 = function canBe_1$1(tags, world) {
    return canBe_1(this, tags, world);
  };

  var tag = {
    tag: tag_1,
    tagSafe: tagSafe,
    unTag: unTag_1$1,
    canBe: canBe_1$1
  };

  var Term = /*#__PURE__*/function () {
    function Term() {
      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      _classCallCheck(this, Term);

      text = String(text);
      var obj = parse(text); // the various forms of our text

      this.text = obj.text || '';
      this.clean = obj.clean;
      this.reduced = obj.reduced;
      this.root =  null;
      this.implicit =  null;
      this.pre = obj.pre || '';
      this.post = obj.post || '';
      this.tags = {};
      this.prev = null;
      this.next = null;
      this.id = _id(obj.clean);
      this.isA = 'Term'; // easier than .constructor...
      // support alternative matches

      if (obj.alias) {
        this.alias = obj.alias;
      }
    }
    /** set the text of the Term to something else*/


    _createClass(Term, [{
      key: "set",
      value: function set(str) {
        var obj = parse(str);
        this.text = obj.text;
        this.clean = obj.clean;
        return this;
      }
    }]);

    return Term;
  }();
  /** create a deep-copy of this term */


  Term.prototype.clone = function () {
    var term = new Term(this.text);
    term.pre = this.pre;
    term.post = this.post;
    term.clean = this.clean;
    term.reduced = this.reduced;
    term.root = this.root;
    term.implicit = this.implicit;
    term.tags = Object.assign({}, this.tags); //use the old id, so it can be matched with .match(doc)
    // term.id = this.id

    return term;
  };

  Object.assign(Term.prototype, methods);
  Object.assign(Term.prototype, tag);
  var Term_1 = Term;

  /** return a flat array of Term objects */
  var terms = function terms(n) {
    if (this.length === 0) {
      return [];
    } // use cache, if it exists


    if (this.cache.terms) {
      if (n !== undefined) {
        return this.cache.terms[n];
      }

      return this.cache.terms;
    }

    var terms = [this.pool.get(this.start)];

    for (var i = 0; i < this.length - 1; i += 1) {
      var id = terms[terms.length - 1].next;

      if (id === null) {
        // throw new Error('linked-list broken')
        console.error("Compromise error: Linked list broken in phrase '" + this.start + "'");
        break;
      }

      var term = this.pool.get(id);
      terms.push(term); //return this one?

      if (n !== undefined && n === i) {
        return terms[n];
      }
    }

    if (n === undefined) {
      this.cache.terms = terms;
    }

    if (n !== undefined) {
      return terms[n];
    }

    return terms;
  };
  /** return a shallow or deep copy of this phrase  */


  var clone = function clone(isShallow) {
    var _this = this;

    if (isShallow) {
      var p = this.buildFrom(this.start, this.length);
      p.cache = this.cache;
      return p;
    } //how do we clone part of the pool?


    var terms = this.terms();
    var newTerms = terms.map(function (t) {
      return t.clone();
    }); // console.log(newTerms)
    //connect these new ids up

    newTerms.forEach(function (t, i) {
      //add it to the pool..
      _this.pool.add(t);

      if (newTerms[i + 1]) {
        t.next = newTerms[i + 1].id;
      }

      if (newTerms[i - 1]) {
        t.prev = newTerms[i - 1].id;
      }
    });
    return this.buildFrom(newTerms[0].id, newTerms.length);
  };
  /** return last term object */


  var lastTerm = function lastTerm() {
    var terms = this.terms();
    return terms[terms.length - 1];
  };
  /** quick lookup for a term id */


  var hasId = function hasId(wantId) {
    if (this.length === 0 || !wantId) {
      return false;
    }

    if (this.start === wantId) {
      return true;
    } // use cache, if available


    if (this.cache.terms) {
      var _terms = this.cache.terms;

      for (var i = 0; i < _terms.length; i++) {
        if (_terms[i].id === wantId) {
          return true;
        }
      }

      return false;
    } // otherwise, go through each term


    var lastId = this.start;

    for (var _i = 0; _i < this.length - 1; _i += 1) {
      var term = this.pool.get(lastId);

      if (term === undefined) {
        console.error("Compromise error: Linked list broken. Missing term '".concat(lastId, "' in phrase '").concat(this.start, "'\n")); // throw new Error('linked List error')

        return false;
      }

      if (term.next === wantId) {
        return true;
      }

      lastId = term.next;
    }

    return false;
  };
  /** how many seperate, non-empty words is it? */


  var wordCount = function wordCount() {
    return this.terms().filter(function (t) {
      return t.text !== '';
    }).length;
  };
  /** get the full-sentence this phrase belongs to */


  var fullSentence = function fullSentence() {
    var t = this.terms(0); //find first term in sentence

    while (t.prev) {
      t = this.pool.get(t.prev);
    }

    var start = t.id;
    var len = 1; //go to end of sentence

    while (t.next) {
      t = this.pool.get(t.next);
      len += 1;
    }

    return this.buildFrom(start, len);
  };

  var _01Utils = {
    terms: terms,
    clone: clone,
    lastTerm: lastTerm,
    hasId: hasId,
    wordCount: wordCount,
    fullSentence: fullSentence
  };

  var trimEnd = function trimEnd(str) {
    return str.replace(/ +$/, '');
  };
  /** produce output in the given format */


  var text = function text() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isFirst = arguments.length > 1 ? arguments[1] : undefined;
    var isLast = arguments.length > 2 ? arguments[2] : undefined;

    if (typeof options === 'string') {
      if (options === 'normal') {
        options = {
          whitespace: true,
          unicode: true,
          lowercase: true,
          punctuation: true,
          acronyms: true,
          abbreviations: true,
          implicit: true,
          normal: true
        };
      } else if (options === 'clean') {
        options = {
          titlecase: false,
          lowercase: true,
          punctuation: true,
          whitespace: true,
          unicode: true,
          implicit: true
        };
      } else if (options === 'reduced') {
        options = {
          titlecase: false,
          lowercase: true,
          punctuation: false,
          //FIXME: reversed?
          whitespace: true,
          unicode: true,
          implicit: true,
          reduced: true
        };
      } else if (options === 'root') {
        options = {
          titlecase: false,
          lowercase: true,
          punctuation: true,
          whitespace: true,
          unicode: true,
          implicit: true,
          root: true
        };
      } else {
        options = {};
      }
    }

    var terms = this.terms(); //this this phrase a complete sentence?

    var isFull = false;

    if (terms[0] && terms[0].prev === null && terms[terms.length - 1].next === null) {
      isFull = true;
    }

    var text = terms.reduce(function (str, t, i) {
      options.last = isLast && i === terms.length - 1;
      var showPre = true;
      var showPost = true;

      if (isFull === false) {
        // dont show beginning whitespace
        if (i === 0 && isFirst) {
          showPre = false;
        } // dont show end-whitespace


        if (i === terms.length - 1 && isLast) {
          showPost = false;
        }
      }

      var txt = t.textOut(options, showPre, showPost); // if (options.titlecase && i === 0) {
      // txt = titleCase(txt)
      // }

      return str + txt;
    }, ''); //full-phrases show punctuation, but not whitespace

    if (isFull === true && isLast) {
      text = trimEnd(text);
    }

    if (options.trim === true) {
      text = text.trim();
    }

    return text;
  };

  var _02Text = {
    text: text
  };

  /** remove start and end whitespace */
  var trim = function trim() {
    var terms = this.terms();

    if (terms.length > 0) {
      //trim starting
      terms[0].pre = terms[0].pre.replace(/^\s+/, ''); //trim ending

      var lastTerm = terms[terms.length - 1];
      lastTerm.post = lastTerm.post.replace(/\s+$/, '');
    }

    return this;
  };

  var _03Change = {
    trim: trim
  };

  var endOfSentence = /[.?!]\s*$/; // replacing a 'word.' with a 'word!'

  var combinePost = function combinePost(before, after) {
    //only transfer the whitespace
    if (endOfSentence.test(after)) {
      var whitespace = before.match(/\s*$/);
      return after + whitespace;
    }

    return before;
  }; //add whitespace to the start of the second bit


  var addWhitespace = function addWhitespace(beforeTerms, newTerms) {
    // add any existing pre-whitespace to beginning
    newTerms[0].pre = beforeTerms[0].pre;
    var lastTerm = beforeTerms[beforeTerms.length - 1]; //add any existing punctuation to end of our new terms

    var newTerm = newTerms[newTerms.length - 1];
    newTerm.post = combinePost(lastTerm.post, newTerm.post); // remove existing punctuation

    lastTerm.post = ''; //before [space]  - after

    if (lastTerm.post === '') {
      lastTerm.post += ' ';
    }
  }; //insert this segment into the linked-list


  var stitchIn = function stitchIn(beforeTerms, newTerms, pool) {
    var lastBefore = beforeTerms[beforeTerms.length - 1];
    var lastNew = newTerms[newTerms.length - 1];
    var afterId = lastBefore.next; //connect ours in (main  newPhrase)

    lastBefore.next = newTerms[0].id; //stich the end in  (newPhrase  after)

    lastNew.next = afterId; //do it backwards, too

    if (afterId) {
      // newPhrase  after
      var afterTerm = pool.get(afterId);
      afterTerm.prev = lastNew.id;
    } // before  newPhrase


    var beforeId = beforeTerms[0].id;

    if (beforeId) {
      var newTerm = newTerms[0];
      newTerm.prev = beforeId;
    }
  }; // avoid stretching a phrase twice.


  var unique = function unique(list) {
    return list.filter(function (o, i) {
      return list.indexOf(o) === i;
    });
  }; //append one phrase onto another.


  var appendPhrase = function appendPhrase(before, newPhrase, doc) {
    var beforeTerms = before.terms();
    var newTerms = newPhrase.terms(); //spruce-up the whitespace issues

    addWhitespace(beforeTerms, newTerms); //insert this segment into the linked-list

    stitchIn(beforeTerms, newTerms, before.pool); // stretch!
    // make each effected phrase longer

    var toStretch = [before];
    var hasId = before.start;
    var docs = [doc];
    docs = docs.concat(doc.parents()); // find them all!

    docs.forEach(function (parent) {
      // only the phrases that should change
      var shouldChange = parent.list.filter(function (p) {
        return p.hasId(hasId);
      });
      toStretch = toStretch.concat(shouldChange);
    }); // don't double-count a phrase

    toStretch = unique(toStretch);
    toStretch.forEach(function (p) {
      p.length += newPhrase.length;
    });
    before.cache = {};
    return before;
  };

  var append = appendPhrase;

  var hasSpace$1 = / /; //a new space needs to be added, either on the new phrase, or the old one
  // '[new] [old]'   -or-   '[old] [new] [old]'

  var addWhitespace$1 = function addWhitespace(newTerms) {
    //add a space before our new text?
    // add a space after our text
    var lastTerm = newTerms[newTerms.length - 1];

    if (hasSpace$1.test(lastTerm.post) === false) {
      lastTerm.post += ' ';
    }

    return;
  }; //insert this segment into the linked-list


  var stitchIn$1 = function stitchIn(main, newPhrase, newTerms) {
    // [newPhrase]  [main]
    var lastTerm = newTerms[newTerms.length - 1];
    lastTerm.next = main.start; // [before]  [main]

    var pool = main.pool;
    var start = pool.get(main.start);

    if (start.prev) {
      var before = pool.get(start.prev);
      before.next = newPhrase.start;
    } //do it backwards, too
    // before  newPhrase


    newTerms[0].prev = main.terms(0).prev; // newPhrase  main

    main.terms(0).prev = lastTerm.id;
  };

  var unique$1 = function unique(list) {
    return list.filter(function (o, i) {
      return list.indexOf(o) === i;
    });
  }; //append one phrase onto another


  var joinPhrase = function joinPhrase(original, newPhrase, doc) {
    var starterId = original.start;
    var newTerms = newPhrase.terms(); //spruce-up the whitespace issues

    addWhitespace$1(newTerms); //insert this segment into the linked-list

    stitchIn$1(original, newPhrase, newTerms); //increase the length of our phrases

    var toStretch = [original];
    var docs = [doc];
    docs = docs.concat(doc.parents());
    docs.forEach(function (d) {
      // only the phrases that should change
      var shouldChange = d.list.filter(function (p) {
        return p.hasId(starterId) || p.hasId(newPhrase.start);
      });
      toStretch = toStretch.concat(shouldChange);
    }); // don't double-count

    toStretch = unique$1(toStretch); // stretch these phrases

    toStretch.forEach(function (p) {
      p.length += newPhrase.length; // change the start too, if necessary

      if (p.start === starterId) {
        p.start = newPhrase.start;
      }

      p.cache = {};
    });
    return original;
  };

  var prepend = joinPhrase;

  //recursively decrease the length of all the parent phrases
  var shrinkAll = function shrinkAll(doc, id, deleteLength, after) {
    var arr = doc.parents();
    arr.push(doc);
    arr.forEach(function (d) {
      //find our phrase to shrink
      var phrase = d.list.find(function (p) {
        return p.hasId(id);
      });

      if (!phrase) {
        return;
      }

      phrase.length -= deleteLength; // does it start with this soon-removed word?

      if (phrase.start === id) {
        phrase.start = after.id;
      }

      phrase.cache = {};
    }); // cleanup empty phrase objects

    doc.list = doc.list.filter(function (p) {
      if (!p.start || !p.length) {
        return false;
      }

      return true;
    });
  };
  /** wrap the linked-list around these terms
   * so they don't appear any more
   */


  var deletePhrase = function deletePhrase(phrase, doc) {
    var pool = doc.pool();
    var terms = phrase.terms(); //grab both sides of the chain,

    var prev = pool.get(terms[0].prev) || {};
    var after = pool.get(terms[terms.length - 1].next) || {};

    if (terms[0].implicit && prev.implicit) {
      prev.set(prev.implicit);
      prev.post += ' ';
    } // //first, change phrase lengths


    shrinkAll(doc, phrase.start, phrase.length, after); // connect [prev]->[after]

    if (prev) {
      prev.next = after.id;
    } // connect [prev]<-[after]


    if (after) {
      after.prev = prev.id;
    } // lastly, actually delete the terms from the pool?
    // for (let i = 0; i < terms.length; i++) {
    //   pool.remove(terms[i].id)
    // }

  };

  var _delete = deletePhrase;

  /** put this text at the end */

  var append_1 = function append_1(newPhrase, doc) {
    append(this, newPhrase, doc);
    return this;
  };
  /** add this text to the beginning */


  var prepend_1 = function prepend_1(newPhrase, doc) {
    prepend(this, newPhrase, doc);
    return this;
  };

  var _delete$1 = function _delete$1(doc) {
    _delete(this, doc);
    return this;
  }; // stich-in newPhrase, stretch 'doc' + parents


  var replace = function replace(newPhrase, doc) {
    //add it do the end
    var firstLength = this.length;
    append(this, newPhrase, doc); //delete original terms

    var tmp = this.buildFrom(this.start, this.length);
    tmp.length = firstLength;
    _delete(tmp, doc);
  };
  /**
   * Turn this phrase object into 3 phrase objects
   */


  var splitOn = function splitOn(p) {
    var terms = this.terms();
    var result = {
      before: null,
      match: null,
      after: null
    };
    var index = terms.findIndex(function (t) {
      return t.id === p.start;
    });

    if (index === -1) {
      return result;
    } //make all three sections into phrase-objects


    var start = terms.slice(0, index);

    if (start.length > 0) {
      result.before = this.buildFrom(start[0].id, start.length);
    }

    var match = terms.slice(index, index + p.length);

    if (match.length > 0) {
      result.match = this.buildFrom(match[0].id, match.length);
    }

    var end = terms.slice(index + p.length, terms.length);

    if (end.length > 0) {
      result.after = this.buildFrom(end[0].id, end.length, this.pool);
    }

    return result;
  };

  var _04Insert = {
    append: append_1,
    prepend: prepend_1,
    "delete": _delete$1,
    replace: replace,
    splitOn: splitOn
  };

  /** return json metadata for this phrase */
  var json$1 = function json() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var world = arguments.length > 1 ? arguments[1] : undefined;
    var res = {}; // text data

    if (options.text) {
      res.text = this.text();
    }

    if (options.normal) {
      res.normal = this.text('normal');
    }

    if (options.clean) {
      res.clean = this.text('clean');
    }

    if (options.reduced) {
      res.reduced = this.text('reduced');
    }

    if (options.root) {
      res.root = this.text('root');
    }

    if (options.trim) {
      if (res.text) {
        res.text = res.text.trim();
      }

      if (res.normal) {
        res.normal = res.normal.trim();
      }

      if (res.reduced) {
        res.reduced = res.reduced.trim();
      }
    } // terms data


    if (options.terms) {
      if (options.terms === true) {
        options.terms = {};
      }

      res.terms = this.terms().map(function (t) {
        return t.json(options.terms, world);
      });
    }

    return res;
  };

  var _05Json$1 = {
    json: json$1
  };

  /** match any terms after this phrase */
  var lookAhead = function lookAhead(regs) {
    // if empty match string, return everything after
    if (!regs) {
      regs = '.*';
    }

    var pool = this.pool; // get a list of all terms preceding our start

    var terms = [];

    var getAfter = function getAfter(id) {
      var term = pool.get(id);

      if (!term) {
        return;
      }

      terms.push(term);

      if (term.prev) {
        getAfter(term.next); //recursion
      }
    };

    var all = this.terms();
    var lastTerm = all[all.length - 1];
    getAfter(lastTerm.next);

    if (terms.length === 0) {
      return [];
    } // got the terms, make a phrase from them


    var p = this.buildFrom(terms[0].id, terms.length);
    return p.match(regs);
  };
  /** match any terms before this phrase */


  var lookBehind = function lookBehind(regs) {
    // if empty match string, return everything before
    if (!regs) {
      regs = '.*';
    }

    var pool = this.pool; // get a list of all terms preceding our start

    var terms = [];

    var getBefore = function getBefore(id) {
      var term = pool.get(id);

      if (!term) {
        return;
      }

      terms.push(term);

      if (term.prev) {
        getBefore(term.prev); //recursion
      }
    };

    var term = pool.get(this.start);
    getBefore(term.prev);

    if (terms.length === 0) {
      return [];
    } // got the terms, make a phrase from them


    var p = this.buildFrom(terms[terms.length - 1].id, terms.length);
    return p.match(regs);
  };

  var _06Lookahead = {
    lookAhead: lookAhead,
    lookBehind: lookBehind
  };

  var methods$1 = Object.assign({}, _01Utils, _02Text, _03Change, _04Insert, _05Json$1, _06Lookahead);

  // try to avoid doing the match
  var failFast = function failFast(p, regs) {
    if (regs.length === 0) {
      return true;
    }

    for (var i = 0; i < regs.length; i += 1) {
      var reg = regs[i]; //logical quick-ones

      if (reg.optional !== true && reg.negative !== true) {
        //start/end impossibilites
        if (reg.start === true && i > 0) {
          return true;
        }
      } //this is not possible


      if (reg.anything === true && reg.negative === true) {
        return true;
      }
    }

    return false;
  };

  var _02FailFast = failFast;

  //found a match? it's greedy? keep going!

  var getGreedy = function getGreedy(terms, t, reg, until, index, length) {
    var start = t;

    for (; t < terms.length; t += 1) {
      //stop for next-reg match
      if (until && terms[t].doesMatch(until, index + t, length)) {
        return t;
      }

      var count = t - start + 1; // is it max-length now?

      if (reg.max !== undefined && count === reg.max) {
        return t;
      } //stop here


      if (terms[t].doesMatch(reg, index + t, length) === false) {
        // is it too short?
        if (reg.min !== undefined && count < reg.min) {
          return null;
        }

        return t;
      }
    }

    return t;
  }; //'unspecific greedy' is a weird situation.


  var greedyTo = function greedyTo(terms, t, nextReg, index, length) {
    //if there's no next one, just go off the end!
    if (!nextReg) {
      return terms.length;
    } //otherwise, we're looking for the next one


    for (; t < terms.length; t += 1) {
      if (terms[t].doesMatch(nextReg, index + t, length) === true) {
        return t;
      }
    } //guess it doesn't exist, then.


    return null;
  }; // get or create named group


  var getOrCreateGroup = function getOrCreateGroup(namedGroups, namedGroupId, terms, startIndex, group) {
    var g = namedGroups[namedGroupId];

    if (g) {
      return g;
    }

    var id = terms[startIndex].id;
    namedGroups[namedGroupId] = {
      group: String(group),
      start: id,
      length: 0
    };
    return namedGroups[namedGroupId];
  };
  /** tries to match a sequence of terms, starting from here */


  var tryHere = function tryHere(terms, regs, index, length) {
    var namedGroups = {};
    var previousGroupId = null;
    var t = 0; // we must satisfy each rule in 'regs'

    for (var r = 0; r < regs.length; r += 1) {
      var reg = regs[r]; // Check if this reg has a named capture group

      var isNamedGroup = typeof reg.named === 'string' || typeof reg.named === 'number';
      var namedGroupId = null; // Reuse previous capture group if same

      if (isNamedGroup) {
        var prev = regs[r - 1];

        if (prev && prev.named === reg.named && previousGroupId) {
          namedGroupId = previousGroupId;
        } else {
          namedGroupId = _id(reg.named);
          previousGroupId = namedGroupId;
        }
      } //should we fail here?


      if (!terms[t]) {
        //are all remaining regs optional?
        var hasNeeds = regs.slice(r).some(function (remain) {
          return !remain.optional;
        });

        if (hasNeeds === false) {
          break;
        } // have unmet needs


        return [false, null];
      } //support 'unspecific greedy' .* properly


      if (reg.anything === true && reg.greedy === true) {
        var skipto = greedyTo(terms, t, regs[r + 1], reg, index); // ensure it's long enough

        if (reg.min !== undefined && skipto - t < reg.min) {
          return [false, null];
        } // reduce it back, if it's too long


        if (reg.max !== undefined && skipto - t > reg.max) {
          t = t + reg.max;
          continue;
        }

        if (skipto === null) {
          return [false, null]; //couldn't find it
        } // is it really this easy?....


        if (isNamedGroup) {
          var g = getOrCreateGroup(namedGroups, namedGroupId, terms, t, reg.named); // Update group

          g.length = skipto - t;
        }

        t = skipto;
        continue;
      } //if it looks like a match, continue
      //we have a special case where an end-anchored greedy match may need to
      //start matching before the actual end; we do this by (temporarily!)
      //removing the "end" property from the matching token... since this is
      //very situation-specific, we *only* do this when we really need to.


      if (reg.anything === true || reg.end === true && reg.greedy === true && index + t < length - 1 && terms[t].doesMatch(Object.assign({}, reg, {
        end: false
      }), index + t, length) === true || terms[t].doesMatch(reg, index + t, length) === true) {
        var startAt = t; // okay, it was a match, but if it optional too,
        // we should check the next reg too, to skip it?

        if (reg.optional && regs[r + 1]) {
          // does the next reg match it too?
          if (terms[t].doesMatch(regs[r + 1], index + t, length) === true) {
            // but does the next reg match the next term??
            // only skip if it doesn't
            if (!terms[t + 1] || terms[t + 1].doesMatch(regs[r + 1], index + t, length) === false) {
              r += 1;
            }
          }
        } //advance to the next term!


        t += 1; //check any ending '$' flags

        if (reg.end === true) {
          //if this isn't the last term, refuse the match
          if (t !== terms.length && reg.greedy !== true) {
            return [false, null];
          }
        } //try keep it going!


        if (reg.greedy === true) {
          // for greedy checking, we no longer care about the reg.start
          // value, and leaving it can cause failures for anchored greedy
          // matches.  ditto for end-greedy matches: we need an earlier non-
          // ending match to succceed until we get to the actual end.
          t = getGreedy(terms, t, Object.assign({}, reg, {
            start: false,
            end: false
          }), regs[r + 1], index, length);

          if (t === null) {
            return [false, null]; //greedy was too short
          }

          if (reg.min && reg.min > t) {
            return [false, null]; //greedy was too short
          } // if this was also an end-anchor match, check to see we really
          // reached the end


          if (reg.end === true && index + t !== length) {
            return [false, null]; //greedy didn't reach the end
          }
        }

        if (isNamedGroup) {
          // Get or create capture group
          var _g = getOrCreateGroup(namedGroups, namedGroupId, terms, startAt, reg.named); // Update group - add greedy or increment length


          if (t > 1 && reg.greedy) {
            _g.length += t - startAt;
          } else {
            _g.length++;
          }
        }

        continue;
      } //bah, who cares, keep going


      if (reg.optional === true) {
        continue;
      } // should we skip-over an implicit word?


      if (terms[t].isImplicit() && regs[r - 1] && terms[t + 1]) {
        // does the next one match?
        if (terms[t + 1].doesMatch(reg, index + t, length)) {
          t += 2;
          continue;
        }
      } // console.log('   \n\n')


      return [false, null];
    } //return our result


    return [terms.slice(0, t), namedGroups];
  };

  var _03TryMatch = tryHere;

  var postProcess = function postProcess(terms, regs, matches) {
    if (!matches || matches.length === 0) {
      return matches;
    } // ensure end reg has the end term


    var atEnd = regs.some(function (r) {
      return r.end;
    });

    if (atEnd) {
      var lastTerm = terms[terms.length - 1];
      matches = matches.filter(function (_ref) {
        var arr = _ref.match;
        return arr.indexOf(lastTerm) !== -1;
      });
    }

    return matches;
  };

  var _04PostProcess = postProcess;

  /* break-down a match expression into this:
  {
    word:'',
    tag:'',
    regex:'',

    start:false,
    end:false,
    negative:false,
    anything:false,
    greedy:false,
    optional:false,

    named:'',
    choices:[],
  }
  */
  var hasMinMax = /\{([0-9]+,?[0-9]*)\}/;
  var andSign = /&&/;
  var captureName = new RegExp(/^<(\S+)>/);

  var titleCase$2 = function titleCase(str) {
    return str.charAt(0).toUpperCase() + str.substr(1);
  };

  var end = function end(str) {
    return str[str.length - 1];
  };

  var start = function start(str) {
    return str[0];
  };

  var stripStart = function stripStart(str) {
    return str.substr(1);
  };

  var stripEnd = function stripEnd(str) {
    return str.substr(0, str.length - 1);
  };

  var stripBoth = function stripBoth(str) {
    str = stripStart(str);
    str = stripEnd(str);
    return str;
  }; //


  var parseToken = function parseToken(w) {
    var obj = {}; //collect any flags (do it twice)

    for (var i = 0; i < 2; i += 1) {
      //end-flag
      if (end(w) === '$') {
        obj.end = true;
        w = stripEnd(w);
      } //front-flag


      if (start(w) === '^') {
        obj.start = true;
        w = stripStart(w);
      } //capture group (this one can span multiple-terms)


      if (start(w) === '[' || end(w) === ']') {
        obj.named = true;

        if (start(w) === '[') {
          obj.groupType = end(w) === ']' ? 'single' : 'start';
        } else {
          obj.groupType = 'end';
        }

        w = w.replace(/^\[/, '');
        w = w.replace(/\]$/, ''); // Use capture group name

        if (start(w) === '<') {
          var res = captureName.exec(w);

          if (res.length >= 2) {
            obj.named = res[1];
            w = w.replace(res[0], '');
          }
        }
      } //back-flags


      if (end(w) === '+') {
        obj.greedy = true;
        w = stripEnd(w);
      }

      if (w !== '*' && end(w) === '*' && w !== '\\*') {
        obj.greedy = true;
        w = stripEnd(w);
      }

      if (end(w) === '?') {
        obj.optional = true;
        w = stripEnd(w);
      }

      if (start(w) === '!') {
        obj.negative = true;
        w = stripStart(w);
      } //wrapped-flags


      if (start(w) === '(' && end(w) === ')') {
        // support (one && two)
        if (andSign.test(w)) {
          obj.choices = w.split(andSign);
          obj.operator = 'and';
        } else {
          obj.choices = w.split('|');
          obj.operator = 'or';
        } //remove '(' and ')'


        obj.choices[0] = stripStart(obj.choices[0]);
        var last = obj.choices.length - 1;
        obj.choices[last] = stripEnd(obj.choices[last]); // clean up the results

        obj.choices = obj.choices.map(function (s) {
          return s.trim();
        });
        obj.choices = obj.choices.filter(function (s) {
          return s;
        }); //recursion alert!

        obj.choices = obj.choices.map(parseToken);
        w = '';
      } //regex


      if (start(w) === '/' && end(w) === '/') {
        w = stripBoth(w);
        obj.regex = new RegExp(w); //potential vuln - security/detect-non-literal-regexp

        return obj;
      } //soft-match


      if (start(w) === '~' && end(w) === '~') {
        w = stripBoth(w);
        obj.soft = true;
        obj.word = w;
        return obj;
      }
    } // support #Tag{0,9}


    if (hasMinMax.test(w) === true) {
      w = w.replace(hasMinMax, function (a, b) {
        var arr = b.split(/,/g);

        if (arr.length === 1) {
          // '{3}'	Exactly three times
          obj.min = Number(arr[0]);
          obj.max = Number(arr[0]);
        } else {
          // '{2,4}' Two to four times
          // '{3,}' Three or more times
          obj.min = Number(arr[0]);
          obj.max = Number(arr[1] || 999);
        }

        obj.greedy = true;
        return '';
      });
    } //do the actual token content


    if (start(w) === '#') {
      obj.tag = stripStart(w);
      obj.tag = titleCase$2(obj.tag);
      return obj;
    } //dynamic function on a term object


    if (start(w) === '@') {
      obj.method = stripStart(w);
      return obj;
    }

    if (w === '.') {
      obj.anything = true;
      return obj;
    } //support alone-astrix


    if (w === '*') {
      obj.anything = true;
      obj.greedy = true;
      obj.optional = true;
      return obj;
    }

    if (w) {
      //somehow handle encoded-chars?
      w = w.replace('\\*', '*');
      w = w.replace('\\.', '.');
      obj.word = w.toLowerCase();
    }

    return obj;
  };

  var parseToken_1 = parseToken;

  var isNamed = function isNamed(capture) {
    return typeof capture === 'string' || typeof capture === 'number';
  };

  var fillGroups = function fillGroups(tokens) {
    var convert = false;
    var index = -1;
    var current; //'fill in' capture groups between start-end

    for (var i = 0; i < tokens.length; i++) {
      var n = tokens[i]; // Give name to un-named single tokens

      if (n.groupType === 'single' && n.named === true) {
        index += 1;
        n.named = index;
        continue;
      } // Start converting tokens


      if (n.groupType === 'start') {
        convert = true;

        if (isNamed(n.named)) {
          current = n.named;
        } else {
          index += 1;
          current = index;
        }
      } // Ensure this token has the right name


      if (convert) {
        n.named = current;
      } // Stop converting tokens


      if (n.groupType === 'end') {
        convert = false;
      }
    }

    return tokens;
  };

  var useOneOf = function useOneOf(tokens) {
    return tokens.map(function (token) {
      if (token.choices !== undefined) {
        // are they all straight non-optional words?
        var shouldPack = token.choices.every(function (c) {
          return c.optional !== true && c.negative !== true && c.word !== undefined;
        });

        if (shouldPack === true) {
          var oneOf = {};
          token.choices.forEach(function (c) {
            return oneOf[c.word] = true;
          });
          token.oneOf = oneOf;
          delete token.choices;
        }
      }

      return token;
    });
  };

  var postProcess$1 = function postProcess(tokens) {
    // ensure all capture groups are filled between start and end
    // give all capture groups names
    var count = tokens.filter(function (t) {
      return t.groupType;
    }).length;

    if (count > 0) {
      tokens = fillGroups(tokens);
    } // convert 'choices' format to 'oneOf' format


    tokens = useOneOf(tokens); // console.log(tokens)

    return tokens;
  };

  var postProcess_1 = postProcess$1;

  var isArray$1 = function isArray(arr) {
    return Object.prototype.toString.call(arr) === '[object Array]';
  }; //split-up by (these things)


  var byParentheses = function byParentheses(str) {
    var arr = str.split(/([\^\[\!]*(?:<\S+>)?\(.*?\)[?+*]*\]?\$?)/);
    arr = arr.map(function (s) {
      return s.trim();
    });
    return arr;
  };

  var byWords = function byWords(arr) {
    var words = [];
    arr.forEach(function (a) {
      //keep brackets lumped together
      if (/^[[^_/]?\(/.test(a[0])) {
        words.push(a);
        return;
      }

      var list = a.split(' ');
      list = list.filter(function (w) {
        return w;
      });
      words = words.concat(list);
    });
    return words;
  }; //turn an array into a 'choices' list


  var byArray = function byArray(arr) {
    return [{
      choices: arr.map(function (s) {
        return {
          word: s
        };
      })
    }];
  };

  var fromDoc = function fromDoc(doc) {
    if (!doc || !doc.list || !doc.list[0]) {
      return [];
    }

    var ids = [];
    doc.list.forEach(function (p) {
      p.terms().forEach(function (t) {
        ids.push({
          id: t.id
        });
      });
    });
    return [{
      choices: ids,
      greedy: true
    }];
  };
  /** parse a match-syntax string into json */


  var syntax = function syntax(input) {
    // fail-fast
    if (input === null || input === undefined || input === '') {
      return [];
    } //try to support a ton of different formats:


    if (_typeof(input) === 'object') {
      if (isArray$1(input)) {
        if (input.length === 0 || !input[0]) {
          return [];
        } //is it a pre-parsed reg-list?


        if (_typeof(input[0]) === 'object') {
          return input;
        } //support a flat array of normalized words


        if (typeof input[0] === 'string') {
          return byArray(input);
        }
      } //support passing-in a compromise object as a match


      if (input && input.isA === 'Doc') {
        return fromDoc(input);
      }

      return [];
    }

    if (typeof input === 'number') {
      input = String(input); //go for it?
    }

    var tokens = byParentheses(input);
    tokens = byWords(tokens);
    tokens = tokens.map(parseToken_1); //clean up anything weird

    tokens = postProcess_1(tokens); // console.log(JSON.stringify(tokens, null, 2))

    return tokens;
  };

  var syntax_1 = syntax;

  /**  returns a simple array of arrays */

  var matchAll = function matchAll(p, regs) {
    var matchOne = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    //if we forgot to parse it..
    if (typeof regs === 'string') {
      regs = syntax_1(regs);
    } //try to dismiss it, at-once


    if (_02FailFast(p, regs) === true) {
      return [];
    } //any match needs to be this long, at least


    var minLength = regs.filter(function (r) {
      return r.optional !== true;
    }).length;
    var terms = p.terms();
    var matches = []; //optimisation for '^' start logic

    if (regs[0].start === true) {
      var _tryMatch = _03TryMatch(terms, regs, 0, terms.length),
          _tryMatch2 = _slicedToArray(_tryMatch, 2),
          match = _tryMatch2[0],
          groups = _tryMatch2[1];

      if (match !== false && match.length > 0) {
        match = match.filter(function (m) {
          return m;
        });
        matches.push({
          match: match,
          groups: groups
        });
      }

      return _04PostProcess(terms, regs, matches);
    } //try starting, from every term


    for (var i = 0; i < terms.length; i += 1) {
      // slice may be too short
      if (i + minLength > terms.length) {
        break;
      } //try it!


      var _tryMatch3 = _03TryMatch(terms.slice(i), regs, i, terms.length),
          _tryMatch4 = _slicedToArray(_tryMatch3, 2),
          _match = _tryMatch4[0],
          _groups = _tryMatch4[1];

      if (_match !== false && _match.length > 0) {
        //zoom forward!
        i += _match.length - 1; //[capture-groups] return some null responses

        _match = _match.filter(function (m) {
          return m;
        });
        matches.push({
          match: _match,
          groups: _groups
        }); //ok, maybe that's enough?

        if (matchOne === true) {
          return _04PostProcess(terms, regs, matches);
        }
      }
    }

    return _04PostProcess(terms, regs, matches);
  };

  var _01MatchAll = matchAll;

  /** return anything that doesn't match.
   * returns a simple array of arrays
   */

  var notMatch = function notMatch(p, regs) {
    var found = {};
    var arr = _01MatchAll(p, regs);
    arr.forEach(function (_ref) {
      var ts = _ref.match;
      ts.forEach(function (t) {
        found[t.id] = true;
      });
    }); //return anything not found

    var terms = p.terms();
    var result = [];
    var current = [];
    terms.forEach(function (t) {
      if (found[t.id] === true) {
        if (current.length > 0) {
          result.push(current);
          current = [];
        }

        return;
      }

      current.push(t);
    });

    if (current.length > 0) {
      result.push(current);
    }

    return result;
  };

  var not = notMatch;

  /** return an array of matching phrases */

  var match_1 = function match_1(regs) {
    var _this = this;

    var justOne = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var matches = _01MatchAll(this, regs, justOne); //make them phrase objects

    matches = matches.map(function (_ref) {
      var match = _ref.match,
          groups = _ref.groups;

      var p = _this.buildFrom(match[0].id, match.length, groups);

      p.cache.terms = match;
      return p;
    });
    return matches;
  };
  /** return boolean if one match is found */


  var has = function has(regs) {
    var matches = _01MatchAll(this, regs, true);
    return matches.length > 0;
  };
  /** remove all matches from the result */


  var not$1 = function not$1(regs) {
    var _this2 = this;

    var matches = not(this, regs); //make them phrase objects

    matches = matches.map(function (list) {
      return _this2.buildFrom(list[0].id, list.length);
    });
    return matches;
  };
  /** return a list of phrases that can have this tag */


  var canBe$1 = function canBe(tag, world) {
    var _this3 = this;

    var results = [];
    var terms = this.terms();
    var previous = false;

    for (var i = 0; i < terms.length; i += 1) {
      var can = terms[i].canBe(tag, world);

      if (can === true) {
        if (previous === true) {
          //add it to the end
          results[results.length - 1].push(terms[i]);
        } else {
          results.push([terms[i]]); //make a new one
        }

        previous = can;
      }
    } //turn them into Phrase objects


    results = results.filter(function (a) {
      return a.length > 0;
    }).map(function (arr) {
      return _this3.buildFrom(arr[0].id, arr.length);
    });
    return results;
  };

  var match = {
    match: match_1,
    has: has,
    not: not$1,
    canBe: canBe$1
  };

  var Phrase = function Phrase(id, length, pool) {
    _classCallCheck(this, Phrase);

    this.start = id;
    this.length = length;
    this.isA = 'Phrase'; // easier than .constructor...

    Object.defineProperty(this, 'pool', {
      enumerable: false,
      writable: true,
      value: pool
    });
    Object.defineProperty(this, 'cache', {
      enumerable: false,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, 'groups', {
      enumerable: false,
      writable: true,
      value: {}
    });
  };
  /** create a new Phrase object from an id and length */


  Phrase.prototype.buildFrom = function (id, length, groups) {
    var p = new Phrase(id, length, this.pool); //copy-over or replace capture-groups too

    if (groups && Object.keys(groups).length > 0) {
      p.groups = groups;
    } else {
      p.groups = this.groups;
    }

    return p;
  }; //apply methods


  Object.assign(Phrase.prototype, match);
  Object.assign(Phrase.prototype, methods$1); //apply aliases

  var aliases = {
    term: 'terms'
  };
  Object.keys(aliases).forEach(function (k) {
    return Phrase.prototype[k] = Phrase.prototype[aliases[k]];
  });
  var Phrase_1 = Phrase;

  /** a key-value store of all terms in our Document */
  var Pool = /*#__PURE__*/function () {
    function Pool() {
      var words = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Pool);

      //quiet this property in console.logs
      Object.defineProperty(this, 'words', {
        enumerable: false,
        value: words
      });
    }
    /** throw a new term object in */


    _createClass(Pool, [{
      key: "add",
      value: function add(term) {
        this.words[term.id] = term;
        return this;
      }
      /** find a term by it's id */

    }, {
      key: "get",
      value: function get(id) {
        return this.words[id];
      }
      /** find a term by it's id */

    }, {
      key: "remove",
      value: function remove(id) {
        delete this.words[id];
      }
    }, {
      key: "merge",
      value: function merge(pool) {
        Object.assign(this.words, pool.words);
        return this;
      }
      /** helper method */

    }, {
      key: "stats",
      value: function stats() {
        return {
          words: Object.keys(this.words).length
        };
      }
    }]);

    return Pool;
  }();
  /** make a deep-copy of all terms */


  Pool.prototype.clone = function () {
    var _this = this;

    var keys = Object.keys(this.words);
    var words = keys.reduce(function (h, k) {
      var t = _this.words[k].clone();

      h[t.id] = t;
      return h;
    }, {});
    return new Pool(words);
  };

  var Pool_1 = Pool;

  //add forward/backward 'linked-list' prev/next ids
  var linkTerms = function linkTerms(terms) {
    terms.forEach(function (term, i) {
      if (i > 0) {
        term.prev = terms[i - 1].id;
      }

      if (terms[i + 1]) {
        term.next = terms[i + 1].id;
      }
    });
  };

  var _linkTerms = linkTerms;

  //(Rule-based sentence boundary segmentation) - chop given text into its proper sentences.
  // Ignore periods/questions/exclamations used in acronyms/abbreviations/numbers, etc.
  // @spencermountain 2017 MIT
  //proper nouns with exclamation marks
  // const blacklist = {
  //   yahoo: true,
  //   joomla: true,
  //   jeopardy: true,
  // }
  //regs-
  var initSplit = /(\S.+?[.!?\u203D\u2E18\u203C\u2047-\u2049])(?=\s+|$)/g;
  var hasSomething = /\S/;
  var isAcronym$1 = /[ .][A-Z]\.? *$/i;
  var hasEllipse = /(?:\u2026|\.{2,}) *$/;
  var newLine = /((?:\r?\n|\r)+)/; // Match different new-line formats

  var hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff]/i;
  var startWhitespace = /^\s+/; // Start with a regex:

  var naiive_split = function naiive_split(text) {
    var all = []; //first, split by newline

    var lines = text.split(newLine);

    for (var i = 0; i < lines.length; i++) {
      //split by period, question-mark, and exclamation-mark
      var arr = lines[i].split(initSplit);

      for (var o = 0; o < arr.length; o++) {
        all.push(arr[o]);
      }
    }

    return all;
  };
  /** does this look like a sentence? */


  var isSentence = function isSentence(str, abbrevs) {
    // check for 'F.B.I.'
    if (isAcronym$1.test(str) === true) {
      return false;
    } //check for '...'


    if (hasEllipse.test(str) === true) {
      return false;
    } // must have a letter


    if (hasLetter.test(str) === false) {
      return false;
    }

    var txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, '');
    var words = txt.split(' ');
    var lastWord = words[words.length - 1].toLowerCase(); // check for 'Mr.'

    if (abbrevs.hasOwnProperty(lastWord)) {
      return false;
    } // //check for jeopardy!
    // if (blacklist.hasOwnProperty(lastWord)) {
    //   return false
    // }


    return true;
  };

  var splitSentences = function splitSentences(text, world) {
    var abbrevs = world.cache.abbreviations;
    text = text || '';
    text = String(text);
    var sentences = []; // First do a greedy-split..

    var chunks = []; // Ensure it 'smells like' a sentence

    if (!text || typeof text !== 'string' || hasSomething.test(text) === false) {
      return sentences;
    } // cleanup unicode-spaces


    text = text.replace('\xa0', ' '); // Start somewhere:

    var splits = naiive_split(text); // Filter-out the crap ones

    for (var i = 0; i < splits.length; i++) {
      var s = splits[i];

      if (s === undefined || s === '') {
        continue;
      } //this is meaningful whitespace


      if (hasSomething.test(s) === false) {
        //add it to the last one
        if (chunks[chunks.length - 1]) {
          chunks[chunks.length - 1] += s;
          continue;
        } else if (splits[i + 1]) {
          //add it to the next one
          splits[i + 1] = s + splits[i + 1];
          continue;
        }
      } //else, only whitespace, no terms, no sentence


      chunks.push(s);
    } //detection of non-sentence chunks:
    //loop through these chunks, and join the non-sentence chunks back together..


    for (var _i = 0; _i < chunks.length; _i++) {
      var c = chunks[_i]; //should this chunk be combined with the next one?

      if (chunks[_i + 1] && isSentence(c, abbrevs) === false) {
        chunks[_i + 1] = c + (chunks[_i + 1] || '');
      } else if (c && c.length > 0) {
        //&& hasLetter.test(c)
        //this chunk is a proper sentence..
        sentences.push(c);
        chunks[_i] = '';
      }
    } //if we never got a sentence, return the given text


    if (sentences.length === 0) {
      return [text];
    } //move whitespace to the ends of sentences, when possible
    //['hello',' world'] -> ['hello ','world']


    for (var _i2 = 1; _i2 < sentences.length; _i2 += 1) {
      var ws = sentences[_i2].match(startWhitespace);

      if (ws !== null) {
        sentences[_i2 - 1] += ws[0];
        sentences[_i2] = sentences[_i2].replace(startWhitespace, '');
      }
    }

    return sentences;
  };

  var _01Sentences = splitSentences; // console.log(sentence_parser('john f. kennedy'));

  var wordlike = /\S/;
  var isBoundary = /^[!?.]+$/;
  var naiiveSplit = /(\S+)/;
  var isSlash = /[a-z] ?\/ ?[a-z]*$/;
  var notWord = {
    '.': true,
    '-': true,
    //dash
    '': true,
    //en-dash
    '': true,
    //em-dash
    '--': true,
    '...': true // '/': true, // 'one / two'

  };

  var hasHyphen = function hasHyphen(str) {
    //dont split 're-do'
    if (/^(re|un)-?[^aeiou]./.test(str) === true) {
      return false;
    } //letter-number


    var reg = /^([a-z\u00C0-\u00FF`"'/]+)(-||)([a-z0-9\u00C0-\u00FF].*)/i;

    if (reg.test(str) === true) {
      return true;
    } //support weird number-emdash combo '20102011'
    // let reg2 = /^([0-9]+)(|)([0-9].*)/i
    // if (reg2.test(str)) {
    //   return true
    // }


    return false;
  }; // 'he / she' should be one word


  var combineSlashes = function combineSlashes(arr) {
    for (var i = 1; i < arr.length - 1; i++) {
      if (isSlash.test(arr[i])) {
        arr[i - 1] += arr[i] + arr[i + 1];
        arr[i] = null;
        arr[i + 1] = null;
      }
    }

    return arr;
  };

  var splitHyphens = function splitHyphens(word) {
    var arr = []; //support multiple-hyphenated-terms

    var hyphens = word.split(/[-]/);
    var whichDash = '-';
    var found = word.match(/[-]/);

    if (found && found[0]) {
      whichDash = found;
    }

    for (var o = 0; o < hyphens.length; o++) {
      if (o === hyphens.length - 1) {
        arr.push(hyphens[o]);
      } else {
        arr.push(hyphens[o] + whichDash);
      }
    }

    return arr;
  };

  var isArray$2 = function isArray(arr) {
    return Object.prototype.toString.call(arr) === '[object Array]';
  }; //turn a string into an array of strings (naiive for now, lumped later)


  var splitWords = function splitWords(str) {
    var result = [];
    var arr = []; //start with a naiive split

    str = str || '';

    if (typeof str === 'number') {
      str = String(str);
    }

    if (isArray$2(str)) {
      return str;
    }

    var words = str.split(naiiveSplit);

    for (var i = 0; i < words.length; i++) {
      //split 'one-two'
      if (hasHyphen(words[i]) === true) {
        arr = arr.concat(splitHyphens(words[i]));
        continue;
      }

      arr.push(words[i]);
    } //greedy merge whitespace+arr to the right


    var carry = '';

    for (var _i = 0; _i < arr.length; _i++) {
      var word = arr[_i]; //if it's more than a whitespace

      if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
        //put whitespace on end of previous term, if possible
        if (result.length > 0) {
          result[result.length - 1] += carry;
          result.push(word);
        } else {
          //otherwise, but whitespace before
          result.push(carry + word);
        }

        carry = '';
      } else {
        carry += word;
      }
    } //handle last one


    if (carry) {
      if (result.length === 0) {
        result[0] = '';
      }

      result[result.length - 1] += carry; //put it on the end
    } // combine 'one / two'


    result = combineSlashes(result); // remove empty results

    result = result.filter(function (s) {
      return s;
    });
    return result;
  };

  var _02Words = splitWords;

  var isArray$3 = function isArray(arr) {
    return Object.prototype.toString.call(arr) === '[object Array]';
  };
  /** turn a string into an array of Phrase objects */


  var fromText = function fromText() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var world = arguments.length > 1 ? arguments[1] : undefined;
    var pool = arguments.length > 2 ? arguments[2] : undefined;
    var sentences = null; //a bit of validation, first

    if (typeof text !== 'string') {
      if (typeof text === 'number') {
        text = String(text);
      } else if (isArray$3(text)) {
        sentences = text;
      }
    } //tokenize into words


    sentences = sentences || _01Sentences(text, world);
    sentences = sentences.map(function (str) {
      return _02Words(str);
    }); //turn them into proper objects

    pool = pool || new Pool_1();
    var phrases = sentences.map(function (terms) {
      terms = terms.map(function (str) {
        var term = new Term_1(str);
        pool.add(term);
        return term;
      }); //add next/previous ids

      _linkTerms(terms); //return phrase objects

      var p = new Phrase_1(terms[0].id, terms.length, pool);
      p.cache.terms = terms;
      return p;
    }); //return them ready for a Document object

    return phrases;
  };

  var _01Tokenizer = fromText;

  var fromJSON = function fromJSON(json, world) {
    var pool = new Pool_1();
    var phrases = json.map(function (p, k) {
      var terms = p.terms.map(function (o, i) {
        var term = new Term_1(o.text);
        term.pre = o.pre !== undefined ? o.pre : '';

        if (o.post === undefined) {
          o.post = ' '; //no given space for very last term

          if (i >= p.terms.length - 1) {
            o.post = '. ';

            if (k >= p.terms.length - 1) {
              o.post = '.';
            }
          }
        }

        term.post = o.post !== undefined ? o.post : ' ';

        if (o.tags) {
          o.tags.forEach(function (tag) {
            return term.tag(tag, '', world);
          });
        }

        pool.add(term);
        return term;
      }); //add prev/next links

      _linkTerms(terms); // return a proper Phrase object

      return new Phrase_1(terms[0].id, terms.length, pool);
    });
    return phrases;
  };

  var fromJSON_1 = fromJSON;

  var _version = '13.5.0X003';

  var _data = {
    "Comparative": "truebetter",
    "Superlative": "trueearlier",
    "PresentTense": "trueis,sounds",
    "Value": "truea few",
    "Noun": "truea5b4c2f1here,ie,lit,m0no doubt,pd,tce;a,d;t,y;a,ca,o0;l,rp;a,l;d,l,rc",
    "Copula": "truea1is,w0;as,ere;m,re",
    "PastTense": "truebe3came,d2had,lied,meant,sa2taken,w0;as,e0;nt,re;id;en,gan",
    "Condition": "trueif,lest,unless",
    "Gerund": "trueaccord0be0develop0go0result0stain0;ing",
    "Negative": "truen0;ever,o0;!n,t",
    "QuestionWord": "truehow3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
    "Plural": "truerecords",
    "Conjunction": "true&,aEbAcuz,how8in caDno7o6p4supposing,t1vers5wh0yet;eth8ile;h0o;eref9o0;!uC;l0rovided that;us;r,therwi6; matt1r;!ev0;er;e0ut;cau1f0;ore;se;lthou1nd,s 0;far as,if;gh",
    "Pronoun": "true'em,elle,h4i3me,ourselves,she5th1us,we,you0;!rself;e0ou;m,y;!l,t;e0im;!'s",
    "Singular": "true0:0Z;1:12;a0Yb0Mc0Dd06e04fZgUhQiPjel0kitty,lOmKnJoIpEquestion mark,rCs7t4u2womY;nc0Ts 2;doll0Fst0H; rex,a3h2ic,ragedy,v show;ere,i1;l0x return;i5ky,omeone,t2uper bowl,yst0Y;ep3ri1u2;de0Rff;faOmoO;st0Nze;al0i1o2;om,se;a4i0Kl06r3u2;dMrpoE;erogaWobl0P;rt,te0J;bjTceHthers;othi1umb0F;a4ee05o2;del,m2nopo0th0D;!my;n,yf0;i0unch;ci1nsect;ead start,o2;l0me3u2;se;! run;adf0entlem5irlZlaci04od,rand3u2;l0y; slam,fa2mo2;th01;an;a5ella,ly,ol0r3un2;di1;iTo2;ntiWsN;mi0thV;conomy,gg,ner5veWx2;ampQecu7;ad7e4innSo2ragonf0ude;cumentFg2i0l0or;gy;ath,t2;ec2;tive;!dy;a8eili1h6i4o2redit card;ttage,u2;riJsin;ty,vil w2;ar;andeliGocol2;ate;n2rD;ary;aAel0lesHo6r4u2;n2tterf0;ti1;eakfast,o2;!th8;dy,tt4y2;!fri2;end;le;nki1r2;ri2;er;d4l0noma0u2;nt;ly; homin4verti2;si1;ng;em",
    "Actor": "trueaJbGcFdCengineIfAgardenIh9instructPjournalLlawyIm8nurse,opeOp5r3s1t0;echnCherapK;ailNcientJoldiGu0;pervKrgeon;e0oofE;ceptionGsearC;hotographClumbColi1r0sychologF;actitionBogrammB;cem6t5;echanic,inist9us4;airdress8ousekeep8;arm7ire0;fight6m2;eputy,iet0;ici0;an;arpent2lerk;ricklay1ut0;ch0;er;ccoun6d2ge7r0ssis6ttenda7;chitect,t0;ist;minist1v0;is1;rat0;or;ta0;nt",
    "Honorific": "truea03b00cSdReQfiLgKhon,jr,king,lJmEoDp8queen,r4s0taoiseach,vice7;e1fc,gt,ir,r,u0;ltTpt,rg;c0nDrgeaL;ond liJretary;abbi,e0;ar1pAs,v0;!erend; admirY;astPhd,r0vt;esideEi1of0;!essN;me mini5nce0;!ss;fficOp,rd;a3essrs,i2lle,me,r1s0;!tr;!s;stK;gistrate,j,r6yF;i3lb,t;en,ov;eld mar3rst l0;ady,i0;eutena0;nt;shG;sq,xcellency;et,oct6r,utchess;apt6hance4mdr,o0pl;lonel,m2ngress0unci3;m0wom0;an;dr,mand5;ll0;or;!ain;ldg,rig0;!adi0;er;d0sst,tty,yatullah;j,m0v;!ir0;al",
    "SportsTeam": "true0:1A;1:1H;2:1G;a1Eb16c0Td0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Bm01newToQpJqueens parkIreal salt lake,sAt5utah jazz,vancouver whitecaps,w3yW;ashington 3est ham0Rh10;natio1Oredski2wizar0W;ampa bay 6e5o3;ronto 3ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasC;buccanee0ra0K;a7eattle 5heffield0Kporting kansas0Wt3;. louis 3oke0V;c1Frams;marine0s3;eah15ounG;cramento Rn 3;antonio spu0diego 3francisco gJjose earthquak1;char08paA; ran07;a8h5ittsburgh 4ortland t3;imbe0rail blaze0;pirat1steele0;il3oenix su2;adelphia 3li1;eagl1philNunE;dr1;akland 3klahoma city thunder,rlando magic;athle0Mrai3;de0; 3castle01;england 7orleans 6york 3;city fc,g4je0FknXme0Fred bul0Yy3;anke1;ian0D;pelica2sain0C;patrio0Brevolut3;ion;anchester Be9i3ontreal impact;ami 7lwaukee b6nnesota 3;t4u0Fvi3;kings;imberwolv1wi2;rewe0uc0K;dolphi2heat,marli2;mphis grizz3ts;li1;cXu08;a4eicesterVos angeles 3;clippe0dodDla9; galaxy,ke0;ansas city 3nE;chiefs,roya0E; pace0polis colU;astr06dynamo,rockeTtexa2;olden state warrio0reen bay pac3;ke0;.c.Aallas 7e3i05od5;nver 5troit 3;lio2pisto2ti3;ge0;broncZnuggeM;cowbo4maver3;ic00;ys; uQ;arCelKh8incinnati 6leveland 5ol3;orado r3umbus crew sc;api5ocki1;brow2cavalie0india2;bengaWre3;ds;arlotte horAicago 3;b4cubs,fire,wh3;iteB;ea0ulR;diff3olina panthe0; c3;ity;altimore 9lackburn rove0oston 5rooklyn 3uffalo bilN;ne3;ts;cel4red3; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 3;brav1falco2h4u3;nited;aw9;ns;es;on villa,r3;os;c5di3;amondbac3;ks;ardi3;na3;ls",
    "Uncountable": "truea1Ib1Ac11d0Ye0Rf0Lg0Hh0Ci08j07knowled1Hl02mUnews,oTpQrLsAt5vi4w0;a2ea05i1oo0;d,l;ldlife,ne;rmth,t17;neg0Yol06tae;e3h2oothpaste,r0una;affPou0;ble,sers,t;ermod1Eund12;a,nnis;a8cene04eri0Oh7il6kittl0Onow,o5p3t1u0;g0Rnshi0H;ati1De0;am,el;ace16e0;ci0Jed;ap,cc0U;k,v0T;eep,ingl0G;d04fe10l0nd;m0St;a3e1ic0;e,ke0D;c0laxa09search;ogni08rea08;bi09in;aJe1hys10last5o0ressV;lit0Zrk,w0J;a0Vtrol;bstetr0Xil,xygen;a5e3ilk,o2u0;mps,s0;ic;nGo0A;a0chan0S;slZt;chine0il,themat0Q; learn05ry;aught08e2i1ogi0Nu0;ck,g0C;ce,ghtn02ngui0LteratH;a0isG;th04;ewel7usti0G;ce,mp0nformaOtself;a0ortan0E;ti0;en0C;a3isto2o0;ck0mework,n0spitali06;ey;ry;ir,libut,ppi7;en01o1r0um,ymna08;a6ound;l0ssip;d,f;i4lour,o1urnit0;ure;od,rgive0uriNwl;ne0;ss;c6sh;conomZduca5lectr4n2quip3thZvery0;body,o0thE;ne;joy0tertain0;ment;iciNonU;tiF;ar1iabet0raugh1;es;ts;a7elcius,h3ivPl2o0urrency;al,ld w0nfusiAttA;ar;assMoth2;aos,e0;e1w0;ing;se;r4sh;a4eef,i1lood,owls,read,utt0;er;lliar1s0;on;ds;g0ss;ga0;ge;c6dvi5ero3ir2mnes1rt,thl0;et7;ty;craft;b4d0naut4;ynam3;ce;id,ou0;st0;ics",
    "Infinitive": "true0:6K;1:6Y;2:57;3:6W;4:6V;5:5Z;6:67;7:6U;8:6Q;9:6I;A:6S;B:6P;C:6Z;D:6D;E:56;F:5P;a6Cb61c52d4Ae3Uf3Hg3Bh34i2Rj2Pk2Nl2Fm25n22o1Xp1Iques3Ir0Qs05tXuSvOwHyG;awn,ield;aJe1Yhist6iIoGre65;nd0rG;k,ry;pe,sh,th0;lk,nHrGsh,tDve;n,raC;d0t;aIiGo7;eGsB;!w;l6Cry;nHpGr4se;gra4Mli3Z;dGi7lo5Spub3O;erGo;mi58w1I;aMeLhKoJrHuGwi8;ne,rn;aGe0Mi5Nu8y;de,in,nsf0p,v5F;r2XuD;ank,reat2N;nd,st;lk,rg1Ps7;aZcWeVhTi4Akip,lSmRnee3Jo4YpQtJuGwitD;bmBck,ff0gge8ppHrGspe5;ge,pri1rou4Vvi3;ly,o34;aLeKoJrHuG;dy,mb6;aEeGi3;ngth2Dss,tD;p,re;m,p;in,ke,r0Qy;laFoil,rink6;e1Xi6o3H;am,ip;a2iv0oG;ck,ut;arDem,le5n1r3tt6;aHo2rG;atDew;le,re;il,ve;a05eIisk,oHuG;in,le,sh;am,ll;a01cZdu9fYgXje5lUmTnt,pQquPsKtJvGwa5O;eGiew,o34;al,l,rG;se,t;aEi2u40;eJi8oItG;!o2rG;i5uc1Y;l3rt;mb6nt,r3;e8i2;air,eHlGo3ZreseC;a9y;at;aEemb0i3Vo3;aHeGi3y;a1nt;te,x;a56r0I;act1Wer,le5u1;a11ei3k5IoGyc6;gni2Anci6rd;ch,li29s5G;i1nG;ge,k;aTerSiRlOoMrIuG;b1Zll,mp,rGsh;cha1s4J;ai1eIiCoG;cGdu9greAhibBmi1te8vi2T;eAlaim;di5pa2ss,veC;iCp,rtr3ZsGur;e,t;aHuG;g,n4;n,y;ck,le;fo30mBsi8;ck,iCrt4Fss,u1;bJccur,ff0pera7utweIverGwe;co40lap,ta20u1wG;helm;igh;ser3taE;eHotG;e,i9;ed,gle5;aLeKiIoHuG;ltip3Crd0;nit11ve;nGrr10;d,g6us;asu2lt,n0Nr4;intaEna4rHtG;ch,t0;ch,kGry;et;aLeKiIoGu1B;aGck,ok,ve;d,n;ft,ke,mBnGst2Wve;e,k;a2Dc0Et;b0Nck,uG;gh,nD;iGno2Z;ck,ll,ss;am,oEuG;d4mp;gno2mQnGss3C;cOdica7flu0MhNsKtIvG;eGol3;nt,st;erGrodu9;a5fe2;i8tG;aGru5;ll;abBibB;lu1Er1C;agi22pG;lemeCo20ro3;aKeIi2oHuG;nt,rry;n02pe,st;aGlp;d,t;nd6ppGrm,te;en;aKloAove1MrIuG;arGeAi13;ant33d;aGip,umb6;b,sp;in,th0ze;aQeaPiNlLoIracHuncG;ti3D;tu2;cus,lHrG;ce,eca8m,s2V;d,l1Z;aFoG;at,od,w;gu2lGniFx;e,l;r,tu2;il,vG;or;a13cho,le5mSnPstNvalua7xG;a0AcLerKi8pGte17;a16eHi2laEoGreA;rt,se;ct,riG;en9;ci1t;el,han4;abGima7;liF;ab6couXdHfor9ga4han9j03riDsu2t0vG;isi2Qy;!u2;body,er4pG;hasiGow0;ze;a06eUiLoKrHuG;mp;aHeAiG;ft;g,in;d4ubt;ff0p,re5sHvG;iYor9;aKcHliGmiApl16tinguiF;ke;oGuA;uGv0;ra4;gr1TppG;ear,ro3;cNem,fLliv0ma0Dny,pKsHterG;mi0E;cribe,er3iHtrG;oy;gn,re;a09e08i5osB;eGi09y;at,ct;iIlHrG;ea1;a2i05;de;ma4n9re,te;a0Ae09h06i7l04oJrG;aHeGoAuFy;a7dB;ck,ve;llZmSnHok,py,uGv0;gh,nt;cePdu5fMsKtIvG;eGin9;rt,y;aEin0SrG;a8ibu7ol;iGtitu7;d0st;iHoGroC;rm;gu2rm;rn;biLfoKmaJpG;a2laE;in;re;nd;rt;ne;ap1e5;aGip,o1;im,w;aHeG;at,ck,w;llen4n4r4se;a1nt0;ll,ncIrGt0u1;eGry;!en;el;aPeMloLoJruFuG;lGry;ly;sh;a8mb,o8rrGth0un9;ow;ck;ar,lHnefBtrG;ay;ie3ong;ng,se;band0Jc0Bd06ffo05gr04id,l01mu1nYppTrQsKttGvoid,waB;acIeHra5;ct;m0Fnd;h,k;k,sG;eIiHocia7uG;me;gn,st;mb6rt;le;chHgGri3;ue;!i3;eaJlIroG;aDve;ch;aud,y;l,r;noun9sw0tG;icipa7;ce;lHt0;er;e4ow;ee;rd;aRdIju8mBoR;it;st;!reA;ss;cJhie3knowled4tiva7;te;ge;ve;eIouCu1;se;nt;pt;on",
    "Unit": "true0:19;a14b12c0Od0Ne0Lf0Gg0Ch09in0Hjoule0k02l00mNnMoLpIqHsqCt7volts,w6y4z321;g,s;c,f,n;b,e2;a0Nb,d0Dears old,o1;tt0H;att0b;able4b3d,e2on1sp;!ne0;a2r0D;!l,sp;spo04; ft,uare 1;c0Id0Hf3i0Fkilo0Jm1ya0E;e0Mil1;e0li0H;eet0o0D;t,uart0;ascals,e2i1ou0Pt;c0Mnt0;rcent,t02;hms,uYz;an0JewtT;/s,b,e9g,i3l,m2p1,;h,s;!;!/h,cro5l1;e1li08;! pFs1;! 1;anEpD;g06s0B;gQter1;! 2s1;! 1;per second;b,i00m,u1x;men0x0;b,elvin0g,ilo2m1nR;!/h,ph,;byZgXmeter1;! p2s1;! p1;er1; hour;e1g,r0z;ct1rtz0;aXogQ;al2b,igAra1;in0m0;!l1;on0;a4emtPl2t1;,; oz,uid ou1;nce0;hrenheit0rad0;b,x1;abyH;eciCg,l,mA;arat0eAg,m9oulomb0u1;bic 1p0;c5d4fo3i2meAya1;rd0;nch0;ot0;eci2;enti1;me4;!,;lsius0nti1;g2li1me1;ter0;ram0;bl,y1;te0;c4tt1;os1;eco1;nd0;re0;!s",
    "Organization": "true0:46;a3Ab2Qc2Ad21e1Xf1Tg1Lh1Gi1Dj19k17l13m0Sn0Go0Dp07qu06rZsStFuBv8w3y1;amaha,m0Xou1w0X;gov,tu2S;a3e1orld trade organizati41;lls fargo,st1;fie22inghou16;l1rner br3D;-m11gree31l street journ25m11;an halNeriz3Wisa,o1;dafo2Gl1;kswagLvo;bs,kip,n2ps,s1;a tod2Rps;es35i1;lev2Xted natio2Uv; mobi2Kaco bePd bMeAgi frida9h3im horto2Tmz,o1witt2W;shiba,y1;ota,s r Y;e 1in lizzy;b3carpen33daily ma2Xguess w2holli0rolling st1Ms1w2;mashing pumpki2Ouprem0;ho;ea1lack eyed pe3Fyrds;ch bo1tl0;ys;l2s1;co,la m12;efoni07us;a6e4ieme2Gnp,o2pice gir5ta1ubaru;rbucks,to2N;ny,undgard1;en;a2Rx pisto1;ls;few25insbu26msu1X;.e.m.,adiohead,b6e3oyal 1yan2X;b1dutch she4;ank;/max,aders dige1Ed 1vl32;bu1c1Uhot chili peppe2Klobst28;ll;c,s;ant2Vizno2F;an5bs,e3fiz24hilip morrBi2r1;emier27octer & gamb1Rudenti14;nk floyd,zza hut;psi28tro1uge08;br2Qchina,n2Q; 2ason1Xda2G;ld navy,pec,range juli2xf1;am;us;a9b8e5fl,h4i3o1sa,wa;kia,tre dame,vart1;is;ke,ntendo,ss0K;l,s;c,st1Etflix,w1; 1sweek;kids on the block,york08;a,c;nd1Us2t1;ional aca2Fo,we0Q;a,cYd0O;aAcdonald9e5i3lb,o1tv,yspace;b1Nnsanto,ody blu0t1;ley crue,or0O;crosoft,t1;as,subisO;dica3rcedes2talli1;ca;!-benz;id,re;'s,s;c's milk,tt13z1Y;'ore09a3e1g,ittle caesa1Ktd;novo,x1;is,mark; pres5-z-boy,bour party;atv,fc,kk,m1od1K;art;iffy lu0Lo3pmorgan1sa;! cha1;se;hnson & johns1Sy d1R;bm,hop,n1tv;c,g,te1;l,rpol; & m,asbro,ewlett-packaTi3o1sbc,yundai;me dep1n1J;ot;tac1zbollah;hi;eneral 6hq,l5mb,o2reen d0Iu1;cci,ns n ros0;ldman sachs,o1;dye1g0B;ar;axo smith kliZencore;electr0Im1;oto0V;a3bi,da,edex,i1leetwood mac,oGrito-l0A;at,nancial1restoV; tim0;cebook,nnie mae;b06sa,u3xxon1; m1m1;ob0H;!rosceptics;aiml0Ae5isney,o3u1;nkin donuts,po0Wran dur1;an;j,w j1;on0;a,f leppa3ll,p2r spiegZstiny's chi1;ld;eche mode,t;rd;aEbc,hBi9nn,o3r1;aigsli5eedence clearwater reviv1ossra05;al;!ca c5l4m1o0Ast05;ca2p1;aq;st;dplMgate;ola;a,sco1tigroup;! systems;ev2i1;ck fil-a,na daily;r0Hy;dbury,pital o1rl's jr;ne;aGbc,eCfAl6mw,ni,o2p,r1;exiteeWos;ei3mbardiJston 1;glo1pizza;be;ng;ack & deckFo2ue c1;roX;ckbuster video,omingda1;le; g1g1;oodriN;cht3e ge0n & jer2rkshire hathaw1;ay;ryH;el;nana republ3s1xt5y5;f,kin robbi1;ns;ic;bXcSdidRerosmith,ig,lLmFnheuser-busEol,ppleAr7s3t&t,v2y1;er;is,on;hland2s1;n,ociated F; o1;il;by4g2m1;co;os; compu2bee1;'s;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 4catel2t1;air;!-luce1;nt;jazeera,qae1;da;as;/dc,a3er,t1;ivisi1;on;demy of scienc0;es;ba,c",
    "Demonym": "true0:16;1:13;a0Wb0Nc0Cd0Ae09f07g04h02iYjVkTlPmLnIomHpDqatari,rBs7t5u4v3wel0Rz2;am0Fimbabwe0;enezuel0ietnam0H;g9krai1;aiwThai,rinida0Iu2;ni0Qrkmen;a4cot0Ke3ingapoOlovak,oma0Tpa05udRw2y0X;edi0Kiss;negal0Br08;mo0uU;o6us0Lw2;and0;a3eru0Hhilipp0Po2;li0Ertugu06;kist3lesti1na2raguay0;ma1;ani;amiZi2orweP;caragu0geri2;an,en;a3ex0Mo2;ngo0Erocc0;cedo1la2;gasy,y08;a4eb9i2;b2thua1;e0Dy0;o,t02;azakh,eny0o2uwaiti;re0;a2orda1;ma0Bp2;anN;celandic,nd4r2sraeli,ta02vo06;a2iT;ni0qi;i0oneV;aiDin2ondur0unN;di;amDe2hanai0reek,uatemal0;or2rm0;gi0;i2ren7;lipino,n4;cuadoVgyp6ngliJsto1thiopi0urope0;a2ominXut4;niH;a9h6o4roa3ub0ze2;ch;ti0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el8o6r3ul2;gaG;aziBi2;ti2;sh;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;gent2me1;ine;ba1ge2;ri0;ni0;gh0r2;ic0;an",
    "Possessive": "trueanyAh5its,m3noCo1sometBthe0yo1;ir1mselves;ur0;!s;i8y0;!se4;er1i0;mse2s;!s0;!e0;lf;o1t0;hing;ne",
    "Currency": "true$,aud,bScQdLeurKfJgbp,hkd,iIjpy,kGlEp8r7s3usd,x2y1z0,,,,,,,,,,,;lotyS;en,uanR;af,of;h0t5;e0il5;k0q0;elM;iel,oubleLp,upeeL;e2ound st0;er0;lingI;n0soH;ceGn0;ies,y;e0i8;i,mpi7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!o8;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;ad,e0ny;nt1;aht,itcoin0;!s",
    "City": "truea2Wb26c1Wd1Re1Qf1Og1Ih1Ai18jakar2Hk0Zl0Tm0Gn0Co0ApZquiYrVsLtCuBv8w3y1z0;agreb,uri1Z;ang1Te0okohama;katerin1Hrev34;ars3e2i0rocl3;ckl0Vn0;nipeg,terth0W;llingt1Oxford;aw;a1i0;en2Hlni2Z;lenc2Uncouv0Gr2G;lan bat0Dtrecht;a6bilisi,e5he4i3o2rondheim,u0;nVr0;in,ku;kyo,ronIulouC;anj23l13miso2Jra2A; haJssaloni0X;gucigalpa,hr2Ol av0L;i0llinn,mpe2Bngi07rtu;chu22n2MpT;a3e2h1kopje,t0ydney;ockholm,uttga12;angh1Fenzh1X;o0KvZ;int peters0Ul3n0ppo1F; 0ti1B;jo0salv2;se;v0z0Q;adU;eykjavik,i1o0;me,sario,t25;ga,o de janei17;to;a8e6h5i4o2r0ueb1Qyongya1N;a0etor24;gue;rt0zn24; elizabe3o;ls1Grae24;iladelph1Znom pe07oenix;r0tah tik19;th;lerJr0tr10;is;dessa,s0ttawa;a1Hlo;a2ew 0is;delTtaip0york;ei;goya,nt0Upl0Uv1R;a5e4i3o1u0;mb0Lni0I;nt0scH;evideo,real;l1Mn01skolc;delln,lbour0S;drid,l5n3r0;ib1se0;ille;or;chest0dalWi0Z;er;mo;a4i1o0vAy01;nd00s angel0F;ege,ma0nz,sbZverpo1;!ss0;ol; pla0Iusan0F;a5hark4i3laipeda,o1rak0uala lump2;ow;be,pavog0sice;ur;ev,ng8;iv;b3mpa0Kndy,ohsiu0Hra0un03;c0j;hi;ncheMstanb0zmir;ul;a5e3o0; chi mi1ms,u0;stI;nh;lsin0rakliG;ki;ifa,m0noi,va0A;bu0SiltD;alw4dan3en2hent,iza,othen1raz,ua0;dalaj0Gngzhou;bu0P;eUoa;sk;ay;es,rankfu0;rt;dmont4indhovU;a1ha01oha,u0;blRrb0Eshanbe;e0kar,masc0FugavpiJ;gu,je0;on;a7ebu,h2o0raioJuriti01;lo0nstanJpenhagNrk;gFmbo;enn3i1ristchur0;ch;ang m1c0ttagoL;ago;ai;i0lgary,pe town,rac4;ro;aHeBirminghWogoAr5u0;char3dap3enos air2r0sZ;g0sa;as;es;est;a2isba1usse0;ls;ne;silPtisla0;va;ta;i3lgrade,r0;g1l0n;in;en;ji0rut;ng;ku,n3r0sel;celo1ranquil0;la;na;g1ja lu0;ka;alo0kok;re;aBb9hmedabad,l7m4n2qa1sh0thens,uckland;dod,gabat;ba;k0twerp;ara;m5s0;terd0;am;exandr0maty;ia;idj0u dhabi;an;lbo1rh0;us;rg",
    "Abbreviation": "truea0Tb0Qc0Kd0Ie0Ff0Cg0Ah08i06j04k02l00mRnOoNpIqHrFs9t6u5v2w0yb,g;is0r,y0L;!c;a,b,e1i0ol,s,t;tro,vo;r,t;niv,safa,t;b1ce,d,e0sp;l,mp,nn,x;!l,sp;ask,e3fc,gt,i2q1r,s,t,u0;pt,rg;! ft;r,tu;c,nVp0;!t;b,d,e0;pSs,v;t,ue;a,d,enn3hd,l,p,r1s0t,vt;!eud;ef,o0;b,f,n;!a;ct,kla,nt,p,rd,z;e0ov;b0e;!r;a7b,d,essrs,g,i4l3m2p1rHs0t;!tr;h,s;!e;!le;!n1s0;c,ter;!n;!j,r,sc;at,b,it,lb,m,ng,t0x;!d;an6b,g,m0;!ph;an,d,r,u0;l,n;a,da,e,n0;c,f;g,on,r0wy,z;!s;a0b,en,ov;!l;e1ig,l0m,r,t,y;! oz,a;b,m;a,g,ng,s1tc,x0;!p;p,q,t;ak,e0g,ist,l,m,r;c,f,pt,t;a3ca,g,l,m2o0pl,res,t,yn;!l0mdr,nn,rp;!o;!dr;!l0pt;!if;a,c,l1r0;ig,os;!dg,vd;d4l3p2r1ss0tty,ug,ve;n,t;c,iz;prox,r,t;!ta;!j,m,v",
    "Country": "true0:38;1:2L;a2Wb2Dc21d1Xe1Rf1Lg1Bh19i13j11k0Zl0Um0Gn05om3CpZqat1JrXsKtCu6v4wal3yemTz2;a24imbabwe;es,lis and futu2X;a2enezue31ietnam;nuatu,tican city;.5gTkraiZnited 3ruXs2zbeE;a,sr;arab emirat0Kkingdom,states2;! of am2X;k.,s.2; 27a.;a7haBimor-les0Bo6rinidad4u2;nis0rk2valu;ey,me2Xs and caic1T; and 2-2;toba1J;go,kel0Ynga;iw2Vji2nz2R;ki2T;aCcotl1eBi8lov7o5pa2Bri lanka,u4w2yr0;az2ed9itzerl1;il1;d2Qriname;lomon1Vmal0uth 2;afr2IkLsud2O;ak0en0;erra leoEn2;gapo1Wt maart2;en;negKrb0ychellY;int 2moa,n marino,udi arab0;hele24luc0mart1Z;epublic of ir0Com2Cuss0w2;an25;a3eHhilippinTitcairn1Ko2uerto riM;l1rtugE;ki2Bl3nama,pua new0Tra2;gu6;au,esti2;ne;aAe8i6or2;folk1Gth3w2;ay; k2ern mariana1B;or0M;caragua,ger2ue;!ia;p2ther18w zeal1;al;mib0u2;ru;a6exi5icro09o2yanm04;ldova,n2roc4zamb9;a3gol0t2;enegro,serrat;co;c9dagascZl6r4urit3yot2;te;an0i14;shall0Vtin2;ique;a3div2i,ta;es;wi,ys0;ao,ed00;a5e4i2uxembourg;b2echtenste10thu1E;er0ya;ban0Gsotho;os,tv0;azakh1De2iriba02osovo,uwait,yrgyz1D;eling0Jnya;a2erF;ma15p1B;c6nd5r3s2taly,vory coast;le of m19rael;a2el1;n,q;ia,oI;el1;aiSon2ungary;dur0Mg kong;aAermany,ha0Pibralt9re7u2;a5ern4inea2ya0O;!-biss2;au;sey;deloupe,m,tema0P;e2na0M;ce,nl1;ar;bTmb0;a6i5r2;ance,ench 2;guia0Dpoly2;nes0;ji,nl1;lklandTroeT;ast tim6cu5gypt,l salv5ngl1quatorial3ritr4st2thiop0;on0; guin2;ea;ad2;or;enmark,jibou4ominica3r con2;go;!n B;ti;aAentral african 9h7o4roat0u3yprQzech2; 8ia;ba,racao;c3lo2morPngo-brazzaville,okFsta r03te d'ivoiK;mb0;osD;i2ristmasF;le,na;republic;m2naTpe verde,yman9;bod0ero2;on;aFeChut00o8r4u2;lgar0r2;kina faso,ma,undi;azil,itish 2unei;virgin2; is2;lands;liv0nai4snia and herzegoviGtswaGuvet2; isl1;and;re;l2n7rmuF;ar2gium,ize;us;h3ngladesh,rbad2;os;am3ra2;in;as;fghaFlCmAn5r3ustr2zerbaijH;al0ia;genti2men0uba;na;dorra,g4t2;arct6igua and barbu2;da;o2uil2;la;er2;ica;b2ger0;an0;ia;ni2;st2;an",
    "Region": "true0:1U;a20b1Sc1Id1Des1Cf19g13h10i0Xj0Vk0Tl0Qm0FnZoXpSqPrMsDtAut9v6w3y1zacatec22;o05u1;cat18kZ;a1est vi4isconsin,yomi14;rwick0shington1;! dc;er2i1;rgin1S;acruz,mont;ah,tar pradesh;a2e1laxca1DuscaA;nnessee,x1R;bas0Kmaulip1QsmJ;a6i4o2taf0Ou1ylh13;ffVrr00s0Y;me10no1Auth 1;cSdR;ber1Ic1naloa;hu0Sily;n2skatchew0Rxo1;ny; luis potosi,ta catari1I;a1hode7;j1ngp02;asth0Mshahi;inghai,u1;e1intana roo;bec,ensWreta0E;ara4e2rince edward1; isU;i,nnsylv1rnambu02;an14;!na;axa0Ndisha,h1klaho1Bntar1reg4x04;io;ayarit,eBo3u1;evo le1nav0L;on;r1tt0Rva scot0X;f6mandy,th1; 1ampton0;c3d2yo1;rk0;ako0Y;aroli0V;olk;bras0Xva01w1; 2foundland1;! and labrador;brunswick,hamp0jers1mexiJyork state;ey;a6i2o1;nta0Nrelos;ch3dlanBn2ss1;issippi,ouri;as geraGneso0M;igQoacQ;dhya,harasht04ine,ni3r1ssachusetts;anhao,y1;land;p1toba;ur;anca0e1incoln0ouis8;e1iH;ds;a1entucky,hul0A;ns08rnata0Dshmir;alis1iangxi;co;daho,llino2nd1owa;ia05;is;a2ert1idalEunA;ford0;mp0waii;ansu,eorgWlou5u1;an2erre1izhou,jarat;ro;ajuato,gdo1;ng;cester0;lori2uji1;an;da;sex;e4o2uran1;go;rs1;et;lawaErby0;a8ea7hi6o1umbrH;ahui4l3nnectic2rsi1ventry;ca;ut;iMorado;la;apEhuahua;ra;l8m1;bridge0peche;a5r4uck1;ingham0;shi1;re;emen,itish columb3;h2ja cal1sque,var2;iforn1;ia;guascalientes,l4r1;izo2kans1;as;na;a2ber1;ta;ba2s1;ka;ma",
    "FemaleName": "true0:FY;1:G2;2:FR;3:FD;4:FC;5:FS;6:ER;7:EP;8:GF;9:EZ;A:GB;B:E5;C:G8;D:FO;E:FL;F:EG;aE2bD4cB8dAIe9Gf91g8Hh83i7Sj6Uk60l4Om38n2To2Qp2Fqu2Er1Os0Qt04ursu6vUwOyLzG;aJeHoG;e,la,ra;lGna;da,ma;da,ra;as7EeHol1TvG;et7onB9;le0sen3;an9endBNhiB4iG;lInG;if3AniGo0;e,f39;a,helmi0lGma;a,ow;aMeJiG;cHviG;an9XenG1;kCZtor3;da,l8Vnus,rG;a,nGoniD2;a,iDC;leGnesEC;nDLrG;i1y;aSePhNiMoJrGu6y4;acG3iGu0E;c3na,sG;h9Mta;nHrG;a,i;i9Jya;a5IffaCGna,s5;al3eGomasi0;a,l8Go6Xres1;g7Uo6WrHssG;!a,ie;eFi,ri8;bNliMmKnIrHs5tGwa0;ia0um;a,yn;iGya;a,ka,s5;a4e4iGmCAra;!ka;a,t5;at5it5;a05carlet2Ye04hUiSkye,oQtMuHyG;bFJlvi1;e,sHzG;an2Tet7ie,y;anGi8;!a,e,nG;aEe;aIeG;fGl3DphG;an2;cF8r6;f3nGphi1;d4ia,ja,ya;er4lv3mon1nGobh75;dy;aKeGirlBLo0y6;ba,e0i6lIrG;iGrBPyl;!d70;ia,lBV;ki4nIrHu0w0yG;la,na;i,leAon,ron;a,da,ia,nGon;a,on;l5Yre0;bMdLi9lKmIndHrGs5vannaE;aEi0;ra,y;aGi4;nt5ra;lBNome;e,ie;in1ri0;a02eXhViToHuG;by,thBK;bQcPlOnNsHwe0xG;an94ie,y;aHeGie,lC;ann8ll1marBFtB;!lGnn1;iGyn;e,nG;a,d7W;da,i,na;an9;hel53io;bin,erByn;a,cGkki,na,ta;helBZki;ea,iannDXoG;da,n12;an0bIgi0i0nGta,y0;aGee;!e,ta;a,eG;cARkaE;chGe,i0mo0n5EquCDvDy0;aCCelGi9;!e,le;een2ia0;aMeLhJoIrG;iGudenAW;scil1Uyamva9;lly,rt3;ilome0oebe,ylG;is,lis;arl,ggy,nelope,r6t4;ige,m0Fn4Oo6rvaBBtHulG;a,et7in1;ricGsy,tA8;a,e,ia;ctav3deHfAWlGphAW;a,ga,iv3;l3t7;aQePiJoGy6;eHrG;aEeDma;ll1mi;aKcIkGla,na,s5ta;iGki;!ta;hoB2k8BolG;a,eBH;!mh;l7Tna,risF;dIi5PnHo23taG;li1s5;cy,et7;eAiCO;a01ckenz2eViLoIrignayani,uriBGyG;a,rG;a,na,tAS;i4ll9XnG;a,iG;ca,ka,qB4;a,chOkaNlJmi,nIrGtzi;aGiam;!n9;a,dy,erva,h,n2;a,dIi9JlG;iGy;cent,e;red;!e6;ae6el3G;ag4KgKi,lHrG;edi61isFyl;an2iGliF;nGsAM;a,da;!an,han;b08c9Ed06e,g04i03l01nZrKtJuHv6Sx87yGz2;a,bell,ra;de,rG;a,eD;h75il9t2;a,cSgOiJjor2l6In2s5tIyG;!aGbe5QjaAlou;m,n9S;a,ha,i0;!aIbALeHja,lCna,sGt53;!a,ol,sa;!l06;!h,m,nG;!a,e,n1;arIeHie,oGr3Kueri7;!t;!ry;et3IiB;elGi61y;a,l1;dGon,ue6;akranBy;iGlo36;a,ka,n9;a,re,s2;daGg2;!l2W;alCd2elGge,isBGon0;eiAin1yn;el,le;a0Ie08iWoQuKyG;d3la,nG;!a,dHe9SnGsAQ;!a,e9R;a,sAO;aB1cJelIiFlHna,pGz;e,iB;a,u;a,la;iGy;a2Ae,l25n9;is,l1GrHtt2uG;el6is1;aIeHi8na,rG;a6Zi8;lei,n1tB;!in1;aQbPd3lLnIsHv3zG;!a,be4Ket7z2;a,et7;a,dG;a,sGy;ay,ey,i,y;a,iaIlG;iGy;a8Ge;!n4F;b7Terty;!n5R;aNda,e0iLla,nKoIslARtGx2;iGt2;c3t3;la,nGra;a,ie,o4;a,or1;a,gh,laG;!ni;!h,nG;a,d4e,n4N;cNdon7Si6kes5na,rMtKurIvHxGy6;mi;ern1in3;a,eGie,yn;l,n;as5is5oG;nya,ya;a,isF;ey,ie,y;aZeUhadija,iMoLrIyG;lGra;a,ee,ie;istGy5B;a,en,iGy;!e,n48;ri,urtn9A;aMerLl99mIrGzzy;a,stG;en,in;!berlG;eGi,y;e,y;a,stD;!na,ra;el6PiJlInHrG;a,i,ri;d4na;ey,i,l9Qs2y;ra,s5;c8Wi5XlOma6nyakumari,rMss5LtJviByG;!e,lG;a,eG;e,i78;a5EeHhGi3PlCri0y;ar5Cer5Cie,leDr9Fy;!lyn73;a,en,iGl4Uyn;!ma,n31sF;ei72i,l2;a04eVilToMuG;anKdJliGst56;aHeGsF;!nAt0W;!n8X;i2Ry;a,iB;!anLcelCd5Vel71han6IlJni,sHva0yG;a,ce;eGie;fi0lCph4X;eGie;en,n1;!a,e,n36;!i10lG;!i0Z;anLle0nIrHsG;i5Qsi5Q;i,ri;!a,el6Pif1RnG;a,et7iGy;!e,f1P;a,e72iHnG;a,e71iG;e,n1;cLd1mi,nHqueliAsmin2Uvie4yAzG;min8;a8eHiG;ce,e,n1s;!lGsFt06;e,le;inHk2lCquelG;in1yn;da,ta;lPmNnMo0rLsHvaG;!na;aHiGob6U;do4;!belGdo4;!a,e,l2G;en1i0ma;a,di4es,gr5R;el9ogG;en1;a,eAia0o0se;aNeKilHoGyacin1N;ll2rten1H;aHdGlaH;a,egard;ry;ath0WiHlGnrietBrmiAst0W;en24ga;di;il75lKnJrGtt2yl75z6D;iGmo4Fri4G;etG;!te;aEnaE;ey,l2;aYeTiOlMold12rIwG;enGyne18;!dolC;acHetGisel9;a,chD;e,ieG;!la;adys,enGor3yn1Y;a,da,na;aJgi,lHna,ov71selG;a,e,le;da,liG;an;!n0;mYnIorgHrG;ald35i,m2Stru73;et7i5T;a,eGna;s1Nvieve;briel3Fil,le,rnet,yle;aReOio0loMrG;anHe9iG;da,e9;!cG;esHiGoi0G;n1s3V;!ca;!rG;a,en43;lHrnG;!an9;ec3ic3;rHtiGy8;ma;ah,rah;d0FileDkBl00mUn4ArRsMtLuKvG;aIelHiG;e,ta;in0Ayn;!ngel2H;geni1la,ni3R;h52ta;meral9peranJtG;eHhGrel6;er;l2Pr;za;iGma,nest29yn;cGka,n;a,ka;eJilImG;aGie,y;!liA;ee,i1y;lGrald;da,y;aTeRiMlLma,no4oJsIvG;a,iG;na,ra;a,ie;iGuiG;se;a,en,ie,y;a0c3da,nJsGzaH;aGe;!beG;th;!a,or;anor,nG;!a;in1na;en,iGna,wi0;e,th;aWeKiJoGul2U;lor51miniq3Yn30rGtt2;a,eDis,la,othGthy;ea,y;an09naEonAx2;anPbOde,eNiLja,lImetr3nGsir4U;a,iG;ce,se;a,iHla,orGphiA;es,is;a,l5J;dGrdG;re;!d4Mna;!b2CoraEra;a,d4nG;!a,e;hl3i0mMnKphn1rHvi1WyG;le,na;a,by,cHia,lG;a,en1;ey,ie;a,et7iG;!ca,el1Aka;arGia;is;a0Qe0Mh04i02lUoJrHynG;di,th3;istGy04;al,i0;lOnLrHurG;tn1D;aId28iGn28riA;!nG;a,e,n1;!l1S;n2sG;tanGuelo;ce,za;eGleD;en,t7;aIeoHotG;il4B;!pat4;ir8rIudG;et7iG;a,ne;a,e,iG;ce,sX;a4er4ndG;i,y;aPeMloe,rG;isHyG;stal;sy,tG;aHen,iGy;!an1e,n1;!l;lseHrG;!i8yl;a,y;nLrG;isJlHmG;aiA;a,eGot7;n1t7;!sa;d4el1PtG;al,el1O;cHlG;es7i3F;el3ilG;e,ia,y;iYlXmilWndVrNsLtGy6;aJeIhGri0;erGleDrCy;in1;ri0;li0ri0;a2GsG;a2Fie;a,iMlKmeIolHrG;ie,ol;!e,in1yn;lGn;!a,la;a,eGie,y;ne,y;na,sF;a0Di0D;a,e,l1;isBl2;tlG;in,yn;arb0CeYianXlVoTrG;andRePiIoHyG;an0nn;nwCok8;an2NdgKg0ItG;n27tG;!aHnG;ey,i,y;ny;etG;!t8;an0e,nG;da,na;i8y;bbi8nG;iBn2;ancGossom,ythe;a,he;ca;aRcky,lin9niBrNssMtIulaEvG;!erlG;ey,y;hHsy,tG;e,i0Zy8;!anG;ie,y;!ie;nGt5yl;adHiG;ce;et7iA;!triG;ce,z;a4ie,ra;aliy29b24d1Lg1Hi19l0Sm0Nn01rWsNthe0uJvIyG;anGes5;a,na;a,r25;drIgusHrG;el3;ti0;a,ey,i,y;hHtrG;id;aKlGt1P;eHi8yG;!n;e,iGy;gh;!nG;ti;iIleHpiB;ta;en,n1t7;an19elG;le;aYdWeUgQiOja,nHtoGya;inet7n3;!aJeHiGmI;e,ka;!mGt7;ar2;!belHliFmT;sa;!le;ka,sGta;a,sa;elGie;a,iG;a,ca,n1qG;ue;!t7;te;je6rea;la;!bHmGstas3;ar3;el;aIberHel3iGy;e,na;!ly;l3n9;da;aTba,eNiKlIma,yG;a,c3sG;a,on,sa;iGys0J;e,s0I;a,cHna,sGza;a,ha,on,sa;e,ia;c3is5jaIna,ssaIxG;aGia;!nd4;nd4;ra;ia;i0nHyG;ah,na;a,is,naE;c5da,leDmLnslKsG;haElG;inGyW;g,n;!h;ey;ee;en;at5g2nG;es;ie;ha;aVdiSelLrG;eIiG;anLenG;a,e,ne;an0;na;aKeJiHyG;nn;a,n1;a,e;!ne;!iG;de;e,lCsG;on;yn;!lG;iAyn;ne;agaJbHiG;!gaI;ey,i8y;!e;il;ah",
    "Place": "truea07b05cZdYeXfVgRhQiOjfk,kMlKmHneEoDp9que,rd,s8t5u4v3w0yyz;is1y0;!o;!c;a,t;pYsafa,t;e1he 0;bronx,hamptons;nn,x;ask,fo,oho,t,under6yd;a2e1h0;l,x;k,nnK;!cifX;kla,nt;b1w eng0;land;!r;a1co,i0t,uc;dKnn;libu,nhattS;a0gw,hr;s,x;an0ul;!s;a0cn,da,ndianMst;!x;arlem,kg,nd,wy;a2re0;at 0enwich;britain,lak6;!y village;co,l0ra;!a;urope,verglad2;ak,en,fw,ist,own4xb;al4dg,gk,hina3l2o1r0t;es;lo,nn;!t;town;!if;cn,e0kk,lvd,rooklyn;l air,verly hills;frica,lta,m5ntarct2r1sia,tl0ve;!ant1;ct0iz;ic0; oce0;an;ericas,s",
    "WeekDay": "truefri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
    "Month": "trueaBdec9feb7j2mar,nov9oct1sep0;!t8;!o8;an3u0;l1n0;!e;!y;!u1;!ru0;ary;!em0;ber;pr1ug0;!ust;!il",
    "Date": "trueago,t0weekend,yesterd2;mr2o0;d0morrow;ay;!w",
    "FirstName": "trueaEblair,cCdevBj8k6lashawn,m3nelly,quinn,re2sh0;ay,e0iloh;a,lby;g1ne;ar1el,org0;an;ion,lo;as8e0r9;ls7nyatta,rry;am0ess1ude;ie,m0;ie;an,on;as0heyenne;ey,sidy;lex1ndra,ubr0;ey;is",
    "LastName": "true0:34;1:3B;2:39;3:2Y;4:2E;5:30;a3Bb31c2Od2Ee2Bf25g1Zh1Pi1Kj1Ek17l0Zm0Nn0Jo0Gp05rYsMtHvFwCxBy8zh6;a6ou,u;ng,o;a6eun2Uoshi1Kun;ma6ng;da,guc1Zmo27sh21zaR;iao,u;a7eb0il6o3right,u;li3Bs2;gn0lk0ng,tanabe;a6ivaldi;ssilj37zqu1;a9h8i2Go7r6sui,urn0;an,ynisJ;lst0Prr1Uth;at1Uomps2;kah0Vnaka,ylor;aEchDeChimizu,iBmiAo9t7u6zabo;ar1lliv2AzuE;a6ein0;l23rm0;sa,u3;rn4th;lva,mmo24ngh;mjon4rrano;midt,neid0ulz;ito,n7sa6to;ki;ch1dLtos,z;amBeag1Zi9o7u6;bio,iz,sD;b6dri1MgIj0Tme24osevelt,ssi,ux;erts,ins2;c6ve0F;ci,hards2;ir1os;aEeAh8ic6ow20ut1N;as6hl0;so;a6illips;m,n1T;ders5et8r7t6;e0Nr4;ez,ry;ers;h21rk0t6vl4;el,te0J;baBg0Blivei01r6;t6w1O;ega,iz;a6eils2guy5ix2owak,ym1E;gy,ka6var1K;ji6muW;ma;aEeCiBo8u6;ll0n6rr0Bssolini,6;oz;lina,oKr6zart;al0Me6r0U;au,no;hhail4ll0;rci0ssi6y0;!er;eWmmad4r6tsu07;in6tin1;!o;aCe8i6op1uo;!n6u;coln,dholm;fe7n0Qr6w0J;oy;bv6v6;re;mmy,rs5u;aBennedy,imuAle0Lo8u7wo6;k,n;mar,znets4;bay6vacs;asY;ra;hn,rl9to,ur,zl4;aAen9ha3imen1o6u3;h6nYu3;an6ns2;ss2;ki0Es5;cks2nsse0D;glesi9ke8noue,shik7to,vano6;u,v;awa;da;as;aBe8itchcock,o7u6;!a3b0ghNynh;a3ffmann,rvat;mingw7nde6rN;rs2;ay;ns5rrQs7y6;asDes;an4hi6;moJ;a9il,o8r7u6;o,tierr1;ayli3ub0;m1nzal1;nd6o,rcia;hi;erAis9lor8o7uj6;ita;st0urni0;es;ch0;nand1;d7insteHsposi6vaL;to;is2wards;aCeBi9omin8u6;bo6rand;is;gu1;az,mitr4;ov;lgado,vi;nkula,rw7vi6;es,s;in;aFhBlarkAo6;h5l6op0rbyn,x;em7li6;ns;an;!e;an8e7iu,o6ristens5u3we;i,ng,u3w,y;!n,on6u3;!g;mpb7rt0st6;ro;ell;aBe8ha3lanco,oyko,r6yrne;ooks,yant;ng;ck7ethov5nnett;en;er,ham;ch,h8iley,rn6;es,i0;er;k,ng;dDl9nd6;ers6rA;en,on,s2;on;eks7iy8var1;ez;ej6;ev;ams",
    "MaleName": "true0:CE;1:BL;2:C2;3:BT;4:B5;5:BZ;6:AT;7:9V;8:BD;9:AX;A:AO;aB4bA8c97d87e7Gf6Yg6Gh5Wi5Ij4Lk4Bl3Rm2Pn2Eo28p22qu20r1As0Qt06u05v00wNxavi3yGzB;aBor0;cBh8Ine;hCkB;!aB1;ar51eB0;ass2i,oCuB;sDu25;nEsDusB;oBsC;uf;ef;at0g;aJeHiCoByaAP;lfgang,odrow;lBn1O;bDey,frBJlB;aA5iB;am,e,s;e89ur;i,nde7sB;!l6t1;de,lCrr5yB;l1ne;lBt3;a93y;aEern1iBladimir;cCha0kt5CnceBrg9Bva0;!nt;ente,t5A;lentin49n8Yughn;lyss4Msm0;aTeOhKiIoErCyB;!l3ro8s1;av9QeBist0oy,um0;nt9Iv54y;bDd7XmBny;!as,mBoharu;aAYie,y;i83y;mBt9;!my,othy;adDeoCia7DomB;!as;!do7M;!de9;dErB;en8HrB;an8GeBy;ll,n8F;!dy;dgh,ic9Tnn3req,ts45;aRcotPeNhJiHoFpenc3tBur1Oylve8Hzym1;anDeBua7B;f0phAFvBwa7A;e57ie;!islaw,l6;lom1nA3uB;leyma8ta;dBl7Jm1;!n6;aDeB;lBrm0;d1t1;h6Sne,qu0Uun,wn,y8;aBbasti0k1Xl41rg40th,ymo9I;m9n;!tB;!ie,y;lCmBnti21q4Iul;!mAu4;ik,vato6V;aWeShe92iOoFuCyB;an,ou;b6LdCf9pe6QssB;!elAI;ol2Uy;an,bIcHdGel,geFh0landA9mEnDry,sCyB;!ce;coe,s;!a95nA;an,eo;l3Jr;e4Qg3n6olfo,ri68;co,ky;bAe9U;cBl6;ar5Oc5NhCkBo;!ey,ie,y;a85ie;gCid,ub5x,yBza;ansh,nS;g8WiB;na8Ss;ch5Yfa4lDmCndBpha4sh6Uul,ymo70;al9Yol2By;i9Ion;f,ph;ent2inB;cy,t1;aFeDhilCier62ol,reB;st1;!ip,lip;d9Brcy,tB;ar,e2V;b3Sdra6Ft44ul;ctav2Vliv3m96rFsCtBum8Uw5;is,to;aCc8SvB;al52;ma;i,l49vJ;athJeHiDoB;aBel,l0ma0r2X;h,m;cCg4i3IkB;h6Uola;hol5XkBol5X;!ol5W;al,d,il,ls1vB;il50;anBy;!a4i4;aWeTiKoFuCyB;l21r1;hamCr5ZstaB;fa,p4G;ed,mF;dibo,e,hamDis1XntCsBussa;es,he;e,y;ad,ed,mB;ad,ed;cGgu4kElDnCtchB;!e7;a78ik;house,o03t1;e,olB;aj;ah,hBk6;a4eB;al,l;hClv2rB;le,ri7v2;di,met;ck,hNlLmOnu4rHs1tDuricCxB;!imilian8Cwe7;e,io;eo,hCi52tB;!eo,hew,ia;eBis;us,w;cDio,k86lCqu6Gsha7tBv2;i2Hy;in,on;!el,oKus;achBcolm,ik;ai,y;amBdi,moud;adB;ou;aReNiMlo2RoIuCyB;le,nd1;cEiDkBth3;aBe;!s;gi,s;as,iaB;no;g0nn6RrenDuBwe7;!iB;e,s;!zo;am,on4;a7Bevi,la4SnDoBst3vi;!nB;!a60el;!ny;mCnBr67ur4Twr4T;ce,d1;ar,o4N;aIeDhaled,iBrist4Vu48y3B;er0p,rB;by,k,ollos;en0iEnBrmit,v2;!dCnBt5C;e0Yy;a7ri4N;r,th;na68rBthem;im,l;aYeQiOoDuB;an,liBst2;an,o,us;aqu2eJhnInGrEsB;eChBi7Bue;!ua;!ph;dBge;an,i,on;!aBny;h,s,th4X;!ath4Wie,nA;!l,sBy;ph;an,e,mB;!mA;d,ffGrDsB;sBus;!e;a5JemCmai8oBry;me,ni0O;i6Uy;!e58rB;ey,y;cHd5kGmFrDsCvi3yB;!d5s1;on,p3;ed,od,rBv4M;e4Zod;al,es,is1;e,ob,ub;k,ob,quB;es;aNbrahMchika,gKkeJlija,nuIrGsDtBv0;ai,sB;uki;aBha0i6Fma4sac;ac,iaB;h,s;a,vinBw2;!g;k,nngu52;!r;nacBor;io;im;in,n;aJeFina4VoDuByd56;be25gBmber4CsD;h,o;m3ra33sBwa3X;se2;aDctCitCn4ErB;be20m0;or;th;bKlJmza,nIo,rDsCyB;a43d5;an,s0;lEo4FrDuBv6;hi40ki,tB;a,o;is1y;an,ey;k,s;!im;ib;aQeMiLlenKoIrEuB;illerCsB;!tavo;mo;aDegBov3;!g,orB;io,y;dy,h57nt;nzaBrd1;lo;!n;lbe4Qno,ovan4R;ne,oDrB;aBry;ld,rd4U;ffr6rge;bri4l5rBv2;la1Zr3Eth,y;aReNiLlJorr0IrB;anDedBitz;!dAeBri24;ri23;cDkB;!ie,lB;in,yn;esJisB;!co,zek;etch3oB;yd;d4lBonn;ip;deriDliCng,rnB;an01;pe,x;co;bi0di;arZdUfrTit0lNmGnFo2rCsteb0th0uge8vBym5zra;an,ere2V;gi,iCnBrol,v2w2;est45ie;c07k;och,rique,zo;aGerFiCmB;aFe2P;lCrB;!h0;!io;s1y;nu4;be09d1iEliDmCt1viBwood;n,s;er,o;ot1Ts;!as,j43sB;ha;a2en;!dAg32mEuCwB;a25in;arB;do;o0Su0S;l,nB;est;aYeOiLoErDuCwByl0;ay8ight;a8dl6nc0st2;ag0ew;minFnDri0ugCyB;le;!l03;!a29nBov0;e7ie,y;go,icB;!k;armuCeBll1on,rk;go;id;anIj0lbeHmetri9nFon,rEsDvCwBxt3;ay8ey;en,in;hawn,mo08;ek,ri0F;is,nBv3;is,y;rt;!dB;re;lKmInHrDvB;e,iB;!d;en,iDne7rByl;eBin,yl;l2Vn;n,o,us;!e,i4ny;iBon;an,en,on;e,lB;as;a06e04hWiar0lLoGrEuCyrB;il,us;rtB;!is;aBistobal;ig;dy,lEnCrB;ey,neli9y;or,rB;ad;by,e,in,l2t1;aGeDiByI;fBnt;fo0Ct1;meCt9velaB;nd;nt;rDuCyB;!t1;de;enB;ce;aFeErisCuB;ck;!tB;i0oph3;st3;d,rlBs;eBie;s,y;cBdric,s11;il;lEmer1rB;ey,lCro7y;ll;!os,t1;eb,v2;ar02eUilTlaSoPrCuByr1;ddy,rtI;aJeEiDuCyB;an,ce,on;ce,no;an,ce;nCtB;!t;dCtB;!on;an,on;dCndB;en,on;!foBl6y;rd;bCrByd;is;!by;i8ke;al,lA;nFrBshoi;at,nCtB;!r10;aBie;rd0S;!edict,iCjam2nA;ie,y;to;n6rBt;eBy;tt;ey;ar0Xb0Nd0Jgust2hm0Gid5ja0ElZmXnPputsiOrFsaEuCveBya0ziz;ry;gust9st2;us;hi;aIchHi4jun,maFnDon,tBy0;hBu06;ur;av,oB;ld;an,nd0A;el;ie;ta;aq;dGgel05tB;hoEoB;i8nB;!i02y;ne;ny;reBy;!as,s,w;ir,mBos;ar;an,beOd5eIfFi,lEonDphonHt1vB;aMin;on;so,zo;an,en;onCrB;edP;so;c,jaEksandDssaExB;!and3;er;ar,er;ndB;ro;rtH;ni;en;ad,eB;d,t;in;aColfBri0vik;!o;mBn;!a;dFeEraCuB;!bakr,lfazl;hBm;am;!l;allEel,oulaye,ulB;!lCrahm0;an;ah,o;ah;av,on",
    "Person": "trueashton kutchSbRcMdKeIgastNhGinez,jEkDleCmBnettJoAp8r4s3t2v0;a0irgin maG;lentino rossi,n go3;heresa may,iger woods,yra banks;addam hussain,carlett johanssJlobodan milosevic,uB;ay romano,eese witherspoIo1ush limbau0;gh;d stewart,nald0;inho,o;a0ipJ;lmIris hiltD;prah winfrFra;essiaen,itt romnEubarek;bron james,e;anye west,iefer sutherland,obe bryant;aime,effers8k rowli0;ng;alle ber0itlBulk hogan;ry;ff0meril lagasse,zekiel;ie;a0enzel washingt2ick wolf;lt1nte;ar1lint0ruz;on;dinal wols1son0;! palm2;ey;arack obama,rock;er",
    "Verb": "trueawak9born,cannot,fr8g7h5k3le2m1s0wors9;e8h3;ake sure,sg;ngth6ss6;eep tabs,n0;own;as0e2;!t2;iv1onna;ight0;en",
    "PhrasalVerb": "true0:72;1:6Q;2:7E;3:74;4:6J;5:7H;6:76;7:6P;8:6C;9:6D;A:5I;B:71;C:70;a7Hb63c5Dd5Ae58f46g3Oh38iron0j34k2Zl2Km2Bn29o27p1Pr1Es09tQuOvacuum 1wGyammerCzD;eroAip EonD;e0k0;by,up;aJeGhFiEorDrit53;d 1k2R;mp0n4Ape0r8s8;eel Bip 7L;aEiD;gh 06rd0;n Br 3D;it 5Kk8lk6rm 0Qsh 74t67v4P;rgeCsD;e 9herA;aRePhNiJoHrFuDype 0N;ckArn D;d2in,o3Gup;ade YiDot0y 28;ckle68p 7A;ne67p Ds4D;d2o6Lup;ck FdEe Dgh5Tme0p o0Dre0;aw3ba4d2in,up;e5Ky 1;by,o6V;ink Drow 5V;ba4ov7up;aDe 4Ill4O;m 1r W;ckCke Elk D;ov7u4O;aDba4d2in,o31up;ba4ft7p4Tw3;a0Gc0Fe09h05i02lYmXnWoVpSquare RtJuHwD;earFiD;ngEtch D;aw3ba4o6P; by;ck Dit 1m 1ss0;in,up;aIe0RiHoFrD;aigh1MiD;ke 5Yn2Y;p Drm1P;by,in,o6B;n2Zr 1tc3I;c2Ymp0nd Dr6Hve6y 1;ba4d2up;d2o67up;ar2Vell0ill4UlErDurC;ingCuc8;a33it 3U;be4Crt0;ap 4Eow B;ash 4Zoke0;eep EiDow 9;c3Np 1;in,oD;ff,v7;gn Eng2Zt Dz8;d2o5up;in,o5up;aFoDu4F;ot Dut0w 5X;aw3ba4f37o5R;c2FdeAk4Sve6;e Hll0nd GtD; Dtl43;d2in,o5upD;!on;aw3ba4d2in,o1Yup;o5to;al4Lout0rap4L;il6v8;at0eKiJoGuD;b 4Ele0n Dstl8;aDba4d2in53o3Gt30u3E;c1Xw3;ot EuD;g2Knd6;a1Xf2Ro5;ng 4Op6;aDel6inAnt0;c4Yd D;o2Tu0C;aQePiOlMoKrHsyc2AuD;ll Ft D;aDba4d2in,o1Ht34up;p39w3;ap38d2in,o5t32up;attleCess EiGoD;p 1;ah1Hon;iDp 53re3Mur45wer 53;nt0;ay3ZuD;gAmp 9;ck 53g0leCn 9p3W;el 47ncilA;c3Pir 2In0ss FtEy D;ba4o4R; d2c1Y;aw3ba4o12;pDw3K;e3Jt B;arrow3Terd0oD;d6te3S;aJeHiGoEuD;ddl8ll37;c17p 1uth6ve D;al3Bd2in,o5up;ss0x 1;asur8lt 9ss D;a1Aup;ke Dn 9r30s1Lx0;do,o3Yup;aPeNiIoDuck0;a17c37g GoDse0;k Dse35;aft7ba4d2forw2Bin3Wov7uD;nd7p;in,o0J;e GghtFnEsDv1T;ten 4D;e 1k 1; 1e2Y;ar43d2;av1Ht 2YvelD; o3L;p 1sh DtchCugh6y1U;in3Lo5;eEick6nock D;d2o3H;eDyA;l2Hp D;aw3ba4d2fSin,o05to,up;aFoEuD;ic8mpA;ke2St2W;c31zz 1;aPeKiHoEuD;nker2Ts0U;lDneArse2O;d De 1;ba4d2fast,oZup;de Et D;ba4on,up;aw3o5;aDlp0;d Fl22r Dt 1;fDof;rom;in,oRu1A;cZm 1nDve it,ze1Y;d Dg 27kerF;d2in,o5;aReLive Jloss1VoFrEunD; f0M;in39ow 23; Dof 0U;aEb17it,oDr35t0Ou12;ff,n,v7;bo5ft7hJw3;aw3ba4d2in,oDup,w3;ff,n,ut;a17ek0t D;aEb11d2oDr2Zup;ff,n,ut,v7;cEhDl1Pr2Xt,w3;ead;ross;d aEnD;g 1;bo5;a08e01iRlNoJrFuD;cDel 1;k 1;eEighten DownCy 1;aw3o2L;eDshe1G; 1z8;lFol D;aDwi19;bo5r2I;d 9;aEeDip0;sh0;g 9ke0mDrD;e 2K;gLlJnHrFsEzzD;le0;h 2H;e Dm 1;aw3ba4up;d0isD;h 1;e Dl 11;aw3fI;ht ba4ure0;eInEsD;s 1;cFd D;fDo1X;or;e B;dQl 1;cHll Drm0t0O;apYbFd2in,oEtD;hrough;ff,ut,v7;a4ehi1S;e E;at0dge0nd Dy8;o1Mup;o09rD;ess 9op D;aw3bNin,o15;aShPlean 9oDross But 0T;me FoEuntD; o1M;k 1l6;aJbIforGin,oFtEuD;nd7;ogeth7;ut,v7;th,wD;ard;a4y;pDr19w3;art;eDipA;ck BeD;r 1;lJncel0rGsFtch EveA; in;o16up;h Bt6;ry EvD;e V;aw3o12;l Dm02;aDba4d2o10up;r0Vw3;a0He08l01oSrHuD;bbleFcklTilZlEndlTrn 05tDy 10zz6;t B;k 9; ov7;anMeaKiDush6;ghHng D;aEba4d2forDin,o5up;th;bo5lDr0Lw3;ong;teD;n 1;k D;d2in,o5up;ch0;arKgJil 9n8oGssFttlEunce Dx B;aw3ba4;e 9; ar0B;k Bt 1;e 1;d2up; d2;d 1;aIeed0oDurt0;cFw D;aw3ba4d2o5up;ck;k D;in,oK;ck0nk0st6; oJaGef 1nd D;d2ov7up;er;up;r0t D;d2in,oDup;ff,ut;ff,nD;to;ck Jil0nFrgEsD;h B;ainCe B;g BkC; on;in,o5; o5;aw3d2o5up;ay;cMdIsk Fuction6; oD;ff;arDo5;ouD;nd;d D;d2oDup;ff,n;own;t D;o5up;ut",
    "Modal": "truec5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to;ay,ight,ust;an,o0;uld",
    "Adjective": "true0:73;1:7I;2:7O;3:7H;4:7A;5:5B;6:4R;7:49;8:48;9:7F;A:60;a6Eb60c5Md52e4Pf45g3Xh3Mi31j2Zk2Yl2Nm2Cn23o1Np16quack,r0Ws0Ct05uMvJwByear5;arp0eFholeEiDoB;man5oBu67;d69zy;despr6Zs5B;!sa7;eClBste22;co1El o4H;!k5;aCiBola47;b7Nce versa,ol50;ca2gabo5Ynilla;ltSnFpCrb55su4tterB;!mo6U; f30b1KpCsBti1D;ca7et,ide dItairs;er,i3J;aLbeco6Lconvin23deIeHfair,ivers4knGprecedUrEsCwB;iel1Writt5U;i1RuB;pervis0specti3;eBu5;cognHgul6Bl6B;own;ndi3v5Oxpect0;cid0rB;!grou5JsB;iz0tood;b7ppeaHssu6AuthorB;iz0;i20ra;aFeDhough4KoCrB;i1oubl0;geth6p,rp6B;en5LlBm4Vrr2Q;li3;boo,lBn;ent0;aTcSeQhPiNmug,nobbi3AoLpKqueami3AtFuBymb5Y;bDi gener50pBrprisi3;erBre0H;! dup6b,i25;du0seq4P;anda6OeEi0LrBy34;aightBip0; fBfB;or56;adfa5Wreotyp0;a4Uec2Cir1Flend5Wot on; call0le,mb6phist1TrBu0Tvi3X;d5Ury;gnifica2nB;ce4Qg7;am2Le6ocki3ut;cBda1em5lfi2Uni1Spa63re8;o1Cr3R;at53ient24reec53;cr0me,ns serif;aIeEiCoB;bu5Ktt4PuOy4;ghtBv4;!-25fA;ar,bel,condi1du5Xfres4XlDpublic3RsBtard0;is43oB;lu1na2;e1Auc41;b5EciB;al,st;aMeKicayu8lac5Copuli5BrCuB;bl54mp0;eFiCoB;!b06fu5Cmi2Xp6;mCor,sBva1;ti8;a4Re;ci58mB;a0EiB;er,um;ac1WrBti1;fe9ma2Pplexi3v2Z;rBst;allelDtB;-tiBi4;me;!ed;bMffKkJld fashion0nIpHrg1Dth6utGvB;al,erB;!aDniCt,wB;eiBrouB;ght;ll;do0Rer,g2Hsi41;en,posi1; boa5Ag2Fli8;!ay; gua58bBli8;eat;eDsB;cBer0Dole1;e8u3F;d2Ose;ak0eIiHoBua4J;nFrCtB;ab7;thB;!eB;rn;chala2descri4Ustop;ght5;arby,cessa3Sighbor5xt;aJeHiEoBultip7;bi7derClBnth5ot,st;dy;a1n;nBx0;iaBor;tu2Y;di49naBre;ci3;cBgenta,in,jZkeshift,le,mmoth,ny,sculi8;ab2Uho;aKeFiCoBu0Z;uti0Yvi3;mCteraB;l,te;it0;ftEgBth4;al,eCitiB;ma1;nda38;!-08;ngu3Lst,tt6;ap1Oind5no06;agg0uB;niKstifi0veni7;de4gno46lleg4mOnDpso 1RrB;a1releB;va2; JaIbr0corHdFfluenPiPnEsDtB;a9en3GoxB;ic31;a8i2N;a1er,oce2;iCoB;or;re9;deq3Eppr2T;fBsitu,vitro;ro2;mFpB;arDerfe9oBrop6;li1rtB;a2ed;ti4;eBi0M;d2Ln30;aGelFiDoBumdr36;ne2Uok0rrBs03ur5;if2N;ghfalut1KspB;an2L;liVpfA;lEnDrB;d01roB;wi3;dy,gi3;f,low0;ainfAener2Eiga1YlHoGraDuB;ilBng ho;ty;cCtB;efAis;efA;ne,od;ea28ob4;aQeKinJlIoDrB;a1PeBoz1G;e28q0YtfA;oDrB; keeps,eBm6tuna1;g00ign;liB;sh;ag2Uue2;al,i1;dFmCrB;ti7;a7ini8;ne;le; up;bl0i2l20r Cux,voB;ri1uri1;oBreac1A;ff;aJfficie2lImiHnFre9there4veExB;a9cess,pe1JtraCuB;be2Gl0D;!va19;n,ryday; Bcouragi3ti0M;rou1sui1;ne2;abo1YdMe14i1;g6sB;t,ygB;oi3;er;aReJiDoBrea11ue;mina2ne,ubB;le,tfA;dact16fficu1JsCvB;er1F;creDeas0gruntl0hone1AordCtB;a2ress0;er5;et; HadpGfFgene1KliDrang0spe1KtCvoB;ut;ail0ermin0;be1Hca1ghB;tfA;ia2;an;facto;i5magBngeroVs0E;ed,i3;ly;ertaNhief,ivil,oDrB;aBowd0u0D;mp0vYz0;loJmHnCoi3rrBve0K;e9u1D;cre1grEsDtB;emBra0B;po09;ta2;ue2;mer04pleB;te,x;ni4ss4;in;aLeHizarGlFoCrB;and new,isk,okL;gCna fiSttom,urgeoB;is;us;ank,iE;re;autifAhiClov0nBst,yoC;eRt;nd;ul;ckCnkru0SrrB;en;!wards; priori,b0Ic0Fd05fra04g00hZlUma01ntiquTppQrKsIttracti02utheHvEwB;aCkB;wa0P;ke,re;ant garCerB;age;de;ntQ;leep,tonisB;hi3;ab,bitEroDtiB;fiB;ci4;ga2;raB;ry;are2etiLrB;oprB;ia1;at0;arEcohCeBiIl,oof;rt;olB;ic;mi3;ead;ainDgressiConiB;zi3;ve;st;id; IeGuFvB;aCerB;se;nc0;ed;lt;pt,qB;ua1;hoc,infinitB;um;cuCtu4u1;al;ra1;erLlKoIruHsCuB;nda2;e2oCtra9;ct;lu1rbi3;ng;te;pt;aBve;rd;aze,e;ra2;nt",
    "Comparable": "true0:3Z;1:4G;2:43;3:49;4:3V;5:2W;a4Mb42c3Md3Be33f2Pg2Dh22i1Tj1Sk1Pl1Hm1Bn15o13p0Tqu0Rr0IsRtKuIvFw7y6za11;ell25ou3;aBe9hi1Wi7r6;o3y;ck0Mde,l6n1ry,se;d,y;a6i4Kt;k,ry;n1Rr6sI;m,y;a7e6ulgar;nge4rda2xi3;gue,in,st;g0n6pco3Kse4;like0ti1;aAen9hi8i7ough,r6;anqu2Oen1ue;dy,g3Sme0ny,r09;ck,n,rs2P;d40se;ll,me,rt,s6wd45;te4;aVcarUeThRiQkin0FlMmKoHpGqua1FtAu7w6;eet,ift;b7dd13per0Gr6;e,re2H;sta2Ft5;aAe9iff,r7u6;pXr1;a6ict,o3;ig3Fn0U;a1ep,rn;le,rk;e22i3Fright0;ci28ft,l7o6re,ur;n,thi3;emn,id;a6el0ooth;ll,rt;e8i6ow,y;ck,g35m6;!y;ek,nd3D;ck,l0mp5;a6iTort,rill,y;dy,ll0Xrp;cu0Rve0Rxy;ce,ed,y;d,fe,int0l1Vv14;aBe9i8o6ude;mantic,o1Isy,u6;gh,nd;ch,pe,tzy;a6d,mo0H;dy,l;gg7ndom,p6re,w;id;ed;ai2i6;ck,et;aEhoDi1QlCoBr8u6;ny,r6;e,p5;egna2ic7o6;fouYud;ey,k0;li04or,te1B;ain,easa2;ny;in4le;dd,f6i0ld,ranQ;fi10;aAe8i7o6;b5isy,rm15sy;ce,mb5;a6w;r,t;ive,rr01;aAe8ild,o7u6;nda19te;ist,o1;a6ek,llX;n,s0ty;d,tuQ;aBeAi9o6ucky;f0Un7o1Du6ve0w17y0T;d,sy;e0g;g1Tke0tt5ve0;an,wd;me,r6te;ge;e7i6;nd;en;ol0ui1P;cy,ll,n6;sBt6;e6ima8;llege2r6;es7media6;te;ti3;ecu6ta2;re;aEeBiAo8u6;ge,m6ng1R;b5id;ll6me0t;ow;gh,l0;a6f04sita2;dy,v6;en0y;nd1Hppy,r6te4;d,sh;aGenFhDiClBoofy,r6;a9e8is0o6ue1E;o6ss;vy;at,en,y;nd,y;ad,ib,ooI;a2d1;a6o6;st0;t5uiY;u1y;aIeeb5iDlat,oAr8u6;ll,n6r14;!ny;aHe6iend0;e,sh;a7r6ul;get4mG;my;erce8n6rm,t;an6e;ciC;! ;le;ir,ke,n0Fr,st,t,ulA;aAerie,mp9sse7v6xtre0Q;il;nti6;al;ty;r7s6;tern,y;ly,th0;aFeCi9r7u6;ll,mb;u6y;nk;r7vi6;ne;e,ty;a6ep,nD;d6f,r;!ly;mp,pp03rk;aHhDlAo8r7u6;dd0r0te;isp,uel;ar6ld,mmon,ol,st0ward0zy;se;e6ou1;a6vW;n,r;ar8e6il0;ap,e6;sy;mi3;gey,lm8r6;e4i3;ful;!i3;aNiLlIoEr8u6;r0sy;ly;aAi7o6;ad,wn;ef,g7llia2;nt;ht;sh,ve;ld,r7un6;cy;ed,i3;ng;a7o6ue;nd,o1;ck,nd;g,tt6;er;d,ld,w1;dy;bsu9ng8we6;so6;me;ry;rd",
    "TextValue": "truebOeJfDhundredNmOninAone,qu8s6t0zeroN;enMh3rNw0;e0o;l0ntD;fHve;ir0ousandKree;d,t6;e0ix8;cond,pt1ven7xt1;adr0int0;illionD;e0th;!t0;e9ie8y;i3o0;rt1ur0;!t2;ie4y;ft0rst,ve;e3h,ie2y;ight0lev2;!e1h,ie0y;th;en0;!th;illion0;!s,th",
    "Ordinal": "truebGeDf9hundredHmGnin7qu6s4t0zeroH;enGh1rFwe0;lfFn9;ir0ousandE;d,t4;e0ixt9;cond,ptAvent8xtA;adr9int9;et0th;e6ie8;i2o0;r0urt3;tie5;ft1rst;ight0lev1;e0h,ie2;en1;illion0;th",
    "Cardinal": "truebHeEf8hundred,mHnineAone,qu6s4t0zero;en,h2rGw0;e0o;lve,n8;irt9ousandEree;e0ix5;pt1ven4xt1;adr0int0;illion;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illion0;!s",
    "Expression": "truea02b01dXeVfuck,gShLlImHnGoDpBshAtsk,u7voi04w3y0;a1eLu0;ck,p;!a,hoo,y;h1ow,t0;af,f;e0oa;e,w;gh,h0;! 0h,m;huh,oh;eesh,hh,it;ff,hew,l0sst;ease,z;h1o0w,y;h,o,ps;!h;ah,ope;eh,mm;m1ol0;!s;ao,fao;a4e2i,mm,oly1urr0;ah;! mo6;e,ll0y;!o;ha0i;!ha;ah,ee,o0rr;l0odbye;ly;e0h,t cetera,ww;k,p;'oh,a0uh;m0ng;mit,n0;!it;ah,oo,ye; 1h0rgh;!em;la",
    "Adverb": "truea07by 05d01eYfShQinPjustOkinda,mMnJoEpCquite,r9s5t2up1very,w0Bye0;p,s; to,wards5;h1o0wiO;o,t6ward;en,us;everal,o0uch;!me1rt0; of;hXtimes,w07;a1e0;alS;ndomRthN;ar excellDer0oint blank; Mhaps;f3n0;ce0ly;! 0;ag00moU; courHten;ewJo0; longEt 0;onHwithstanding;aybe,eanwhiAore0;!ovB;! aboS;deed,steT;en0;ce;or2u0;l9rther0;!moH; 0ev3;examp0good,suF;le;n mas1v0;er;se;e0irect1; 1finite0;ly;ju7trop;far,n0;ow; CbroBd nauseam,gAl5ny2part,side,t 0w3;be5l0mo5wor5;arge,ea4;mo1w0;ay;re;l 1mo0one,ready,so,ways;st;b1t0;hat;ut;ain;ad;lot,posteriori",
    "Preposition": "true'o,-,aKbHcGdFexcept,fEinDmidPnotwithstandiQoBpRqua,sAt6u3vi2w0;/o,hereMith0;!in,oQ;a,s-a-vis;n1p0;!on;like,til;h0ill,owards;an,r0;ough0u;!oI;ans,ince,o that;',f0n1ut;!f;!to;or,rom;espite,own,u3;hez,irca;ar1e0oAy;low,sides,tween;ri6;',bo7cross,ft6lo5m3propos,round,s1t0;!op;! long 0;as;id0ong0;!st;ng;er;ut",
    "Determiner": "trueaAboth,d8e5few,l3mu7neiCown,plenty,some,th2various,wh0;at0ich0;evB;at,e3is,ose;a,e0;!ast,s;a1i6l0nough,very;!se;ch;e0u;!s;!n0;!o0y;th0;er"
  };

  var entity = ['Person', 'Place', 'Organization'];
  var nouns = {
    Noun: {
      notA: ['Verb', 'Adjective', 'Adverb']
    },
    // - singular
    Singular: {
      isA: 'Noun',
      notA: 'Plural'
    },
    //a specific thing that's capitalized
    ProperNoun: {
      isA: 'Noun'
    },
    // -- people
    Person: {
      isA: ['ProperNoun', 'Singular'],
      notA: ['Place', 'Organization', 'Date']
    },
    FirstName: {
      isA: 'Person'
    },
    MaleName: {
      isA: 'FirstName',
      notA: ['FemaleName', 'LastName']
    },
    FemaleName: {
      isA: 'FirstName',
      notA: ['MaleName', 'LastName']
    },
    LastName: {
      isA: 'Person',
      notA: ['FirstName']
    },
    NickName: {
      isA: 'Person',
      notA: ['FirstName', 'LastName']
    },
    Honorific: {
      isA: 'Noun',
      notA: ['FirstName', 'LastName', 'Value']
    },
    // -- places
    Place: {
      isA: 'Singular',
      notA: ['Person', 'Organization']
    },
    Country: {
      isA: ['Place', 'ProperNoun'],
      notA: ['City']
    },
    City: {
      isA: ['Place', 'ProperNoun'],
      notA: ['Country']
    },
    Region: {
      isA: ['Place', 'ProperNoun']
    },
    Address: {
      isA: 'Place'
    },
    //---Orgs---
    Organization: {
      isA: ['Singular', 'ProperNoun'],
      notA: ['Person', 'Place']
    },
    SportsTeam: {
      isA: 'Organization'
    },
    School: {
      isA: 'Organization'
    },
    Company: {
      isA: 'Organization'
    },
    // - plural
    Plural: {
      isA: 'Noun',
      notA: ['Singular']
    },
    //(not plural or singular)
    Uncountable: {
      isA: 'Noun'
    },
    Pronoun: {
      isA: 'Noun',
      notA: entity
    },
    //a word for someone doing something -'plumber'
    Actor: {
      isA: 'Noun',
      notA: entity
    },
    //a gerund-as-noun - 'swimming'
    Activity: {
      isA: 'Noun',
      notA: ['Person', 'Place']
    },
    //'kilograms'
    Unit: {
      isA: 'Noun',
      notA: entity
    },
    //'Canadians'
    Demonym: {
      isA: ['Noun', 'ProperNoun'],
      notA: entity
    },
    //`john's`
    Possessive: {
      isA: 'Noun' // notA: 'Pronoun',

    }
  };

  var verbs = {
    Verb: {
      notA: ['Noun', 'Adjective', 'Adverb', 'Value']
    },
    // walks
    PresentTense: {
      isA: 'Verb',
      notA: ['PastTense', 'Copula', 'FutureTense']
    },
    // neutral form - 'walk'
    Infinitive: {
      isA: 'PresentTense',
      notA: ['PastTense', 'Gerund']
    },
    // walking
    Gerund: {
      isA: 'PresentTense',
      notA: ['PastTense', 'Copula', 'FutureTense']
    },
    // walked
    PastTense: {
      isA: 'Verb',
      notA: ['FutureTense']
    },
    // will walk
    FutureTense: {
      isA: 'Verb'
    },
    // is
    Copula: {
      isA: 'Verb'
    },
    // would have
    Modal: {
      isA: 'Verb',
      notA: ['Infinitive']
    },
    // had walked
    PerfectTense: {
      isA: 'Verb',
      notA: 'Gerund'
    },
    Pluperfect: {
      isA: 'Verb'
    },
    // shown
    Participle: {
      isA: 'Verb'
    },
    // show up
    PhrasalVerb: {
      isA: 'Verb'
    },
    //'up' part
    Particle: {
      isA: 'PhrasalVerb'
    }
  };

  var values = {
    Value: {
      notA: ['Verb', 'Adjective', 'Adverb']
    },
    Ordinal: {
      isA: 'Value',
      notA: ['Cardinal']
    },
    Cardinal: {
      isA: 'Value',
      notA: ['Ordinal']
    },
    RomanNumeral: {
      isA: 'Cardinal',
      //can be a person, too
      notA: ['Ordinal', 'TextValue']
    },
    TextValue: {
      isA: 'Value',
      notA: ['NumericValue']
    },
    NumericValue: {
      isA: 'Value',
      notA: ['TextValue']
    },
    Money: {
      isA: 'Cardinal'
    },
    Percent: {
      isA: 'Value'
    }
  };

  var anything = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Value', 'QuestionWord'];
  var misc = {
    //--Adjectives--
    Adjective: {
      notA: ['Noun', 'Verb', 'Adverb', 'Value']
    },
    // adjectives that can conjugate
    Comparable: {
      isA: ['Adjective']
    },
    // better
    Comparative: {
      isA: ['Adjective']
    },
    // best
    Superlative: {
      isA: ['Adjective'],
      notA: ['Comparative']
    },
    NumberRange: {
      isA: ['Contraction']
    },
    Adverb: {
      notA: ['Noun', 'Verb', 'Adjective', 'Value']
    },
    // Dates:
    //not a noun, but usually is
    Date: {
      notA: ['Verb', 'Conjunction', 'Adverb', 'Preposition', 'Adjective']
    },
    Month: {
      isA: ['Date', 'Singular'],
      notA: ['Year', 'WeekDay', 'Time']
    },
    WeekDay: {
      isA: ['Date', 'Noun']
    },
    // '9:20pm'
    Time: {
      isA: ['Date'],
      notA: ['Value']
    },
    //glue
    Determiner: {
      notA: anything
    },
    Conjunction: {
      notA: anything
    },
    Preposition: {
      notA: anything
    },
    // what, who, why
    QuestionWord: {
      notA: ['Determiner']
    },
    // peso, euro
    Currency: {},
    // ughh
    Expression: {
      notA: ['Noun', 'Adjective', 'Verb', 'Adverb']
    },
    // dr.
    Abbreviation: {},
    // internet tags
    Url: {
      notA: ['HashTag', 'PhoneNumber', 'Verb', 'Adjective', 'Value', 'AtMention', 'Email']
    },
    PhoneNumber: {
      notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention', 'Email']
    },
    HashTag: {},
    AtMention: {
      isA: ['Noun'],
      notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'Email']
    },
    Emoji: {
      notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention']
    },
    Emoticon: {
      notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention']
    },
    Email: {
      notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention']
    },
    //non-exclusive
    Auxiliary: {
      notA: ['Noun', 'Adjective', 'Value']
    },
    Acronym: {
      notA: ['Plural', 'RomanNumeral']
    },
    Negative: {
      notA: ['Noun', 'Adjective', 'Value']
    },
    // if, unless, were
    Condition: {
      notA: ['Verb', 'Adjective', 'Noun', 'Value']
    }
  };

  // i just made these up
  var colorMap = {
    Noun: 'blue',
    Verb: 'green',
    Negative: 'green',
    Date: 'red',
    Value: 'red',
    Adjective: 'magenta',
    Preposition: 'cyan',
    Conjunction: 'cyan',
    Determiner: 'cyan',
    Adverb: 'cyan'
  };
  /** add a debug color to some tags */

  var addColors = function addColors(tags) {
    Object.keys(tags).forEach(function (k) {
      // assigned from plugin, for example
      if (tags[k].color) {
        tags[k].color = tags[k].color;
        return;
      } // defined above


      if (colorMap[k]) {
        tags[k].color = colorMap[k];
        return;
      }

      tags[k].isA.some(function (t) {
        if (colorMap[t]) {
          tags[k].color = colorMap[t];
          return true;
        }

        return false;
      });
    });
    return tags;
  };

  var _color = addColors;

  var unique$2 = function unique(arr) {
    return arr.filter(function (v, i, a) {
      return a.indexOf(v) === i;
    });
  }; //add 'downward' tags (that immediately depend on this one)


  var inferIsA = function inferIsA(tags) {
    Object.keys(tags).forEach(function (k) {
      var tag = tags[k];
      var len = tag.isA.length;

      for (var i = 0; i < len; i++) {
        var down = tag.isA[i];

        if (tags[down]) {
          tag.isA = tag.isA.concat(tags[down].isA);
        }
      } // clean it up


      tag.isA = unique$2(tag.isA);
    });
    return tags;
  };

  var _isA = inferIsA;

  var unique$3 = function unique(arr) {
    return arr.filter(function (v, i, a) {
      return a.indexOf(v) === i;
    });
  }; // crawl the tag-graph and infer any conflicts
  // faster than doing this at tag-time


  var inferNotA = function inferNotA(tags) {
    var keys = Object.keys(tags);
    keys.forEach(function (k) {
      var tag = tags[k];
      tag.notA = tag.notA || [];
      tag.isA.forEach(function (down) {
        if (tags[down] && tags[down].notA) {
          // borrow its conflicts
          var notA = typeof tags[down].notA === 'string' ? [tags[down].isA] : tags[down].notA || [];
          tag.notA = tag.notA.concat(notA);
        }
      }); // any tag that lists us as a conflict, we conflict it back.

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (tags[key].notA.indexOf(k) !== -1) {
          tag.notA.push(key);
        }
      } // clean it up


      tag.notA = unique$3(tag.notA);
    });
    return tags;
  };

  var _notA = inferNotA;

  // a lineage is all 'incoming' tags that have this as 'isA'
  var inferLineage = function inferLineage(tags) {
    var keys = Object.keys(tags);
    keys.forEach(function (k) {
      var tag = tags[k];
      tag.lineage = []; // find all tags with it in their 'isA' set

      for (var i = 0; i < keys.length; i++) {
        if (tags[keys[i]].isA.indexOf(k) !== -1) {
          tag.lineage.push(keys[i]);
        }
      }
    });
    return tags;
  };

  var _lineage = inferLineage;

  var validate = function validate(tags) {
    // cleanup format
    Object.keys(tags).forEach(function (k) {
      var tag = tags[k]; // ensure isA is an array

      tag.isA = tag.isA || [];

      if (typeof tag.isA === 'string') {
        tag.isA = [tag.isA];
      } // ensure notA is an array


      tag.notA = tag.notA || [];

      if (typeof tag.notA === 'string') {
        tag.notA = [tag.notA];
      }
    });
    return tags;
  }; // build-out the tag-graph structure


  var inferTags = function inferTags(tags) {
    // validate data
    tags = validate(tags); // build its 'down tags'

    tags = _isA(tags); // infer the conflicts

    tags = _notA(tags); // debug tag color

    tags = _color(tags); // find incoming links

    tags = _lineage(tags);
    return tags;
  };

  var inference = inferTags;

  var addIn = function addIn(obj, tags) {
    Object.keys(obj).forEach(function (k) {
      tags[k] = obj[k];
    });
  };

  var build = function build() {
    var tags = {};
    addIn(nouns, tags);
    addIn(verbs, tags);
    addIn(values, tags);
    addIn(misc, tags); // do the graph-stuff

    tags = inference(tags);
    return tags;
  };

  var tags = build();

  var seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      cache = seq.split("").reduce(function (n, o, e) {
    return n[o] = e, n;
  }, {}),
      toAlphaCode = function toAlphaCode(n) {
    if (void 0 !== seq[n]) return seq[n];
    var o = 1,
        e = 36,
        t = "";

    for (; n >= e; n -= e, o++, e *= 36) {
    }

    for (; o--;) {
      var _o = n % 36;

      t = String.fromCharCode((_o < 10 ? 48 : 55) + _o) + t, n = (n - _o) / 36;
    }

    return t;
  },
      fromAlphaCode = function fromAlphaCode(n) {
    if (void 0 !== cache[n]) return cache[n];
    var o = 0,
        e = 1,
        t = 36,
        r = 1;

    for (; e < n.length; o += t, e++, t *= 36) {
    }

    for (var _e = n.length - 1; _e >= 0; _e--, r *= 36) {
      var _t = n.charCodeAt(_e) - 48;

      _t > 10 && (_t -= 7), o += _t * r;
    }

    return o;
  };

  var encoding = {
    toAlphaCode: toAlphaCode,
    fromAlphaCode: fromAlphaCode
  },
      symbols = function symbols(n) {
    var o = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");

    for (var e = 0; e < n.nodes.length; e++) {
      var t = o.exec(n.nodes[e]);

      if (!t) {
        n.symCount = e;
        break;
      }

      n.syms[encoding.fromAlphaCode(t[1])] = encoding.fromAlphaCode(t[2]);
    }

    n.nodes = n.nodes.slice(n.symCount, n.nodes.length);
  };

  var indexFromRef = function indexFromRef(n, o, e) {
    var t = encoding.fromAlphaCode(o);
    return t < n.symCount ? n.syms[t] : e + t + 1 - n.symCount;
  },
      toArray = function toArray(n) {
    var o = [],
        e = function e(t, r) {
      var s = n.nodes[t];
      "!" === s[0] && (o.push(r), s = s.slice(1));
      var c = s.split(/([A-Z0-9,]+)/g);

      for (var _s = 0; _s < c.length; _s += 2) {
        var u = c[_s],
            i = c[_s + 1];
        if (!u) continue;
        var l = r + u;

        if ("," === i || void 0 === i) {
          o.push(l);
          continue;
        }

        var f = indexFromRef(n, i, t);
        e(f, l);
      }
    };

    return e(0, ""), o;
  },
      unpack = function unpack(n) {
    var o = {
      nodes: n.split(";"),
      syms: [],
      symCount: 0
    };
    return n.match(":") && symbols(o), toArray(o);
  };

  var unpack_1 = unpack,
      unpack_1$1 = function unpack_1$1(n) {
    var o = n.split("|").reduce(function (n, o) {
      var e = o.split("");
      return n[e[0]] = e[1], n;
    }, {}),
        e = {};
    return Object.keys(o).forEach(function (n) {
      var t = unpack_1(o[n]);
      "true" === n && (n = !0);

      for (var _o2 = 0; _o2 < t.length; _o2++) {
        var r = t[_o2];
        !0 === e.hasOwnProperty(r) ? !1 === Array.isArray(e[r]) ? e[r] = [e[r], n] : e[r].push(n) : e[r] = n;
      }
    }), e;
  };

  var efrtUnpack_min = unpack_1$1;

  //safely add it to the lexicon
  var addWord = function addWord(word, tag, lex) {
    if (lex[word] !== undefined && 
        typeof lex[word] != 'function') {     // @blab+ override prototype of object!!!
      if (typeof lex[word] === 'string') {
        lex[word] = [lex[word]];
      }
      if (typeof tag === 'string') {
        lex[word].push(tag);
      } else {
        lex[word] = lex[word].concat(tag);
      }
    } else {
      lex[word] = tag;
    }
  }; // blast-out more forms for some given words


  var addMore = function addMore(word, tag, world) {
    var lexicon = world.words;
    var transform = world.transforms; // cache multi-words

    var words = word.split(' ');

    if (words.length > 1) {
      //cache the beginning word
      world.hasCompound[words[0]] = true;
    } // inflect our nouns


    if (tag === 'Singular') {
      var plural = transform.toPlural(word, world);
      lexicon[plural] = lexicon[plural] || 'Plural'; // only if it's safe
    } //conjugate our verbs


    if (tag === 'Infinitive') {
      var conj = transform.conjugate(word, world);
      var tags = Object.keys(conj);

      for (var i = 0; i < tags.length; i++) {
        var w = conj[tags[i]];
        lexicon[w] = lexicon[w] || tags[i]; // only if it's safe
      }
    } //derive more adjective forms


    if (tag === 'Comparable') {
      var _conj = transform.adjectives(word);

      var _tags = Object.keys(_conj);

      for (var _i = 0; _i < _tags.length; _i++) {
        var _w = _conj[_tags[_i]];
        lexicon[_w] = lexicon[_w] || _tags[_i]; // only if it's safe
      }
    } //conjugate phrasal-verbs


    if (tag === 'PhrasalVerb') {
      //add original form
      addWord(word, 'Infinitive', lexicon); //conjugate first word

      var _conj2 = transform.conjugate(words[0], world);

      var _tags2 = Object.keys(_conj2);

      for (var _i2 = 0; _i2 < _tags2.length; _i2++) {
        //add it to our cache
        world.hasCompound[_conj2[_tags2[_i2]]] = true; //first + last words

        var _w2 = _conj2[_tags2[_i2]] + ' ' + words[1];

        addWord(_w2, _tags2[_i2], lexicon);
        addWord(_w2, 'PhrasalVerb', lexicon);
      }
    } // inflect our demonyms - 'germans'


    if (tag === 'Demonym') {
      var _plural = transform.toPlural(word, world);

      lexicon[_plural] = lexicon[_plural] || ['Demonym', 'Plural']; // only if it's safe
    }
  }; // throw a bunch of words in our lexicon
  // const doWord = function(words, tag, world) {
  //   let lexicon = world.words
  //   for (let i = 0; i < words.length; i++) {
  //     addWord(words[i], tag, lexicon)
  //     // do some fancier stuff
  //     addMore(words[i], tag, world)
  //   }
  // }


  var addWords = {
    addWord: addWord,
    addMore: addMore
  };

  // add words from plurals and conjugations data
  var addIrregulars = function addIrregulars(world) {
    //add irregular plural nouns
    var nouns = world.irregulars.nouns;
    var words = Object.keys(nouns);

    for (var i = 0; i < words.length; i++) {
      var w = words[i];
      world.words[w] = 'Singular';
      world.words[nouns[w]] = 'Plural';
    } // add irregular verb conjugations


    var verbs = world.irregulars.verbs;
    var keys = Object.keys(verbs);

    var _loop = function _loop(_i) {
      var inf = keys[_i]; //add only if it it's safe...

      world.words[inf] = world.words[inf] || 'Infinitive';
      var forms = world.transforms.conjugate(inf, world);
      forms = Object.assign(forms, verbs[inf]); //add the others

      Object.keys(forms).forEach(function (tag) {
        world.words[forms[tag]] = world.words[forms[tag]] || tag;
      });
    };

    for (var _i = 0; _i < keys.length; _i++) {
      _loop(_i);
    }
  };

  var addIrregulars_1 = addIrregulars;

  //words that can't be compressed, for whatever reason
  var misc$1 = {
    // numbers
    '20th century fox': 'Organization',
    // '3m': 'Organization',
    '7 eleven': 'Organization',
    '7-eleven': 'Organization',
    g8: 'Organization',
    'motel 6': 'Organization',
    vh1: 'Organization',
    q1: 'Date',
    q2: 'Date',
    q3: 'Date',
    q4: 'Date'
  };

  //nouns with irregular plural/singular forms
  //used in noun.inflect, and also in the lexicon.
  var plurals = {
    addendum: 'addenda',
    alga: 'algae',
    alumna: 'alumnae',
    alumnus: 'alumni',
    analysis: 'analyses',
    antenna: 'antennae',
    appendix: 'appendices',
    avocado: 'avocados',
    axis: 'axes',
    bacillus: 'bacilli',
    barracks: 'barracks',
    beau: 'beaux',
    bus: 'buses',
    cactus: 'cacti',
    chateau: 'chateaux',
    child: 'children',
    circus: 'circuses',
    clothes: 'clothes',
    corpus: 'corpora',
    criterion: 'criteria',
    curriculum: 'curricula',
    database: 'databases',
    deer: 'deer',
    diagnosis: 'diagnoses',
    echo: 'echoes',
    embargo: 'embargoes',
    epoch: 'epochs',
    foot: 'feet',
    formula: 'formulae',
    fungus: 'fungi',
    genus: 'genera',
    goose: 'geese',
    halo: 'halos',
    hippopotamus: 'hippopotami',
    index: 'indices',
    larva: 'larvae',
    leaf: 'leaves',
    libretto: 'libretti',
    loaf: 'loaves',
    man: 'men',
    matrix: 'matrices',
    memorandum: 'memoranda',
    modulus: 'moduli',
    mosquito: 'mosquitoes',
    mouse: 'mice',
    move: 'moves',
    nebula: 'nebulae',
    nucleus: 'nuclei',
    octopus: 'octopi',
    opus: 'opera',
    ovum: 'ova',
    ox: 'oxen',
    parenthesis: 'parentheses',
    person: 'people',
    phenomenon: 'phenomena',
    prognosis: 'prognoses',
    quiz: 'quizzes',
    radius: 'radii',
    referendum: 'referenda',
    rodeo: 'rodeos',
    sex: 'sexes',
    shoe: 'shoes',
    sombrero: 'sombreros',
    stimulus: 'stimuli',
    stomach: 'stomachs',
    syllabus: 'syllabi',
    synopsis: 'synopses',
    tableau: 'tableaux',
    thesis: 'theses',
    thief: 'thieves',
    tooth: 'teeth',
    tornado: 'tornados',
    tuxedo: 'tuxedos',
    vertebra: 'vertebrae' // virus: 'viri',
    // zero: 'zeros',

  };

  // a list of irregular verb conjugations
  // used in verbs().conjugate()
  // but also added to our lexicon
  //use shorter key-names
  var mapping = {
    g: 'Gerund',
    prt: 'Participle',
    perf: 'PerfectTense',
    pst: 'PastTense',
    fut: 'FuturePerfect',
    pres: 'PresentTense',
    pluperf: 'Pluperfect',
    a: 'Actor'
  }; // '_' in conjugations is the infinitive form

  var conjugations = {
    act: {
      a: '_or'
    },
    ache: {
      pst: 'ached',
      g: 'aching'
    },
    age: {
      g: 'ageing',
      pst: 'aged',
      pres: 'ages'
    },
    aim: {
      a: '_er',
      g: '_ing',
      pst: '_ed'
    },
    arise: {
      prt: '_n',
      pst: 'arose'
    },
    babysit: {
      a: '_ter',
      pst: 'babysat'
    },
    ban: {
      a: '',
      g: '_ning',
      pst: '_ned'
    },
    be: {
      a: '',
      g: 'am',
      prt: 'been',
      pst: 'was',
      pres: 'is'
    },
    beat: {
      a: '_er',
      g: '_ing',
      prt: '_en'
    },
    become: {
      prt: '_'
    },
    begin: {
      g: '_ning',
      prt: 'begun',
      pst: 'began'
    },
    being: {
      g: 'are',
      pst: 'were',
      pres: 'are'
    },
    bend: {
      prt: 'bent'
    },
    bet: {
      a: '_ter',
      prt: '_'
    },
    bind: {
      pst: 'bound'
    },
    bite: {
      g: 'biting',
      prt: 'bitten',
      pst: 'bit'
    },
    bleed: {
      prt: 'bled',
      pst: 'bled'
    },
    blow: {
      prt: '_n',
      pst: 'blew'
    },
    boil: {
      a: '_er'
    },
    brake: {
      prt: 'broken'
    },
    "break": {
      pst: 'broke'
    },
    breed: {
      pst: 'bred'
    },
    bring: {
      prt: 'brought',
      pst: 'brought'
    },
    broadcast: {
      pst: '_'
    },
    budget: {
      pst: '_ed'
    },
    build: {
      prt: 'built',
      pst: 'built'
    },
    burn: {
      prt: '_ed'
    },
    burst: {
      prt: '_'
    },
    buy: {
      prt: 'bought',
      pst: 'bought'
    },
    can: {
      a: '',
      fut: '_',
      g: '',
      pst: 'could',
      perf: 'could',
      pluperf: 'could',
      pres: '_'
    },
    "catch": {
      pst: 'caught'
    },
    choose: {
      g: 'choosing',
      prt: 'chosen',
      pst: 'chose'
    },
    cling: {
      prt: 'clung'
    },
    come: {
      prt: '_',
      pst: 'came',
      g: 'coming'
    },
    compete: {
      a: 'competitor',
      g: 'competing',
      pst: '_d'
    },
    cost: {
      pst: '_'
    },
    creep: {
      prt: 'crept'
    },
    cut: {
      prt: '_'
    },
    deal: {
      prt: '_t',
      pst: '_t'
    },
    develop: {
      a: '_er',
      g: '_ing',
      pst: '_ed'
    },
    die: {
      g: 'dying',
      pst: '_d'
    },
    dig: {
      g: '_ging',
      prt: 'dug',
      pst: 'dug'
    },
    dive: {
      prt: '_d'
    },
    "do": {
      pst: 'did',
      pres: '_es'
    },
    draw: {
      prt: '_n',
      pst: 'drew'
    },
    dream: {
      prt: '_t'
    },
    drink: {
      prt: 'drunk',
      pst: 'drank'
    },
    drive: {
      g: 'driving',
      prt: '_n',
      pst: 'drove'
    },
    drop: {
      g: '_ping',
      pst: '_ped'
    },
    eat: {
      a: '_er',
      g: '_ing',
      prt: '_en',
      pst: 'ate'
    },
    edit: {
      pst: '_ed',
      g: '_ing'
    },
    egg: {
      pst: '_ed'
    },
    fall: {
      prt: '_en',
      pst: 'fell'
    },
    feed: {
      prt: 'fed',
      pst: 'fed'
    },
    feel: {
      a: '_er',
      pst: 'felt'
    },
    fight: {
      prt: 'fought',
      pst: 'fought'
    },
    find: {
      pst: 'found'
    },
    flee: {
      g: '_ing',
      prt: 'fled'
    },
    fling: {
      prt: 'flung'
    },
    fly: {
      prt: 'flown',
      pst: 'flew'
    },
    forbid: {
      pst: 'forbade'
    },
    forget: {
      g: '_ing',
      prt: 'forgotten',
      pst: 'forgot'
    },
    forgive: {
      g: 'forgiving',
      prt: '_n',
      pst: 'forgave'
    },
    free: {
      a: '',
      g: '_ing'
    },
    freeze: {
      g: 'freezing',
      prt: 'frozen',
      pst: 'froze'
    },
    get: {
      pst: 'got',
      prt: 'gotten'
    },
    give: {
      g: 'giving',
      prt: '_n',
      pst: 'gave'
    },
    go: {
      prt: '_ne',
      pst: 'went',
      pres: 'goes'
    },
    grow: {
      prt: '_n'
    },
    hang: {
      prt: 'hung',
      pst: 'hung'
    },
    have: {
      g: 'having',
      prt: 'had',
      pst: 'had',
      pres: 'has'
    },
    hear: {
      prt: '_d',
      pst: '_d'
    },
    hide: {
      prt: 'hidden',
      pst: 'hid'
    },
    hit: {
      prt: '_'
    },
    hold: {
      prt: 'held',
      pst: 'held'
    },
    hurt: {
      prt: '_',
      pst: '_'
    },
    ice: {
      g: 'icing',
      pst: '_d'
    },
    imply: {
      pst: 'implied',
      pres: 'implies'
    },
    is: {
      a: '',
      g: 'being',
      pst: 'was',
      pres: '_'
    },
    keep: {
      prt: 'kept'
    },
    kneel: {
      prt: 'knelt'
    },
    know: {
      prt: '_n'
    },
    lay: {
      prt: 'laid',
      pst: 'laid'
    },
    lead: {
      prt: 'led',
      pst: 'led'
    },
    leap: {
      prt: '_t'
    },
    leave: {
      prt: 'left',
      pst: 'left'
    },
    lend: {
      prt: 'lent'
    },
    lie: {
      g: 'lying',
      pst: 'lay'
    },
    light: {
      prt: 'lit',
      pst: 'lit'
    },
    log: {
      g: '_ging',
      pst: '_ged'
    },
    loose: {
      prt: 'lost'
    },
    lose: {
      g: 'losing',
      pst: 'lost'
    },
    make: {
      prt: 'made',
      pst: 'made'
    },
    mean: {
      prt: '_t',
      pst: '_t'
    },
    meet: {
      a: '_er',
      g: '_ing',
      prt: 'met',
      pst: 'met'
    },
    miss: {
      pres: '_'
    },
    name: {
      g: 'naming'
    },
    pay: {
      prt: 'paid',
      pst: 'paid'
    },
    prove: {
      prt: '_n'
    },
    puke: {
      g: 'puking'
    },
    put: {
      prt: '_'
    },
    quit: {
      prt: '_'
    },
    read: {
      prt: '_',
      pst: '_'
    },
    ride: {
      prt: 'ridden'
    },
    ring: {
      prt: 'rung',
      pst: 'rang'
    },
    rise: {
      fut: 'will have _n',
      g: 'rising',
      prt: '_n',
      pst: 'rose',
      pluperf: 'had _n'
    },
    rub: {
      g: '_bing',
      pst: '_bed'
    },
    run: {
      g: '_ning',
      prt: '_',
      pst: 'ran'
    },
    say: {
      prt: 'said',
      pst: 'said',
      pres: '_s'
    },
    seat: {
      prt: 'sat'
    },
    see: {
      g: '_ing',
      prt: '_n',
      pst: 'saw'
    },
    seek: {
      prt: 'sought'
    },
    sell: {
      prt: 'sold',
      pst: 'sold'
    },
    send: {
      prt: 'sent'
    },
    set: {
      prt: '_'
    },
    sew: {
      prt: '_n'
    },
    shake: {
      prt: '_n'
    },
    shave: {
      prt: '_d'
    },
    shed: {
      g: '_ding',
      pst: '_',
      pres: '_s'
    },
    shine: {
      prt: 'shone',
      pst: 'shone'
    },
    shoot: {
      prt: 'shot',
      pst: 'shot'
    },
    show: {
      pst: '_ed'
    },
    shut: {
      prt: '_'
    },
    sing: {
      prt: 'sung',
      pst: 'sang'
    },
    sink: {
      pst: 'sank',
      pluperf: 'had sunk'
    },
    sit: {
      pst: 'sat'
    },
    ski: {
      pst: '_ied'
    },
    slay: {
      prt: 'slain'
    },
    sleep: {
      prt: 'slept'
    },
    slide: {
      prt: 'slid',
      pst: 'slid'
    },
    smash: {
      pres: '_es'
    },
    sneak: {
      prt: 'snuck'
    },
    speak: {
      fut: 'will have spoken',
      prt: 'spoken',
      pst: 'spoke',
      perf: 'have spoken',
      pluperf: 'had spoken'
    },
    speed: {
      prt: 'sped'
    },
    spend: {
      prt: 'spent'
    },
    spill: {
      prt: '_ed',
      pst: 'spilt'
    },
    spin: {
      g: '_ning',
      prt: 'spun',
      pst: 'spun'
    },
    spit: {
      prt: 'spat'
    },
    split: {
      prt: '_'
    },
    spread: {
      pst: '_'
    },
    spring: {
      prt: 'sprung'
    },
    stand: {
      pst: 'stood'
    },
    steal: {
      a: '_er',
      pst: 'stole'
    },
    stick: {
      pst: 'stuck'
    },
    sting: {
      pst: 'stung'
    },
    stink: {
      prt: 'stunk',
      pst: 'stunk'
    },
    stream: {
      a: '_er'
    },
    strew: {
      prt: '_n'
    },
    strike: {
      g: 'striking',
      pst: 'struck'
    },
    suit: {
      a: '_er',
      g: '_ing',
      pst: '_ed'
    },
    sware: {
      prt: 'sworn'
    },
    swear: {
      pst: 'swore'
    },
    sweep: {
      prt: 'swept'
    },
    swim: {
      g: '_ming',
      pst: 'swam'
    },
    swing: {
      pst: 'swung'
    },
    take: {
      fut: 'will have _n',
      pst: 'took',
      perf: 'have _n',
      pluperf: 'had _n'
    },
    teach: {
      pst: 'taught',
      pres: '_es'
    },
    tear: {
      pst: 'tore'
    },
    tell: {
      pst: 'told'
    },
    think: {
      pst: 'thought'
    },
    thrive: {
      prt: '_d'
    },
    tie: {
      g: 'tying',
      pst: '_d'
    },
    undergo: {
      prt: '_ne'
    },
    understand: {
      pst: 'understood'
    },
    upset: {
      prt: '_'
    },
    wait: {
      a: '_er',
      g: '_ing',
      pst: '_ed'
    },
    wake: {
      pst: 'woke'
    },
    wear: {
      pst: 'wore'
    },
    weave: {
      prt: 'woven'
    },
    wed: {
      pst: 'wed'
    },
    weep: {
      prt: 'wept'
    },
    win: {
      g: '_ning',
      pst: 'won'
    },
    wind: {
      prt: 'wound'
    },
    withdraw: {
      pst: 'withdrew'
    },
    wring: {
      prt: 'wrung'
    },
    write: {
      g: 'writing',
      prt: 'written',
      pst: 'wrote'
    }
  }; //uncompress our ad-hoc compression scheme

  var keys = Object.keys(conjugations);

  var _loop = function _loop(i) {
    var inf = keys[i];
    var _final = {};
    Object.keys(conjugations[inf]).forEach(function (key) {
      var str = conjugations[inf][key]; //swap-in infinitives for '_'

      str = str.replace('_', inf);
      var full = mapping[key];
      _final[full] = str;
    }); //over-write original

    conjugations[inf] = _final;
  };

  for (var i = 0; i < keys.length; i++) {
    _loop(i);
  }

  var conjugations_1 = conjugations;

  var endsWith = {
    b: [{
      reg: /([^aeiou][aeiou])b$/i,
      repl: {
        pr: '$1bs',
        pa: '$1bbed',
        gr: '$1bbing'
      }
    }],
    d: [{
      reg: /(end)$/i,
      repl: {
        pr: '$1s',
        pa: 'ent',
        gr: '$1ing',
        ar: '$1er'
      }
    }, {
      reg: /(eed)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ed',
        gr: '$1ing',
        ar: '$1er'
      }
    }, {
      reg: /(ed)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ded',
        ar: '$1der',
        gr: '$1ding'
      }
    }, {
      reg: /([^aeiou][ou])d$/i,
      repl: {
        pr: '$1ds',
        pa: '$1dded',
        gr: '$1dding'
      }
    }],
    e: [{
      reg: /(eave)$/i,
      repl: {
        pr: '$1s',
        pa: '$1d',
        gr: 'eaving',
        ar: '$1r'
      }
    }, {
      reg: /(ide)$/i,
      repl: {
        pr: '$1s',
        pa: 'ode',
        gr: 'iding',
        ar: 'ider'
      }
    }, {
      //shake
      reg: /(t|sh?)(ake)$/i,
      repl: {
        pr: '$1$2s',
        pa: '$1ook',
        gr: '$1aking',
        ar: '$1$2r'
      }
    }, {
      //awake
      reg: /w(ake)$/i,
      repl: {
        pr: 'w$1s',
        pa: 'woke',
        gr: 'waking',
        ar: 'w$1r'
      }
    }, {
      //make
      reg: /m(ake)$/i,
      repl: {
        pr: 'm$1s',
        pa: 'made',
        gr: 'making',
        ar: 'm$1r'
      }
    }, {
      reg: /(a[tg]|i[zn]|ur|nc|gl|is)e$/i,
      repl: {
        pr: '$1es',
        pa: '$1ed',
        gr: '$1ing' // prt: '$1en',

      }
    }, {
      reg: /([bd]l)e$/i,
      repl: {
        pr: '$1es',
        pa: '$1ed',
        gr: '$1ing'
      }
    }, {
      reg: /(om)e$/i,
      repl: {
        pr: '$1es',
        pa: 'ame',
        gr: '$1ing'
      }
    }],
    g: [{
      reg: /([^aeiou][ou])g$/i,
      repl: {
        pr: '$1gs',
        pa: '$1gged',
        gr: '$1gging'
      }
    }],
    h: [{
      reg: /(..)([cs]h)$/i,
      repl: {
        pr: '$1$2es',
        pa: '$1$2ed',
        gr: '$1$2ing'
      }
    }],
    k: [{
      reg: /(ink)$/i,
      repl: {
        pr: '$1s',
        pa: 'unk',
        gr: '$1ing',
        ar: '$1er'
      }
    }],
    m: [{
      reg: /([^aeiou][aeiou])m$/i,
      repl: {
        pr: '$1ms',
        pa: '$1mmed',
        gr: '$1mming'
      }
    }],
    n: [{
      reg: /(en)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ed',
        gr: '$1ing'
      }
    }],
    p: [{
      reg: /(e)(ep)$/i,
      repl: {
        pr: '$1$2s',
        pa: '$1pt',
        gr: '$1$2ing',
        ar: '$1$2er'
      }
    }, {
      reg: /([^aeiou][aeiou])p$/i,
      repl: {
        pr: '$1ps',
        pa: '$1pped',
        gr: '$1pping'
      }
    }, {
      reg: /([aeiu])p$/i,
      repl: {
        pr: '$1ps',
        pa: '$1p',
        gr: '$1pping'
      }
    }],
    r: [{
      reg: /([td]er)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ed',
        gr: '$1ing'
      }
    }, {
      reg: /(er)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ed',
        gr: '$1ing'
      }
    }],
    s: [{
      reg: /(ish|tch|ess)$/i,
      repl: {
        pr: '$1es',
        pa: '$1ed',
        gr: '$1ing'
      }
    }],
    t: [{
      reg: /(ion|end|e[nc]t)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ed',
        gr: '$1ing'
      }
    }, {
      reg: /(.eat)$/i,
      repl: {
        pr: '$1s',
        pa: '$1ed',
        gr: '$1ing'
      }
    }, {
      reg: /([aeiu])t$/i,
      repl: {
        pr: '$1ts',
        pa: '$1t',
        gr: '$1tting'
      }
    }, {
      reg: /([^aeiou][aeiou])t$/i,
      repl: {
        pr: '$1ts',
        pa: '$1tted',
        gr: '$1tting'
      }
    }],
    w: [{
      reg: /(..)(ow)$/i,
      repl: {
        pr: '$1$2s',
        pa: '$1ew',
        gr: '$1$2ing',
        prt: '$1$2n'
      }
    }],
    y: [{
      reg: /([i|f|rr])y$/i,
      repl: {
        pr: '$1ies',
        pa: '$1ied',
        gr: '$1ying'
      }
    }],
    z: [{
      reg: /([aeiou]zz)$/i,
      repl: {
        pr: '$1es',
        pa: '$1ed',
        gr: '$1ing'
      }
    }]
  };
  var suffixes = endsWith;

  var posMap = {
    pr: 'PresentTense',
    pa: 'PastTense',
    gr: 'Gerund',
    prt: 'Participle',
    ar: 'Actor'
  };

  var doTransform = function doTransform(str, obj) {
    var found = {};
    var keys = Object.keys(obj.repl);

    for (var i = 0; i < keys.length; i += 1) {
      var pos = keys[i];
      found[posMap[pos]] = str.replace(obj.reg, obj.repl[pos]);
    }

    return found;
  }; //look at the end of the word for clues


  var checkSuffix = function checkSuffix() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var c = str[str.length - 1];

    if (suffixes.hasOwnProperty(c) === true) {
      for (var r = 0; r < suffixes[c].length; r += 1) {
        var reg = suffixes[c][r].reg;

        if (reg.test(str) === true) {
          return doTransform(str, suffixes[c][r]);
        }
      }
    }

    return {};
  };

  var _01Suffixes = checkSuffix;

  //non-specifc, 'hail-mary' transforms from infinitive, into other forms
  var hasY = /[bcdfghjklmnpqrstvwxz]y$/;
  var generic = {
    Gerund: function Gerund(inf) {
      if (inf.charAt(inf.length - 1) === 'e') {
        return inf.replace(/e$/, 'ing');
      }

      return inf + 'ing';
    },
    PresentTense: function PresentTense(inf) {
      if (inf.charAt(inf.length - 1) === 's') {
        return inf + 'es';
      }

      if (hasY.test(inf) === true) {
        return inf.slice(0, -1) + 'ies';
      }

      return inf + 's';
    },
    PastTense: function PastTense(inf) {
      if (inf.charAt(inf.length - 1) === 'e') {
        return inf + 'd';
      }

      if (inf.substr(-2) === 'ed') {
        return inf;
      }

      if (hasY.test(inf) === true) {
        return inf.slice(0, -1) + 'ied';
      }

      return inf + 'ed';
    }
  };
  var _02Generic = generic;

  //we assume the input word is a proper infinitive

  var conjugate = function conjugate() {
    var inf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var world = arguments.length > 1 ? arguments[1] : undefined;
    var found = {}; // 1. look at irregulars
    //the lexicon doesn't pass this in

    if (world && world.irregulars) {
      if (world.irregulars.verbs.hasOwnProperty(inf) === true) {
        found = Object.assign({}, world.irregulars.verbs[inf]);
      }
    } //2. rule-based regex


    found = Object.assign({}, _01Suffixes(inf), found); //3. generic transformations
    //'buzzing'

    if (found.Gerund === undefined) {
      found.Gerund = _02Generic.Gerund(inf);
    } //'buzzed'


    if (found.PastTense === undefined) {
      found.PastTense = _02Generic.PastTense(inf);
    } //'buzzes'


    if (found.PresentTense === undefined) {
      found.PresentTense = _02Generic.PresentTense(inf);
    }

    return found;
  };

  var conjugate_1 = conjugate; // console.log(conjugate('bake'))

  //turn 'quick' into 'quickest'
  var do_rules = [/ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /oud$/, /...p$/];
  var dont_rules = [/ary$/];
  var irregulars = {
    nice: 'nicest',
    late: 'latest',
    hard: 'hardest',
    inner: 'innermost',
    outer: 'outermost',
    far: 'furthest',
    worse: 'worst',
    bad: 'worst',
    good: 'best',
    big: 'biggest',
    large: 'largest'
  };
  var transforms = [{
    reg: /y$/i,
    repl: 'iest'
  }, {
    reg: /([aeiou])t$/i,
    repl: '$1ttest'
  }, {
    reg: /([aeou])de$/i,
    repl: '$1dest'
  }, {
    reg: /nge$/i,
    repl: 'ngest'
  }, {
    reg: /([aeiou])te$/i,
    repl: '$1test'
  }];

  var to_superlative = function to_superlative(str) {
    //irregulars
    if (irregulars.hasOwnProperty(str)) {
      return irregulars[str];
    } //known transforms


    for (var i = 0; i < transforms.length; i++) {
      if (transforms[i].reg.test(str)) {
        return str.replace(transforms[i].reg, transforms[i].repl);
      }
    } //dont-rules


    for (var _i = 0; _i < dont_rules.length; _i++) {
      if (dont_rules[_i].test(str) === true) {
        return null;
      }
    } //do-rules


    for (var _i2 = 0; _i2 < do_rules.length; _i2++) {
      if (do_rules[_i2].test(str) === true) {
        if (str.charAt(str.length - 1) === 'e') {
          return str + 'st';
        }

        return str + 'est';
      }
    }

    return str + 'est';
  };

  var toSuperlative = to_superlative;

  //turn 'quick' into 'quickly'
  var do_rules$1 = [/ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /old$/, /oud$/, /e[ae]p$/];
  var dont_rules$1 = [/ary$/, /ous$/];
  var irregulars$1 = {
    grey: 'greyer',
    gray: 'grayer',
    green: 'greener',
    yellow: 'yellower',
    red: 'redder',
    good: 'better',
    well: 'better',
    bad: 'worse',
    sad: 'sadder',
    big: 'bigger'
  };
  var transforms$1 = [{
    reg: /y$/i,
    repl: 'ier'
  }, {
    reg: /([aeiou])t$/i,
    repl: '$1tter'
  }, {
    reg: /([aeou])de$/i,
    repl: '$1der'
  }, {
    reg: /nge$/i,
    repl: 'nger'
  }];

  var to_comparative = function to_comparative(str) {
    //known-irregulars
    if (irregulars$1.hasOwnProperty(str)) {
      return irregulars$1[str];
    } //known-transforms


    for (var i = 0; i < transforms$1.length; i++) {
      if (transforms$1[i].reg.test(str) === true) {
        return str.replace(transforms$1[i].reg, transforms$1[i].repl);
      }
    } //dont-patterns


    for (var _i = 0; _i < dont_rules$1.length; _i++) {
      if (dont_rules$1[_i].test(str) === true) {
        return null;
      }
    } //do-patterns


    for (var _i2 = 0; _i2 < do_rules$1.length; _i2++) {
      if (do_rules$1[_i2].test(str) === true) {
        return str + 'er';
      }
    } //easy-one


    if (/e$/.test(str) === true) {
      return str + 'r';
    }

    return str + 'er';
  };

  var toComparative = to_comparative;

  var fns$1 = {
    toSuperlative: toSuperlative,
    toComparative: toComparative
  };
  /** conjugate an adjective into other forms */

  var conjugate$1 = function conjugate(w) {
    var res = {}; // 'greatest'

    var sup = fns$1.toSuperlative(w);

    if (sup) {
      res.Superlative = sup;
    } // 'greater'


    var comp = fns$1.toComparative(w);

    if (comp) {
      res.Comparative = comp;
    }

    return res;
  };

  var adjectives = conjugate$1;

  /** patterns for turning 'bus' to 'buses'*/
  var suffixes$1 = {
    a: [[/(antenn|formul|nebul|vertebr|vit)a$/i, '$1ae'], [/([ti])a$/i, '$1a']],
    e: [[/(kn|l|w)ife$/i, '$1ives'], [/(hive)$/i, '$1s'], [/([m|l])ouse$/i, '$1ice'], [/([m|l])ice$/i, '$1ice']],
    f: [[/^(dwar|handkerchie|hoo|scar|whar)f$/i, '$1ves'], [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, '$1ves']],
    i: [[/(octop|vir)i$/i, '$1i']],
    m: [[/([ti])um$/i, '$1a']],
    n: [[/^(oxen)$/i, '$1']],
    o: [[/(al|ad|at|er|et|ed|ad)o$/i, '$1oes']],
    s: [[/(ax|test)is$/i, '$1es'], [/(alias|status)$/i, '$1es'], [/sis$/i, 'ses'], [/(bu)s$/i, '$1ses'], [/(sis)$/i, 'ses'], [/^(?!talis|.*hu)(.*)man$/i, '$1men'], [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, '$1i']],
    x: [[/(matr|vert|ind|cort)(ix|ex)$/i, '$1ices'], [/^(ox)$/i, '$1en']],
    y: [[/([^aeiouy]|qu)y$/i, '$1ies']],
    z: [[/(quiz)$/i, '$1zes']]
  };
  var _rules = suffixes$1;

  var addE = /(x|ch|sh|s|z)$/;

  var trySuffix = function trySuffix(str) {
    var c = str[str.length - 1];

    if (_rules.hasOwnProperty(c) === true) {
      for (var i = 0; i < _rules[c].length; i += 1) {
        var reg = _rules[c][i][0];

        if (reg.test(str) === true) {
          return str.replace(reg, _rules[c][i][1]);
        }
      }
    }

    return null;
  };
  /** Turn a singular noun into a plural
   * assume the given string is singular
   */


  var pluralize = function pluralize() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var world = arguments.length > 1 ? arguments[1] : undefined;
    var irregulars = world.irregulars.nouns; // check irregulars list

    if (irregulars.hasOwnProperty(str)) {
      return irregulars[str];
    } //we have some rules to try-out


    var plural = trySuffix(str);

    if (plural !== null) {
      return plural;
    } //like 'church'


    if (addE.test(str)) {
      return str + 'es';
    } // \_()_/


    return str + 's';
  };

  var toPlural = pluralize;

  //patterns for turning 'dwarves' to 'dwarf'
  var _rules$1 = [[/([^v])ies$/i, '$1y'], [/ises$/i, 'isis'], [/(kn|[^o]l|w)ives$/i, '$1ife'], [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, '$1f'], [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, '$1f'], [/(antenn|formul|nebul|vertebr|vit)ae$/i, '$1a'], [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, '$1us'], [/(buffal|tomat|tornad)(oes)$/i, '$1o'], // [/(analy|diagno|parenthe|progno|synop|the)ses$/i, '$1sis'],
  [/(eas)es$/i, '$1e'], //diseases
  [/(..[aeiou]s)es$/i, '$1'], //geniouses
  [/(vert|ind|cort)(ices)$/i, '$1ex'], [/(matr|append)(ices)$/i, '$1ix'], [/(x|ch|ss|sh|z|o)es$/i, '$1'], [/men$/i, 'man'], [/(n)ews$/i, '$1ews'], [/([ti])a$/i, '$1um'], [/([^aeiouy]|qu)ies$/i, '$1y'], [/(s)eries$/i, '$1eries'], [/(m)ovies$/i, '$1ovie'], [/([m|l])ice$/i, '$1ouse'], [/(cris|ax|test)es$/i, '$1is'], [/(alias|status)es$/i, '$1'], [/(ss)$/i, '$1'], [/(ics)$/i, '$1'], [/s$/i, '']];

  var invertObj = function invertObj(obj) {
    return Object.keys(obj).reduce(function (h, k) {
      h[obj[k]] = k;
      return h;
    }, {});
  };

  var toSingular = function toSingular(str, world) {
    var irregulars = world.irregulars.nouns;
    var invert = invertObj(irregulars); //(not very efficient)
    // check irregulars list

    if (invert.hasOwnProperty(str)) {
      return invert[str];
    } // go through our regexes


    for (var i = 0; i < _rules$1.length; i++) {
      if (_rules$1[i][0].test(str) === true) {
        str = str.replace(_rules$1[i][0], _rules$1[i][1]);
        return str;
      }
    }

    return str;
  };

  var toSingular_1 = toSingular;

  //rules for turning a verb into infinitive form
  var rules = {
    Participle: [{
      reg: /own$/i,
      to: 'ow'
    }, {
      reg: /(.)un([g|k])$/i,
      to: '$1in$2'
    }],
    Actor: [{
      reg: /(er)er$/i,
      to: '$1'
    }],
    PresentTense: [{
      reg: /(..)(ies)$/i,
      to: '$1y'
    }, {
      reg: /(tch|sh)es$/i,
      to: '$1'
    }, {
      reg: /(ss|zz)es$/i,
      to: '$1'
    }, {
      reg: /([tzlshicgrvdnkmu])es$/i,
      to: '$1e'
    }, {
      reg: /(n[dtk]|c[kt]|[eo]n|i[nl]|er|a[ytrl])s$/i,
      to: '$1'
    }, {
      reg: /(ow)s$/i,
      to: '$1'
    }, {
      reg: /(op)s$/i,
      to: '$1'
    }, {
      reg: /([eirs])ts$/i,
      to: '$1t'
    }, {
      reg: /(ll)s$/i,
      to: '$1'
    }, {
      reg: /(el)s$/i,
      to: '$1'
    }, {
      reg: /(ip)es$/i,
      to: '$1e'
    }, {
      reg: /ss$/i,
      to: 'ss'
    }, {
      reg: /s$/i,
      to: ''
    }],
    Gerund: [{
      //popping -> pop
      reg: /(..)(p|d|t|g){2}ing$/i,
      to: '$1$2'
    }, {
      //fuzzing -> fuzz
      reg: /(ll|ss|zz)ing$/i,
      to: '$1'
    }, {
      reg: /([^aeiou])ying$/i,
      to: '$1y'
    }, {
      reg: /([^ae]i.)ing$/i,
      to: '$1e'
    }, {
      //eating, reading
      reg: /(ea[dklnrtv])ing$/i,
      to: '$1'
    }, {
      //washing -> wash
      reg: /(ch|sh)ing$/i,
      to: '$1'
    }, //soft-e forms:
    {
      //z : hazing (not buzzing)
      reg: /(z)ing$/i,
      to: '$1e'
    }, {
      //a : baking, undulating
      reg: /(a[gdkvtc])ing$/i,
      to: '$1e'
    }, {
      //u : conjuring, tubing
      reg: /(u[rtcbn])ing$/i,
      to: '$1e'
    }, {
      //o : forboding, poking, hoping, boring (not hooping)
      reg: /([^o]o[bdknprv])ing$/i,
      to: '$1e'
    }, {
      //ling : tingling, wrinkling, circling, scrambling, bustling
      reg: /([tbckg]l)ing$/i,
      //dp
      to: '$1e'
    }, {
      //cing : bouncing, denouncing
      reg: /(c|s)ing$/i,
      //dp
      to: '$1e'
    }, // {
    //   //soft-e :
    //   reg: /([ua]s|[dr]g|z|o[rlsp]|cre)ing$/i,
    //   to: '$1e',
    // },
    {
      //fallback
      reg: /(..)ing$/i,
      to: '$1'
    }],
    PastTense: [{
      reg: /(ued)$/i,
      to: 'ue'
    }, {
      reg: /a([^aeiouy])ed$/i,
      to: 'a$1e'
    }, {
      reg: /([aeiou]zz)ed$/i,
      to: '$1'
    }, {
      reg: /(e|i)lled$/i,
      to: '$1ll'
    }, {
      reg: /(.)(sh|ch)ed$/i,
      to: '$1$2'
    }, {
      reg: /(tl|gl)ed$/i,
      to: '$1e'
    }, {
      reg: /(um?pt?)ed$/i,
      to: '$1'
    }, {
      reg: /(ss)ed$/i,
      to: '$1'
    }, {
      reg: /pped$/i,
      to: 'p'
    }, {
      reg: /tted$/i,
      to: 't'
    }, {
      reg: /(..)gged$/i,
      to: '$1g'
    }, {
      reg: /(..)lked$/i,
      to: '$1lk'
    }, {
      reg: /([^aeiouy][aeiou])ked$/i,
      to: '$1ke'
    }, {
      reg: /(.[aeiou])led$/i,
      to: '$1l'
    }, {
      reg: /(..)(h|ion|n[dt]|ai.|[cs]t|pp|all|ss|tt|int|ail|ld|en|oo.|er|k|pp|w|ou.|rt|ght|rm)ed$/i,
      to: '$1$2'
    }, {
      reg: /(.ut)ed$/i,
      to: '$1e'
    }, {
      reg: /(.pt)ed$/i,
      to: '$1'
    }, {
      reg: /(us)ed$/i,
      to: '$1e'
    }, {
      reg: /(dd)ed$/i,
      to: '$1'
    }, {
      reg: /(..[^aeiouy])ed$/i,
      to: '$1e'
    }, {
      reg: /(..)ied$/i,
      to: '$1y'
    }, {
      reg: /(.o)ed$/i,
      to: '$1o'
    }, {
      reg: /(..i)ed$/i,
      to: '$1'
    }, {
      reg: /(.a[^aeiou])ed$/i,
      to: '$1'
    }, {
      //owed, aced
      reg: /([aeiou][^aeiou])ed$/i,
      to: '$1e'
    }, {
      reg: /([rl])ew$/i,
      to: '$1ow'
    }, {
      reg: /([pl])t$/i,
      to: '$1t'
    }]
  };
  var _transform = rules;

  var guessVerb = {
    Gerund: ['ing'],
    Actor: ['erer'],
    Infinitive: ['ate', 'ize', 'tion', 'rify', 'then', 'ress', 'ify', 'age', 'nce', 'ect', 'ise', 'ine', 'ish', 'ace', 'ash', 'ure', 'tch', 'end', 'ack', 'and', 'ute', 'ade', 'ock', 'ite', 'ase', 'ose', 'use', 'ive', 'int', 'nge', 'lay', 'est', 'ain', 'ant', 'ent', 'eed', 'er', 'le', 'own', 'unk', 'ung', 'en'],
    PastTense: ['ed', 'lt', 'nt', 'pt', 'ew', 'ld'],
    PresentTense: ['rks', 'cks', 'nks', 'ngs', 'mps', 'tes', 'zes', 'ers', 'les', 'acks', 'ends', 'ands', 'ocks', 'lays', 'eads', 'lls', 'els', 'ils', 'ows', 'nds', 'ays', 'ams', 'ars', 'ops', 'ffs', 'als', 'urs', 'lds', 'ews', 'ips', 'es', 'ts', 'ns']
  }; //flip it into a lookup object

  guessVerb = Object.keys(guessVerb).reduce(function (h, k) {
    guessVerb[k].forEach(function (a) {
      return h[a] = k;
    });
    return h;
  }, {});
  var _guess = guessVerb;

  /** it helps to know what we're conjugating from */

  var guessTense = function guessTense(str) {
    var three = str.substr(str.length - 3);

    if (_guess.hasOwnProperty(three) === true) {
      return _guess[three];
    }

    var two = str.substr(str.length - 2);

    if (_guess.hasOwnProperty(two) === true) {
      return _guess[two];
    }

    var one = str.substr(str.length - 1);

    if (one === 's') {
      return 'PresentTense';
    }

    return null;
  };

  var toInfinitive = function toInfinitive(str, world, tense) {
    if (!str) {
      return '';
    } //1. look at known irregulars


    if (world.words.hasOwnProperty(str) === true) {
      var irregs = world.irregulars.verbs;
      var keys = Object.keys(irregs);

      for (var i = 0; i < keys.length; i++) {
        var forms = Object.keys(irregs[keys[i]]);

        for (var o = 0; o < forms.length; o++) {
          if (str === irregs[keys[i]][forms[o]]) {
            return keys[i];
          }
        }
      }
    } // give'r!


    tense = tense || guessTense(str);

    if (tense && _transform[tense]) {
      for (var _i = 0; _i < _transform[tense].length; _i++) {
        var rule = _transform[tense][_i];

        if (rule.reg.test(str) === true) {
          // console.log(rule.reg)
          return str.replace(rule.reg, rule.to);
        }
      }
    }

    return str;
  };

  var toInfinitive_1 = toInfinitive;

  var irregulars$2 = {
    nouns: plurals,
    verbs: conjugations_1
  }; //these behaviours are configurable & shared across some plugins

  var transforms$2 = {
    conjugate: conjugate_1,
    adjectives: adjectives,
    toPlural: toPlural,
    toSingular: toSingular_1,
    toInfinitive: toInfinitive_1
  };
  var _isVerbose = false;
  /** all configurable linguistic data */

  var World = /*#__PURE__*/function () {
    function World() {
      _classCallCheck(this, World);

      // quiet these properties from a console.log
      Object.defineProperty(this, 'words', {
        enumerable: false,
        value: misc$1,
        writable: true
      });
      Object.defineProperty(this, 'hasCompound', {
        enumerable: false,
        value: {},
        writable: true
      });
      Object.defineProperty(this, 'irregulars', {
        enumerable: false,
        value: irregulars$2,
        writable: true
      });
      Object.defineProperty(this, 'tags', {
        enumerable: false,
        value: Object.assign({}, tags),
        writable: true
      });
      Object.defineProperty(this, 'transforms', {
        enumerable: false,
        value: transforms$2,
        writable: true
      });
      Object.defineProperty(this, 'taggers', {
        enumerable: false,
        value: [],
        writable: true
      }); // add our compressed data to lexicon

      this.unpackWords(_data); // add our irregulars to lexicon

      this.addIrregulars(); // cache our abbreviations for our sentence-parser

      Object.defineProperty(this, 'cache', {
        enumerable: false,
        value: {
          abbreviations: this.getByTag('Abbreviation')
        }
      });
    }
    /** more logs for debugging */


    _createClass(World, [{
      key: "verbose",
      value: function verbose(bool) {
        _isVerbose = bool;
        return this;
      }
    }, {
      key: "isVerbose",
      value: function isVerbose() {
        return _isVerbose;
      }
      /** get all terms in our lexicon with this tag */

    }, {
      key: "getByTag",
      value: function getByTag(tag) {
        var lex = this.words;
        var res = {};
        var words = Object.keys(lex);

        for (var i = 0; i < words.length; i++) {
          if (typeof lex[words[i]] === 'string') {
            if (lex[words[i]] === tag) {
              res[words[i]] = true;
            }
          } else if (lex[words[i]].some(function (t) {
            return t === tag;
          })) {
            res[words[i]] = true;
          }
        }

        return res;
      }
      /** augment our lingustic data with new data */

    }, {
      key: "unpackWords",
      value: function unpackWords(lex) {
        var tags = Object.keys(lex);

        for (var i = 0; i < tags.length; i++) {
          var words = Object.keys(efrtUnpack_min(lex[tags[i]]));

          for (var w = 0; w < words.length; w++) {
            addWords.addWord(words[w], tags[i], this.words); // do some fancier stuff

            addWords.addMore(words[w], tags[i], this);
          }
        }
      }
      /** put new words into our lexicon, properly */

    }, {
      key: "addWords",
      value: function addWords$1(obj) {
        var keys = Object.keys(obj);

        for (var i = 0; i < keys.length; i++) {
          var word = keys[i].toLowerCase();
          addWords.addWord(word, obj[keys[i]], this.words); // do some fancier stuff

          addWords.addMore(word, obj[keys[i]], this);
        }
      }
    }, {
      key: "addIrregulars",
      value: function addIrregulars() {
        addIrregulars_1(this);

        return this;
      }
      /** extend the compromise tagset */

    }, {
      key: "addTags",
      value: function addTags(tags) {
        tags = Object.assign({}, tags);
        this.tags = Object.assign(this.tags, tags); // calculate graph implications for the new tags

        this.tags = inference(this.tags);
        return this;
      }
      /** call methods after tagger runs */

    }, {
      key: "postProcess",
      value: function postProcess(fn) {
        this.taggers.push(fn);
        return this;
      }
      /** helper method for logging + debugging */

    }, {
      key: "stats",
      value: function stats() {
        return {
          words: Object.keys(this.words).length,
          plurals: Object.keys(this.irregulars.nouns).length,
          conjugations: Object.keys(this.irregulars.verbs).length,
          compounds: Object.keys(this.hasCompound).length,
          postProcessors: this.taggers.length
        };
      }
    }]);

    return World;
  }(); //  \_(:/)_/


  var clone$1 = function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  };
  /** produce a deep-copy of all lingustic data */


  World.prototype.clone = function () {
    var w2 = new World(); // these are simple to copy:

    w2.words = Object.assign({}, this.words);
    w2.hasCompound = Object.assign({}, this.hasCompound); //these ones are nested:

    w2.irregulars = clone$1(this.irregulars);
    w2.tags = clone$1(this.tags); // these are functions

    w2.transforms = this.transforms;
    w2.taggers = this.taggers;
    return w2;
  };

  var World_1 = World;

  var _01Utils$1 = createCommonjsModule(function (module, exports) {
    /** return the root, first document */
    exports.all = function () {
      return this.parents()[0] || this;
    };
    /** return the previous result */


    exports.parent = function () {
      if (this.from) {
        return this.from;
      }

      return this;
    };
    /**  return a list of all previous results */


    exports.parents = function (n) {
      var arr = [];

      var addParent = function addParent(doc) {
        if (doc.from) {
          arr.push(doc.from);
          addParent(doc.from);
        }
      };

      addParent(this);
      arr = arr.reverse();

      if (typeof n === 'number') {
        return arr[n];
      }

      return arr;
    };
    /** deep-copy the document, so that no references remain */


    exports.clone = function (doShallow) {
      var list = this.list.map(function (ts) {
        return ts.clone(doShallow);
      });
      var tmp = this.buildFrom(list);
      return tmp;
    };
    /** how many seperate terms does the document have? */


    exports.wordCount = function () {
      return this.list.reduce(function (count, p) {
        count += p.wordCount();
        return count;
      }, 0);
    };

    exports.wordcount = exports.wordCount;
    /** turn on logging for decision-debugging */
    // exports.verbose = function(bool) {
    //   if (bool === undefined) {
    //     bool = true
    //   }
    //   this.world.verbose = bool
    // }
  });

  var _02Accessors = createCommonjsModule(function (module, exports) {
    /** use only the first result(s) */
    exports.first = function (n) {
      if (n === undefined) {
        return this.get(0);
      }

      return this.slice(0, n);
    };
    /** use only the last result(s) */


    exports.last = function (n) {
      if (n === undefined) {
        return this.get(this.list.length - 1);
      }

      var end = this.list.length;
      return this.slice(end - n, end);
    };
    /** grab a given subset of the results*/


    exports.slice = function (start, end) {
      var list = this.list.slice(start, end);
      return this.buildFrom(list);
    };
    /* grab nth result */


    exports.eq = function (n) {
      var p = this.list[n];

      if (p === undefined) {
        return this.buildFrom([]);
      }

      return this.buildFrom([p]);
    };

    exports.get = exports.eq;
    /** grab term[0] for every match */

    exports.firstTerms = function () {
      return this.match('^.');
    };

    exports.firstTerm = exports.firstTerms;
    /** grab the last term for every match  */

    exports.lastTerms = function () {
      return this.match('.$');
    };

    exports.lastTerm = exports.lastTerms;
    /** return a flat array of term objects */

    exports.termList = function (num) {
      var arr = []; //'reduce' but faster

      for (var i = 0; i < this.list.length; i++) {
        var terms = this.list[i].terms();

        for (var o = 0; o < terms.length; o++) {
          arr.push(terms[o]); //support .termList(4)

          if (num !== undefined && arr[num] !== undefined) {
            return arr[num];
          }
        }
      }

      return arr;
    };
    /** return a flat array of term text strings */
    /* @blab+ */
    exports.textList = function (num) {
      var arr = []; //'reduce' but faster

      for (var i = 0; i < this.list.length; i++) {
        var terms = this.list[i].terms();

        for (var o = 0; o < terms.length; o++) {
          arr.push(terms[o]); //support .termList(4)

          if (num !== undefined && arr[num] !== undefined) {
            return arr[num];
          }
        }
      }

      return arr.map(function (term) { return term.text });
    };


    /* grab named capture group terms as object */
    var getGroups = function getGroups(doc) {
      var res = {};
      var allGroups = {};

      var _loop = function _loop(i) {
        var phrase = doc.list[i];
        var groups = Object.keys(phrase.groups).map(function (k) {
          return phrase.groups[k];
        });

        for (var j = 0; j < groups.length; j++) {
          var _groups$j = groups[j],
              group = _groups$j.group,
              start = _groups$j.start,
              length = _groups$j.length;

          if (!allGroups[group]) {
            allGroups[group] = [];
          }

          allGroups[group].push(phrase.buildFrom(start, length));
        }
      };

      for (var i = 0; i < doc.list.length; i++) {
        _loop(i);
      }

      var keys = Object.keys(allGroups);

      for (var _i = 0; _i < keys.length; _i++) {
        var key = keys[_i];
        res[key] = doc.buildFrom(allGroups[key]);
      }

      return res;
    };

    var getOneName = function getOneName(doc, name) {
      var arr = [];

      var _loop2 = function _loop2(i) {
        var phrase = doc.list[i];
        var keys = Object.keys(phrase.groups);
        keys = keys.filter(function (id) {
          return phrase.groups[id].group === name;
        });
        keys.forEach(function (id) {
          arr.push(phrase.buildFrom(phrase.groups[id].start, phrase.groups[id].length));
        });
      };

      for (var i = 0; i < doc.list.length; i++) {
        _loop2(i);
      }

      return doc.buildFrom(arr);
    };
    /** grab named capture group results */


    exports.groups = function (target) {
      if (target === undefined) {
        return getGroups(this);
      }

      if (typeof target === 'number') {
        target = String(target);
      }

      return getOneName(this, target) || this.buildFrom([]);
    };

    exports.group = exports.groups;
    /** get the full-sentence each phrase belongs to */

    exports.sentences = function (n) {
      var arr = [];
      this.list.forEach(function (p) {
        arr.push(p.fullSentence());
      });

      if (typeof n === 'number') {
        return this.buildFrom([arr[n]]);
      }

      return this.buildFrom(arr);
    };

    exports.sentence = exports.sentences;
  });

  // cache the easier conditions up-front
  var cacheRequired = function cacheRequired(reg) {
    var needTags = [];
    var needWords = [];
    reg.forEach(function (obj) {
      if (obj.optional === true || obj.negative === true) {
        return;
      }

      if (obj.tag !== undefined) {
        needTags.push(obj.tag);
      }

      if (obj.word !== undefined) {
        needWords.push(obj.word);
      }
    });
    return {
      tags: needTags,
      words: needWords
    };
  };

  var failFast$1 = function failFast(doc, regs) {
    if (doc._cache && doc._cache.set === true) {
      var _cacheRequired = cacheRequired(regs),
          words = _cacheRequired.words,
          tags = _cacheRequired.tags; //check required words


      for (var i = 0; i < words.length; i++) {
        if (doc._cache.words[words[i]] === undefined) {
          return false;
        }
      } //check required tags


      for (var _i = 0; _i < tags.length; _i++) {
        if (doc._cache.tags[tags[_i]] === undefined) {
          return false;
        }
      }
    }

    return true;
  };

  var checkCache = failFast$1;

  var _03Match = createCommonjsModule(function (module, exports) {
    /** return a new Doc, with this one as a parent */
    exports.match = function (reg, name) {
      //parse-up the input expression
      var regs = syntax_1(reg);

      if (regs.length === 0) {
        return this.buildFrom([]);
      } //check our cache, if it exists


      if (checkCache(this, regs) === false) {
        return this.buildFrom([]);
      } //try expression on each phrase


      var matches = this.list.reduce(function (arr, p) {
        return arr.concat(p.match(regs));
      }, []);

      if (name !== undefined && name !== null && name !== '') {
        return this.buildFrom(matches).groups(name);
      }

      return this.buildFrom(matches);
    };
    /** return all results except for this */


    exports.not = function (reg) {
      //parse-up the input expression
      var regs = syntax_1(reg); //if it's empty, return them all!

      if (regs.length === 0 || checkCache(this, regs) === false) {
        return this;
      } //try expression on each phrase


      var matches = this.list.reduce(function (arr, p) {
        return arr.concat(p.not(regs));
      }, []);
      return this.buildFrom(matches);
    };
    /** return only the first match */


    exports.matchOne = function (reg) {
      var regs = syntax_1(reg); //check our cache, if it exists

      if (checkCache(this, regs) === false) {
        return this.buildFrom([]);
      }

      for (var i = 0; i < this.list.length; i++) {
        var match = this.list[i].match(regs, true);
        return this.buildFrom(match);
      }

      return this.buildFrom([]);
    };
    /** return each current phrase, only if it contains this match */


    exports["if"] = function (reg) {
      var regs = syntax_1(reg); //consult our cache, if it exists

      if (checkCache(this, regs) === false) {
        return this.buildFrom([]);
      }

      var found = this.list.filter(function (p) {
        return p.has(regs) === true;
      });
      return this.buildFrom(found);
    };
    /** Filter-out any current phrases that have this match*/


    exports.ifNo = function (reg) {
      var regs = syntax_1(reg);
      var found = this.list.filter(function (p) {
        return p.has(regs) === false;
      });
      return this.buildFrom(found);
    };
    /**Return a boolean if this match exists */

    // function (reg:string|string [],all:boolean) -> boolean
    exports.has = function (reg,all) {
      // @blab+
      if (typeof reg == 'object' && reg.length) {
        for(var i in reg) { 
          var check=exports.has.call(this,reg[i]); 
          if (all && !check) return false;
          if (!all && check) return true;
        }
        return all?true:false;
      } 
      var regs = syntax_1(reg); //consult our cache, if it exists

      if (checkCache(this, regs) === false) {
        return false;
      }

      return this.list.some(function (p) {
        return p.has(regs) === true;
      });
    };
    
    // @blab; contains similar terms?
    exports.hasSimilar = function (reg,thres,all) {
      var terms = this.termList();
      var count=0;
      thres=thres||90;
      if (typeof reg=='string') reg=[reg];
      for(var i in terms) {
        for (var j in reg) {
          var check = similar_text(terms[i].text,reg[j],1)>thres;
          if (!all && check) return true;
          if (check) { count++; break }
        }
      }
      return all?count==res.length:false;
    }
    /** match any terms after our matches, within the sentence */


    exports.lookAhead = function (reg) {
      // find everything afterwards, by default
      if (!reg) {
        reg = '.*';
      }

      var regs = syntax_1(reg);
      var matches = [];
      this.list.forEach(function (p) {
        matches = matches.concat(p.lookAhead(regs));
      });
      matches = matches.filter(function (p) {
        return p;
      });
      return this.buildFrom(matches);
    };

    exports.lookAfter = exports.lookAhead;
    /** match any terms before our matches, within the sentence */

    exports.lookBehind = function (reg) {
      // find everything afterwards, by default
      if (!reg) {
        reg = '.*';
      }

      var regs = syntax_1(reg);
      var matches = [];
      this.list.forEach(function (p) {
        matches = matches.concat(p.lookBehind(regs));
      });
      matches = matches.filter(function (p) {
        return p;
      });
      return this.buildFrom(matches);
    };

    exports.lookBefore = exports.lookBehind;
    /** return all terms before a match, in each phrase */

    exports.before = function (reg) {
      var regs = syntax_1(reg); //only the phrases we care about

      var phrases = this["if"](regs).list;
      var befores = phrases.map(function (p) {
        var ids = p.terms().map(function (t) {
          return t.id;
        }); //run the search again

        var m = p.match(regs)[0];
        var index = ids.indexOf(m.start); //nothing is before a first-term match

        if (index === 0 || index === -1) {
          return null;
        }

        return p.buildFrom(p.start, index);
      });
      befores = befores.filter(function (p) {
        return p !== null;
      });
      return this.buildFrom(befores);
    };
    /** return all terms after a match, in each phrase */


    exports.after = function (reg) {
      var regs = syntax_1(reg); //only the phrases we care about

      var phrases = this["if"](regs).list;
      var befores = phrases.map(function (p) {
        var terms = p.terms();
        var ids = terms.map(function (t) {
          return t.id;
        }); //run the search again

        var m = p.match(regs)[0];
        var index = ids.indexOf(m.start); //skip if nothing is after it

        if (index === -1 || !terms[index + m.length]) {
          return null;
        } //create the new phrase, after our match.


        var id = terms[index + m.length].id;
        var len = p.length - index - m.length;
        return p.buildFrom(id, len);
      });
      befores = befores.filter(function (p) {
        return p !== null;
      });
      return this.buildFrom(befores);
    };
    /** return only results with this match afterwards */


    exports.hasAfter = function (reg) {
      return this.filter(function (doc) {
        return doc.lookAfter(reg).found;
      });
    };
    /** return only results with this match before it */


    exports.hasBefore = function (reg) {
      return this.filter(function (doc) {
        return doc.lookBefore(reg).found;
      });
    };
  });

  /** apply a tag, or tags to all terms */
  var tagTerms = function tagTerms(tag, doc, safe, reason) {
    var tagList = [];

    if (typeof tag === 'string') {
      tagList = tag.split(' ');
    } //do indepenent tags for each term:


    doc.list.forEach(function (p) {
      var terms = p.terms(); // tagSafe - apply only to fitting terms

      if (safe === true) {
        terms = terms.filter(function (t) {
          return t.canBe(tag, doc.world);
        });
      }

      terms.forEach(function (t, i) {
        //fancy version:
        if (tagList.length > 1) {
          if (tagList[i] && tagList[i] !== '.') {
            t.tag(tagList[i], reason, doc.world);
          }
        } else {
          //non-fancy version (same tag for all terms)
          t.tag(tag, reason, doc.world);
        }
      });
    });
    return;
  };

  var _setTag = tagTerms;

  /** Give all terms the given tag */

  var tag$1 = function tag(tags, why) {
    if (!tags) {
      return this;
    }

    _setTag(tags, this, false, why);
    return this;
  };
  /** Only apply tag to terms if it is consistent with current tags */


  var tagSafe$1 = function tagSafe(tags, why) {
    if (!tags) {
      return this;
    }

    _setTag(tags, this, true, why);
    return this;
  };
  /** Remove this term from the given terms */


  var unTag$1 = function unTag(tags, why) {
    var _this = this;

    this.list.forEach(function (p) {
      p.terms().forEach(function (t) {
        return t.unTag(tags, why, _this.world);
      });
    });
    return this;
  };
  /** return only the terms that can be this tag*/


  var canBe$2 = function canBe(tag) {
    if (!tag) {
      return this;
    }

    var world = this.world;
    var matches = this.list.reduce(function (arr, p) {
      return arr.concat(p.canBe(tag, world));
    }, []);
    return this.buildFrom(matches);
  };

  var _04Tag = {
    tag: tag$1,
    tagSafe: tagSafe$1,
    unTag: unTag$1,
    canBe: canBe$2
  };

  /* run each phrase through a function, and create a new document */
  var map = function map(fn) {
    var _this = this;

    if (!fn) {
      return this;
    }

    var list = this.list.map(function (p, i) {
      var doc = _this.buildFrom([p]);

      doc.from = null; //it's not a child/parent

      var res = fn(doc, i); // if its a doc, return one result

      if (res && res.list && res.list[0]) {
        return res.list[0];
      }

      return res;
    }); //remove nulls

    list = list.filter(function (x) {
      return x;
    }); // return an empty response

    if (list.length === 0) {
      return this.buildFrom(list);
    } // if it is not a list of Phrase objects, then don't try to make a Doc object


    if (_typeof(list[0]) !== 'object' || list[0].isA !== 'Phrase') {
      return list;
    }

    return this.buildFrom(list);
  };
  /** run a function on each phrase */


  var forEach = function forEach(fn, detachParent) {
    var _this2 = this;

    if (!fn) {
      return this;
    }

    this.list.forEach(function (p, i) {
      var sub = _this2.buildFrom([p]); // if we're doing fancy insertions, we may want to skip updating the parent each time.


      if (detachParent === true) {
        sub.from = null; //
      }

      fn(sub, i);
    });
    return this;
  };
  /** return only the phrases that return true */


  var filter = function filter(fn) {
    var _this3 = this;

    if (!fn) {
      return this;
    }

    var list = this.list.filter(function (p, i) {
      var doc = _this3.buildFrom([p]);

      doc.from = null; //it's not a child/parent

      return fn(doc, i);
    });
    return this.buildFrom(list);
  };
  /** return a document with only the first phrase that matches */


  var find = function find(fn) {
    var _this4 = this;

    if (!fn) {
      return this;
    }

    var phrase = this.list.find(function (p, i) {
      var doc = _this4.buildFrom([p]);

      doc.from = null; //it's not a child/parent

      return fn(doc, i);
    });

    if (phrase) {
      return this.buildFrom([phrase]);
    }

    return undefined;
  };
  /** return true or false if there is one matching phrase */


  var some = function some(fn) {
    var _this5 = this;

    if (!fn) {
      return this;
    }

    return this.list.some(function (p, i) {
      var doc = _this5.buildFrom([p]);

      doc.from = null; //it's not a child/parent

      return fn(doc, i);
    });
  };
  /** sample a subset of the results */


  var random = function random(n) {
    if (!this.found) {
      return this;
    }

    var r = Math.floor(Math.random() * this.list.length);

    if (n === undefined) {
      var list = [this.list[r]];
      return this.buildFrom(list);
    } //prevent it from going over the end


    if (r + n > this.length) {
      r = this.length - n;
      r = r < 0 ? 0 : r;
    }

    return this.slice(r, r + n);
  };
  /** combine each phrase into a new data-structure */
  // exports.reduce = function(fn, h) {
  //   let list = this.list.reduce((_h, ts) => {
  //     let doc = this.buildFrom([ts])
  //     doc.from = null //it's not a child/parent
  //     return fn(_h, doc)
  //   }, h)
  //   return this.buildFrom(list)
  // }


  var _05Loops = {
    map: map,
    forEach: forEach,
    filter: filter,
    find: find,
    some: some,
    random: random
  };

  // const tokenize = require('../../01-tokenizer/02-words')
  var tokenize = function tokenize(str) {
    return str.split(/[ -]/g);
  }; // take a list of strings
  // look them up in the document


  var buildTree = function buildTree(termList) {
    var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var root = {}; // parse our input

    termList.forEach(function (str, i) {
      var val = true;

      if (values[i] !== undefined) {
        val = values[i];
      } // some rough normalization


      str = (str || '').toLowerCase();
      str = str.replace(/[,;.!?]+$/, '');
      var arr = tokenize(str).map(function (s) {
        return s.trim();
      });
      root[arr[0]] = root[arr[0]] || {};

      if (arr.length === 1) {
        root[arr[0]].value = val;
      } else {
        root[arr[0]].more = root[arr[0]].more || [];
        root[arr[0]].more.push({
          rest: arr.slice(1),
          value: val
        });
      }
    }); // sort by longest-first?
    // console.log(JSON.stringify(root, null, 2))

    return root;
  };

  var fastLookup = function fastLookup(termList, values, doc) {
    var root = buildTree(termList, values);
    var found = []; // each phrase

    var _loop = function _loop(i) {
      var p = doc.list[i];
      var terms = p.terms();
      var words = terms.map(function (t) {
        return t.reduced;
      }); // each word

      var _loop2 = function _loop2(w) {
        if (root[words[w]] !== undefined) {
          // is it a multi-word match?
          if (root[words[w]].more !== undefined) {
            root[words[w]].more.forEach(function (more) {
              // is it too-long?
              if (words[w + more.rest.length] === undefined) {
                return;
              } // compare each subsequent term


              var everyTerm = more.rest.every(function (word, r) {
                return word === words[w + r + 1];
              });

              if (everyTerm === true) {
                found.push({
                  id: p.terms()[w].id,
                  value: more.value,
                  length: more.rest.length + 1
                });
              }
            });
          } // is it a single-word match?


          if (root[words[w]].value !== undefined) {
            found.push({
              id: p.terms()[w].id,
              value: root[words[w]].value,
              length: 1
            });
          }
        }
      };

      for (var w = 0; w < words.length; w++) {
        _loop2(w);
      }
    };

    for (var i = 0; i < doc.list.length; i++) {
      _loop(i);
    }

    return found;
  };

  var _lookup = fastLookup;

  var _06Lookup = createCommonjsModule(function (module, exports) {
    // compare one term and one match
    // const doesMatch = function(term, str) {
    //   if (str === '') {
    //     return false
    //   }
    //   return term.reduced === str || term.implicit === str || term.root === str || term.text.toLowerCase() === str
    // }
    var isObject = function isObject(obj) {
      return obj && Object.prototype.toString.call(obj) === '[object Object]';
    };
    /** lookup an array of words or phrases */


    exports.lookup = function (arr) {
      var _this = this;

      var values = []; //is it a {key:val} object?

      var isObj = isObject(arr);

      if (isObj === true) {
        arr = Object.keys(arr).map(function (k) {
          values.push(arr[k]);
          return k;
        });
      } // support .lookup('foo')


      if (typeof arr === 'string') {
        arr = [arr];
      } //make sure we go fast.


      if (this._cache.set !== true) {
        this.cache();
      }

      var found = _lookup(arr, values, this);
      var p = this.list[0]; // make object response

      if (isObj === true) {
        var byVal = {};
        found.forEach(function (o) {
          byVal[o.value] = byVal[o.value] || [];
          byVal[o.value].push(p.buildFrom(o.id, o.length));
        });
        Object.keys(byVal).forEach(function (k) {
          byVal[k] = _this.buildFrom(byVal[k]);
        });
        return byVal;
      } // otherwise, make array response:


      found = found.map(function (o) {
        return p.buildFrom(o.id, o.length);
      });
      return this.buildFrom(found);
    };

    exports.lookUp = exports.lookup;
  });

  /** freeze the current state of the document, for speed-purposes*/
  var cache$1 = function cache(options) {
    var _this = this;

    options = options || {};
    var words = {};
    var tags = {};
    this._cache.words = words;
    this._cache.tags = tags;
    this._cache.set = true;
    this.list.forEach(function (p, i) {
      p.cache = p.cache || {}; //p.terms get cached automatically

      var terms = p.terms(); // cache all the terms

      terms.forEach(function (t) {
        if (words[t.reduced] && !words.hasOwnProperty(t.reduced)) {
          return; //skip prototype words
        }

        words[t.reduced] = words[t.reduced] || [];
        words[t.reduced].push(i);
        Object.keys(t.tags).forEach(function (tag) {
          tags[tag] = tags[tag] || [];
          tags[tag].push(i);
        }); // cache root-form on Term, too

        if (options.root) {
          t.setRoot(_this.world);
          words[t.root] = true;
        }
      });
    });
    return this;
  };
  /** un-freezes the current state of the document, so it may be transformed */


  var uncache = function uncache() {
    this._cache = {};
    this.list.forEach(function (p) {
      p.cache = {};
    }); // do parents too?

    this.parents().forEach(function (doc) {
      doc._cache = {};
      doc.list.forEach(function (p) {
        p.cache = {};
      });
    });
    return this;
  };

  var _07Cache = {
    cache: cache$1,
    uncache: uncache
  };

  var titleCase$3 = function titleCase(str) {
    return str.charAt(0).toUpperCase() + str.substr(1);
  };
  /** substitute-in new content */


  var replaceWith = function replaceWith(replace) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!replace) {
      return this["delete"]();
    } //support old-style params


    if (options === true) {
      options = {
        keepTags: true
      };
    }

    if (options === false) {
      options = {
        keepTags: false
      };
    }

    options = options || {}; // clear the cache

    this.uncache(); // return this

    this.list.forEach(function (p) {
      var input = replace; // accept a function for replace

      if (typeof replace === 'function') {
        input = replace(p);
      }

      var newPhrases; // accept a Doc object to replace

      if (input && _typeof(input) === 'object' && input.isA === 'Doc') {
        newPhrases = input.list;

        _this.pool().merge(input.pool());
      } else if (typeof input === 'string') {
        //input is a string
        if (options.keepCase !== false && p.terms(0).isTitleCase()) {
          input = titleCase$3(input);
        }

        newPhrases = _01Tokenizer(input, _this.world, _this.pool()); //tag the new phrases

        var tmpDoc = _this.buildFrom(newPhrases);

        tmpDoc.tagger();
        newPhrases = tmpDoc.list;
      } else {
        return; //don't even bother
      } // try to keep its old tags, if appropriate


      if (options.keepTags === true) {
        var oldTags = p.json({
          terms: {
            tags: true
          }
        }).terms;
        newPhrases[0].terms().forEach(function (t, i) {
          if (oldTags[i]) {
            t.tagSafe(oldTags[i].tags, 'keptTag', _this.world);
          }
        });
      }

      p.replace(newPhrases[0], _this); //Oneday: support multi-sentence replacements
    });
    return this;
  };
  /** search and replace match with new content */


  var replace$1 = function replace(match, _replace, options) {
    // if there's no 2nd param, use replaceWith
    if (_replace === undefined) {
      return this.replaceWith(match, options);
    }

    this.match(match).replaceWith(_replace, options);
    return this;
  };

  var _01Replace = {
    replaceWith: replaceWith,
    replace: replace$1
  };

  var _02Insert = createCommonjsModule(function (module, exports) {
    // if it's empty, just create the phrase
    var makeNew = function makeNew(str, doc) {
      var phrase = _01Tokenizer(str, doc.world)[0]; //assume it's one sentence, for now

      var tmpDoc = doc.buildFrom([phrase]);
      tmpDoc.tagger();
      doc.list = tmpDoc.list;
      return doc;
    };
    /** add these new terms to the end*/


    exports.append = function (str) {
      var _this = this;

      if (!str) {
        return this;
      } // if it's empty, just create the phrase


      if (!this.found) {
        return makeNew(str, this);
      } // clear the cache


      this.uncache(); //add it to end of every phrase

      this.list.forEach(function (p) {
        //build it
        var phrase = _01Tokenizer(str, _this.world, _this.pool())[0]; //assume it's one sentence, for now
        //tag it

        var tmpDoc = _this.buildFrom([phrase]);

        tmpDoc.tagger(); // push it onto the end

        p.append(phrase, _this);
      });
      return this;
    };

    exports.insertAfter = exports.append;
    exports.insertAt = exports.append;
    /** add these new terms to the front*/

    exports.prepend = function (str) {
      var _this2 = this;

      if (!str) {
        return this;
      } // if it's empty, just create the phrase


      if (!this.found) {
        return makeNew(str, this);
      } // clear the cache


      this.uncache(); //add it to start of every phrase

      this.list.forEach(function (p) {
        //build it
        var phrase = _01Tokenizer(str, _this2.world, _this2.pool())[0]; //assume it's one sentence, for now
        //tag it

        var tmpDoc = _this2.buildFrom([phrase]);

        tmpDoc.tagger(); // add it to the start

        p.prepend(phrase, _this2);
      });
      return this;
    };

    exports.insertBefore = exports.prepend;
    /** add these new things to the end*/

    exports.concat = function () {
      // clear the cache
      this.uncache();
      var list = this.list.slice(0); //repeat for any number of params

      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i]; //support a fresh string

        if (typeof arg === 'string') {
          var arr = _01Tokenizer(arg, this.world); //TODO: phrase.tagger()?

          list = list.concat(arr);
        } else if (arg.isA === 'Doc') {
          list = list.concat(arg.list);
        } else if (arg.isA === 'Phrase') {
          list.push(arg);
        }
      }

      return this.buildFrom(list);
    };
    /** fully remove these terms from the document */


    exports["delete"] = function (match) {
      var _this3 = this;

      // clear the cache
      this.uncache();
      var toRemove = this;

      if (match) {
        toRemove = this.match(match);
      }

      toRemove.list.forEach(function (phrase) {
        return phrase["delete"](_this3);
      });
      return this;
    }; // aliases


    exports.remove = exports["delete"];
  });

  var shouldTrim = {
    clean: true,
    reduced: true,
    root: true
  };
  /** return the document as text */

  var text$1 = function text(options) {
    var _this = this;

    options = options || {}; //are we showing every phrase?

    var showFull = false;

    if (this.parents().length === 0) {
      showFull = true;
    } // cache roots, if necessary


    if (options === 'root' || _typeof(options) === 'object' && options.root) {
      this.list.forEach(function (p) {
        p.terms().forEach(function (t) {
          if (t.root === null) {
            t.setRoot(_this.world);
          }
        });
      });
    }

    var txt = this.list.reduce(function (str, p, i) {
      var trimPre = !showFull && i === 0;
      var trimPost = !showFull && i === _this.list.length - 1;
      return str + p.text(options, trimPre, trimPost);
    }, ''); // clumsy final trim of leading/trailing whitespace

    if (shouldTrim[options] === true || options.reduced === true || options.clean === true || options.root === true) {
      txt = txt.trim();
    }

    return txt;
  };

  var _01Text = {
    text: text$1
  };

  // get all character startings in doc
  var termOffsets = function termOffsets(doc) {
    var elapsed = 0;
    var index = 0;
    var offsets = {};
    doc.termList().forEach(function (term) {
      offsets[term.id] = {
        index: index,
        start: elapsed + term.pre.length,
        length: term.text.length
      };
      elapsed += term.pre.length + term.text.length + term.post.length;
      index += 1;
    });
    return offsets;
  };

  var calcOffset = function calcOffset(doc, result, options) {
    // calculate offsets for each term
    var offsets = termOffsets(doc.all()); // add index values

    if (options.terms.index || options.index) {
      result.forEach(function (o) {
        o.terms.forEach(function (t) {
          t.index = offsets[t.id].index;
        });
        o.index = o.terms[0].index;
      });
    } // add offset values


    if (options.terms.offset || options.offset) {
      result.forEach(function (o) {
        o.terms.forEach(function (t) {
          t.offset = offsets[t.id] || {};
        }); // let len = o.terms.reduce((n, t, i) => {
        //   n += t.offset.length || 0
        //   //add whitespace, too
        //   console.log(t.post)
        //   return n
        // }, 0)
        // The offset information for the entire doc starts at (or just before)
        // the first term, and is as long as the whole text.  The code originally
        // copied the entire offset value from terms[0], but since we're now
        // overriding 2 of the three fields, it's cleaner to just create an all-
        // new object and not pretend it's "just" the same as terms[0].

        o.offset = {
          index: o.terms[0].offset.index,
          start: o.terms[0].offset.start - o.text.indexOf(o.terms[0].text),
          length: o.text.length
        };
      });
    }
  };

  var _offset = calcOffset;

  var _02Json = createCommonjsModule(function (module, exports) {
    var jsonDefaults = {
      text: true,
      terms: true,
      trim: true
    }; //some options have dependents

    var setOptions = function setOptions(options) {
      options = Object.assign({}, jsonDefaults, options);

      if (options.unique) {
        options.reduced = true;
      } //offset calculation requires these options to be on


      if (options.offset) {
        options.text = true;

        if (!options.terms || options.terms === true) {
          options.terms = {};
        }

        options.terms.offset = true;
      }

      if (options.index || options.terms.index) {
        options.terms = options.terms === true ? {} : options.terms;
        options.terms.id = true;
      }

      return options;
    };
    /** pull out desired metadata from the document */


    exports.json = function () {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      //support json(3) format
      if (typeof options === 'number' && this.list[options]) {
        return this.list[options].json(jsonDefaults);
      }

      options = setOptions(options); // cache root strings beforehand, if necessary

      if (options.root === true) {
        this.list.forEach(function (p) {
          p.terms().forEach(function (t) {
            if (t.root === null) {
              t.setRoot(_this.world);
            }
          });
        });
      }

      var result = this.list.map(function (p) {
        return p.json(options, _this.world);
      }); // add offset and index data for each term

      if (options.terms.offset || options.offset || options.terms.index || options.index) {
        _offset(this, result, options);
      } // add frequency #s


      if (options.frequency || options.freq || options.count) {
        var obj = {};
        this.list.forEach(function (p) {
          var str = p.text('reduced');
          obj[str] = obj[str] || 0;
          obj[str] += 1;
        });
        this.list.forEach(function (p, i) {
          result[i].count = obj[p.text('reduced')];
        });
      } // remove duplicates


      if (options.unique) {
        var already = {};
        result = result.filter(function (o) {
          if (already[o.reduced] === true) {
            return false;
          }

          already[o.reduced] = true;
          return true;
        });
      }

      return result;
    }; //aliases


    exports.data = exports.json;
  });

  var _debug = createCommonjsModule(function (module) {
    // https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color
    var reset = '\x1b[0m';

    var padEnd = function padEnd(str, width) {
      str = str.toString();

      while (str.length < width) {
        str += ' ';
      }

      return str;
    };

    function isClientSide() {
      return typeof window !== 'undefined' && window.document;
    } // some nice colors for client-side debug


    var css = {
      green: '#7f9c6c',
      red: '#914045',
      blue: '#6699cc',
      magenta: '#6D5685',
      cyan: '#2D85A8',
      yellow: '#e6d7b3',
      black: '#303b50'
    };

    var logClientSide = function logClientSide(doc) {
      var tagset = doc.world.tags;
      doc.list.forEach(function (p) {
        console.log('\n%c"' + p.text() + '"', 'color: #e6d7b3;');
        var terms = p.terms();
        terms.forEach(function (t) {
          var tags = Object.keys(t.tags);
          var text = t.text || '-';

          if (t.implicit) {
            text = '[' + t.implicit + ']';
          }

          var word = "'" + text + "'";
          word = padEnd(word, 8);
          var found = tags.find(function (tag) {
            return tagset[tag] && tagset[tag].color;
          });
          var color = 'steelblue';

          if (tagset[found]) {
            color = tagset[found].color;
            color = css[color];
          }

          console.log("   ".concat(word, "  -  %c").concat(tags.join(', ')), "color: ".concat(color || 'steelblue', ";"));
        });
      });
    }; //cheaper than requiring chalk


    var cli = {
      green: function green(str) {
        return '\x1b[32m' + str + reset;
      },
      red: function red(str) {
        return '\x1b[31m' + str + reset;
      },
      blue: function blue(str) {
        return '\x1b[34m' + str + reset;
      },
      magenta: function magenta(str) {
        return '\x1b[35m' + str + reset;
      },
      cyan: function cyan(str) {
        return '\x1b[36m' + str + reset;
      },
      yellow: function yellow(str) {
        return '\x1b[33m' + str + reset;
      },
      black: function black(str) {
        return '\x1b[30m' + str + reset;
      }
    };

    var tagString = function tagString(tags, world) {
      tags = tags.map(function (tag) {
        if (!world.tags.hasOwnProperty(tag)) {
          return tag;
        }

        var c = world.tags[tag].color || 'blue';
        return cli[c](tag);
      });
      return tags.join(', ');
    }; //output some helpful stuff to the console


    var debug = function debug(doc) {
      if (isClientSide()) {
        logClientSide(doc);
        return doc;
      }

      console.log(cli.blue('====='));
      doc.list.forEach(function (p) {
        console.log(cli.blue('  -----'));
        var terms = p.terms();
        terms.forEach(function (t) {
          var tags = Object.keys(t.tags);
          var text = t.text || '-';

          if (t.implicit) {
            text = '[' + t.implicit + ']';
          }

          {
            text = cli.yellow(text);
          }

          var word = "'" + text + "'";
          word = padEnd(word, 18);
          var str = cli.blue('   ') + word + '  - ' + tagString(tags, doc.world);
          console.log(str);
        });
      });
      console.log('');
      return doc;
    };

    module.exports = debug;
  });

  var topk = function topk(doc) {
    var list = doc.json({
      text: false,
      terms: false,
      reduced: true
    }); // combine them

    var obj = {};
    list.forEach(function (o) {
      if (!obj[o.reduced]) {
        o.count = 0;
        obj[o.reduced] = o;
      }

      obj[o.reduced].count += 1;
    });
    var arr = Object.keys(obj).map(function (k) {
      return obj[k];
    }); // sort them

    arr.sort(function (a, b) {
      if (a.count > b.count) {
        return -1;
      } else if (a.count < b.count) {
        return 1;
      }

      return 0;
    });
    return arr;
  };

  var _topk = topk;

  /** pretty-print the current document and its tags */

  var debug_1 = function debug_1() {
    _debug(this);
    return this;
  };
  /** some named output formats */


  var out = function out(method) {
    if (method === 'text') {
      return this.text();
    }

    if (method === 'normal') {
      return this.text('normal');
    }

    if (method === 'json') {
      return this.json();
    }

    if (method === 'offset' || method === 'offsets') {
      return this.json({
        offset: true
      });
    }

    if (method === 'array') {
      return this.json({
        terms: false
      }).map(function (obj) {
        return obj.text;
      });
    }

    if (method === 'freq' || method === 'frequency') {
      return _topk(this);
    }

    if (method === 'terms') {
      var list = [];
      this.json({
        text: false,
        terms: {
          text: true
        }
      }).forEach(function (obj) {
        var terms = obj.terms.map(function (t) {
          return t.text;
        });
        terms = terms.filter(function (t) {
          return t;
        });
        list = list.concat(terms);
      });
      return list;
    }

    if (method === 'tags') {
      return this.list.map(function (p) {
        return p.terms().reduce(function (h, t) {
          h[t.clean || t.implicit] = Object.keys(t.tags);
          return h;
        }, {});
      });
    }

    if (method === 'debug') {
      _debug(this);
      return this;
    }

    return this.text();
  };

  var _03Out = {
    debug: debug_1,
    out: out
  };

  var methods$2 = {
    /** alphabetical order */
    alpha: function alpha(a, b) {
      var left = a.text('clean');
      var right = b.text('clean');

      if (left < right) {
        return -1;
      }

      if (left > right) {
        return 1;
      }

      return 0;
    },

    /** count the # of characters of each match */
    length: function length(a, b) {
      var left = a.text().trim().length;
      var right = b.text().trim().length;

      if (left < right) {
        return 1;
      }

      if (left > right) {
        return -1;
      }

      return 0;
    },

    /** count the # of terms in each match */
    wordCount: function wordCount(a, b) {
      var left = a.wordCount();
      var right = b.wordCount();

      if (left < right) {
        return 1;
      }

      if (left > right) {
        return -1;
      }

      return 0;
    }
  };
  /** sort by # of duplicates in the document*/

  var byFreq = function byFreq(doc) {
    var counts = {};
    var options = {
      "case": true,
      punctuation: false,
      whitespace: true,
      unicode: true
    };
    doc.list.forEach(function (p) {
      var str = p.text(options);
      counts[str] = counts[str] || 0;
      counts[str] += 1;
    }); // sort by freq

    doc.list.sort(function (a, b) {
      var left = counts[a.text(options)];
      var right = counts[b.text(options)];

      if (left < right) {
        return 1;
      }

      if (left > right) {
        return -1;
      }

      return 0;
    });
    return doc;
  }; // order results 'chronologically', or document-order


  var sortSequential = function sortSequential(doc) {
    var order = {};
    doc.json({
      terms: {
        offset: true
      }
    }).forEach(function (o) {
      order[o.terms[0].id] = o.terms[0].offset.start;
    });
    doc.list = doc.list.sort(function (a, b) {
      if (order[a.start] > order[b.start]) {
        return 1;
      } else if (order[a.start] < order[b.start]) {
        return -1;
      }

      return 0;
    });
    return doc;
  }; //aliases


  methods$2.alphabetical = methods$2.alpha;
  methods$2.wordcount = methods$2.wordCount; // aliases for sequential ordering

  var seqNames = {
    index: true,
    sequence: true,
    seq: true,
    sequential: true,
    chron: true,
    chronological: true
  };
  /** re-arrange the order of the matches (in place) */

  var sort = function sort(input) {
    input = input || 'alpha'; //do this one up-front

    if (input === 'freq' || input === 'frequency' || input === 'topk') {
      return byFreq(this);
    }

    if (seqNames.hasOwnProperty(input)) {
      return sortSequential(this);
    }

    input = methods$2[input] || input; // apply sort method on each phrase

    if (typeof input === 'function') {
      this.list = this.list.sort(input);
      return this;
    }

    return this;
  };
  /** reverse the order of the matches, but not the words */


  var reverse = function reverse() {
    var list = [].concat(this.list);
    list = list.reverse();
    return this.buildFrom(list);
  };
  /** remove any duplicate matches */


  var unique$4 = function unique() {
    var list = [].concat(this.list);
    var obj = {};
    list = list.filter(function (p) {
      var str = p.text('reduced').trim();

      if (obj.hasOwnProperty(str) === true) {
        return false;
      }

      obj[str] = true;
      return true;
    });
    return this.buildFrom(list);
  };

  var _01Sort = {
    sort: sort,
    reverse: reverse,
    unique: unique$4
  };

  var isPunct = /[\[\]{}:,\-;\/*\^%=~|]/g;
  var quotes = /['"]+/g;
  var methods$3 = {
    // cleanup newlines and extra spaces
    whitespace: function whitespace(doc) {
      var termArr = doc.list.map(function (ts) {
        return ts.terms();
      });
      termArr.forEach(function (terms, o) {
        terms.forEach(function (t, i) {
          // keep dashes between words
          if (t.hasDash() === true) {
            t.post = ' - ';
            return;
          } // remove existing spaces


          t.pre = t.pre.replace(/\s/g, '');
          t.post = t.post.replace(/\s/g, ''); //last word? ensure there's a next sentence.

          if (terms.length - 1 === i && !termArr[o + 1]) {
            return;
          } // no extra spaces for contractions


          if (t.implicit && Boolean(t.text) === true) {
            return;
          } // no extra spaces for hyphenated words


          if (t.hasHyphen() === true) {
            return;
          }

          t.post += ' ';
        });
      });
    },
    punctuation: function punctuation(termList) {
      termList.forEach(function (t) {
        // space between hyphenated words
        if (t.hasHyphen() === true) {
          t.post = ' ';
        }

        t.pre = t.pre.replace(isPunct, '');
        t.post = t.post.replace(isPunct, ''); // elipses

        t.post = t.post.replace(/\.\.\./, ''); // only allow one exclamation

        if (/!/.test(t.post) === true) {
          t.post = t.post.replace(/!/g, '');
          t.post = '!' + t.post;
        } // only allow one question mark


        if (/\?/.test(t.post) === true) {
          t.post = t.post.replace(/[\?!]*/, '');
          t.post = '?' + t.post;
        }
      });
    },
    unicode: function unicode(termList) {
      termList.forEach(function (t) {
        if (t.isImplicit() === true) {
          return;
        }

        t.text = unicode_1(t.text);
      });
    },
    quotations: function quotations(termList) {
      termList.forEach(function (t) {
        t.post = t.post.replace(quotes, '');
        t.pre = t.pre.replace(quotes, '');
      });
    },
    adverbs: function adverbs(doc) {
      doc.match('#Adverb').not('(not|nary|seldom|never|barely|almost|basically|so)').remove();
    },
    // remove the '.' from 'Mrs.' (safely)
    abbreviations: function abbreviations(doc) {
      doc.list.forEach(function (ts) {
        var terms = ts.terms();
        terms.forEach(function (t, i) {
          if (t.tags.Abbreviation === true && terms[i + 1]) {
            t.post = t.post.replace(/^\./, '');
          }
        });
      });
    }
  };
  var _methods = methods$3;

  var defaults = {
    // light
    whitespace: true,
    unicode: true,
    punctuation: true,
    emoji: true,
    acronyms: true,
    abbreviations: true,
    // medium
    "case": false,
    contractions: false,
    parentheses: false,
    quotations: false,
    adverbs: false,
    // heavy (loose legibility)
    possessives: false,
    verbs: false,
    nouns: false,
    honorifics: false // pronouns: true,

  };
  var mapping$1 = {
    light: {},
    medium: {
      "case": true,
      contractions: true,
      parentheses: true,
      quotations: true,
      adverbs: true
    }
  };
  mapping$1.heavy = Object.assign({}, mapping$1.medium, {
    possessives: true,
    verbs: true,
    nouns: true,
    honorifics: true
  });
  /** common ways to clean-up the document, and reduce noise */

  var normalize = function normalize(options) {
    options = options || {}; // support named forms

    if (typeof options === 'string') {
      options = mapping$1[options] || {};
    } // set defaults


    options = Object.assign({}, defaults, options); // clear the cache

    this.uncache();
    var termList = this.termList(); // lowercase things

    if (options["case"]) {
      this.toLowerCase();
    } //whitespace


    if (options.whitespace) {
      _methods.whitespace(this);
    } // unicode:  -> e


    if (options.unicode) {
      _methods.unicode(termList);
    } //punctuation - keep sentence punctation, quotes, parenths


    if (options.punctuation) {
      _methods.punctuation(termList);
    } // remove ':)'


    if (options.emoji) {
      this.remove('(#Emoji|#Emoticon)');
    } // 'f.b.i.' -> 'FBI'


    if (options.acronyms) {
      this.acronyms().strip(); // .toUpperCase()
    } // remove period from abbreviations


    if (options.abbreviations) {
      _methods.abbreviations(this);
    } // --Medium methods--
    // `isn't` -> 'is not'


    if (options.contraction || options.contractions) {
      this.contractions().expand();
    } // '(word)' -> 'word'


    if (options.parentheses) {
      this.parentheses().unwrap();
    } // remove "" punctuation


    if (options.quotations || options.quotes) {
      _methods.quotations(termList);
    } // remove any un-necessary adverbs


    if (options.adverbs) {
      _methods.adverbs(this);
    } // --Heavy methods--
    // `cory hart's -> cory hart'


    if (options.possessive || options.possessives) {
      this.possessives().strip();
    } // 'he walked' -> 'he walk'


    if (options.verbs) {
      this.verbs().toInfinitive();
    } // 'three dogs' -> 'three dog'


    if (options.nouns || options.plurals) {
      this.nouns().toSingular();
    } // remove 'Mr.' from 'Mr John Smith'


    if (options.honorifics) {
      this.remove('#Honorific');
    }

    return this;
  };

  var _02Normalize = {
    normalize: normalize
  };

  var _03Split = createCommonjsModule(function (module, exports) {
    /** return a Document with three parts for every match
     * seperate everything before the word, as a new phrase
     */
    exports.splitOn = function (reg) {
      // if there's no match, split parent, instead
      if (!reg) {
        var parent = this.parent();
        return parent.splitOn(this);
      } //start looking for a match..


      var regs = syntax_1(reg);
      var matches = [];
      this.list.forEach(function (p) {
        var foundEm = p.match(regs); //no match here, add full sentence

        if (foundEm.length === 0) {
          matches.push(p);
          return;
        } // we found something here.


        var carry = p;
        foundEm.forEach(function (found) {
          var parts = carry.splitOn(found); // add em in

          if (parts.before) {
            matches.push(parts.before);
          }

          if (parts.match) {
            matches.push(parts.match);
          } // start matching now on the end


          carry = parts.after;
        }); // add that last part

        if (carry) {
          matches.push(carry);
        }
      });
      return this.buildFrom(matches);
    };
    /** return a Document with two parts for every match
     * seperate everything after the word, as a new phrase
     */


    exports.splitAfter = function (reg) {
      // if there's no match, split parent, instead
      if (!reg) {
        var parent = this.parent();
        return parent.splitAfter(this);
      } // start looking for our matches


      var regs = syntax_1(reg);
      var matches = [];
      this.list.forEach(function (p) {
        var foundEm = p.match(regs); //no match here, add full sentence

        if (foundEm.length === 0) {
          matches.push(p);
          return;
        } // we found something here.


        var carry = p;
        foundEm.forEach(function (found) {
          var parts = carry.splitOn(found); // add em in

          if (parts.before && parts.match) {
            // merge these two together
            parts.before.length += parts.match.length;
            matches.push(parts.before);
          } else if (parts.match) {
            matches.push(parts.match);
          } // start matching now on the end


          carry = parts.after;
        }); // add that last part

        if (carry) {
          matches.push(carry);
        }
      });
      return this.buildFrom(matches);
    };

    exports.split = exports.splitAfter; //i guess?

    /** return a Document with two parts for every match */

    exports.splitBefore = function (reg) {
      // if there's no match, split parent, instead
      if (!reg) {
        var parent = this.parent();
        return parent.splitBefore(this);
      } //start looking for a match..


      var regs = syntax_1(reg);
      var matches = [];
      this.list.forEach(function (p) {
        var foundEm = p.match(regs); //no match here, add full sentence

        if (foundEm.length === 0) {
          matches.push(p);
          return;
        } // we found something here.


        var carry = p;
        foundEm.forEach(function (found) {
          var parts = carry.splitOn(found); // add before part in

          if (parts.before) {
            matches.push(parts.before);
          } // merge match+after


          if (parts.match && parts.after) {
            parts.match.length += parts.after.length;
          } // start matching now on the end


          carry = parts.match;
        }); // add that last part

        if (carry) {
          matches.push(carry);
        }
      });
      return this.buildFrom(matches);
    };
    /** split a document into labeled sections */


    exports.segment = function (regs, options) {
      regs = regs || {};
      options = options || {
        text: true
      };
      var doc = this;
      var keys = Object.keys(regs); // split em

      keys.forEach(function (k) {
        doc = doc.splitOn(k);
      }); //add labels for each section

      doc.list.forEach(function (p) {
        for (var i = 0; i < keys.length; i += 1) {
          if (p.has(keys[i])) {
            p.segment = regs[keys[i]];
            return;
          }
        }
      });
      return doc.list.map(function (p) {
        var res = p.json(options);
        res.segment = p.segment || null;
        return res;
      });
    };
  });

  var eachTerm = function eachTerm(doc, fn) {
    var world = doc.world;
    doc.list.forEach(function (p) {
      p.terms().forEach(function (t) {
        return t[fn](world);
      });
    });
    return doc;
  };
  /** turn every letter of every term to lower-cse */


  var toLowerCase = function toLowerCase() {
    return eachTerm(this, 'toLowerCase');
  };
  /** turn every letter of every term to upper case */


  var toUpperCase = function toUpperCase() {
    return eachTerm(this, 'toUpperCase');
  };
  /** upper-case the first letter of each term */


  var toTitleCase = function toTitleCase() {
    return eachTerm(this, 'toTitleCase');
  };
  /** remove whitespace and title-case each term */


  var toCamelCase = function toCamelCase() {
    this.list.forEach(function (p) {
      //remove whitespace
      var terms = p.terms();
      terms.forEach(function (t, i) {
        if (i !== 0) {
          t.toTitleCase();
        }

        if (i !== terms.length - 1) {
          t.post = '';
        }
      });
    }); // this.tag('#CamelCase', 'toCamelCase')

    return this;
  };

  var _04Case = {
    toLowerCase: toLowerCase,
    toUpperCase: toUpperCase,
    toTitleCase: toTitleCase,
    toCamelCase: toCamelCase
  };

  var _05Whitespace = createCommonjsModule(function (module, exports) {
    /** add this punctuation or whitespace before each match: */
    exports.pre = function (str, concat) {
      if (str === undefined) {
        return this.list[0].terms(0).pre;
      }

      this.list.forEach(function (p) {
        var term = p.terms(0);

        if (concat === true) {
          term.pre += str;
        } else {
          term.pre = str;
        }
      });
      return this;
    };
    /** add this punctuation or whitespace after each match: */


    exports.post = function (str, concat) {
      // return array of post strings
      if (str === undefined) {
        return this.list.map(function (p) {
          var terms = p.terms();
          var term = terms[terms.length - 1];
          return term.post;
        });
      } // set post string on all ends


      this.list.forEach(function (p) {
        var terms = p.terms();
        var term = terms[terms.length - 1];

        if (concat === true) {
          term.post += str;
        } else {
          term.post = str;
        }
      });
      return this;
    };
    /** remove start and end whitespace */


    exports.trim = function () {
      this.list = this.list.map(function (p) {
        return p.trim();
      });
      return this;
    };
    /** connect words with hyphen, and remove whitespace */


    exports.hyphenate = function () {
      this.list.forEach(function (p) {
        var terms = p.terms(); //remove whitespace

        terms.forEach(function (t, i) {
          if (i !== 0) {
            t.pre = '';
          }

          if (terms[i + 1]) {
            t.post = '-';
          }
        });
      });
      return this;
    };
    /** remove hyphens between words, and set whitespace */


    exports.dehyphenate = function () {
      var hasHyphen = /(-||)/;
      this.list.forEach(function (p) {
        var terms = p.terms(); //remove whitespace

        terms.forEach(function (t) {
          if (hasHyphen.test(t.post)) {
            t.post = ' ';
          }
        });
      });
      return this;
    };

    exports.deHyphenate = exports.dehyphenate;
    /** add quotations around these matches */

    exports.toQuotations = function (start, end) {
      start = start || "\"";
      end = end || "\"";
      this.list.forEach(function (p) {
        var terms = p.terms();
        terms[0].pre = start + terms[0].pre;
        var last = terms[terms.length - 1];
        last.post = end + last.post;
      });
      return this;
    };

    exports.toQuotation = exports.toQuotations;
    /** add brackets around these matches */

    exports.toParentheses = function (start, end) {
      start = start || "(";
      end = end || ")";
      this.list.forEach(function (p) {
        var terms = p.terms();
        terms[0].pre = start + terms[0].pre;
        var last = terms[terms.length - 1];
        last.post = end + last.post;
      });
      return this;
    };
  });

  /** make all phrases into one phrase */
  var join = function join(str) {
    // clear the cache
    this.uncache(); // make one large phrase - 'main'

    var main = this.list[0];
    var before = main.length;
    var removed = {};

    for (var i = 1; i < this.list.length; i++) {
      var p = this.list[i];
      removed[p.start] = true;
      var term = main.lastTerm(); // add whitespace between them

      if (str) {
        term.post += str;
      } //  main -> p


      term.next = p.start; // main <- p

      p.terms(0).prev = term.id;
      main.length += p.length;
      main.cache = {};
    } // parents are bigger than than their children.
    // when we increase a child, we increase their parent too.


    var increase = main.length - before;
    this.parents().forEach(function (doc) {
      // increase length on each effected phrase
      doc.list.forEach(function (p) {
        var terms = p.terms();

        for (var _i = 0; _i < terms.length; _i++) {
          if (terms[_i].id === main.start) {
            p.length += increase;
            break;
          }
        }

        p.cache = {};
      }); // remove redundant phrases now

      doc.list = doc.list.filter(function (p) {
        return removed[p.start] !== true;
      });
    }); // return one major phrase

    return this.buildFrom([main]);
  };

  var _06Join = {
    join: join
  };

  var postPunct = /[,\)"';:\-\.]/; // const irregulars = {
  //   'will not': `won't`,
  //   'i am': `i'm`,
  // }

  var setContraction = function setContraction(m, suffix) {
    if (!m.found) {
      return;
    }

    var terms = m.termList(); //avoid any problematic punctuation

    for (var i = 0; i < terms.length - 1; i++) {
      var t = terms[i];

      if (postPunct.test(t.post)) {
        return;
      }
    } // set them as implict


    terms.forEach(function (t) {
      t.implicit = t.clean;
    }); // perform the contraction

    terms[0].text += suffix; // clean-up the others

    terms.slice(1).forEach(function (t) {
      t.text = '';
    });

    for (var _i = 0; _i < terms.length - 1; _i++) {
      var _t = terms[_i];
      _t.post = _t.post.replace(/ /, '');
    }
  };
  /** turn 'i am' into i'm */


  var contract = function contract() {
    var doc = this.not('@hasContraction'); // we are -> we're

    var m = doc.match('(we|they|you) are');
    setContraction(m, "'re"); // they will -> they'll

    m = doc.match('(he|she|they|it|we|you) will');
    setContraction(m, "'ll"); // she is -> she's

    m = doc.match('(he|she|they|it|we) is');
    setContraction(m, "'s"); // spencer is -> spencer's

    m = doc.match('#Person is');
    setContraction(m, "'s"); // spencer would -> spencer'd

    m = doc.match('#Person would');
    setContraction(m, "'d"); // would not -> wouldn't

    m = doc.match('(is|was|had|would|should|could|do|does|have|has|can) not');
    setContraction(m, "n't"); // i have -> i've

    m = doc.match('(i|we|they) have');
    setContraction(m, "'ve"); // would have -> would've

    m = doc.match('(would|should|could) have');
    setContraction(m, "'ve"); // i am -> i'm

    m = doc.match('i am');
    setContraction(m, "'m"); // going to -> gonna

    m = doc.match('going to');
    return this;
  };

  var _07Contract = {
    contract: contract
  };

  var methods$4 = Object.assign({}, _01Utils$1, _02Accessors, _03Match, _04Tag, _05Loops, _06Lookup, _07Cache, _01Replace, _02Insert, _01Text, _02Json, _03Out, _01Sort, _02Normalize, _03Split, _04Case, _05Whitespace, _06Join, _07Contract);

  var methods$5 = {}; // allow helper methods like .adjectives() and .adverbs()

  var arr = [['terms', '.'], ['hyphenated', '@hasHyphen .'], ['adjectives', '#Adjective'], ['hashTags', '#HashTag'], ['emails', '#Email'], ['emoji', '#Emoji'], ['emoticons', '#Emoticon'], ['atMentions', '#AtMention'], ['urls', '#Url'], ['adverbs', '#Adverb'], ['pronouns', '#Pronoun'], ['conjunctions', '#Conjunction'], ['prepositions', '#Preposition']];
  arr.forEach(function (a) {
    methods$5[a[0]] = function (n) {
      var m = this.match(a[1]);

      if (typeof n === 'number') {
        m = m.get(n);
      }

      return m;
    };
  }); // aliases

  methods$5.emojis = methods$5.emoji;
  methods$5.atmentions = methods$5.atMentions;
  methods$5.words = methods$5.terms;
  /** return anything tagged as a phone number */

  methods$5.phoneNumbers = function (n) {
    var m = this.splitAfter('@hasComma');
    m = m.match('#PhoneNumber+');

    if (typeof n === 'number') {
      m = m.get(n);
    }

    return m;
  };
  /** Deprecated: please use compromise-numbers plugin */


  methods$5.money = function (n) {
    var m = this.match('#Money #Currency?');

    if (typeof n === 'number') {
      m = m.get(n);
    }

    return m;
  };
  /** return all cities, countries, addresses, and regions */


  methods$5.places = function (n) {
    // don't split 'paris, france'
    var keep = this.match('(#City && @hasComma) (#Region|#Country)'); // but split the other commas

    var m = this.not(keep).splitAfter('@hasComma'); // combine them back together

    m = m.concat(keep);
    m.sort('index');
    m = m.match('#Place+');

    if (typeof n === 'number') {
      m = m.get(n);
    }

    return m;
  };
  /** return all schools, businesses and institutions */


  methods$5.organizations = function (n) {
    var m = this.clauses();
    m = m.match('#Organization+');

    if (typeof n === 'number') {
      m = m.get(n);
    }

    return m;
  }; //combine them with .topics() method


  methods$5.entities = function (n) {
    var r = this.clauses(); // Find people, places, and organizations

    var yup = r.people();
    yup = yup.concat(r.places());
    yup = yup.concat(r.organizations());
    var ignore = ['someone', 'man', 'woman', 'mother', 'brother', 'sister', 'father'];
    yup = yup.not(ignore); //return them to normal ordering

    yup.sort('sequence'); // yup.unique() //? not sure

    if (typeof n === 'number') {
      yup = yup.get(n);
    }

    return yup;
  }; //aliases


  methods$5.things = methods$5.entities;
  methods$5.topics = methods$5.entities;
  var _simple = methods$5;

  var underOver = /^(under|over)-?/;
  /** match a word-sequence, like 'super bowl' in the lexicon */

  var tryMultiple = function tryMultiple(terms, t, world) {
    var lex = world.words; //try a two-word version

    var txt = terms[t].reduced + ' ' + terms[t + 1].reduced;

    if (lex[txt] !== undefined && lex.hasOwnProperty(txt) === true) {
      terms[t].tag(lex[txt], 'lexicon-two', world);
      terms[t + 1].tag(lex[txt], 'lexicon-two', world);
      return 1;
    } //try a three-word version?


    if (t + 2 < terms.length) {
      txt += ' ' + terms[t + 2].reduced;

      if (lex[txt] !== undefined && lex.hasOwnProperty(txt) === true) {
        terms[t].tag(lex[txt], 'lexicon-three', world);
        terms[t + 1].tag(lex[txt], 'lexicon-three', world);
        terms[t + 2].tag(lex[txt], 'lexicon-three', world);
        return 2;
      }
    } //try a four-word version?


    if (t + 3 < terms.length) {
      txt += ' ' + terms[t + 3].reduced;

      if (lex[txt] !== undefined && lex.hasOwnProperty(txt) === true) {
        terms[t].tag(lex[txt], 'lexicon-four', world);
        terms[t + 1].tag(lex[txt], 'lexicon-four', world);
        terms[t + 2].tag(lex[txt], 'lexicon-four', world);
        terms[t + 3].tag(lex[txt], 'lexicon-four', world);
        return 3;
      }
    }

    return 0;
  };
  /** look at each word in our list of known-words */


  var checkLexicon = function checkLexicon(terms, world) {
    var lex = world.words;
    var hasCompound = world.hasCompound; // use reduced?
    //go through each term, and check the lexicon

    for (var t = 0; t < terms.length; t += 1) {
      var str = terms[t].clean; //is it the start of a compound word, like 'super bowl'?

      if (hasCompound[str] === true && t + 1 < terms.length) {
        var foundWords = tryMultiple(terms, t, world);

        if (foundWords > 0) {
          t += foundWords; //skip any already-found words

          continue;
        }
      } //try one-word lexicon


      if (lex[str] !== undefined && lex.hasOwnProperty(str) === true) {
        terms[t].tag(lex[str], 'lexicon', world);
        continue;
      } // look at reduced version of term, too


      if (str !== terms[t].reduced && lex.hasOwnProperty(terms[t].reduced) === true) {
        terms[t].tag(lex[terms[t].reduced], 'lexicon', world);
        continue;
      } // prefix strip: try to match 'take' for 'undertake'


      if (underOver.test(str) === true) {
        var noPrefix = str.replace(underOver, '');

        if (lex.hasOwnProperty(noPrefix) === true) {
          terms[t].tag(lex[noPrefix], 'noprefix-lexicon', world);
        }
      }
    }

    return terms;
  };

  var _01Lexicon = checkLexicon;

  var apostrophes = /[\'`]$/;
  var perSec = /^(m|k|cm|km|m)\/(s|h|hr)$/; // '5 k/m'
  //

  var checkPunctuation = function checkPunctuation(terms, i, world) {
    var term = terms[i]; //check hyphenation
    // if (term.post.indexOf('-') !== -1 && terms[i + 1] && terms[i + 1].pre === '') {
    //   term.tag('Hyphenated', 'has-hyphen', world)
    // }
    // support 'head-over'
    // if (term.hasHyphen() === true) {
    //   console.log(term.tags)
    // }
    // console.log(term.hasHyphen(), term.text)
    //an end-tick (trailing apostrophe) - flanders', or Carlos'

    if (apostrophes.test(term.text)) {
      if (!apostrophes.test(term.pre) && !apostrophes.test(term.post) && term.clean.length > 2) {
        var endChar = term.clean[term.clean.length - 2]; //flanders'

        if (endChar === 's') {
          term.tag(['Possessive', 'Noun'], 'end-tick', world);
          return;
        } //chillin'


        if (endChar === 'n') {
          term.tag(['Gerund'], 'chillin', world);
        }
      }
    } // '5 km/s'


    if (perSec.test(term.text)) {
      term.tag('Unit', 'per-sec', world);
    } // 'NASA' is, but not 'i REALLY love it.'
    // if (term.tags.Noun === true && isAcronym(term, world)) {
    //   term.tag('Acronym', 'acronym-step', world)
    //   term.tag('Noun', 'acronym-infer', world)
    // } else if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym.test(term.text)) {
    //   term.tag('Acronym', 'one-letter-acronym', world)
    //   term.tag('Noun', 'one-letter-infer', world)
    // }

  };

  var _02Punctuation$1 = checkPunctuation;

  //these are regexes applied to t.text, instead of t.clean
  // order matters.
  var startsWith = [//web tags
  [/^[\w\.]+@[\w\.]+\.[a-z]{2,3}$/, 'Email'], //not fancy
  [/^#[a-z0-9_\u00C0-\u00FF]{2,}$/, 'HashTag'], [/^@\w{2,}$/, 'AtMention'], [/^(https?:\/\/|www\.)\w+\.[a-z]{2,3}/, 'Url'], //with http/www
  [/^[\w./]+\.(com|net|gov|org|ly|edu|info|biz|ru|jp|de|in|uk|br)/, 'Url'], //http://mostpopularwebsites.net/top-level-domain
  //dates/times
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, 'Time'], //4:32:32
  [/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/, 'Time'], //4pm
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/, 'Time'], //4:00pm
  [/^[PMCE]ST$/, 'Time'], //PST, time zone abbrevs
  [/^utc ?[+-]?[0-9]+?$/, 'Time'], //UTC 8+
  [/^[a-z0-9]*? o\'?clock$/, 'Time'], //3 oclock
  [/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, 'Date'], // 03-02-89
  [/^[0-9]{1,4}\/[0-9]{1,2}\/[0-9]{1,4}$/, 'Date'], // 03/02/89
  [/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, 'Date'], // 03-March-89
  //names
  [/^ma?c\'.*/, 'LastName'], //mc'adams
  [/^o\'[drlkn].*/, 'LastName'], //o'douggan
  [/^ma?cd[aeiou]/, 'LastName'], //macdonell - Last patterns https://en.wikipedia.org/wiki/List_of_family_name_affixes
  //slang things
  [/^(lol)+[sz]$/, 'Expression'], //lol
  [/^woo+a*?h?$/, 'Expression'], //whoaa, wooo
  [/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, 'Verb'], // [/^(over|under)[a-z]{2,}/, 'Adjective'],
  [/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, 'Date'], // 03-02-89
  //phone numbers
  [/^[0-9]{3}-[0-9]{4}$/, 'PhoneNumber'], //589-3809
  [/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, 'PhoneNumber'], //632-589-3809
  //money
  // currency regex
  // /[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]
  //like $5.30
  [/^[-+]?[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6][-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(k|m|b|bn)?\+?$/, ['Money', 'Value']], //like 5.30$
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]\+?$/, ['Money', 'Value']], //like 400usd
  [/^[-+]?[0-9]([0-9,.])+?(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ['Money', 'Value']], //numbers
  // 50 | -50 | 3.23  | 5,999.0  | 10+
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ['Cardinal', 'NumericValue']], [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|th)$/, ['Ordinal', 'NumericValue']], // .73th
  [/^\.[0-9]+\+?$/, ['Cardinal', 'NumericValue']], //percent
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ['Percent', 'Cardinal', 'NumericValue']], //7%  ..
  [/^\.[0-9]+%$/, ['Percent', 'Cardinal', 'NumericValue']], //.7%  ..
  //fraction
  [/^[0-9]{1,4}\/[0-9]{1,4}$/, 'Fraction'], //3/2ths
  //range
  [/^[0-9.]{1,2}[-][0-9]{1,2}$/, ['Value', 'NumberRange']], //7-8
  [/^[0-9.]{1,4}(st|nd|rd|th)?[-][0-9\.]{1,4}(st|nd|rd|th)?$/, 'NumberRange'], //5-7
  //with unit
  [/^[0-9.]+([a-z]{1,4})$/, 'Value'] //like 5tbsp
  //ordinal
  // [/^[0-9][0-9,.]*(st|nd|rd|r?th)$/, ['NumericValue', 'Ordinal']], //like 5th
  // [/^[0-9]+(st|nd|rd|th)$/, 'Ordinal'], //like 5th
  ];

  var romanNumeral = /^[IVXLCDM]{2,}$/;
  var romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/; //  https://stackoverflow.com/a/267405/168877
  //try each of the ^regexes in our list

  var checkRegex = function checkRegex(term, world) {
    var str = term.text; // do them all!

    for (var r = 0; r < startsWith.length; r += 1) {
      if (startsWith[r][0].test(str) === true) {
        term.tagSafe(startsWith[r][1], 'prefix #' + r, world);
        break;
      }
    } // do some more!
    //roman numberals - XVII


    if (term.text.length >= 2 && romanNumeral.test(str) && romanNumValid.test(str)) {
      term.tag('RomanNumeral', 'xvii', world);
    }
  };

  var _03Prefixes = checkRegex;

  //regex suffix patterns and their most common parts of speech,
  //built using wordnet, by spencer kelly.
  //this mapping shrinks-down the uglified build
  var Adj = 'Adjective';
  var Inf = 'Infinitive';
  var Pres = 'PresentTense';
  var Sing = 'Singular';
  var Past = 'PastTense';
  var Adverb = 'Adverb';
  var Exp = 'Expression';
  var Actor = 'Actor';
  var Verb = 'Verb';
  var Noun = 'Noun';
  var Last = 'LastName'; //the order here matters.
  //regexes indexed by mandated last-character

  var endsWith$1 = {
    a: [[/.[aeiou]na$/, Noun], [/.[oau][wvl]ska$/, Last], //polish (female)
    [/.[^aeiou]ica$/, Sing], [/^([hyj]a)+$/, Exp] //hahah
    ],
    c: [[/.[^aeiou]ic$/, Adj]],
    d: [//==-ed==
    //double-consonant
    [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, Past], //popped, planned
    //double-vowel
    [/.[aeo]{2}[bdgmnprvz]ed$/, Past], //beeped, mooned, veered
    //-hed
    [/.[aeiou][sg]hed$/, Past], //stashed, sighed
    //-rd
    [/.[aeiou]red$/, Past], //stored
    [/.[aeiou]r?ried$/, Past], //buried
    //-led
    [/.[bcdgtr]led$/, Past], //startled, rumbled
    [/.[aoui]f?led$/, Past], //impaled, stifled
    //-sed
    [/.[iao]sed$/, Past], //franchised
    [/[aeiou]n?[cs]ed$/, Past], //laced, lanced
    //-med
    [/[aeiou][rl]?[mnf]ed$/, Past], //warmed, attained, engulfed
    //-ked
    [/[aeiou][ns]?c?ked$/, Past], //hooked, masked
    //-ged
    [/[aeiou][nl]?ged$/, Past], //engaged
    //-ted
    [/.[tdbwxz]ed$/, Past], //bribed, boxed
    [/[^aeiou][aeiou][tvx]ed$/, Past], //boxed
    //-ied
    [/.[cdlmnprstv]ied$/, Past], //rallied
    [/[^aeiou]ard$/, Sing], //card
    [/[aeiou][^aeiou]id$/, Adj], [/.[vrl]id$/, Adj]],
    e: [[/.[lnr]ize$/, Inf], [/.[^aeiou]ise$/, Inf], [/.[aeiou]te$/, Inf], [/.[^aeiou][ai]ble$/, Adj], [/.[^aeiou]eable$/, Adj], [/.[ts]ive$/, Adj]],
    h: [[/.[^aeiouf]ish$/, Adj], [/.v[iy]ch$/, Last], //east-europe
    [/^ug?h+$/, Exp], //uhh
    [/^uh[ -]?oh$/, Exp] //uhoh
    ],
    i: [[/.[oau][wvl]ski$/, Last] //polish (male)
    ],
    k: [[/^(k){2}$/, Exp] //kkkk
    ],
    l: [[/.[gl]ial$/, Adj], [/.[^aeiou]ful$/, Adj], [/.[nrtumcd]al$/, Adj], [/.[^aeiou][ei]al$/, Adj]],
    m: [[/.[^aeiou]ium$/, Sing], [/[^aeiou]ism$/, Sing], [/^h*u*m+$/, Exp], //mmmmmmm / ummmm / huuuuuummmmmm
    [/^\d+ ?[ap]m$/, 'Date']],
    n: [[/.[lsrnpb]ian$/, Adj], [/[^aeiou]ician$/, Actor], [/[aeiou][ktrp]in$/, 'Gerund'] // 'cookin', 'hootin'
    ],
    o: [[/^no+$/, Exp], //noooo
    [/^(yo)+$/, Exp], //yoyo
    [/^woo+[pt]?$/, Exp] //woo
    ],
    r: [[/.[bdfklmst]ler$/, 'Noun'], [/.[ilk]er$/, 'Comparative'], [/[aeiou][pns]er$/, Sing], [/[^i]fer$/, Inf], [/.[^aeiou][ao]pher$/, Actor]],
    t: [[/.[di]est$/, 'Superlative'], [/.[icldtgrv]ent$/, Adj], [/[aeiou].*ist$/, Adj], [/^[a-z]et$/, Verb]],
    s: [[/.[rln]ates$/, Pres], [/.[^z]ens$/, Verb], [/.[lstrn]us$/, Sing], [/.[aeiou]sks$/, Pres], //masks
    [/.[aeiou]kes$/, Pres], //bakes
    [/[aeiou][^aeiou]is$/, Sing], [/[a-z]\'s$/, Noun], [/^yes+$/, Exp] //yessss
    ],
    v: [[/.[^aeiou][ai][kln]ov$/, Last] //east-europe
    ],
    y: [[/.[cts]hy$/, Adj], [/.[st]ty$/, Adj], [/.[gk]y$/, Adj], [/.[tnl]ary$/, Adj], [/.[oe]ry$/, Sing], [/[rdntkbhs]ly$/, Adverb], [/...lly$/, Adverb], [/[bszmp]{2}y$/, Adj], [/.(gg|bb|zz)ly$/, Adj], [/.[aeiou]my$/, Adj], [/[ea]{2}zy$/, Adj], [/.[^aeiou]ity$/, Sing]]
  };

  //just a foolish lookup of known suffixes
  var Adj$1 = 'Adjective';
  var Inf$1 = 'Infinitive';
  var Pres$1 = 'PresentTense';
  var Sing$1 = 'Singular';
  var Past$1 = 'PastTense';
  var Avb = 'Adverb';
  var Plrl = 'Plural';
  var Actor$1 = 'Actor';
  var Vb = 'Verb';
  var Noun$1 = 'Noun';
  var Last$1 = 'LastName';
  var Modal = 'Modal';
  var Place = 'Place'; // find any issues - https://observablehq.com/@spencermountain/suffix-word-lookup

  var suffixMap = [null, //0
  null, //1
  {
    //2-letter
    ea: Sing$1,
    ia: Noun$1,
    ic: Adj$1,
    ly: Avb,
    "'n": Vb,
    "'t": Vb
  }, {
    //3-letter
    oed: Past$1,
    ued: Past$1,
    xed: Past$1,
    ' so': Avb,
    "'ll": Modal,
    "'re": 'Copula',
    azy: Adj$1,
    end: Vb,
    ped: Past$1,
    ffy: Adj$1,
    ify: Inf$1,
    ing: 'Gerund',
    //likely to be converted to Adj after lexicon pass
    ize: Inf$1,
    lar: Adj$1,
    mum: Adj$1,
    nes: Pres$1,
    nny: Adj$1,
    oid: Adj$1,
    ous: Adj$1,
    que: Adj$1,
    rmy: Adj$1,
    rol: Sing$1,
    sis: Sing$1,
    zes: Pres$1
  }, {
    //4-letter
    amed: Past$1,
    aped: Past$1,
    ched: Past$1,
    lked: Past$1,
    nded: Past$1,
    cted: Past$1,
    dged: Past$1,
    akis: Last$1,
    //greek
    cede: Inf$1,
    chuk: Last$1,
    //east-europe
    czyk: Last$1,
    //polish (male)
    ects: Pres$1,
    ends: Vb,
    enko: Last$1,
    //east-europe
    ette: Sing$1,
    fies: Pres$1,
    fore: Avb,
    gate: Inf$1,
    gone: Adj$1,
    ices: Plrl,
    ints: Plrl,
    ines: Plrl,
    ions: Plrl,
    less: Avb,
    llen: Adj$1,
    made: Adj$1,
    nsen: Last$1,
    //norway
    oses: Pres$1,
    ould: Modal,
    some: Adj$1,
    sson: Last$1,
    //swedish male
    tage: Inf$1,
    teen: 'Value',
    tion: Sing$1,
    tive: Adj$1,
    tors: Noun$1,
    vice: Sing$1
  }, {
    //5-letter
    tized: Past$1,
    urned: Past$1,
    eased: Past$1,
    ances: Plrl,
    bound: Adj$1,
    ettes: Plrl,
    fully: Avb,
    ishes: Pres$1,
    ities: Plrl,
    marek: Last$1,
    //polish (male)
    nssen: Last$1,
    //norway
    ology: Noun$1,
    ports: Plrl,
    rough: Adj$1,
    tches: Pres$1,
    tieth: 'Ordinal',
    tures: Plrl,
    wards: Avb,
    where: Avb
  }, {
    //6-letter
    auskas: Last$1,
    //lithuania
    keeper: Actor$1,
    logist: Actor$1,
    teenth: 'Value'
  }, {
    //7-letter
    opoulos: Last$1,
    //greek
    borough: Place,
    //Hillsborough
    sdottir: Last$1 //swedish female

  }];

  var endRegexs = function endRegexs(term, world) {
    var str = term.clean;
    var _char = str[str.length - 1];

    if (endsWith$1.hasOwnProperty(_char) === true) {
      var regs = endsWith$1[_char];

      for (var r = 0; r < regs.length; r += 1) {
        if (regs[r][0].test(str) === true) {
          term.tagSafe(regs[r][1], "endReg ".concat(_char, " #").concat(r), world);
          break;
        }
      }
    }
  }; //sweep-through all suffixes


  var knownSuffixes = function knownSuffixes(term, world) {
    var len = term.clean.length;
    var max = 7;

    if (len <= max) {
      max = len - 1;
    }

    for (var i = max; i > 1; i -= 1) {
      var str = term.clean.substr(len - i, len);

      if (suffixMap[str.length].hasOwnProperty(str) === true) {
        var tag = suffixMap[str.length][str];
        term.tagSafe(tag, 'suffix -' + str, world);
        break;
      }
    }
  }; //all-the-way-down!


  var checkRegex$1 = function checkRegex(term, world) {
    knownSuffixes(term, world);
    endRegexs(term, world);
  };

  var _04Suffixes = checkRegex$1;

  //just some of the most common emoticons
  //faster than
  //http://stackoverflow.com/questions/28077049/regex-matching-emoticons
  var emoticons = {
    ':(': true,
    ':)': true,
    ':P': true,
    ':p': true,
    ':O': true,
    ':3': true,
    ':|': true,
    ':/': true,
    ':\\': true,
    ':$': true,
    ':*': true,
    ':@': true,
    ':-(': true,
    ':-)': true,
    ':-P': true,
    ':-p': true,
    ':-O': true,
    ':-3': true,
    ':-|': true,
    ':-/': true,
    ':-\\': true,
    ':-$': true,
    ':-*': true,
    ':-@': true,
    ':^(': true,
    ':^)': true,
    ':^P': true,
    ':^p': true,
    ':^O': true,
    ':^3': true,
    ':^|': true,
    ':^/': true,
    ':^\\': true,
    ':^$': true,
    ':^*': true,
    ':^@': true,
    '):': true,
    '(:': true,
    '$:': true,
    '*:': true,
    ')-:': true,
    '(-:': true,
    '$-:': true,
    '*-:': true,
    ')^:': true,
    '(^:': true,
    '$^:': true,
    '*^:': true,
    '<3': true,
    '</3': true,
    '<\\3': true
  };

  var emojiReg = /^(\u00a9|\u00ae|[\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/; //for us, there's three types -
  // * ;) - emoticons
  // *  - unicode emoji
  // * :smiling_face: - asci-represented emoji
  //test for forms like ':woman_tone2::ear_of_rice:'
  //https://github.com/Kikobeats/emojis-keywords/blob/master/index.js

  var isCommaEmoji = function isCommaEmoji(raw) {
    if (raw.charAt(0) === ':') {
      //end comma can be last or second-last ':haircut_tone3:'
      if (raw.match(/:.?$/) === null) {
        return false;
      } //ensure no spaces


      if (raw.match(' ')) {
        return false;
      } //reasonably sized


      if (raw.length > 35) {
        return false;
      }

      return true;
    }

    return false;
  }; //check against emoticon whitelist


  var isEmoticon = function isEmoticon(str) {
    str = str.replace(/^[:;]/, ':'); //normalize the 'eyes'

    return emoticons.hasOwnProperty(str);
  };

  var tagEmoji = function tagEmoji(term, world) {
    var raw = term.pre + term.text + term.post;
    raw = raw.trim(); //dont double-up on ending periods

    raw = raw.replace(/[.!?,]$/, ''); //test for :keyword: emojis

    if (isCommaEmoji(raw) === true) {
      term.tag('Emoji', 'comma-emoji', world);
      term.text = raw;
      term.pre = term.pre.replace(':', '');
      term.post = term.post.replace(':', '');
    } //test for unicode emojis


    if (term.text.match(emojiReg)) {
      term.tag('Emoji', 'unicode-emoji', world);
      term.text = raw;
    } //test for emoticon ':)' emojis


    if (isEmoticon(raw) === true) {
      term.tag('Emoticon', 'emoticon-emoji', world);
      term.text = raw;
    }
  };

  var _05Emoji = tagEmoji;

  var steps = {
    lexicon: _01Lexicon,
    punctuation: _02Punctuation$1,
    regex: _03Prefixes,
    suffix: _04Suffixes,
    emoji: _05Emoji
  }; //'lookups' look at a term by itself

  var lookups = function lookups(doc, terms) {
    var world = doc.world; //our list of known-words

    steps.lexicon(terms, world); //try these other methods

    for (var i = 0; i < terms.length; i += 1) {
      var term = terms[i]; //or maybe some helpful punctuation

      steps.punctuation(terms, i, world); //mostly prefix checks

      steps.regex(term, world); //maybe we can guess

      steps.suffix(term, world); //emoji and emoticons

      steps.emoji(term, world);
    }

    return doc;
  };

  var _01Init = lookups;

  //markov-like stats about co-occurance, for hints about unknown terms
  //basically, a little-bit better than the noun-fallback
  //just top n-grams from nlp tags, generated from nlp-corpus
  //after this word, here's what happens usually
  var afterThisWord = {
    i: 'Verb',
    //44% //i walk..
    first: 'Noun',
    //50% //first principles..
    it: 'Verb',
    //33%
    there: 'Verb',
    //35%
    not: 'Verb',
    //33%
    because: 'Noun',
    //31%
    "if": 'Noun',
    //32%
    but: 'Noun',
    //26%
    who: 'Verb',
    //40%
    "this": 'Noun',
    //37%
    his: 'Noun',
    //48%
    when: 'Noun',
    //33%
    you: 'Verb',
    //35%
    very: 'Adjective',
    // 39%
    old: 'Noun',
    //51%
    never: 'Verb',
    //42%
    before: 'Noun' //28%

  }; //in advance of this word, this is what happens usually

  var beforeThisWord = {
    there: 'Verb',
    //23% // be there
    me: 'Verb',
    //31% //see me
    man: 'Adjective',
    // 80% //quiet man
    only: 'Verb',
    //27% //sees only
    him: 'Verb',
    //32% //show him
    were: 'Noun',
    //48% //we were
    took: 'Noun',
    //38% //he took
    himself: 'Verb',
    //31% //see himself
    went: 'Noun',
    //43% //he went
    who: 'Noun',
    //47% //person who
    jr: 'Person'
  }; //following this POS, this is likely

  var afterThisPOS = {
    Adjective: 'Noun',
    //36% //blue dress
    Possessive: 'Noun',
    //41% //his song
    Determiner: 'Noun',
    //47%
    Adverb: 'Verb',
    //20%
    Pronoun: 'Verb',
    //40%
    Value: 'Noun',
    //47%
    Ordinal: 'Noun',
    //53%
    Modal: 'Verb',
    //35%
    Superlative: 'Noun',
    //43%
    Demonym: 'Noun',
    //38%
    Honorific: 'Person' //

  }; //in advance of this POS, this is likely

  var beforeThisPOS = {
    Copula: 'Noun',
    //44% //spencer is
    PastTense: 'Noun',
    //33% //spencer walked
    Conjunction: 'Noun',
    //36%
    Modal: 'Noun',
    //38%
    Pluperfect: 'Noun',
    //40%
    PerfectTense: 'Verb' //32%

  };
  var markov = {
    beforeThisWord: beforeThisWord,
    afterThisWord: afterThisWord,
    beforeThisPos: beforeThisPOS,
    afterThisPos: afterThisPOS
  };

  var afterKeys = Object.keys(markov.afterThisPos);
  var beforeKeys = Object.keys(markov.beforeThisPos);

  var checkNeighbours = function checkNeighbours(terms, world) {
    var _loop = function _loop(i) {
      var term = terms[i]; //do we still need a tag?

      if (term.isKnown() === true) {
        return "continue";
      } //ok, this term needs a tag.
      //look at previous word for clues..


      var lastTerm = terms[i - 1];

      if (lastTerm) {
        // 'foobar term'
        if (markov.afterThisWord.hasOwnProperty(lastTerm.clean) === true) {
          var tag = markov.afterThisWord[lastTerm.clean];
          term.tag(tag, 'after-' + lastTerm.clean, world);
          return "continue";
        } // 'Tag term'
        // (look at previous POS tags for clues..)


        var foundTag = afterKeys.find(function (tag) {
          return lastTerm.tags[tag];
        });

        if (foundTag !== undefined) {
          var _tag = markov.afterThisPos[foundTag];
          term.tag(_tag, 'after-' + foundTag, world);
          return "continue";
        }
      } //look at next word for clues..


      var nextTerm = terms[i + 1];

      if (nextTerm) {
        // 'term foobar'
        if (markov.beforeThisWord.hasOwnProperty(nextTerm.clean) === true) {
          var _tag2 = markov.beforeThisWord[nextTerm.clean];
          term.tag(_tag2, 'before-' + nextTerm.clean, world);
          return "continue";
        } // 'term Tag'
        // (look at next POS tags for clues..)


        var _foundTag = beforeKeys.find(function (tag) {
          return nextTerm.tags[tag];
        });

        if (_foundTag !== undefined) {
          var _tag3 = markov.beforeThisPos[_foundTag];
          term.tag(_tag3, 'before-' + _foundTag, world);
          return "continue";
        }
      }
    };

    for (var i = 0; i < terms.length; i += 1) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }
  };

  var _01Neighbours = checkNeighbours;

  var titleCase$4 = /^[A-Z][a-z'\u00C0-\u00FF]/;
  var hasNumber = /[0-9]/;
  /** look for any grammar signals based on capital/lowercase */

  var checkCase = function checkCase(doc) {
    var world = doc.world;
    doc.list.forEach(function (p) {
      var terms = p.terms();

      for (var i = 1; i < terms.length; i++) {
        var term = terms[i];

        if (titleCase$4.test(term.text) === true && hasNumber.test(term.text) === false) {
          term.tag('ProperNoun', 'titlecase-noun', world);
        }
      }
    });
  };

  var _02Case = checkCase;

  var hasPrefix = /^(re|un)-?[a-z\u00C0-\u00FF]/;
  var prefix = /^(re|un)-?/;
  /** check 'rewatch' in lexicon as 'watch' */

  var checkPrefix = function checkPrefix(terms, world) {
    var lex = world.words;
    terms.forEach(function (term) {
      // skip if we have a good tag already
      if (term.isKnown() === true) {
        return;
      } //does it start with 'un|re'


      if (hasPrefix.test(term.clean) === true) {
        // look for the root word in the lexicon:
        var stem = term.clean.replace(prefix, '');

        if (stem && stem.length > 3 && lex[stem] !== undefined && lex.hasOwnProperty(stem) === true) {
          term.tag(lex[stem], 'stem-' + stem, world);
        }
      }
    });
  };

  var _03Stem = checkPrefix;

  //similar to plural/singularize rules, but not the same
  var isPlural = [/(^v)ies$/i, /ises$/i, /ives$/i, /(antenn|formul|nebul|vertebr|vit)ae$/i, /(octop|vir|radi|nucle|fung|cact|stimul)i$/i, /(buffal|tomat|tornad)oes$/i, /(analy|ba|diagno|parenthe|progno|synop|the)ses$/i, /(vert|ind|cort)ices$/i, /(matr|append)ices$/i, /(x|ch|ss|sh|s|z|o)es$/i, /is$/i, /men$/i, /news$/i, /.tia$/i, /(^f)ves$/i, /(lr)ves$/i, /(^aeiouy|qu)ies$/i, /(m|l)ice$/i, /(cris|ax|test)es$/i, /(alias|status)es$/i, /ics$/i]; //similar to plural/singularize rules, but not the same

  var isSingular = [/(ax|test)is$/i, /(octop|vir|radi|nucle|fung|cact|stimul)us$/i, /(octop|vir)i$/i, /(rl)f$/i, /(alias|status)$/i, /(bu)s$/i, /(al|ad|at|er|et|ed|ad)o$/i, /(ti)um$/i, /(ti)a$/i, /sis$/i, /(?:(^f)fe|(lr)f)$/i, /hive$/i, /s[aeiou]+ns$/i, // sans, siens
  /(^aeiouy|qu)y$/i, /(x|ch|ss|sh|z)$/i, /(matr|vert|ind|cort)(ix|ex)$/i, /(m|l)ouse$/i, /(m|l)ice$/i, /(antenn|formul|nebul|vertebr|vit)a$/i, /.sis$/i, /^(?!talis|.*hu)(.*)man$/i];
  var isPlural_1 = {
    isSingular: isSingular,
    isPlural: isPlural
  };

  var noPlurals = ['Uncountable', 'Pronoun', 'Place', 'Value', 'Person', 'Month', 'WeekDay', 'Holiday'];
  var notPlural = [/ss$/, /sis$/, /[^aeiou][uo]s$/, /'s$/];
  var notSingular = [/i$/, /ae$/];
  /** turn nouns into singular/plural */

  var checkPlural = function checkPlural(t, world) {
    if (t.tags.Noun && !t.tags.Acronym) {
      var str = t.clean; //skip existing tags, fast

      if (t.tags.Singular || t.tags.Plural) {
        return;
      } //too short


      if (str.length <= 3) {
        t.tag('Singular', 'short-singular', world);
        return;
      } //is it impossible to be plural?


      if (noPlurals.find(function (tag) {
        return t.tags[tag];
      })) {
        return;
      } // isPlural suffix rules


      if (isPlural_1.isPlural.find(function (reg) {
        return reg.test(str);
      })) {
        t.tag('Plural', 'plural-rules', world);
        return;
      } // isSingular suffix rules


      if (isPlural_1.isSingular.find(function (reg) {
        return reg.test(str);
      })) {
        t.tag('Singular', 'singular-rules', world);
        return;
      } // finally, fallback 'looks plural' rules..


      if (/s$/.test(str) === true) {
        //avoid anything too sketchy to be plural
        if (notPlural.find(function (reg) {
          return reg.test(str);
        })) {
          return;
        }

        t.tag('Plural', 'plural-fallback', world);
        return;
      } //avoid anything too sketchy to be singular


      if (notSingular.find(function (reg) {
        return reg.test(str);
      })) {
        return;
      }

      t.tag('Singular', 'singular-fallback', world);
    }
  };

  var _04Plurals = checkPlural;

  //nouns that also signal the title of an unknown organization
  //todo remove/normalize plural forms
  var orgWords = ['academy', 'administration', 'agence', 'agences', 'agencies', 'agency', 'airlines', 'airways', 'army', 'assoc', 'associates', 'association', 'assurance', 'authority', 'autorite', 'aviation', 'bank', 'banque', 'board', 'boys', 'brands', 'brewery', 'brotherhood', 'brothers', 'building society', 'bureau', 'cafe', 'caisse', 'capital', 'care', 'cathedral', 'center', 'central bank', 'centre', 'chemicals', 'choir', 'chronicle', 'church', 'circus', 'clinic', 'clinique', 'club', 'co', 'coalition', 'coffee', 'collective', 'college', 'commission', 'committee', 'communications', 'community', 'company', 'comprehensive', 'computers', 'confederation', 'conference', 'conseil', 'consulting', 'containers', 'corporation', 'corps', 'corp', 'council', 'crew', 'daily news', 'data', 'departement', 'department', 'department store', 'departments', 'design', 'development', 'directorate', 'division', 'drilling', 'education', 'eglise', 'electric', 'electricity', 'energy', 'ensemble', 'enterprise', 'enterprises', 'entertainment', 'estate', 'etat', 'evening news', 'faculty', 'federation', 'financial', 'fm', 'foundation', 'fund', 'gas', 'gazette', 'girls', 'government', 'group', 'guild', 'health authority', 'herald', 'holdings', 'hospital', 'hotel', 'hotels', 'inc', 'industries', 'institut', 'institute', 'institute of technology', 'institutes', 'insurance', 'international', 'interstate', 'investment', 'investments', 'investors', 'journal', 'laboratory', 'labs', // 'law',
  'liberation army', 'limited', 'local authority', 'local health authority', 'machines', 'magazine', 'management', 'marine', 'marketing', 'markets', 'media', 'memorial', 'mercantile exchange', 'ministere', 'ministry', 'military', 'mobile', 'motor', 'motors', 'musee', 'museum', // 'network',
  'news', 'news service', 'observatory', 'office', 'oil', 'optical', 'orchestra', 'organization', 'partners', 'partnership', // 'party',
  "people's party", 'petrol', 'petroleum', 'pharmacare', 'pharmaceutical', 'pharmaceuticals', 'pizza', 'plc', 'police', 'polytechnic', 'post', 'power', 'press', 'productions', 'quartet', 'radio', 'regional authority', 'regional health authority', 'reserve', 'resources', 'restaurant', 'restaurants', 'savings', 'school', 'securities', 'service', 'services', 'social club', 'societe', 'society', 'sons', 'standard', 'state police', 'state university', 'stock exchange', 'subcommittee', 'syndicat', 'systems', 'telecommunications', 'telegraph', 'television', 'times', 'tribunal', 'tv', 'union', 'university', 'utilities', 'workers'];
  var organizations = orgWords.reduce(function (h, str) {
    h[str] = 'Noun';
    return h;
  }, {});

  var maybeOrg = function maybeOrg(t) {
    //must be a noun
    if (!t.tags.Noun) {
      return false;
    } //can't be these things


    if (t.tags.Pronoun || t.tags.Comma || t.tags.Possessive) {
      return false;
    } //must be one of these


    if (t.tags.Organization || t.tags.Acronym || t.tags.Place || t.titleCase()) {
      return true;
    }

    return false;
  };

  var tagOrgs = function tagOrgs(terms, world) {
    for (var i = 0; i < terms.length; i += 1) {
      var t = terms[i];

      if (organizations[t.clean] !== undefined && organizations.hasOwnProperty(t.clean) === true) {
        // look-backward - eg. 'Toronto University'
        var lastTerm = terms[i - 1];

        if (lastTerm !== undefined && maybeOrg(lastTerm) === true) {
          lastTerm.tagSafe('Organization', 'org-word-1', world);
          t.tagSafe('Organization', 'org-word-2', world);
          continue;
        } //look-forward - eg. University of Toronto


        var nextTerm = terms[i + 1];

        if (nextTerm !== undefined && nextTerm.clean === 'of') {
          if (terms[i + 2] && maybeOrg(terms[i + 2])) {
            t.tagSafe('Organization', 'org-of-word-1', world);
            nextTerm.tagSafe('Organization', 'org-of-word-2', world);
            terms[i + 2].tagSafe('Organization', 'org-of-word-3', world);
            continue;
          }
        }
      }
    }
  };

  var _05Organizations = tagOrgs;

  var oneLetterAcronym$1 = /^[A-Z]('s|,)?$/;
  var periodSeperated = /([A-Z]\.){2}[A-Z]?/i;
  var oneLetterWord = {
    I: true,
    A: true
  };

  var isAcronym$2 = function isAcronym(term, world) {
    var str = term.reduced; // a known acronym like fbi

    if (term.tags.Acronym) {
      return true;
    } // if (term.tags.Adverb || term.tags.Verb || term.tags.Value || term.tags.Plural) {
    //   return false
    // }
    // known-words, like 'PIZZA' is not an acronym.


    if (world.words[str]) {
      return false;
    }

    return term.isAcronym();
  }; // F.B.I., NBC, - but not 'NO COLLUSION'


  var checkAcronym = function checkAcronym(terms, world) {
    terms.forEach(function (term) {
      //these are not acronyms
      if (term.tags.RomanNumeral === true) {
        return;
      } //period-ones F.D.B.


      if (periodSeperated.test(term.text) === true) {
        term.tag('Acronym', 'period-acronym', world);
      } //non-period ones are harder


      if (term.isUpperCase() && isAcronym$2(term, world)) {
        term.tag('Acronym', 'acronym-step', world);
        term.tag('Noun', 'acronym-infer', world);
      } else if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym$1.test(term.text)) {
        term.tag('Acronym', 'one-letter-acronym', world);
        term.tag('Noun', 'one-letter-infer', world);
      } //if it's a organization,


      if (term.tags.Organization && term.text.length <= 3) {
        term.tag('Acronym', 'acronym-org', world);
      }

      if (term.tags.Organization && term.isUpperCase() && term.text.length <= 6) {
        term.tag('Acronym', 'acronym-org-case', world);
      }
    });
  };

  var _06Acronyms = checkAcronym;

  var step = {
    neighbours: _01Neighbours,
    "case": _02Case,
    stem: _03Stem,
    plural: _04Plurals,
    organizations: _05Organizations,
    acronyms: _06Acronyms
  }; //

  var fallbacks = function fallbacks(doc, terms) {
    var world = doc.world; // if it's empty, consult it's neighbours, first

    step.neighbours(terms, world); // is there a case-sensitive clue?

    step["case"](doc); // check 'rewatch' as 'watch'

    step.stem(terms, world); // ... fallback to a noun!

    terms.forEach(function (t) {
      if (t.isKnown() === false) {
        t.tag('Noun', 'noun-fallback', doc.world);
      }
    }); // turn 'Foo University' into an Org

    step.organizations(terms, world); //turn 'FBD' into an acronym

    step.acronyms(terms, world); //are the nouns singular or plural?

    terms.forEach(function (t) {
      step.plural(t, doc.world);
    });
    return doc;
  };

  var _02Fallbacks = fallbacks;

  var hasNegative = /n't$/;
  var irregulars$3 = {
    "won't": ['will', 'not'],
    wont: ['will', 'not'],
    "can't": ['can', 'not'],
    cant: ['can', 'not'],
    cannot: ['can', 'not'],
    "shan't": ['should', 'not'],
    dont: ['do', 'not'],
    dun: ['do', 'not'] // "ain't" is ambiguous for is/was

  }; // either 'is not' or 'are not'

  var doAint = function doAint(term, phrase) {
    var terms = phrase.terms();
    var index = terms.indexOf(term);
    var before = terms.slice(0, index); //look for the preceding noun

    var noun = before.find(function (t) {
      return t.tags.Noun;
    });

    if (noun && noun.tags.Plural) {
      return ['are', 'not'];
    }

    return ['is', 'not'];
  };

  var checkNegative = function checkNegative(term, phrase) {
    //check named-ones
    if (irregulars$3.hasOwnProperty(term.clean) === true) {
      return irregulars$3[term.clean];
    } //this word needs it's own logic:


    if (term.clean === "ain't" || term.clean === 'aint') {
      return doAint(term, phrase);
    } //try it normally


    if (hasNegative.test(term.clean) === true) {
      var main = term.clean.replace(hasNegative, '');
      return [main, 'not'];
    }

    return null;
  };

  var _01Negative = checkNegative;

  var contraction = /([a-z\u00C0-\u00FF]+)[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]([a-z]{1,2})$/i; //these ones don't seem to be ambiguous

  var easy = {
    ll: 'will',
    ve: 'have',
    re: 'are',
    m: 'am',
    "n't": 'not'
  }; //

  var checkApostrophe = function checkApostrophe(term) {
    var parts = term.text.match(contraction);

    if (parts === null) {
      return null;
    }

    if (easy.hasOwnProperty(parts[2])) {
      return [parts[1], easy[parts[2]]];
    }

    return null;
  };

  var _02Simple = checkApostrophe;

  var irregulars$4 = {
    wanna: ['want', 'to'],
    gonna: ['going', 'to'],
    im: ['i', 'am'],
    alot: ['a', 'lot'],
    ive: ['i', 'have'],
    imma: ['I', 'will'],
    "where'd": ['where', 'did'],
    whered: ['where', 'did'],
    "when'd": ['when', 'did'],
    whend: ['when', 'did'],
    // "how'd": ['how', 'did'], //'how would?'
    // "what'd": ['what', 'did'], //'what would?'
    howd: ['how', 'did'],
    whatd: ['what', 'did'],
    // "let's": ['let', 'us'], //too weird
    //multiple word contractions
    dunno: ['do', 'not', 'know'],
    brb: ['be', 'right', 'back'],
    gtg: ['got', 'to', 'go'],
    irl: ['in', 'real', 'life'],
    tbh: ['to', 'be', 'honest'],
    imo: ['in', 'my', 'opinion'],
    til: ['today', 'i', 'learned'],
    rn: ['right', 'now'],
    twas: ['it', 'was'],
    '@': ['at']
  }; //

  var checkIrregulars = function checkIrregulars(term) {
    //check white-list
    if (irregulars$4.hasOwnProperty(term.clean)) {
      return irregulars$4[term.clean];
    }

    return null;
  };

  var _03Irregulars = checkIrregulars;

  var hasApostropheS = /([a-z\u00C0-\u00FF]+)[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]s$/i;
  var banList = {
    that: true,
    there: true
  };

  var isPossessive = function isPossessive(term, pool) {
    // if we already know it
    if (term.tags.Possessive) {
      return true;
    } //a pronoun can't be possessive - "he's house"


    if (term.tags.Pronoun || term.tags.QuestionWord) {
      return false;
    }

    if (banList.hasOwnProperty(term.reduced)) {
      return false;
    } //if end of sentence, it is possessive - "was spencer's"


    var nextTerm = pool.get(term.next);

    if (!nextTerm) {
      return true;
    } //a gerund suggests 'is walking'


    if (nextTerm.tags.Verb) {
      //fix 'jamie's bite'
      if (nextTerm.tags.Infinitive) {
        return true;
      } //fix 'spencer's runs'


      if (nextTerm.tags.PresentTense) {
        return true;
      }

      return false;
    } //spencer's house


    if (nextTerm.tags.Noun) {
      return true;
    } //rocket's red glare


    var twoTerm = pool.get(nextTerm.next);

    if (twoTerm && twoTerm.tags.Noun && !twoTerm.tags.Pronoun) {
      return true;
    } //othwerwise, an adjective suggests 'is good'


    if (nextTerm.tags.Adjective || nextTerm.tags.Adverb || nextTerm.tags.Verb) {
      return false;
    }

    return false;
  };

  var isHas = function isHas(term, phrase) {
    var terms = phrase.terms();
    var index = terms.indexOf(term);
    var after = terms.slice(index + 1, index + 3); //look for a past-tense verb

    return after.find(function (t) {
      return t.tags.PastTense;
    });
  };

  var checkPossessive = function checkPossessive(term, phrase, world) {
    //the rest of 's
    var found = term.text.match(hasApostropheS);

    if (found !== null) {
      //spencer's thing vs spencer-is
      if (isPossessive(term, phrase.pool) === true) {
        term.tag('#Possessive', 'isPossessive', world);
        return null;
      } //'spencer is'


      if (found !== null) {
        if (isHas(term, phrase)) {
          return [found[1], 'has'];
        }

        return [found[1], 'is'];
      }
    }

    return null;
  };

  var _04Possessive = checkPossessive;

  var hasPerfect = /[a-z\u00C0-\u00FF]'d$/;
  var useDid = {
    how: true,
    what: true
  };
  /** split `i'd` into 'i had',  or 'i would'  */

  var checkPerfect = function checkPerfect(term, phrase) {
    if (hasPerfect.test(term.clean)) {
      var root = term.clean.replace(/'d$/, ''); //look at the next few words

      var terms = phrase.terms();
      var index = terms.indexOf(term);
      var after = terms.slice(index + 1, index + 4); //is it before a past-tense verb? - 'i'd walked'

      for (var i = 0; i < after.length; i++) {
        var t = after[i];

        if (t.tags.Verb) {
          if (t.tags.PastTense) {
            return [root, 'had'];
          } //what'd you see


          if (useDid[root] === true) {
            return [root, 'did'];
          }

          return [root, 'would'];
        }
      } //otherwise, 'i'd walk'


      return [root, 'would'];
    }

    return null;
  };

  var _05PerfectTense = checkPerfect;

  var isRange = /^([0-9]+)[-]([0-9]+)$/i; //split '2-4' into '2 to 4'

  var checkRange = function checkRange(term) {
    if (term.tags.PhoneNumber === true) {
      return null;
    }

    var parts = term.text.match(isRange);

    if (parts !== null) {
      return [parts[1], 'to', parts[2]];
    }

    return null;
  };

  var _06Ranges = checkRange;

  var contraction$1 = /^(l|c|d|j|m|n|qu|s|t)[\u0027\u0060\u00B4\u2018\u2019\u201A\u201B\u2032\u2035\u2039\u203A]([a-z\u00C0-\u00FF]+)$/i; // basic support for ungendered french contractions
  // not perfect, but better than nothing, to support matching on french text.

  var french = {
    l: 'le',
    // l'amour
    c: 'ce',
    // c'est
    d: 'de',
    // d'amerique
    j: 'je',
    // j'aime
    m: 'me',
    // m'appelle
    n: 'ne',
    // n'est
    qu: 'que',
    // qu'il
    s: 'se',
    // s'appelle
    t: 'tu' // t'aime

  };

  var checkFrench = function checkFrench(term) {
    var parts = term.text.match(contraction$1);

    if (parts === null || french.hasOwnProperty(parts[1]) === false) {
      return null;
    }

    var arr = [french[parts[1]], parts[2]];

    if (arr[0] && arr[1]) {
      return arr;
    }

    return null;
  };

  var _07French = checkFrench;

  var isNumber = /^[0-9]+$/;

  var createPhrase = function createPhrase(found, doc) {
    //create phrase from ['would', 'not']
    var phrase = _01Tokenizer(found.join(' '), doc.world, doc.pool())[0]; //tag it

    var terms = phrase.terms();
    _01Lexicon(terms, doc.world); //make these terms implicit

    terms.forEach(function (t) {
      t.implicit = t.text;
      t.text = '';
      t.clean = ''; // remove whitespace for implicit terms

      t.pre = '';
      t.post = ''; // tag number-ranges

      if (isNumber.test(t.implicit)) {
        t.tags.Number = true;
        t.tags.Cardinal = true;
      }
    });
    return phrase;
  };

  var contractions = function contractions(doc) {
    var world = doc.world;
    doc.list.forEach(function (p) {
      var terms = p.terms();

      for (var i = 0; i < terms.length; i += 1) {
        var term = terms[i];
        var found = _01Negative(term, p);
        found = found || _02Simple(term);
        found = found || _03Irregulars(term);
        found = found || _04Possessive(term, p, world);
        found = found || _05PerfectTense(term, p);
        found = found || _06Ranges(term);
        found = found || _07French(term); //add them in

        if (found !== null) {
          var newPhrase = createPhrase(found, doc); // keep tag NumberRange, if we had it

          if (p.has('#NumberRange') === true) {
            doc.buildFrom([newPhrase]).tag('NumberRange');
          } //set text as contraction


          var firstTerm = newPhrase.terms(0);
          firstTerm.text = term.text; //grab sub-phrase to remove

          var match = p.buildFrom(term.id, 1, doc.pool());
          match.replace(newPhrase, doc, true);
        }
      }
    });
    return doc;
  };

  var _03Contractions = contractions;

  var hasWord = function hasWord(doc, word) {
    var arr = doc._cache.words[word] || [];
    arr = arr.map(function (i) {
      return doc.list[i];
    });
    return doc.buildFrom(arr);
  };

  var hasTag = function hasTag(doc, tag) {
    var arr = doc._cache.tags[tag] || [];
    arr = arr.map(function (i) {
      return doc.list[i];
    });
    return doc.buildFrom(arr);
  }; //mostly pos-corections here


  var miscCorrection = function miscCorrection(doc) {
    //exactly like
    var m = hasWord(doc, 'like');
    m.match('#Adverb like').notIf('(really|generally|typically|usually|sometimes|often) [like]').tag('Adverb', 'adverb-like'); //the orange.

    m = hasTag(doc, 'Adjective');
    m.match('#Determiner #Adjective$').notIf('(#Comparative|#Superlative)').terms(1).tag('Noun', 'the-adj-1'); // Firstname x (dangerous)

    m = hasTag(doc, 'FirstName');
    m.match('#FirstName (#Noun|@titleCase)').ifNo('^#Possessive').ifNo('#Pronoun').ifNo('@hasComma .').lastTerm().tag('#LastName', 'firstname-noun'); //three trains / one train

    m = hasTag(doc, 'Value');
    m = m.match('#Value #PresentTense');

    if (m.found) {
      if (m.has('(one|1)') === true) {
        m.terms(1).tag('Singular', 'one-presentTense');
      } else {
        m.terms(1).tag('Plural', 'value-presentTense');
      }
    } // well i've been...


    doc.match('^(well|so|okay)').tag('Expression', 'well-'); //been walking

    m = hasTag(doc, 'Gerund');
    m.match("(be|been) (#Adverb|not)+? #Gerund").not('#Verb$').tag('Auxiliary', 'be-walking'); // directive verb - 'use reverse'

    doc.match('(try|use|attempt|build|make) #Verb').ifNo('(@hasComma|#Negative|#Copula|will|be)').lastTerm().tag('#Noun', 'do-verb'); //possessives
    //'her match' vs 'let her match'

    m = hasTag(doc, 'Possessive');
    m = m.match('#Possessive [#Infinitive]', 0);

    if (!m.lookBehind('(let|made|make|force|ask)').found) {
      m.tag('Noun', 'her-match');
    }

    return doc;
  };

  var fixMisc = miscCorrection;

  var unique$5 = function unique(arr) {
    var obj = {};

    for (var i = 0; i < arr.length; i++) {
      obj[arr[i]] = true;
    }

    return Object.keys(obj);
  };

  var _unique = unique$5;

  // order matters
  var list = [// ==== Mutliple tags ====
  {
    match: 'too much',
    tag: 'Adverb Adjective',
    reason: 'bit-4'
  }, // u r cool
  {
    match: 'u r',
    tag: 'Pronoun Copula',
    reason: 'u r'
  }, //sometimes adverbs - 'pretty good','well above'
  {
    match: '#Copula (pretty|dead|full|well) (#Adjective|#Noun)',
    tag: '#Copula #Adverb #Adjective',
    reason: 'sometimes-adverb'
  }, //walking is cool
  {
    match: '[#Gerund] #Adverb? not? #Copula',
    group: 0,
    tag: 'Activity',
    reason: 'gerund-copula'
  }, //walking should be fun
  {
    match: '[#Gerund] #Modal',
    group: 0,
    tag: 'Activity',
    reason: 'gerund-modal'
  }, //swear-words as non-expression POS
  {
    match: 'holy (shit|fuck|hell)',
    tag: 'Expression',
    reason: 'swears-expression'
  }, //Aircraft designer
  {
    match: '#Noun #Actor',
    tag: 'Actor',
    reason: 'thing-doer'
  }, {
    match: '#Conjunction [u]',
    group: 0,
    tag: 'Pronoun',
    reason: 'u-pronoun-2'
  }, //'u' as pronoun
  {
    match: '[u] #Verb',
    group: 0,
    tag: 'Pronoun',
    reason: 'u-pronoun-1'
  }, // ==== Determiners ====
  {
    match: '#Noun [(who|whom)]',
    group: 0,
    tag: 'Determiner',
    reason: 'captain-who'
  }, //that car goes
  {
    match: 'that #Noun [#Verb]',
    group: 0,
    tag: 'Determiner',
    reason: 'that-determiner'
  }, {
    match: 'a bit much',
    tag: 'Determiner Adverb Adjective',
    reason: 'bit-3'
  }, // ==== Propositions ====
  //all students
  {
    match: '#Verb #Adverb? #Noun [(that|which)]',
    group: 0,
    tag: 'Preposition',
    reason: 'that-prep'
  }, //work, which has been done.
  {
    match: '@hasComma [which] (#Pronoun|#Verb)',
    group: 0,
    tag: 'Preposition',
    reason: 'which-copula'
  }, 
  {
    match: 'just [like]',
    group: 0,
    tag: 'Preposition',
    reason: 'like-preposition'
  }, //folks like her
  {
    match: '#Noun [like] #Noun',
    group: 0,
    tag: 'Preposition',
    reason: 'noun-like'
  }, //fix for busted-up phrasalVerbs
  {
    match: '#Noun [#Particle]',
    group: 0,
    tag: 'Preposition',
    reason: 'repair-noPhrasal'
  }, // ==== Conditions ====
  // had he survived,
  {
    match: '[had] #Noun+ #PastTense',
    group: 0,
    tag: 'Condition',
    reason: 'had-he'
  }, // were he to survive
  {
    match: '[were] #Noun+ to #Infinitive',
    group: 0,
    tag: 'Condition',
    reason: 'were-he'
  }, // ==== Questions ====
  //the word 'how'
  {
    match: '^how',
    tag: 'QuestionWord',
    reason: 'how-question'
  }, {
    match: '[how] (#Determiner|#Copula|#Modal|#PastTense)',
    group: 0,
    tag: 'QuestionWord',
    reason: 'how-is'
  }, // //the word 'which'
  {
    match: '^which',
    tag: 'QuestionWord',
    reason: 'which-question'
  }, {
    match: '[which] . (#Noun)+ #Pronoun',
    group: 0,
    tag: 'QuestionWord',
    reason: 'which-question2'
  }, // { match: 'which', tag: 'QuestionWord', reason: 'which-question3' },
  // ==== Conjunctions ====
  {
    match: '[so] #Noun',
    group: 0,
    tag: 'Conjunction',
    reason: 'so-conj'
  }, //how he is driving
  {
    match: '[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)',
    group: 0,
    tag: 'Conjunction',
    reason: 'how-he-is-x'
  }, 
  {
    match: '[(who|what|where|why|how|when)] #Noun #Adverb? #Infinitive not? #Gerund',
    group: 0,
    tag: 'Conjunction',
    reason: 'when i go fishing'
  },
  { /*@blab+*/
    match: '^[(who|what|where|why|how|when)] #Adjective? #Verb #Pronoun',
    group: 0,
    tag: 'Adverb',
    reason: 'where-question'
  },
  { /*@blab+*/
    match: 'the way',
    tag: 'Noun',
    reason: 'fix-1'
  },  
  ];
  var _01Misc = list;

  //Dates: 'june' or 'may'
  var dates = '(april|june|may|jan|august|eve)';
  var list$1 = [// ==== Holiday ====
  {
    match: '#Holiday (day|eve)',
    tag: 'Holiday',
    reason: 'holiday-day'
  }, // the captain who
  // ==== WeekDay ====
  // sun the 5th
  {
    match: '[sun] the #Ordinal',
    tag: 'WeekDay',
    reason: 'sun-the-5th'
  }, //sun feb 2
  {
    match: '[sun] #Date',
    group: 0,
    tag: 'WeekDay',
    reason: 'sun-feb'
  }, //1pm next sun
  {
    match: '#Date (on|this|next|last|during)? [sun]',
    group: 0,
    tag: 'WeekDay',
    reason: '1pm-sun'
  }, //this sat
  {
    match: "(in|by|before|during|on|until|after|of|within|all) [sat]",
    group: 0,
    tag: 'WeekDay',
    reason: 'sat'
  }, //sat november
  {
    match: '[sat] #Date',
    group: 0,
    tag: 'WeekDay',
    reason: 'sat-feb'
  }, // ==== Month ====
  //all march
  {
    match: "#Preposition [(march|may)]",
    group: 0,
    tag: 'Month',
    reason: 'in-month'
  }, //this march
  {
    match: "this [(march|may)]",
    group: 0,
    tag: 'Month',
    reason: 'this-month'
  }, {
    match: "next [(march|may)]",
    group: 0,
    tag: 'Month',
    reason: 'this-month'
  }, {
    match: "last [(march|may)]",
    group: 0,
    tag: 'Month',
    reason: 'this-month'
  }, // march 5th
  {
    match: "[(march|may)] the? #Value",
    group: 0,
    tag: 'Month',
    reason: 'march-5th'
  }, // 5th of march
  {
    match: "#Value of? [(march|may)]",
    group: 0,
    tag: 'Month',
    reason: '5th-of-march'
  }, // march and feb
  {
    match: "[(march|may)] .? #Date",
    group: 0,
    tag: 'Month',
    reason: 'march-and-feb'
  }, // feb to march
  {
    match: "#Date .? [(march|may)]",
    group: 0,
    tag: 'Month',
    reason: 'feb-and-march'
  }, //quickly march
  {
    match: "#Adverb [(march|may)]",
    group: 0,
    tag: 'Verb',
    reason: 'quickly-march'
  }, //march quickly
  {
    match: "[(march|may)] #Adverb",
    group: 0,
    tag: 'Verb',
    reason: 'march-quickly'
  }, //5th of March
  {
    match: '#Value of #Month',
    tag: 'Date',
    reason: 'value-of-month'
  }, //5 March
  {
    match: '#Cardinal #Month',
    tag: 'Date',
    reason: 'cardinal-month'
  }, //march 5 to 7
  {
    match: '#Month #Value to #Value',
    tag: 'Date',
    reason: 'value-to-value'
  }, //march the 12th
  {
    match: '#Month the #Value',
    tag: 'Date',
    reason: 'month-the-value'
  }, //june 7
  {
    match: '(#WeekDay|#Month) #Value',
    tag: 'Date',
    reason: 'date-value'
  }, //7 june
  {
    match: '#Value (#WeekDay|#Month)',
    tag: 'Date',
    reason: 'value-date'
  }, //may twenty five
  {
    match: '(#TextValue && #Date) #TextValue',
    tag: 'Date',
    reason: 'textvalue-date'
  }, // in june
  {
    match: "in [".concat(dates, "]"),
    group: 0,
    tag: 'Date',
    reason: 'in-june'
  }, {
    match: "during [".concat(dates, "]"),
    group: 0,
    tag: 'Date',
    reason: 'in-june'
  }, {
    match: "on [".concat(dates, "]"),
    group: 0,
    tag: 'Date',
    reason: 'in-june'
  }, {
    match: "by [".concat(dates, "]"),
    group: 0,
    tag: 'Date',
    reason: 'in-june'
  }, {
    match: "before [".concat(dates, "]"),
    group: 0,
    tag: 'Date',
    reason: 'in-june'
  }, {
    match: "#Date [".concat(dates, "]"),
    group: 0,
    tag: 'Date',
    reason: 'in-june'
  }, // june 1992
  {
    match: "".concat(dates, " #Value"),
    tag: 'Date',
    reason: 'june-5th'
  }, {
    match: "".concat(dates, " #Date"),
    tag: 'Date',
    reason: 'june-5th'
  }, // June Smith
  {
    match: "".concat(dates, " #ProperNoun"),
    tag: 'Person',
    reason: 'june-smith',
    safe: true
  }, // june m. Cooper
  {
    match: "".concat(dates, " #Acronym? (#ProperNoun && !#Month)"),
    tag: 'Person',
    reason: 'june-smith-jr'
  }, // 'second'
  {
    match: "#Cardinal [second]",
    tag: 'Unit',
    reason: 'one-second'
  }];
  var _02Dates = list$1;

  var _03Noun = [// ==== Plural ====
  //there are reasons
  {
    match: 'there (are|were) #Adjective? [#PresentTense]',
    group: 0,
    tag: 'Plural',
    reason: 'there-are'
  }, // ==== Singular ====
  //the sun
  {
    match: '#Determiner [sun]',
    group: 0,
    tag: 'Singular',
    reason: 'the-sun'
  }, //did a 900, paid a 20
  {
    match: '#Verb (a|an) [#Value]',
    group: 0,
    tag: 'Singular',
    reason: 'did-a-value'
  }, //'the can'
  {
    match: '#Determiner [(can|will|may)]',
    group: 0,
    tag: 'Singular',
    reason: 'the can'
  }, // ==== Possessive ====
  //spencer kelly's
  {
    match: '#FirstName #Acronym? (#Possessive && #LastName)',
    tag: 'Possessive',
    reason: 'name-poss'
  }, //Super Corp's fundraiser
  {
    match: '#Organization+ #Possessive',
    tag: 'Possessive',
    reason: 'org-possessive'
  }, //Los Angeles's fundraiser
  {
    match: '#Place+ #Possessive',
    tag: 'Possessive',
    reason: 'place-possessive'
  }, // assign all tasks
  {
    match: '#Verb (all|every|each|most|some|no) [#PresentTense]',
    group: 0,
    tag: 'Noun',
    reason: 'all-presentTense'
  }, //big dreams, critical thinking
  {
    match: '(#Adjective && !all) [#PresentTense]',
    group: 0,
    tag: 'Noun',
    reason: 'adj-presentTense'
  }, //his fine
  {
    match: '(his|her|its) [#Adjective]',
    group: 0,
    tag: 'Noun',
    reason: 'his-fine'
  }, //some pressing issues
  {
    match: 'some [#Verb] #Plural',
    group: 0,
    tag: 'Noun',
    reason: 'determiner6'
  }, //'more' is not always an adverb
  {
    match: 'more #Noun',
    tag: 'Noun',
    reason: 'more-noun'
  }, {
    match: '(#Noun && @hasComma) #Noun (and|or) [#PresentTense]',
    group: 0,
    tag: 'Noun',
    reason: 'noun-list'
  }, //3 feet
  {
    match: '(right|rights) of .',
    tag: 'Noun',
    reason: 'right-of'
  }, // a bit
  {
    match: 'a [bit]',
    group: 0,
    tag: 'Noun',
    reason: 'bit-2'
  }, //running-a-show
  {
    match: '#Gerund #Determiner [#Infinitive]',
    group: 0,
    tag: 'Noun',
    reason: 'running-a-show'
  }, //the-only-reason
  {
    match: '#Determiner #Adverb [#Infinitive]',
    group: 0,
    tag: 'Noun',
    reason: 'the-reason'
  }, //the nice swim
  {
    match: '(the|this|those|these) #Adjective [#Verb]',
    group: 0,
    tag: 'Noun',
    reason: 'the-adj-verb'
  }, // the truly nice swim
  {
    match: '(the|this|those|these) #Adverb #Adjective [#Verb]',
    group: 0,
    tag: 'Noun',
    reason: 'determiner4'
  }, //the orange is
  {
    match: '#Determiner [#Adjective] (#Copula|#PastTense|#Auxiliary)',
    group: 0,
    tag: 'Noun',
    reason: 'the-adj-2'
  }, // a stream runs
  {
    match: '(the|this|a|an) [#Infinitive] #Adverb? #Verb',
    group: 0,
    tag: 'Noun',
    reason: 'determiner5'
  }, //the test string
  {
    match: '#Determiner [#Infinitive] #Noun',
    group: 0,
    tag: 'Noun',
    reason: 'determiner7'
  }, //by a bear.
  {
    match: '#Determiner #Adjective [#Infinitive]$',
    group: 0,
    tag: 'Noun',
    reason: 'a-inf'
  }, //the wait to vote
  {
    match: '(the|this) [#Verb] #Preposition .',
    group: 0,
    tag: 'Noun',
    reason: 'determiner1'
  }, //a sense of
  {
    match: '#Determiner [#Verb] of',
    group: 0,
    tag: 'Noun',
    reason: 'the-verb-of'
  }, //the threat of force
  {
    match: '#Determiner #Noun of [#Verb]',
    group: 0,
    tag: 'Noun',
    reason: 'noun-of-noun'
  }, //the western line
  {
    match: '#Determiner [(western|eastern|northern|southern|central)] #Noun',
    group: 0,
    tag: 'Noun',
    reason: 'western-line'
  }, //her polling
  {
    match: '#Possessive [#Gerund]',
    group: 0,
    tag: 'Noun',
    reason: 'her-polling'
  }, //her fines
  {
    match: '(his|her|its) [#PresentTense]',
    group: 0,
    tag: 'Noun',
    reason: 'its-polling'
  }, //linear algebra
  {
    match: '(#Determiner|#Value) [(linear|binary|mobile|lexical|technical|computer|scientific|formal)] #Noun',
    group: 0,
    tag: 'Noun',
    reason: 'technical-noun'
  }, // walk the walk
  {
    match: '(the|those|these) #Adjective? [#Infinitive]',
    group: 0,
    tag: 'Noun',
    reason: 'det-inf'
  }, {
    match: '(the|those|these) #Adjective? [#PresentTense]',
    group: 0,
    tag: 'Noun',
    reason: 'det-pres'
  }, {
    match: '(the|those|these) #Adjective? [#PastTense]',
    group: 0,
    tag: 'Noun',
    reason: 'det-past'
  }, //air-flow
  {
    match: '(#Noun && @hasHyphen) #Verb',
    tag: 'Noun',
    reason: 'hyphen-verb'
  }, //is no walk
  {
    match: 'is no [#Verb]',
    group: 0,
    tag: 'Noun',
    reason: 'is-no-verb'
  }, //different views than
  {
    match: '[#Verb] than',
    group: 0,
    tag: 'Noun',
    reason: 'correction'
  }, // goes to sleep
  {
    match: '(go|goes|went) to [#Infinitive]',
    group: 0,
    tag: 'Noun',
    reason: 'goes-to-verb'
  }, //a great run
  {
    match: '(a|an) #Adjective [(#Infinitive|#PresentTense)]',
    tag: 'Noun',
    reason: 'a|an2'
  }, //a tv show
  {
    match: '(a|an) #Noun [#Infinitive]',
    group: 0,
    tag: 'Noun',
    reason: 'a-noun-inf'
  }, //do so
  {
    match: 'do [so]',
    group: 0,
    tag: 'Noun',
    reason: 'so-noun'
  }, //is mark hughes
  {
    match: '#Copula [#Infinitive] #Noun',
    group: 0,
    tag: 'Noun',
    reason: 'is-pres-noun'
  }, //
  // { match: '[#Infinitive] #Copula', group: 0, tag: 'Noun', reason: 'inf-copula' },
  //a close
  {
    match: '#Determiner #Adverb? [close]',
    group: 0,
    tag: 'Adjective',
    reason: 'a-close'
  }, // what the hell
  {
    match: '#Determiner [(shit|damn|hell)]',
    group: 0,
    tag: 'Noun',
    reason: 'swears-noun'
  }];

  var adjectives$1 = '(misty|rusty|dusty|rich|randy)';
  var list$2 = [// all fell apart
  {
    match: '[all] #Determiner? #Noun',
    group: 0,
    tag: 'Adjective',
    reason: 'all-noun'
  }, // very rusty
  {
    match: "#Adverb [".concat(adjectives$1, "]"),
    group: 0,
    tag: 'Adjective',
    reason: 'really-rich'
  }, // rusty smith
  {
    match: "".concat(adjectives$1, " #Person"),
    tag: 'Person',
    reason: 'randy-smith'
  }, // rusty a. smith
  {
    match: "".concat(adjectives$1, " #Acronym? #ProperNoun"),
    tag: 'Person',
    reason: 'rusty-smith'
  }, //sometimes not-adverbs
  {
    match: '#Copula [(just|alone)]$',
    group: 0,
    tag: 'Adjective',
    reason: 'not-adverb'
  }, //jack is guarded
  {
    match: '#Singular is #Adverb? [#PastTense$]',
    group: 0,
    tag: 'Adjective',
    reason: 'is-filled'
  }, // smoked poutine is
  {
    match: '[#PastTense] #Singular is',
    group: 0,
    tag: 'Adjective',
    reason: 'smoked-poutine'
  }, // baked onions are
  {
    match: '[#PastTense] #Plural are',
    group: 0,
    tag: 'Adjective',
    reason: 'baked-onions'
  }, //a staggering cost
  {
    match: '(a|an) [#Gerund]',
    group: 0,
    tag: 'Adjective',
    reason: 'a|an'
  }, // is f*ed up
  {
    match: '#Copula [fucked up?]',
    tag: 'Adjective',
    reason: 'swears-adjective'
  }, //jack seems guarded
  {
    match: '#Singular (seems|appears) #Adverb? [#PastTense$]',
    group: 0,
    tag: 'Adjective',
    reason: 'seems-filled'
  }];
  var _04Adjective = list$2;

  var _05Adverb = [//still good
  {
    match: '[still] #Adjective',
    group: 0,
    tag: 'Adverb',
    reason: 'still-advb'
  }, //still make
  {
    match: '[still] #Verb',
    group: 0,
    tag: 'Adverb',
    reason: 'still-verb'
  }, // so hot
  {
    match: '[so] #Adjective',
    group: 0,
    tag: 'Adverb',
    reason: 'so-adv'
  }, // all singing
  {
    match: '[all] #Verb',
    group: 0,
    tag: 'Adverb',
    reason: 'all-verb'
  }, // sing like an angel
  {
    match: '#Verb [like]',
    group: 0,
    tag: 'Adverb',
    reason: 'verb-like'
  }, //barely even walk
  {
    match: '(barely|hardly) even',
    tag: 'Adverb',
    reason: 'barely-even'
  }, //cheering hard - dropped -ly's
  {
    match: '#PresentTense [(hard|quick|long|bright|slow)]',
    group: 0,
    tag: 'Adverb',
    reason: 'lazy-ly'
  }, // much appreciated
  {
    match: '[much] #Adjective',
    group: 0,
    tag: 'Adverb',
    reason: 'bit-1'
  }];

  var _06Value = [// ==== PhoneNumber ====
  //1 800 ...
  {
    match: '1 #Value #PhoneNumber',
    tag: 'PhoneNumber',
    reason: '1-800-Value'
  }, //(454) 232-9873
  {
    match: '#NumericValue #PhoneNumber',
    tag: 'PhoneNumber',
    reason: '(800) PhoneNumber'
  }, // ==== Currency ====
  // chinese yuan
  {
    match: '#Demonym #Currency',
    tag: 'Currency',
    reason: 'demonym-currency'
  }, // ==== Ordinal ====
  {
    match: '[second] #Noun',
    group: 0,
    tag: 'Ordinal',
    reason: 'second-noun'
  }, // ==== Unit ====
  //5 yan
  {
    match: '#Value+ [#Currency]',
    group: 0,
    tag: 'Unit',
    reason: '5-yan'
  }, {
    match: '#Value [(foot|feet)]',
    group: 0,
    tag: 'Unit',
    reason: 'foot-unit'
  }, //minus 7
  {
    match: '(minus|negative) #Value',
    tag: 'Value',
    reason: 'minus-value'
  }, //5 kg.
  {
    match: '#Value [#Abbreviation]',
    group: 0,
    tag: 'Unit',
    reason: 'value-abbr'
  }, {
    match: '#Value [k]',
    group: 0,
    tag: 'Unit',
    reason: 'value-k'
  }, {
    match: '#Unit an hour',
    tag: 'Unit',
    reason: 'unit-an-hour'
  }, //seven point five
  {
    match: '#Value (point|decimal) #Value',
    tag: 'Value',
    reason: 'value-point-value'
  }, // ten bucks
  {
    match: '(#Value|a) [(buck|bucks|grand)]',
    group: 0,
    tag: 'Currency',
    reason: 'value-bucks'
  }, //quarter million
  {
    match: '#Determiner [(half|quarter)] #Ordinal',
    group: 0,
    tag: 'Value',
    reason: 'half-ordinal'
  }, {
    match: 'a #Value',
    tag: 'Value',
    reason: 'a-value'
  }, // ==== Money ====
  {
    match: '[#Value+] #Currency',
    group: 0,
    tag: 'Money',
    reason: '15 usd'
  }, // thousand and two
  {
    match: "(hundred|thousand|million|billion|trillion|quadrillion)+ and #Value",
    tag: 'Value',
    reason: 'magnitude-and-value'
  }, //'a/an' can mean 1 - "a hour"
  {
    match: '!once [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)',
    group: 0,
    tag: 'Value',
    reason: 'a-is-one'
  }];

  var verbs$1 = '(pat|wade|ollie|will|rob|buck|bob|mark|jack)';
  var list$3 = [// ==== Tense ====
  //he left
  {
    match: '#Noun #Adverb? [left]',
    group: 0,
    tag: 'PastTense',
    reason: 'left-verb'
  }, //this rocks
  {
    match: '(this|that) [#Plural]',
    group: 0,
    tag: 'PresentTense',
    reason: 'this-verbs'
  }, // ==== Auxiliary ====
  //was walking
  {
    match: "[#Copula (#Adverb|not)+?] (#Gerund|#PastTense)",
    group: 0,
    tag: 'Auxiliary',
    reason: 'copula-walking'
  }, //support a splattering of auxillaries before a verb
  {
    match: "[(has|had) (#Adverb|not)+?] #PastTense",
    group: 0,
    tag: 'Auxiliary',
    reason: 'had-walked'
  }, //would walk
  {
    match: "[#Adverb+? (#Modal|did)+ (#Adverb|not)+?] #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'modal-verb'
  }, //would have had
  {
    match: "[#Modal (#Adverb|not)+? have (#Adverb|not)+? had (#Adverb|not)+?] #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'would-have'
  }, //would be walking
  {
    match: "#Modal (#Adverb|not)+? be (#Adverb|not)+? #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'would-be'
  }, //had been walking
  {
    match: "(#Modal|had|has) (#Adverb|not)+? been (#Adverb|not)+? #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'had-been'
  }, //was walking
  {
    match: "[#Copula (#Adverb|not)+?] (#Gerund|#PastTense)",
    group: 0,
    tag: 'Auxiliary',
    reason: 'copula-walking'
  }, //support a splattering of auxillaries before a verb
  {
    match: "[(has|had) (#Adverb|not)+?] #PastTense",
    group: 0,
    tag: 'Auxiliary',
    reason: 'had-walked'
  }, // will walk
  {
    match: '[(do|does|will|have|had)] (not|#Adverb)? #Verb',
    group: 0,
    tag: 'Auxiliary',
    reason: 'have-had'
  }, // about to go
  {
    match: '[about to] #Adverb? #Verb',
    group: 0,
    tag: ['Auxiliary', 'Verb'],
    reason: 'about-to'
  }, //would be walking
  {
    match: "#Modal (#Adverb|not)+? be (#Adverb|not)+? #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'would-be'
  }, //would have had
  {
    match: "[#Modal (#Adverb|not)+? have (#Adverb|not)+? had (#Adverb|not)+?] #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'would-have'
  }, //had been walking
  {
    match: "(#Modal|had|has) (#Adverb|not)+? been (#Adverb|not)+? #Verb",
    group: 0,
    tag: 'Auxiliary',
    reason: 'had-been'
  }, // was being driven
  {
    match: '[(be|being|been)] #Participle',
    group: 0,
    tag: 'Auxiliary',
    reason: 'being-foo'
  }, // ==== Phrasal ====
  //'foo-up'
  {
    match: '(#Verb && @hasHyphen) up',
    group: 0,
    tag: 'PhrasalVerb',
    reason: 'foo-up'
  }, {
    match: '(#Verb && @hasHyphen) off',
    group: 0,
    tag: 'PhrasalVerb',
    reason: 'foo-off'
  }, {
    match: '(#Verb && @hasHyphen) over',
    group: 0,
    tag: 'PhrasalVerb',
    reason: 'foo-over'
  }, {
    match: '(#Verb && @hasHyphen) out',
    group: 0,
    tag: 'PhrasalVerb',
    reason: 'foo-out'
  }, //fall over
  {
    match: '#PhrasalVerb [#PhrasalVerb]',
    group: 0,
    tag: 'Particle',
    reason: 'phrasal-particle'
  }, // ==== Copula ====
  //will be running (not copula)
  {
    match: '[will #Adverb? not? #Adverb? be] #Gerund',
    group: 0,
    tag: 'Copula',
    reason: 'will-be-copula'
  }, //for more complex forms, just tag 'be'
  {
    match: 'will #Adverb? not? #Adverb? [be] #Adjective',
    group: 0,
    tag: 'Copula',
    reason: 'be-copula'
  }, // ==== Infinitive ====
  //march to
  {
    match: '[march] (up|down|back|to|toward)',
    group: 0,
    tag: 'Infinitive',
    reason: 'march-to'
  }, //must march
  {
    match: '#Modal [march]',
    group: 0,
    tag: 'Infinitive',
    reason: 'must-march'
  }, //let him glue
  {
    match: '(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)',
    group: 0,
    tag: 'Infinitive',
    reason: 'let-him-glue'
  }, //he quickly foo
  {
    match: '#Noun #Adverb [#Noun]',
    group: 0,
    tag: 'Verb',
    reason: 'quickly-foo'
  }, //will secure our
  {
    match: 'will [#Adjective]',
    group: 0,
    tag: 'Verb',
    reason: 'will-adj'
  }, //he disguised the thing
  {
    match: '#Pronoun [#Adjective] #Determiner #Adjective? #Noun',
    group: 0,
    tag: 'Verb',
    reason: 'he-adj-the'
  }, //is eager to go
  {
    match: '#Copula [#Adjective to] #Verb',
    group: 0,
    tag: 'Verb',
    reason: 'adj-to'
  }, // open the door
  {
    match: '[open] #Determiner',
    group: 0,
    tag: 'Infinitive',
    reason: 'open-the'
  }, // would wade
  {
    match: "#Modal [".concat(verbs$1, "]"),
    group: 0,
    tag: 'Verb',
    reason: 'would-mark'
  }, {
    match: "#Adverb [".concat(verbs$1, "]"),
    group: 0,
    tag: 'Verb',
    reason: 'really-mark'
  }, // wade smith
  {
    match: "".concat(verbs$1, " #Person"),
    tag: 'Person',
    reason: 'rob-smith'
  }, // wade m. Cooper
  {
    match: "".concat(verbs$1, " #Acronym? #ProperNoun"),
    tag: 'Person',
    reason: 'rob-a-smith'
  }, // damn them
  {
    match: '[shit] (#Determiner|#Possessive|them)',
    group: 0,
    tag: 'Verb',
    reason: 'swear1-verb'
  }, {
    match: '[damn] (#Determiner|#Possessive|them)',
    group: 0,
    tag: 'Verb',
    reason: 'swear2-verb'
  }, {
    match: '[fuck] (#Determiner|#Possessive|them)',
    group: 0,
    tag: 'Verb',
    reason: 'swear3-verb'
  }];
  var _07Verbs = list$3;

  var places = '(paris|alexandria|houston|kobe|salvador|sydney)';
  var list$4 = [// ==== Region ====
  //West Norforlk
  {
    match: '(west|north|south|east|western|northern|southern|eastern)+ #Place',
    tag: 'Region',
    reason: 'west-norfolk'
  }, //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
  {
    match: '#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|or|pa|sc|tn|tx|ut|vt|pr)]',
    group: 0,
    tag: 'Region',
    reason: 'us-state'
  }, //Foo District
  {
    match: '#ProperNoun+ (district|region|province|county|prefecture|municipality|territory|burough|reservation)',
    tag: 'Region',
    reason: 'foo-district'
  }, //District of Foo
  {
    match: '(district|region|province|municipality|territory|burough|state) of #ProperNoun',
    tag: 'Region',
    reason: 'district-of-Foo'
  }, // in Foo California
  {
    match: 'in [#ProperNoun] #Place',
    group: 0,
    tag: 'Place',
    reason: 'propernoun-place'
  }, // ==== Address ====
  {
    match: '#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)',
    tag: 'Address',
    reason: 'address-st'
  }, // in houston
  {
    match: "in [".concat(places, "]"),
    group: 0,
    tag: 'Place',
    reason: 'in-paris'
  }, {
    match: "near [".concat(places, "]"),
    group: 0,
    tag: 'Place',
    reason: 'near-paris'
  }, {
    match: "at [".concat(places, "]"),
    group: 0,
    tag: 'Place',
    reason: 'at-paris'
  }, {
    match: "from [".concat(places, "]"),
    group: 0,
    tag: 'Place',
    reason: 'from-paris'
  }, {
    match: "to [".concat(places, "]"),
    group: 0,
    tag: 'Place',
    reason: 'to-paris'
  }, {
    match: "#Place [".concat(places, "]"),
    group: 0,
    tag: 'Place',
    reason: 'tokyo-paris'
  }, // houston texas
  {
    match: "[".concat(places, "] #Place"),
    group: 0,
    tag: 'Place',
    reason: 'paris-france'
  }];
  var _08Place = list$4;

  var _09Org = [//John & Joe's
  {
    match: '#Noun (&|n) #Noun',
    tag: 'Organization',
    reason: 'Noun-&-Noun'
  }, // teachers union of Ontario
  {
    match: '#Organization of the? #ProperNoun',
    tag: 'Organization',
    reason: 'org-of-place',
    safe: true
  }, //walmart USA
  {
    match: '#Organization #Country',
    tag: 'Organization',
    reason: 'org-country'
  }, //organization
  {
    match: '#ProperNoun #Organization',
    tag: 'Organization',
    reason: 'titlecase-org'
  }, //FitBit Inc
  {
    match: '#ProperNoun (ltd|co|inc|dept|assn|bros)',
    tag: 'Organization',
    reason: 'org-abbrv'
  }, // the OCED
  {
    match: 'the [#Acronym]',
    group: 0,
    tag: 'Organization',
    reason: 'the-acronym',
    safe: true
  }, // global trade union
  {
    match: '(world|global|international|national|#Demonym) #Organization',
    tag: 'Organization',
    reason: 'global-org'
  }, // schools
  {
    match: '#Noun+ (public|private) school',
    tag: 'School',
    reason: 'noun-public-school'
  }];

  var nouns$1 = '(rose|robin|dawn|ray|holly|bill|joy|viola|penny|sky|violet|daisy|melody|kelvin|hope|mercedes|olive|jewel|faith|van|charity|miles|lily|summer|dolly|rod|dick|cliff|lane|reed|kitty|art|jean|trinity)';
  var months = '(january|april|may|june|jan|sep)'; //summer|autumn

  var list$5 = [// ==== Honorific ====
  {
    match: '[(1st|2nd|first|second)] #Honorific',
    group: 0,
    tag: 'Honorific',
    reason: 'ordinal-honorific'
  }, {
    match: '[(private|general|major|corporal|lord|lady|secretary|premier)] #Honorific? #Person',
    group: 0,
    tag: 'Honorific',
    reason: 'ambg-honorifics'
  }, // ==== FirstNames ====
  //is foo Smith
  {
    match: '#Copula [(#Noun|#PresentTense)] #LastName',
    group: 0,
    tag: 'FirstName',
    reason: 'copula-noun-lastname'
  }, //pope francis
  {
    match: '(lady|queen|sister) #ProperNoun',
    tag: 'FemaleName',
    reason: 'lady-titlecase',
    safe: true
  }, {
    match: '(king|pope|father) #ProperNoun',
    tag: 'MaleName',
    reason: 'pope-titlecase',
    safe: true
  }, //ambiguous-but-common firstnames
  {
    match: '[(will|may|april|june|said|rob|wade|ray|rusty|drew|miles|jack|chuck|randy|jan|pat|cliff|bill)] #LastName',
    group: 0,
    tag: 'FirstName',
    reason: 'maybe-lastname'
  }, // ==== Nickname ====
  // Dwayne 'the rock' Johnson
  {
    match: '#FirstName [#Determiner #Noun] #LastName',
    group: 0,
    tag: 'NickName',
    reason: 'first-noun-last'
  }, //my buddy
  {
    match: '#Possessive [#FirstName]',
    group: 0,
    tag: 'Person',
    reason: 'possessive-name'
  }, {
    match: '#Acronym #ProperNoun',
    tag: 'Person',
    reason: 'acronym-titlecase',
    safe: true
  }, //ludwig van beethovan
  {
    match: '#Person (jr|sr|md)',
    tag: 'Person',
    reason: 'person-honorific'
  }, //peter II
  {
    match: '#Person #Person the? #RomanNumeral',
    tag: 'Person',
    reason: 'roman-numeral'
  }, //'Professor Fink', 'General McCarthy'
  {
    match: '#FirstName [/^[^aiurck]$/]',
    group: 0,
    tag: ['Acronym', 'Person'],
    reason: 'john-e'
  }, //Doctor john smith jr
  //general pearson
  {
    match: '#Honorific #Person',
    tag: 'Person',
    reason: 'honorific-person'
  }, //remove single 'mr'
  {
    match: '#Honorific #Acronym',
    tag: 'Person',
    reason: 'Honorific-TitleCase'
  }, //j.k Rowling
  {
    match: '#Noun van der? #Noun',
    tag: 'Person',
    reason: 'von der noun',
    safe: true
  }, //king of spain
  {
    match: '(king|queen|prince|saint|lady) of? #Noun',
    tag: 'Person',
    reason: 'king-of-noun',
    safe: true
  }, //Foo U Ford
  {
    match: '[#ProperNoun] #Person',
    group: 0,
    tag: 'Person',
    reason: 'proper-person',
    safe: true
  }, // al sharpton
  {
    match: 'al (#Person|#ProperNoun)',
    tag: 'Person',
    reason: 'al-borlen',
    safe: true
  }, //ferdinand de almar
  {
    match: '#FirstName de #Noun',
    tag: 'Person',
    reason: 'bill-de-noun'
  }, //Osama bin Laden
  {
    match: '#FirstName (bin|al) #Noun',
    tag: 'Person',
    reason: 'bill-al-noun'
  }, //John L. Foo
  {
    match: '#FirstName #Acronym #ProperNoun',
    tag: 'Person',
    reason: 'bill-acronym-title'
  }, //Andrew Lloyd Webber
  {
    match: '#FirstName #FirstName #ProperNoun',
    tag: 'Person',
    reason: 'bill-firstname-title'
  }, //Mr Foo
  {
    match: '#Honorific #FirstName? #ProperNoun',
    tag: 'Person',
    reason: 'dr-john-Title'
  }, //peter the great
  {
    match: '#FirstName the #Adjective',
    tag: 'Person',
    reason: 'name-the-great'
  }, //very common-but-ambiguous lastnames
  {
    match: '#FirstName (green|white|brown|hall|young|king|hill|cook|gray|price)',
    tag: 'Person',
    reason: 'bill-green'
  }, // faith smith
  {
    match: "".concat(nouns$1, " #Person"),
    tag: 'Person',
    reason: 'ray-smith',
    safe: true
  }, // faith m. Smith
  {
    match: "".concat(nouns$1, " #Acronym? #ProperNoun"),
    tag: 'Person',
    reason: 'ray-a-smith',
    safe: true
  }, //give to april
  {
    match: "#Infinitive #Determiner? #Adjective? #Noun? (to|for) [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'ambig-person'
  }, // remind june
  {
    match: "#Infinitive [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'infinitive-person'
  }, // may waits for
  {
    match: "[".concat(months, "] #PresentTense for"),
    group: 0,
    tag: 'Person',
    reason: 'ambig-active-for'
  }, // may waits to
  {
    match: "[".concat(months, "] #PresentTense to"),
    group: 0,
    tag: 'Person',
    reason: 'ambig-active-to'
  }, // april will
  {
    match: "[".concat(months, "] #Modal"),
    group: 0,
    tag: 'Person',
    reason: 'ambig-modal'
  }, // would april
  {
    match: "#Modal [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'modal-ambig'
  }, // it is may
  {
    match: "#Copula [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'is-may'
  }, // may is
  {
    match: "[".concat(months, "] #Copula"),
    group: 0,
    tag: 'Person',
    reason: 'may-is'
  }, // with april
  {
    match: "that [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'that-month'
  }, // with april
  {
    match: "with [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'with-month'
  }, // for april
  {
    match: "for [".concat(months, "]"),
    group: 0,
    tag: 'Person',
    reason: 'for-month'
  }, // this april
  {
    match: "this [".concat(months, "]"),
    group: 0,
    tag: 'Month',
    reason: 'this-may'
  }, //maybe not 'this'
  // next april
  {
    match: "next [".concat(months, "]"),
    group: 0,
    tag: 'Month',
    reason: 'next-may'
  }, // last april
  {
    match: "last [".concat(months, "]"),
    group: 0,
    tag: 'Month',
    reason: 'last-may'
  }, // wednesday april
  {
    match: "#Date [".concat(months, "]"),
    group: 0,
    tag: 'Month',
    reason: 'date-may'
  }, // may 5th
  {
    match: "[".concat(months, "] the? #Value"),
    group: 0,
    tag: 'Month',
    reason: 'may-5th'
  }, // 5th of may
  {
    match: "#Value of [".concat(months, "]"),
    group: 0,
    tag: 'Month',
    reason: '5th-of-may'
  }, // dick van dyke
  {
    match: '#ProperNoun (van|al|bin) #ProperNoun',
    tag: 'Person',
    reason: 'title-van-title',
    safe: true
  }, //jose de Sucre
  {
    match: '#ProperNoun (de|du) la? #ProperNoun',
    tag: 'Person',
    reason: 'title-de-title',
    safe: true
  }, //Jani K. Smith
  {
    match: '#Singular #Acronym #LastName',
    tag: '#Person',
    reason: 'title-acro-noun',
    safe: true
  }, //John Foo
  {
    match: '#FirstName (#Noun && #ProperNoun) #ProperNoun?',
    tag: 'Person',
    reason: 'firstname-titlecase'
  }, //Joe K. Sombrero
  {
    match: '#FirstName #Acronym #Noun',
    tag: 'Person',
    reason: 'n-acro-noun',
    safe: true
  }];
  var _10People = list$5;

  var matches = [];
  matches = matches.concat(_01Misc);
  matches = matches.concat(_02Dates);
  matches = matches.concat(_03Noun);
  matches = matches.concat(_04Adjective);
  matches = matches.concat(_05Adverb);
  matches = matches.concat(_06Value);
  matches = matches.concat(_07Verbs);
  matches = matches.concat(_08Place);
  matches = matches.concat(_09Org);
  matches = matches.concat(_10People); // cache the easier conditions up-front

  var cacheRequired$1 = function cacheRequired(reg) {
    var needTags = [];
    var needWords = [];
    reg.forEach(function (obj) {
      if (obj.optional === true || obj.negative === true) {
        return;
      }

      if (obj.tag !== undefined) {
        needTags.push(obj.tag);
      }

      if (obj.word !== undefined) {
        needWords.push(obj.word);
      }
    });
    return {
      tags: _unique(needTags),
      words: _unique(needWords)
    };
  };

  var allLists = function allLists(m) {
    var more = [];
    var lists = m.reg.filter(function (r) {
      return r.oneOf !== undefined;
    });

    if (lists.length === 1) {
      var i = m.reg.findIndex(function (r) {
        return r.oneOf !== undefined;
      });
      Object.keys(m.reg[i].oneOf).forEach(function (w) {
        var newM = Object.assign({}, m);
        newM.reg = newM.reg.slice(0);
        newM.reg[i] = Object.assign({}, newM.reg[i]);
        newM.reg[i].word = w;
        delete newM.reg[i].operator;
        delete newM.reg[i].oneOf;
        newM.reason += '-' + w;
        more.push(newM);
      });
    }

    return more;
  }; // parse them


  var all = [];
  matches.forEach(function (m) {
    m.reg = syntax_1(m.match);
    var enumerated = allLists(m);

    if (enumerated.length > 0) {
      all = all.concat(enumerated);
    } else {
      all.push(m);
    }
  });
  all.forEach(function (m) {
    m.required = cacheRequired$1(m.reg);
    return m;
  });
  var matches_1 = all;

  var hasEvery = function hasEvery(chances) {
    if (chances.length === 0) {
      return [];
    }

    var obj = {};
    chances.forEach(function (arr) {
      arr = _unique(arr);

      for (var i = 0; i < arr.length; i++) {
        obj[arr[i]] = obj[arr[i]] || 0;
        obj[arr[i]] += 1;
      }
    });
    var res = Object.keys(obj);
    res = res.filter(function (k) {
      return obj[k] === chances.length;
    });
    res = res.map(function (num) {
      return Number(num);
    });
    return res;
  };

  var runner = function runner(doc) {
    //find phrases to try for each match
    matches_1.forEach(function (m) {
      var allChances = [];
      m.required.words.forEach(function (w) {
        allChances.push(doc._cache.words[w] || []);
      });
      m.required.tags.forEach(function (tag) {
        allChances.push(doc._cache.tags[tag] || []);
      });
      var worthIt = hasEvery(allChances);

      if (worthIt.length === 0) {
        return;
      }

      var phrases = worthIt.map(function (index) {
        return doc.list[index];
      });
      var tryDoc = doc.buildFrom(phrases); // phrases getting tagged

      var match = tryDoc.match(m.reg, m.group);

      if (match.found) {
        if (m.safe === true) {
          match.tagSafe(m.tag, m.reason);
        } else {
          match.tag(m.tag, m.reason);
        }
      }
    });
  };

  var runner_1 = runner; // console.log(hasEvery([[1, 2, 2, 3], [2, 3], []]))

  // misc: 40ms
  //sequence of match-tag statements to correct mis-tags

  var corrections = function corrections(doc) {
    runner_1(doc);
    fixMisc(doc);
    return doc;
  };

  var _04Correction = corrections;

  /** POS-tag all terms in this document */

  var tagger = function tagger(doc) {
    var terms = doc.termList(); // check against any known-words

    doc = _01Init(doc, terms); // everything has gotta be something. \_(:/)_/

    doc = _02Fallbacks(doc, terms); // support "didn't" & "spencer's"

    doc = _03Contractions(doc); //set our cache, to speed things up

    doc.cache(); // wiggle-around the results, so they make more sense

    doc = _04Correction(doc); // remove our cache, as it's invalidated now

    doc.uncache(); // run any user-given tagger functions

    doc.world.taggers.forEach(function (fn) {
      fn(doc);
    });
    return doc;
  };

  var _02Tagger = tagger;

  var addMethod = function addMethod(Doc) {
    /**  */
    var Abbreviations = /*#__PURE__*/function (_Doc) {
      _inherits(Abbreviations, _Doc);

      var _super = _createSuper(Abbreviations);

      function Abbreviations() {
        _classCallCheck(this, Abbreviations);

        return _super.apply(this, arguments);
      }

      _createClass(Abbreviations, [{
        key: "stripPeriods",
        value: function stripPeriods() {
          this.termList().forEach(function (t) {
            if (t.tags.Abbreviation === true && t.next) {
              t.post = t.post.replace(/^\./, '');
            }

            var str = t.text.replace(/\./, '');
            t.set(str);
          });
          return this;
        }
      }, {
        key: "addPeriods",
        value: function addPeriods() {
          this.termList().forEach(function (t) {
            t.post = t.post.replace(/^\./, '');
            t.post = '.' + t.post;
          });
          return this;
        }
      }]);

      return Abbreviations;
    }(Doc);

    Abbreviations.prototype.unwrap = Abbreviations.prototype.stripPeriods;

    Doc.prototype.abbreviations = function (n) {
      var match = this.match('#Abbreviation');

      if (typeof n === 'number') {
        match = match.get(n);
      }

      return new Abbreviations(match.list, this, this.world);
    };

    return Doc;
  };

  var Abbreviations = addMethod;

  var hasPeriod = /\./;

  var addMethod$1 = function addMethod(Doc) {
    /**  */
    var Acronyms = /*#__PURE__*/function (_Doc) {
      _inherits(Acronyms, _Doc);

      var _super = _createSuper(Acronyms);

      function Acronyms() {
        _classCallCheck(this, Acronyms);

        return _super.apply(this, arguments);
      }

      _createClass(Acronyms, [{
        key: "stripPeriods",
        value: function stripPeriods() {
          this.termList().forEach(function (t) {
            var str = t.text.replace(/\./g, '');
            t.set(str);
          });
          return this;
        }
      }, {
        key: "addPeriods",
        value: function addPeriods() {
          this.termList().forEach(function (t) {
            var str = t.text.replace(/\./g, '');
            str = str.split('').join('.'); // don't add a end-period if there's a sentence-end one

            if (hasPeriod.test(t.post) === false) {
              str += '.';
            }

            t.set(str);
          });
          return this;
        }
      }]);

      return Acronyms;
    }(Doc);

    Acronyms.prototype.unwrap = Acronyms.prototype.stripPeriods;
    Acronyms.prototype.strip = Acronyms.prototype.stripPeriods;

    Doc.prototype.acronyms = function (n) {
      var match = this.match('#Acronym');

      if (typeof n === 'number') {
        match = match.get(n);
      }

      return new Acronyms(match.list, this, this.world);
    };

    return Doc;
  };

  var Acronyms = addMethod$1;

  var addMethod$2 = function addMethod(Doc) {
    /** split into approximate sub-sentence phrases */
    Doc.prototype.clauses = function (n) {
      // an awkward way to disambiguate a comma use
      var commas = this["if"]('@hasComma').notIf('@hasComma @hasComma') //fun, cool...
      .notIf('@hasComma . .? (and|or) .') //cool, and fun
      .notIf('(#City && @hasComma) #Country') //'toronto, canada'
      .notIf('(#Date && @hasComma) #Year') //'july 6, 1992'
      .notIf('@hasComma (too|also)$') //at end of sentence
      .match('@hasComma');
      var found = this.splitAfter(commas);
      var quotes = found.quotations();
      found = found.splitOn(quotes);
      var parentheses = found.parentheses();
      found = found.splitOn(parentheses); // it is cool and it is ..

      var conjunctions = found["if"]('#Copula #Adjective #Conjunction (#Pronoun|#Determiner) #Verb').match('#Conjunction');
      found = found.splitBefore(conjunctions); // if it is this then that

      var condition = found["if"]('if .{2,9} then .').match('then');
      found = found.splitBefore(condition); // misc clause partitions

      found = found.splitBefore('as well as .');
      found = found.splitBefore('such as .');
      found = found.splitBefore('in addition to .'); // semicolons, dashes

      found = found.splitAfter('@hasSemicolon');
      found = found.splitAfter('@hasDash'); // passive voice verb - '.. which was robbed is empty'
      // let passive = found.match('#Noun (which|that) (was|is) #Adverb? #PastTense #Adverb?')
      // if (passive.found) {
      //   found = found.splitAfter(passive)
      // }
      // //which the boy robbed
      // passive = found.match('#Noun (which|that) the? #Noun+ #Adverb? #PastTense #Adverb?')
      // if (passive.found) {
      //   found = found.splitAfter(passive)
      // }
      // does there appear to have relative/subordinate clause still?

      var tooLong = found.filter(function (d) {
        return d.wordCount() > 5 && d.match('#Verb+').length >= 2;
      });

      if (tooLong.found) {
        var m = tooLong.splitAfter('#Noun .* #Verb .* #Noun+');
        found = found.splitOn(m.eq(0));
      }

      if (typeof n === 'number') {
        found = found.get(n);
      }

      return new Doc(found.list, this, this.world);
    };

    return Doc;
  };

  var Clauses = addMethod$2;

  var addMethod$3 = function addMethod(Doc) {
    /**  */
    var Contractions = /*#__PURE__*/function (_Doc) {
      _inherits(Contractions, _Doc);

      var _super = _createSuper(Contractions);

      function Contractions(list, from, world) {
        var _this;

        _classCallCheck(this, Contractions);

        _this = _super.call(this, list, from, world);
        _this.contracted = null;
        return _this;
      }
      /** turn didn't into 'did not' */


      _createClass(Contractions, [{
        key: "expand",
        value: function expand() {
          this.list.forEach(function (p) {
            var terms = p.terms(); //change the case?

            var isTitlecase = terms[0].isTitleCase();
            terms.forEach(function (t, i) {
              //use the implicit text
              t.set(t.implicit || t.text);
              t.implicit = undefined; //add whitespace

              if (i < terms.length - 1 && t.post === '') {
                t.post += ' ';
              }
            }); //set titlecase

            if (isTitlecase) {
              terms[0].toTitleCase();
            }
          });
          return this;
        }
      }]);

      return Contractions;
    }(Doc); //find contractable, expanded-contractions
    // const findExpanded = r => {
    //   let remain = r.not('#Contraction')
    //   let m = remain.match('(#Noun|#QuestionWord) (#Copula|did|do|have|had|could|would|will)')
    //   m.concat(remain.match('(they|we|you|i) have'))
    //   m.concat(remain.match('i am'))
    //   m.concat(remain.match('(#Copula|#Modal|do|does|have|has|can|will) not'))
    //   return m
    // }


    Doc.prototype.contractions = function (n) {
      //find currently-contracted
      var found = this.match('@hasContraction+'); //(may want to split these up)
      //todo: split consecutive contractions

      if (typeof n === 'number') {
        found = found.get(n);
      }

      return new Contractions(found.list, this, this.world);
    }; //aliases


    Doc.prototype.expanded = Doc.prototype.isExpanded;
    Doc.prototype.contracted = Doc.prototype.isContracted;
    return Doc;
  };

  var Contractions = addMethod$3;

  var addMethod$4 = function addMethod(Doc) {
    //pull it apart..
    var parse = function parse(doc) {
      var things = doc.splitAfter('@hasComma').splitOn('(and|or) not?').not('(and|or) not?');
      var beforeLast = doc.match('[.] (and|or)', 0);
      return {
        things: things,
        conjunction: doc.match('(and|or) not?'),
        beforeLast: beforeLast,
        hasOxford: beforeLast.has('@hasComma')
      };
    };
    /** cool, fun, and nice */


    var Lists = /*#__PURE__*/function (_Doc) {
      _inherits(Lists, _Doc);

      var _super = _createSuper(Lists);

      function Lists() {
        _classCallCheck(this, Lists);

        return _super.apply(this, arguments);
      }

      _createClass(Lists, [{
        key: "conjunctions",

        /** coordinating conjunction */
        value: function conjunctions() {
          return this.match('(and|or)');
        }
        /** split-up by list object */

      }, {
        key: "parts",
        value: function parts() {
          return this.splitAfter('@hasComma').splitOn('(and|or) not?');
        }
        /** remove the conjunction */

      }, {
        key: "items",
        value: function items() {
          return parse(this).things;
        }
        /** add a new unit to the list */

      }, {
        key: "add",
        value: function add(str) {
          this.forEach(function (p) {
            var beforeLast = parse(p).beforeLast;
            beforeLast.append(str); //add a comma to it

            beforeLast.termList(0).addPunctuation(',');
          });
          return this;
        }
        /** remove any matching unit from the list */

      }, {
        key: "remove",
        value: function remove(match) {
          return this.items()["if"](match).remove();
        }
        /** return only lists that use a serial comma */

      }, {
        key: "hasOxfordComma",
        value: function hasOxfordComma() {
          return this.filter(function (doc) {
            return parse(doc).hasOxford;
          });
        }
      }, {
        key: "addOxfordComma",
        value: function addOxfordComma() {
          var items = this.items();
          var needsComma = items.eq(items.length - 2);

          if (needsComma.found && needsComma.has('@hasComma') === false) {
            needsComma.post(', ');
          }

          return this;
        }
      }, {
        key: "removeOxfordComma",
        value: function removeOxfordComma() {
          var items = this.items();
          var needsComma = items.eq(items.length - 2);

          if (needsComma.found && needsComma.has('@hasComma') === true) {
            needsComma.post(' ');
          }

          return this;
        }
      }]);

      return Lists;
    }(Doc); // aliases


    Lists.prototype.things = Lists.prototype.items;

    Doc.prototype.lists = function (n) {
      var m = this["if"]('@hasComma+ .? (and|or) not? .'); // person-list

      var nounList = m.match('(#Noun|#Adjective|#Determiner|#Article)+ #Conjunction not? (#Article|#Determiner)? #Adjective? #Noun+')["if"]('#Noun');
      var adjList = m.match('(#Adjective|#Adverb)+ #Conjunction not? #Adverb? #Adjective+');
      var verbList = m.match('(#Verb|#Adverb)+ #Conjunction not? #Adverb? #Verb+');
      var result = nounList.concat(adjList);
      result = result.concat(verbList);
      result = result["if"]('@hasComma');

      if (typeof n === 'number') {
        result = m.get(n);
      }

      return new Lists(result.list, this, this.world);
    };

    return Doc;
  };

  var Lists = addMethod$4;

  var noPlural = '(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)'; //certain words can't be plural, like 'peace'

  var hasPlural = function hasPlural(doc) {
    if (doc.has('#Plural') === true) {
      return true;
    } // these can't be plural


    if (doc.has(noPlural) === true) {
      return false;
    }

    return true;
  };

  var hasPlural_1 = hasPlural;

  var irregulars$5 = {
    hour: 'an',
    heir: 'an',
    heirloom: 'an',
    honest: 'an',
    honour: 'an',
    honor: 'an',
    uber: 'an' //german u

  }; //pronounced letters of acronyms that get a 'an'

  var an_acronyms = {
    a: true,
    e: true,
    f: true,
    h: true,
    i: true,
    l: true,
    m: true,
    n: true,
    o: true,
    r: true,
    s: true,
    x: true
  }; //'a' regexes

  var a_regexs = [/^onc?e/i, //'wu' sound of 'o'
  /^u[bcfhjkqrstn][aeiou]/i, // 'yu' sound for hard 'u'
  /^eul/i];

  var makeArticle = function makeArticle(doc) {
    //no 'the john smith', but 'a london hotel'
    if (doc.has('#Person') || doc.has('#Place')) {
      return '';
    } //no a/an if it's plural


    if (doc.has('#Plural')) {
      return 'the';
    }

    var str = doc.text('normal').trim(); //explicit irregular forms

    if (irregulars$5.hasOwnProperty(str)) {
      return irregulars$5[str];
    } //spelled-out acronyms


    var firstLetter = str.substr(0, 1);

    if (doc.has('^@isAcronym') && an_acronyms.hasOwnProperty(firstLetter)) {
      return 'an';
    } //'a' regexes


    for (var i = 0; i < a_regexs.length; i++) {
      if (a_regexs[i].test(str)) {
        return 'a';
      }
    } //basic vowel-startings


    if (/^[aeiou]/i.test(str)) {
      return 'an';
    }

    return 'a';
  };

  var getArticle = makeArticle;

  //similar to plural/singularize rules, but not the same
  var isPlural$1 = [/(antenn|formul|nebul|vertebr|vit)ae$/i, /(octop|vir|radi|nucle|fung|cact|stimul)i$/i, /men$/i, /.tia$/i, /(m|l)ice$/i]; //similar to plural/singularize rules, but not the same

  var isSingular$1 = [/(ax|test)is$/i, /(octop|vir|radi|nucle|fung|cact|stimul)us$/i, /(octop|vir)i$/i, /(rl)f$/i, /(alias|status)$/i, /(bu)s$/i, /(al|ad|at|er|et|ed|ad)o$/i, /(ti)um$/i, /(ti)a$/i, /sis$/i, /(?:(^f)fe|(lr)f)$/i, /hive$/i, /(^aeiouy|qu)y$/i, /(x|ch|ss|sh|z)$/i, /(matr|vert|ind|cort)(ix|ex)$/i, /(m|l)ouse$/i, /(m|l)ice$/i, /(antenn|formul|nebul|vertebr|vit)a$/i, /.sis$/i, /^(?!talis|.*hu)(.*)man$/i];
  var _rules$2 = {
    isSingular: isSingular$1,
    isPlural: isPlural$1
  };

  var endS = /s$/; // double-check this term, if it is not plural, or singular.
  // (this is a partial copy of ./tagger/fallbacks/plural)
  // fallback plural if it ends in an 's'.

  var isPlural$2 = function isPlural(str) {
    // isSingular suffix rules
    if (_rules$2.isSingular.find(function (reg) {
      return reg.test(str);
    })) {
      return false;
    } // does it end in an s?


    if (endS.test(str) === true) {
      return true;
    } // is it a plural like 'fungi'?


    if (_rules$2.isPlural.find(function (reg) {
      return reg.test(str);
    })) {
      return true;
    }

    return null;
  };

  var isPlural_1$1 = isPlural$2;

  var exceptions = {
    he: 'his',
    she: 'hers',
    they: 'theirs',
    we: 'ours',
    i: 'mine',
    you: 'yours',
    her: 'hers',
    their: 'theirs',
    our: 'ours',
    my: 'mine',
    your: 'yours'
  }; // turn "David" to "David's"

  var toPossessive = function toPossessive(doc) {
    var str = doc.text('text').trim(); // exceptions

    if (exceptions.hasOwnProperty(str)) {
      doc.replaceWith(exceptions[str], true);
      doc.tag('Possessive', 'toPossessive');
      return;
    } // flanders'


    if (/s$/.test(str)) {
      str += "'";
      doc.replaceWith(str, true);
      doc.tag('Possessive', 'toPossessive');
      return;
    } //normal form:


    str += "'s";
    doc.replaceWith(str, true);
    doc.tag('Possessive', 'toPossessive');
    return;
  };

  var toPossessive_1 = toPossessive;

  // .nouns() supports some noun-phrase-ish groupings
  // pull these apart, if necessary
  var parse$1 = function parse(doc) {
    var res = {
      main: doc
    }; //support 'mayor of chicago' as one noun-phrase

    if (doc.has('#Noun (of|by|for) .')) {
      var m = doc.splitAfter('[#Noun+]', 0);
      res.main = m.eq(0);
      res.post = m.eq(1);
    }

    return res;
  };

  var parse_1 = parse$1;

  var methods$6 = {
    /** overload the original json with noun information */
    json: function json(options) {
      var n = null;

      if (typeof options === 'number') {
        n = options;
        options = null;
      }

      options = options || {
        text: true,
        normal: true,
        trim: true,
        terms: true
      };
      var res = [];
      this.forEach(function (doc) {
        var json = doc.json(options)[0];
        json.article = getArticle(doc);
        res.push(json);
      });

      if (n !== null) {
        return res[n];
      }

      return res;
    },

    /** get all adjectives describing this noun*/
    adjectives: function adjectives() {
      var list = this.lookAhead('^(that|who|which)? (was|is|will)? be? #Adverb? #Adjective+');
      list = list.concat(this.lookBehind('#Adjective+ #Adverb?$'));
      list = list.match('#Adjective');
      return list.sort('index');
    },
    isPlural: function isPlural() {
      return this["if"]('#Plural'); //assume tagger has run?
    },
    hasPlural: function hasPlural() {
      return this.filter(function (d) {
        return hasPlural_1(d);
      });
    },
    toPlural: function toPlural(agree) {
      var _this = this;

      var toPlural = this.world.transforms.toPlural;
      this.forEach(function (doc) {
        if (doc.has('#Plural') || hasPlural_1(doc) === false) {
          return;
        } // double-check it isn't an un-tagged plural


        var main = parse_1(doc).main;
        var str = main.text('reduced');

        if (!main.has('#Singular') && isPlural_1$1(str) === true) {
          return;
        }

        str = toPlural(str, _this.world);
        main.replace(str).tag('#Plural'); // 'an apple' -> 'apples'

        if (agree) {
          var an = main.lookBefore('(an|a) #Adjective?$').not('#Adjective');

          if (an.found === true) {
            an.remove();
          }
        }
      });
      return this;
    },
    toSingular: function toSingular(agree) {
      var _this2 = this;

      var toSingular = this.world.transforms.toSingular;
      this.forEach(function (doc) {
        if (doc.has('^#Singular+$') || hasPlural_1(doc) === false) {
          return;
        } // double-check it isn't an un-tagged plural


        var main = parse_1(doc).main;
        var str = main.text('reduced');

        if (!main.has('#Plural') && isPlural_1$1(str) !== true) {
          return;
        }

        str = toSingular(str, _this2.world);
        main.replace(str).tag('#Singular'); // add an article

        if (agree) {
          // 'apples' -> 'an apple'
          var start = doc;
          var adj = doc.lookBefore('#Adjective');

          if (adj.found) {
            start = adj;
          }

          var article = getArticle(start);
          start.insertBefore(article);
        }
      });
      return this;
    },
    toPossessive: function toPossessive() {
      this.forEach(function (d) {
        toPossessive_1(d);
      });
      return this;
    }
  };
  var methods_1 = methods$6;

  var addMethod$5 = function addMethod(Doc) {
    /**  */
    var Nouns = /*#__PURE__*/function (_Doc) {
      _inherits(Nouns, _Doc);

      var _super = _createSuper(Nouns);

      function Nouns() {
        _classCallCheck(this, Nouns);

        return _super.apply(this, arguments);
      }

      return Nouns;
    }(Doc); // add-in our methods


    Object.assign(Nouns.prototype, methods_1);

    Doc.prototype.nouns = function (n) {
      // don't split 'paris, france'
      var keep = this.match('(#City && @hasComma) (#Region|#Country)'); // but split the other commas

      var m = this.not(keep).splitAfter('@hasComma'); // combine them back together

      m = m.concat(keep);
      m = m.match('#Noun+ (of|by)? the? #Noun+?'); //nouns that we don't want in these results, for weird reasons

      m = m.not('#Pronoun');
      m = m.not('(there|these)');
      m = m.not('(#Month|#WeekDay)'); //allow Durations, Holidays
      // //allow possessives like "spencer's", but not generic ones like,

      m = m.not('(my|our|your|their|her|his)');
      m = m.not('(of|for|by|the)$');

      if (typeof n === 'number') {
        m = m.get(n);
      }

      return new Nouns(m.list, this, this.world);
    };

    return Doc;
  };

  var Nouns = addMethod$5;

  var open = /\(/;
  var close = /\)/;

  var addMethod$6 = function addMethod(Doc) {
    /** anything between (these things) */
    var Parentheses = /*#__PURE__*/function (_Doc) {
      _inherits(Parentheses, _Doc);

      var _super = _createSuper(Parentheses);

      function Parentheses() {
        _classCallCheck(this, Parentheses);

        return _super.apply(this, arguments);
      }

      _createClass(Parentheses, [{
        key: "unwrap",

        /** remove the parentheses characters */
        value: function unwrap() {
          this.list.forEach(function (p) {
            var first = p.terms(0);
            first.pre = first.pre.replace(open, '');
            var last = p.lastTerm();
            last.post = last.post.replace(close, '');
          });
          return this;
        }
      }]);

      return Parentheses;
    }(Doc);

    Doc.prototype.parentheses = function (n) {
      var list = [];
      this.list.forEach(function (p) {
        var terms = p.terms(); //look for opening brackets

        for (var i = 0; i < terms.length; i += 1) {
          var t = terms[i];

          if (open.test(t.pre)) {
            //look for the closing bracket..
            for (var o = i; o < terms.length; o += 1) {
              if (close.test(terms[o].post)) {
                var len = o - i + 1;
                list.push(p.buildFrom(t.id, len));
                i = o;
                break;
              }
            }
          }
        }
      }); //support nth result

      if (typeof n === 'number') {
        if (list[n]) {
          list = [list[n]];
        } else {
          list = [];
        }

        return new Parentheses(list, this, this.world);
      }

      return new Parentheses(list, this, this.world);
    };

    return Doc;
  };

  var Parentheses = addMethod$6;

  var addMethod$7 = function addMethod(Doc) {
    /**  */
    var Possessives = /*#__PURE__*/function (_Doc) {
      _inherits(Possessives, _Doc);

      var _super = _createSuper(Possessives);

      function Possessives(list, from, world) {
        var _this;

        _classCallCheck(this, Possessives);

        _this = _super.call(this, list, from, world);
        _this.contracted = null;
        return _this;
      }
      /** turn didn't into 'did not' */


      _createClass(Possessives, [{
        key: "strip",
        value: function strip() {
          this.list.forEach(function (p) {
            var terms = p.terms();
            terms.forEach(function (t) {
              var str = t.text.replace(/'s$/, '');
              t.set(str || t.text);
            });
          });
          return this;
        }
      }]);

      return Possessives;
    }(Doc); //find contractable, expanded-contractions
    // const findExpanded = r => {
    //   let remain = r.not('#Contraction')
    //   let m = remain.match('(#Noun|#QuestionWord) (#Copula|did|do|have|had|could|would|will)')
    //   m.concat(remain.match('(they|we|you|i) have'))
    //   m.concat(remain.match('i am'))
    //   m.concat(remain.match('(#Copula|#Modal|do|does|have|has|can|will) not'))
    //   return m
    // }


    Doc.prototype.possessives = function (n) {
      //find currently-contracted
      var found = this.match('#Noun+? #Possessive'); //todo: split consecutive contractions

      if (typeof n === 'number') {
        found = found.get(n);
      }

      return new Possessives(found.list, this, this.world);
    };

    return Doc;
  };

  var Possessives = addMethod$7;

  var pairs = {
    "\"": "\"",
    // 'StraightDoubleQuotes'
    "\uFF02": "\uFF02",
    // 'StraightDoubleQuotesWide'
    "'": "'",
    // 'StraightSingleQuotes'
    "\u201C": "\u201D",
    // 'CommaDoubleQuotes'
    "\u2018": "\u2019",
    // 'CommaSingleQuotes'
    "\u201F": "\u201D",
    // 'CurlyDoubleQuotesReversed'
    "\u201B": "\u2019",
    // 'CurlySingleQuotesReversed'
    "\u201E": "\u201D",
    // 'LowCurlyDoubleQuotes'
    "\u2E42": "\u201D",
    // 'LowCurlyDoubleQuotesReversed'
    "\u201A": "\u2019",
    // 'LowCurlySingleQuotes'
    "\xAB": "\xBB",
    // 'AngleDoubleQuotes'
    "\u2039": "\u203A",
    // 'AngleSingleQuotes'
    // Prime 'non quotation'
    "\u2035": "\u2032",
    // 'PrimeSingleQuotes'
    "\u2036": "\u2033",
    // 'PrimeDoubleQuotes'
    "\u2037": "\u2034",
    // 'PrimeTripleQuotes'
    // Prime 'quotation' variation
    "\u301D": "\u301E",
    // 'PrimeDoubleQuotes'
    "`": "\xB4",
    // 'PrimeSingleQuotes'
    "\u301F": "\u301E" // 'LowPrimeDoubleQuotesReversed'

  };
  var hasOpen = RegExp('(' + Object.keys(pairs).join('|') + ')');

  var addMethod$8 = function addMethod(Doc) {
    /** "these things" */
    var Quotations = /*#__PURE__*/function (_Doc) {
      _inherits(Quotations, _Doc);

      var _super = _createSuper(Quotations);

      function Quotations() {
        _classCallCheck(this, Quotations);

        return _super.apply(this, arguments);
      }

      _createClass(Quotations, [{
        key: "unwrap",

        /** remove the quote characters */
        value: function unwrap() {
          return this;
        }
      }]);

      return Quotations;
    }(Doc);

    Doc.prototype.quotations = function (n) {
      var list = [];
      this.list.forEach(function (p) {
        var terms = p.terms(); //look for opening quotes

        for (var i = 0; i < terms.length; i += 1) {
          var t = terms[i];

          if (hasOpen.test(t.pre)) {
            var _char = (t.pre.match(hasOpen) || [])[0];
            var want = pairs[_char]; // if (!want) {
            //   console.warn('missing quote char ' + char)
            // }
            //look for the closing bracket..

            for (var o = i; o < terms.length; o += 1) {
              if (terms[o].post.indexOf(want) !== -1) {
                var len = o - i + 1;
                list.push(p.buildFrom(t.id, len));
                i = o;
                break;
              }
            }
          }
        }
      }); //support nth result

      if (typeof n === 'number') {
        if (list[n]) {
          list = [list[n]];
        } else {
          list = [];
        }

        return new Quotations(list, this, this.world);
      }

      return new Quotations(list, this, this.world);
    }; // alias


    Doc.prototype.quotes = Doc.prototype.quotations;
    return Doc;
  };

  var Quotations = addMethod$8;

  // walked => walk  - turn a verb into it's root form
  var toInfinitive$1 = function toInfinitive(parsed, world) {
    var verb = parsed.verb; // console.log(parsed)
    // verb.debug()
    //1. if it's already infinitive

    var str = verb.text('normal');

    if (verb.has('#Infinitive')) {
      return str;
    } // 2. world transform does the heavy-lifting


    var tense = null;

    if (verb.has('#PastTense')) {
      tense = 'PastTense';
    } else if (verb.has('#Gerund')) {
      tense = 'Gerund';
    } else if (verb.has('#PresentTense')) {
      tense = 'PresentTense';
    } else if (verb.has('#Participle')) {
      tense = 'Participle';
    } else if (verb.has('#Actor')) {
      tense = 'Actor';
    }

    return world.transforms.toInfinitive(str, world, tense);
  };

  var toInfinitive_1$1 = toInfinitive$1;

  // spencer walks -> singular
  // we walk -> plural
  // the most-recent noun-phrase, before this verb.
  var findNoun = function findNoun(vb) {
    var noun = vb.lookBehind('#Noun+').last();
    return noun;
  }; //sometimes you can tell if a verb is plural/singular, just by the verb
  // i am / we were
  // othertimes you need its subject 'we walk' vs 'i walk'


  var isPlural$3 = function isPlural(parsed) {
    var vb = parsed.verb;

    if (vb.has('(are|were|does)') || parsed.auxiliary.has('(are|were|does)')) {
      return true;
    }

    if (vb.has('(is|am|do|was)') || parsed.auxiliary.has('(is|am|do|was)')) {
      return false;
    } //consider its prior noun


    var noun = findNoun(vb);

    if (noun.has('(we|they|you)')) {
      return true;
    }

    if (noun.has('#Plural')) {
      return true;
    }

    if (noun.has('#Singular')) {
      return false;
    }

    return null;
  };

  var isPlural_1$2 = isPlural$3;

  // #Copula : is           -> 'is not'
  // #PastTense : walked    -> did not walk
  // #PresentTense : walks  -> does not walk
  // #Gerund : walking:     -> not walking
  // #Infinitive : walk     -> do not walk

  var toNegative = function toNegative(parsed, world) {
    var vb = parsed.verb; // if it's already negative...

    if (parsed.negative.found) {
      return;
    } // would walk -> would not walk


    if (parsed.auxiliary.found) {
      parsed.auxiliary.eq(0).append('not'); // 'would not have'  'would not have'

      if (parsed.auxiliary.has('#Modal have not')) {
        parsed.auxiliary.replace('have not', 'not have');
      }

      return;
    } // is walking -> is not walking


    if (vb.has('(#Copula|will|has|had|do)')) {
      vb.append('not');
      return;
    } // walked -> did not walk


    if (vb.has('#PastTense')) {
      var inf = toInfinitive_1$1(parsed, world);
      vb.replaceWith(inf, true);
      vb.prepend('did not');
      return;
    } // walks -> does not walk


    if (vb.has('#PresentTense')) {
      var _inf = toInfinitive_1$1(parsed, world);

      vb.replaceWith(_inf, true);

      if (isPlural_1$2(parsed)) {
        vb.prepend('do not');
      } else {
        vb.prepend('does not');
      }

      return;
    } //walking -> not walking


    if (vb.has('#Gerund')) {
      var _inf2 = toInfinitive_1$1(parsed, world);

      vb.replaceWith(_inf2, true);
      vb.prepend('not');
      return;
    } //fallback 1:  walk -> does not walk


    if (isPlural_1$2(parsed)) {
      vb.prepend('does not');
      return;
    } //fallback 2:  walk -> do not walk


    vb.prepend('do not');
    return;
  };

  var toNegative_1 = toNegative;

  // turn 'would not really walk up' into parts
  var parseVerb = function parseVerb(vb) {
    var parsed = {
      adverb: vb.match('#Adverb+'),
      // 'really'
      negative: vb.match('#Negative'),
      // 'not'
      auxiliary: vb.match('#Auxiliary+').not('(#Negative|#Adverb)'),
      // 'will' of 'will go'
      particle: vb.match('#Particle'),
      // 'up' of 'pull up'
      verb: vb.match('#Verb+').not('(#Adverb|#Negative|#Auxiliary|#Particle)')
    }; // fallback, if no verb found

    if (!parsed.verb.found) {
      // blank-everything
      Object.keys(parsed).forEach(function (k) {
        parsed[k] = parsed[k].not('.');
      }); // it's all the verb

      parsed.verb = vb;
      return parsed;
    } //


    if (parsed.adverb && parsed.adverb.found) {
      var match = parsed.adverb.text('reduced') + '$';

      if (vb.has(match)) {
        parsed.adverbAfter = true;
      }
    }

    return parsed;
  };

  var parse$2 = parseVerb;

  /** too many special cases for is/was/will be*/

  var toBe = function toBe(parsed) {
    var isI = false;
    var plural = isPlural_1$2(parsed);
    var isNegative = parsed.negative.found; //account for 'i is' -> 'i am' irregular
    // if (vb.parent && vb.parent.has('i #Adverb? #Copula')) {
    //   isI = true;
    // }
    // 'i look', not 'i looks'

    if (parsed.verb.lookBehind('(i|we) (#Adverb|#Verb)?$').found) {
      isI = true;
    }

    var obj = {
      PastTense: 'was',
      PresentTense: 'is',
      FutureTense: 'will be',
      Infinitive: 'is',
      Gerund: 'being',
      Actor: '',
      PerfectTense: 'been',
      Pluperfect: 'been'
    }; //"i is" -> "i am"

    if (isI === true) {
      obj.PresentTense = 'am';
      obj.Infinitive = 'am';
    }

    if (plural) {
      obj.PastTense = 'were';
      obj.PresentTense = 'are';
      obj.Infinitive = 'are';
    }

    if (isNegative) {
      obj.PastTense += ' not';
      obj.PresentTense += ' not';
      obj.FutureTense = 'will not be';
      obj.Infinitive += ' not';
      obj.PerfectTense = 'not ' + obj.PerfectTense;
      obj.Pluperfect = 'not ' + obj.Pluperfect;
      obj.Gerund = 'not ' + obj.Gerund;
    }

    return obj;
  };

  var toBe_1 = toBe;

  // 'may/could/should' -> 'may/could/should have'
  var doModal = function doModal(parsed) {
    var str = parsed.verb.text();
    var res = {
      PastTense: str + ' have',
      PresentTense: str,
      FutureTense: str,
      Infinitive: str // Gerund: ,
      // Actor: '',
      // PerfectTense: '',
      // Pluperfect: '',

    };
    return res;
  };

  var doModal_1 = doModal;

  var conjugate$2 = function conjugate(parsed, world) {
    var verb = parsed.verb; //special handling of 'is', 'will be', etc.

    if (verb.has('#Copula') || verb.out('normal') === 'be' && parsed.auxiliary.has('will')) {
      return toBe_1(parsed);
    } // special handling of 'he could.'


    if (verb.has('#Modal')) {
      return doModal_1(parsed);
    }

    var hasHyphen = parsed.verb.termList(0).hasHyphen();
    var infinitive = toInfinitive_1$1(parsed, world);

    if (!infinitive) {
      return {};
    }

    var forms = world.transforms.conjugate(infinitive, world);
    forms.Infinitive = infinitive; // add particle to phrasal verbs ('fall over')

    if (parsed.particle.found) {
      var particle = parsed.particle.text();
      var space = hasHyphen === true ? '-' : ' ';
      Object.keys(forms).forEach(function (k) {
        return forms[k] += space + particle;
      });
    } //put the adverb at the end?
    // if (parsed.adverb.found) {
    // let adverb = parsed.adverb.text()
    // let space = hasHyphen === true ? '-' : ' '
    // if (parsed.adverbAfter === true) {
    //   Object.keys(forms).forEach(k => (forms[k] += space + adverb))
    // } else {
    //   Object.keys(forms).forEach(k => (forms[k] = adverb + space + forms[k]))
    // }
    // }
    //apply negative


    var isNegative = parsed.negative.found;

    if (isNegative) {
      forms.PastTense = 'did not ' + forms.Infinitive;
      forms.PresentTense = 'does not ' + forms.Infinitive;
      forms.Gerund = 'not ' + forms.Gerund;
    } //future Tense is pretty straightforward


    if (!forms.FutureTense) {
      if (isNegative) {
        forms.FutureTense = 'will not ' + forms.Infinitive;
      } else {
        forms.FutureTense = 'will ' + forms.Infinitive;
      }
    }

    if (isNegative) {
      forms.Infinitive = 'not ' + forms.Infinitive;
    }

    return forms;
  };

  var conjugate_1$1 = conjugate$2;

  // if something is 'modal-ish' we are forced to use past-participle
  // ('i could drove' is wrong)

  var useParticiple = function useParticiple(parsed) {
    if (parsed.auxiliary.has('(could|should|would|may|can|must)')) {
      return true;
    }

    if (parsed.auxiliary.has('am .+? being')) {
      return true;
    }

    if (parsed.auxiliary.has('had .+? been')) {
      return true;
    }

    return false;
  }; // conjugate 'drive'  'have driven'


  var toParticiple = function toParticiple(parsed, world) {
    //is it already a participle?
    if (parsed.auxiliary.has('(have|had)') && parsed.verb.has('#Participle')) {
      return;
    } // try to swap the main verb to its participle form


    var obj = conjugate_1$1(parsed, world);
    var str = obj.Participle || obj.PastTense;

    if (str) {
      parsed.verb.replaceWith(str, false);
    } // 'am being driven'  'have been driven'


    if (parsed.auxiliary.has('am .+? being')) {
      parsed.auxiliary.remove('am');
      parsed.auxiliary.replace('being', 'have been');
    } // add a 'have'


    if (!parsed.auxiliary.has('have')) {
      parsed.auxiliary.append('have');
    } // tag it as a participle


    parsed.verb.tag('Participle', 'toParticiple'); // turn 'i can swim' to -> 'i could swim'

    parsed.auxiliary.replace('can', 'could'); //'must be'  'must have been'

    parsed.auxiliary.replace('be have', 'have been'); //'not have'  'have not'

    parsed.auxiliary.replace('not have', 'have not'); // ensure all new words are tagged right

    parsed.auxiliary.tag('Auxiliary');
  };

  var participle = {
    useParticiple: useParticiple,
    toParticiple: toParticiple
  };

  var _toParticiple = participle.toParticiple,
      useParticiple$1 = participle.useParticiple; // remove any tense-information in auxiliary verbs

  var makeNeutral = function makeNeutral(parsed) {
    //remove tense-info from auxiliaries
    parsed.auxiliary.remove('(will|are|am|being)');
    parsed.auxiliary.remove('(did|does)');
    parsed.auxiliary.remove('(had|has|have)'); //our conjugation includes the 'not' and the phrasal-verb particle

    parsed.particle.remove();
    parsed.negative.remove();
    return parsed;
  };

  var methods$7 = {
    /** overload the original json with verb information */
    json: function json(options) {
      var _this = this;

      var n = null;

      if (typeof options === 'number') {
        n = options;
        options = null;
      }

      options = options || {
        text: true,
        normal: true,
        trim: true,
        terms: true
      };
      var res = [];
      this.forEach(function (p) {
        var json = p.json(options)[0];
        var parsed = parse$2(p);
        json.parts = {};
        Object.keys(parsed).forEach(function (k) {
          if (parsed[k] && parsed[k].isA === 'Doc') {
            json.parts[k] = parsed[k].text('normal');
          } else {
            json.parts[k] = parsed[k];
          }
        });
        json.isNegative = p.has('#Negative');
        json.conjugations = conjugate_1$1(parsed, _this.world);
        res.push(json);
      });

      if (n !== null) {
        return res[n];
      }

      return res;
    },

    /** grab the adverbs describing these verbs */
    adverbs: function adverbs() {
      var list = []; // look at internal adverbs

      this.forEach(function (vb) {
        var advb = parse$2(vb).adverb;

        if (advb.found) {
          list = list.concat(advb.list);
        }
      }); // look for leading adverbs

      var m = this.lookBehind('#Adverb+$');

      if (m.found) {
        list = m.list.concat(list);
      } // look for trailing adverbs


      m = this.lookAhead('^#Adverb+');

      if (m.found) {
        list = list.concat(m.list);
      }

      return this.buildFrom(list);
    },
    /// Verb Inflection

    /**return verbs like 'we walk' and not 'spencer walks' */
    isPlural: function isPlural() {
      var _this2 = this;

      var list = [];
      this.forEach(function (vb) {
        var parsed = parse$2(vb);

        if (isPlural_1$2(parsed, _this2.world) === true) {
          list.push(vb.list[0]);
        }
      });
      return this.buildFrom(list);
    },

    /** return verbs like 'spencer walks' and not 'we walk' */
    isSingular: function isSingular() {
      var _this3 = this;

      var list = [];
      this.forEach(function (vb) {
        var parsed = parse$2(vb);

        if (isPlural_1$2(parsed, _this3.world) === false) {
          list.push(vb.list[0]);
        }
      });
      return this.buildFrom(list);
    },
    /// Conjugation

    /** return all forms of this verb  */
    conjugate: function conjugate() {
      var _this4 = this;

      var result = [];
      this.forEach(function (vb) {
        var parsed = parse$2(vb);

        var forms = conjugate_1$1(parsed, _this4.world);

        result.push(forms);
      });
      return result;
    },

    /** walk  walked*/
    toPastTense: function toPastTense() {
      var _this5 = this;

      this.forEach(function (vb) {
        var parsed = parse$2(vb); // should we support 'would swim'  'would have swam'

        if (useParticiple$1(parsed)) {
          _toParticiple(parsed, _this5.world);

          return;
        }

        var str = conjugate_1$1(parsed, _this5.world).PastTense;

        if (str) {
          parsed = makeNeutral(parsed);
          parsed.verb.replaceWith(str, false); // vb.tag('PastTense')
        }
      });
      return this;
    },

    /** walk  walks */
    toPresentTense: function toPresentTense() {
      var _this6 = this;

      this.forEach(function (vb) {
        var parsed = parse$2(vb);

        var obj = conjugate_1$1(parsed, _this6.world);

        var str = obj.PresentTense; // 'i look', not 'i looks'

        if (vb.lookBehind('(i|we) (#Adverb|#Verb)?$').found) {
          str = obj.Infinitive;
        }

        if (str) {
          //awkward support for present-participle form
          // -- should we support 'have been swimming'  'am swimming'
          if (parsed.auxiliary.has('(have|had) been')) {
            parsed.auxiliary.replace('(have|had) been', 'am being');

            if (obj.Particle) {
              str = obj.Particle || obj.PastTense;
            }

            return;
          }

          parsed.verb.replaceWith(str, false);
          parsed.verb.tag('PresentTense');
          parsed = makeNeutral(parsed); // avoid 'he would walks'

          parsed.auxiliary.remove('#Modal');
        }
      });
      return this;
    },

    /** walk  will walk*/
    toFutureTense: function toFutureTense() {
      var _this7 = this;

      this.forEach(function (vb) {
        var parsed = parse$2(vb); // 'i should drive' is already future-enough

        if (useParticiple$1(parsed)) {
          return;
        }

        var str = conjugate_1$1(parsed, _this7.world).FutureTense;

        if (str) {
          parsed = makeNeutral(parsed); // avoid 'he would will go'

          parsed.auxiliary.remove('#Modal');
          parsed.verb.replaceWith(str, false);
          parsed.verb.tag('FutureTense');
        }
      });
      return this;
    },

    /** walks  walk */
    toInfinitive: function toInfinitive() {
      var _this8 = this;

      this.forEach(function (vb) {
        var parsed = parse$2(vb);

        var str = conjugate_1$1(parsed, _this8.world).Infinitive;

        if (str) {
          vb.replaceWith(str, false);
          vb.tag('Infinitive');
        }
      });
      return this;
    },

    /** walk  walking */
    toGerund: function toGerund() {
      var _this9 = this;

      this.forEach(function (vb) {
        var parsed = parse$2(vb);

        var str = conjugate_1$1(parsed, _this9.world).Gerund;

        if (str) {
          vb.replaceWith(str, false);
          vb.tag('Gerund');
        }
      });
      return this;
    },

    /** drive  driven - naked past-participle if it exists, otherwise past-tense */
    toParticiple: function toParticiple() {
      var _this10 = this;

      this.forEach(function (vb) {
        var parsed = parse$2(vb);
        var noAux = !parsed.auxiliary.found;

        _toParticiple(parsed, _this10.world); // dirty trick to  ensure our new auxiliary is found


        if (noAux) {
          parsed.verb.prepend(parsed.auxiliary.text());
          parsed.auxiliary.remove();
        }
      });
      return this;
    },
    /// Negation

    /** return only verbs with 'not'*/
    isNegative: function isNegative() {
      return this["if"]('#Negative');
    },

    /**  return only verbs without 'not'*/
    isPositive: function isPositive() {
      return this.ifNo('#Negative');
    },

    /** add a 'not' to these verbs */
    toNegative: function toNegative() {
      var _this11 = this;

      this.list.forEach(function (p) {
        var doc = _this11.buildFrom([p]);

        var parsed = parse$2(doc);

        toNegative_1(parsed, doc.world);
      });
      return this;
    },

    /** remove 'not' from these verbs */
    toPositive: function toPositive() {
      var m = this.match('do not #Verb');

      if (m.found) {
        m.remove('do not');
      }

      return this.remove('#Negative');
    }
  };

  var addMethod$9 = function addMethod(Doc) {
    /**  */
    var Verbs = /*#__PURE__*/function (_Doc) {
      _inherits(Verbs, _Doc);

      var _super = _createSuper(Verbs);

      function Verbs() {
        _classCallCheck(this, Verbs);

        return _super.apply(this, arguments);
      }

      return Verbs;
    }(Doc); // add-in our methods


    Object.assign(Verbs.prototype, methods$7); // aliases

    Verbs.prototype.negate = Verbs.prototype.toNegative;

    Doc.prototype.verbs = function (n) {
      var match = this.match('(#Adverb|#Auxiliary|#Verb|#Negative|#Particle)+'); // try to ignore leading and trailing adverbs

      match = match.not('^#Adverb+');
      match = match.not('#Adverb+$'); // handle commas:
      // don't split 'really, really'

      var keep = match.match('(#Adverb && @hasComma) #Adverb'); // // but split the other commas

      var m = match.not(keep).splitAfter('@hasComma'); // // combine them back together

      m = m.concat(keep);
      m.sort('index'); //handle slashes?
      //ensure there's actually a verb

      m = m["if"]('#Verb'); // the reason he will is ...

      if (m.has('(is|was)$')) {
        m = m.splitBefore('(is|was)$');
      } //grab (n)th result


      if (typeof n === 'number') {
        m = m.get(n);
      }

      var vb = new Verbs(m.list, this, this.world);
      return vb;
    };

    return Doc;
  };

  var Verbs = addMethod$9;

  var addMethod$a = function addMethod(Doc) {
    /**  */
    var People = /*#__PURE__*/function (_Doc) {
      _inherits(People, _Doc);

      var _super = _createSuper(People);

      function People() {
        _classCallCheck(this, People);

        return _super.apply(this, arguments);
      }

      return People;
    }(Doc);

    Doc.prototype.people = function (n) {
      var match = this.splitAfter('@hasComma');
      match = match.match('#Person+'); //grab (n)th result

      if (typeof n === 'number') {
        match = match.get(n);
      }

      return new People(match.list, this, this.world);
    };

    return Doc;
  };

  var People = addMethod$a;

  var subclass = [Abbreviations, Acronyms, Clauses, Contractions, Lists, Nouns, Parentheses, Possessives, Quotations, Verbs, People];

  var extend = function extend(Doc) {
    // add basic methods
    Object.keys(_simple).forEach(function (k) {
      return Doc.prototype[k] = _simple[k];
    }); // add subclassed methods

    subclass.forEach(function (addFn) {
      return addFn(Doc);
    });
    return Doc;
  };

  var Subset = extend;

  var methods$8 = {
    misc: methods$4,
    selections: _simple
  };
  /** a parsed text object */

  var Doc = /*#__PURE__*/function () {
    function Doc(list, from, world) {
      var _this = this;

      _classCallCheck(this, Doc);

      this.list = list; //quiet these properties in console.logs

      Object.defineProperty(this, 'from', {
        enumerable: false,
        value: from,
        writable: true
      }); //borrow some missing data from parent

      if (world === undefined && from !== undefined) {
        world = from.world;
      } //'world' getter


      Object.defineProperty(this, 'world', {
        enumerable: false,
        value: world,
        writable: true
      }); //fast-scans for our data

      Object.defineProperty(this, '_cache', {
        enumerable: false,
        writable: true,
        value: {}
      }); //'found' getter

      Object.defineProperty(this, 'found', {
        get: function get() {
          return _this.list.length > 0;
        }
      }); //'length' getter

      Object.defineProperty(this, 'length', {
        get: function get() {
          return _this.list.length;
        }
      }); // this is way easier than .constructor.name...

      Object.defineProperty(this, 'isA', {
        get: function get() {
          return 'Doc';
        }
      });
    }
    /** run part-of-speech tagger on all results*/


    _createClass(Doc, [{
      key: "tagger",
      value: function tagger() {
        return _02Tagger(this);
      }
      /** pool is stored on phrase objects */

    }, {
      key: "pool",
      value: function pool() {
        if (this.list.length > 0) {
          return this.list[0].pool;
        }

        return this.all().list[0].pool;
      }
    }]);

    return Doc;
  }();
  /** create a new Document object */


  Doc.prototype.buildFrom = function (list) {
    list = list.map(function (p) {
      return p.clone(true);
    }); // new this.constructor()

    var doc = new Doc(list, this, this.world);
    return doc;
  };
  /** create a new Document from plaintext. */


  Doc.prototype.fromText = function (str) {
    var list = _01Tokenizer(str, this.world, this.pool());
    return this.buildFrom(list);
  };

  Object.assign(Doc.prototype, methods$8.misc);
  Object.assign(Doc.prototype, methods$8.selections); //add sub-classes

  Subset(Doc); //aliases

  var aliases$1 = {
    untag: 'unTag',
    and: 'match',
    notIf: 'ifNo',
    only: 'if',
    onlyIf: 'if'
  };
  Object.keys(aliases$1).forEach(function (k) {
    return Doc.prototype[k] = Doc.prototype[aliases$1[k]];
  });
  var Doc_1 = Doc;

  var smallTagger = function smallTagger(doc) {
    var terms = doc.termList();
    _01Lexicon(terms, doc.world);
    return doc;
  };

  var tiny = smallTagger;

  function instance(worldInstance) {
    //blast-out our word-lists, just once
    var world = worldInstance;
    /** parse and tag text into a compromise object  */

    var nlp = function nlp() {
      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var lexicon = arguments.length > 1 ? arguments[1] : undefined;

      if (lexicon) {
        world.addWords(lexicon);
      }

      var list = _01Tokenizer(text, world);
      var doc = new Doc_1(list, null, world);
      doc.tagger();
      return doc;
    };
    
    nlp.similar = similar_text;
    /** parse text into a compromise object, without running POS-tagging */


    nlp.tokenize = function () {
      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var lexicon = arguments.length > 1 ? arguments[1] : undefined;
      var w = world;

      if (lexicon) {
        w = w.clone();
        w.words = {};
        w.addWords(lexicon);
      }

      var list = _01Tokenizer(text, w);
      var doc = new Doc_1(list, null, w);

      if (lexicon) {
        tiny(doc);
      }

      return doc;
    };
    /** mix in a compromise-plugin */


    nlp.extend = function (fn) {
      fn(Doc_1, world, this, Phrase_1, Term_1, Pool_1);
      return this;
    };
    /** create a compromise Doc object from .json() results */


    nlp.fromJSON = function (json) {
      var list = fromJSON_1(json, world);
      return new Doc_1(list, null, world);
    };
    /** make a deep-copy of the library state */


    nlp.clone = function () {
      return instance(world.clone());
    };
    /** log our decision-making for debugging */


    nlp.verbose = function () {
      var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      world.verbose(bool);
      return this;
    };
    /** grab currently-used World object */


    nlp.world = function () {
      return world;
    };
    /** pre-parse any match statements */


    nlp.parseMatch = function (str) {
      return syntax_1(str);
    };
    /** current version of the library */


    nlp.version = _version; // alias

    nlp["import"] = nlp.load;
    return nlp;
  }

  var src = instance(new World_1());

  return src;

})));
};
BundleModuleCode['plugins/nlp/compromise-adjectives']=function (module,exports,global,process){
/* compromise-adjectives 0.0.6 MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.compromiseAdjectives = factory());
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  //turn 'quick' into 'quickly'
  var not_matches = [/airs$/, /ll$/, /ee.$/, /ile$/, /y$/];
  var irregulars = {
    bad: 'badly',
    good: 'well',
    icy: 'icily',
    idle: 'idly',
    male: 'manly',
    "public": 'publicly',
    simple: 'simply',
    single: 'singly',
    special: 'especially',
    straight: 'straight',
    vague: 'vaguely',
    whole: 'wholly'
  };
  var dontChange = ['best', 'early', 'hard', 'fast', 'wrong', 'well', 'late', 'latter', 'little', 'long', 'low'].reduce(function (h, c) {
    h[c] = true;
    return h;
  }, {});
  var transforms = [{
    reg: /al$/i,
    repl: 'ally'
  }, {
    reg: /ly$/i,
    repl: 'ly'
  }, {
    reg: /(.{3})y$/i,
    repl: '$1ily'
  }, {
    reg: /que$/i,
    repl: 'quely'
  }, {
    reg: /ue$/i,
    repl: 'uly'
  }, {
    reg: /ic$/i,
    repl: 'ically'
  }, {
    reg: /ble$/i,
    repl: 'bly'
  }, {
    reg: /l$/i,
    repl: 'ly'
  }];

  var adj_to_adv = function adj_to_adv(str) {
    if (irregulars.hasOwnProperty(str) === true) {
      return irregulars[str];
    }

    if (dontChange.hasOwnProperty(str) === true) {
      return str;
    }

    for (var i = 0; i < not_matches.length; i++) {
      if (not_matches[i].test(str) === true) {
        return null;
      }
    }

    for (var _i = 0; _i < transforms.length; _i++) {
      if (transforms[_i].reg.test(str) === true) {
        return str.replace(transforms[_i].reg, transforms[_i].repl);
      }
    }

    return str + 'ly';
  };

  var toAdverb = adj_to_adv;

  //convert 'cute' to 'cuteness'
  var irregulars$1 = {
    clean: 'cleanliness',
    naivety: 'naivety',
    hurt: 'hurt'
  };
  var transforms$1 = [{
    reg: /y$/,
    repl: 'iness'
  }, {
    reg: /le$/,
    repl: 'ility'
  }, {
    reg: /ial$/,
    repl: 'y'
  }, {
    reg: /al$/,
    repl: 'ality'
  }, {
    reg: /ting$/,
    repl: 'ting'
  }, {
    reg: /ring$/,
    repl: 'ring'
  }, {
    reg: /bing$/,
    repl: 'bingness'
  }, {
    reg: /sing$/,
    repl: 'se'
  }, {
    reg: /ing$/,
    repl: 'ment'
  }, {
    reg: /ess$/,
    repl: 'essness'
  }, {
    reg: /ous$/,
    repl: 'ousness'
  }];

  var to_noun = function to_noun(w) {
    if (irregulars$1.hasOwnProperty(w)) {
      return irregulars$1[w];
    }

    var lastChar = w.charAt(w.length - 1);

    if (lastChar === 'w' || lastChar === 's') {
      return null;
    }

    for (var i = 0; i < transforms$1.length; i++) {
      if (transforms$1[i].reg.test(w) === true) {
        return w.replace(transforms$1[i].reg, transforms$1[i].repl);
      }
    }

    return w + 'ness';
  };

  var toNoun = to_noun;

  //turn an adjective like 'soft' into a verb like 'soften'
  //(don't do words like 'green' -> 'greenen')
  //these are suffices that are usually too weird
  var dontDo = ['c', 'e', 'g', 'l', 'n', 'r', 'w', 'y'].reduce(function (h, c) {
    h[c] = true;
    return h;
  }, {});
  var dontDoTwo = {
    ed: true,
    nt: true
  };
  var banList = {
    random: true,
    wild: true
  };
  var irregulars$2 = {
    bored: 'bore',
    red: 'redden',
    sad: 'sadden',
    fat: 'fatten',
    small: 'shrink',
    full: 'fill',
    tired: 'tire'
  };

  var toVerb = function toVerb(str) {
    if (irregulars$2.hasOwnProperty(str) === true) {
      return irregulars$2[str];
    } //don't bother with these:


    if (str.length <= 3) {
      return null;
    }

    if (banList.hasOwnProperty(str) === true) {
      return null;
    } //suffixes to avoid


    if (dontDo.hasOwnProperty(str[str.length - 1])) {
      return null;
    }

    var suffix = str.substr(str.length - 2);

    if (dontDoTwo.hasOwnProperty(suffix) === true) {
      return null;
    }

    if (/e$/.test(str) === true) {
      return str + 'n';
    }

    return str + 'en';
  };

  var toVerb_1 = toVerb;

  var addMethods = function addMethods(Doc) {
    /**  */
    var Adjective = /*#__PURE__*/function (_Doc) {
      _inherits(Adjective, _Doc);

      var _super = _createSuper(Adjective);

      function Adjective() {
        _classCallCheck(this, Adjective);

        return _super.apply(this, arguments);
      }

      _createClass(Adjective, [{
        key: "json",

        /** overload the original json with noun information */
        value: function json(options) {
          var n = null;

          if (typeof options === 'number') {
            n = options;
            options = null;
          }

          var res = [];
          this.forEach(function (doc) {
            var json = doc.json(options)[0];
            var str = doc.text('reduced');
            json.toAdverb = toAdverb(str);
            json.toNoun = toNoun(str);
            json.toVerb = toVerb_1(str);
            res.push(json);
          });

          if (n !== null) {
            return res[n];
          }

          return res;
        }
      }, {
        key: "conjugate",
        value: function conjugate(n) {
          var transform = this.world.transforms.adjectives;
          var arr = [];
          this.forEach(function (doc) {
            var str = doc.text('reduced');
            var obj = transform(str);
            obj.Adverb = toAdverb(str);
            obj.Noun = toNoun(str);
            obj.Verb = toVerb_1(str);
            arr.push(obj);
          }); //support nth result

          if (typeof n === 'number') {
            return arr[n];
          }

          return arr;
        }
      }, {
        key: "toSuperlative",
        value: function toSuperlative() {
          var transform = this.world.transforms.adjectives;
          this.forEach(function (doc) {
            var obj = transform(doc.text('reduced'));
            doc.replaceWith(obj.Superlative, true);
          });
          return this;
        }
      }, {
        key: "toComparative",
        value: function toComparative() {
          var transform = this.world.transforms.adjectives;
          this.forEach(function (doc) {
            var obj = transform(doc.text('reduced'));
            doc.replaceWith(obj.Comparative, true);
          });
          return this;
        }
      }, {
        key: "toAdverb",
        value: function toAdverb$1() {
          this.forEach(function (doc) {
            var adverb = toAdverb(doc.text('reduced'));

            doc.replaceWith(adverb, true);
          });
          return this;
        }
      }, {
        key: "toVerb",
        value: function toVerb() {
          this.forEach(function (doc) {
            var verb = toVerb_1(doc.text('reduced'));

            doc.replaceWith(verb, true);
          });
          return this;
        }
      }, {
        key: "toNoun",
        value: function toNoun$1() {
          this.forEach(function (doc) {
            var noun = toNoun(doc.text('reduced'));

            doc.replaceWith(noun, true);
          });
          return this;
        }
      }]);

      return Adjective;
    }(Doc);
    /** grab all the adjectives */


    Doc.prototype.adjectives = function (n) {
      var m = this.match('#Adjective'); //grab (n)th result

      if (typeof n === 'number') {
        m = m.get(n);
      }

      return new Adjective(m.list, this, this.world);
    };
  };

  var src = addMethods;

  return src;

})));
//# sourceMappingURL=compromise-adjectives.js.map
};
BundleModuleCode['plugins/nlp/compromise-dates']=function (module,exports,global,process){
/* compromise-dates 1.3.0 MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.compromiseDates = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  //ambiguous 'may' and 'march'
  var preps = '(in|by|before|during|on|until|after|of|within|all)'; //6

  var thisNext = '(last|next|this|previous|current|upcoming|coming)'; //2

  var sections = '(start|end|middle|starting|ending|midpoint|beginning)'; //2

  var seasons = '(spring|summer|winter|fall|autumn)'; //ensure a year is approximately typical for common years
  //please change in one thousand years

  var tagYear = function tagYear(m, reason) {
    if (m.found !== true) {
      return;
    }

    m.forEach(function (p) {
      var str = p.text('reduced');
      var num = parseInt(str, 10);

      if (num && num > 1000 && num < 3000) {
        p.tag('Year', reason);
      }
    });
  }; //same, but for less-confident values


  var tagYearSafe = function tagYearSafe(m, reason) {
    if (m.found !== true) {
      return;
    }

    m.forEach(function (p) {
      var str = p.text('reduced');
      var num = parseInt(str, 10);

      if (num && num > 1900 && num < 2030) {
        p.tag('Year', reason);
      }
    });
  };

  var tagDates = function tagDates(doc) {
    // in the evening
    doc.match('in the (night|evening|morning|afternoon|day|daytime)').tag('Time', 'in-the-night'); // 8 pm

    doc.match('(#Value|#Time) (am|pm)').tag('Time', 'value-ampm'); // 22-aug
    // doc.match('/^[0-9]{2}-(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov)/').tag('Date', '20-jan')
    // 2012-06

    doc.match('/^[0-9]{4}-[0-9]{2}$/').tag('Date', '2012-06'); // misc weekday words

    doc.match('(tue|thu)').tag('WeekDay', 'misc-weekday'); //months:

    var month = doc["if"]('#Month');

    if (month.found === true) {
      //June 5-7th
      month.match("#Month #Date+").tag('Date', 'correction-numberRange'); //5th of March

      month.match('#Value of #Month').tag('Date', 'value-of-month'); //5 March

      month.match('#Cardinal #Month').tag('Date', 'cardinal-month'); //march 5 to 7

      month.match('#Month #Value to #Value').tag('Date', 'value-to-value'); //march the 12th

      month.match('#Month the #Value').tag('Date', 'month-the-value');
    } //months:


    var val = doc["if"]('#Value');

    if (val.found === true) {
      //june 7
      val.match('(#WeekDay|#Month) #Value').ifNo('#Money').tag('Date', 'date-value'); //7 june

      val.match('#Value (#WeekDay|#Month)').ifNo('#Money').tag('Date', 'value-date'); //may twenty five

      val.match('#TextValue #TextValue')["if"]('#Date').tag('#Date', 'textvalue-date'); //two thursdays back

      val.match('#Value (#WeekDay|#Duration) back').tag('#Date', '3-back'); //eg 'year'

      var duration = val["if"]('#Duration');

      if (duration.found === true) {
        //for 4 months
        duration.match('for #Value #Duration').tag('Date', 'for-x-duration'); //two days before

        duration.match('#Value #Duration #Conjunction').tag('Date', 'val-duration-conjunction'); //for four days

        duration.match("".concat(preps, "? #Value #Duration")).tag('Date', 'value-duration'); //two years old

        duration.match('#Value #Duration old').unTag('Date', 'val-years-old');
      }
    } //seasons


    var season = doc["if"](seasons);

    if (season.found === true) {
      season.match("".concat(preps, "? ").concat(thisNext, " ").concat(seasons)).tag('Date', 'thisNext-season');
      season.match("the? ".concat(sections, " of ").concat(seasons)).tag('Date', 'section-season');
      season.match("".concat(seasons, " ").concat(preps, "? #Cardinal")).tag('Date', 'season-year');
    } //rest-dates


    var date = doc["if"]('#Date');

    if (date.found === true) {
      //june the 5th
      date.match('#Date the? #Ordinal').tag('Date', 'correction'); //last month

      date.match("".concat(thisNext, " #Date")).tag('Date', 'thisNext'); //by 5 March

      date.match('due? (by|before|after|until) #Date').tag('Date', 'by'); //next feb

      date.match('(last|next|this|previous|current|upcoming|coming|the) #Date').tag('Date', 'next-feb'); //start of june

      date.match("the? ".concat(sections, " of #Date")).tag('Date', 'section-of'); //fifth week in 1998

      date.match('#Ordinal #Duration in #Date').tag('Date', 'duration-in'); //early in june

      date.match('(early|late) (at|in)? the? #Date').tag('Time', 'early-evening'); //tomorrow before 3

      date.match('#Date (by|before|after|at|@|about) #Cardinal').not('^#Date').tag('Time', 'date-before-Cardinal'); //saturday am

      date.match('#Date [(am|pm)]', 0).unTag('Verb').unTag('Copula').tag('Time', 'date-am'); //feb to june

      date.match('#Date (#Preposition|to) #Date').ifNo('#Duration').tag('Date', 'date-prep-date'); //2nd quarter of 2019
      // date.match('#Date of #Date').tag('Date', 'date-of-date')
    } //year/cardinal tagging


    var cardinal = doc["if"]('#Cardinal');

    if (cardinal.found === true) {
      var v = cardinal.match("#Date #Value [#Cardinal]", 0);
      tagYear(v, 'date-value-year'); //scoops up a bunch

      v = cardinal.match("#Date [#Cardinal]", 0);
      tagYearSafe(v, 'date-year'); //middle of 1999

      v = cardinal.match("".concat(sections, " of [#Cardinal]"));
      tagYearSafe(v, 'section-year'); //feb 8 2018

      v = cardinal.match("#Month #Value [#Cardinal]", 0);
      tagYear(v, 'month-value-year'); //feb 8 to 10th 2018

      v = cardinal.match("#Month #Value to #Value [#Cardinal]", 0);
      tagYear(v, 'month-range-year'); //in 1998

      v = cardinal.match("(in|of|by|during|before|starting|ending|for|year|since) [#Cardinal]", 0);
      tagYear(v, 'in-year-1'); //q2 2009

      v = cardinal.match('(q1|q2|q3|q4) [#Cardinal]', 0);
      tagYear(v, 'in-year-2'); //2nd quarter 2009

      v = cardinal.match('#Ordinal quarter [#Cardinal]', 0);
      tagYear(v, 'in-year-3'); //in the year 1998

      v = cardinal.match('the year [#Cardinal]', 0);
      tagYear(v, 'in-year-4'); //it was 1998

      v = cardinal.match('it (is|was) [#Cardinal]', 0);
      tagYearSafe(v, 'in-year-5'); // re-tag this part

      cardinal.match("".concat(sections, " of #Year")).tag('Date');
    }

    var time = doc["if"]('#Time');

    if (time.found === true) {
      //by 6pm
      time.match('(by|before|after|at|@|about) #Time').tag('Time', 'preposition-time'); //7 7pm
      // time.match('#Cardinal #Time').not('#Year').tag('Time', 'value-time')
      //2pm est

      time.match('#Time [(eastern|pacific|central|mountain)]', 0).tag('Date', 'timezone'); //6pm est

      time.match('#Time [(est|pst|gmt)]', 0).tag('Date', 'timezone abbr');
    } //'2020' bare input


    var m = doc.match('^/^20[012][0-9]$/$');
    tagYearSafe(m, '2020-ish'); // in 20mins

    doc.match('(in|after) /^[0-9]+(min|sec|wk)s?/').tag('Date', 'shift-units');
    return doc;
  };

  var _00Basic = tagDates;

  var here = 'date-values'; //

  var values = function values(doc) {
    // a year ago
    if (!doc.has('once [a] #Duration')) {
      doc.match('[a] #Duration', 0).replaceWith('1').tag('Cardinal', here);
    }

    if (doc.has('#Value')) {
      //june 5 to 7th
      doc.match('#Month #Value to #Value of? #Year?').tag('Date', here); //5 to 7th june

      doc.match('#Value to #Value of? #Month #Year?').tag('Date', here); //third week of may

      doc.match('#Value #Duration of #Date').tag('Date', here); //two days after

      doc.match('#Value+ #Duration (after|before|into|later|afterwards|ago)?').tag('Date', here); //two days

      doc.match('#Value #Date').tag('Date', here); //june 5th

      doc.match('#Date #Value').tag('Date', here); //tuesday at 5

      doc.match('#Date #Preposition #Value').tag('Date', here); //tomorrow before 3

      doc.match('#Date (after|before|during|on|in) #Value').tag('Date', here); //a year and a half

      doc.match('#Value (year|month|week|day) and a half').tag('Date', here); //5 and a half years

      doc.match('#Value and a half (years|months|weeks|days)').tag('Date', here); //on the fifth

      doc.match('on the #Ordinal').tag('Date', here);
    }

    return doc;
  };

  var _01Values = values;

  var here$1 = 'date-tagger'; //

  var dateTagger = function dateTagger(doc) {
    doc.match('(spring|summer|winter|fall|autumn|springtime|wintertime|summertime)').match('#Noun').tag('Season', here$1);
    doc.match('(q1|q2|q3|q4)').tag('FinancialQuarter', here$1);
    doc.match('(this|next|last|current) quarter').tag('FinancialQuarter', here$1);
    doc.match('(this|next|last|current) season').tag('Season', here$1);

    if (doc.has('#Date')) {
      //friday to sunday
      doc.match('#Date #Preposition #Date').tag('Date', here$1); //once a day..

      doc.match('(once|twice) (a|an|each) #Date').tag('Date', here$1); //TODO:fixme

      doc.match('(by|until|on|in|at|during|over|every|each|due) the? #Date').tag('Date', here$1); //tuesday

      doc.match('#Date+').tag('Date', here$1); //by June

      doc.match('(by|until|on|in|at|during|over|every|each|due) the? #Date').tag('Date', here$1); //a year after..

      doc.match('a #Duration').tag('Date', here$1); //between x and y

      doc.match('(between|from) #Date').tag('Date', here$1);
      doc.match('(to|until|upto) #Date').tag('Date', here$1);
      doc.match('#Date and #Date').tag('Date', here$1); //during this june

      doc.match('(by|until|after|before|during|on|in|following|since) (next|this|last)? (#Date|#Date)').tag('Date', here$1); //day after next

      doc.match('the? #Date after next one?').tag('Date', here$1); //approximately...

      doc.match('(about|approx|approximately|around) #Date').tag('Date', here$1);
    }

    return doc;
  };

  var _02Dates = dateTagger;

  var here$2 = 'section-tagger'; //

  var sectionTagger = function sectionTagger(doc) {
    if (doc.has('#Date')) {
      // //next september
      doc.match('this? (last|next|past|this|previous|current|upcoming|coming|the) #Date').tag('Date', here$2); //starting this june

      doc.match('(starting|beginning|ending) #Date').tag('Date', here$2); //start of june

      doc.match('the? (start|end|middle|beginning) of (last|next|this|the) (#Date|#Date)').tag('Date', here$2); //this coming june

      doc.match('(the|this) #Date').tag('Date', here$2); //january up to june

      doc.match('#Date up to #Date').tag('Date', here$2);
    }

    return doc;
  };

  var _03Sections = sectionTagger;

  var here$3 = 'time-tagger'; //

  var timeTagger = function timeTagger(doc) {
    // 2 oclock
    doc.match('#Cardinal oclock').tag('Time', here$3); // 13h30

    doc.match('/^[0-9]{2}h[0-9]{2}$/').tag('Time', here$3); // 03/02

    doc.match('/^[0-9]{2}/[0-9]{2}/').tag('Date', here$3).unTag('Value'); // 3 in the morning

    doc.match('[#Value] (in|at) the? (morning|evening|night|nighttime)').tag('Time', here$3); // quarter to seven (not march 5 to 7)

    if (doc.has('#Cardinal') && !doc.has('#Month')) {
      doc.match('1? (half|quarter|25|15|10|5) (past|after|to) #Cardinal').tag('Time', here$3);
    } //timezone


    if (doc.has('#Date')) {
      // iso  (2020-03-02T00:00:00.000Z)
      doc.match('/^[0-9]{4}[:-][0-9]{2}[:-][0-9]{2}T[0-9]/').tag('Time', here$3); // tuesday at 4

      doc.match('#Date [at #Cardinal]', 0).notIf('#Year').tag('Time', here$3); // half an hour

      doc.match('half an (hour|minute|second)').tag('Date', here$3); //eastern daylight time

      doc.match('#Noun (standard|daylight|central|mountain)? time').tag('Timezone', here$3); //utc+5

      doc.match('/^utc[+-][0-9]/').tag('Timezone', here$3);
      doc.match('/^gmt[+-][0-9]/').tag('Timezone', here$3);
      doc.match('(in|for|by|near|at) #Timezone').tag('Timezone', here$3); // 2pm eastern

      doc.match('#Time [(eastern|mountain|pacific|central)]', 0).tag('Timezone', here$3);
    }

    return doc;
  };

  var _04Time = timeTagger;

  var here$4 = 'shift-tagger'; //

  var shiftTagger = function shiftTagger(doc) {
    if (doc.has('#Date')) {
      //'two days before'/ 'nine weeks frow now'
      doc.match('#Cardinal #Duration (before|after|ago|from|hence|back)').tag('DateShift', here$4); // in two weeks

      doc.match('in #Cardinal #Duration').tag('DateShift', here$4); // in a few weeks

      doc.match('in a (few|couple) of? #Duration').tag('DateShift', here$4); //two weeks and three days before

      doc.match('#Cardinal #Duration and? #DateShift').tag('DateShift', here$4);
      doc.match('#DateShift and #Cardinal #Duration').tag('DateShift', here$4); // 'day after tomorrow'

      doc.match('[#Duration (after|before)] #Date', 0).tag('DateShift', here$4); // in half an hour

      doc.match('in half (a|an) #Duration').tag('DateShift', here$4);
    }

    return doc;
  };

  var _05Shifts = shiftTagger;

  var here$5 = 'fix-tagger'; //

  var fixUp = function fixUp(doc) {
    //fixups
    if (doc.has('#Date')) {
      //first day by monday
      var oops = doc.match('#Date+ by #Date+');

      if (oops.found && !oops.has('^due')) {
        oops.match('^#Date+').unTag('Date', 'by-monday');
      }

      var d = doc.match('#Date+'); //'spa day'

      d.match('^day$').unTag('Date', 'spa-day'); // tomorrow's meeting

      d.match('(in|of|by|for)? (#Possessive && #Date)').unTag('Date', 'tomorrows meeting');
      var knownDate = '(yesterday|today|tomorrow)';

      if (d.has(knownDate)) {
        //yesterday 7
        d.match("".concat(knownDate, " [#Value]$")).unTag('Date', 'yesterday-7'); //7 yesterday

        d.match("^[#Value] ".concat(knownDate, "$"), 0).unTag('Date', '7 yesterday'); //friday yesterday

        d.match("#WeekDay+ ".concat(knownDate, "$")).unTag('Date').lastTerm().tag('Date', 'fri-yesterday'); // yesterday yesterday
        // d.match(`${knownDate}+ ${knownDate}$`)
        //   .unTag('Date')
        //   .lastTerm()
        //   .tag('Date', here)

        d.match("(this|last|next) #Date ".concat(knownDate, "$")).unTag('Date').lastTerm().tag('Date', 'this month yesterday');
      } //tomorrow on 5


      d.match("on #Cardinal$").unTag('Date', here$5); //this tomorrow

      d.match("this tomorrow").terms(0).unTag('Date', 'this-tomorrow'); //q2 2019

      d.match("(q1|q2|q3|q4) #Year").tag('Date', here$5); //5 tuesday
      // d.match(`^#Value #WeekDay`).terms(0).unTag('Date');
      //5 next week

      d.match("^#Value (this|next|last)").terms(0).unTag('Date', here$5);

      if (d.has('(last|this|next)')) {
        //this month 7
        d.match("(last|this|next) #Duration #Value").terms(2).unTag('Date', here$5); //7 this month

        d.match("!#Month #Value (last|this|next) #Date").terms(0).unTag('Date', here$5);
      } //january 5 5


      if (d.has('(#Year|#Time|#TextValue|#NumberRange)') === false) {
        d.match('(#Month|#WeekDay) #Value #Value').terms(2).unTag('Date', here$5);
      } //between june


      if (d.has('^between') && !d.has('and .')) {
        d.unTag('Date', here$5);
      } //june june


      if (d.has('#Month #Month') && !d.has('@hasHyphen') && !d.has('@hasComma')) {
        d.match('#Month').lastTerm().unTag('Date', 'month-month');
      } // log the hours


      if (d.has('(minutes|seconds|weeks|hours|days|months)') && !d.has('#Value #Duration')) {
        d.match('(minutes|seconds|weeks|hours|days|months)').unTag('Date', 'log-hours');
      } // about thanksgiving


      if (d.has('about #Holiday')) {
        d.match('about').unTag('#Date', 'about-thanksgiving');
      } // a month from now


      d.match('(from|by|before) now').unTag('Time'); // dangling date-chunks
      // if (d.has('!#Date (in|of|by|for) !#Date')) {
      //   d.unTag('Date', 'dangling-date')
      // }
      // the day after next

      d.match('#Date+').match('^the').unTag('Date');
    }

    return doc;
  };

  var _06Fixup = fixUp;

  var methods = [_00Basic, _01Values, _02Dates, _03Sections, _04Time, _05Shifts, _06Fixup]; // normalizations to run before tagger

  var normalize = function normalize(doc) {
    // turn '20mins' into '20 mins'
    doc.numbers().normalize(); // this is sorta problematic

    return doc;
  }; // run each of the taggers


  var tagDate = function tagDate(doc) {
    doc = normalize(doc); // run taggers

    methods.forEach(function (fn) {
      return fn(doc);
    });
    return doc;
  };

  var _01Tagger = tagDate;

  var _tags = {
    FinancialQuarter: {
      isA: 'Date'
    },
    // 'summer'
    Season: {
      isA: 'Date'
    },
    // '1982'
    Year: {
      isA: ['Date'],
      notA: 'RomanNumeral'
    },
    // 'months'
    Duration: {
      isA: ['Date', 'Noun']
    },
    // 'easter'
    Holiday: {
      isA: ['Date', 'Noun']
    },
    // 'PST'
    Timezone: {
      isA: ['Date', 'Noun'],
      notA: ['Adjective', 'DateShift']
    },
    // 'two weeks before'
    DateShift: {
      isA: ['Date'],
      notA: ['TimeZone', 'Holiday']
    }
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  /* spencermountain/spacetime 6.12.2 Apache 2.0 */
  var spacetime = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {

      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var MSEC_IN_HOUR = 60 * 60 * 1000; //convert our local date syntax a javascript UTC date

      var toUtc = function toUtc(dstChange, offset, year) {
        var _dstChange$split = dstChange.split('/'),
            _dstChange$split2 = _slicedToArray(_dstChange$split, 2),
            month = _dstChange$split2[0],
            rest = _dstChange$split2[1];

        var _rest$split = rest.split(':'),
            _rest$split2 = _slicedToArray(_rest$split, 2),
            day = _rest$split2[0],
            hour = _rest$split2[1];

        return Date.UTC(year, month - 1, day, hour) - offset * MSEC_IN_HOUR;
      }; // compare epoch with dst change events (in utc)


      var inSummerTime = function inSummerTime(epoch, start, end, summerOffset, winterOffset) {
        var year = new Date(epoch).getUTCFullYear();
        var startUtc = toUtc(start, winterOffset, year);
        var endUtc = toUtc(end, summerOffset, year); // console.log(epoch, endUtc)
        // simple number comparison now

        return epoch >= startUtc && epoch < endUtc;
      };

      var summerTime = inSummerTime; // it reproduces some things in ./index.js, but speeds up spacetime considerably

      var quickOffset = function quickOffset(s) {
        var zones = s.timezones;
        var obj = zones[s.tz];

        if (obj === undefined) {
          console.warn("Warning: couldn't find timezone " + s.tz);
          return 0;
        }

        if (obj.dst === undefined) {
          return obj.offset;
        } //get our two possible offsets


        var jul = obj.offset;
        var dec = obj.offset + 1; // assume it's the same for now

        if (obj.hem === 'n') {
          dec = jul - 1;
        }

        var split = obj.dst.split('->');
        var inSummer = summerTime(s.epoch, split[0], split[1], jul, dec);

        if (inSummer === true) {
          return jul;
        }

        return dec;
      };

      var quick = quickOffset;
      var _build = {
        "9|s": "2/dili,2/jayapura",
        "9|n": "2/chita,2/khandyga,2/pyongyang,2/seoul,2/tokyo,11/palau",
        "9.5|s|04/05:03->10/04:02": "4/adelaide,4/broken_hill,4/south,4/yancowinna",
        "9.5|s": "4/darwin,4/north",
        "8|s|03/08:01->10/04:00": "12/casey",
        "8|s": "2/kuala_lumpur,2/makassar,2/singapore,4/perth,4/west",
        "8|n|03/25:03->09/29:23": "2/ulan_bator",
        "8|n": "2/brunei,2/choibalsan,2/chongqing,2/chungking,2/harbin,2/hong_kong,2/irkutsk,2/kuching,2/macao,2/macau,2/manila,2/shanghai,2/taipei,2/ujung_pandang,2/ulaanbaatar",
        "8.75|s": "4/eucla",
        "7|s": "12/davis,2/jakarta,9/christmas",
        "7|n": "2/bangkok,2/barnaul,2/ho_chi_minh,2/hovd,2/krasnoyarsk,2/novokuznetsk,2/novosibirsk,2/phnom_penh,2/pontianak,2/saigon,2/tomsk,2/vientiane",
        "6|s": "12/vostok",
        "6|n": "2/almaty,2/bishkek,2/dacca,2/dhaka,2/kashgar,2/omsk,2/qyzylorda,2/qostanay,2/thimbu,2/thimphu,2/urumqi,9/chagos",
        "6.5|n": "2/rangoon,2/yangon,9/cocos",
        "5|s": "12/mawson,9/kerguelen",
        "5|n": "2/aqtau,2/aqtobe,2/ashgabat,2/ashkhabad,2/atyrau,2/baku,2/dushanbe,2/karachi,2/oral,2/samarkand,2/tashkent,2/yekaterinburg,9/maldives",
        "5.75|n": "2/kathmandu,2/katmandu",
        "5.5|n": "2/calcutta,2/colombo,2/kolkata",
        "4|s": "9/reunion",
        "4|n": "2/dubai,2/muscat,2/tbilisi,2/yerevan,8/astrakhan,8/samara,8/saratov,8/ulyanovsk,8/volgograd,2/volgograd,9/mahe,9/mauritius",
        "4.5|n|03/21:00->09/20:24": "2/tehran",
        "4.5|n": "2/kabul",
        "3|s": "12/syowa,9/antananarivo",
        "3|n|03/29:03->10/25:04": "2/famagusta,2/nicosia,8/athens,8/bucharest,8/helsinki,8/kiev,8/mariehamn,8/nicosia,8/riga,8/sofia,8/tallinn,8/uzhgorod,8/vilnius,8/zaporozhye",
        "3|n|03/29:02->10/25:03": "8/chisinau,8/tiraspol",
        "3|n|03/29:00->10/24:24": "2/beirut",
        "3|n|03/28:00->10/24:01": "2/gaza,2/hebron",
        "3|n|03/27:02->10/25:02": "2/jerusalem,2/tel_aviv",
        "3|n|03/27:00->10/30:01": "2/amman",
        "3|n|03/27:00->10/29:24": "2/damascus",
        "3|n": "0/addis_ababa,0/asmara,0/asmera,0/dar_es_salaam,0/djibouti,0/juba,0/kampala,0/mogadishu,0/nairobi,2/aden,2/baghdad,2/bahrain,2/istanbul,2/kuwait,2/qatar,2/riyadh,8/istanbul,8/kirov,8/minsk,8/moscow,8/simferopol,9/comoro,9/mayotte",
        "2|s|03/29:02->10/25:02": "12/troll",
        "2|s": "0/gaborone,0/harare,0/johannesburg,0/lubumbashi,0/lusaka,0/maputo,0/maseru,0/mbabane",
        "2|n|03/29:02->10/25:03": "0/ceuta,arctic/longyearbyen,3/jan_mayen,8/amsterdam,8/andorra,8/belgrade,8/berlin,8/bratislava,8/brussels,8/budapest,8/busingen,8/copenhagen,8/gibraltar,8/ljubljana,8/luxembourg,8/madrid,8/malta,8/monaco,8/oslo,8/paris,8/podgorica,8/prague,8/rome,8/san_marino,8/sarajevo,8/skopje,8/stockholm,8/tirane,8/vaduz,8/vatican,8/vienna,8/warsaw,8/zagreb,8/zurich",
        "2|n": "0/blantyre,0/bujumbura,0/cairo,0/khartoum,0/kigali,0/tripoli,8/kaliningrad",
        "1|s|04/02:01->09/03:03": "0/windhoek",
        "1|s": "0/kinshasa,0/luanda",
        "1|n|04/19:03->05/31:02": "0/casablanca,0/el_aaiun",
        "1|n|03/29:01->10/25:02": "3/canary,3/faeroe,3/faroe,3/madeira,8/belfast,8/dublin,8/guernsey,8/isle_of_man,8/jersey,8/lisbon,8/london",
        "1|n": "0/algiers,0/bangui,0/brazzaville,0/douala,0/lagos,0/libreville,0/malabo,0/ndjamena,0/niamey,0/porto-novo,0/tunis",
        "14|n": "11/kiritimati",
        "13|s|04/05:04->09/27:03": "11/apia",
        "13|s|01/15:02->11/05:03": "11/tongatapu",
        "13|n": "11/enderbury,11/fakaofo",
        "12|s|04/05:03->09/27:02": "12/mcmurdo,12/south_pole,11/auckland",
        "12|s|01/12:03->12/20:02": "11/fiji",
        "12|n": "2/anadyr,2/kamchatka,2/srednekolymsk,11/funafuti,11/kwajalein,11/majuro,11/nauru,11/tarawa,11/wake,11/wallis",
        "12.75|s|04/05:03->04/05:02": "11/chatham",
        "11|s|04/05:03->10/04:02": "12/macquarie",
        "11|s": "11/bougainville",
        "11|n": "2/magadan,2/sakhalin,11/efate,11/guadalcanal,11/kosrae,11/noumea,11/pohnpei,11/ponape",
        "11.5|n|04/05:03->10/04:02": "11/norfolk",
        "10|s|04/05:03->10/04:02": "4/act,4/canberra,4/currie,4/hobart,4/melbourne,4/nsw,4/sydney,4/tasmania,4/victoria",
        "10|s": "12/dumontdurville,4/brisbane,4/lindeman,4/queensland",
        "10|n": "2/ust-nera,2/vladivostok,2/yakutsk,11/chuuk,11/guam,11/port_moresby,11/saipan,11/truk,11/yap",
        "10.5|s|04/05:01->10/04:02": "4/lhi,4/lord_howe",
        "0|n|03/29:00->10/25:01": "1/scoresbysund,3/azores",
        "0|n": "0/abidjan,0/accra,0/bamako,0/banjul,0/bissau,0/conakry,0/dakar,0/freetown,0/lome,0/monrovia,0/nouakchott,0/ouagadougou,0/sao_tome,0/timbuktu,1/danmarkshavn,3/reykjavik,3/st_helena,13/gmt,13/gmt+0,13/gmt-0,13/gmt0,13/greenwich,13/utc,13/universal,13/zulu",
        "-9|n|03/08:02->11/01:02": "1/adak,1/atka",
        "-9|n": "11/gambier",
        "-9.5|n": "11/marquesas",
        "-8|n|03/08:02->11/01:02": "1/anchorage,1/juneau,1/metlakatla,1/nome,1/sitka,1/yakutat",
        "-8|n": "11/pitcairn",
        "-7|n|03/08:02->11/01:02": "1/ensenada,1/los_angeles,1/santa_isabel,1/tijuana,1/vancouver,6/pacific,10/bajanorte",
        "-7|n|03/08:02->11/01:01": "1/dawson,1/whitehorse,6/yukon",
        "-7|n": "1/creston,1/dawson_creek,1/fort_nelson,1/hermosillo,1/phoenix",
        "-6|s|04/04:22->09/05:22": "7/easterisland,11/easter",
        "-6|n|04/05:02->10/25:02": "1/chihuahua,1/mazatlan,10/bajasur",
        "-6|n|03/08:02->11/01:02": "1/boise,1/cambridge_bay,1/denver,1/edmonton,1/inuvik,1/ojinaga,1/shiprock,1/yellowknife,6/mountain",
        "-6|n": "1/belize,1/costa_rica,1/el_salvador,1/guatemala,1/managua,1/regina,1/swift_current,1/tegucigalpa,6/east-saskatchewan,6/saskatchewan,11/galapagos",
        "-5|s": "1/lima,1/rio_branco,5/acre",
        "-5|n|04/05:02->10/25:02": "1/bahia_banderas,1/merida,1/mexico_city,1/monterrey,10/general",
        "-5|n|03/12:03->11/05:01": "1/north_dakota",
        "-5|n|03/08:02->11/01:02": "1/chicago,1/knox_in,1/matamoros,1/menominee,1/rainy_river,1/rankin_inlet,1/resolute,1/winnipeg,6/central",
        "-5|n": "1/atikokan,1/bogota,1/cancun,1/cayman,1/coral_harbour,1/eirunepe,1/guayaquil,1/jamaica,1/panama,1/porto_acre",
        "-4|s|05/13:23->08/13:01": "12/palmer",
        "-4|s|04/04:24->09/06:00": "1/santiago,7/continental",
        "-4|s|03/21:24->10/04:00": "1/asuncion",
        "-4|s|02/16:24->11/03:00": "1/campo_grande,1/cuiaba",
        "-4|s": "1/la_paz,1/manaus,5/west",
        "-4|n|03/12:03->11/05:01": "1/indiana,1/kentucky",
        "-4|n|03/08:02->11/01:02": "1/detroit,1/fort_wayne,1/grand_turk,1/indianapolis,1/iqaluit,1/louisville,1/montreal,1/nassau,1/new_york,1/nipigon,1/pangnirtung,1/port-au-prince,1/thunder_bay,1/toronto,6/eastern",
        "-4|n|03/08:00->11/01:01": "1/havana",
        "-4|n": "1/anguilla,1/antigua,1/aruba,1/barbados,1/blanc-sablon,1/boa_vista,1/caracas,1/curacao,1/dominica,1/grenada,1/guadeloupe,1/guyana,1/kralendijk,1/lower_princes,1/marigot,1/martinique,1/montserrat,1/port_of_spain,1/porto_velho,1/puerto_rico,1/santo_domingo,1/st_barthelemy,1/st_kitts,1/st_lucia,1/st_thomas,1/st_vincent,1/tortola,1/virgin",
        "-3|s": "1/argentina,1/buenos_aires,1/cordoba,1/fortaleza,1/montevideo,1/punta_arenas,1/sao_paulo,12/rothera,3/stanley,5/east",
        "-3|n|03/28:22->10/24:23": "1/nuuk",
        "-3|n|03/08:02->11/01:02": "1/glace_bay,1/goose_bay,1/halifax,1/moncton,1/thule,3/bermuda,6/atlantic",
        "-3|n": "1/araguaina,1/bahia,1/belem,1/catamarca,1/cayenne,1/jujuy,1/maceio,1/mendoza,1/paramaribo,1/recife,1/rosario,1/santarem",
        "-2|s": "5/denoronha",
        "-2|n|03/28:22->10/24:23": "1/godthab",
        "-2|n|03/08:02->11/01:02": "1/miquelon",
        "-2|n": "1/noronha,3/south_georgia",
        "-2.5|n|03/08:02->11/01:02": "1/st_johns,6/newfoundland",
        "-1|n": "3/cape_verde",
        "-11|n": "11/midway,11/niue,11/pago_pago,11/samoa",
        "-10|n": "11/honolulu,11/johnston,11/rarotonga,11/tahiti"
      };

      var _build$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _build
      }); //prefixes for iana names..


      var _prefixes = ['africa', 'america', 'asia', 'atlantic', 'australia', 'brazil', 'canada', 'chile', 'europe', 'indian', 'mexico', 'pacific', 'antarctica', 'etc'];

      function createCommonjsModule(fn, module) {
        return module = {
          exports: {}
        }, fn(module, module.exports), module.exports;
      }

      function getCjsExportFromNamespace(n) {
        return n && n['default'] || n;
      }

      var data = getCjsExportFromNamespace(_build$1);
      var all = {};
      Object.keys(data).forEach(function (k) {
        var split = k.split('|');
        var obj = {
          offset: Number(split[0]),
          hem: split[1]
        };

        if (split[2]) {
          obj.dst = split[2];
        }

        var names = data[k].split(',');
        names.forEach(function (str) {
          str = str.replace(/(^[0-9]+)\//, function (before, num) {
            num = Number(num);
            return _prefixes[num] + '/';
          });
          all[str] = obj;
        });
      });
      all['utc'] = {
        offset: 0,
        hem: 'n' //default to northern hemisphere - (sorry!)

      }; //add etc/gmt+n

      for (var i = -14; i <= 14; i += 0.5) {
        var num = i;

        if (num > 0) {
          num = '+' + num;
        }

        var name = 'etc/gmt' + num;
        all[name] = {
          offset: i * -1,
          //they're negative!
          hem: 'n' //(sorry)

        };
        name = 'utc/gmt' + num; //this one too, why not.

        all[name] = {
          offset: i * -1,
          hem: 'n'
        };
      }

      var unpack = all; //find the implicit iana code for this machine.
      //safely query the Intl object
      //based on - https://bitbucket.org/pellepim/jstimezonedetect/src

      var fallbackTZ = 'utc'; //
      //this Intl object is not supported often, yet

      var safeIntl = function safeIntl() {
        if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {
          return null;
        }

        var format = Intl.DateTimeFormat();

        if (typeof format === 'undefined' || typeof format.resolvedOptions === 'undefined') {
          return null;
        }

        var timezone = format.resolvedOptions().timeZone;

        if (!timezone) {
          return null;
        }

        return timezone.toLowerCase();
      };

      var guessTz = function guessTz() {
        var timezone = safeIntl();

        if (timezone === null) {
          return fallbackTZ;
        }

        return timezone;
      }; //do it once per computer


      var guessTz_1 = guessTz;
      var isOffset = /(\-?[0-9]+)h(rs)?/i;
      var isNumber = /(\-?[0-9]+)/;
      var utcOffset = /utc([\-+]?[0-9]+)/i;
      var gmtOffset = /gmt([\-+]?[0-9]+)/i;

      var toIana = function toIana(num) {
        num = Number(num);

        if (num >= -13 && num <= 13) {
          num = num * -1; //it's opposite!

          num = (num > 0 ? '+' : '') + num; //add plus sign

          return 'etc/gmt' + num;
        }

        return null;
      };

      var parseOffset = function parseOffset(tz) {
        // '+5hrs'
        var m = tz.match(isOffset);

        if (m !== null) {
          return toIana(m[1]);
        } // 'utc+5'


        m = tz.match(utcOffset);

        if (m !== null) {
          return toIana(m[1]);
        } // 'GMT-5' (not opposite)


        m = tz.match(gmtOffset);

        if (m !== null) {
          var num = Number(m[1]) * -1;
          return toIana(num);
        } // '+5'


        m = tz.match(isNumber);

        if (m !== null) {
          return toIana(m[1]);
        }

        return null;
      };

      var parseOffset_1 = parseOffset;
      var local = guessTz_1(); //add all the city names by themselves

      var cities = Object.keys(unpack).reduce(function (h, k) {
        var city = k.split('/')[1] || '';
        city = city.replace(/_/g, ' ');
        h[city] = k;
        return h;
      }, {}); //try to match these against iana form

      var normalize = function normalize(tz) {
        tz = tz.replace(/ time/g, '');
        tz = tz.replace(/ (standard|daylight|summer)/g, '');
        tz = tz.replace(/\b(east|west|north|south)ern/g, '$1');
        tz = tz.replace(/\b(africa|america|australia)n/g, '$1');
        tz = tz.replace(/\beuropean/g, 'europe');
        tz = tz.replace(/\islands/g, 'island');
        return tz;
      }; // try our best to reconcile the timzone to this given string


      var lookupTz = function lookupTz(str, zones) {
        if (!str) {
          return local;
        }

        if (typeof str !== 'string') {
          console.error("Timezone must be a string - recieved: '", str, "'\n");
        }

        var tz = str.trim();
        var split = str.split('/'); //support long timezones like 'America/Argentina/Rio_Gallegos'

        if (split.length > 2 && zones.hasOwnProperty(tz) === false) {
          tz = split[0] + '/' + split[1];
        }

        tz = tz.toLowerCase();

        if (zones.hasOwnProperty(tz) === true) {
          return tz;
        } //lookup more loosely..


        tz = normalize(tz);

        if (zones.hasOwnProperty(tz) === true) {
          return tz;
        } //try city-names


        if (cities.hasOwnProperty(tz) === true) {
          return cities[tz];
        } // //try to parse '-5h'


        if (/[0-9]/.test(tz) === true) {
          var id = parseOffset_1(tz);

          if (id) {
            return id;
          }
        }

        throw new Error("Spacetime: Cannot find timezone named: '" + str + "'. Please enter an IANA timezone id.");
      };

      var find = lookupTz;
      var o = {
        millisecond: 1
      };
      o.second = 1000;
      o.minute = 60000;
      o.hour = 3.6e6; // dst is supported post-hoc

      o.day = 8.64e7; //

      o.date = o.day;
      o.month = 8.64e7 * 29.5; //(average)

      o.week = 6.048e8;
      o.year = 3.154e10; // leap-years are supported post-hoc
      //add plurals

      Object.keys(o).forEach(function (k) {
        o[k + 's'] = o[k];
      });
      var milliseconds = o;

      var walk = function walk(s, n, fn, unit, previous) {
        var current = s.d[fn]();

        if (current === n) {
          return; //already there
        }

        var startUnit = previous === null ? null : s.d[previous]();
        var original = s.epoch; //try to get it as close as we can

        var diff = n - current;
        s.epoch += milliseconds[unit] * diff; //DST edge-case: if we are going many days, be a little conservative
        // console.log(unit, diff)

        if (unit === 'day') {
          // s.epoch -= ms.minute
          //but don't push it over a month
          if (Math.abs(diff) > 28 && n < 28) {
            s.epoch += milliseconds.hour;
          }
        } // 1st time: oops, did we change previous unit? revert it.


        if (previous !== null && startUnit !== s.d[previous]()) {
          // console.warn('spacetime warning: missed setting ' + unit)
          s.epoch = original; // s.epoch += ms[unit] * diff * 0.89 // maybe try and make it close...?
        } //repair it if we've gone too far or something
        //(go by half-steps, just in case)


        var halfStep = milliseconds[unit] / 2;

        while (s.d[fn]() < n) {
          s.epoch += halfStep;
        }

        while (s.d[fn]() > n) {
          s.epoch -= halfStep;
        } // 2nd time: did we change previous unit? revert it.


        if (previous !== null && startUnit !== s.d[previous]()) {
          // console.warn('spacetime warning: missed setting ' + unit)
          s.epoch = original;
        }
      }; //find the desired date by a increment/check while loop


      var units = {
        year: {
          valid: function valid(n) {
            return n > -4000 && n < 4000;
          },
          walkTo: function walkTo(s, n) {
            return walk(s, n, 'getFullYear', 'year', null);
          }
        },
        month: {
          valid: function valid(n) {
            return n >= 0 && n <= 11;
          },
          walkTo: function walkTo(s, n) {
            var d = s.d;
            var current = d.getMonth();
            var original = s.epoch;
            var startUnit = d.getFullYear();

            if (current === n) {
              return;
            } //try to get it as close as we can..


            var diff = n - current;
            s.epoch += milliseconds.day * (diff * 28); //special case
            //oops, did we change the year? revert it.

            if (startUnit !== s.d.getFullYear()) {
              s.epoch = original;
            } //incriment by day


            while (s.d.getMonth() < n) {
              s.epoch += milliseconds.day;
            }

            while (s.d.getMonth() > n) {
              s.epoch -= milliseconds.day;
            }
          }
        },
        date: {
          valid: function valid(n) {
            return n > 0 && n <= 31;
          },
          walkTo: function walkTo(s, n) {
            return walk(s, n, 'getDate', 'day', 'getMonth');
          }
        },
        hour: {
          valid: function valid(n) {
            return n >= 0 && n < 24;
          },
          walkTo: function walkTo(s, n) {
            return walk(s, n, 'getHours', 'hour', 'getDate');
          }
        },
        minute: {
          valid: function valid(n) {
            return n >= 0 && n < 60;
          },
          walkTo: function walkTo(s, n) {
            return walk(s, n, 'getMinutes', 'minute', 'getHours');
          }
        },
        second: {
          valid: function valid(n) {
            return n >= 0 && n < 60;
          },
          walkTo: function walkTo(s, n) {
            //do this one directly
            s.epoch = s.seconds(n).epoch;
          }
        },
        millisecond: {
          valid: function valid(n) {
            return n >= 0 && n < 1000;
          },
          walkTo: function walkTo(s, n) {
            //do this one directly
            s.epoch = s.milliseconds(n).epoch;
          }
        }
      };

      var walkTo = function walkTo(s, wants) {
        var keys = Object.keys(units);
        var old = s.clone();

        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var n = wants[k];

          if (n === undefined) {
            n = old[k]();
          }

          if (typeof n === 'string') {
            n = parseInt(n, 10);
          } //make-sure it's valid


          if (!units[k].valid(n)) {
            s.epoch = null;

            if (s.silent === false) {
              console.warn('invalid ' + k + ': ' + n);
            }

            return;
          }

          units[k].walkTo(s, n);
        }

        return;
      };

      var walk_1 = walkTo;
      var shortMonths = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sept', 'oct', 'nov', 'dec'];
      var longMonths = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];

      function buildMapping() {
        var obj = {
          sep: 8 //support this format

        };

        for (var i = 0; i < shortMonths.length; i++) {
          obj[shortMonths[i]] = i;
        }

        for (var _i = 0; _i < longMonths.length; _i++) {
          obj[longMonths[_i]] = _i;
        }

        return obj;
      }

      var months = {
        "short": function _short() {
          return shortMonths;
        },
        "long": function _long() {
          return longMonths;
        },
        mapping: function mapping() {
          return buildMapping();
        },
        set: function set(i18n) {
          shortMonths = i18n["short"] || shortMonths;
          longMonths = i18n["long"] || longMonths;
        }
      }; //pull-apart ISO offsets, like "+0100"

      var parseOffset$1 = function parseOffset(s, offset) {
        if (!offset) {
          return s;
        } //this is a fancy-move


        if (offset === 'Z' || offset === 'z') {
          offset = '+0000';
        } // according to ISO8601, tz could be hh:mm, hhmm or hh
        // so need few more steps before the calculation.


        var num = 0; // for (+-)hh:mm

        if (/^[\+-]?[0-9]{2}:[0-9]{2}$/.test(offset)) {
          //support "+01:00"
          if (/:00/.test(offset) === true) {
            offset = offset.replace(/:00/, '');
          } //support "+01:30"


          if (/:30/.test(offset) === true) {
            offset = offset.replace(/:30/, '.5');
          }
        } // for (+-)hhmm


        if (/^[\+-]?[0-9]{4}$/.test(offset)) {
          offset = offset.replace(/30$/, '.5');
        }

        num = parseFloat(offset); //divide by 100 or 10 - , "+0100", "+01"

        if (Math.abs(num) > 100) {
          num = num / 100;
        } //okay, try to match it to a utc timezone
        //remember - this is opposite! a -5 offset maps to Etc/GMT+5  \_(:/)_/
        //https://askubuntu.com/questions/519550/why-is-the-8-timezone-called-gmt-8-in-the-filesystem


        num *= -1;

        if (num >= 0) {
          num = '+' + num;
        }

        var tz = 'etc/gmt' + num;
        var zones = s.timezones;

        if (zones[tz]) {
          // log a warning if we're over-writing a given timezone?
          // console.log('changing timezone to: ' + tz)
          s.tz = tz;
        }

        return s;
      };

      var parseOffset_1$1 = parseOffset$1;

      var parseTime = function parseTime(s) {
        var str = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        str = str.replace(/^\s+/, '').toLowerCase(); //trim
        //formal time formats - 04:30.23

        var arr = str.match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:\.]?([0-9]{1,4})?/);

        if (arr !== null) {
          //validate it a little
          var h = Number(arr[1]);

          if (h < 0 || h > 24) {
            return s.startOf('day');
          }

          var m = Number(arr[2]); //don't accept '5:3pm'

          if (arr[2].length < 2 || m < 0 || m > 59) {
            return s.startOf('day');
          }

          if (arr[4] > 999) {
            // fix overflow issue with milliseconds, if input is longer than standard (e.g. 2017-08-06T09:00:00.123456Z)
            arr[4] = parseInt("".concat(arr[4]).substring(0, 3), 10);
          }

          s = s.hour(h);
          s = s.minute(m);
          s = s.seconds(arr[3] || 0);
          s = s.millisecond(arr[4] || 0); //parse-out am/pm

          var ampm = str.match(/[\b0-9](am|pm)\b/);

          if (ampm !== null && ampm[1]) {
            s = s.ampm(ampm[1]);
          }

          return s;
        } //try an informal form - 5pm (no minutes)


        arr = str.match(/([0-9]+) ?(am|pm)/);

        if (arr !== null && arr[1]) {
          var _h = Number(arr[1]); //validate it a little..


          if (_h > 12 || _h < 1) {
            return s.startOf('day');
          }

          s = s.hour(arr[1] || 0);
          s = s.ampm(arr[2]);
          s = s.startOf('hour');
          return s;
        } //no time info found, use start-of-day


        s = s.startOf('day');
        return s;
      };

      var parseTime_1 = parseTime;
      var monthLengths = [31, // January - 31 days
      28, // February - 28 days in a common year and 29 days in leap years
      31, // March - 31 days
      30, // April - 30 days
      31, // May - 31 days
      30, // June - 30 days
      31, // July - 31 days
      31, // August - 31 days
      30, // September - 30 days
      31, // October - 31 days
      30, // November - 30 days
      31 // December - 31 days
      ];
      var monthLengths_1 = monthLengths; // 28 - feb

      var fns = createCommonjsModule(function (module, exports) {
        //git:blame @JuliasCaesar https://www.timeanddate.com/date/leapyear.html
        exports.isLeapYear = function (year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }; // unsurprisingly-nasty `typeof date` call


        exports.isDate = function (d) {
          return Object.prototype.toString.call(d) === '[object Date]' && !isNaN(d.valueOf());
        };

        exports.isArray = function (input) {
          return Object.prototype.toString.call(input) === '[object Array]';
        };

        exports.isObject = function (input) {
          return Object.prototype.toString.call(input) === '[object Object]';
        };

        exports.isBoolean = function (input) {
          return Object.prototype.toString.call(input) === '[object Boolean]';
        };

        exports.zeroPad = function (str) {
          var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
          var pad = '0';
          str = str + '';
          return str.length >= len ? str : new Array(len - str.length + 1).join(pad) + str;
        };

        exports.titleCase = function (str) {
          if (!str) {
            return '';
          }

          return str[0].toUpperCase() + str.substr(1);
        };

        exports.ordinal = function (i) {
          var j = i % 10;
          var k = i % 100;

          if (j === 1 && k !== 11) {
            return i + 'st';
          }

          if (j === 2 && k !== 12) {
            return i + 'nd';
          }

          if (j === 3 && k !== 13) {
            return i + 'rd';
          }

          return i + 'th';
        }; //strip 'st' off '1st'..


        exports.toCardinal = function (str) {
          str = String(str);
          str = str.replace(/([0-9])(st|nd|rd|th)$/i, '$1');
          return parseInt(str, 10);
        }; //used mostly for cleanup of unit names, like 'months'


        exports.normalize = function () {
          var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          str = str.toLowerCase().trim();
          str = str.replace(/ies$/, 'y'); //'centuries'

          str = str.replace(/s$/, '');
          str = str.replace(/-/g, '');

          if (str === 'day' || str === 'days') {
            return 'date';
          }

          if (str === 'min' || str === 'mins') {
            return 'minute';
          }

          return str;
        };

        exports.getEpoch = function (tmp) {
          //support epoch
          if (typeof tmp === 'number') {
            return tmp;
          } //suport date objects


          if (exports.isDate(tmp)) {
            return tmp.getTime();
          }

          if (tmp.epoch) {
            return tmp.epoch;
          }

          return null;
        }; //make sure this input is a spacetime obj


        exports.beADate = function (d, s) {
          if (exports.isObject(d) === false) {
            return s.clone().set(d);
          }

          return d;
        };

        exports.formatTimezone = function (offset) {
          var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var sign = offset > 0 ? '+' : '-';
          var absOffset = Math.abs(offset);
          var hours = exports.zeroPad(parseInt('' + absOffset, 10));
          var minutes = exports.zeroPad(absOffset % 1 * 60);
          return "".concat(sign).concat(hours).concat(delimiter).concat(minutes);
        };
      });
      var fns_1 = fns.isLeapYear;
      var fns_2 = fns.isDate;
      var fns_3 = fns.isArray;
      var fns_4 = fns.isObject;
      var fns_5 = fns.isBoolean;
      var fns_6 = fns.zeroPad;
      var fns_7 = fns.titleCase;
      var fns_8 = fns.ordinal;
      var fns_9 = fns.toCardinal;
      var fns_10 = fns.normalize;
      var fns_11 = fns.getEpoch;
      var fns_12 = fns.beADate;
      var fns_13 = fns.formatTimezone;
      var isLeapYear = fns.isLeapYear; //given a month, return whether day number exists in it

      var hasDate = function hasDate(obj) {
        //invalid values
        if (monthLengths_1.hasOwnProperty(obj.month) !== true) {
          return false;
        } //support leap-year in february


        if (obj.month === 1) {
          if (isLeapYear(obj.year) && obj.date <= 29) {
            return true;
          } else {
            return obj.date <= 28;
          }
        } //is this date too-big for this month?


        var max = monthLengths_1[obj.month] || 0;

        if (obj.date <= max) {
          return true;
        }

        return false;
      };

      var hasDate_1 = hasDate;
      var months$1 = months.mapping();

      var parseYear = function parseYear() {
        var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var today = arguments.length > 1 ? arguments[1] : undefined;
        var year = parseInt(str.trim(), 10); // use a given year from options.today

        if (!year && today) {
          year = today.year;
        } // fallback to this year


        year = year || new Date().getFullYear();
        return year;
      };

      var strFmt = [//iso-this 1998-05-30T22:00:00:000Z, iso-that 2017-04-03T08:00:00-0700
      {
        reg: /^(\-?0?0?[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\-\+:]+)?$/i,
        parse: function parse(s, arr, givenTz, options) {
          var month = parseInt(arr[2], 10) - 1;
          var obj = {
            year: arr[1],
            month: month,
            date: arr[3]
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          parseOffset_1$1(s, arr[5]);
          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //iso "2015-03-25" or "2015/03/25" or "2015/03/25 12:26:14 PM"
      {
        reg: /^([0-9]{4})[\-\/.]([0-9]{1,2})[\-\/.]([0-9]{1,2}),?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i,
        parse: function parse(s, arr) {
          var obj = {
            year: arr[1],
            month: parseInt(arr[2], 10) - 1,
            date: parseInt(arr[3], 10)
          };

          if (obj.month >= 12) {
            //support yyyy/dd/mm (weird, but ok)
            obj.date = parseInt(arr[2], 10);
            obj.month = parseInt(arr[3], 10) - 1;
          }

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //mm/dd/yyyy - uk/canada "6/28/2019, 12:26:14 PM"
      {
        reg: /^([0-9]{1,2})[\-\/.]([0-9]{1,2})[\-\/.]?([0-9]{4})?,?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i,
        parse: function parse(s, arr) {
          var month = parseInt(arr[1], 10) - 1;
          var date = parseInt(arr[2], 10); //support dd/mm/yyy

          if (s.british || month >= 12) {
            date = parseInt(arr[1], 10);
            month = parseInt(arr[2], 10) - 1;
          }

          var year = arr[3] || new Date().getFullYear();
          var obj = {
            year: year,
            month: month,
            date: date
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, // '2012-06' last attempt at iso-like format
      {
        reg: /^([0-9]{4})[\-\/]([0-9]{2})$/i,
        parse: function parse(s, arr, givenTz, options) {
          var month = parseInt(arr[2], 10) - 1;
          var obj = {
            year: arr[1],
            month: month,
            date: 1
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          parseOffset_1$1(s, arr[5]);
          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //common british format - "25-feb-2015"
      {
        reg: /^([0-9]{1,2})[\-\/]([a-z]+)[\-\/]?([0-9]{4})?$/i,
        parse: function parse(s, arr) {
          var month = months$1[arr[2].toLowerCase()];
          var year = parseYear(arr[3], s._today);
          var obj = {
            year: year,
            month: month,
            date: fns.toCardinal(arr[1] || '')
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //alt short format - "feb-25-2015"
      {
        reg: /^([a-z]+)[\-\/]([0-9]{1,2})[\-\/]?([0-9]{4})?$/i,
        parse: function parse(s, arr) {
          var month = months$1[arr[1].toLowerCase()];
          var year = parseYear(arr[3], s._today);
          var obj = {
            year: year,
            month: month,
            date: fns.toCardinal(arr[2] || '')
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //Long "Mar 25 2015"
      //February 22, 2017 15:30:00
      {
        reg: /^([a-z]+) ([0-9]{1,2}(?:st|nd|rd|th)?),?( [0-9]{4})?( ([0-9:]+( ?am| ?pm| ?gmt)?))?$/i,
        parse: function parse(s, arr) {
          var month = months$1[arr[1].toLowerCase()];
          var year = parseYear(arr[3], s._today);
          var obj = {
            year: year,
            month: month,
            date: fns.toCardinal(arr[2] || '')
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //February 2017 (implied date)
      {
        reg: /^([a-z]+) ([0-9]{4})$/i,
        parse: function parse(s, arr) {
          var month = months$1[arr[1].toLowerCase()];
          var year = parseYear(arr[2], s._today);
          var obj = {
            year: year,
            month: month,
            date: s._today.date || 1
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, //Long "25 Mar 2015"
      {
        reg: /^([0-9]{1,2}(?:st|nd|rd|th)?) ([a-z]+),?( [0-9]{4})?,? ?([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i,
        parse: function parse(s, arr) {
          var month = months$1[arr[2].toLowerCase()];

          if (!month) {
            return null;
          }

          var year = parseYear(arr[3], s._today);
          var obj = {
            year: year,
            month: month,
            date: fns.toCardinal(arr[1])
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s, arr[4]);
          return s;
        }
      }, {
        // 'q2 2002'
        reg: /^(q[0-9])( of)?( [0-9]{4})?/i,
        parse: function parse(s, arr) {
          var quarter = arr[1] || '';
          s = s.quarter(quarter);
          var year = arr[3] || '';

          if (year) {
            year = year.trim();
            s = s.year(year);
          }

          return s;
        }
      }, {
        // 'summer 2002'
        reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i,
        parse: function parse(s, arr) {
          var season = arr[1] || '';
          s = s.season(season);
          var year = arr[3] || '';

          if (year) {
            year = year.trim();
            s = s.year(year);
          }

          return s;
        }
      }, {
        // '200bc'
        reg: /^[0-9,]+ ?b\.?c\.?$/i,
        parse: function parse(s, arr) {
          var str = arr[0] || ''; //make negative-year

          str = str.replace(/^([0-9,]+) ?b\.?c\.?$/i, '-$1'); //remove commas

          str = str.replace(/,/g, '');
          var year = parseInt(str.trim(), 10);
          var d = new Date();
          var obj = {
            year: year,
            month: d.getMonth(),
            date: d.getDate()
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s);
          return s;
        }
      }, {
        // '200ad'
        reg: /^[0-9,]+ ?(a\.?d\.?|c\.?e\.?)$/i,
        parse: function parse(s, arr) {
          var str = arr[0] || ''; //remove commas

          str = str.replace(/,/g, '');
          var year = parseInt(str.trim(), 10);
          var d = new Date();
          var obj = {
            year: year,
            month: d.getMonth(),
            date: d.getDate()
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s);
          return s;
        }
      }, {
        // '1992'
        reg: /^[0-9]{4}( ?a\.?d\.?)?$/i,
        parse: function parse(s, arr) {
          var today = s._today;
          var year = parseYear(arr[0], today);
          var d = new Date(); // using today's date, but a new month is awkward.

          if (today.month && !today.date) {
            today.date = 1;
          }

          var obj = {
            year: year,
            month: today.month || d.getMonth(),
            date: today.date || d.getDate()
          };

          if (hasDate_1(obj) === false) {
            s.epoch = null;
            return s;
          }

          walk_1(s, obj);
          s = parseTime_1(s);
          return s;
        }
      }];
      var strParse = strFmt; // pull in 'today' data for the baseline moment

      var getNow = function getNow(s) {
        s.epoch = Date.now();
        Object.keys(s._today || {}).forEach(function (k) {
          if (typeof s[k] === 'function') {
            s = s[k](s._today[k]);
          }
        });
        return s;
      };

      var dates = {
        now: function now(s) {
          return getNow(s);
        },
        today: function today(s) {
          return getNow(s);
        },
        tonight: function tonight(s) {
          s = getNow(s);
          s = s.hour(18); //6pm

          return s;
        },
        tomorrow: function tomorrow(s) {
          s = getNow(s);
          s = s.add(1, 'day');
          s = s.startOf('day');
          return s;
        },
        yesterday: function yesterday(s) {
          s = getNow(s);
          s = s.subtract(1, 'day');
          s = s.startOf('day');
          return s;
        },
        christmas: function christmas(s) {
          var year = getNow(s).year();
          s = s.set([year, 11, 25, 18, 0, 0]); // Dec 25

          return s;
        },
        'new years': function newYears(s) {
          var year = getNow(s).year();
          s = s.set([year, 11, 31, 18, 0, 0]); // Dec 31

          return s;
        }
      };
      dates['new years eve'] = dates['new years'];
      var namedDates = dates; //  -  can't use built-in js parser ;(
      //=========================================
      // ISO Date	  "2015-03-25"
      // Short Date	"03/25/2015" or "2015/03/25"
      // Long Date	"Mar 25 2015" or "25 Mar 2015"
      // Full Date	"Wednesday March 25 2015"
      //=========================================
      //-- also -
      // if the given epoch is really small, they've probably given seconds and not milliseconds
      // anything below this number is likely (but not necessarily) a mistaken input.
      // this may seem like an arbitrary number, but it's 'within jan 1970'
      // this is only really ambiguous until 2054 or so

      var minimumEpoch = 2500000000;
      var defaults = {
        year: new Date().getFullYear(),
        month: 0,
        date: 1
      }; //support [2016, 03, 01] format

      var handleArray = function handleArray(s, arr, today) {
        if (arr.length === 0) {
          return s;
        }

        var order = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];

        for (var i = 0; i < order.length; i++) {
          var num = arr[i] || today[order[i]] || defaults[order[i]] || 0;
          s = s[order[i]](num);
        }

        return s;
      }; //support {year:2016, month:3} format


      var handleObject = function handleObject(s, obj, today) {
        // if obj is empty, do nothing
        if (Object.keys(obj).length === 0) {
          return s;
        }

        obj = Object.assign({}, defaults, today, obj);
        var keys = Object.keys(obj);

        for (var i = 0; i < keys.length; i++) {
          var unit = keys[i]; //make sure we have this method

          if (s[unit] === undefined || typeof s[unit] !== 'function') {
            continue;
          } //make sure the value is a number


          if (obj[unit] === null || obj[unit] === undefined || obj[unit] === '') {
            continue;
          }

          var num = obj[unit] || today[unit] || defaults[unit] || 0;
          s = s[unit](num);
        }

        return s;
      }; //find the epoch from different input styles


      var parseInput = function parseInput(s, input, givenTz) {
        var today = s._today || defaults; //if we've been given a epoch number, it's easy

        if (typeof input === 'number') {
          if (input > 0 && input < minimumEpoch && s.silent === false) {
            console.warn('  - Warning: You are setting the date to January 1970.');
            console.warn('       -   did input seconds instead of milliseconds?');
          }

          s.epoch = input;
          return s;
        } //set tmp time


        s.epoch = Date.now(); // overwrite tmp time with 'today' value, if exists

        if (s._today && fns.isObject(s._today) && Object.keys(s._today).length > 0) {
          var res = handleObject(s, today, defaults);

          if (res.isValid()) {
            s.epoch = res.epoch;
          }
        } // null input means 'now'


        if (input === null || input === undefined || input === '') {
          return s; //k, we're good.
        } //support input of Date() object


        if (fns.isDate(input) === true) {
          s.epoch = input.getTime();
          return s;
        } //support [2016, 03, 01] format


        if (fns.isArray(input) === true) {
          s = handleArray(s, input, today);
          return s;
        } //support {year:2016, month:3} format


        if (fns.isObject(input) === true) {
          //support spacetime object as input
          if (input.epoch) {
            s.epoch = input.epoch;
            s.tz = input.tz;
            return s;
          }

          s = handleObject(s, input, today);
          return s;
        } //input as a string..


        if (typeof input !== 'string') {
          return s;
        } //little cleanup..


        input = input.replace(/\b(mon|tues|wed|wednes|thu|thurs|fri|sat|satur|sun)(day)?\b/i, '');
        input = input.replace(/,/g, '');
        input = input.replace(/ +/g, ' ').trim(); //try some known-words, like 'now'

        if (namedDates.hasOwnProperty(input) === true) {
          s = namedDates[input](s);
          return s;
        } //try each text-parse template, use the first good result


        for (var i = 0; i < strParse.length; i++) {
          var m = input.match(strParse[i].reg);

          if (m) {
            // console.log(strFmt[i].reg)
            var _res = strParse[i].parse(s, m, givenTz);

            if (_res !== null && _res.isValid()) {
              return _res;
            }
          }
        }

        if (s.silent === false) {
          console.warn("Warning: couldn't parse date-string: '" + input + "'");
        }

        s.epoch = null;
        return s;
      };

      var input = parseInput;
      var shortDays = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
      var longDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      var days = {
        "short": function _short2() {
          return shortDays;
        },
        "long": function _long2() {
          return longDays;
        },
        set: function set(i18n) {
          shortDays = i18n["short"] || shortDays;
          longDays = i18n["long"] || longDays;
        },
        aliases: {
          tues: 2,
          thur: 4,
          thurs: 4
        }
      };
      var titleCaseEnabled = true;
      var caseFormat = {
        useTitleCase: function useTitleCase() {
          return titleCaseEnabled;
        },
        set: function set(useTitleCase) {
          titleCaseEnabled = useTitleCase;
        }
      }; // it's kind of nuts how involved this is
      // "+01:00", "+0100", or simply "+01"

      var isoOffset = function isoOffset(s) {
        var offset = s.timezone().current.offset;
        return !offset ? 'Z' : fns.formatTimezone(offset, ':');
      };

      var _offset = isoOffset;

      var applyCaseFormat = function applyCaseFormat(str) {
        if (caseFormat.useTitleCase()) {
          return fns.titleCase(str);
        }

        return str;
      };

      var format = {
        day: function day(s) {
          return applyCaseFormat(s.dayName());
        },
        'day-short': function dayShort(s) {
          return applyCaseFormat(days["short"]()[s.day()]);
        },
        'day-number': function dayNumber(s) {
          return s.day();
        },
        'day-ordinal': function dayOrdinal(s) {
          return fns.ordinal(s.day());
        },
        'day-pad': function dayPad(s) {
          return fns.zeroPad(s.day());
        },
        date: function date(s) {
          return s.date();
        },
        'date-ordinal': function dateOrdinal(s) {
          return fns.ordinal(s.date());
        },
        'date-pad': function datePad(s) {
          return fns.zeroPad(s.date());
        },
        month: function month(s) {
          return applyCaseFormat(s.monthName());
        },
        'month-short': function monthShort(s) {
          return applyCaseFormat(months["short"]()[s.month()]);
        },
        'month-number': function monthNumber(s) {
          return s.month();
        },
        'month-ordinal': function monthOrdinal(s) {
          return fns.ordinal(s.month());
        },
        'month-pad': function monthPad(s) {
          return fns.zeroPad(s.month());
        },
        'iso-month': function isoMonth(s) {
          return fns.zeroPad(s.month() + 1);
        },
        //1-based months
        year: function year(s) {
          var year = s.year();

          if (year > 0) {
            return year;
          }

          year = Math.abs(year);
          return year + ' BC';
        },
        'year-short': function yearShort(s) {
          var year = s.year();

          if (year > 0) {
            return "'".concat(String(s.year()).substr(2, 4));
          }

          year = Math.abs(year);
          return year + ' BC';
        },
        'iso-year': function isoYear(s) {
          var year = s.year();
          var isNegative = year < 0;
          var str = fns.zeroPad(Math.abs(year), 4); //0-padded

          if (isNegative) {
            //negative years are for some reason 6-digits ('-00008')
            str = fns.zeroPad(str, 6);
            str = '-' + str;
          }

          return str;
        },
        time: function time(s) {
          return s.time();
        },
        'time-24': function time24(s) {
          return "".concat(s.hour24(), ":").concat(fns.zeroPad(s.minute()));
        },
        hour: function hour(s) {
          return s.hour12();
        },
        'hour-pad': function hourPad(s) {
          return fns.zeroPad(s.hour12());
        },
        'hour-24': function hour24(s) {
          return s.hour24();
        },
        'hour-24-pad': function hour24Pad(s) {
          return fns.zeroPad(s.hour24());
        },
        minute: function minute(s) {
          return s.minute();
        },
        'minute-pad': function minutePad(s) {
          return fns.zeroPad(s.minute());
        },
        second: function second(s) {
          return s.second();
        },
        'second-pad': function secondPad(s) {
          return fns.zeroPad(s.second());
        },
        ampm: function ampm(s) {
          return s.ampm();
        },
        quarter: function quarter(s) {
          return 'Q' + s.quarter();
        },
        season: function season(s) {
          return s.season();
        },
        era: function era(s) {
          return s.era();
        },
        json: function json(s) {
          return s.json();
        },
        timezone: function timezone(s) {
          return s.timezone().name;
        },
        offset: function offset(s) {
          return _offset(s);
        },
        numeric: function numeric(s) {
          return "".concat(s.year(), "/").concat(fns.zeroPad(s.month() + 1), "/").concat(fns.zeroPad(s.date()));
        },
        // yyyy/mm/dd
        'numeric-us': function numericUs(s) {
          return "".concat(fns.zeroPad(s.month() + 1), "/").concat(fns.zeroPad(s.date()), "/").concat(s.year());
        },
        // mm/dd/yyyy
        'numeric-uk': function numericUk(s) {
          return "".concat(fns.zeroPad(s.date()), "/").concat(fns.zeroPad(s.month() + 1), "/").concat(s.year());
        },
        //dd/mm/yyyy
        'mm/dd': function mmDd(s) {
          return "".concat(fns.zeroPad(s.month() + 1), "/").concat(fns.zeroPad(s.date()));
        },
        //mm/dd
        // ... https://en.wikipedia.org/wiki/ISO_8601 ;(((
        iso: function iso(s) {
          var year = s.format('iso-year');
          var month = fns.zeroPad(s.month() + 1); //1-based months

          var date = fns.zeroPad(s.date());
          var hour = fns.zeroPad(s.h24());
          var minute = fns.zeroPad(s.minute());
          var second = fns.zeroPad(s.second());
          var ms = fns.zeroPad(s.millisecond(), 3);

          var offset = _offset(s);

          return "".concat(year, "-").concat(month, "-").concat(date, "T").concat(hour, ":").concat(minute, ":").concat(second, ".").concat(ms).concat(offset); //2018-03-09T08:50:00.000-05:00
        },
        'iso-short': function isoShort(s) {
          var month = fns.zeroPad(s.month() + 1); //1-based months

          var date = fns.zeroPad(s.date());
          return "".concat(s.year(), "-").concat(month, "-").concat(date); //2017-02-15
        },
        'iso-utc': function isoUtc(s) {
          return new Date(s.epoch).toISOString(); //2017-03-08T19:45:28.367Z
        },
        //i made these up
        nice: function nice(s) {
          return "".concat(months["short"]()[s.month()], " ").concat(fns.ordinal(s.date()), ", ").concat(s.time());
        },
        'nice-year': function niceYear(s) {
          return "".concat(months["short"]()[s.month()], " ").concat(fns.ordinal(s.date()), ", ").concat(s.year());
        },
        'nice-day': function niceDay(s) {
          return "".concat(days["short"]()[s.day()], " ").concat(applyCaseFormat(months["short"]()[s.month()]), " ").concat(fns.ordinal(s.date()));
        },
        'nice-full': function niceFull(s) {
          return "".concat(s.dayName(), " ").concat(applyCaseFormat(s.monthName()), " ").concat(fns.ordinal(s.date()), ", ").concat(s.time());
        }
      }; //aliases

      var aliases = {
        'day-name': 'day',
        'month-name': 'month',
        'iso 8601': 'iso',
        'time-h24': 'time-24',
        'time-12': 'time',
        'time-h12': 'time',
        tz: 'timezone',
        'day-num': 'day-number',
        'month-num': 'month-number',
        'month-iso': 'iso-month',
        'year-iso': 'iso-year',
        'nice-short': 'nice',
        mdy: 'numeric-us',
        dmy: 'numeric-uk',
        ymd: 'numeric',
        'yyyy/mm/dd': 'numeric',
        'mm/dd/yyyy': 'numeric-us',
        'dd/mm/yyyy': 'numeric-us',
        'little-endian': 'numeric-uk',
        'big-endian': 'numeric',
        'day-nice': 'nice-day'
      };
      Object.keys(aliases).forEach(function (k) {
        return format[k] = format[aliases[k]];
      });

      var printFormat = function printFormat(s) {
        var str = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ''; //don't print anything if it's an invalid date

        if (s.isValid() !== true) {
          return '';
        } //support .format('month')


        if (format.hasOwnProperty(str)) {
          var out = format[str](s) || '';

          if (str !== 'json') {
            out = String(out);

            if (str !== 'ampm') {
              out = applyCaseFormat(out);
            }
          }

          return out;
        } //support '{hour}:{minute}' notation


        if (str.indexOf('{') !== -1) {
          var sections = /\{(.+?)\}/g;
          str = str.replace(sections, function (_, fmt) {
            fmt = fmt.toLowerCase().trim();

            if (format.hasOwnProperty(fmt)) {
              return String(format[fmt](s));
            }

            return '';
          });
          return str;
        }

        return s.format('iso-short');
      };

      var format_1 = printFormat;
      var pad = fns.zeroPad;
      var formatTimezone = fns.formatTimezone; //parse this insane unix-time-templating thing, from the 19th century
      //http://unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns
      //time-symbols we support

      var mapping = {
        G: function G(s) {
          return s.era();
        },
        GG: function GG(s) {
          return s.era();
        },
        GGG: function GGG(s) {
          return s.era();
        },
        GGGG: function GGGG(s) {
          return s.era() === 'AD' ? 'Anno Domini' : 'Before Christ';
        },
        //year
        y: function y(s) {
          return s.year();
        },
        yy: function yy(s) {
          //last two chars
          return parseInt(String(s.year()).substr(2, 4), 10);
        },
        yyy: function yyy(s) {
          return s.year();
        },
        yyyy: function yyyy(s) {
          return s.year();
        },
        yyyyy: function yyyyy(s) {
          return '0' + s.year();
        },
        // u: (s) => {},//extended non-gregorian years
        //quarter
        Q: function Q(s) {
          return s.quarter();
        },
        QQ: function QQ(s) {
          return s.quarter();
        },
        QQQ: function QQQ(s) {
          return s.quarter();
        },
        QQQQ: function QQQQ(s) {
          return s.quarter();
        },
        //month
        M: function M(s) {
          return s.month() + 1;
        },
        MM: function MM(s) {
          return pad(s.month() + 1);
        },
        MMM: function MMM(s) {
          return s.format('month-short');
        },
        MMMM: function MMMM(s) {
          return s.format('month');
        },
        //week
        w: function w(s) {
          return s.week();
        },
        ww: function ww(s) {
          return pad(s.week());
        },
        //week of month
        // W: (s) => s.week(),
        //date of month
        d: function d(s) {
          return s.date();
        },
        dd: function dd(s) {
          return pad(s.date());
        },
        //date of year
        D: function D(s) {
          return s.dayOfYear();
        },
        DD: function DD(s) {
          return pad(s.dayOfYear());
        },
        DDD: function DDD(s) {
          return pad(s.dayOfYear(), 3);
        },
        // F: (s) => {},//date of week in month
        // g: (s) => {},//modified julian day
        //day
        E: function E(s) {
          return s.format('day-short');
        },
        EE: function EE(s) {
          return s.format('day-short');
        },
        EEE: function EEE(s) {
          return s.format('day-short');
        },
        EEEE: function EEEE(s) {
          return s.format('day');
        },
        EEEEE: function EEEEE(s) {
          return s.format('day')[0];
        },
        e: function e(s) {
          return s.day();
        },
        ee: function ee(s) {
          return s.day();
        },
        eee: function eee(s) {
          return s.format('day-short');
        },
        eeee: function eeee(s) {
          return s.format('day');
        },
        eeeee: function eeeee(s) {
          return s.format('day')[0];
        },
        //am/pm
        a: function a(s) {
          return s.ampm().toUpperCase();
        },
        aa: function aa(s) {
          return s.ampm().toUpperCase();
        },
        aaa: function aaa(s) {
          return s.ampm().toUpperCase();
        },
        aaaa: function aaaa(s) {
          return s.ampm().toUpperCase();
        },
        //hour
        h: function h(s) {
          return s.h12();
        },
        hh: function hh(s) {
          return pad(s.h12());
        },
        H: function H(s) {
          return s.hour();
        },
        HH: function HH(s) {
          return pad(s.hour());
        },
        // j: (s) => {},//weird hour format
        m: function m(s) {
          return s.minute();
        },
        mm: function mm(s) {
          return pad(s.minute());
        },
        s: function s(_s) {
          return _s.second();
        },
        ss: function ss(s) {
          return pad(s.second());
        },
        //milliseconds in the day
        A: function A(s) {
          return s.epoch - s.startOf('day').epoch;
        },
        //timezone
        z: function z(s) {
          return s.timezone().name;
        },
        zz: function zz(s) {
          return s.timezone().name;
        },
        zzz: function zzz(s) {
          return s.timezone().name;
        },
        zzzz: function zzzz(s) {
          return s.timezone().name;
        },
        Z: function Z(s) {
          return formatTimezone(s.timezone().current.offset);
        },
        ZZ: function ZZ(s) {
          return formatTimezone(s.timezone().current.offset);
        },
        ZZZ: function ZZZ(s) {
          return formatTimezone(s.timezone().current.offset);
        },
        ZZZZ: function ZZZZ(s) {
          return formatTimezone(s.timezone().current.offset, ':');
        }
      };

      var addAlias = function addAlias(_char, to, n) {
        var name = _char;
        var toName = to;

        for (var i = 0; i < n; i += 1) {
          mapping[name] = mapping[toName];
          name += _char;
          toName += to;
        }
      };

      addAlias('q', 'Q', 4);
      addAlias('L', 'M', 4);
      addAlias('Y', 'y', 4);
      addAlias('c', 'e', 4);
      addAlias('k', 'H', 2);
      addAlias('K', 'h', 2);
      addAlias('S', 's', 2);
      addAlias('v', 'z', 4);
      addAlias('V', 'Z', 4); // support unix-style escaping with ' character

      var escapeChars = function escapeChars(arr) {
        for (var i = 0; i < arr.length; i += 1) {
          if (arr[i] === "'") {
            // greedy-search for next apostrophe
            for (var o = i + 1; o < arr.length; o += 1) {
              if (arr[o]) {
                arr[i] += arr[o];
              }

              if (arr[o] === "'") {
                arr[o] = null;
                break;
              }

              arr[o] = null;
            }
          }
        }

        return arr.filter(function (ch) {
          return ch;
        });
      }; //combine consecutive chars, like 'yyyy' as one.


      var combineRepeated = function combineRepeated(arr) {
        for (var i = 0; i < arr.length; i += 1) {
          var c = arr[i]; // greedy-forward

          for (var o = i + 1; o < arr.length; o += 1) {
            if (arr[o] === c) {
              arr[i] += arr[o];
              arr[o] = null;
            } else {
              break;
            }
          }
        } // '' means one apostrophe


        arr = arr.filter(function (ch) {
          return ch;
        });
        arr = arr.map(function (str) {
          if (str === "''") {
            str = "'";
          }

          return str;
        });
        return arr;
      };

      var unixFmt = function unixFmt(s, str) {
        var arr = str.split(''); // support character escaping

        arr = escapeChars(arr); //combine 'yyyy' as string.

        arr = combineRepeated(arr);
        return arr.reduce(function (txt, c) {
          if (mapping[c] !== undefined) {
            txt += mapping[c](s) || '';
          } else {
            // 'unescape'
            if (/^'.{1,}'$/.test(c)) {
              c = c.replace(/'/g, '');
            }

            txt += c;
          }

          return txt;
        }, '');
      };

      var unixFmt_1 = unixFmt;
      var units$1 = ['year', 'season', 'quarter', 'month', 'week', 'day', 'quarterHour', 'hour', 'minute'];

      var doUnit = function doUnit(s, k) {
        var start = s.clone().startOf(k);
        var end = s.clone().endOf(k);
        var duration = end.epoch - start.epoch;
        var percent = (s.epoch - start.epoch) / duration;
        return parseFloat(percent.toFixed(2));
      }; //how far it is along, from 0-1


      var progress = function progress(s, unit) {
        if (unit) {
          unit = fns.normalize(unit);
          return doUnit(s, unit);
        }

        var obj = {};
        units$1.forEach(function (k) {
          obj[k] = doUnit(s, k);
        });
        return obj;
      };

      var progress_1 = progress;

      var nearest = function nearest(s, unit) {
        //how far have we gone?
        var prog = s.progress();
        unit = fns.normalize(unit); //fix camel-case for this one

        if (unit === 'quarterhour') {
          unit = 'quarterHour';
        }

        if (prog[unit] !== undefined) {
          // go forward one?
          if (prog[unit] > 0.5) {
            s = s.add(1, unit);
          } // go to start


          s = s.startOf(unit);
        } else if (s.silent === false) {
          console.warn("no known unit '" + unit + "'");
        }

        return s;
      };

      var nearest_1 = nearest; //increment until dates are the same

      var climb = function climb(a, b, unit) {
        var i = 0;
        a = a.clone();

        while (a.isBefore(b)) {
          //do proper, expensive increment to catch all-the-tricks
          a = a.add(1, unit);
          i += 1;
        } //oops, we went too-far..


        if (a.isAfter(b, unit)) {
          i -= 1;
        }

        return i;
      }; // do a thurough +=1 on the unit, until they match
      // for speed-reasons, only used on day, month, week.


      var diffOne = function diffOne(a, b, unit) {
        if (a.isBefore(b)) {
          return climb(a, b, unit);
        } else {
          return climb(b, a, unit) * -1; //reverse it
        }
      };

      var one = diffOne; // 2020 - 2019 may be 1 year, or 0 years
      // - '1 year difference' means 366 days during a leap year

      var fastYear = function fastYear(a, b) {
        var years = b.year() - a.year(); // should we decrement it by 1?

        a = a.year(b.year());

        if (a.isAfter(b)) {
          years -= 1;
        }

        return years;
      }; // use a waterfall-method for computing a diff of any 'pre-knowable' units
      // compute years, then compute months, etc..
      // ... then ms-math for any very-small units


      var diff = function diff(a, b) {
        // an hour is always the same # of milliseconds
        // so these units can be 'pre-calculated'
        var msDiff = b.epoch - a.epoch;
        var obj = {
          milliseconds: msDiff,
          seconds: parseInt(msDiff / 1000, 10)
        };
        obj.minutes = parseInt(obj.seconds / 60, 10);
        obj.hours = parseInt(obj.minutes / 60, 10); //do the year

        var tmp = a.clone();
        obj.years = fastYear(tmp, b);
        tmp = a.add(obj.years, 'year'); //there's always 12 months in a year...

        obj.months = obj.years * 12;
        tmp = a.add(obj.months, 'month');
        obj.months += one(tmp, b, 'month'); // there's always atleast 52 weeks in a year..
        // (month * 4) isn't as close

        obj.weeks = obj.years * 52;
        tmp = a.add(obj.weeks, 'week');
        obj.weeks += one(tmp, b, 'week'); // there's always atleast 7 days in a week

        obj.days = obj.weeks * 7;
        tmp = a.add(obj.days, 'day');
        obj.days += one(tmp, b, 'day');
        return obj;
      };

      var waterfall = diff;

      var reverseDiff = function reverseDiff(obj) {
        Object.keys(obj).forEach(function (k) {
          obj[k] *= -1;
        });
        return obj;
      }; // this method counts a total # of each unit, between a, b.
      // '1 month' means 28 days in february
      // '1 year' means 366 days in a leap year


      var main = function main(a, b, unit) {
        b = fns.beADate(b, a); //reverse values, if necessary

        var reversed = false;

        if (a.isAfter(b)) {
          var tmp = a;
          a = b;
          b = tmp;
          reversed = true;
        } //compute them all (i know!)


        var obj = waterfall(a, b);

        if (reversed) {
          obj = reverseDiff(obj);
        } //return just the requested unit


        if (unit) {
          //make sure it's plural-form
          unit = fns.normalize(unit);

          if (/s$/.test(unit) !== true) {
            unit += 's';
          }

          if (unit === 'dates') {
            unit = 'days';
          }

          return obj[unit];
        }

        return obj;
      };

      var diff$1 = main; //our conceptual 'break-points' for each unit

      var qualifiers = {
        months: {
          almost: 10,
          over: 4
        },
        days: {
          almost: 25,
          over: 10
        },
        hours: {
          almost: 20,
          over: 8
        },
        minutes: {
          almost: 50,
          over: 20
        },
        seconds: {
          almost: 50,
          over: 20
        }
      }; //get number of hours/minutes... between the two dates

      function getDiff(a, b) {
        var isBefore = a.isBefore(b);
        var later = isBefore ? b : a;
        var earlier = isBefore ? a : b;
        earlier = earlier.clone();
        var diff = {
          years: 0,
          months: 0,
          days: 0,
          hours: 0,
          minutes: 0,
          seconds: 0
        };
        Object.keys(diff).forEach(function (unit) {
          if (earlier.isSame(later, unit)) {
            return;
          }

          var max = earlier.diff(later, unit);
          earlier = earlier.add(max, unit);
          diff[unit] = max;
        }); //reverse it, if necessary

        if (isBefore) {
          Object.keys(diff).forEach(function (u) {
            if (diff[u] !== 0) {
              diff[u] *= -1;
            }
          });
        }

        return diff;
      } // Expects a plural unit arg


      function pluralize(value, unit) {
        if (value === 1) {
          unit = unit.slice(0, -1);
        }

        return value + ' ' + unit;
      } //create the human-readable diff between the two dates


      var since = function since(start, end) {
        end = fns.beADate(end, start);
        var diff = getDiff(start, end);
        var isNow = Object.keys(diff).every(function (u) {
          return !diff[u];
        });

        if (isNow === true) {
          return {
            diff: diff,
            rounded: 'now',
            qualified: 'now',
            precise: 'now'
          };
        }

        var rounded;
        var qualified;
        var precise;
        var englishValues = []; //go through each value and create its text-representation

        Object.keys(diff).forEach(function (unit, i, units) {
          var value = Math.abs(diff[unit]);

          if (value === 0) {
            return;
          }

          var englishValue = pluralize(value, unit);
          englishValues.push(englishValue);

          if (!rounded) {
            rounded = qualified = englishValue;

            if (i > 4) {
              return;
            } //is it a 'almost' something, etc?


            var nextUnit = units[i + 1];
            var nextValue = Math.abs(diff[nextUnit]);

            if (nextValue > qualifiers[nextUnit].almost) {
              rounded = pluralize(value + 1, unit);
              qualified = 'almost ' + rounded;
            } else if (nextValue > qualifiers[nextUnit].over) qualified = 'over ' + englishValue;
          }
        }); //make them into a string

        precise = englishValues.splice(0, 2).join(', '); //handle before/after logic

        if (start.isAfter(end) === true) {
          rounded += ' ago';
          qualified += ' ago';
          precise += ' ago';
        } else {
          rounded = 'in ' + rounded;
          qualified = 'in ' + qualified;
          precise = 'in ' + precise;
        }

        return {
          diff: diff,
          rounded: rounded,
          qualified: qualified,
          precise: precise
        };
      };

      var since_1 = since; //https://www.timeanddate.com/calendar/aboutseasons.html
      // Spring - from March 1 to May 31;
      // Summer - from June 1 to August 31;
      // Fall (autumn) - from September 1 to November 30; and,
      // Winter - from December 1 to February 28 (February 29 in a leap year).

      var seasons = {
        north: [['spring', 2, 1], //spring march 1
        ['summer', 5, 1], //june 1
        ['fall', 8, 1], //sept 1
        ['autumn', 8, 1], //sept 1
        ['winter', 11, 1] //dec 1
        ],
        south: [['fall', 2, 1], //march 1
        ['autumn', 2, 1], //march 1
        ['winter', 5, 1], //june 1
        ['spring', 8, 1], //sept 1
        ['summer', 11, 1] //dec 1
        ]
      };
      var quarters = [null, [0, 1], //jan 1
      [3, 1], //apr 1
      [6, 1], //july 1
      [9, 1] //oct 1
      ];
      var units$2 = {
        minute: function minute(s) {
          walk_1(s, {
            second: 0,
            millisecond: 0
          });
          return s;
        },
        quarterhour: function quarterhour(s) {
          var minute = s.minutes();

          if (minute >= 45) {
            s = s.minutes(45);
          } else if (minute >= 30) {
            s = s.minutes(30);
          } else if (minute >= 15) {
            s = s.minutes(15);
          } else {
            s = s.minutes(0);
          }

          walk_1(s, {
            second: 0,
            millisecond: 0
          });
          return s;
        },
        hour: function hour(s) {
          walk_1(s, {
            minute: 0,
            second: 0,
            millisecond: 0
          });
          return s;
        },
        day: function day(s) {
          walk_1(s, {
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          });
          return s;
        },
        week: function week(s) {
          var original = s.clone();
          s = s.day(s._weekStart); //monday

          if (s.isAfter(original)) {
            s = s.subtract(1, 'week');
          }

          walk_1(s, {
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          });
          return s;
        },
        month: function month(s) {
          walk_1(s, {
            date: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          });
          return s;
        },
        quarter: function quarter(s) {
          var q = s.quarter();

          if (quarters[q]) {
            walk_1(s, {
              month: quarters[q][0],
              date: quarters[q][1],
              hour: 0,
              minute: 0,
              second: 0,
              millisecond: 0
            });
          }

          return s;
        },
        season: function season(s) {
          var current = s.season();
          var hem = 'north';

          if (s.hemisphere() === 'South') {
            hem = 'south';
          }

          for (var i = 0; i < seasons[hem].length; i++) {
            if (seasons[hem][i][0] === current) {
              //winter goes between years
              var year = s.year();

              if (current === 'winter' && s.month() < 3) {
                year -= 1;
              }

              walk_1(s, {
                year: year,
                month: seasons[hem][i][1],
                date: seasons[hem][i][2],
                hour: 0,
                minute: 0,
                second: 0,
                millisecond: 0
              });
              return s;
            }
          }

          return s;
        },
        year: function year(s) {
          walk_1(s, {
            month: 0,
            date: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          });
          return s;
        },
        decade: function decade(s) {
          s = s.startOf('year');
          var year = s.year();
          var decade = parseInt(year / 10, 10) * 10;
          s = s.year(decade);
          return s;
        },
        century: function century(s) {
          s = s.startOf('year');
          var year = s.year(); // near 0AD goes '-1 | +1'

          var decade = parseInt(year / 100, 10) * 100;
          s = s.year(decade);
          return s;
        }
      };
      units$2.date = units$2.day;

      var startOf = function startOf(a, unit) {
        var s = a.clone();
        unit = fns.normalize(unit);

        if (units$2[unit]) {
          return units$2[unit](s);
        }

        if (unit === 'summer' || unit === 'winter') {
          s = s.season(unit);
          return units$2.season(s);
        }

        return s;
      }; //piggy-backs off startOf


      var endOf = function endOf(a, unit) {
        var s = a.clone();
        unit = fns.normalize(unit);

        if (units$2[unit]) {
          s = units$2[unit](s); // startof

          s = s.add(1, unit);
          s = s.subtract(1, 'milliseconds');
          return s;
        }

        return s;
      };

      var startOf_1 = {
        startOf: startOf,
        endOf: endOf
      };

      var isDay = function isDay(unit) {
        if (days["short"]().find(function (s) {
          return s === unit;
        })) {
          return true;
        }

        if (days["long"]().find(function (s) {
          return s === unit;
        })) {
          return true;
        }

        return false;
      }; // return a list of the weeks/months/days between a -> b
      // returns spacetime objects in the timezone of the input


      var every = function every(start) {
        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var end = arguments.length > 2 ? arguments[2] : undefined;

        if (!unit || !end) {
          return [];
        } //cleanup unit param


        unit = fns.normalize(unit); //cleanup to param

        end = start.clone().set(end); //swap them, if they're backwards

        if (start.isAfter(end)) {
          var tmp = start;
          start = end;
          end = tmp;
        } //support 'every wednesday'


        var d = start.clone();

        if (isDay(unit)) {
          d = d.next(unit);
          unit = 'week';
        } else {
          d = d.next(unit);
        } //okay, actually start doing it


        var result = [];

        while (d.isBefore(end)) {
          result.push(d);
          d = d.add(1, unit);
        }

        return result;
      };

      var every_1 = every;

      var parseDst = function parseDst(dst) {
        if (!dst) {
          return [];
        }

        return dst.split('->');
      };

      var titleCase = function titleCase(str) {
        str = str[0].toUpperCase() + str.substr(1);
        str = str.replace(/\/gmt/, '/GMT');
        str = str.replace(/[\/_]([a-z])/gi, function (s) {
          return s.toUpperCase();
        });
        return str;
      }; //get metadata about this timezone


      var timezone = function timezone(s) {
        var zones = s.timezones;
        var tz = s.tz;

        if (zones.hasOwnProperty(tz) === false) {
          tz = find(s.tz, zones);
        }

        if (tz === null) {
          if (s.silent === false) {
            console.warn("Warn: could not find given or local timezone - '" + s.tz + "'");
          }

          return {
            current: {
              epochShift: 0
            }
          };
        }

        var found = zones[tz];
        var result = {
          name: titleCase(tz),
          hasDst: Boolean(found.dst),
          default_offset: found.offset,
          //do north-hemisphere version as default (sorry!)
          hemisphere: found.hem === 's' ? 'South' : 'North',
          current: {}
        };

        if (result.hasDst) {
          var arr = parseDst(found.dst);
          result.change = {
            start: arr[0],
            back: arr[1]
          };
        } //find the offsets for summer/winter times
        //(these variable names are north-centric)


        var summer = found.offset; // (july)

        var winter = summer; // (january) assume it's the same for now

        if (result.hasDst === true) {
          if (result.hemisphere === 'North') {
            winter = summer - 1;
          } else {
            //southern hemisphere
            winter = found.offset + 1;
          }
        } //find out which offset to use right now
        //use 'summer' time july-time


        if (result.hasDst === false) {
          result.current.offset = summer;
          result.current.isDST = false;
        } else if (summerTime(s.epoch, result.change.start, result.change.back, summer, winter) === true) {
          result.current.offset = summer;
          result.current.isDST = result.hemisphere === 'North'; //dst 'on' in winter in north
        } else {
          //use 'winter' january-time
          result.current.offset = winter;
          result.current.isDST = result.hemisphere === 'South'; //dst 'on' in summer in south
        }

        return result;
      };

      var timezone_1 = timezone;
      var units$3 = ['century', 'decade', 'year', 'month', 'date', 'day', 'hour', 'minute', 'second', 'millisecond']; //the spacetime instance methods (also, the API)

      var methods = {
        set: function set(input$1, tz) {
          var s = this.clone();
          s = input(s, input$1, null);

          if (tz) {
            this.tz = find(tz);
          }

          return s;
        },
        timezone: function timezone() {
          return timezone_1(this);
        },
        isDST: function isDST() {
          return timezone_1(this).current.isDST;
        },
        hasDST: function hasDST() {
          return timezone_1(this).hasDst;
        },
        offset: function offset() {
          return timezone_1(this).current.offset * 60;
        },
        hemisphere: function hemisphere() {
          return timezone_1(this).hemisphere;
        },
        format: function format(fmt) {
          return format_1(this, fmt);
        },
        unixFmt: function unixFmt(fmt) {
          return unixFmt_1(this, fmt);
        },
        startOf: function startOf(unit) {
          return startOf_1.startOf(this, unit);
        },
        endOf: function endOf(unit) {
          return startOf_1.endOf(this, unit);
        },
        leapYear: function leapYear() {
          var year = this.year();
          return fns.isLeapYear(year);
        },
        progress: function progress(unit) {
          return progress_1(this, unit);
        },
        nearest: function nearest(unit) {
          return nearest_1(this, unit);
        },
        diff: function diff(d, unit) {
          return diff$1(this, d, unit);
        },
        since: function since(d) {
          if (!d) {
            d = this.clone().set();
          }

          return since_1(this, d);
        },
        next: function next(unit) {
          var s = this.add(1, unit);
          return s.startOf(unit);
        },
        //the start of the previous year/week/century
        last: function last(unit) {
          var s = this.subtract(1, unit);
          return s.startOf(unit);
        },
        isValid: function isValid() {
          //null/undefined epochs
          if (!this.epoch && this.epoch !== 0) {
            return false;
          }

          return !isNaN(this.d.getTime());
        },
        //travel to this timezone
        "goto": function _goto(tz) {
          var s = this.clone();
          s.tz = find(tz, s.timezones); //science!

          return s;
        },
        //get each week/month/day between a -> b
        every: function every(unit, to) {
          return every_1(this, unit, to);
        },
        isAwake: function isAwake() {
          var hour = this.hour(); //10pm -> 8am

          if (hour < 8 || hour > 22) {
            return false;
          }

          return true;
        },
        isAsleep: function isAsleep() {
          return !this.isAwake();
        },
        //pretty-printing
        log: function log() {
          console.log('');
          console.log(format_1(this, 'nice-short'));
          return this;
        },
        logYear: function logYear() {
          console.log('');
          console.log(format_1(this, 'full-short'));
          return this;
        },
        json: function json() {
          var _this = this;

          return units$3.reduce(function (h, unit) {
            h[unit] = _this[unit]();
            return h;
          }, {});
        },
        debug: function debug() {
          var tz = this.timezone();
          var date = this.format('MM') + ' ' + this.format('date-ordinal') + ' ' + this.year();
          date += '\n     - ' + this.format('time');
          console.log('\n\n', date + '\n     - ' + tz.name + ' (' + tz.current.offset + ')');
          return this;
        },
        //alias of 'since' but opposite - like moment.js
        from: function from(d) {
          d = this.clone().set(d);
          return d.since(this);
        },
        fromNow: function fromNow() {
          var d = this.clone().set(Date.now());
          return d.since(this);
        },
        weekStart: function weekStart(input) {
          //accept a number directly
          if (typeof input === 'number') {
            this._weekStart = input;
            return this;
          }

          if (typeof input === 'string') {
            // accept 'wednesday'
            input = input.toLowerCase().trim();
            var num = days["short"]().indexOf(input);

            if (num === -1) {
              num = days["long"]().indexOf(input);
            }

            if (num === -1) {
              num = 1; //go back to default
            }

            this._weekStart = num;
          } else {
            console.warn('Spacetime Error: Cannot understand .weekStart() input:', input);
          }

          return this;
        }
      }; // aliases

      methods.inDST = methods.isDST;
      methods.round = methods.nearest;
      methods.each = methods.every;
      var methods_1 = methods; //these methods wrap around them.

      var isLeapYear$1 = fns.isLeapYear;

      var validate = function validate(n) {
        //handle number as a string
        if (typeof n === 'string') {
          n = parseInt(n, 10);
        }

        return n;
      };

      var order = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond']; //reduce hostile micro-changes when moving dates by millisecond

      var confirm = function confirm(s, tmp, unit) {
        var n = order.indexOf(unit);
        var arr = order.slice(n, order.length);

        for (var i = 0; i < arr.length; i++) {
          var want = tmp[arr[i]]();
          s[arr[i]](want);
        }

        return s;
      };

      var set = {
        milliseconds: function milliseconds(s, n) {
          n = validate(n);
          var current = s.millisecond();
          var diff = current - n; //milliseconds to shift by

          return s.epoch - diff;
        },
        seconds: function seconds(s, n) {
          n = validate(n);
          var diff = s.second() - n;
          var shift = diff * milliseconds.second;
          return s.epoch - shift;
        },
        minutes: function minutes(s, n) {
          n = validate(n);
          var old = s.clone();
          var diff = s.minute() - n;
          var shift = diff * milliseconds.minute;
          s.epoch -= shift; // check against a screw-up
          // if (old.hour() != s.hour()) {
          //   walkTo(old, {
          //     minute: n
          //   })
          //   return old.epoch
          // }

          confirm(s, old, 'second');
          return s.epoch;
        },
        hours: function hours(s, n) {
          n = validate(n);

          if (n >= 24) {
            n = 24;
          } else if (n < 0) {
            n = 0;
          }

          var old = s.clone();
          var diff = s.hour() - n;
          var shift = diff * milliseconds.hour;
          s.epoch -= shift; // oops, did we change the day?

          if (s.date() !== old.date()) {
            s = old.clone();

            if (diff > 1) {
              diff -= 1;
            }

            if (diff < 1) {
              diff += 1;
            }

            shift = diff * milliseconds.hour;
            s.epoch -= shift;
          }

          walk_1(s, {
            hour: n
          });
          confirm(s, old, 'minute');
          return s.epoch;
        },
        //support setting time by '4:25pm' - this isn't very-well developed..
        time: function time(s, str) {
          var m = str.match(/([0-9]{1,2})[:h]([0-9]{1,2})(:[0-9]{1,2})? ?(am|pm)?/);

          if (!m) {
            //fallback to support just '2am'
            m = str.match(/([0-9]{1,2}) ?(am|pm)/);

            if (!m) {
              return s.epoch;
            }

            m.splice(2, 0, '0'); //add implicit 0 minutes

            m.splice(3, 0, ''); //add implicit seconds
          }

          var h24 = false;
          var hour = parseInt(m[1], 10);
          var minute = parseInt(m[2], 10);

          if (hour > 12) {
            h24 = true;
          } //make the hour into proper 24h time


          if (h24 === false) {
            if (m[4] === 'am' && hour === 12) {
              //12am is midnight
              hour = 0;
            }

            if (m[4] === 'pm' && hour < 12) {
              //12pm is noon
              hour += 12;
            }
          } // handle seconds


          m[3] = m[3] || '';
          m[3] = m[3].replace(/:/, '');
          var sec = parseInt(m[3], 10) || 0;
          s = s.hour(hour);
          s = s.minute(minute);
          s = s.second(sec);
          s = s.millisecond(0);
          return s.epoch;
        },
        date: function date(s, n) {
          n = validate(n); //avoid setting february 31st

          if (n > 28) {
            var month = s.month();
            var max = monthLengths_1[month]; // support leap day in february

            if (month === 1 && n === 29 && isLeapYear$1(s.year())) {
              max = 29;
            }

            if (n > max) {
              n = max;
            }
          } //avoid setting < 0


          if (n <= 0) {
            n = 1;
          }

          walk_1(s, {
            date: n
          });
          return s.epoch;
        },
        //this one's tricky
        month: function month(s, n) {
          if (typeof n === 'string') {
            n = months.mapping()[n.toLowerCase()];
          }

          n = validate(n); //don't go past december

          if (n >= 12) {
            n = 11;
          }

          if (n <= 0) {
            n = 0;
          }

          var date = s.date(); //there's no 30th of february, etc.

          if (date > monthLengths_1[n]) {
            //make it as close as we can..
            date = monthLengths_1[n];
          }

          walk_1(s, {
            month: n,
            date: date
          });
          return s.epoch;
        },
        year: function year(s, n) {
          // support '97
          if (typeof n === 'string' && /^'[0-9]{2}$/.test(n)) {
            n = n.replace(/'/, '').trim();
            n = Number(n); // '89 is 1989

            if (n > 30) {
              //change this in 10y
              n = 1900 + n;
            } else {
              // '12 is 2012
              n = 2000 + n;
            }
          }

          n = validate(n);
          walk_1(s, {
            year: n
          });
          return s.epoch;
        },
        dayOfYear: function dayOfYear(s, n) {
          n = validate(n);
          var old = s.clone();
          n -= 1; //days are 1-based

          if (n <= 0) {
            n = 0;
          } else if (n >= 365) {
            n = 364;
          }

          s = s.startOf('year');
          s = s.add(n, 'day');
          confirm(s, old, 'hour');
          return s.epoch;
        }
      };
      var methods$1 = {
        millisecond: function millisecond(num) {
          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.milliseconds(s, num);
            return s;
          }

          return this.d.getMilliseconds();
        },
        second: function second(num) {
          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.seconds(s, num);
            return s;
          }

          return this.d.getSeconds();
        },
        minute: function minute(num) {
          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.minutes(s, num);
            return s;
          }

          return this.d.getMinutes();
        },
        hour: function hour(num) {
          var d = this.d;

          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.hours(s, num);
            return s;
          }

          return d.getHours();
        },
        //'3:30' is 3.5
        hourFloat: function hourFloat(num) {
          if (num !== undefined) {
            var s = this.clone();

            var _minute = num % 1;

            _minute = _minute * 60;

            var _hour = parseInt(num, 10);

            s.epoch = set.hours(s, _hour);
            s.epoch = set.minutes(s, _minute);
            return s;
          }

          var d = this.d;
          var hour = d.getHours();
          var minute = d.getMinutes();
          minute = minute / 60;
          return hour + minute;
        },
        // hour in 12h format
        hour12: function hour12(str) {
          var d = this.d;

          if (str !== undefined) {
            var s = this.clone();
            str = '' + str;
            var m = str.match(/^([0-9]+)(am|pm)$/);

            if (m) {
              var hour = parseInt(m[1], 10);

              if (m[2] === 'pm') {
                hour += 12;
              }

              s.epoch = set.hours(s, hour);
            }

            return s;
          } //get the hour


          var hour12 = d.getHours();

          if (hour12 > 12) {
            hour12 = hour12 - 12;
          }

          if (hour12 === 0) {
            hour12 = 12;
          }

          return hour12;
        },
        //some ambiguity here with 12/24h
        time: function time(str) {
          if (str !== undefined) {
            var s = this.clone();
            str = str.toLowerCase().trim();
            s.epoch = set.time(s, str);
            return s;
          }

          return "".concat(this.h12(), ":").concat(fns.zeroPad(this.minute())).concat(this.ampm());
        },
        // either 'am' or 'pm'
        ampm: function ampm(input) {
          var which = 'am';
          var hour = this.hour();

          if (hour >= 12) {
            which = 'pm';
          }

          if (typeof input !== 'string') {
            return which;
          } //okay, we're doing a setter


          var s = this.clone();
          input = input.toLowerCase().trim(); //ampm should never change the day
          // - so use `.hour(n)` instead of `.minus(12,'hour')`

          if (hour >= 12 && input === 'am') {
            //noon is 12pm
            hour -= 12;
            return s.hour(hour);
          }

          if (hour < 12 && input === 'pm') {
            hour += 12;
            return s.hour(hour);
          }

          return s;
        },
        //some hard-coded times of day, like 'noon'
        dayTime: function dayTime(str) {
          if (str !== undefined) {
            var times = {
              morning: '7:00am',
              breakfast: '7:00am',
              noon: '12:00am',
              lunch: '12:00pm',
              afternoon: '2:00pm',
              evening: '6:00pm',
              dinner: '6:00pm',
              night: '11:00pm',
              midnight: '23:59pm'
            };
            var s = this.clone();
            str = str || '';
            str = str.toLowerCase();

            if (times.hasOwnProperty(str) === true) {
              s = s.time(times[str]);
            }

            return s;
          }

          var h = this.hour();

          if (h < 6) {
            return 'night';
          }

          if (h < 12) {
            //until noon
            return 'morning';
          }

          if (h < 17) {
            //until 5pm
            return 'afternoon';
          }

          if (h < 22) {
            //until 10pm
            return 'evening';
          }

          return 'night';
        },
        //parse a proper iso string
        iso: function iso(num) {
          if (num !== undefined) {
            return this.set(num);
          }

          return this.format('iso');
        }
      };
      var _01Time = methods$1;
      var methods$2 = {
        // # day in the month
        date: function date(num) {
          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.date(s, num);
            return s;
          }

          return this.d.getDate();
        },
        //like 'wednesday' (hard!)
        day: function day(input) {
          if (input === undefined) {
            return this.d.getDay();
          }

          var original = this.clone();
          var want = input; // accept 'wednesday'

          if (typeof input === 'string') {
            input = input.toLowerCase();

            if (days.aliases.hasOwnProperty(input)) {
              want = days.aliases[input];
            } else {
              want = days["short"]().indexOf(input);

              if (want === -1) {
                want = days["long"]().indexOf(input);
              }
            }
          } //move approx


          var day = this.d.getDay();
          var diff = day - want;
          var s = this.subtract(diff, 'days'); //tighten it back up

          walk_1(s, {
            hour: original.hour(),
            minute: original.minute(),
            second: original.second()
          });
          return s;
        },
        //these are helpful name-wrappers
        dayName: function dayName(input) {
          if (input === undefined) {
            return days["long"]()[this.day()];
          }

          var s = this.clone();
          s = s.day(input);
          return s;
        },
        //either name or number
        month: function month(input) {
          if (input !== undefined) {
            var s = this.clone();
            s.epoch = set.month(s, input);
            return s;
          }

          return this.d.getMonth();
        }
      };
      var _02Date = methods$2;

      var clearMinutes = function clearMinutes(s) {
        s = s.minute(0);
        s = s.second(0);
        s = s.millisecond(1);
        return s;
      };

      var methods$3 = {
        // day 0-366
        dayOfYear: function dayOfYear(num) {
          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.dayOfYear(s, num);
            return s;
          } //days since newyears - jan 1st is 1, jan 2nd is 2...


          var sum = 0;
          var month = this.d.getMonth();
          var tmp; //count the num days in each month

          for (var i = 1; i <= month; i++) {
            tmp = new Date();
            tmp.setDate(1);
            tmp.setFullYear(this.d.getFullYear()); //the year matters, because leap-years

            tmp.setHours(1);
            tmp.setMinutes(1);
            tmp.setMonth(i);
            tmp.setHours(-2); //the last day of the month

            sum += tmp.getDate();
          }

          return sum + this.d.getDate();
        },
        //since the start of the year
        week: function week(num) {
          // week-setter
          if (num !== undefined) {
            var s = this.clone();
            s = s.month(0);
            s = s.date(1);
            s = s.day('monday');
            s = clearMinutes(s); //first week starts first Thurs in Jan
            // so mon dec 28th is 1st week
            // so mon dec 29th is not the week

            if (s.monthName() === 'december' && s.date() >= 28) {
              s = s.add(1, 'week');
            }

            num -= 1; //1-based

            s = s.add(num, 'weeks');
            return s;
          } //find-out which week it is


          var tmp = this.clone();
          tmp = tmp.month(0);
          tmp = tmp.date(1);
          tmp = clearMinutes(tmp);
          tmp = tmp.day('monday'); //don't go into last-year

          if (tmp.monthName() === 'december' && tmp.date() >= 28) {
            tmp = tmp.add(1, 'week');
          } // is first monday the 1st?


          var toAdd = 1;

          if (tmp.date() === 1) {
            toAdd = 0;
          }

          tmp = tmp.minus(1, 'second');
          var thisOne = this.epoch; //if the week technically hasn't started yet

          if (tmp.epoch > thisOne) {
            return 1;
          } //speed it up, if we can


          var i = 0;
          var skipWeeks = this.month() * 4;
          tmp.epoch += milliseconds.week * skipWeeks;
          i += skipWeeks;

          for (; i < 52; i++) {
            if (tmp.epoch > thisOne) {
              return i + toAdd;
            }

            tmp = tmp.add(1, 'week');
          }

          return 52;
        },
        //'january'
        monthName: function monthName(input) {
          if (input === undefined) {
            return months["long"]()[this.month()];
          }

          var s = this.clone();
          s = s.month(input);
          return s;
        },
        //q1, q2, q3, q4
        quarter: function quarter(num) {
          if (num !== undefined) {
            if (typeof num === 'string') {
              num = num.replace(/^q/i, '');
              num = parseInt(num, 10);
            }

            if (quarters[num]) {
              var s = this.clone();
              var _month = quarters[num][0];
              s = s.month(_month);
              s = s.date(1);
              s = s.startOf('day');
              return s;
            }
          }

          var month = this.d.getMonth();

          for (var i = 1; i < quarters.length; i++) {
            if (month < quarters[i][0]) {
              return i - 1;
            }
          }

          return 4;
        },
        //spring, summer, winter, fall
        season: function season(input) {
          var hem = 'north';

          if (this.hemisphere() === 'South') {
            hem = 'south';
          }

          if (input !== undefined) {
            var s = this.clone();

            for (var i = 0; i < seasons[hem].length; i++) {
              if (input === seasons[hem][i][0]) {
                s = s.month(seasons[hem][i][1]);
                s = s.date(1);
                s = s.startOf('day');
              }
            }

            return s;
          }

          var month = this.d.getMonth();

          for (var _i = 0; _i < seasons[hem].length - 1; _i++) {
            if (month >= seasons[hem][_i][1] && month < seasons[hem][_i + 1][1]) {
              return seasons[hem][_i][0];
            }
          }

          return 'winter';
        },
        //the year number
        year: function year(num) {
          if (num !== undefined) {
            var s = this.clone();
            s.epoch = set.year(s, num);
            return s;
          }

          return this.d.getFullYear();
        },
        //bc/ad years
        era: function era(str) {
          if (str !== undefined) {
            var s = this.clone();
            str = str.toLowerCase(); //TODO: there is no year-0AD i think. may have off-by-1 error here

            var year = s.d.getFullYear(); //make '1992' into 1992bc..

            if (str === 'bc' && year > 0) {
              s.epoch = set.year(s, year * -1);
            } //make '1992bc' into '1992'


            if (str === 'ad' && year < 0) {
              s.epoch = set.year(s, year * -1);
            }

            return s;
          }

          if (this.d.getFullYear() < 0) {
            return 'BC';
          }

          return 'AD';
        },
        // 2019 -> 2010
        decade: function decade(input) {
          if (input !== undefined) {
            input = String(input);
            input = input.replace(/([0-9])'?s$/, '$1'); //1950's

            input = input.replace(/([0-9])(th|rd|st|nd)/, '$1'); //fix ordinals

            if (!input) {
              console.warn('Spacetime: Invalid decade input');
              return this;
            } // assume 20th century?? for '70s'.


            if (input.length === 2 && /[0-9][0-9]/.test(input)) {
              input = '19' + input;
            }

            var year = Number(input);

            if (isNaN(year)) {
              return this;
            } // round it down to the decade


            year = Math.floor(year / 10) * 10;
            return this.year(year); //.startOf('decade')
          }

          return this.startOf('decade').year();
        },
        // 1950 -> 19+1
        century: function century(input) {
          if (input !== undefined) {
            if (typeof input === 'string') {
              input = input.replace(/([0-9])(th|rd|st|nd)/, '$1'); //fix ordinals

              input = input.replace(/([0-9]+) ?(b\.?c\.?|a\.?d\.?)/i, function (a, b, c) {
                if (c.match(/b\.?c\.?/i)) {
                  b = '-' + b;
                }

                return b;
              });
              input = input.replace(/c$/, ''); //20thC
            }

            var year = Number(input);

            if (isNaN(input)) {
              console.warn('Spacetime: Invalid century input');
              return this;
            } // there is no century 0


            if (year === 0) {
              year = 1;
            }

            if (year >= 0) {
              year = (year - 1) * 100;
            } else {
              year = (year + 1) * 100;
            }

            return this.year(year);
          } // century getter


          var num = this.startOf('century').year();
          num = Math.floor(num / 100);

          if (num < 0) {
            return num - 1;
          }

          return num + 1;
        },
        // 2019 -> 2+1
        millenium: function millenium(input) {
          if (input !== undefined) {
            if (typeof input === 'string') {
              input = input.replace(/([0-9])(th|rd|st|nd)/, '$1'); //fix ordinals

              input = Number(input);

              if (isNaN(input)) {
                console.warn('Spacetime: Invalid millenium input');
                return this;
              }
            }

            if (input > 0) {
              input -= 1;
            }

            var year = input * 1000; // there is no year 0

            if (year === 0) {
              year = 1;
            }

            return this.year(year);
          } // get the current millenium


          var num = Math.floor(this.year() / 1000);

          if (num >= 0) {
            num += 1;
          }

          return num;
        }
      };
      var _03Year = methods$3;
      var methods$4 = Object.assign({}, _01Time, _02Date, _03Year); //aliases

      methods$4.milliseconds = methods$4.millisecond;
      methods$4.seconds = methods$4.second;
      methods$4.minutes = methods$4.minute;
      methods$4.hours = methods$4.hour;
      methods$4.hour24 = methods$4.hour;
      methods$4.h12 = methods$4.hour12;
      methods$4.h24 = methods$4.hour24;
      methods$4.days = methods$4.day;

      var addMethods = function addMethods(Space) {
        //hook the methods into prototype
        Object.keys(methods$4).forEach(function (k) {
          Space.prototype[k] = methods$4[k];
        });
      };

      var query = addMethods;
      var isLeapYear$2 = fns.isLeapYear;

      var getMonthLength = function getMonthLength(month, year) {
        if (month === 1 && isLeapYear$2(year)) {
          return 29;
        }

        return monthLengths_1[month];
      }; //month is the one thing we 'model/compute'
      //- because ms-shifting can be off by enough


      var rollMonth = function rollMonth(want, old) {
        //increment year
        if (want.month > 0) {
          var years = parseInt(want.month / 12, 10);
          want.year = old.year() + years;
          want.month = want.month % 12;
        } else if (want.month < 0) {
          //decrement year
          var _years = Math.floor(Math.abs(want.month) / 13, 10);

          _years = Math.abs(_years) + 1;
          want.year = old.year() - _years; //ignore extras

          want.month = want.month % 12;
          want.month = want.month + 12;

          if (want.month === 12) {
            want.month = 0;
          }
        }

        return want;
      }; // briefly support day=-2 (this does not need to be perfect.)


      var rollDaysDown = function rollDaysDown(want, old, sum) {
        want.year = old.year();
        want.month = old.month();
        var date = old.date();
        want.date = date - Math.abs(sum);

        while (want.date < 1) {
          want.month -= 1;

          if (want.month < 0) {
            want.month = 11;
            want.year -= 1;
          }

          var max = getMonthLength(want.month, want.year);
          want.date += max;
        }

        return want;
      }; // briefly support day=33 (this does not need to be perfect.)


      var rollDaysUp = function rollDaysUp(want, old, sum) {
        var year = old.year();
        var month = old.month();
        var max = getMonthLength(month, year);

        while (sum > max) {
          sum -= max;
          month += 1;

          if (month >= 12) {
            month -= 12;
            year += 1;
          }

          max = getMonthLength(month, year);
        }

        want.month = month;
        want.date = sum;
        return want;
      };

      var _model = {
        months: rollMonth,
        days: rollDaysUp,
        daysBack: rollDaysDown
      }; // but briefly:
      // millisecond-math, and some post-processing covers most-things
      // we 'model' the calendar here only a little bit
      // and that usually works-out...

      var order$1 = ['millisecond', 'second', 'minute', 'hour', 'date', 'month'];
      var keep = {
        second: order$1.slice(0, 1),
        minute: order$1.slice(0, 2),
        quarterhour: order$1.slice(0, 2),
        hour: order$1.slice(0, 3),
        date: order$1.slice(0, 4),
        month: order$1.slice(0, 4),
        quarter: order$1.slice(0, 4),
        season: order$1.slice(0, 4),
        year: order$1,
        decade: order$1,
        century: order$1
      };
      keep.week = keep.hour;
      keep.season = keep.date;
      keep.quarter = keep.date; // Units need to be dst adjuested

      var dstAwareUnits = {
        year: true,
        quarter: true,
        season: true,
        month: true,
        week: true,
        day: true
      };
      var keepDate = {
        month: true,
        quarter: true,
        season: true,
        year: true
      };

      var addMethods$1 = function addMethods(SpaceTime) {
        SpaceTime.prototype.add = function (num, unit) {
          var s = this.clone();

          if (!unit || num === 0) {
            return s; //don't bother
          }

          var old = this.clone();
          unit = fns.normalize(unit); // support 'fortnight' alias

          if (unit === 'fortnight') {
            num *= 2;
            unit = 'week';
          } //move forward by the estimated milliseconds (rough)


          if (milliseconds[unit]) {
            s.epoch += milliseconds[unit] * num;
          } else if (unit === 'week') {
            s.epoch += milliseconds.day * (num * 7);
          } else if (unit === 'quarter' || unit === 'season') {
            s.epoch += milliseconds.month * (num * 3.1); //go a little too-far
          } else if (unit === 'quarterhour') {
            s.epoch += milliseconds.minute * 15 * num;
          } //now ensure our milliseconds/etc are in-line


          var want = {};

          if (keep[unit]) {
            keep[unit].forEach(function (u) {
              want[u] = old[u]();
            });
          }

          if (dstAwareUnits[unit]) {
            var diff = old.timezone().current.offset - s.timezone().current.offset;
            s.epoch += diff * 3600 * 1000;
          } //ensure month/year has ticked-over


          if (unit === 'month') {
            want.month = old.month() + num; //month is the one unit we 'model' directly

            want = _model.months(want, old);
          } //support coercing a week, too


          if (unit === 'week') {
            var sum = old.date() + num * 7;

            if (sum <= 28 && sum > 1) {
              want.date = sum;
            }
          } //support 25-hour day-changes on dst-changes
          else if (unit === 'date') {
              if (num < 0) {
                want = _model.daysBack(want, old, num);
              } else {
                //specify a naive date number, if it's easy to do...
                var _sum = old.date() + num; // ok, model this one too


                want = _model.days(want, old, _sum);
              } //manually punt it if we haven't moved at all..


              if (num !== 0 && old.isSame(s, 'day')) {
                want.date = old.date() + num;
              }
            } //ensure year has changed (leap-years)
            else if (unit === 'year') {
                var wantYear = old.year() + num;
                var haveYear = s.year();

                if (haveYear < wantYear) {
                  s.epoch += milliseconds.day;
                } else if (haveYear > wantYear) {
                  s.epoch += milliseconds.day;
                }
              } //these are easier
              else if (unit === 'decade') {
                  want.year = s.year() + 10;
                } else if (unit === 'century') {
                  want.year = s.year() + 100;
                } //keep current date, unless the month doesn't have it.


          if (keepDate[unit]) {
            var max = monthLengths_1[want.month];
            want.date = old.date();

            if (want.date > max) {
              want.date = max;
            }
          }

          walk_1(s, want);
          return s;
        }; //subtract is only add *-1


        SpaceTime.prototype.subtract = function (num, unit) {
          var s = this.clone();
          return s.add(num * -1, unit);
        }; //add aliases


        SpaceTime.prototype.minus = SpaceTime.prototype.subtract;
        SpaceTime.prototype.plus = SpaceTime.prototype.add;
      };

      var add = addMethods$1; //make a string, for easy comparison between dates

      var print = {
        millisecond: function millisecond(s) {
          return s.epoch;
        },
        second: function second(s) {
          return [s.year(), s.month(), s.date(), s.hour(), s.minute(), s.second()].join('-');
        },
        minute: function minute(s) {
          return [s.year(), s.month(), s.date(), s.hour(), s.minute()].join('-');
        },
        hour: function hour(s) {
          return [s.year(), s.month(), s.date(), s.hour()].join('-');
        },
        day: function day(s) {
          return [s.year(), s.month(), s.date()].join('-');
        },
        week: function week(s) {
          return [s.year(), s.week()].join('-');
        },
        month: function month(s) {
          return [s.year(), s.month()].join('-');
        },
        quarter: function quarter(s) {
          return [s.year(), s.quarter()].join('-');
        },
        year: function year(s) {
          return s.year();
        }
      };
      print.date = print.day;

      var addMethods$2 = function addMethods(SpaceTime) {
        SpaceTime.prototype.isSame = function (b, unit) {
          var tzAware = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var a = this;

          if (!unit) {
            return null;
          }

          if (typeof b === 'string' || typeof b === 'number') {
            b = new SpaceTime(b, this.timezone.name);
          } //support 'seconds' aswell as 'second'


          unit = unit.replace(/s$/, ''); // make them the same timezone for proper comparison

          if (tzAware === true && a.tz !== b.tz) {
            b = b.clone();
            b.tz = a.tz;
          }

          if (print[unit]) {
            return print[unit](a) === print[unit](b);
          }

          return null;
        };
      };

      var same = addMethods$2;

      var addMethods$3 = function addMethods(SpaceTime) {
        var methods = {
          isAfter: function isAfter(d) {
            d = fns.beADate(d, this);
            var epoch = fns.getEpoch(d);

            if (epoch === null) {
              return null;
            }

            return this.epoch > epoch;
          },
          isBefore: function isBefore(d) {
            d = fns.beADate(d, this);
            var epoch = fns.getEpoch(d);

            if (epoch === null) {
              return null;
            }

            return this.epoch < epoch;
          },
          isEqual: function isEqual(d) {
            d = fns.beADate(d, this);
            var epoch = fns.getEpoch(d);

            if (epoch === null) {
              return null;
            }

            return this.epoch === epoch;
          },
          isBetween: function isBetween(start, end) {
            var isInclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            start = fns.beADate(start, this);
            end = fns.beADate(end, this);
            var startEpoch = fns.getEpoch(start);

            if (startEpoch === null) {
              return null;
            }

            var endEpoch = fns.getEpoch(end);

            if (endEpoch === null) {
              return null;
            }

            if (isInclusive) {
              return this.isBetween(start, end) || this.isEqual(start) || this.isEqual(end);
            }

            return startEpoch < this.epoch && this.epoch < endEpoch;
          }
        }; //hook them into proto

        Object.keys(methods).forEach(function (k) {
          SpaceTime.prototype[k] = methods[k];
        });
      };

      var compare = addMethods$3;

      var addMethods$4 = function addMethods(SpaceTime) {
        var methods = {
          i18n: function i18n(data) {
            //change the day names
            if (fns.isObject(data.days)) {
              days.set(data.days);
            } //change the month names


            if (fns.isObject(data.months)) {
              months.set(data.months);
            } // change the the display style of the month / day names


            if (fns.isBoolean(data.useTitleCase)) {
              caseFormat.set(data.useTitleCase);
            }
          }
        }; //hook them into proto

        Object.keys(methods).forEach(function (k) {
          SpaceTime.prototype[k] = methods[k];
        });
      };

      var i18n = addMethods$4;
      var timezones = unpack; //fake timezone-support, for fakers (es5 class)

      var SpaceTime = function SpaceTime(input$1, tz) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; //the holy moment

        this.epoch = null; //the shift for the given timezone

        this.tz = find(tz, timezones); //whether to output warnings to console

        this.silent = options.silent || true; // favour british interpretation of 02/02/2018, etc

        this.british = options.dmy || options.british; //does the week start on sunday, or monday:

        this._weekStart = 1; //default to monday

        if (options.weekStart !== undefined) {
          this._weekStart = options.weekStart;
        } // the reference today date object, (for testing)


        this._today = {};

        if (options.today !== undefined) {
          this._today = options.today;
        } //add getter/setters


        Object.defineProperty(this, 'd', {
          //return a js date object
          get: function get() {
            var offset = quick(this); //every computer is somewhere- get this computer's built-in offset

            var bias = new Date(this.epoch).getTimezoneOffset() || 0; //movement

            var shift = bias + offset * 60; //in minutes

            shift = shift * 60 * 1000; //in ms
            //remove this computer's offset

            var epoch = this.epoch + shift;
            var d = new Date(epoch);
            return d;
          }
        }); //add this data on the object, to allow adding new timezones

        Object.defineProperty(this, 'timezones', {
          get: function get() {
            return timezones;
          },
          set: function set(obj) {
            timezones = obj;
            return obj;
          }
        }); //parse the various formats

        var tmp = input(this, input$1, tz);
        this.epoch = tmp.epoch;
      }; //(add instance methods to prototype)


      Object.keys(methods_1).forEach(function (k) {
        SpaceTime.prototype[k] = methods_1[k];
      }); // \_()_/

      SpaceTime.prototype.clone = function () {
        return new SpaceTime(this.epoch, this.tz, {
          silent: this.silent,
          weekStart: this._weekStart,
          today: this._today
        });
      }; //return native date object at the same epoch


      SpaceTime.prototype.toLocalDate = function () {
        return new Date(this.epoch);
      }; //append more methods


      query(SpaceTime);
      add(SpaceTime);
      same(SpaceTime);
      compare(SpaceTime);
      i18n(SpaceTime);
      var spacetime = SpaceTime;

      var whereIts = function whereIts(a, b) {
        var start = new spacetime(null);
        var end = new spacetime(null);
        start = start.time(a); //if b is undefined, use as 'within one hour'

        if (b) {
          end = end.time(b);
        } else {
          end = start.add(59, 'minutes');
        }

        var startHour = start.hour();
        var endHour = end.hour();
        var tzs = Object.keys(start.timezones).filter(function (tz) {
          if (tz.indexOf('/') === -1) {
            return false;
          }

          var m = new spacetime(null, tz);
          var hour = m.hour(); //do 'calendar-compare' not real-time-compare

          if (hour >= startHour && hour <= endHour) {
            //test minutes too, if applicable
            if (hour === startHour && m.minute() < start.minute()) {
              return false;
            }

            if (hour === endHour && m.minute() > end.minute()) {
              return false;
            }

            return true;
          }

          return false;
        });
        return tzs;
      };

      var whereIts_1 = whereIts;
      var _version = '6.12.2';

      var main$1 = function main(input, tz, options) {
        return new spacetime(input, tz, options);
      }; // set all properties of a given 'today' object


      var setToday = function setToday(s) {
        var today = s._today || {};
        Object.keys(today).forEach(function (k) {
          s = s[k](today[k]);
        });
        return s;
      }; //some helper functions on the main method


      main$1.now = function (tz, options) {
        var s = new spacetime(new Date().getTime(), tz, options);
        s = setToday(s);
        return s;
      };

      main$1.today = function (tz, options) {
        var s = new spacetime(new Date().getTime(), tz, options);
        s = setToday(s);
        return s.startOf('day');
      };

      main$1.tomorrow = function (tz, options) {
        var s = new spacetime(new Date().getTime(), tz, options);
        s = setToday(s);
        return s.add(1, 'day').startOf('day');
      };

      main$1.yesterday = function (tz, options) {
        var s = new spacetime(new Date().getTime(), tz, options);
        s = setToday(s);
        return s.subtract(1, 'day').startOf('day');
      };

      main$1.extend = function (obj) {
        Object.keys(obj).forEach(function (k) {
          spacetime.prototype[k] = obj[k];
        });
        return this;
      }; //find tz by time


      main$1.whereIts = whereIts_1;
      main$1.version = _version; //aliases:

      main$1.plugin = main$1.extend;
      var src = main$1;
      return src;
    });
  });

  // these timezone abbreviations are wholly made-up by me, Spencer Kelly, with no expertise in geography
  // generated humbly from https://github.com/spencermountain/spacetime-informal

  var america = 'America/';
  var asia = 'Asia/';
  var europe = 'Europe/';
  var africa = 'Africa/';
  var aus = 'Australia/';
  var pac = 'Pacific/';
  var informal = {
    //europe
    'british summer time': europe + 'London',
    bst: europe + 'London',
    'british time': europe + 'London',
    'britain time': europe + 'London',
    'irish summer time': europe + 'Dublin',
    'irish time': europe + 'Dublin',
    ireland: europe + 'Dublin',
    'central european time': europe + 'Berlin',
    cet: europe + 'Berlin',
    'central european summer time': europe + 'Berlin',
    cest: europe + 'Berlin',
    'central europe': europe + 'Berlin',
    'eastern european time': europe + 'Riga',
    eet: europe + 'Riga',
    'eastern european summer time': europe + 'Riga',
    eest: europe + 'Riga',
    'eastern europe time': europe + 'Riga',
    'western european time': europe + 'Lisbon',
    // wet: europe+'Lisbon',
    'western european summer time': europe + 'Lisbon',
    // west: europe+'Lisbon',
    'western europe': europe + 'Lisbon',
    'turkey standard time': europe + 'Istanbul',
    trt: europe + 'Istanbul',
    'turkish time': europe + 'Istanbul',
    //africa
    etc: africa + 'Freetown',
    utc: africa + 'Freetown',
    'greenwich standard time': africa + 'Freetown',
    gmt: africa + 'Freetown',
    'east africa time': africa + 'Nairobi',
    // eat: africa+'Nairobi',
    'east african time': africa + 'Nairobi',
    'eastern africa time': africa + 'Nairobi',
    'central africa time': africa + 'Khartoum',
    // cat: africa+'Khartoum',
    'central african time': africa + 'Khartoum',
    'south africa standard time': africa + 'Johannesburg',
    sast: africa + 'Johannesburg',
    'southern africa': africa + 'Johannesburg',
    'south african': africa + 'Johannesburg',
    'west africa standard time': africa + 'Lagos',
    // wat: africa+'Lagos',
    'western africa time': africa + 'Lagos',
    'west african time': africa + 'Lagos',
    'australian central standard time': aus + 'Adelaide',
    acst: aus + 'Adelaide',
    'australian central daylight time': aus + 'Adelaide',
    acdt: aus + 'Adelaide',
    'australia central': aus + 'Adelaide',
    'australian eastern standard time': aus + 'Brisbane',
    aest: aus + 'Brisbane',
    'australian eastern daylight time': aus + 'Brisbane',
    aedt: aus + 'Brisbane',
    'australia east': aus + 'Brisbane',
    'australian western standard time': aus + 'Perth',
    awst: aus + 'Perth',
    'australian western daylight time': aus + 'Perth',
    awdt: aus + 'Perth',
    'australia west': aus + 'Perth',
    'australian central western standard time': aus + 'Eucla',
    acwst: aus + 'Eucla',
    'australia central west': aus + 'Eucla',
    'lord howe standard time': aus + 'Lord_Howe',
    lhst: aus + 'Lord_Howe',
    'lord howe daylight time': aus + 'Lord_Howe',
    lhdt: aus + 'Lord_Howe',
    'russian standard time': europe + 'Moscow',
    msk: europe + 'Moscow',
    russian: europe + 'Moscow',
    //america
    'central standard time': america + 'Chicago',
    'central time': america + 'Chicago',
    cst: america + 'Havana',
    'central daylight time': america + 'Chicago',
    cdt: america + 'Havana',
    'mountain standard time': america + 'Denver',
    'mountain time': america + 'Denver',
    mst: america + 'Denver',
    'mountain daylight time': america + 'Denver',
    mdt: america + 'Denver',
    'atlantic standard time': america + 'Halifax',
    'atlantic time': america + 'Halifax',
    ast: asia + 'Baghdad',
    'atlantic daylight time': america + 'Halifax',
    adt: america + 'Halifax',
    'eastern standard time': america + 'New_York',
    'eastern time': america + 'New_York',
    est: america + 'New_York',
    'eastern daylight time': america + 'New_York',
    edt: america + 'New_York',
    'pacific time': america + 'Los_Angeles',
    'pacific standard time': america + 'Los_Angeles',
    pst: america + 'Los_Angeles',
    'pacific daylight time': america + 'Los_Angeles',
    pdt: america + 'Los_Angeles',
    'alaskan standard time': america + 'Anchorage',
    'alaskan time': america + 'Anchorage',
    ahst: america + 'Anchorage',
    'alaskan daylight time': america + 'Anchorage',
    ahdt: america + 'Anchorage',
    'hawaiian standard time': pac + 'Honolulu',
    'hawaiian time': pac + 'Honolulu',
    hst: pac + 'Honolulu',
    'aleutian time': pac + 'Honolulu',
    'hawaii time': pac + 'Honolulu',
    'newfoundland standard time': america + 'St_Johns',
    'newfoundland time': america + 'St_Johns',
    nst: america + 'St_Johns',
    'newfoundland daylight time': america + 'St_Johns',
    ndt: america + 'St_Johns',
    'brazil time': america + 'Sao_Paulo',
    brt: america + 'Sao_Paulo',
    braslia: america + 'Sao_Paulo',
    brasilia: america + 'Sao_Paulo',
    'brazilian time': america + 'Sao_Paulo',
    'argentina time': america + 'Buenos_Aires',
    // art: a+'Buenos_Aires',
    'argentinian time': america + 'Buenos_Aires',
    'amazon time': america + 'Manaus',
    amt: america + 'Manaus',
    'amazonian time': america + 'Manaus',
    'easter island standard time': 'Chile/Easterisland',
    east: 'Chile/Easterisland',
    'easter island summer time': 'Chile/Easterisland',
    easst: 'Chile/Easterisland',
    'venezuelan standard time': america + 'Caracas',
    'venezuelan time': america + 'Caracas',
    vet: america + 'Caracas',
    'venezuela time': america + 'Caracas',
    'paraguay time': america + 'Asuncion',
    pyt: america + 'Asuncion',
    'paraguay summer time': america + 'Asuncion',
    pyst: america + 'Asuncion',
    'cuba standard time': america + 'Havana',
    'cuba time': america + 'Havana',
    'cuba daylight time': america + 'Havana',
    'cuban time': america + 'Havana',
    'bolivia time': america + 'La_Paz',
    // bot: a+'La_Paz',
    'bolivian time': america + 'La_Paz',
    'colombia time': america + 'Bogota',
    cot: america + 'Bogota',
    'colombian time': america + 'Bogota',
    'acre time': america + 'Eirunepe',
    // act: a+'Eirunepe',
    'peru time': america + 'Lima',
    // pet: a+'Lima',
    'chile standard time': america + 'Punta_Arenas',
    'chile time': america + 'Punta_Arenas',
    clst: america + 'Punta_Arenas',
    'chile summer time': america + 'Punta_Arenas',
    cldt: america + 'Punta_Arenas',
    'uruguay time': america + 'Montevideo',
    uyt: america + 'Montevideo',
    //asia
    ist: asia + 'Jerusalem',
    'arabic standard time': asia + 'Baghdad',
    'arabic time': asia + 'Baghdad',
    'arab time': asia + 'Baghdad',
    'iran standard time': asia + 'Tehran',
    'iran time': asia + 'Tehran',
    irst: asia + 'Tehran',
    'iran daylight time': asia + 'Tehran',
    irdt: asia + 'Tehran',
    iranian: asia + 'Tehran',
    'pakistan standard time': asia + 'Karachi',
    'pakistan time': asia + 'Karachi',
    pkt: asia + 'Karachi',
    'india standard time': asia + 'Kolkata',
    'indian time': asia + 'Kolkata',
    'indochina time': asia + 'Bangkok',
    ict: asia + 'Bangkok',
    'south east asia': asia + 'Bangkok',
    'china standard time': asia + 'Shanghai',
    ct: asia + 'Shanghai',
    'chinese time': asia + 'Shanghai',
    'alma-ata time': asia + 'Almaty',
    almt: asia + 'Almaty',
    'oral time': asia + 'Oral',
    'orat time': asia + 'Oral',
    'yakutsk time': asia + 'Yakutsk',
    yakt: asia + 'Yakutsk',
    'gulf standard time': asia + 'Dubai',
    'gulf time': asia + 'Dubai',
    gst: asia + 'Dubai',
    uae: asia + 'Dubai',
    'hong kong time': asia + 'Hong_Kong',
    hkt: asia + 'Hong_Kong',
    'western indonesian time': asia + 'Jakarta',
    wib: asia + 'Jakarta',
    'indonesia time': asia + 'Jakarta',
    'central indonesian time': asia + 'Makassar',
    wita: asia + 'Makassar',
    'israel daylight time': asia + 'Jerusalem',
    idt: asia + 'Jerusalem',
    'israel standard time': asia + 'Jerusalem',
    'israel time': asia + 'Jerusalem',
    israeli: asia + 'Jerusalem',
    'krasnoyarsk time': asia + 'Krasnoyarsk',
    krat: asia + 'Krasnoyarsk',
    'malaysia time': asia + 'Kuala_Lumpur',
    myt: asia + 'Kuala_Lumpur',
    'singapore time': asia + 'Singapore',
    sgt: asia + 'Singapore',
    'korea standard time': asia + 'Seoul',
    'korea time': asia + 'Seoul',
    kst: asia + 'Seoul',
    'korean time': asia + 'Seoul',
    'uzbekistan time': asia + 'Samarkand',
    uzt: asia + 'Samarkand',
    'vladivostok time': asia + 'Vladivostok',
    vlat: asia + 'Vladivostok',
    //indian
    'maldives time': 'Indian/Maldives',
    mvt: 'Indian/Maldives',
    'mauritius time': 'Indian/Mauritius',
    mut: 'Indian/Mauritius',
    // pacific
    'marshall islands time': pac + 'Kwajalein',
    mht: pac + 'Kwajalein',
    'samoa standard time': pac + 'Midway',
    sst: pac + 'Midway',
    'somoan time': pac + 'Midway',
    'chamorro standard time': pac + 'Guam',
    chst: pac + 'Guam',
    'papua new guinea time': pac + 'Bougainville',
    pgt: pac + 'Bougainville'
  }; //add the official iana zonefile names

  var iana = spacetime().timezones;
  var formal = Object.keys(iana).reduce(function (h, k) {
    h[k] = k;
    return h;
  }, {});

  var _timezones = Object.assign({}, informal, formal);

  var dates = ['weekday', 'summer', 'winter', 'autumn', 'some day', 'one day', 'all day', 'some point', 'eod', 'eom', 'eoy', 'standard time', 'daylight time', 'tommorrow'];

  var durations = ['centuries', 'century', 'day', 'days', 'decade', 'decades', 'hour', 'hours', 'hr', 'hrs', 'millisecond', 'milliseconds', 'minute', 'minutes', 'min', 'mins', 'month', 'months', 'seconds', 'sec', 'secs', 'week end', 'week ends', 'weekend', 'weekends', 'week', 'weeks', 'wk', 'wks', 'year', 'years', 'yr', 'yrs', 'quarter', 'quarters', 'qtr', 'qtrs', 'season', 'seasons'];

  var holidays = ['all hallows eve', 'all saints day', 'all sts day', 'april fools', 'armistice day', 'australia day', 'bastille day', 'boxing day', 'canada day', 'christmas eve', 'christmas', 'cinco de mayo', 'day of the dead', 'dia de muertos', 'dieciseis de septiembre', 'emancipation day', 'grito de dolores', 'groundhog day', 'halloween', 'harvey milk day', 'inauguration day', 'independence day', 'independents day', 'juneteenth', 'labour day', 'national freedom day', 'national nurses day', 'new years eve', 'new years', 'purple heart day', 'rememberance day', 'rosa parks day', 'saint andrews day', 'saint patricks day', 'saint stephens day', 'saint valentines day', 'st andrews day', 'st patricks day', 'st stephens day', 'st valentines day ', 'valentines day', 'valentines', 'veterans day', 'victoria day', 'womens equality day', 'xmas', // Fixed religious and cultural holidays
  // Catholic + Christian
  'epiphany', 'orthodox christmas day', 'orthodox new year', 'assumption of mary', 'all souls day', 'feast of the immaculate conception', 'feast of our lady of guadalupe', // Kwanzaa
  'kwanzaa', // Pagan / metal 
  'imbolc', 'beltaine', 'lughnassadh', 'samhain', 'martin luther king day', 'mlk day', 'presidents day', 'mardi gras', 'tax day', 'commonwealth day', 'mothers day', 'memorial day', 'fathers day', 'columbus day', 'indigenous peoples day', 'canadian thanksgiving', 'election day', 'thanksgiving', 't-day', 'turkey day', 'black friday', 'cyber monday', // Astronomical religious and cultural holidays
  'ash wednesday', 'palm sunday', 'maundy thursday', 'good friday', 'holy saturday', 'easter', 'easter sunday', 'easter monday', 'orthodox good friday', 'orthodox holy saturday', 'orthodox easter', 'orthodox easter monday', 'ascension day', 'pentecost', 'whitsunday', 'whit sunday', 'whit monday', 'trinity sunday', 'corpus christi', 'advent', // Jewish
  'tu bishvat', 'tu bshevat', 'purim', 'passover', 'yom hashoah', 'lag baomer', 'shavuot', 'tisha bav', 'rosh hashana', 'yom kippur', 'sukkot', 'shmini atzeret', 'simchat torah', 'chanukah', 'hanukkah', // Muslim
  'isra and miraj', 'lailat al-qadr', 'eid al-fitr', 'id al-Fitr', 'eid ul-Fitr', 'ramadan', 'eid al-adha', 'muharram', 'the prophets birthday', 'ostara', 'march equinox', 'vernal equinox', 'litha', 'june solistice', 'summer solistice', 'mabon', 'september equinox', 'fall equinox', 'autumnal equinox', 'yule', 'december solstice', 'winter solstice', // Additional important holidays
  'chinese new year', 'diwali'];

  var times = ['noon', 'midnight', 'now', 'morning', 'tonight', 'evening', 'afternoon', 'night', 'breakfast time', 'lunchtime', 'dinnertime', 'sometime', 'midday', 'eod', 'oclock', 'oclock', 'all day', 'at night'];

  var data = [[dates, '#Date'], [durations, '#Duration'], [holidays, '#Holiday'], [times, '#Time'], [Object.keys(_timezones), '#Timezone']];
  var lex = {
    'a couple': 'Value'
  };
  data.forEach(function (a) {
    for (var i = 0; i < a[0].length; i++) {
      lex[a[0][i]] = a[1];
    }
  });
  var words = lex;

  var knownUnits = {
    second: true,
    minute: true,
    hour: true,
    day: true,
    week: true,
    weekend: true,
    month: true,
    season: true,
    quarter: true,
    year: true
  };
  var aliases = {
    wk: 'week',
    min: 'minute',
    sec: 'second',
    weekend: 'week' //for now...

  };

  var parseUnit = function parseUnit(m) {
    var unit = m.match('#Duration').text('normal');
    unit = unit.replace(/s$/, ''); // support shorthands like 'min'

    if (aliases.hasOwnProperty(unit)) {
      unit = aliases[unit];
    }

    return unit;
  }; //turn '5 weeks before' to {weeks:5}


  var parseShift = function parseShift(doc) {
    var result = {};
    var shift = doc.match('#DateShift+');

    if (shift.found === false) {
      return result;
    } // '5 weeks'


    shift.match('#Cardinal #Duration').forEach(function (ts) {
      var num = ts.match('#Cardinal').text('normal');
      num = parseFloat(num);

      if (num && typeof num === 'number') {
        var unit = parseUnit(ts);

        if (knownUnits[unit] === true) {
          result[unit] = num;
        }
      }
    }); //is it 2 weeks ago?   -2

    if (shift.has('(before|ago|hence|back)$') === true) {
      Object.keys(result).forEach(function (k) {
        return result[k] *= -1;
      });
    }

    shift.remove('#Cardinal #Duration'); // supoprt '1 day after tomorrow'

    var m = shift.match('[<unit>#Duration] [<dir>(after|before)]');

    if (m.found) {
      var unit = m.groups('unit').text('reduced'); // unit = unit.replace(/s$/, '')

      var dir = m.groups('dir').text('reduced');

      if (dir === 'after') {
        result[unit] = 1;
      } else if (dir === 'before') {
        result[unit] = -1;
      }
    } // in half an hour


    m = shift.match('half (a|an) [#Duration]', 0);

    if (m.found) {
      var _unit = parseUnit(m);

      result[_unit] = 0.5;
    } // finally, remove it from our text


    doc.remove('#DateShift');
    return result;
  };

  var _01Shift = parseShift;

  /*
  a 'counter' is a Unit determined after a point
    * first hour of x
    * 7th week in x
    * last year in x
    * 
  unlike a shift, like "2 weeks after x"
  */
  var oneBased = {
    minute: true
  };

  var getCounter = function getCounter(doc) {
    // 7th week of
    var m = doc.match('[<num>#Value] [<unit>#Duration+] (of|in)');

    if (m.found) {
      var obj = m.groups();
      var num = obj.num.text('reduced');
      var unit = obj.unit.text('reduced');
      var found = {
        unit: unit,
        num: Number(num) || 0
      }; // 0-based or 1-based units

      if (!oneBased[unit]) {
        found.num -= 1;
      }

      doc = doc.remove(m);
      return found;
    } // first week of


    m = doc.match('[<dir>(first|initial|last|final)] [<unit>#Duration+] (of|in)');

    if (m.found) {
      var _obj = m.groups();

      var dir = _obj.dir.text('reduced');

      var _unit = _obj.unit.text('reduced');

      if (dir === 'initial') {
        dir = 'first';
      }

      if (dir === 'final') {
        dir = 'last';
      }

      var _found = {
        unit: _unit,
        dir: dir
      };
      doc = doc.remove(m);
      return _found;
    }

    return {};
  };

  var _02Counter = getCounter;

  var hardCoded = {
    daybreak: '7:00am',
    //ergh
    breakfast: '8:00am',
    morning: '9:00am',
    noon: '12:00pm',
    midday: '12:00pm',
    afternoon: '2:00pm',
    lunchtime: '12:00pm',
    evening: '6:00pm',
    dinnertime: '6:00pm',
    night: '8:00pm',
    eod: '10:00pm',
    midnight: '12:00am'
  };

  var halfPast = function halfPast(m, s) {
    var hour = m.match('#Cardinal$').text('reduced');
    var term = m.match('(half|quarter|25|15|10|5)');
    var mins = term.text('reduced');

    if (term.has('half')) {
      mins = '30';
    }

    if (term.has('quarter')) {
      mins = '15';
    }

    var behind = m.has('to'); // apply it

    s = s.hour(hour);
    s = s.startOf('hour'); // assume 'half past 5' is 5pm

    if (hour < 6) {
      s = s.ampm('pm');
    }

    if (behind) {
      s = s.subtract(mins, 'minutes');
    } else {
      s = s.add(mins, 'minutes');
    }

    return s;
  };

  var parseTime = function parseTime(doc, context) {
    var time = doc.match('(at|by|for|before|this)? #Time+');

    if (time.found) {
      doc.remove(time);
    } // get the main part of the time


    time = time.not('^(at|by|for|before|this)');
    time = time.not('sharp');
    time = time.not('on the dot');
    var s = spacetime.now(context.timezone);
    var now = s.clone(); // check for known-times (like 'today')

    var timeStr = time.text('reduced');

    if (hardCoded.hasOwnProperty(timeStr)) {
      return hardCoded[timeStr];
    } // '5 oclock'


    var m = time.match('^#Cardinal oclock (am|pm)?');

    if (m.found) {
      m = m.not('oclock');
      s = s.hour(m.text('reduced'));
      s = s.startOf('hour');

      if (s.isValid() && !s.isEqual(now)) {
        return s.time();
      }
    } // 'quarter to two'


    m = time.match('(half|quarter|25|15|10|5) (past|after|to) #Cardinal');

    if (m.found) {
      s = halfPast(m, s);

      if (s.isValid() && !s.isEqual(now)) {
        return s.time();
      }
    } // '4 in the evening'


    m = time.match('[<time>#Time] (in|at) the? [<desc>(morning|evening|night|nighttime)]');

    if (m.found) {
      var _str = m.groups('time').text('reduced');

      if (/^[0-9]{1,2}$/.test(_str)) {
        s = s.hour(_str); //3 in the morning
      } else {
        s = s.time(_str); // 3:30 in the morning
      }

      if (s.isValid() && !s.isEqual(now)) {
        var desc = m.groups('desc').text('reduced');

        if (desc === 'evening' || desc === 'night') {
          s = s.ampm('pm');
        }

        return s.time();
      }
    } // 'this morning at 4'


    m = time.match('this? [<desc>(morning|evening|tonight)] at [<time>(#Cardinal|#Time)]');

    if (m.found) {
      var g = m.groups();

      var _str2 = g.time.text('reduced');

      if (/^[0-9]{1,2}$/.test(_str2)) {
        s = s.hour(_str2); //3

        s = s.startOf('hour');
      } else {
        s = s.time(_str2); // 3:30
      }

      if (s.isValid() && !s.isEqual(now)) {
        var _desc = g.desc.text('reduced');

        if (_desc === 'morning') {
          s = s.ampm('am');
        }

        if (_desc === 'evening' || _desc === 'tonight') {
          s = s.ampm('pm');
        }

        return s.time();
      }
    } // 'at 4' -> '4'


    m = time.match('^#Cardinal$');

    if (m.found) {
      s = s.hour(m.text('reduced'));
      s = s.startOf('hour');

      if (s.isValid() && !s.isEqual(now)) {
        return s.time();
      }
    } // parse random a time like '4:54pm'


    var str = time.text('reduced');
    s = s.time(str);

    if (s.isValid() && !s.isEqual(now)) {
      return s.time();
    }

    return null;
  };

  var _03Time = parseTime;

  // interpret 'this halloween' or 'next june'
  var parseRelative = function parseRelative(doc) {
    // avoid parsing 'last month of 2019'
    // if (doc.has('^(this|current|next|upcoming|last|previous) #Duration')) {
    //   return null
    // }
    // parse 'this evening'
    // let m = doc.match('^(next|last|this)$')
    // if (m.found) {
    //   doc.remove(m)
    //   return doc.text('reduced')
    // }
    // but avoid parsing 'day after next'
    if (doc.has('(next|last|this)$')) {
      return null;
    }

    var rel = null;
    var m = doc.match('^this? (next|upcoming|coming)');

    if (m.found) {
      rel = 'next';
      doc.remove(m);
    }

    m = doc.match('^this? (last|previous)');

    if (m.found) {
      rel = 'last';
      doc.remove(m);
    }

    m = doc.match('^(this|current)');

    if (m.found) {
      rel = 'this';
      doc.remove(m);
    } // finally, remove it from our text
    // doc.remove('^(this|current|next|upcoming|last|previous)')


    return rel;
  };

  var _04Relative = parseRelative;

  // 'start of october', 'middle of june 1st'
  var parseSection = function parseSection(doc) {
    // start of 2019
    var m = doc.match('[(start|beginning) of] .', 0);

    if (m.found) {
      doc.remove(m);
      return 'start';
    } // end of 2019


    m = doc.match('[end of] .', 0);

    if (m.found) {
      doc.remove(m);
      return 'end';
    } // middle of 2019


    m = doc.match('[(middle|midpoint|center) of] .', 0);

    if (m.found) {
      doc.remove(m);
      return 'middle';
    }

    return null;
  };

  var _05Section = parseSection;

  var isOffset = /(\-?[0-9]+)h(rs)?/i;
  var isNumber = /(\-?[0-9]+)/;
  var utcOffset = /utc([\-+]?[0-9]+)/i;
  var gmtOffset = /gmt([\-+]?[0-9]+)/i;

  var toIana = function toIana(num) {
    num = Number(num);

    if (num > -13 && num < 13) {
      num = num * -1; //it's opposite!

      num = (num > 0 ? '+' : '') + num; //add plus sign

      return 'Etc/GMT' + num;
    }

    return null;
  };

  var parseOffset = function parseOffset(tz) {
    // '+5hrs'
    var m = tz.match(isOffset);

    if (m !== null) {
      return toIana(m[1]);
    } // 'utc+5'


    m = tz.match(utcOffset);

    if (m !== null) {
      return toIana(m[1]);
    } // 'GMT-5' (not opposite)


    m = tz.match(gmtOffset);

    if (m !== null) {
      var num = Number(m[1]) * -1;
      return toIana(num);
    } // '+5'


    m = tz.match(isNumber);

    if (m !== null) {
      return toIana(m[1]);
    }

    return null;
  };

  var parseTimezone = function parseTimezone(doc) {
    var m = doc.match('#Timezone+'); //remove prepositions

    m = m.remove('(in|for|by|near|at)');
    var str = m.text('reduced'); // remove it from our doc, either way

    doc.remove('#Timezone+'); // check our list of informal tz names

    if (_timezones.hasOwnProperty(str)) {
      return _timezones[str];
    }

    var tz = parseOffset(str);

    if (tz) {
      return tz;
    }

    return null;
  };

  var _06Timezone = parseTimezone;

  var Unit = /*#__PURE__*/function () {
    function Unit(input, unit, context, keepTime) {
      _classCallCheck(this, Unit);

      this.unit = unit || 'day';
      context = context || {};
      var today = {};

      if (context.today) {
        today = {
          date: context.today.date(),
          month: context.today.month(),
          year: context.today.year()
        };
      } // set it to the beginning of the given unit


      var d = spacetime(input, context.timezone, {
        today: today
      }); // set to beginning
      // if (d.isValid() && keepTime !== true) {
      //   d = d.startOf(this.unit)
      // }

      Object.defineProperty(this, 'd', {
        enumerable: false,
        writable: true,
        value: d
      });
      Object.defineProperty(this, 'context', {
        enumerable: false,
        writable: true,
        value: context
      });
    } // make a new one


    _createClass(Unit, [{
      key: "clone",
      value: function clone() {
        var d = new Unit(this.d, this.unit, this.context);
        return d;
      }
    }, {
      key: "log",
      value: function log() {
        console.log('--');
        this.d.log();
        console.log('\n');
        return this;
      }
    }, {
      key: "applyShift",
      value: function applyShift() {
        var _this = this;

        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.keys(obj).forEach(function (unit) {
          _this.d = _this.d.add(obj[unit], unit);
        });
        return this;
      }
    }, {
      key: "applyTime",
      value: function applyTime(str) {
        if (str) {
          this.d = this.d.time(str);
        } else {
          this.d = this.d.startOf('day'); //zero-out time
        }

        return this;
      }
    }, {
      key: "applyRel",
      value: function applyRel(rel) {
        if (rel === 'next') {
          return this.next();
        }

        if (rel === 'last') {
          return this.last();
        }

        return this;
      }
    }, {
      key: "applySection",
      value: function applySection(section) {
        if (section === 'start') {
          return this.start();
        }

        if (section === 'end') {
          return this.end();
        }

        if (section === 'middle') {
          return this.middle();
        }

        return this;
      }
    }, {
      key: "format",
      value: function format(fmt) {
        return this.d.format(fmt);
      }
    }, {
      key: "start",
      value: function start() {
        this.d = this.d.startOf(this.unit);
        return this;
      }
    }, {
      key: "end",
      value: function end() {
        this.d = this.d.endOf(this.unit);
        return this;
      }
    }, {
      key: "middle",
      value: function middle() {
        var diff = this.d.diff(this.d.endOf(this.unit));
        var minutes = Math.round(diff.minutes / 2);
        this.d = this.d.add(minutes, 'minutes');
        return this;
      } // the millescond before

    }, {
      key: "before",
      value: function before() {
        this.d = this.d.minus(1, this.unit);
        this.d = this.d.endOf(this.unit);
        return this;
      } // 'after 2019'

    }, {
      key: "after",
      value: function after() {
        this.d = this.d.add(1, this.unit);
        this.d = this.d.startOf(this.unit);
        return this;
      } // tricky: 'next june' 'next tuesday'

    }, {
      key: "next",
      value: function next() {
        this.d = this.d.add(1, this.unit);
        this.d = this.d.startOf(this.unit);
        return this;
      } // tricky: 'last june' 'last tuesday'

    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(1, this.unit);
        this.d = this.d.startOf(this.unit);
        return this;
      }
    }]);

    return Unit;
  }();

  var Unit_1 = Unit;

  var Day = /*#__PURE__*/function (_Unit) {
    _inherits(Day, _Unit);

    var _super = _createSuper(Day);

    function Day(input, unit, context) {
      var _this;

      _classCallCheck(this, Day);

      _this = _super.call(this, input, unit, context);
      _this.unit = 'day';

      if (_this.d.isValid()) {
        _this.d = _this.d.startOf('day');
      }

      return _this;
    }

    return Day;
  }(Unit_1); // like 'feb 2'


  var CalendarDate = /*#__PURE__*/function (_Day) {
    _inherits(CalendarDate, _Day);

    var _super2 = _createSuper(CalendarDate);

    function CalendarDate(input, unit, context) {
      var _this2;

      _classCallCheck(this, CalendarDate);

      _this2 = _super2.call(this, input, unit, context);
      _this2.unit = 'day';

      if (_this2.d.isValid()) {
        _this2.d = _this2.d.startOf('day');
      }

      return _this2;
    }

    _createClass(CalendarDate, [{
      key: "next",
      value: function next() {
        this.d = this.d.add(1, 'year');
        return this;
      }
    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(1, 'year');
        return this;
      }
    }]);

    return CalendarDate;
  }(Day);

  var WeekDay = /*#__PURE__*/function (_Day2) {
    _inherits(WeekDay, _Day2);

    var _super3 = _createSuper(WeekDay);

    function WeekDay(input, unit, context) {
      var _this3;

      _classCallCheck(this, WeekDay);

      _this3 = _super3.call(this, input, unit, context);
      _this3.unit = 'week'; // is the input just a weekday?

      if (typeof input === 'string') {
        _this3.d = spacetime(context.today, context.timezone);
        _this3.d = _this3.d.day(input); // assume a wednesday in the future

        if (_this3.d.isBefore(context.today)) {
          _this3.d = _this3.d.add(7, 'days');
        }
      } else {
        _this3.d = input;
      }

      _this3.weekDay = _this3.d.dayName();

      if (_this3.d.isValid()) {
        _this3.d = _this3.d.startOf('day');
      }

      return _this3;
    }

    _createClass(WeekDay, [{
      key: "clone",
      value: function clone() {
        //overloaded method
        return new WeekDay(this.d, this.unit, this.context);
      }
    }, {
      key: "end",
      value: function end() {
        //overloaded method
        this.d = this.d.endOf('day');
        return this;
      }
    }, {
      key: "next",
      value: function next() {
        this.d = this.d.add(7, 'days');
        this.d = this.d.day(this.weekDay);
        return this;
      }
    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(7, 'days');
        this.d = this.d.day(this.weekDay);
        return this;
      }
    }]);

    return WeekDay;
  }(Day); // like 'haloween'


  var Holiday = /*#__PURE__*/function (_CalendarDate) {
    _inherits(Holiday, _CalendarDate);

    var _super4 = _createSuper(Holiday);

    function Holiday(input, unit, context) {
      var _this4;

      _classCallCheck(this, Holiday);

      _this4 = _super4.call(this, input, unit, context);
      _this4.unit = 'day';

      if (_this4.d.isValid()) {
        _this4.d = _this4.d.startOf('day');
      }

      return _this4;
    }

    return Holiday;
  }(CalendarDate);

  var _day = {
    Day: Day,
    WeekDay: WeekDay,
    CalendarDate: CalendarDate,
    Holiday: Holiday
  };

  var AnyMonth = /*#__PURE__*/function (_Unit) {
    _inherits(AnyMonth, _Unit);

    var _super = _createSuper(AnyMonth);

    function AnyMonth(input, unit, context) {
      var _this;

      _classCallCheck(this, AnyMonth);

      _this = _super.call(this, input, unit, context);
      _this.unit = 'month'; // set to beginning

      if (_this.d.isValid()) {
        _this.d = _this.d.startOf(_this.unit);
      }

      return _this;
    }

    return AnyMonth;
  }(Unit_1); // a specific month, like 'March'


  var Month = /*#__PURE__*/function (_Unit2) {
    _inherits(Month, _Unit2);

    var _super2 = _createSuper(Month);

    function Month(input, unit, context) {
      var _this2;

      _classCallCheck(this, Month);

      _this2 = _super2.call(this, input, unit, context);
      _this2.unit = 'month'; // set to beginning

      if (_this2.d.isValid()) {
        _this2.d = _this2.d.startOf(_this2.unit);
      }

      return _this2;
    }

    _createClass(Month, [{
      key: "next",
      value: function next() {
        this.d = this.d.add(1, 'year');
        this.d = this.d.startOf('month');
        return this;
      }
    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(1, 'year');
        this.d = this.d.startOf('month');
        return this;
      }
    }]);

    return Month;
  }(Unit_1);

  var AnyQuarter = /*#__PURE__*/function (_Unit3) {
    _inherits(AnyQuarter, _Unit3);

    var _super3 = _createSuper(AnyQuarter);

    function AnyQuarter(input, unit, context) {
      var _this3;

      _classCallCheck(this, AnyQuarter);

      _this3 = _super3.call(this, input, unit, context);
      _this3.unit = 'quarter'; // set to beginning

      if (_this3.d.isValid()) {
        _this3.d = _this3.d.startOf(_this3.unit);
      }

      return _this3;
    }

    _createClass(AnyQuarter, [{
      key: "last",
      value: function last() {
        console.log(this.d.format());
        this.d = this.d.minus(1, 'quarter');
        console.log(this.d.format());
        this.d = this.d.startOf(this.unit);
        console.log(this.d.format());
        return this;
      }
    }]);

    return AnyQuarter;
  }(Unit_1);

  var Quarter = /*#__PURE__*/function (_Unit4) {
    _inherits(Quarter, _Unit4);

    var _super4 = _createSuper(Quarter);

    function Quarter(input, unit, context) {
      var _this4;

      _classCallCheck(this, Quarter);

      _this4 = _super4.call(this, input, unit, context);
      _this4.unit = 'quarter'; // set to beginning

      if (_this4.d.isValid()) {
        _this4.d = _this4.d.startOf(_this4.unit);
      }

      return _this4;
    }

    _createClass(Quarter, [{
      key: "next",
      value: function next() {
        this.d = this.d.add(1, 'year');
        this.d = this.d.startOf(this.unit);
        return this;
      }
    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(1, 'year');
        this.d = this.d.startOf(this.unit);
        return this;
      }
    }]);

    return Quarter;
  }(Unit_1);

  var Season = /*#__PURE__*/function (_Unit5) {
    _inherits(Season, _Unit5);

    var _super5 = _createSuper(Season);

    function Season(input, unit, context) {
      var _this5;

      _classCallCheck(this, Season);

      _this5 = _super5.call(this, input, unit, context);
      _this5.unit = 'season'; // set to beginning

      if (_this5.d.isValid()) {
        _this5.d = _this5.d.startOf(_this5.unit);
      }

      return _this5;
    }

    _createClass(Season, [{
      key: "next",
      value: function next() {
        this.d = this.d.add(1, 'year');
        this.d = this.d.startOf(this.unit);
        return this;
      }
    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(1, 'year');
        this.d = this.d.startOf(this.unit);
        return this;
      }
    }]);

    return Season;
  }(Unit_1);

  var Year = /*#__PURE__*/function (_Unit6) {
    _inherits(Year, _Unit6);

    var _super6 = _createSuper(Year);

    function Year(input, unit, context) {
      var _this6;

      _classCallCheck(this, Year);

      _this6 = _super6.call(this, input, unit, context);
      _this6.unit = 'year';

      if (_this6.d.isValid()) {
        _this6.d = _this6.d.startOf('year');
      }

      return _this6;
    }

    return Year;
  }(Unit_1);

  var _year = {
    AnyMonth: AnyMonth,
    Month: Month,
    Quarter: Quarter,
    AnyQuarter: AnyQuarter,
    Season: Season,
    Year: Year
  };

  var Week = /*#__PURE__*/function (_Unit) {
    _inherits(Week, _Unit);

    var _super = _createSuper(Week);

    function Week(input, unit, context) {
      var _this;

      _classCallCheck(this, Week);

      _this = _super.call(this, input, unit, context);
      _this.unit = 'week';

      if (_this.d.isValid()) {
        _this.d = _this.d.startOf('week');
      }

      return _this;
    }

    return Week;
  }(Unit_1); //may need some work


  var WeekEnd = /*#__PURE__*/function (_Unit2) {
    _inherits(WeekEnd, _Unit2);

    var _super2 = _createSuper(WeekEnd);

    function WeekEnd(input, unit, context) {
      var _this2;

      _classCallCheck(this, WeekEnd);

      _this2 = _super2.call(this, input, unit, context);
      _this2.unit = 'week';

      if (_this2.d.isValid()) {
        _this2.d = _this2.d.day('saturday');
        _this2.d = _this2.d.startOf('day');
      }

      return _this2;
    }

    _createClass(WeekEnd, [{
      key: "start",
      value: function start() {
        this.d = this.d.day('saturday').startOf('day');
        return this;
      } // end() {
      //   this.d = this.d.day('sunday').endOf('day')
      //   return this
      // }

    }, {
      key: "next",
      value: function next() {
        this.d = this.d.add(1, this.unit);
        this.d = this.d.startOf('weekend');
        return this;
      }
    }, {
      key: "last",
      value: function last() {
        this.d = this.d.minus(1, this.unit);
        this.d = this.d.startOf('weekend');
        return this;
      }
    }]);

    return WeekEnd;
  }(Unit_1);

  var _week = {
    Week: Week,
    WeekEnd: WeekEnd
  };

  var Hour = /*#__PURE__*/function (_Unit) {
    _inherits(Hour, _Unit);

    var _super = _createSuper(Hour);

    function Hour(input, unit, context) {
      var _this;

      _classCallCheck(this, Hour);

      _this = _super.call(this, input, unit, context, true);
      _this.unit = 'hour';

      if (_this.d.isValid()) {
        _this.d = _this.d.startOf('hour');
      }

      return _this;
    }

    return Hour;
  }(Unit_1);

  var Minute = /*#__PURE__*/function (_Unit2) {
    _inherits(Minute, _Unit2);

    var _super2 = _createSuper(Minute);

    function Minute(input, unit, context) {
      var _this2;

      _classCallCheck(this, Minute);

      _this2 = _super2.call(this, input, unit, context, true);
      _this2.unit = 'minute';

      if (_this2.d.isValid()) {
        _this2.d = _this2.d.startOf('minute');
      }

      return _this2;
    }

    return Minute;
  }(Unit_1);

  var Moment = /*#__PURE__*/function (_Unit3) {
    _inherits(Moment, _Unit3);

    var _super3 = _createSuper(Moment);

    function Moment(input, unit, context) {
      var _this3;

      _classCallCheck(this, Moment);

      _this3 = _super3.call(this, input, unit, context, true);
      _this3.unit = 'millisecond';
      return _this3;
    }

    return Moment;
  }(Unit_1);

  var _time = {
    Hour: Hour,
    Minute: Minute,
    Moment: Moment
  };

  var units = Object.assign({
    Unit: Unit_1
  }, _day, _year, _week, _time);

  var Day$1 = units.Day,
      Moment$1 = units.Moment,
      Hour$1 = units.Hour;
  var knownWord = {
    today: function today(context) {
      return new Day$1(context.today, null, context);
    },
    yesterday: function yesterday(context) {
      return new Day$1(context.today.minus(1, 'day'), null, context);
    },
    tomorrow: function tomorrow(context) {
      return new Day$1(context.today.plus(1, 'day'), null, context);
    },
    eom: function eom(context) {
      var d = context.today.endOf('month');
      d = d.startOf('day');
      return new Day$1(d, null, context);
    },
    // eod: (context) => {
    //   let d = context.today.endOf('day')
    //   d = d.startOf('hour').minus(4, 'hours') //rough
    //   return new Hour(d, null, context)
    // },
    eoy: function eoy(context) {
      var d = context.today.endOf('year');
      d = d.startOf('day');
      return new Day$1(d, null, context);
    }
  };
  knownWord.tommorrow = knownWord.tomorrow;
  knownWord.tmrw = knownWord.tomorrow;

  var today = function today(doc, context, section) {
    var unit = null; // is it empty?

    if (doc.found === false) {
      // do we have just a time?
      if (section.time !== null) {
        unit = new Moment$1(context.today, null, context); // choose today
      } //do we just have a shift?


      if (Object.keys(section.shift).length > 0) {
        if (section.shift.hour || section.shift.minute) {
          unit = new Moment$1(context.today, null, context); // choose now
        } else {
          unit = new Day$1(context.today, null, context); // choose today
        }
      }
    } // today, yesterday, tomorrow


    var str = doc.text('reduced');

    if (knownWord.hasOwnProperty(str) === true) {
      return knownWord[str](context);
    } // day after next


    if (str === 'next' && Object.keys(section.shift).length > 0) {
      return knownWord.tomorrow(context);
    }

    return unit;
  };

  var _01Today = today;

  var spacetimeHoliday = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory(spacetime) ;
    })(commonjsGlobal, function (spacetime) {

      function _interopDefaultLegacy(e) {
        return e && _typeof(e) === 'object' && 'default' in e ? e : {
          'default': e
        };
      }

      var spacetime__default = /*#__PURE__*/_interopDefaultLegacy(spacetime); //yep,


      var jan = 'january';
      var feb = 'february';
      var mar = 'march';
      var apr = 'april';
      var may = 'may';
      var jun = 'june';
      var jul = 'july';
      var aug = 'august';
      var sep = 'september';
      var oct = 'october';
      var nov = 'november';
      var dec = 'december';
      var fixedHolidays = {
        'new years eve': [dec, 31],
        'new years': [jan, 1],
        'new years day': [jan, 1],
        'inauguration day': [jan, 20],
        'australia day': [jan, 26],
        'national freedom day': [feb, 1],
        'groundhog day': [feb, 2],
        'rosa parks day': [feb, 4],
        'valentines day': [feb, 14],
        'saint valentines day': [feb, 14],
        'st valentines day ': [feb, 14],
        'saint patricks day': [mar, 17],
        'st patricks day': [mar, 17],
        'april fools': [apr, 1],
        'april fools day': [apr, 1],
        'emancipation day': [apr, 16],
        'tax day': [apr, 15],
        //US
        'labour day': [may, 1],
        'cinco de mayo': [may, 5],
        'national nurses day': [may, 6],
        'harvey milk day': [may, 22],
        'victoria day': [may, 24],
        juneteenth: [jun, 19],
        'canada day': [jul, 1],
        'independence day': [jul, 4],
        'independents day': [jul, 4],
        'bastille day': [jul, 14],
        'purple heart day': [aug, 7],
        'womens equality day': [aug, 26],
        '16 de septiembre': [sep, 16],
        'dieciseis de septiembre': [sep, 16],
        'grito de dolores': [sep, 16],
        halloween: [oct, 31],
        'all hallows eve': [oct, 31],
        'day of the dead': [oct, 31],
        // Ranged holiday [nov, 2],
        'dia de muertos': [oct, 31],
        // Ranged holiday [nov, 2],
        'veterans day': [nov, 11],
        'st andrews day': [nov, 30],
        'saint andrews day': [nov, 30],
        'all saints day': [nov, 1],
        'all sts day': [nov, 1],
        'armistice day': [nov, 11],
        'rememberance day': [nov, 11],
        'christmas eve': [dec, 24],
        christmas: [dec, 25],
        xmas: [dec, 25],
        'boxing day': [dec, 26],
        'st stephens day': [dec, 26],
        'saint stephens day': [dec, 26],
        // Fixed religious and cultural holidays
        // Catholic + Christian
        epiphany: [jan, 6],
        'orthodox christmas day': [jan, 7],
        'orthodox new year': [jan, 14],
        'assumption of mary': [aug, 15],
        'all souls day': [nov, 2],
        'feast of the immaculate conception': [dec, 8],
        'feast of our lady of guadalupe': [dec, 12],
        // Kwanzaa
        kwanzaa: [dec, 26],
        // Ranged holiday [jan, 1],
        // Pagan / metal 
        imbolc: [feb, 2],
        beltaine: [may, 1],
        lughnassadh: [aug, 1],
        samhain: [oct, 31]
      };

      var fixedDates = function fixedDates(str, normal, year, tz) {
        if (fixedHolidays.hasOwnProperty(str) || fixedHolidays.hasOwnProperty(normal)) {
          var arr = fixedHolidays[str] || fixedHolidays[normal] || [];
          var s = spacetime__default['default'].now(tz);
          s = s.year(year);
          s = s.startOf('year');
          s = s.month(arr[0]);
          s = s.date(arr[1]);

          if (s.isValid()) {
            return s;
          }
        }

        return null;
      };

      var _01FixedDates = fixedDates; //these are holidays on the 'nth weekday of month'

      var jan$1 = 'january';
      var feb$1 = 'february';
      var mar$1 = 'march'; // const apr = 'april'

      var may$1 = 'may';
      var jun$1 = 'june'; // const jul = 'july'
      // const aug = 'august'

      var sep$1 = 'september';
      var oct$1 = 'october';
      var nov$1 = 'november'; // const dec = 'december'

      var mon = 'monday'; // const tues = 'tuesday'
      // const wed = 'wednesday'

      var thurs = 'thursday';
      var fri = 'friday'; // const sat = 'saturday'

      var sun = 'sunday';
      var holidays = {
        'martin luther king day': [3, mon, jan$1],
        //[third monday in january],
        'presidents day': [3, mon, feb$1],
        //[third monday in february],
        'commonwealth day': [2, mon, mar$1],
        //[second monday in march],
        'mothers day': [2, sun, may$1],
        //[second Sunday in May],
        'fathers day': [3, sun, jun$1],
        //[third Sunday in June],
        'labor day': [1, mon, sep$1],
        //[first monday in september],
        'columbus day': [2, mon, oct$1],
        //[second monday in october],
        'canadian thanksgiving': [2, mon, oct$1],
        //[second monday in october],
        thanksgiving: [4, thurs, nov$1],
        // [fourth Thursday in November],
        'black friday': [4, fri, nov$1] //[fourth friday in november],
        // 'memorial day': [may], //[last monday in may],
        // 'us election': [nov], // [Tuesday following the first Monday in November],
        // 'cyber monday': [nov]
        // 'advent': [] // fourth Sunday before Christmas

      }; // add aliases

      holidays['turday day'] = holidays.thanksgiving;
      holidays['indigenous peoples day'] = holidays['columbus day'];
      holidays['mlk day'] = holidays['martin luther king day'];
      var calendarHolidays = holidays;

      var fixedDates$1 = function fixedDates(str, normal, year, tz) {
        if (calendarHolidays.hasOwnProperty(str) || calendarHolidays.hasOwnProperty(normal)) {
          var arr = calendarHolidays[str] || calendarHolidays[normal] || [];
          var s = spacetime__default['default'].now(tz);
          s = s.year(year); // [3rd, 'monday', 'january']

          s = s.month(arr[2]);
          s = s.startOf('month'); // make it january

          var month = s.month(); // make it the 1st monday

          s = s.day(arr[1]);

          if (s.month() !== month) {
            s = s.add(1, 'week');
          } // make it nth monday


          if (arr[0] > 1) {
            s = s.add(arr[0] - 1, 'week');
          }

          if (s.isValid()) {
            return s;
          }
        }

        return null;
      };

      var _02NthWeekday = fixedDates$1; // https://www.timeanddate.com/calendar/determining-easter-date.html

      var dates = {
        easter: 0,
        'ash wednesday': -46,
        // (46 days before easter)
        'palm sunday': 7,
        // (1 week before easter)
        'maundy thursday': -3,
        // (3 days before easter)
        'good friday': -2,
        // (2 days before easter)
        'holy saturday': -1,
        // (1 days before easter)
        'easter saturday': -1,
        // (1 day before easter)
        'easter monday': 1,
        // (1 day after easter)
        'ascension day': 39,
        // (39 days after easter)
        'whit sunday': 49,
        // / pentecost (49 days after easter)
        'whit monday': 50,
        // (50 days after easter)
        'trinity sunday': 65,
        // (56 days after easter)
        'corpus christi': 60,
        // (60 days after easter)
        'mardi gras': -47 //(47 days before easter)

      };
      dates['easter sunday'] = dates.easter;
      dates['pentecost'] = dates['whit sunday'];
      dates['whitsun'] = dates['whit sunday'];
      var easterHolidays = dates; // by John Dyer
      // based on the algorithm by Oudin (1940) from http://www.tondering.dk/claus/cal/easter.php

      var calcEaster = function calcEaster(year) {
        var f = Math.floor,
            // Golden Number - 1
        G = year % 19,
            C = f(year / 100),
            // related to Epact
        H = (C - f(C / 4) - f((8 * C + 13) / 25) + 19 * G + 15) % 30,
            // number of days from 21 March to the Paschal full moon
        I = H - f(H / 28) * (1 - f(29 / (H + 1)) * f((21 - G) / 11)),
            // weekday for the Paschal full moon
        J = (year + f(year / 4) + I + 2 - C + f(C / 4)) % 7,
            // number of days from 21 March to the Sunday on or before the Paschal full moon
        L = I - J,
            month = 3 + f((L + 40) / 44),
            date = L + 28 - 31 * f(month / 4);
        month = month === 4 ? 'April' : 'March';
        return month + ' ' + date;
      };

      var calcEaster_1 = calcEaster;

      var easterDates = function easterDates(str, normal, year, tz) {
        if (easterHolidays.hasOwnProperty(str) || easterHolidays.hasOwnProperty(normal)) {
          var days = easterHolidays[str] || easterHolidays[normal] || [];
          var date = calcEaster_1(year);

          if (!date) {
            return null; //no easter for this year
          }

          var e = spacetime__default['default'](date, tz);
          e = e.year(year);
          var s = e.add(days, 'day');

          if (s.isValid()) {
            return s;
          }
        }

        return null;
      };

      var _03EasterDates = easterDates; // http://www.astropixels.com/ephemeris/soleq2001.html
      // years 2000-2100

      var exceptions = {
        spring: [2003, 2007, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076, 2077, 2080, 2081, 2084, 2085, 2088, 2089, 2092, 2093, 2096, 2097],
        summer: [2021, 2016, 2020, 2024, 2028, 2032, 2036, 2040, 2041, 2044, 2045, 2048, 2049, 2052, 2053, 2056, 2057, 2060, 2061, 2064, 2065, 2068, 2069, 2070, 2072, 2073, 2074, 2076, 2077, 2078, 2080, 2081, 2082, 2084, 2085, 2086, 2088, 2089, 2090, 2092, 2093, 2094, 2096, 2097, 2098, 2099],
        fall: [2002, 2003, 2004, 2006, 2007, 2010, 2011, 2014, 2015, 2018, 2019, 2022, 2023, 2026, 2027, 2031, 2035, 2039, 2043, 2047, 2051, 2055, 2059, 2092, 2096],
        winter: [2002, 2003, 2006, 2007, 2011, 2015, 2019, 2023, 2027, 2031, 2035, 2039, 2043, 2080, 2084, 2088, 2092, 2096]
      };
      var winter20th = [2080, 2084, 2088, 2092, 2096];

      var calcSeasons = function calcSeasons(year) {
        // most common defaults
        var res = {
          spring: 'March 20 ' + year,
          summer: 'June 21 ' + year,
          fall: 'Sept 22 ' + year,
          winter: 'Dec 21 ' + year
        };

        if (exceptions.spring.indexOf(year) !== -1) {
          res.spring = 'March 19 ' + year;
        }

        if (exceptions.summer.indexOf(year) !== -1) {
          res.summer = 'June 20 ' + year;
        }

        if (exceptions.fall.indexOf(year) !== -1) {
          res.fall = 'Sept 21 ' + year;
        } // winter can be 20th, 21st, or 22nd


        if (exceptions.winter.indexOf(year) !== -1) {
          res.winter = 'Dec 22 ' + year;
        }

        if (winter20th.indexOf(year) !== -1) {
          res.winter = 'Dec 20 ' + year;
        }

        return res;
      };

      var seasons = calcSeasons; // these are properly calculated in ./lib/seasons

      var dates$1 = {
        'spring equinox': 'spring',
        'summer solistice': 'summer',
        'fall equinox': 'fall',
        'winter solstice': 'winter'
      }; // aliases

      dates$1['march equinox'] = dates$1['spring equinox'];
      dates$1['vernal equinox'] = dates$1['spring equinox'];
      dates$1['ostara'] = dates$1['spring equinox'];
      dates$1['june solstice'] = dates$1['summer solistice'];
      dates$1['litha'] = dates$1['summer solistice'];
      dates$1['autumn equinox'] = dates$1['fall equinox'];
      dates$1['autumnal equinox'] = dates$1['fall equinox'];
      dates$1['september equinox'] = dates$1['fall equinox'];
      dates$1['sept equinox'] = dates$1['fall equinox'];
      dates$1['mabon'] = dates$1['fall equinox'];
      dates$1['december solstice'] = dates$1['winter solistice'];
      dates$1['dec solstice'] = dates$1['winter solistice'];
      dates$1['yule'] = dates$1['winter solistice'];
      var astroHolidays = dates$1;

      var astroDates = function astroDates(str, normal, year, tz) {
        if (astroHolidays.hasOwnProperty(str) || astroHolidays.hasOwnProperty(normal)) {
          var season = astroHolidays[str] || astroHolidays[normal];
          var seasons$1 = seasons(year);

          if (!season || !seasons$1 || !seasons$1[season]) {
            return null; // couldn't figure it out
          }

          var s = spacetime__default['default'](seasons$1[season], tz);

          if (s.isValid()) {
            return s;
          }
        }

        return null;
      };

      var _04Astronomical = astroDates;
      var dates$2 = {
        // Muslim holidays
        'isra and miraj': 'april 13',
        'lailat al-qadr': 'june 10',
        'eid al-fitr': 'june 15',
        'id al-Fitr': 'june 15',
        'eid ul-Fitr': 'june 15',
        ramadan: 'may 16',
        // Range holiday
        'eid al-adha': 'sep 22',
        muharram: 'sep 12',
        'prophets birthday': 'nov 21'
      };
      var lunarHolidays = dates$2;
      var dayDiff = -10.64;

      var lunarDates = function lunarDates(str, normal, year, tz) {
        if (lunarHolidays.hasOwnProperty(str) || lunarHolidays.hasOwnProperty(normal)) {
          var date = lunarHolidays[str] || lunarHolidays[normal] || [];

          if (!date) {
            return null;
          } // start at 2018


          var s = spacetime__default['default'](date + ' 2018', tz);
          var diff = year - 2018;
          var toAdd = diff * dayDiff;
          s = s.add(toAdd, 'day');
          s = s.startOf('day'); // now set the correct year

          s = s.year(year);

          if (s.isValid()) {
            return s;
          }
        }

        return null;
      };

      var _05LunarDates = lunarDates;
      var nowYear = spacetime__default['default'].now().year();

      var spacetimeHoliday = function spacetimeHoliday(str, year, tz) {
        year = year || nowYear;
        str = str || '';
        str = String(str);
        str = str.trim().toLowerCase();
        str = str.replace(/'s/, 's'); // 'mother's day'

        var normal = str.replace(/ day$/, '');
        normal = normal.replace(/^the /, '');
        normal = normal.replace(/^orthodox /, ''); //orthodox good friday
        // try easier, unmoving holidays

        var s = _01FixedDates(str, normal, year, tz);

        if (s !== null) {
          return s;
        } // try 'nth monday' holidays


        s = _02NthWeekday(str, normal, year, tz);

        if (s !== null) {
          return s;
        } // easter-based holidays


        s = _03EasterDates(str, normal, year, tz);

        if (s !== null) {
          return s;
        } // solar-based holidays


        s = _04Astronomical(str, normal, year, tz);

        if (s !== null) {
          return s;
        } // mostly muslim holidays


        s = _05LunarDates(str, normal, year, tz);

        if (s !== null) {
          return s;
        }

        return null;
      };

      var src = spacetimeHoliday;
      return src;
    });
  });

  var Holiday$1 = units.Holiday;

  var parseHoliday = function parseHoliday(doc, context) {
    var unit = null;
    var m = doc.match('[<holiday>#Holiday+] [<year>#Year?]');
    var year = context.today.year();

    if (m.groups('year').found) {
      year = Number(m.groups('year').text('reduced')) || year;
    }

    var str = m.groups('holiday').text('reduced');
    var s = spacetimeHoliday(str, year, context.timezone);

    if (s !== null) {
      // assume the year in the future..
      if (s.isBefore(context.today) && year === context.today.year()) {
        s = spacetimeHoliday(str, year + 1, context.timezone);
      }

      unit = new Holiday$1(s, null, context);
    }

    return unit;
  };

  var _02Holidays = parseHoliday;

  var Week$1 = units.Week,
      WeekEnd$1 = units.WeekEnd,
      AnyMonth$1 = units.AnyMonth,
      AnyQuarter$1 = units.AnyQuarter,
      Year$1 = units.Year,
      Season$1 = units.Season,
      WeekDay$1 = units.WeekDay,
      Day$2 = units.Day,
      Hour$2 = units.Hour,
      Minute$1 = units.Minute,
      Moment$2 = units.Moment;
  var mapping = {
    day: Day$2,
    hour: Hour$2,
    evening: Hour$2,
    second: Moment$2,
    milliscond: Moment$2,
    instant: Moment$2,
    minute: Minute$1,
    week: Week$1,
    weekend: WeekEnd$1,
    month: AnyMonth$1,
    quarter: AnyQuarter$1,
    year: Year$1,
    season: Season$1,
    // set aliases
    yr: Year$1,
    qtr: AnyQuarter$1,
    wk: Week$1,
    sec: Moment$2,
    hr: Hour$2
  };
  var matchStr = "^(".concat(Object.keys(mapping).join('|'), ")$"); // when a unit of time is spoken of as 'this month' - instead of 'february'

  var nextLast = function nextLast(doc, context) {
    //this month, last quarter, next year
    var m = doc.match(matchStr);

    if (m.found === true) {
      var str = m.text('reduced');

      if (mapping.hasOwnProperty(str)) {
        var Model = mapping[str];

        if (!Model) {
          return null;
        }

        var unit = new Model(null, str, context);
        return unit;
      }
    } //try this version - 'next friday, last thursday'


    m = doc.match('^#WeekDay$');

    if (m.found === true) {
      var _str = m.text('reduced');

      var _unit = new WeekDay$1(_str, null, context);

      return _unit;
    }

    return null;
  };

  var _03NextLast = nextLast;

  var Quarter$1 = units.Quarter,
      Season$2 = units.Season,
      Year$2 = units.Year;

  var fmtToday = function fmtToday(context) {
    return {
      date: context.today.date(),
      month: context.today.month(),
      year: context.today.year()
    };
  };

  var parseYearly = function parseYearly(doc, context) {
    // support 'summer 2002'
    var m = doc.match('(spring|summer|winter|fall|autumn) [<year>#Year?]');

    if (m.found) {
      var str = doc.text('reduced');
      var s = spacetime(str, context.timezone, {
        today: fmtToday(context)
      });
      var unit = new Season$2(s, null, context);

      if (unit.d.isValid() === true) {
        return unit;
      }
    } // support 'q4 2020'


    m = doc.match('[<q>#FinancialQuarter] [<year>#Year?]');

    if (m.found) {
      var _str = m.groups('q').text('reduced');

      var _s = spacetime(_str, context.timezone, {
        today: fmtToday(context)
      });

      if (m.groups('year')) {
        var year = Number(m.groups('year').text()) || context.today.year();
        _s = _s.year(year);
      }

      var _unit = new Quarter$1(_s, null, context);

      if (_unit.d.isValid() === true) {
        return _unit;
      }
    } // support '4th quarter 2020'


    m = doc.match('[<q>#Value] quarter (of|in)? [<year>#Year?]');

    if (m.found) {
      var q = m.groups('q').text('reduced');

      var _s2 = spacetime("q".concat(q), context.timezone, {
        today: fmtToday(context)
      });

      if (m.groups('year')) {
        var _year = Number(m.groups('year').text()) || context.today.year();

        _s2 = _s2.year(_year);
      }

      var _unit2 = new Quarter$1(_s2, null, context);

      if (_unit2.d.isValid() === true) {
        return _unit2;
      }
    } // support '2020'


    m = doc.match('^#Year$');

    if (m.found) {
      var _str2 = doc.text('reduced');

      var _s3 = spacetime(null, context.timezone, {
        today: fmtToday(context)
      });

      _s3 = _s3.year(_str2);

      var _unit3 = new Year$2(_s3, null, context);

      if (_unit3.d.isValid() === true) {
        return _unit3;
      }
    }

    return null;
  };

  var _04Yearly = parseYearly;

  var Day$3 = units.Day,
      CalendarDate$1 = units.CalendarDate,
      Month$1 = units.Month,
      Moment$3 = units.Moment; // parse things like 'june 5th 2019'
  // most of this is done in spacetime

  var parseExplicit = function parseExplicit(doc, context) {
    var impliedYear = context.today.year(); // 'fifth of june 1992'
    // 'june the fifth 1992'

    var m = doc.match('[<date>#Value] of? [<month>#Month] [<year>#Year]');

    if (!m.found) {
      m = doc.match('[<month>#Month] the? [<date>#Value] [<year>#Year]');
    }

    if (m.found) {
      var obj = {
        month: m.groups('month').text(),
        date: m.groups('date').text(),
        year: m.groups('year').text() || impliedYear
      };

      var _unit = new CalendarDate$1(obj, null, context);

      if (_unit.d.isValid() === true) {
        return _unit;
      }
    } // 'march 1992'


    m = doc.match('[<month>#Month] of? [<year>#Year]');

    if (m.found) {
      var _obj = {
        month: m.groups('month').text(),
        year: m.groups('year').text() || impliedYear
      };

      var _unit2 = new Month$1(_obj, null, context);

      if (_unit2.d.isValid() === true) {
        return _unit2;
      }
    } //no-years
    // 'fifth of june'


    m = doc.match('[<date>#Value] of? [<month>#Month]'); // 'june the fifth'

    if (!m.found) {
      m = doc.match('[<month>#Month] the? [<date>#Value]');
    }

    if (m.found) {
      var _obj2 = {
        month: m.groups('month').text(),
        date: m.groups('date').text(),
        year: context.today.year()
      };

      var _unit3 = new CalendarDate$1(_obj2, null, context); // assume 'feb' in the future


      if (_unit3.d.month() < context.today.month()) {
        _obj2.year += 1;
        _unit3 = new CalendarDate$1(_obj2, null, context);
      }

      if (_unit3.d.isValid() === true) {
        return _unit3;
      }
    } // support 'december'


    if (doc.has('#Month')) {
      var _obj3 = {
        month: doc.match('#Month').text(),
        date: 1,
        //assume 1st
        year: context.today.year()
      };

      var _unit4 = new Month$1(_obj3, null, context); // assume 'feb' in the future


      if (_unit4.d.month() < context.today.month()) {
        _obj3.year += 1;
        _unit4 = new Month$1(_obj3, null, context);
      }

      if (_unit4.d.isValid() === true) {
        return _unit4;
      }
    } // support 'thursday 21st'


    m = doc.match('#WeekDay [<date>#Value]');

    if (m.found) {
      var _obj4 = {
        month: context.today.month(),
        date: m.groups('date').text(),
        year: context.today.year()
      };

      var _unit5 = new CalendarDate$1(_obj4, null, context);

      if (_unit5.d.isValid() === true) {
        return _unit5;
      }
    } // support date-only 'the 21st'


    m = doc.match('the [<date>#Value]');

    if (m.found) {
      var _obj5 = {
        month: context.today.month(),
        date: m.groups('date').text(),
        year: context.today.year()
      };

      var _unit6 = new CalendarDate$1(_obj5, null, context);

      if (_unit6.d.isValid() === true) {
        // assume it's forward
        if (_unit6.d.isBefore(context.today)) {
          _unit6.d = _unit6.d.add(1, 'month');
        }

        return _unit6;
      }
    } // parse ISO as a Moment


    m = doc.match('/[0-9]{4}-[0-9]{2}-[0-9]{2}t[0-9]{2}:/');

    if (m.found) {
      var _str = doc.text('reduced');

      var _unit7 = new Moment$3(_str, null, context);

      if (_unit7.d.isValid() === true) {
        return _unit7;
      }
    }

    var str = doc.text('reduced'); // punt it to spacetime, for the heavy-lifting

    var unit = new Day$3(str, null, context); // did we find a date?

    if (unit.d.isValid() === false) {
      return null;
    }

    return unit;
  };

  var _05Explicit = parseExplicit;

  var Quarter$2 = units.Quarter,
      Season$3 = units.Season,
      Week$2 = units.Week,
      Day$4 = units.Day,
      Hour$3 = units.Hour,
      Minute$2 = units.Minute,
      Month$2 = units.Month,
      WeekEnd$2 = units.WeekEnd;
  var units$1 = {
    day: Day$4,
    week: Week$2,
    weekend: WeekEnd$2,
    month: Month$2,
    quarter: Quarter$2,
    season: Season$3,
    hour: Hour$3,
    minute: Minute$2
  };

  var applyCounter = function applyCounter(unit) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var Unit = units$1[counter.unit];

    if (!Unit) {
      return unit;
    }

    var d = unit.d; // support 'first' or 0th

    if (counter.dir === 'first' || counter.num === 0) {
      d = unit.start().d;
      d = d.startOf(counter.unit);
    } else if (counter.dir === 'last') {
      d = d.endOf(unit.unit);
      d = d.startOf(counter.unit);
    } else if (counter.num) {
      // support 'nth week', eg.
      d = d.add(counter.num, counter.unit);
    }

    var u = new Unit(d, null, unit.context);

    if (u.d.isValid() === true) {
      return u;
    }

    return unit; //fallback
  };

  var addCounter = applyCounter;

  var tokens = {
    shift: _01Shift,
    counter: _02Counter,
    time: _03Time,
    relative: _04Relative,
    section: _05Section,
    timezone: _06Timezone
  };
  var parse = {
    today: _01Today,
    holiday: _02Holidays,
    nextLast: _03NextLast,
    yearly: _04Yearly,
    explicit: _05Explicit
  };
  var transform = {
    counter: addCounter
  };

  var parseDate = function parseDate(doc, context) {
    // quick normalization
    doc.match('[^the] !#Value', 0).remove(); // keep 'the 17th'
    //parse-out any sections

    var shift = tokens.shift(doc);
    var counter = tokens.counter(doc);
    var tz = tokens.timezone(doc);
    var time = tokens.time(doc, context);
    var section = tokens.section(doc, context);
    var rel = tokens.relative(doc); //set our new timezone

    if (tz) {
      context = Object.assign({}, context, {
        timezone: tz
      });
      var iso = context.today.format('iso-short');
      context.today = context.today["goto"](context.timezone).set(iso);
    }

    var unit = null; //'in two days'

    unit = unit || parse.today(doc, context, {
      shift: shift,
      time: time,
      rel: rel
    }); // 'this haloween'

    unit = unit || parse.holiday(doc, context); // 'this month'

    unit = unit || parse.nextLast(doc, context); // 'q2 2002'

    unit = unit || parse.yearly(doc, context); // 'this june 2nd'

    unit = unit || parse.explicit(doc, context); // doc.debug()

    if (!unit) {
      return null;
    } // 2 days after..


    if (shift) {
      unit.applyShift(shift); // if (shift.hour || shift.minute || shift.second) {
      //   console.log(shift)
      //   unit = new Hour(unit.d, null, unit.context)
      // }
    } // this/next/last


    if (rel) {
      unit.applyRel(rel);
    } // end of


    if (section) {
      unit.applySection(section);
    } // at 5:40pm


    if (time) {
      unit.applyTime(time);
    } // apply counter


    if (counter && counter.unit) {
      unit = transform.counter(unit, counter);
    } // debugging
    // console.log('\n\n=-=-=-=-=-=-=-=-=-=-=-=Date-=-=-=-=-=-=-=-=-=-=-=-=-\n')
    // console.log(`  shift:      ${JSON.stringify(shift)}`)
    // console.log(`  counter:   `, counter)
    // console.log(`  rel:        ${rel || '-'}`)
    // console.log(`  section:    ${section || '-'}`)
    // console.log(`  time:       ${time || '-'}`)
    // console.log(`  str:       '${doc.text()}'`)
    // console.log('  unit:     ', unit, '\n')
    // doc.debug()
    // console.log('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n')


    return unit;
  };

  var parse_1 = parseDate;

  var punt = function punt(unit, context) {
    unit = unit.applyShift(context.punt);
    return unit;
  };

  var ranges = [{
    // two explicit dates - 'between friday and sunday'
    match: 'between [<start>*] and [<end>*]',
    parse: function parse(m, context) {
      var start = m.groups('start');
      start = parse_1(start, context);
      var end = m.groups('end');
      end = parse_1(end, context);

      if (start && end) {
        return {
          start: start,
          end: end.before()
        };
      }

      return null;
    }
  }, {
    // two months, no year - 'june 5 to june 7'
    match: '[<from>#Month #Value] (to|through|thru) [<to>#Month #Value] [<year>#Year?]',
    parse: function parse(m, context) {
      var res = m.groups();
      var start = res.from;

      if (res.year) {
        start = start.append(res.year);
      }

      start = parse_1(start, context);

      if (start) {
        var end = res.to;

        if (res.year) {
          end = end.append(res.year);
        }

        end = parse_1(end, context); // reverse the order?

        if (start.d.isAfter(end.d)) {
          var tmp = start;
          start = end;
          end = tmp;
        }

        return {
          start: start,
          end: end.end()
        };
      }

      return null;
    }
  }, {
    // one month, one year, first form - 'january 5 to 7 1998'
    match: '[<month>#Month] [<from>#Value] (to|through|thru) [<to>#Value] of? [<year>#Year]',
    parse: function parse(m, context) {
      var _m$groups = m.groups(),
          month = _m$groups.month,
          from = _m$groups.from,
          to = _m$groups.to,
          year = _m$groups.year;

      var year2 = year.clone();
      var start = from.prepend(month.text()).append(year.text());
      start = parse_1(start, context);

      if (start) {
        var end = to.prepend(month.text()).append(year2);
        end = parse_1(end, context);
        return {
          start: start,
          end: end.end()
        };
      }

      return null;
    }
  }, {
    // one month, one year, second form - '5 to 7 of january 1998'
    match: '[<from>#Value] (to|through|thru) [<to>#Value of? #Month of? #Year]',
    parse: function parse(m, context) {
      var to = m.groups('to');
      to = parse_1(to, context);

      if (to) {
        var fromDate = m.groups('to');
        var from = to.clone();
        from.d = from.d.date(fromDate.text('normal'));
        return {
          start: from,
          end: to.end()
        };
      }

      return null;
    }
  }, {
    // one month, no year - '5 to 7 of january'
    match: '[<from>#Value] (to|through|thru) [<to>#Value of? #Month]',
    parse: function parse(m, context) {
      var to = m.groups('to');
      to = parse_1(to, context);

      if (to) {
        var fromDate = m.groups('from');
        var from = to.clone();
        from.d = from.d.date(fromDate.text('normal'));
        return {
          start: from,
          end: to.end()
        };
      }

      return null;
    }
  }, {
    // one month, no year - 'january 5 to 7'
    match: '[<from>#Month #Value] (to|through|thru) [<to>#Value]',
    parse: function parse(m, context) {
      var from = m.groups('from');
      from = parse_1(from, context);

      if (from) {
        var toDate = m.groups('to');
        var to = from.clone();
        to.d = to.d.date(toDate.text('normal'));
        return {
          start: from,
          end: to.end()
        };
      }

      return null;
    }
  }, {
    // 'from A to B'
    match: 'from? [<from>*] (to|until|upto|through|thru) [<to>*]',
    parse: function parse(m, context) {
      var from = m.groups('from');
      var to = m.groups('to');
      from = parse_1(from, context);
      to = parse_1(to, context);

      if (from && to) {
        return {
          start: from,
          end: to.end()
        };
      }

      return null;
    }
  }, // {
  //   // 'A through B' (inclusive end)
  //   match: 'from? [<a>*] (through|thru) [<b>*]',
  //   parse: (m, context) => {
  //     let from = m.groups('a')
  //     let to = m.groups('b')
  //     from = parseDate(from, context)
  //     to = parseDate(to, context)
  //     if (from && to) {
  //       return {
  //         start: from,
  //         end: to.end(),
  //       }
  //     }
  //     return null
  //   },
  // },
  // {
  //   // 'A until B' (not inclusive end)
  //   match: 'from? [<a>*] (to|until|upto) [<b>*]',
  //   parse: (m, context) => {
  //     let from = m.groups('a')
  //     let to = m.groups('b')
  //     from = parseDate(from, context)
  //     to = parseDate(to, context)
  //     if (from && to) {
  //       return {
  //         start: from,
  //         end: to.end(),
  //       }
  //     }
  //     return null
  //   },
  // },
  {
    // 'before june'
    match: '^due? (by|before) [*]',
    group: 0,
    parse: function parse(m, context) {
      var unit = parse_1(m, context);

      if (unit) {
        var start = new Unit_1(context.today, null, context);

        if (start.d.isAfter(unit.d)) {
          start = unit.clone().applyShift({
            weeks: -2
          });
        } // end the night before


        var end = unit.clone().applyShift({
          day: -1
        });
        return {
          start: start,
          end: end.end()
        };
      }

      return null;
    }
  }, {
    // 'in june'
    match: '^(on|in|at|@) [*]',
    group: 0,
    parse: function parse(m, context) {
      var unit = parse_1(m, context);

      if (unit) {
        return {
          start: unit,
          end: unit.clone().end()
        };
      }

      return null;
    }
  }, {
    // 'after june'
    match: '^(after|following) [*]',
    group: 0,
    parse: function parse(m, context) {
      var unit = parse_1(m, context);

      if (unit) {
        unit = unit.after();
        return {
          start: unit.clone(),
          end: punt(unit.clone(), context)
        };
      }

      return null;
    }
  }, {
    // 'in june'
    match: '^(on|during|in|during) [*]',
    group: 0,
    parse: function parse(m, context) {
      var unit = parse_1(m, context);

      if (unit) {
        return {
          start: unit,
          end: unit.clone().end()
        };
      }

      return null;
    }
  }];

  var parseRange = function parseRange(doc, context) {
    // try each template in order
    for (var i = 0; i < ranges.length; i += 1) {
      var fmt = ranges[i];
      var m = doc.match(fmt.match);

      if (m.found) {
        if (fmt.group !== undefined) {
          m = m.groups(fmt.group);
        }

        var res = fmt.parse(m, context);

        if (res !== null) {
          // console.log(fmt.match)
          return res;
        }
      }
    } //else, try whole thing


    var unit = parse_1(doc, context);

    if (unit) {
      return {
        start: unit,
        end: unit.clone().end()
      };
    }

    return {
      start: null,
      end: null
    };
  };

  var _02Ranges = parseRange;

  var normalize$1 = function normalize(doc) {
    doc = doc.clone();

    if (!doc.numbers) {
      console.warn("Compromise: compromise-dates cannot find plugin dependency 'compromise-number'");
    } else {
      // convert 'two' to 2
      var num = doc.numbers();
      num.toNumber();
      num.toCardinal(false); // num.normalize()
    } // // expand 'aug 20-21'


    doc.contractions().expand(); // // remove adverbs

    doc.adverbs().remove(); // // 'week-end'

    doc.replace('week end', 'weekend').tag('Date'); // // 'a up to b'

    doc.replace('up to', 'upto').tag('Date'); // 'in a few years'

    var m = doc.match('in [a few] #Duration');

    if (m.found) {
      m.groups('0').replaceWith('2');
      m.tag('DateShift');
    }

    return doc;
  };

  var normalize_1 = normalize$1;

  var getDate = function getDate(doc, context) {
    // validate context a bit
    context = context || {};
    context.timezone = context.timezone || 'ETC/UTC';
    context.today = spacetime(context.today || null, context.timezone); //turn 'five' into 5..

    doc = normalize_1(doc); //interpret 'between [A] and [B]'...

    return _02Ranges(doc, context);
  };

  var find = getDate;

  var arr = [['mon', 'monday'], ['tue', 'tuesday'], ['tues', 'tuesday'], ['wed', 'wednesday'], ['thu', 'thursday'], ['thurs', 'thursday'], ['fri', 'friday'], ['sat', 'saturday'], ['sun', 'sunday'], ['jan', 'january'], ['feb', 'february'], ['mar', 'march'], ['apr', 'april'], ['jun', 'june'], ['jul', 'july'], ['aug', 'august'], ['sep', 'september'], ['sept', 'september'], ['oct', 'october'], ['nov', 'november'], ['dec', 'december']];
  arr = arr.map(function (a) {
    return {
      "short": a[0],
      "long": a[1]
    };
  });
  var _abbrevs = arr;

  var methods$1 = {
    /** overload the original json with noun information */
    json: function json(options) {
      var _this = this;

      var n = null;

      if (typeof options === 'number') {
        n = options;
        options = null;
      }

      options = options || {
        terms: false
      };
      var res = [];
      var format = options.format || 'iso';
      this.forEach(function (doc) {
        var json = doc.json(options)[0];
        var obj = find(doc, _this.context);
        var start = obj.start ? obj.start.format(format) : null;
        var end = obj.end ? obj.end.format(format) : null; // set iso strings to json result

        json.date = {
          start: start,
          end: end
        }; // add duration

        if (start && end) {
          json.date.duration = obj.start.d.diff(obj.end.d); // we don't need these

          delete json.date.duration.milliseconds;
          delete json.date.duration.seconds;
        }

        res.push(json);
      });

      if (n !== null) {
        return res[n];
      }

      return res;
    },

    /** render all dates according to a specific format */
    format: function format(fmt) {
      var _this2 = this;

      this.forEach(function (doc) {
        var obj = find(doc, _this2.context);
        var str = '';

        if (obj.start) {
          str = obj.start.format(fmt);

          if (obj.end) {
            var end = obj.start.format(fmt);

            if (str !== end) {
              str += ' to ' + end;
            }
          }

          doc.replaceWith(str, {
            keepTags: true,
            keepCase: false
          });
        }
      });
      return this;
    },

    /** replace 'Fri' with 'Friday', etc*/
    toLongForm: function toLongForm() {
      var _this3 = this;

      _abbrevs.forEach(function (a) {
        _this3.replace(a["short"], a["long"], true);
      });
      return this;
    },

    /** replace 'Friday' with 'Fri', etc*/
    toShortForm: function toShortForm() {
      var _this4 = this;

      _abbrevs.forEach(function (a) {
        _this4.replace(a["long"], a["short"], true);
      });
      return this;
    }
  };

  var opts = {
    punt: {
      weeks: 2
    }
  };

  var addMethods = function addMethods(Doc, world) {
    // our new tags
    world.addTags(_tags); // add info for the date plugin

    world.addWords(words); // run our tagger

    world.postProcess(_01Tagger);
    /**  */

    var Dates = /*#__PURE__*/function (_Doc) {
      _inherits(Dates, _Doc);

      var _super = _createSuper(Dates);

      function Dates(list, from, w) {
        var _this;

        _classCallCheck(this, Dates);

        _this = _super.call(this, list, from, w);
        _this.context = opts;
        return _this;
      }

      return Dates;
    }(Doc); //add-in methods


    Object.assign(Dates.prototype, methods$1);

    Doc.prototype.dates = function (n) {
      var context = {};

      if (n && _typeof(n) === 'object') {
        context = n;
        n = null;
      }

      context = Object.assign({}, context, opts); // let r = this.clauses()

      var dates = this.match('#Date+');

      if (typeof n === 'number') {
        dates = dates.get(n);
      }

      var d = new Dates(dates.list, this, this.world);

      if (context.today) {
        context.today = spacetime(context.today, context.timezone);
      }

      d.context = context;
      return d;
    };
  };

  var src = addMethods;

  return src;

})));
//# sourceMappingURL=compromise-dates.js.map
};
BundleModuleCode['plugins/nlp/compromise-numbers']=function (module,exports,global,process){
/* compromise-numbers 1.1.0 MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.compromiseNumbers = factory());
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var tens = 'twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty';
  var teens = 'eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen'; // this is a bit of a mess

  var findNumbers = function findNumbers(doc, n) {
    var match = doc.match('#Value+'); //"50 83"

    if (match.has('#NumericValue #NumericValue')) {
      //a comma may mean two numbers
      if (match.has('#Value @hasComma #Value')) {
        match.splitAfter('@hasComma');
      } else if (match.has('#NumericValue #Fraction')) {
        match.splitAfter('#NumericValue #Fraction');
      } else {
        match = match.splitAfter('#NumericValue');
      }
    } //three-length


    if (match.has('#Value #Value #Value') && !match.has('#Multiple')) {
      //twenty-five-twenty
      if (match.has('(' + tens + ') #Cardinal #Cardinal')) {
        match = match.splitAfter('(' + tens + ') #Cardinal');
      }
    } //two-length ones


    if (match.has('#Value #Value')) {
      //june 21st 1992 is two seperate values
      if (match.has('#NumericValue #NumericValue')) {
        match = match.splitOn('#Year');
      } //sixty fifteen


      if (match.has('(' + tens + ') (' + teens + ')')) {
        match = match.splitAfter('(' + tens + ')');
      } //"72 82"


      var _double = match.match('#Cardinal #Cardinal');

      if (_double.found && !match.has('(point|decimal)')) {
        //not 'two hundred'
        if (!_double.has('#Cardinal (#Multiple|point|decimal)')) {
          //one proper way, 'twenty one', or 'hundred one'
          if (!_double.has('(' + tens + ') #Cardinal') && !_double.has('#Multiple #Value')) {
            // double = double.firstTerm()
            _double.terms().forEach(function (d) {
              match = match.splitOn(d);
            });
          }
        }
      } //seventh fifth


      if (match.match('#Ordinal #Ordinal').match('#TextValue').found && !match.has('#Multiple')) {
        //the one proper way, 'twenty first'
        if (!match.has('(' + tens + ') #Ordinal')) {
          match = match.splitAfter('#Ordinal');
        }
      } //fifth five


      if (match.has('#Ordinal #Cardinal')) {
        match = match.splitBefore('#Cardinal+');
      } //five 2017 (support '5 hundred', and 'twenty 5'


      if (match.has('#TextValue #NumericValue') && !match.has('(' + tens + '|#Multiple)')) {
        match = match.splitBefore('#NumericValue+');
      }
    } //5-8


    if (match.has('#NumberRange')) {
      match = match.splitAfter('#NumberRange');
    } //grab (n)th result


    if (typeof n === 'number') {
      match = match.get(n);
    }

    return match;
  };

  var find = findNumbers;

  //support global multipliers, like 'half-million' by doing 'million' then multiplying by 0.5
  var findModifiers = function findModifiers(str) {
    var mults = [{
      reg: /^(minus|negative)[\s\-]/i,
      mult: -1
    }, {
      reg: /^(a\s)?half[\s\-](of\s)?/i,
      mult: 0.5
    } //  {
    //   reg: /^(a\s)?quarter[\s\-]/i,
    //   mult: 0.25
    // }
    ];

    for (var i = 0; i < mults.length; i++) {
      if (mults[i].reg.test(str) === true) {
        return {
          amount: mults[i].mult,
          str: str.replace(mults[i].reg, '')
        };
      }
    }

    return {
      amount: 1,
      str: str
    };
  };

  var findModifiers_1 = findModifiers;

  var data = {
    ones: {
      zeroth: 0,
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      zero: 0,
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9
    },
    teens: {
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      ten: 10,
      eleven: 11,
      twelve: 12,
      thirteen: 13,
      fourteen: 14,
      fifteen: 15,
      sixteen: 16,
      seventeen: 17,
      eighteen: 18,
      nineteen: 19
    },
    tens: {
      twentieth: 20,
      thirtieth: 30,
      fortieth: 40,
      fourtieth: 40,
      fiftieth: 50,
      sixtieth: 60,
      seventieth: 70,
      eightieth: 80,
      ninetieth: 90,
      twenty: 20,
      thirty: 30,
      forty: 40,
      fourty: 40,
      fifty: 50,
      sixty: 60,
      seventy: 70,
      eighty: 80,
      ninety: 90
    },
    multiples: {
      hundredth: 100,
      thousandth: 1000,
      millionth: 1e6,
      billionth: 1e9,
      trillionth: 1e12,
      quadrillionth: 1e15,
      quintillionth: 1e18,
      sextillionth: 1e21,
      septillionth: 1e24,
      hundred: 100,
      thousand: 1000,
      million: 1e6,
      billion: 1e9,
      trillion: 1e12,
      quadrillion: 1e15,
      quintillion: 1e18,
      sextillion: 1e21,
      septillion: 1e24,
      grand: 1000
    }
  };

  var isValid = function isValid(w, has) {
    if (data.ones.hasOwnProperty(w)) {
      if (has.ones || has.teens) {
        return false;
      }
    } else if (data.teens.hasOwnProperty(w)) {
      if (has.ones || has.teens || has.tens) {
        return false;
      }
    } else if (data.tens.hasOwnProperty(w)) {
      if (has.ones || has.teens || has.tens) {
        return false;
      }
    }

    return true;
  };

  var validate = isValid;

  var parseDecimals = function parseDecimals(arr) {
    var str = '0.';

    for (var i = 0; i < arr.length; i++) {
      var w = arr[i];

      if (data.ones.hasOwnProperty(w) === true) {
        str += data.ones[w];
      } else if (data.teens.hasOwnProperty(w) === true) {
        str += data.teens[w];
      } else if (data.tens.hasOwnProperty(w) === true) {
        str += data.tens[w];
      } else if (/^[0-9]$/.test(w) === true) {
        str += w;
      } else {
        return 0;
      }
    }

    return parseFloat(str);
  };

  var parseDecimals_1 = parseDecimals;

  //parse a string like "4,200.1" into Number 4200.1
  var parseNumeric = function parseNumeric(str) {
    //remove ordinal - 'th/rd'
    str = str.replace(/1st$/, '1');
    str = str.replace(/2nd$/, '2');
    str = str.replace(/3rd$/, '3');
    str = str.replace(/([4567890])r?th$/, '$1'); //remove prefixes

    str = str.replace(/^[$]/, ''); //remove suffixes

    str = str.replace(/[%$]$/, ''); //remove commas

    str = str.replace(/,/g, ''); //split '5kg' from '5'

    str = str.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, '$1');
    return str;
  };

  var parseNumeric_1 = parseNumeric;

  var improperFraction = /^([0-9,\. ]+)\/([0-9,\. ]+)$/; //some numbers we know

  var casualForms = {
    // 'a few': 3,
    'a couple': 2,
    'a dozen': 12,
    'two dozen': 24,
    zero: 0
  }; // a 'section' is something like 'fifty-nine thousand'
  // turn a section into something we can add to - like 59000

  var section_sum = function section_sum(obj) {
    return Object.keys(obj).reduce(function (sum, k) {
      sum += obj[k];
      return sum;
    }, 0);
  }; //turn a string into a number


  var parse = function parse(str) {
    //convert some known-numbers
    if (casualForms.hasOwnProperty(str) === true) {
      return casualForms[str];
    } //'a/an' is 1


    if (str === 'a' || str === 'an') {
      return 1;
    }

    var modifier = findModifiers_1(str);
    str = modifier.str;
    var last_mult = null;
    var has = {};
    var sum = 0;
    var isNegative = false;
    var terms = str.split(/[ -]/);

    for (var i = 0; i < terms.length; i++) {
      var w = terms[i];
      w = parseNumeric_1(w);

      if (!w || w === 'and') {
        continue;
      }

      if (w === '-' || w === 'negative') {
        isNegative = true;
        continue;
      }

      if (w.charAt(0) === '-') {
        isNegative = true;
        w = w.substr(1);
      } //decimal mode


      if (w === 'point') {
        sum += section_sum(has);
        sum += parseDecimals_1(terms.slice(i + 1, terms.length));
        sum *= modifier.amount;
        return sum;
      } //improper fraction


      var fm = w.match(improperFraction);

      if (fm) {
        var num = parseFloat(fm[1].replace(/[, ]/g, ''));
        var denom = parseFloat(fm[2].replace(/[, ]/g, ''));

        if (denom) {
          sum += num / denom || 0;
        }

        continue;
      } //prevent mismatched units, like 'seven eleven'


      if (validate(w, has) === false) {
        return null;
      } //buildOut section, collect 'has' values


      if (/^[0-9\.]+$/.test(w)) {
        has['ones'] = parseFloat(w); //not technically right
      } else if (data.ones.hasOwnProperty(w) === true) {
        has['ones'] = data.ones[w];
      } else if (data.teens.hasOwnProperty(w) === true) {
        has['teens'] = data.teens[w];
      } else if (data.tens.hasOwnProperty(w) === true) {
        has['tens'] = data.tens[w];
      } else if (data.multiples.hasOwnProperty(w) === true) {
        var mult = data.multiples[w]; //something has gone wrong : 'two hundred five hundred'

        if (mult === last_mult) {
          return null;
        } //support 'hundred thousand'
        //this one is tricky..


        if (mult === 100 && terms[i + 1] !== undefined) {
          // has['hundreds']=
          var w2 = terms[i + 1];

          if (data.multiples[w2]) {
            mult *= data.multiples[w2]; //hundredThousand/hundredMillion

            i += 1;
          }
        } //natural order of things
        //five thousand, one hundred..


        if (last_mult === null || mult < last_mult) {
          sum += (section_sum(has) || 1) * mult;
          last_mult = mult;
          has = {};
        } else {
          //maybe hundred .. thousand
          sum += section_sum(has);
          last_mult = mult;
          sum = (sum || 1) * mult;
          has = {};
        }
      }
    } //dump the remaining has values


    sum += section_sum(has); //post-process add modifier

    sum *= modifier.amount;
    sum *= isNegative ? -1 : 1; //dont return 0, if it went straight-through

    if (sum === 0 && Object.keys(has).length === 0) {
      return null;
    }

    return sum;
  };

  var toNumber = parse;

  var parseNumeric$1 = function parseNumeric(str, p) {
    str = str.replace(/,/g, ''); //parse a numeric-number (easy)

    var arr = str.split(/^([^0-9]*)([0-9.,]*)([^0-9]*)$/);

    if (arr && arr[2] && p.terms().length < 2) {
      var num = parseFloat(arr[2] || str); //ensure that num is an actual number

      if (typeof num !== 'number') {
        num = null;
      } // strip an ordinal off the suffix


      var suffix = arr[3] || '';

      if (suffix === 'st' || suffix === 'nd' || suffix === 'rd' || suffix === 'th') {
        suffix = '';
      } // support M for million, k for thousand


      if (suffix === 'm' || suffix === 'M') {
        num *= 1000000;
        suffix = '';
      }

      if (suffix === 'k' || suffix === 'k') {
        num *= 1000;
        suffix = '';
      }

      return {
        prefix: arr[1] || '',
        num: num,
        suffix: suffix
      };
    }

    return null;
  }; // get a numeric value from this phrase


  var parseNumber = function parseNumber(p) {
    var str = p.text('reduced'); // is it in '3,123' format?

    var hasComma = /[0-9],[0-9]/.test(p.text('text')); // parse a numeric-number like '$4.00'

    var res = parseNumeric$1(str, p);

    if (res !== null) {
      res.hasComma = hasComma;
      return res;
    } //parse a text-numer (harder)


    var num = toNumber(str);
    return {
      hasComma: hasComma,
      prefix: '',
      num: num,
      suffix: ''
    };
  };

  var parse$1 = parseNumber;

  // handle 'one bottle', 'two bottles'
  var agreeUnits = function agreeUnits(agree, val, obj) {
    if (agree === false) {
      return;
    }

    var unit = val.lookAhead('^(#Unit|#Noun)'); // don't do these

    if (unit.has('(#Address|#Money|#Percent)') || val.has('#Ordinal')) {
      return;
    }

    if (obj.num === 1) {
      unit.nouns().toSingular();
    } else if (unit.has('#Singular')) {
      unit.nouns().toPlural();
    }
  };

  var _agreeUnits = agreeUnits;

  /**
   * turn big numbers, like 2.3e+22, into a string with a ton of trailing 0's
   * */
  var numToString = function numToString(n) {
    if (n < 1000000) {
      return String(n);
    }

    var str;

    if (typeof n === 'number') {
      str = n.toFixed(0);
    } else {
      str = n;
    }

    if (str.indexOf('e+') === -1) {
      return str;
    }

    return str.replace('.', '').split('e+').reduce(function (p, b) {
      return p + Array(b - p.length + 2).join(0);
    });
  };

  var _toString = numToString; // console.log(numToString(2.5e+22));

  /**
   * turns an integer/float into.ber, like 'fifty-five'
   */

  var tens_mapping = [['ninety', 90], ['eighty', 80], ['seventy', 70], ['sixty', 60], ['fifty', 50], ['forty', 40], ['thirty', 30], ['twenty', 20]];
  var ones_mapping = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
  var sequence = [[1e24, 'septillion'], [1e20, 'hundred sextillion'], [1e21, 'sextillion'], [1e20, 'hundred quintillion'], [1e18, 'quintillion'], [1e17, 'hundred quadrillion'], [1e15, 'quadrillion'], [1e14, 'hundred trillion'], [1e12, 'trillion'], [1e11, 'hundred billion'], [1e9, 'billion'], [1e8, 'hundred million'], [1e6, 'million'], [100000, 'hundred thousand'], [1000, 'thousand'], [100, 'hundred'], [1, 'one']]; //turn number into an array of magnitudes, like [[5, million], [2, hundred]]

  var breakdown_magnitudes = function breakdown_magnitudes(num) {
    var working = num;
    var have = [];
    sequence.forEach(function (a) {
      if (num >= a[0]) {
        var howmany = Math.floor(working / a[0]);
        working -= howmany * a[0];

        if (howmany) {
          have.push({
            unit: a[1],
            count: howmany
          });
        }
      }
    });
    return have;
  }; //turn numbers from 100-0 into their text


  var breakdown_hundred = function breakdown_hundred(num) {
    var arr = [];

    if (num > 100) {
      return arr; //something bad happened..
    }

    for (var i = 0; i < tens_mapping.length; i++) {
      if (num >= tens_mapping[i][1]) {
        num -= tens_mapping[i][1];
        arr.push(tens_mapping[i][0]);
      }
    } //(hopefully) we should only have 20-0 now


    if (ones_mapping[num]) {
      arr.push(ones_mapping[num]);
    }

    return arr;
  };
  /** print-out 'point eight nine'*/


  var handle_decimal = function handle_decimal(num) {
    var names = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
    var arr = []; //parse it out like a string, because js math is such shit

    var str = _toString(num);
    var decimal = str.match(/\.([0-9]+)/);

    if (!decimal || !decimal[0]) {
      return arr;
    }

    arr.push('point');
    var decimals = decimal[0].split('');

    for (var i = 0; i < decimals.length; i++) {
      arr.push(names[decimals[i]]);
    }

    return arr;
  };
  /** turns an integer into a textual number */


  var to_text = function to_text(num) {
    // handle zero, quickly
    if (num === 0 || num === '0') {
      return 'zero'; // no?
    } //big numbers, north of sextillion, aren't gonna work well..
    //keep them small..


    if (num > 1e21) {
      num = _toString(num);
    }

    var arr = []; //handle negative numbers

    if (num < 0) {
      arr.push('minus');
      num = Math.abs(num);
    } //break-down into units, counts


    var units = breakdown_magnitudes(num); //build-up the string from its components

    for (var i = 0; i < units.length; i++) {
      var unit_name = units[i].unit;

      if (unit_name === 'one') {
        unit_name = ''; //put an 'and' in here

        if (arr.length > 1) {
          arr.push('and');
        }
      }

      arr = arr.concat(breakdown_hundred(units[i].count));
      arr.push(unit_name);
    } //also support decimals - 'point eight'


    arr = arr.concat(handle_decimal(num)); //remove empties

    arr = arr.filter(function (s) {
      return s;
    });

    if (arr.length === 0) {
      arr[0] = '';
    }

    return arr.join(' ');
  };

  var toText = to_text; // console.log(to_text(-1000.8));

  /**
   * turn a number like 5 into an ordinal like 5th
   */

  var numOrdinal = function numOrdinal(num) {
    if (!num && num !== 0) {
      return null;
    } //the teens are all 'th'


    var tens = num % 100;

    if (tens > 10 && tens < 20) {
      return String(num) + 'th';
    } //the rest of 'em


    var mapping = {
      0: 'th',
      1: 'st',
      2: 'nd',
      3: 'rd'
    };
    var str = _toString(num);
    var last = str.slice(str.length - 1, str.length);

    if (mapping[last]) {
      str += mapping[last];
    } else {
      str += 'th';
    }

    return str;
  };

  var numOrdinal_1 = numOrdinal;

  var irregulars = {
    one: 'first',
    two: 'second',
    three: 'third',
    five: 'fifth',
    eight: 'eighth',
    nine: 'ninth',
    twelve: 'twelfth',
    twenty: 'twentieth',
    thirty: 'thirtieth',
    forty: 'fortieth',
    fourty: 'fourtieth',
    fifty: 'fiftieth',
    sixty: 'sixtieth',
    seventy: 'seventieth',
    eighty: 'eightieth',
    ninety: 'ninetieth'
  };
  /**
   * convert a javascript number to 'twentieth' format
   * */

  var textOrdinal = function textOrdinal(num) {
    var words = toText(num).split(' '); //convert the last number to an ordinal

    var last = words[words.length - 1];

    if (irregulars.hasOwnProperty(last)) {
      words[words.length - 1] = irregulars[last];
    } else {
      words[words.length - 1] = last.replace(/y$/, 'i') + 'th';
    }

    return words.join(' ');
  };

  var textOrdinal_1 = textOrdinal;

  var prefixes = {
    '': 'cents',
    $: 'dollars',
    '': 'pounds',
    '': 'yen',
    '': 'euros',
    '': 'coln',
    '': 'baht',
    '': 'kip',
    '': 'won',
    '': 'rupees',
    '': 'ruble',
    '': 'liras'
  };
  var suffixes = {
    '%': 'percent',
    s: 'seconds',
    cm: 'centimetres',
    km: 'kilometres'
  };
  var _symbols = {
    prefixes: prefixes,
    suffixes: suffixes
  };

  var prefixes$1 = _symbols.prefixes;
  var suffixes$1 = _symbols.suffixes;
  var isCurrency = {
    usd: true,
    eur: true,
    jpy: true,
    gbp: true,
    cad: true,
    aud: true,
    chf: true,
    cny: true,
    hkd: true,
    nzd: true,
    kr: true,
    rub: true
  }; // convert $ to 'dollars', etc

  var prefixToText = function prefixToText(obj) {
    // turn 5% to 'five percent'
    if (prefixes$1.hasOwnProperty(obj.prefix)) {
      obj.suffix += prefixes$1[obj.prefix];
      obj.prefix = '';
    } //turn 5km to 'five kilometres'


    if (suffixes$1.hasOwnProperty(obj.suffix)) {
      obj.suffix = suffixes$1[obj.suffix];
    } //uppercase lost case for 'USD', etc


    if (isCurrency.hasOwnProperty(obj.suffix)) {
      obj.suffix = obj.suffix.toUpperCase();
    } // add a space, if it exists


    if (obj.suffix) {
      obj.suffix = ' ' + obj.suffix;
    }

    return obj;
  }; //business-logic for converting a cardinal-number to other forms


  var makeNumber = function makeNumber(obj, isText, isOrdinal) {
    var num = String(obj.num);

    if (isText) {
      obj = prefixToText(obj);

      if (isOrdinal) {
        //ordinal-text
        num = textOrdinal_1(num);
        return "".concat(obj.prefix || '').concat(num).concat(obj.suffix || '');
      } //cardinal-text


      num = toText(num);
      return "".concat(obj.prefix || '').concat(num).concat(obj.suffix || '');
    } //ordinal-number


    if (isOrdinal) {
      num = numOrdinal_1(num); // support '5th percent'

      obj = prefixToText(obj);
      return "".concat(obj.prefix || '').concat(num).concat(obj.suffix || '');
    } // support comma format


    if (obj.hasComma === true) {
      num = obj.num.toLocaleString();
    } // cardinal-number


    num = _toString(num); // support very large numbers

    return "".concat(obj.prefix || '').concat(num).concat(obj.suffix || '');
  };

  var makeNumber_1 = makeNumber;

  var methods = {
    /** overloaded json method with additional number information */
    json: function json(options) {
      var n = null;

      if (typeof options === 'number') {
        n = options;
        options = null;
      }

      options = options || {
        text: true,
        normal: true,
        trim: true,
        terms: true
      };
      var res = [];
      this.forEach(function (doc) {
        var json = doc.json(options)[0];
        var obj = parse$1(doc);
        json.prefix = obj.prefix;
        json.number = obj.num;
        json.suffix = obj.suffix;
        json.cardinal = makeNumber_1(obj, false, false);
        json.ordinal = makeNumber_1(obj, false, true);
        json.textCardinal = makeNumber_1(obj, true, false);
        json.textOrdinal = makeNumber_1(obj, true, true);
        res.push(json);
      });

      if (n !== null) {
        return res[n];
      }

      return res;
    },

    /** two of what? */
    units: function units() {
      var m = this.lookAhead('(#Unit|#Noun)+');
      m = m.splitAfter('@hasComma').first();
      m = m.not('#Pronoun');
      return m.first();
    },

    /** return only ordinal numbers */
    isOrdinal: function isOrdinal() {
      return this["if"]('#Ordinal');
    },

    /** return only cardinal numbers*/
    isCardinal: function isCardinal() {
      return this["if"]('#Cardinal');
    },

    /** convert to numeric form like '8' or '8th' */
    toNumber: function toNumber() {
      this.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num === null) {
          return;
        }

        var str = makeNumber_1(obj, false, val.has('#Ordinal'));
        val.replaceWith(str, true);
        val.tag('NumericValue');
      });
      return this;
    },

    /** add commas, or nicer formatting for numbers */
    toLocaleString: function toLocaleString() {
      this.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num === null) {
          return;
        }

        obj.num = obj.num.toLocaleString();
        var str = makeNumber_1(obj, false, val.has('#Ordinal'));
        val.replaceWith(str, true);
      });
      return this;
    },

    /** convert to text form - like 'eight' or 'eigth'*/
    toText: function toText() {
      this.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num === null) {
          return;
        }

        var str = makeNumber_1(obj, true, val.has('#Ordinal'));
        val.replaceWith(str, true);
        val.tag('TextValue');
      });
      return this;
    },

    /** convert to cardinal form, like 'eight', or '8' */
    toCardinal: function toCardinal(agree) {
      var m = this["if"]('#Ordinal');
      m.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num === null) {
          return;
        }

        var str = makeNumber_1(obj, val.has('#TextValue'), false); // a hack for number-ranges

        if (val.has('#NumberRange')) {
          var t = val.termList()[0];

          if (t.text && t.post === '') {
            t.post = ' ';
          }
        } // change the number text


        val.replaceWith(str, true);
        val.tag('Cardinal'); // turn unit into plural -> 'seven beers'

        _agreeUnits(agree, val, obj);
      });
      return this;
    },

    /** convert to ordinal form, like 'eighth', or '8th' */
    toOrdinal: function toOrdinal() {
      var _this = this;

      var m = this["if"]('#Cardinal');
      m.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num === null) {
          return;
        }

        var str = makeNumber_1(obj, val.has('#TextValue'), true); // a hack for number-ranges

        if (val.has('#NumberRange')) {
          var t = val.termList()[0];

          if (t.text && t.post === '') {
            t.post = ' ';
          }
        } // change the number text


        val.replaceWith(str, true);
        val.tag('Ordinal'); // turn unit into singular -> 'seventh beer'

        var unit = _this.lookAhead('^#Plural');

        if (unit.found) {
          unit.nouns().toSingular();
        }
      });
      return this;
    },

    /** return only numbers that are == n */
    isEqual: function isEqual(n) {
      return this.filter(function (val) {
        var num = parse$1(val).num;
        return num === n;
      });
    },

    /** return only numbers that are > n*/
    greaterThan: function greaterThan(n) {
      return this.filter(function (val) {
        var num = parse$1(val).num;
        return num > n;
      });
    },

    /** return only numbers that are < n*/
    lessThan: function lessThan(n) {
      return this.filter(function (val) {
        var num = parse$1(val).num;
        return num < n;
      });
    },

    /** return only numbers > min and < max */
    between: function between(min, max) {
      return this.filter(function (val) {
        var num = parse$1(val).num;
        return num > min && num < max;
      });
    },

    /** set these number to n */
    set: function set(n, agree) {
      if (n === undefined) {
        return this; // don't bother
      }

      if (typeof n === 'string') {
        n = toNumber(n);
      }

      this.forEach(function (val) {
        var obj = parse$1(val);
        obj.num = n;

        if (obj.num === null) {
          return;
        }

        var str = makeNumber_1(obj, val.has('#TextValue'), val.has('#Ordinal'));
        val = val.not('#Currency');
        val.replaceWith(str, true); // handle plural/singular unit

        _agreeUnits(agree, val, obj);
      });
      return this;
    },
    add: function add(n, agree) {
      if (!n) {
        return this; // don't bother
      }

      if (typeof n === 'string') {
        n = toNumber(n);
      }

      this.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num === null) {
          return;
        }

        obj.num += n;
        var str = makeNumber_1(obj, val.has('#TextValue'), val.has('#Ordinal'));
        val = val.not('#Currency');
        val.replaceWith(str, true); // handle plural/singular unit

        _agreeUnits(agree, val, obj);
      });
      return this;
    },

    /** decrease each number by n*/
    subtract: function subtract(n, agree) {
      return this.add(n * -1, agree);
    },

    /** increase each number by 1 */
    increment: function increment(agree) {
      this.add(1, agree);
      return this;
    },

    /** decrease each number by 1 */
    decrement: function decrement(agree) {
      this.add(-1, agree);
      return this;
    },

    /** return things like CCXX*/
    romanNumerals: function romanNumerals(n) {
      var m = this.match('#RomanNumeral').numbers();

      if (typeof n === 'number') {
        m = m.get(n);
      }

      return m;
    },

    /** split-apart suffix and number */
    normalize: function normalize() {
      var keep = {
        '%': true
      };
      this.forEach(function (val) {
        var obj = parse$1(val);

        if (obj.num !== null && obj.suffix && keep[obj.suffix] !== true) {
          var prefix = obj.prefix || '';
          val = val.replaceWith(prefix + obj.num + ' ' + obj.suffix);
          return;
        }
      });
      return this;
    },

    /** retrieve the parsed number */
    get: function get(n) {
      var arr = [];
      this.forEach(function (doc) {
        arr.push(parse$1(doc).num);
      });

      if (n !== undefined) {
        return arr[n];
      }

      return arr;
    }
  }; // aliases

  methods.toNice = methods.toLocaleString;
  methods.isBetween = methods.between;
  methods.minus = methods.subtract;
  methods.plus = methods.add;
  methods.equals = methods.isEqual;
  var methods_1 = methods;

  //from wikipedia's {{infobox currency}}, Dec 2020
  var currencies = [{
    dem: 'american',
    name: 'dollar',
    iso: 'usd',
    sub: 'cent',
    sym: ['$', 'US$', 'U$']
  }, {
    name: 'euro',
    iso: 'eur',
    sub: 'cent',
    sym: ['']
  }, {
    dem: 'british',
    name: 'pound',
    iso: 'gbp',
    sub: 'penny',
    alias: {
      sterling: true
    },
    sym: ['']
  }, {
    name: 'renminbi',
    iso: 'cny',
    sub: 'yun',
    plural: 'yun',
    alias: {
      yuan: true
    },
    sym: [''] //''

  }, {
    dem: 'japanese',
    name: 'yen',
    iso: 'jpy',
    sub: 'sen',
    sym: ['', '', '']
  }, // kr
  {
    dem: 'swedish',
    name: 'krona',
    iso: 'sek',
    sub: 're',
    alias: {
      ore: true,
      kronor: true
    },
    sym: ['kr']
  }, {
    dem: 'estonian',
    name: 'kroon',
    iso: 'eek',
    sub: 'sent',
    sym: ['kr']
  }, {
    dem: 'norwegian',
    name: 'krone',
    iso: 'nok',
    sub: 're',
    sym: ['kr']
  }, {
    dem: 'icelandic',
    name: 'krna',
    iso: 'isk',
    sym: ['kr']
  }, {
    dem: 'danish',
    name: 'krone',
    iso: 'dkk',
    sub: 're',
    sym: ['kr.']
  }, // {
  //   dem: 'scandinavian',
  //   name: 'Monetary Union',
  //   sub: 're',
  //   sym: ['kr.'],
  // },
  // 'k'
  {
    dem: 'zambian',
    name: 'kwacha',
    iso: 'zmw',
    sub: 'ngwee',
    sym: ['K']
  }, {
    dem: 'malawian',
    name: 'kwacha',
    iso: 'mwk',
    sub: 'tambala',
    sym: ['K']
  }, // misc
  {
    dem: 'greek',
    name: 'drachma',
    iso: 'grd',
    sub: 'leptn',
    sym: ['.', '.', '']
  }, {
    dem: 'eastern caribbean',
    name: 'dollar',
    iso: 'xcd',
    sub: 'cent',
    sym: ['$']
  }, {
    dem: 'finnish',
    name: 'markka',
    iso: 'fim',
    sub: 'penni',
    sym: ['mk']
  }, {
    dem: 'polish',
    name: 'zoty',
    iso: 'pln',
    sub: 'grosz',
    sym: ['z']
  }, {
    dem: 'slovenian',
    name: 'tolar',
    iso: 'sit',
    sub: 'stotin',
    sym: []
  }, {
    dem: 'australian',
    name: 'dollar',
    iso: 'aud',
    sub: 'cent',
    sym: ['$', 'A$', 'AU$']
  }, {
    dem: 'deutsche',
    name: 'mark',
    iso: 'dem',
    sub: 'pfennig',
    sym: ['DM']
  }, {
    dem: 'thai',
    name: 'baht',
    iso: 'thb',
    sub: 'satang',
    sym: ['']
  }, {
    dem: 'canadian',
    name: 'dollar',
    iso: 'cad',
    sub: 'cent',
    sym: ['$', 'Can$', 'C$', 'CA$', 'CAD']
  }, {
    dem: 'mexican',
    name: 'peso',
    iso: 'mxn',
    sub: 'centavo',
    sym: ['$', 'Mex$']
  }, {
    dem: 'spanish',
    name: 'peseta',
    iso: 'esp',
    sub: 'cntimo',
    sym: ['Pta']
  }, {
    dem: 'new zealand',
    name: 'dollar',
    iso: 'nzd',
    sub: 'cent',
    sym: ['$', 'NZ$']
  }, {
    dem: 'chilean',
    name: 'peso',
    iso: 'clp',
    sub: 'Centavo',
    sym: ['Cifro', '$']
  }, {
    dem: 'nigerian',
    name: 'naira',
    iso: 'ngn',
    sub: 'kobo',
    sym: ['']
  }, {
    dem: 'austrian',
    name: 'schilling',
    iso: 'ats',
    sub: 'groschen',
    sym: ['S', 'S']
  }, {
    dem: 'guatemalan',
    name: 'quetzal',
    iso: 'gtq',
    sub: 'centavo',
    sym: ['Q']
  }, {
    dem: 'philippine',
    name: 'peso',
    iso: 'php',
    sub: 'sentimo',
    sym: ['']
  }, {
    dem: 'hungarian',
    name: 'forint',
    iso: 'huf',
    sub: 'fillr',
    sym: ['Ft']
  }, {
    dem: 'russian',
    name: 'ruble',
    iso: 'rub',
    sub: 'kopeyka',
    sym: ['', '', '.']
  }, {
    dem: 'kuwaiti',
    name: 'dinar',
    iso: 'kwd',
    sub: 'fils',
    sym: ['.', 'KD']
  }, {
    dem: 'israeli',
    name: 'new shekel',
    iso: 'ils',
    sub: 'agora',
    sym: ['']
  }, {
    dem: 'latvian',
    name: 'lats',
    iso: 'lvl',
    sub: 'santms',
    sym: ['Ls']
  }, {
    dem: 'kazakhstani',
    name: 'tenge',
    iso: 'kzt',
    sub: 'tyn',
    sym: ['']
  }, {
    dem: 'iraqi',
    name: 'dinar',
    iso: 'iqd',
    sub: 'fils',
    sym: ['.']
  }, {
    dem: 'bahamian',
    name: 'dollar',
    iso: 'bsd',
    sub: 'cent',
    sym: ['$', 'B$']
  }, {
    dem: 'seychellois',
    name: 'rupee',
    iso: 'scr',
    sub: 'cent',
    sym: ['SCR', 'SR']
  }, {
    dem: 'albanian',
    name: 'lek',
    iso: 'all',
    sub: 'qindark',
    sym: ['L']
  }, {
    dem: 'bulgarian',
    name: 'lev',
    iso: 'bgn',
    sub: 'stotinka',
    sym: ['.']
  }, {
    dem: 'irish',
    name: 'pound',
    iso: 'iep',
    sym: ['', 'IR']
  }, {
    name: 'cfp franc',
    iso: 'xpf',
    sym: ['f']
  }, {
    dem: 'south african',
    name: 'rand',
    iso: 'zar',
    sub: 'cent',
    sym: ['R']
  }, {
    dem: 'south korean',
    name: 'won',
    iso: 'krw',
    sub: 'jeon',
    plural: 'won',
    sym: ['']
  }, {
    dem: 'north korean',
    name: 'won',
    iso: 'kpw',
    sub: 'chon',
    plural: 'won',
    sym: ['']
  }, {
    dem: 'portuguese',
    name: 'escudo',
    iso: 'pte',
    sub: 'centavo',
    sym: []
  }, {
    dem: 'ghanaian',
    name: 'cedi',
    iso: 'ghs',
    sub: 'pesewa',
    sym: ['GH']
  }, {
    dem: 'hong kong',
    name: 'dollar',
    iso: 'hkd',
    sub: '',
    sym: ['$']
  }, {
    dem: 'new taiwan',
    name: 'dollar',
    iso: 'twd',
    sub: 'dime',
    sym: ['NT$']
  }, {
    dem: 'east german',
    name: 'mark',
    iso: 'ddm',
    sub: 'pfennig',
    sym: ['M']
  }, {
    dem: 'namibian',
    name: 'dollar',
    iso: 'nad',
    sub: 'cent',
    sym: ['$']
  }, {
    dem: 'malaysian',
    name: 'ringgit',
    iso: 'myr',
    sub: 'sen',
    sym: ['RM']
  }, {
    dem: 'swiss',
    name: 'franc',
    iso: 'chf',
    sym: ['Rp.']
  }, {
    dem: 'panamanian',
    name: 'balboa',
    iso: 'pab',
    sub: 'centsimo',
    sym: ['B/.']
  }, {
    dem: 'indonesian',
    name: 'rupiah',
    iso: 'idr',
    sub: 'sen',
    sym: ['Rp']
  }, {
    dem: 'brunei',
    name: 'dollar',
    iso: 'bnd',
    sub: 'sen',
    sym: ['$', 'B$']
  }, {
    dem: 'venezuelan',
    name: 'bolvar',
    iso: 'vef',
    sub: 'cntimo',
    sym: ['Bs.F', 'Bs.']
  }, {
    dem: 'macedonian',
    name: 'denar',
    iso: 'mkd',
    sub: 'deni',
    sym: ['den']
  }, {
    dem: 'mauritanian',
    name: 'ouguiya',
    iso: 'mru',
    sub: 'khoums',
    sym: ['UM']
  }, {
    dem: 'argentine',
    name: 'peso',
    iso: 'ars',
    sub: 'centavo',
    sym: ['$']
  }, {
    dem: 'libyan',
    name: 'dinar',
    iso: 'lyd',
    sub: 'dirham',
    sym: ['LD', '.']
  }, {
    dem: 'jordanian',
    name: 'dinar',
    iso: 'jod',
    sub: 'dirham',
    sym: ['.']
  }, {
    dem: 'french',
    name: 'franc',
    iso: 'frf',
    sub: 'centime',
    sym: ['F', 'Fr', 'FF', '']
  }, {
    dem: 'syrian',
    name: 'pound',
    iso: 'syp',
    sub: 'piastre',
    sym: ['LS', 'S']
  }, {
    dem: 'belize',
    name: 'dollar',
    iso: 'bzd',
    sub: 'cent',
    sym: ['$']
  }, {
    dem: 'saudi',
    name: 'riyal',
    iso: 'sar',
    sub: 'halalah',
    sym: ['SAR', '.', ' ']
  }, {
    dem: 'surinamese',
    name: 'dollar',
    iso: 'srd',
    sub: 'cent',
    sym: ['$']
  }, {
    dem: 'singapore',
    name: 'dollar',
    iso: 'sgd',
    sub: 'cent',
    sym: ['S$', '$']
  }, {
    dem: 'nepalese',
    name: 'rupee',
    iso: 'npr',
    sub: 'Paisa',
    sym: [' ', 'Re']
  }, {
    dem: 'macanese',
    name: 'pataca',
    iso: 'mop',
    sub: 'ho',
    sym: ['MOP$']
  }, {
    dem: 'nicaraguan',
    name: 'crdoba',
    iso: 'nio',
    sub: 'centavo',
    sym: ['C$']
  }, {
    dem: 'bangladeshi',
    name: 'taka',
    iso: 'bdt',
    sub: 'poysha',
    sym: ['']
  }, {
    dem: 'indian',
    name: 'rupee',
    iso: 'inr',
    sub: 'paisa',
    sym: ['']
  }, {
    dem: 'maldivian',
    name: 'rufiyaa',
    iso: 'mvr',
    sub: 'laari',
    sym: ['Rf', 'MRf', 'MVR', '. ']
  }, {
    dem: 'sri lankan',
    name: 'rupee',
    iso: 'lkr',
    sub: 'Cents',
    sym: ['Rs', '', '']
  }, {
    dem: 'bhutanese',
    name: 'ngultrum',
    iso: 'btn',
    sub: 'chhertum',
    sym: ['Nu.']
  }, {
    dem: 'turkish',
    name: 'lira',
    iso: 'try',
    sub: 'new kuru',
    sym: ['YTL']
  }, {
    dem: 'serbian',
    name: 'dinar',
    iso: 'rsd',
    sub: 'para',
    sym: ['din', '']
  }, {
    dem: 'bosnia and herzegovina',
    name: 'convertible mark',
    iso: 'bam',
    sub: 'Fening/Pfenig',
    sym: ['KM']
  }, {
    dem: 'botswana',
    name: 'pula',
    iso: 'bwp',
    sub: 'thebe',
    sym: ['p']
  }, {
    dem: 'swazi',
    name: 'lilangeni',
    iso: 'szl',
    sub: 'cent',
    sym: ['L', 'E']
  }, {
    dem: 'lithuanian',
    name: 'litas',
    iso: 'ltl',
    sub: 'centas',
    sym: ['Lt', 'ct']
  }, {
    dem: 'mauritian',
    name: 'rupee',
    iso: 'mur',
    sub: 'cent',
    sym: ['']
  }, {
    dem: 'pakistani',
    name: 'rupee',
    iso: 'pkr',
    sub: 'Paisa',
    sym: ['']
  }, {
    dem: 'maltese',
    name: 'lira',
    iso: 'mtl',
    sub: 'cent',
    sym: ['', 'Lm']
  }, {
    dem: 'cypriot',
    name: 'pound',
    iso: 'cyp',
    sub: 'cent',
    sym: ['']
  }, {
    dem: 'moldovan',
    name: 'leu',
    iso: 'mdl',
    sub: 'ban',
    sym: ['l']
  }, {
    dem: 'croatian',
    name: 'kuna',
    iso: 'hrk',
    sub: 'lipa',
    sym: ['kn']
  }, {
    dem: 'afghan',
    name: 'afghani',
    iso: 'afn',
    sub: 'pul',
    sym: ['', 'Af', 'Afs']
  }, {
    dem: 'ecuadorian',
    name: 'sucre',
    iso: 'ecs',
    sub: 'centavo',
    sym: ['S/.']
  }, {
    dem: 'sierra leonean',
    name: 'leone',
    iso: 'sll',
    sub: 'cent',
    sym: ['Le']
  } // {
  //
  //   name: 'European Currency Unit',
  //   iso: 'xeu',
  //   sym: [''],
  // },
  // {
  //
  //   name: 'Special drawing rights',
  //   iso: 'xdr',
  //   sym: ['SDR'],
  // },
  // {
  //
  //   name: 'Unidad de Valor Constante',
  //   iso: 'ecv',
  // },
  ];

  var symbols = {};
  currencies.forEach(function (o) {
    o.sym.forEach(function (str) {
      symbols[str] = symbols[str] || o.iso;
    });
    symbols[o.iso] = symbols[o.iso] || o.iso;
  }); // parse 'australian dollars'

  var getNamedCurrency = function getNamedCurrency(doc) {
    var m = doc.match('#Currency+');
    m.nouns().toSingular(); // 'dollars''dollar'

    var str = m.text('reduced');
    return currencies.find(function (o) {
      // 'mexcan peso'
      if (str === "".concat(o.dem, " ").concat(o.name)) {
        return o;
      } // 'CAD'


      if (str === o.iso) {
        return o;
      } // 'cent'


      if (str === o.sub) {
        return o;
      } // 'peso'


      if (str === o.name) {
        return o;
      } // any other alt names


      if (o.alias && o.alias[str] === true) {
        return o;
      }

      return false;
    });
  }; // turn '' into GBP


  var getBySymbol = function getBySymbol(obj) {
    // do suffix first, for '$50CAD'
    if (obj.suffix && symbols.hasOwnProperty(obj.suffix)) {
      return currencies.find(function (o) {
        return o.iso === symbols[obj.suffix];
      });
    } // parse prefix for '50'


    if (obj.prefix && symbols.hasOwnProperty(obj.prefix)) {
      return currencies.find(function (o) {
        return o.iso === symbols[obj.prefix];
      });
    }

    return null;
  };

  var parseMoney = function parseMoney(doc) {
    var res = parse$1(doc);
    var found = getBySymbol(res) || getNamedCurrency(doc) || {};
    var sym = '';

    if (found && found.sym) {
      sym = found.sym[0];
    }

    return {
      num: res.num,
      iso: found.iso,
      demonym: found.dem,
      currency: found.name,
      plural: found.plural,
      symbol: sym
    };
  };

  var parse$2 = parseMoney;

  var titleCase = function titleCase() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return str.replace(/\w\S*/g, function (txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
  };

  var moneyMethods = {
    /** which currency is this money in? */
    currency: function currency(n) {
      var arr = [];
      this.forEach(function (doc) {
        var found = parse$2(doc);

        if (found) {
          arr.push(found);
        }
      });

      if (typeof n === 'number') {
        return arr[n];
      }

      return arr;
    },

    /** overloaded json method with additional number information */
    json: function json(options) {
      var n = null;

      if (typeof options === 'number') {
        n = options;
        options = null;
      }

      options = options || {
        text: true,
        normal: true,
        trim: true,
        terms: true
      };
      var res = [];
      this.forEach(function (doc) {
        var json = doc.json(options)[0];
        var obj = parse$2(doc);
        json.number = obj.num;

        if (obj.iso) {
          json.iso = obj.iso.toUpperCase();
          json.symbol = obj.symbol;
          json.currency = titleCase(obj.demonym) + ' ' + titleCase(obj.currency);
        } // 'thirty pounds'


        json.textFmt = makeNumber_1(obj, true, false);

        if (obj.currency) {
          var str = obj.currency;

          if (obj.num !== 1) {
            str = obj.plural || str + 's';
          }

          json.textFmt += ' ' + str;
        }

        res.push(json);
      });

      if (n !== null) {
        return res[n] || {};
      }

      return res;
    }
  };
  var methods$1 = moneyMethods;

  var endS = /s$/;

  var slashForm = function slashForm(m) {
    var str = m.text('reduced');
    var found = str.match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);

    if (found && found[1] && found[0]) {
      return {
        numerator: Number(found[1]),
        denominator: Number(found[2])
      };
    }

    return null;
  }; // parse '4 out of 4'


  var textForm1 = function textForm1(m) {
    var found = m.match('[<num>#Value+] out of every? [<den>#Value+]');

    if (found.found !== true) {
      return null;
    }

    var _found$groups = found.groups(),
        num = _found$groups.num,
        den = _found$groups.den;

    num = num.numbers().get(0);
    den = den.numbers().get(0);

    if (typeof num === 'number' && typeof den === 'number') {
      return {
        numerator: num,
        denominator: den
      };
    }

    return null;
  }; // parse 'a third'


  var textForm2 = function textForm2(m) {
    var found = m.match('[<num>(#Cardinal|a)+] [<den>#Ordinal+]');

    if (found.found !== true) {
      return null;
    }

    var _found$groups2 = found.groups(),
        num = _found$groups2.num,
        den = _found$groups2.den; // quick-support for 'a third'


    if (num.has('a')) {
      num = 1;
    } else {
      num = num.numbers().get(0);
    } // turn 'thirds' into third


    var str = den.text('reduced');

    if (endS.test(str)) {
      str = str.replace(endS, '');
      den.replaceWith(str);
    } // support 'one half' as '1/2'


    if (den.has('half')) {
      den = 2;
    } else {
      den = den.numbers().get(0);
    }

    if (typeof num === 'number' && typeof den === 'number') {
      return {
        numerator: num,
        denominator: den
      };
    }

    return null;
  };

  var parseFraction = function parseFraction(m) {
    return slashForm(m) || textForm1(m) || textForm2(m) || null;
  };

  var parse$3 = parseFraction;

  var methods$2 = {
    /** overloaded json method with additional number information */
    json: function json(options) {
      var n = null;

      if (typeof options === 'number') {
        n = options;
        options = null;
      }

      options = options || {
        text: true,
        normal: true,
        trim: true,
        terms: true
      };
      var res = [];
      this.forEach(function (m) {
        var json = m.json(options)[0];
        var found = parse$3(m) || {};
        json.numerator = found.numerator;
        json.denominator = found.denominator;
        res.push(json);
      });

      if (n !== null) {
        return res[n] || {};
      }

      return res;
    },

    /** change 'four out of 10' to 4/10 */
    normalize: function normalize() {
      var _this = this;

      this.forEach(function (m) {
        var found = parse$3(m);

        if (found && typeof found.numerator === 'number' && typeof found.denominator === 'number') {
          var str = "".concat(found.numerator, "/").concat(found.denominator);

          _this.replace(m, str);
        }
      });
      return this;
    }
  };
  var methods_1$1 = methods$2;

  var here = 'number-tag';
  var multiples = '(hundred|thousand|million|billion|trillion|quadrillion|quintillion|sextillion|septillion)'; //support 'two thirds'
  // (do this conservatively)

  var ordinals = ['half', 'third', 'fourth', 'quarter', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'hundredth', 'thousandth', 'millionth']; // add plural forms

  var len = ordinals.length;

  for (var i = 0; i < len; i += 1) {
    ordinals.push(ordinals[i] + 's');
  }

  ordinals = "(".concat(ordinals.join('|'), ")"); // improved tagging for numbers

  var tagger = function tagger(doc) {
    doc.match(multiples).tag('#Multiple', here); //  in the 400s

    doc.match('the [/[0-9]+s$/]').tag('#Plural', here); //half a million

    doc.match('half a? #Value').tag('Value', 'half-a-value'); //(quarter not ready)
    //five and a half

    doc.match('#Value and a (half|quarter)').tag('Value', 'value-and-a-half'); //one hundred and seven dollars

    doc.match('#Money and #Money #Currency?').tag('Money', 'money-and-money'); // $5.032 is invalid money

    doc.match('#Money').not('#TextValue').match('/\\.[0-9]{3}$/').unTag('#Money', 'three-decimal money'); // cleanup currency false-positives

    doc.ifNo('#Value').match('#Currency #Verb').unTag('Currency', 'no-currency'); // 6 dollars and 5 cents

    doc.match('#Value #Currency [and] #Value (cents|ore|centavos|sens)', 0).tag('Money', here); // maybe currencies

    var m = doc.match('[<num>#Value] [<currency>(mark|rand|won|rub|ore)]');
    m.group('num').tag('Money', here);
    m.group('currency').tag('Currency', here); // fraction - '3 out of 5'

    doc.match('#Cardinal+ out of every? #Cardinal').tag('Fraction', here); // fraction - 'a third of a slice'

    m = doc.match("[(#Cardinal|a) ".concat(ordinals, "] of (a|an|the)"), 0).tag('Fraction', here); // tag 'thirds' as a ordinal

    m.match('.$').tag('Ordinal', 'plural-ordinal');
  };

  var tagger_1 = tagger;

  var tags = {
    Fraction: {
      isA: ['Value', 'NumericValue']
    },
    Multiple: {
      isA: 'Value'
    }
  };

  var ambig = {
    mark: true,
    sucre: true,
    leone: true,
    afghani: true,
    rand: true,
    "try": true,
    mop: true,
    won: true,
    all: true,
    rub: true,
    eek: true,
    sit: true,
    bam: true,
    npr: true,
    leu: true
  };
  var lex = {
    kronor: 'Currency'
  };
  currencies.forEach(function (o) {
    if (o.iso && !ambig[o.iso]) {
      lex[o.iso] = ['Acronym', 'Currency'];
    }

    var name = o.name;

    if (name && !ambig[name]) {
      lex[name] = 'Currency';
      lex[name + 's'] = 'Currency';
    }

    if (o.dem) {
      var dem = o.dem;
      lex["".concat(dem, " ").concat(name)] = 'Currency';
      lex["".concat(dem, " ").concat(name, "s")] = 'Currency';
    }
  });
  var lexicon = lex;

  /** adds .numbers() method */

  var plugin = function plugin(Doc, world) {
    // add money words to our lexicon
    world.addWords(lexicon); // add tags to our tagset

    world.addTags(tags); // additional tagging before running the number-parser

    world.postProcess(tagger_1);
    /** a list of number values, and their units */

    var Numbers = /*#__PURE__*/function (_Doc) {
      _inherits(Numbers, _Doc);

      var _super = _createSuper(Numbers);

      function Numbers() {
        _classCallCheck(this, Numbers);

        return _super.apply(this, arguments);
      }

      return Numbers;
    }(Doc);

    Object.assign(Numbers.prototype, methods_1);
    /** a number and a currency */

    var Money = /*#__PURE__*/function (_Numbers) {
      _inherits(Money, _Numbers);

      var _super2 = _createSuper(Money);

      function Money() {
        _classCallCheck(this, Money);

        return _super2.apply(this, arguments);
      }

      return Money;
    }(Numbers);

    Object.assign(Money.prototype, methods$1);

    var Fraction = /*#__PURE__*/function (_Numbers2) {
      _inherits(Fraction, _Numbers2);

      var _super3 = _createSuper(Fraction);

      function Fraction() {
        _classCallCheck(this, Fraction);

        return _super3.apply(this, arguments);
      }

      return Fraction;
    }(Numbers);

    Object.assign(Fraction.prototype, methods_1$1);
    var docMethods = {
      /** find all numbers and values */
      numbers: function numbers(n) {
        var m = find(this, n);
        return new Numbers(m.list, this, this.world);
      },

      /** return '4%' or 'four percent' etc*/
      percentages: function percentages(n) {
        var m = this.match('#Percent+');
        m = m.concat(this.match('[#Cardinal] percent', 0));

        if (typeof n === 'number') {
          m = m.eq(n);
        }

        return new Numbers(m.list, this, this.world);
      },

      /** return '3 out of 5' or '3/5' etc**/
      fractions: function fractions(n) {
        var m = this.match('#Fraction+');

        if (typeof n === 'number') {
          m = m.eq(n);
        }

        return new Fraction(m.list, this, this.world);
      },

      /** number + currency pair */
      money: function money() {
        var m = this.splitOn('(#Money|#Currency)+');
        m = m["if"]('#Money')["if"]('#Value');
        return new Money(m.list, this, this.world);
      }
    }; // aliases

    docMethods.values = docMethods.numbers;
    docMethods.percents = docMethods.percentages;
    Object.assign(Doc.prototype, docMethods);
    return Doc;
  };

  var src = plugin;

  return src;

})));
//# sourceMappingURL=compromise-numbers.js.map
};
BundleModuleCode['plugins/nlp/compromise-sentences']=function (module,exports,global,process){
/* compromise-sentences 0.1.1 MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.compromiseSentences = factory());
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var tags = {
    // Phrase: {},
    NounPhrase: {
      // isA: 'Phrase',
      notA: ['VerbPhrase', 'AdjectivePhrase'],
      color: 'blue'
    },
    VerbPhrase: {
      // isA: 'Phrase',
      notA: ['AdjectivePhrase', 'NounPhrase'],
      color: 'green'
    },
    AdjectivePhrase: {
      // isA: 'Phrase',
      notA: ['VerbPhrase', 'NounPhrase'],
      color: 'magenta'
    },
    Subordinate: {
      // isA: 'Phrase',
      notA: [] // color: '',

    }
  };

  var tagger = function tagger(doc) {
    doc.match('#Noun').tag('NounPhrase');
    doc.match('#Verb').tag('VerbPhrase'); // NounPhrase

    doc.match('(this|that|those|these)').tag('NounPhrase');
    doc.match('#Adjective+ #NounPhrase').tagSafe('NounPhrase');
    doc.match('#NounPhrase #Adjective+').tagSafe('NounPhrase'); // numbers

    doc.match('#Value #NounPhrase').tag('NounPhrase'); // (determiners)

    doc.match('#Determiner #NounPhrase').tag('NounPhrase');
    doc.match('#Determiner #Adverb+? #Adjective+ #NounPhrase').tag('NounPhrase');
    doc.match('(many|most|all|one|some|plenty) of #NounPhrase').tag('NounPhrase');
    doc.match('such a #NounPhrase').tag('NounPhrase'); // VerbPhrase

    doc.match('#VerbPhrase #Adverb+').tagSafe('VerbPhrase');
    doc.match('#Adverb+ #VerbPhrase').tagSafe('VerbPhrase');
    doc.match('#Auxiliary+ #VerbPhrase').tagSafe('VerbPhrase');
    doc.match('#VerbPhrase no').tagSafe('VerbPhrase');
    doc.match('not #VerbPhrase').tagSafe('VerbPhrase'); // claiming that

    doc.match('#VerbPhrase [that]', 0).unTag('NounPhrase'); // (conjunctions)

    doc.match('#VerbPhrase #Conjunction #VerbPhrase').tagSafe('VerbPhrase'); // nouns

    doc.match('(who|what|which)').tag('NounPhrase'); // Adjective

    doc.match('#Adverb+ #Adjective').tagSafe('AdjectivePhrase');
    doc.match('#Adjective').tagSafe('AdjectivePhrase'); // missing

    doc.match('#Value').tagSafe('NounPhrase');
    doc.match('#Date').tagSafe('NounPhrase');
    doc.match('#Date at #Date').tagSafe('NounPhrase');
  };

  var tagger_1 = tagger;

  /** add a word to the start of this sentence */
  var prepend = function prepend(str) {
    this.forEach(function (doc) {
      // repair the titlecase
      var firstTerms = doc.match('^.');
      firstTerms.not('#ProperNoun').toLowerCase(); // actually add the word

      firstTerms._prepend(str); // add a titlecase


      firstTerms.terms(0).toTitleCase();
    });
    return this;
  };
  /** add a word to the end of this sentence */


  var append_1 = function append_1(str) {
    var hasEnd = /[.?!]\s*$/.test(str);
    this.forEach(function (doc) {
      var end = doc.match('.$');
      var lastTerm = end.termList(0);
      var punct = lastTerm.post;

      if (hasEnd === true) {
        punct = '';
      } // add punctuation to the end


      end._append(str + punct); // remove punctuation from the former last-term


      lastTerm.post = ' ';
    });
    return this;
  };

  var append = {
    prepend: prepend,
    append: append_1
  };

  // if a clause starts with these, it's not a main clause
  var subordinate = "(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)";
  var relative = "(that|which|whichever|who|whoever|whom|whose|whomever)"; //try to remove secondary clauses

  var mainClause = function mainClause(og) {
    var m = og.clone(true);

    if (m.length === 1) {
      return m;
    } // if there's no verb?


    m = m["if"]('#Verb');

    if (m.length === 1) {
      return m;
    } // this is a signal for subordinate-clauses


    m = m.ifNo(subordinate);
    m = m.ifNo('^even (if|though)');
    m = m.ifNo('^so that');
    m = m.ifNo('^rather than');
    m = m.ifNo('^provided that');

    if (m.length === 1) {
      return m;
    } // relative clauses


    m = m.ifNo(relative);

    if (m.length === 1) {
      return m;
    }

    m = m.ifNo('(despite|during|before|through|throughout)');

    if (m.length === 1) {
      return m;
    } // did we go too far?


    if (m.length === 0) {
      m = og;
    } // choose the first one?


    return m.eq(0);
  };

  var mainClause_1 = mainClause;

  var parse = function parse(doc) {
    var clauses = doc.clauses();
    var main = mainClause_1(clauses);
    var nouns = main.match('#Determiner? (#Noun|#Adjective)+')["if"]('#Noun');
    var verb = main.verbs().eq(0); // match('(do|will)? not? #Verb+ not?').eq(0)

    return {
      subject: nouns.eq(0),
      verb: verb,
      object: verb.lookAhead('.*')
    };
  };

  var parse_1 = parse;

  /** overload the original json with noun information */

  var json_1 = function json_1(options) {
    var n = null;

    if (typeof options === 'number') {
      n = options;
      options = null;
    }

    options = options || {
      text: true,
      normal: true,
      trim: true,
      terms: true
    };
    var res = [];
    this.forEach(function (doc) {
      var json = doc._json(options)[0];

      var obj = parse_1(doc);
      json.subject = obj.subject.json(options)[0];
      json.verb = obj.verb.json(options)[0];
      json.object = obj.object.json(options)[0];
      res.push(json);
    });

    if (n !== null) {
      return res[n];
    }

    return res;
  };

  var json = {
    json: json_1
  };

  /** he walks -> he did not walk */

  var toNegative = function toNegative() {
    this.forEach(function (doc) {
      var obj = parse_1(doc);
      var vb = obj.verb.clone();
      vb = vb.verbs().toNegative();
      obj.verb.replaceWith(vb, false);
    });
    return this;
  };
  /** he doesn't walk -> he walks */


  var toPositive = function toPositive() {
    this.forEach(function (doc) {
      var obj = parse_1(doc);
      var vb = obj.verb.clone();
      vb = vb.verbs().toPositive();
      obj.verb.replaceWith(vb, false);
    });
    return this;
  };

  var negative = {
    toNegative: toNegative,
    toPositive: toPositive
  };

  //is this sentence asking a question?
  var isQuestion = function isQuestion(doc) {
    var endPunct = doc.post();
    var clauses = doc.clauses();

    if (/\?/.test(endPunct) === true) {
      return true;
    } // Has ellipsis at the end means it's probably not a question
    // e.g., Is this just fantasy...


    if (/\.\.$/.test(doc.out('text'))) {
      return false;
    } // Starts with question word, but has a comma, so probably not a question
    // e.g., Why are we caught in a land slide, no escape from reality


    if (doc.has('^#QuestionWord') && doc.has('#Comma')) {
      return false;
    } // Starts with a #QuestionWord
    // e.g., What open your eyes look up to the skies and see


    if (doc.has('^#QuestionWord')) {
      return true;
    } // Second word is a #QuestionWord
    // e.g., I'm what a poor boy
    // case ts.has('^\w+\s#QuestionWord'):
    // return true;
    // is it, do you - start of sentence
    // e.g., Do I need no sympathy


    if (doc.has('^(do|does|did|is|was|can|could|will|would|may) #Noun')) {
      return true;
    } // these are a little more loose..
    // e.g., Must I be come easy come easy go


    if (doc.has('^(have|must) you')) {
      return true;
    } // Clause starts with a question word
    // e.g., Anyway the wind blows, what doesn't really matter to me


    if (clauses.has('^#QuestionWord')) {
      return true;
    } //is wayne gretskzy alive


    if (clauses.has('(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$')) {
      return true;
    } // Probably not a question


    return false;
  };

  var isQuestion_1 = isQuestion;

  /** return sentences ending with '?' */

  var isQuestion_1$1 = function isQuestion_1$1() {
    return this.filter(function (d) {
      return isQuestion_1(d);
    });
  };
  /** return sentences ending with '!' */


  var isExclamation = function isExclamation() {
    return this.filter(function (doc) {
      var term = doc.lastTerm().termList(0);
      return term.hasPost('!');
    });
  };
  /** return sentences with neither a question or an exclamation */


  var isStatement = function isStatement() {
    return this.filter(function (doc) {
      var term = doc.lastTerm().termList(0);
      return !term.hasPost('?') && !term.hasPost('!');
    });
  };
  /** 'he is.' -> 'he is!' */


  var toExclamation = function toExclamation() {
    this.post('!');
    return this;
  };
  /** 'he is.' -> 'he is?' */


  var toQuestion = function toQuestion() {
    this.post('?');
    return this;
  };
  /** 'he is?' -> 'he is.' */


  var toStatement = function toStatement() {
    this.post('.');
    return this;
  };

  var questions = {
    isQuestion: isQuestion_1$1,
    isExclamation: isExclamation,
    isStatement: isStatement,
    toExclamation: toExclamation,
    toQuestion: toQuestion,
    toStatement: toStatement
  };

  var useParticiple = function useParticiple(vb) {
    if (vb.has('(could|should|would|may|can|must)')) {
      return true;
    }

    return false;
  };
  /** he walks -> he walked */


  var toPastTense = function toPastTense() {
    this.forEach(function (doc) {
      if (doc.has('#PastTense')) {
        return;
      }

      var obj = parse_1(doc);
      var vb = obj.verb.clone(); // support 'he could drive' -> 'he could have driven'

      if (useParticiple(vb)) {
        vb = vb.verbs().toParticiple();
        obj.verb.replaceWith(vb, false);
      } else {
        //   //do a normal conjugation
        vb = vb.verbs().toPastTense();
        obj.verb.replaceWith(vb, false);
      } // // trailing gerund/future/present are okay, but 'walked and eats' is not


      if (obj.object && obj.object.found && obj.object.has('#PresentTense')) {
        var verbs = obj.object.verbs();
        verbs["if"]('#PresentTense').verbs().toPastTense();
      }
    });
    return this;
  };
  /** he drives -> he has driven */


  var toParticiple = function toParticiple() {
    this.forEach(function (doc) {
      if (doc.has('has #Participle')) {
        return;
      }

      var obj = parse_1(doc);
      var vb = obj.verb.clone();
      vb = vb.verbs().toParticiple();
      obj.verb.replaceWith(vb, false); // trailing gerund/future/present are okay, but 'walked and eats' is not

      if (obj.object && obj.object.found && obj.object.has('#PresentTense')) {
        var verbs = obj.object.verbs();
        verbs["if"]('#PresentTense').verbs().toParticiple();
      }
    });
    return this;
  };
  /** he walked -> he walks */


  var toPresentTense = function toPresentTense() {
    this.forEach(function (doc) {
      var obj = parse_1(doc);
      var isPlural = obj.verb.lookBehind('(i|we) (#Adverb|#Verb)?$').found;
      var vb = obj.verb.clone(); // 'i look', not 'i looks'

      if (isPlural) {
        //quick hack for copula verb - be/am
        if (vb.has('(is|was|am|be)')) {
          vb = vb.replace('will? (is|was|am|be)', 'am');
        } else {
          vb = vb.verbs().toInfinitive();
        }
      } else {
        //'he looks'
        vb = vb.verbs().toPresentTense();
      }

      obj.verb.replaceWith(vb, false); // future is okay, but 'walks and ate' -> 'walks and eats'

      if (obj.object && obj.object.found && obj.object.has('#PastTense')) {
        var verbs = obj.object.verbs();
        verbs["if"]('#PastTense').verbs().toPresentTense();
      }
    });
    return this;
  };
  /**he walked -> he will walk */


  var toFutureTense = function toFutureTense() {
    this.forEach(function (doc) {
      var obj = parse_1(doc);
      var vb = obj.verb.clone();
      vb = vb.verbs().toFutureTense();
      obj.verb.replaceWith(vb, false); //Present is okay, but 'will walk and ate' -> 'will walk and eat'

      if (obj.object && obj.object.found && obj.object.has('(#PastTense|#PresentTense)')) {
        var verbs = obj.object.verbs();
        verbs["if"]('(#PastTense|#PresentTense)').verbs().toInfinitive();
      }
    });
    return this;
  };
  /** the main noun of the sentence */


  var subjects = function subjects() {
    return this.map(function (doc) {
      var res = parse_1(doc);
      return res.subject;
    });
  };
  /** return sentences that are in passive-voice */


  var isPassive = function isPassive() {
    return this["if"]('was #Adverb? #PastTense #Adverb? by'); //haha
  };

  var tense = {
    toPastTense: toPastTense,
    toParticiple: toParticiple,
    toPresentTense: toPresentTense,
    toFutureTense: toFutureTense,
    subjects: subjects,
    isPassive: isPassive
  };

  var phrases_1 = function phrases_1() {
    var arr = [];
    this.forEach(function (s) {
      s = s.splitOn('#VerbPhrase+');
      s = s.splitOn('#NounPhrase+');
      s = s.splitOn('#AdjectivePhrase+');
      arr = arr.concat(s.list);
    });
    return this.buildFrom(arr);
  };

  var phrases = {
    phrases: phrases_1
  };

  var methods = Object.assign({}, append, json, negative, questions, tense, phrases);

  var plugin = function plugin(Doc, world) {
    // our new tags
    world.addTags(tags); // run our tagger

    world.postProcess(tagger_1);
    /**  */

    var Sentences = /*#__PURE__*/function (_Doc) {
      _inherits(Sentences, _Doc);

      var _super = _createSuper(Sentences);

      function Sentences(list, from, w) {
        _classCallCheck(this, Sentences);

        list = list.map(function (p) {
          return p.clone(true);
        });
        return _super.call(this, list, from, w);
      }

      return Sentences;
    }(Doc); // add some aliases


    methods.questions = methods.isQuestion;
    methods.exclamations = methods.isExclamation;
    methods.statements = methods.isStatement; // keep backups of these methods

    methods._prepend = Sentences.prototype.prepend;
    methods._append = Sentences.prototype.append;
    methods._json = Sentences.prototype.json;
    Object.assign(Sentences.prototype, methods);
    /** create a new Sentences object */

    Sentences.prototype.buildFrom = function (list) {
      list = list.map(function (p) {
        return p.clone(true);
      });
      var doc = new Sentences(list, this, this.world);
      return doc;
    };
    /** create a new Doc object */


    Sentences.prototype.toDoc = function () {
      return Doc.prototype.buildFrom(this.list);
    };
    /** overload original sentences() method and return Sentence class**/


    Doc.prototype.sentences = function (n) {
      var arr = [];
      this.list.forEach(function (p) {
        arr.push(p.fullSentence());
      });
      var s = new Sentences(arr, this, this.world);

      if (typeof n === 'number') {
        s = s.get(n);
      }

      return s;
    };

    return Doc;
  };

  var src = plugin;

  return src;

})));
//# sourceMappingURL=compromise-sentences.js.map
};
BundleModuleCode['plugins/nlp/efrt']=function (module,exports,global,process){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.efrt = factory());
}(this, function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var commonPrefix = function(w1, w2) {
	  var len = Math.min(w1.length, w2.length);
	  while (len > 0) {
	    var prefix = w1.slice(0, len);
	    if (prefix === w2.slice(0, len)) {
	      return prefix
	    }
	    len -= 1;
	  }
	  return ''
	};

	/* Sort elements and remove duplicates from array (modified in place) */
	var unique = function(a) {
	  a.sort();
	  for (var i = 1; i < a.length; i++) {
	    if (a[i - 1] === a[i]) {
	      a.splice(i, 1);
	    }
	  }
	};

	var fns = {
	  commonPrefix: commonPrefix,
	  unique: unique
	};

	var Histogram = function() {
	  this.counts = {};
	};

	var methods = {
	  init: function(sym) {
	    if (this.counts[sym] === undefined) {
	      this.counts[sym] = 0;
	    }
	  },
	  add: function(sym, n) {
	    if (n === undefined) {
	      n = 1;
	    }
	    this.init(sym);
	    this.counts[sym] += n;
	  },
	  countOf: function(sym) {
	    this.init(sym);
	    return this.counts[sym]
	  },
	  highest: function(top) {
	    var sorted = [];
	    var keys = Object.keys(this.counts);
	    for (var i = 0; i < keys.length; i++) {
	      var sym = keys[i];
	      sorted.push([sym, this.counts[sym]]);
	    }
	    sorted.sort(function(a, b) {
	      return b[1] - a[1]
	    });
	    if (top) {
	      sorted = sorted.slice(0, top);
	    }
	    return sorted
	  }
	};
	Object.keys(methods).forEach(function(k) {
	  Histogram.prototype[k] = methods[k];
	});
	var histogram = Histogram;

	var BASE = 36;

	var seq = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	var cache = seq.split('').reduce(function(h, c, i) {
	  h[c] = i;
	  return h
	}, {});

	// 0, 1, 2, ..., A, B, C, ..., 00, 01, ... AA, AB, AC, ..., AAA, AAB, ...
	var toAlphaCode = function(n) {
	  if (seq[n] !== undefined) {
	    return seq[n]
	  }
	  var places = 1;
	  var range = BASE;
	  var s = '';

	  for (; n >= range; n -= range, places++, range *= BASE) {}
	  while (places--) {
	    var d = n % BASE;
	    s = String.fromCharCode((d < 10 ? 48 : 55) + d) + s;
	    n = (n - d) / BASE;
	  }
	  return s
	};

	var fromAlphaCode = function(s) {
	  if (cache[s] !== undefined) {
	    return cache[s]
	  }
	  var n = 0;
	  var places = 1;
	  var range = BASE;
	  var pow = 1;

	  for (; places < s.length; n += range, places++, range *= BASE) {}
	  for (var i = s.length - 1; i >= 0; i--, pow *= BASE) {
	    var d = s.charCodeAt(i) - 48;
	    if (d > 10) {
	      d -= 7;
	    }
	    n += d * pow;
	  }
	  return n
	};

	var encoding = {
	  toAlphaCode: toAlphaCode,
	  fromAlphaCode: fromAlphaCode
	};

	var config = {
      SYM_SEP: '|',
	  NODE_SEP: ';',
	  KEY_VAL: ':',
	  STRING_SEP: ',',
	  TERMINAL_PREFIX: '!',
	  BASE: 36
	};

	// Return packed representation of Trie as a string.

	// Return packed representation of Trie as a string.
	//
	// Each node of the Trie is output on a single line.
	//
	// For example Trie("the them there thesis this"):
	// {
	//    "th": {
	//      "is": 1,
	//      "e": {
	//        "": 1,
	//        "m": 1,
	//        "re": 1,
	//        "sis": 1
	//      }
	//    }
	//  }
	//
	// Would be reperesented as:
	//
	// th0
	// e0is
	// !m,re,sis
	//
	// The line begins with a '!' iff it is a terminal node of the Trie.
	// For each string property in a node, the string is listed, along
	// with a (relative!) line number of the node that string references.
	// Terminal strings (those without child node references) are
	// separated by ',' characters.

	var nodeLine = function(self, node) {
	  var line = '',
	    sep = '';

	  if (self.isTerminal(node)) {
	    line += config.TERMINAL_PREFIX;
	  }

	  var props = self.nodeProps(node);
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    if (typeof node[prop] === 'number') {
	      line += sep + prop;
	      sep = config.STRING_SEP;
	      continue
	    }
	    if (self.syms[node[prop]._n]) {
	      line += sep + prop + self.syms[node[prop]._n];
	      sep = '';
	      continue
	    }
	    var ref = encoding.toAlphaCode(node._n - node[prop]._n - 1 + self.symCount);
	    // Large reference to smaller string suffix -> duplicate suffix
	    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {
	      ref = node[prop]._g;
	      line += sep + prop + ref;
	      sep = config.STRING_SEP;
	      continue
	    }
	    line += sep + prop + ref;
	    sep = '';
	  }
	  return line
	};

	var analyzeRefs = function(self, node) {
	  if (self.visited(node)) {
	    return
	  }
	  var props = self.nodeProps(node, true);
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    var ref = node._n - node[prop]._n - 1;
	    // Count the number of single-character relative refs
	    if (ref < config.BASE) {
	      self.histRel.add(ref);
	    }
	    // Count the number of characters saved by converting an absolute
	    // reference to a one-character symbol.
	    self.histAbs.add(node[prop]._n, encoding.toAlphaCode(ref).length - 1);
	    analyzeRefs(self, node[prop]);
	  }
	};

	var symbolCount = function(self) {
	  self.histAbs = self.histAbs.highest(config.BASE);
	  var savings = [];
	  savings[-1] = 0;
	  var best = 0,
	    sCount = 0;
	  var defSize = 3 + encoding.toAlphaCode(self.nodeCount).length;
	  for (var sym = 0; sym < config.BASE; sym++) {
	    if (self.histAbs[sym] === undefined) {
	      break
	    }
	    savings[sym] =
	      self.histAbs[sym][1] -
	      defSize -
	      self.histRel.countOf(config.BASE - sym - 1) +
	      savings[sym - 1];
	    if (savings[sym] >= best) {
	      best = savings[sym];
	      sCount = sym + 1;
	    }
	  }
	  return sCount
	};

	var numberNodes = function(self, node) {
	  // Topological sort into nodes array
	  if (node._n !== undefined) {
	    return
	  }
	  var props = self.nodeProps(node, true);
	  for (var i = 0; i < props.length; i++) {
	    numberNodes(self, node[props[i]]); //recursive
	  }
	  node._n = self.pos++;
	  self.nodes.unshift(node);
	};

	var pack = function(self) {
	  self.nodes = [];
	  self.nodeCount = 0;
	  self.syms = {};
	  self.symCount = 0;
	  self.pos = 0;
	  // Make sure we've combined all the common suffixes
	  self.optimize();

	  self.histAbs = new histogram();
	  self.histRel = new histogram();

	  numberNodes(self, self.root);
	  self.nodeCount = self.nodes.length;

	  self.prepDFS();
	  analyzeRefs(self, self.root);
	  self.symCount = symbolCount(self);
	  for (var sym = 0; sym < self.symCount; sym++) {
	    self.syms[self.histAbs[sym][0]] = encoding.toAlphaCode(sym);
	  }
	  for (var i = 0; i < self.nodeCount; i++) {
	    self.nodes[i] = nodeLine(self, self.nodes[i]);
	  }
	  // Prepend symbols
	  for (var sym = self.symCount - 1; sym >= 0; sym--) {
	    self.nodes.unshift(
	      encoding.toAlphaCode(sym) +
	        config.KEY_VAL +
	        encoding.toAlphaCode(self.nodeCount - self.histAbs[sym][0] - 1)
	    );
	  }

	  return self.nodes.join(config.NODE_SEP)
	};

	var pack_1 = pack;

	var NOT_ALLOWED = new RegExp('[0-9A-Z,;!:|]'); //characters banned from entering the trie

	var methods$1 = {
	  // Insert words from one big string, or from an array.
	  insertWords: function(words) {
	    if (words === undefined) {
	      return
	    }
	    if (typeof words === 'string') {
	      words = words.split(/[^a-zA-Z]+/);
	    }
	    for (var i = 0; i < words.length; i++) {
	      words[i] = words[i].toLowerCase();
	    }
	    fns.unique(words);
	    for (var i = 0; i < words.length; i++) {
	      if (words[i].match(NOT_ALLOWED) === null) {
	        this.insert(words[i]);
	      }
	    }
	  },

	  insert: function(word) {
	    this._insert(word, this.root);
	    var lastWord = this.lastWord;
	    this.lastWord = word;

	    var prefix = fns.commonPrefix(word, lastWord);
	    if (prefix === lastWord) {
	      return
	    }

	    var freeze = this.uniqueNode(lastWord, word, this.root);
	    if (freeze) {
	      this.combineSuffixNode(freeze);
	    }
	  },

	  _insert: function(word, node) {
	    var prefix, next;

	    // Duplicate word entry - ignore
	    if (word.length === 0) {
	      return
	    }

	    // Do any existing props share a common prefix?
	    var keys = Object.keys(node);
	    for (var i = 0; i < keys.length; i++) {
	      var prop = keys[i];
	      prefix = fns.commonPrefix(word, prop);
	      if (prefix.length === 0) {
	        continue
	      }
	      // Prop is a proper prefix - recurse to child node
	      if (prop === prefix && typeof node[prop] === 'object') {
	        this._insert(word.slice(prefix.length), node[prop]);
	        return
	      }
	      // Duplicate terminal string - ignore
	      if (prop === word && typeof node[prop] === 'number') {
	        return
	      }
	      next = {};
	      next[prop.slice(prefix.length)] = node[prop];
	      this.addTerminal(next, word = word.slice(prefix.length));
	      delete node[prop];
	      node[prefix] = next;
	      this.wordCount++;
	      return
	    }

	    // No shared prefix.  Enter the word here as a terminal string.
	    this.addTerminal(node, word);
	    this.wordCount++;
	  },

	  // Add a terminal string to node.
	  // If 2 characters or less, just add with value == 1.
	  // If more than 2 characters, point to shared node
	  // Note - don't prematurely share suffixes - these
	  // terminals may become split and joined with other
	  // nodes in this part of the tree.
	  addTerminal: function(node, prop) {
	    if (prop.length <= 1) {
	      node[prop] = 1;
	      return
	    }
	    var next = {};
	    node[prop[0]] = next;
	    this.addTerminal(next, prop.slice(1));
	  },

	  // Well ordered list of properties in a node (string or object properties)
	  // Use nodesOnly==true to return only properties of child nodes (not
	  // terminal strings.
	  nodeProps: function(node, nodesOnly) {
	    var props = [];
	    for (var prop in node) {
	      if (prop !== '' && prop[0] !== '_') {
	        if (!nodesOnly || typeof node[prop] === 'object') {
	          props.push(prop);
	        }
	      }
	    }
	    props.sort();
	    return props
	  },

	  optimize: function() {
	    this.combineSuffixNode(this.root);
	    this.prepDFS();
	    this.countDegree(this.root);
	    this.prepDFS();
	    this.collapseChains(this.root);
	  },

	  // Convert Trie to a DAWG by sharing identical nodes
	  combineSuffixNode: function(node) {
	    // Frozen node - can't change.
	    if (node._c) {
	      return node
	    }
	    // Make sure all children are combined and generate unique node
	    // signature for this node.
	    var sig = [];
	    if (this.isTerminal(node)) {
	      sig.push('!');
	    }
	    var props = this.nodeProps(node);
	    for (var i = 0; i < props.length; i++) {
	      var prop = props[i];
	      if (typeof node[prop] === 'object') {
	        node[prop] = this.combineSuffixNode(node[prop]);
	        sig.push(prop);
	        sig.push(node[prop]._c);
	      } else {
	        sig.push(prop);
	      }
	    }
	    sig = sig.join('-');

	    var shared = this.suffixes[sig];
	    if (shared) {
	      return shared
	    }
	    this.suffixes[sig] = node;
	    node._c = this.cNext++;
	    return node
	  },

	  prepDFS: function() {
	    this.vCur++;
	  },

	  visited: function(node) {
	    if (node._v === this.vCur) {
	      return true
	    }
	    node._v = this.vCur;
	    return false
	  },

	  countDegree: function(node) {
	    if (node._d === undefined) {
	      node._d = 0;
	    }
	    node._d++;
	    if (this.visited(node)) {
	      return
	    }
	    var props = this.nodeProps(node, true);
	    for (var i = 0; i < props.length; i++) {
	      this.countDegree(node[props[i]]);
	    }
	  },

	  // Remove intermediate singleton nodes by hoisting into their parent
	  collapseChains: function(node) {
	    var prop, props, child, i;
	    if (this.visited(node)) {
	      return
	    }
	    props = this.nodeProps(node);
	    for (i = 0; i < props.length; i++) {
	      prop = props[i];
	      child = node[prop];
	      if (typeof child !== 'object') {
	        continue
	      }
	      this.collapseChains(child);
	      // Hoist the singleton child's single property to the parent
	      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {
	        delete node[prop];
	        prop += child._g;
	        node[prop] = child[child._g];
	      }
	    }
	    // Identify singleton nodes
	    if (props.length === 1 && !this.isTerminal(node)) {
	      node._g = prop;
	    }
	  },

	  isTerminal: function(node) {
	    return !!node['']
	  },

	  // Find highest node in Trie that is on the path to word
	  // and that is NOT on the path to other.
	  uniqueNode: function(word, other, node) {
	    var props = this.nodeProps(node, true);
	    for (var i = 0; i < props.length; i++) {
	      var prop = props[i];
	      if (prop === word.slice(0, prop.length)) {
	        if (prop !== other.slice(0, prop.length)) {
	          return node[prop]
	        }
	        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop])
	      }
	    }
	    return undefined
	  },

	  pack: function() {
	    return pack_1(this)
	  }
	};

	/*
	 A JavaScript implementation of a Trie search datastructure.
	Each node of the Trie is an Object that can contain the following properties:
	      '' - If present (with value == 1), the node is a Terminal Node - the prefix
	          leading to this node is a word in the dictionary.
	      numeric properties (value == 1) - the property name is a terminal string
	          so that the prefix + string is a word in the dictionary.
	      Object properties - the property name is one or more characters to be consumed
	          from the prefix of the test string, with the remainder to be checked in
	          the child node.
	      '_c': A unique name for the node (starting from 1), used in combining Suffixes.
	      '_n': Created when packing the Trie, the sequential node number
	          (in pre-order traversal).
	      '_d': The number of times a node is shared (it's in-degree from other nodes).
	      '_v': Visited in DFS.
	      '_g': For singleton nodes, the name of it's single property.
	 */
	var Trie = function(words) {
	  this.root = {};
	  this.lastWord = '';
	  this.suffixes = {};
	  this.suffixCounts = {};
	  this.cNext = 1;
	  this.wordCount = 0;
	  this.insertWords(words);
	  this.vCur = 0;
	};
	Object.keys(methods$1).forEach(function(k) {
	  Trie.prototype[k] = methods$1[k];
	});
	var trie = Trie;

	var isArray = function(input) {
	  return Object.prototype.toString.call(input) === '[object Array]'
	};

	var handleFormats = function(input) {
	  //null
	  if (input === null || input === undefined) {
	    return {}
	  }
	  //string
	  if (typeof input === 'string') {
	    return input.split(/ +/g).reduce(function(h, str) {
	      h[str] = true;
	      return h
	    }, {})
	  }
	  //array
	  if (isArray(input)) {
	    return input.reduce(function(h, str) {
	      h[str] = true;
	      return h
	    }, {})
	  }
	  //object
	  return input
	};

	//turn an array into a compressed string
	var pack$1 = function(obj) {
	  obj = handleFormats(obj);
	  //pivot into categories:
	  var flat = Object.keys(obj).reduce(function(h, k) {
	    var val = obj[k];
	    //array version-
	    //put it in several buckets
	    if (isArray(val)) {
	      for (var i = 0; i < val.length; i++) {
	        h[val[i]] = h[val[i]] || [];
	        h[val[i]].push(k);
	      }
	      return h
	    }
	    //normal string/boolean version
	    if (h.hasOwnProperty(val) === false) {
	      //basically h[val]=[]  - support reserved words
	      Object.defineProperty(h, val, {
	        writable: true,
	        enumerable: true,
	        configurable: true,
	        value: []
	      });
	    }
	    h[val].push(k);
	    return h
	  }, {});
	  //pack each into a compressed string
	  Object.keys(flat).forEach(function(k) {
	    var t = new trie(flat[k]);
	    flat[k] = t.pack();
	  });
	  // flat = JSON.stringify(flat, null, 0);

	  return Object.keys(flat)
	    .map(function (k) {
	      return k + ':' + flat[k]
	    })
	    .join('|')

	  // return flat;
	};
	var pack_1$1 = pack$1;

	//the symbols are at the top of the array.
	var symbols = function(t) {
	  //... process these lines
	  var reSymbol = new RegExp('([0-9A-Z]+):([0-9A-Z]+)');
	  for (var i = 0; i < t.nodes.length; i++) {
	    var m = reSymbol.exec(t.nodes[i]);
	    if (!m) {
	      t.symCount = i;
	      break
	    }
	    t.syms[encoding.fromAlphaCode(m[1])] = encoding.fromAlphaCode(m[2]);
	  }
	  //remove from main node list
	  t.nodes = t.nodes.slice(t.symCount, t.nodes.length);
	};

	// References are either absolute (symbol) or relative (1 - based)
	var indexFromRef = function(trie, ref, index) {
	  var dnode = encoding.fromAlphaCode(ref);
	  if (dnode < trie.symCount) {
	    return trie.syms[dnode]
	  }
	  return index + dnode + 1 - trie.symCount
	};

	var toArray = function(trie) {
	  var all = [];
	  var crawl = function (index, pref) {
	    var node = trie.nodes[index];
	    if (node[0] === '!') {
	      all.push(pref);
	      node = node.slice(1); //ok, we tried. remove it.
	    }
	    var matches = node.split(/([A-Z0-9,]+)/g);
	    for (var i = 0; i < matches.length; i += 2) {
	      var str = matches[i];
	      var ref = matches[i + 1];
	      if (!str) {
	        continue
	      }

	      var have = pref + str;
	      //branch's end
	      if (ref === ',' || ref === undefined) {
	        all.push(have);
	        continue
	      }
	      var newIndex = indexFromRef(trie, ref, index);
	      crawl(newIndex, have);
	    }
	  };
	  crawl(0, '');
	  return all
	};

	//PackedTrie - Trie traversal of the Trie packed-string representation.
	var unpack = function(str) {
	  var trie = {
	    nodes: str.split(';'), //that's all ;)!
	    syms: [],
	    symCount: 0
	  };
	  //process symbols, if they have them
	  if (str.match(':')) {
	    symbols(trie);
	  }
	  return toArray(trie)
	};

	var unpack_1 = unpack;

	var unpack_1$1 = function(str) {
	  //turn the weird string into a key-value object again
	  var obj = str.split('|').reduce(function (h, s) {
	    var arr = s.split(':');
	    h[arr[0]] = arr[1];
	    return h
	  }, {});
	  var all = {};
	  Object.keys(obj).forEach(function(cat) {
	    var arr = unpack_1(obj[cat]);
	    //special case, for botched-boolean
	    if (cat === 'true') {
	      cat = true;
	    }
	    for (var i = 0; i < arr.length; i++) {
	      var k = arr[i];
	      if (all.hasOwnProperty(k) === true) {
	        if (Array.isArray(all[k]) === false) {
	          all[k] = [all[k], cat];
	        } else {
	          all[k].push(cat);
	        }
	      } else {
	        all[k] = cat;
	      }
	    }
	  });
	  return all
	};

    // Create a fast symbol lexer from packed string (about 2-5 times slower than unpacked hash table)
    var lexer = function (packed) {
      var lex={};
      var symbols = packed.split(config.SYM_SEP);
      function lexit (treestr) {
        var levels = treestr.split(';');
//        print(levels);
        return function (text) {
          var scannerOff=0,level=0,jump,shift,startOff=0;
          for(var textOff=0;;) {
            var current = levels[level];
// print(level,textOff,scannerOff,text[textOff],current[scannerOff],/[0-9A-Z]/.test(current[scannerOff]));
            if (current[scannerOff]==undefined) return true; // terminal; all chars consumed
            if (current[scannerOff]==',' && text[textOff]==undefined) return true; // terminal; all chars consumed
            if (current[scannerOff]==',') scannerOff++;
            if (/[0-9A-Z]/.test(current[scannerOff])) {
              jump = 0;
              // BASE36 encoding !!!
              var code='';
              while(/[0-9A-Z]/.test(current[scannerOff])) {
                code += current[scannerOff++];
              }
              
              level += (fromAlphaCode(code)+1); // delta
              scannerOff=0;
              startOff=textOff;
              jump=undefined;
              continue;
            }
            if (current[scannerOff]=='!' && text[textOff]==undefined) return true;
            else if (current[scannerOff]=='!') scannerOff++;
            if (current[scannerOff]==text[textOff]) {
              textOff++;scannerOff++;
            } else {
              // skip to next pattern on current level (starts after comma or jump number)
              while (current[scannerOff]!=undefined && !(/[0-9A-Z]/.test(current[scannerOff])) && current[scannerOff]!=',') 
               scannerOff++;
              if (current[scannerOff]==',') scannerOff++;
              else while (current[scannerOff]!=undefined && (/[0-9A-Z]/.test(current[scannerOff]))) scannerOff++;
              if (current[scannerOff]==undefined) return false; // no matching; end of pattern list on this level
              textOff=startOff;
            }
          }
          return text[textOff]==undefined && 
                 (current[scannerOff]==undefined||current[scannerOff]==','||current[scannerOff]=='!');
        }
      }
      symbols.forEach(function (line) {
        var tokens=line.split(':');
        lex[tokens[0]]=lexit(tokens[1]);
      });
      return lex;
    };
    
	var src = createCommonjsModule(function (module) {
	var efrt = {
      lexer : lexer,
	  pack: pack_1$1,
	  unpack: unpack_1$1
	};

	//and then all-the-exports...
	if (typeof self !== 'undefined') {
	  self.efrt = efrt; // Web Worker
	} else if (typeof window !== 'undefined') {
	  window.efrt = efrt; // Browser
	} else if (typeof commonjsGlobal !== 'undefined') {
	  commonjsGlobal.efrt = efrt; // NodeJS
	}
	//then for some reason, do this too!
	{
	  module.exports = efrt;
	}
	});

	return src;

}));
};

var Base64=Require('os/base64');
module.exports = Require('plugins/nlp/nlp.js');
if (typeof window != 'undefined') for(var p in module.exports) window[p]=module.exports[p];
return module.exports;
