#!/usr/bin/node
var CoreModule = {};
CoreModule['crypto']='crypto';
CoreModule['util']='util';
CoreModule['http']='http';
CoreModule['fs']='fs';
CoreModule['stream']='stream';
CoreModule['url']='url';
CoreModule['os']='os';
CoreModule['net']='net';
CoreModule['zlib']='zlib';
CoreModule['path']='path';
CoreModule['dgram']='dgram';
CoreModule['child_process']='child_process';
CoreModule['events']='events';
CoreModule['string_decoder']='string_decoder';
CoreModule['assert']='assert';
CoreModule['buffer']='buffer';

module.paths.push(process.env.HOME+"/.node_modules"); //append custom path to NODE_PATH
module.paths.push(process.env.HOME+"/node_modules"); //append custom path to NODE_PATH
module.paths.push(process.env.PWD); //append custom path to NODE_PATH
var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
var Fs = require("fs");
PATHS=[process.cwd(),".","/home/sbosse/proj/workbook/src","/opt/workbook/lib"];
function _isdir(path) {
  var stats=Fs.lstatSync(path);
  return stats.isDirectory()};
function _search(index,file) {
  if (PATHS.length==index) return file;
  var path=PATHS[index];
  if (Fs.existsSync(path+"/"+file+".js")) return path+"/"+file+".js";
  else if (Fs.existsSync(path+"/"+file) && !_isdir(path+"/"+file)) return path+"/"+file;
  else return _search(index+1,file);
 }
global.Require=function(modupath) { 
  var file,filepath;
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}; var module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports);
  else { try {  file=_search(0,modupath); module = require(file)}
  catch (e) { var more="";
   if ((e.name==="SyntaxError"||e.name==="TypeError") && file) {
      var src=Fs.readFileSync(file,"utf8");
      var Esprima = Require("parser/esprima");
      try {
        var ast = Esprima.parse(src, { tolerant: true, loc:true });
        if (ast.errors && ast.errors.length>0) more = ", "+ast.errors[0];
      } catch (e) {
        if (e.lineNumber) more = ", in line "+e.lineNumber;
      }
   }
   console.log("Require import of "+modupath+" ("+file+") failed: "+e+more);
   // if (e.stack) console.log(e.stack);
   throw e; // process.exit(-1);
  }}
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
global.FilesEmbedded = {};
global.FileEmbedd = function (path,format) {};
global.FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
Import = function (files,exports) {
  new Function("SourceMap", "exports", function() {
   var code = files.map(function(file) {
     return FileEmbedded(file, "utf8");
   });
   return code.join("\n\n");
 }())({}, exports);
}
global.Import = Import;
global.TARGET='node';

BundleModuleCode['com/io']=function (module,exports){
/**
 **      ==================================
 **      OOOO   OOOO OOOO  O      O   OOOO
 **      O   O  O    O     O     O O  O   O
 **      O   O  O    O     O     O O  O   O
 **      OOOO   OOOO OOOO  O     OOO  OOOO
 **      O   O     O    O  O    O   O O   O
 **      O   O     O    O  O    O   O O   O
 **      OOOO   OOOO OOOO  OOOO O   O OOOO
 **      ==================================
 **      BSSLAB, Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR.
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2020 BSSLAB
 **    $CREATED:     sbosse on 3/28/15.
 **    $VERSION:     1.7.1X
 **
 **    $INFO:
 *
 * This module encapsulates all IO operations (except networking) supporting
 * node.js applications.
 *
 **    $ENDOFINFO
 */

if (global.TARGET=='node')  { 

 /*
  ************
  ** Node.js
  ************
  */
 var util = require('util');
 var GetEnv = Require('os/getenv');
 var Base64 = Require('os/base64');
 var Fs = require('fs');
 var os = require('os');
 var child = require('child_process');

 var stderr_fun = function (str) { process.stderr.write(str); };
 var stdout_fun = function (str) { process.stdout.write(str); };

 /*
  ** node.js specific
  */

 var tracefile = undefined;
 var tracing = true;

 /**
 * Open a module and append all exported properties to the current global object.
 * (top-level scope)
 */
 global.open = function(name,as) {
   var module = Require(name);
   for (var p in module) {
     global[p] = module[p];
   };
   if (as) global[as]=module;
 }

/*
 ** node.js
 */
var io = {
    checkOptions : function(options,defaultOptions) {
      return Object.assign({}, defaultOptions||{}, options) },
      
    checkOption : function (option,defaultOption) { 
      return option==undefined? defaultOption:option },

    config: {
        columns:undefined,
        rows:undefined
    },
    /**************
     ** FILE IO
     ***************/
    /**
     *
     * @param fd
     */
    close: function (fd) {
        Fs.closeSync(fd);
    },
    /**
     *
     * @param path
     */
    exists: function (path) {
        return Fs.existsSync(path);
    },
    /**
     *
     * @param path
     */
    file_exists: function (path) {
        return Fs.existsSync(path);
    },
    /** Search a file by iterating global PATH variable.
     *
     * @param name  File name or partial (relative) path
     */
    file_search: function (name) {
        // Expecting global PATH variable !?
        if (this.file_exists(name)) return name; 
        else if (typeof PATH !== 'undefined') {
          for (var p in PATH) {
            if (this.file_exists(PATH[p]+'/'+name)) return (PATH[p]+'/'+name);
          }
          return undefined;
        } else return undefined;
    },
    /**
     *
     * @param path
     * @returns {number}
     */
    file_size: function (path) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            return stat.size;
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param timekind a c m
     * @returns {number}
     */
    file_time: function (path,timekind) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            switch (timekind) {
                case 'a': return stat.atime.getTime()/1000;
                case 'c': return stat.ctime.getTime()/1000;
                case 'm': return stat.mtime.getTime()/1000;
                default: return stat.mtime.getTime()/1000;
            }
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param mode
     * @returns {*}
     */
    open: function (path, mode) {
        return Fs.openSync(path, mode);
    },
    /**
     *
     * @param fd
     * @param len
     * @param foff
     */
    read: function (fd, len, foff) {
        // TODO
    },
    /**
     *
     * @param path
     * @returns {string|undefined}
     */
    read_file: function (path) {
        try {
            return Fs.readFileSync(path,'utf8');
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    read_file_bin: function (path) {
        try {
            return Fs.readFileSync(path);
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param fd
     */
    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {number}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return Fs.readSync(fd, buf, boff, len, foff);
    },
    /**
     *
     * @param fd
     */
    sync: function (fd) {
        Fs.fsyncSync(fd);
    },
    
    time: function () {
      return Date.now()
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {number}
     */
    write: function (fd, data, foff) {
        return Fs.writeSync(fd, data, foff);
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {number}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return Fs.writeSync(fd, buf, bpos, blen, foff);
    },
    /**
     *
     * @param path
     * @param {string} buf
     */
    write_file: function (path,str) {
        try {
            Fs.writeFileSync(path, str, 'utf8');
            return str.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param path
     * @param buf
     * @returns {*}
     */
    write_file_bin: function (path,buf) {
        try {
            Fs.writeFileSync(path, buf, 'binary');
            return buf.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param fd
     * @param {string} str
     * @returns {number}
     */
    write_line: function (fd, str) {
        return Fs.writeSync(fd, str+NL);
    },

    /****************
     ** CONSOLE IO
     ****************/
    /**
     *
     * @param msg
     */
    debug: function (msg) {
        console.error('Debug: ' + msg);
    },
    /**
     *
     * @param msg
     */
    err: function (msg) {
        console.error('Error: ' + msg);
        throw Error(msg);
    },
    /**
     *
     * @param msg
     */
    fail: function (msg) {
        console.error('Fatal Error: ' + msg);
        process.exit(0);
    },
    /**
     *
     * @param obj
     */
    inspect: function (obj,depth) {return util.inspect(obj,{showHidden: false, 
                                                            depth: depth?depth:2})},

    /**
     * 
     */
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (!e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        if (where==undefined) this.out(e);
        else this.out(where+': '+e);
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
     /**
     *
     * @param e
     * @param where
     */
    sprintstack: function (e) {
        var str='';
        if (e==_ || !e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .replace(/^Object.eval\s*\(/gm, '')
            .split('\n');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                if (str!='') str += '\n';
                str += '  at '+line;
            }
        }
        return str;
    },
   /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    /**
     *
     * @param msg
     */
    out: function (msg) {
        console.warn(msg)
    },
    /**
     *
     * @param msg
     */
    warn: function (msg) {
        console.warn('Warning: ' + msg);
    },
    /**
     *
     * @param fun
     */
    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    /**
     *
     * @param fun
     */
    set_stdout: function(fun) {
        stdout_fun=fun;
    },
    /**
     *
     * @param msg
     */
    stderr: function (msg) {
        stderr_fun(msg);
    },
    /**
     *
     * @param msg
     */
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            Fs.writeSync(tracefile, '[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        tracefile = Fs.openSync(path, 'w+');
        if (tracefile != undefined) this.tracing = false;
    },

    /**************
     ** Process control
     ***************/
    exit: function (n) {
        process.exit(n);
    },
    /**
     *
     * @returns {*} RSS HEAP in kBytes {data,heap}
     */
    mem: function () {
        var mem = process.memoryUsage();
        return {data:(mem.rss/1024)|0,heap:(mem.heapUsed/1024)|0};
    },
    /****************************
     ** Environment and Arguments
     ****************************/
    getenv: function (name, def) {
        return GetEnv(name, def);
    },
    workdir: function () {
        return this.getenv('PWD','');
    },

    /**
     *  @return {string []}
     */
    getargs: function () {
        return process.argv;
    },

    sleep: function(delay) {
      var start = new Date().getTime();
      while (new Date().getTime() < start + delay);
    },
    
    /**
     *  Process management
     */
    fork: child.fork,
    exec: child.exec,
    spawn: child.spawn,

    /**
     * OS
     */
    hostname: os.hostname

  };
} else {
 /*
  ************
  ** Browser
  ************
  */
  var tracing = true;
  var stderr_fun = function (str) { console.log(str); };
  var stdout_fun = function (str) { console.log(str); };
  var args=[];

  /**
  * Open a module and append all exported properties to the current global object.
  * (top-level scope)
  */
  global.open = function(name,as) {
    var module = Require(name);
    for (var p in module) {
      global[p] = module[p];
    };
    if (as) global[as]=module;
  }
  
  var io = {
    /*
    ************
    ** Browser
    ************
    */
    /*
     ** FILE IO
     * TODO WebStorage
     */
    close: function (fd) {
        return;
    },
    exists: function (path) {
        return false;
    },
    open: function (path, mode) {
        var fd = Fs.openSync(path, mode);
        return fd;
    },

    read: function (fd, len, foff) {
        // TODO
    },
    read_file: function (path) {
        return '';
    },

    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {*}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return -1;
    },
    sync: function (fd) {
        return;
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {*}
     */
    write: function (fd, data, foff) {
        return -1;
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {*}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return -1;
    },

    /*
     ** CONSOLE IO
     */
    debug: function (msg) {
        stderr_fun('Debug: ' + msg);
    },
    err: function (msg) {
        stderr_fun('Error: ' + msg);
        throw Error(msg);
    },
    fail: function (msg) {
        stderr_fun('Fatal Error: ' + msg);
    },
    inspect: function (obj) {
        return;
    },
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        stderr_fun('Stack Trace');
        stderr_fun('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                stderr_fun(line);
            }
        }
        stderr_fun('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (where==undefined) stderr_fun(e);
        else stderr_fun(where+': '+e);
    },
    /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    out: function (msg) {
        stdout_fun(msg)
    },
    warn: function (msg) {
        stderr_fun('Warning: ' + msg);
    },


    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    set_stdout: function(fun) {
        stdout_fun=fun;
    },

    stderr: function (msg) {
        stderr_fun(msg);
    },
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            this.log('[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        return undefined;
    },

    exit: function (n) {
        return;
    },
    getenv: function (name, def) {
        return def;
    },
    workdir: function () {
        return '';
    },
    /**
     *  @return {string []}
     */
    getargs: function () {
        return args;
    },
    set_args: function (argv) {
        args=argv;
    },
    inspect: function (o) {return '?'}
  };
}  
module.exports = io;
};
BundleModuleCode['os/getenv']=function (module,exports){
var util = require("util");
var url = require("url");

var fallbacksDisabled = false;

function _value(varName, fallback) {
  var value = process.env[varName];
  if (value === undefined) {
    if (fallback === undefined) {
      throw new Error('GetEnv.Nonexistent: ' + varName + ' does not exist ' +
                      'and no fallback value provided.');
    }
    if (fallbacksDisabled) {
      throw new Error('GetEnv.DisabledFallbacks: ' + varName + ' relying on fallback ' + 
                      'when fallbacks have been disabled');
    }
    return '' + fallback;
  }
  return value;
}

var convert = {
  string: function(value) {
    return '' + value;
  },
  int: function(value) {
    var isInt = value.match(/^-?\d+$/);
    if (!isInt) {
      throw new Error('GetEnv.NoInteger: ' + value + ' is not an integer.');
    }

    return +value;
  },
  float: function(value) {
    var isInfinity = (+value === Infinity || +value === -Infinity);
    if (isInfinity) {
      throw new Error('GetEnv.Infinity: ' + value + ' is set to +/-Infinity.');
    }

    var isFloat = !(isNaN(value) || value === '');
    if (!isFloat) {
      throw new Error('GetEnv.NoFloat: ' + value + ' is not a number.');
    }

    return +value;
  },
  bool: function(value) {
    var isBool = (value === 'true' || value === 'false');
    if (!isBool) {
      throw new Error('GetEnv.NoBoolean: ' + value + ' is not a boolean.');
    }

    return (value === 'true');
  },
  url: url.parse
};

function converter(type) {
  return function(varName, fallback) {
    if(typeof varName == 'string') { // default
      var value = _value(varName, fallback);
      return convert[type](value);
    } else { // multibert!
      return getenv.multi(varName);
    }
  };
};

var getenv = converter('string');

Object.keys(convert).forEach(function(type) {
  getenv[type] = converter(type);
});

getenv.array = function array(varName, type, fallback) {
  type = type || 'string';
  if (Object.keys(convert).indexOf(type) === -1) {
    throw new Error('GetEnv.ArrayUndefinedType: Unknown array type ' + type);
  }
  var value = _value(varName, fallback);
  return value.split(/\s*,\s*/).map(convert[type]);
};

getenv.multi = function multi(spec) {
  var key, value;
  var result = {};
  for(var key in spec) {
    var value = spec[key];
    if(util.isArray(value)) { // default value & typecast
      switch(value.length) {
        case 1: // no default value
        case 2: // no type casting
          result[key] = getenv(value[0], value[1]); // dirty, when case 1: value[1] is undefined
        break;
        case 3: // with typecast
          result[key] = getenv[value[2]](value[0], value[1]);
          break;
        default: // wtf?
          throw('getenv.multi(): invalid spec');
          break;
      }
    } else { // value or throw
      result[key] = getenv(value);
    }
  }
  return result;
};

getenv.disableFallbacks = function() {
  fallbacksDisabled = true;
};

getenv.enableFallbacks = function() {
  fallbacksDisabled = false;
};

module.exports = getenv;
};
BundleModuleCode['os/base64']=function (module,exports){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['com/path']=function (module,exports){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['com/sprintf']=function (module,exports){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['top/worksh.js']=function (module,exports){
/**
 * WorkBook Shell (CLI)
 */

/* Soem hacks */
process.noDeprecation = true

var fs = require('fs');
var bd = Require('aux/build');
var linereader = Require('linereader');

if (typeof print == 'undefined') print=console.log;

var execSync  = require("child_process").execSync;

// Optional websocket interface
var WebSocket;
try { WebSocket = require('ws') } catch (e) { /* no ws module installed */ }


Require('plugins/com/utils.js');
Require('plugins/com/code.js');
Require('plugins/math/math.js')
Require('plugins/db/db.js')
Require('plugins/fft/fft.js');
Require('plugins/csp/csp.js');
ML          = Require('plugins/ml/ml.js')
sprintf     = Require('aux/sprintf.js').sprintf;
esprima     = Require('parser/esprima.js');
var numpy   = Require('plugins/numpy/numpy');
Code.worker = Require('plugins/com/worker.js');
Code.barrier = Code.worker.Barrier;
Code.mutex = Code.worker.Mutex;
Code.semaphore = Code.worker.Semaphore;
Code.sms    = Require('plugins/pcsp/sm.js');
Code.Worker = Require('Worker.js');
var BufferObjects = Require('plugins/pcsp/bobj.js');
// Code.webworker = Require('plugins/com/webworker.js');
var http    = require('http');
var fs      = Require('fs');
var cache   = Require('cache');
var yaml    = Require('yaml');
var line    = Require('aux/line/line');
var Http    = Require('plugins/com/Http.js');
var Html    = Require('plugins/html/html.js');
var Encryptor = Require('fpe'); // Format preserving encryption

var PATH = {
  basename : function (path,extension) {
    if (path[path.length-1]=='/') return '/';
    return extension?
            path.split('/').reverse()[0].replace(RegExp(extension.replace(/\./,'\\.')+'$'),'')
            :
            path.split('/').reverse()[0];
  },
  dirname : function (path) {
    var el=path.split('/');
    el.pop();
    return el.join('/');
  },
  
  extension : function (file) {
    return file.replace(/^[^\.]+\./,'');
  }
}

Require('cap.js')

var util = require('util');
inspect = function (o,depth) {
  return util.inspect(o,null,depth);
} 
var csv = Require('parser/papaparse');
var doc = Require('doc/doc');
var readline = Require('com/readline');
var readlineSync = Require('term/readlineSync');
var renderer = doc.Renderer({lazy:true});

Require('doc/table');

var TYPI = Require('signature');
sizeOf = Require('sizeof').sizeOf;
typeOf = TYPI.typeOf;


var Comp    = Require('com/compat');
var Io      = Require('com/io');
_ = undefined;
NL = '\n';

// WorkBook compatible FS API
var FS = {
  linereader : linereader,
  list : async function (dir,cb) {
    function handler(files) {
      if (!files) return;
      files = files.map(function (entry) {
        try {
          var stat=fs.statSync(dir+'/'+entry);
          return {name:entry,dir:stat.isDirectory(),size:stat.size,time:stat.mtime};
        } catch (e)  {};
      }).filter(function (entry) { return entry });
      return [{name:'..',dir:true}].concat(files);
    }
    if (cb) {
      fs.readdir(dir,function (error,list) {
        if (error) cb(error);
        else cb(handler(list))
      })
    } else {
      return new Promise(function (resolve,reject) {
        fs.readdir(dir,function (error,list) {
          if (error) reject(error);
          resolve(handler(list))
        })      
      });
    }
  },
  load : async function(dir,file,mimetype,cb) { 
    mimetype=mimetype||'utf8';
    dir=dir.replace(/^~/,process.env.HOME);
    var path=dir+'/'+file;
    function handler(data) { return mimetype=='binary' && !(data instanceof Buffer)?Buffer.from(data,'binary'):data };
    if (cb) {
      if (mimetype=='binay')
        fs.readFile(path,function (error,data) {
          if (error) cb(error);
          else cb(handler(data));
        });
      else
        fs.readFile(path,mimetype,function (error,data) {
          if (error) cb(error);
          else cb(handler(data));
        });
    } else {
      return new Promise(function (resolve,reject) {
        if (mimetype=='binay')
          fs.readFile(path,function (error,data) {
            if (error) reject(error);
            resolve(handler(data))
          });      
        else
          fs.readFile(path,mimetype,function (error,data) {
            if (error) reject(error);
            resolve(handler(data))
          })      
      });
    }
  },
  save : async function(dir,file,data,mimetype,cb) { 
    mimetype=mimetype||'utf8';
    dir=dir.replace(/^~/,process.env.HOME);
    var path=dir+'/'+file;
    if (cb) {
      fs.writeFile(path,data instanceof Buffer?data:Buffer(data),mimetype,function (error) {
        if (error) cb(error);
        else cb(0)
      })
    } else {
      return new Promise(function (resolve,reject) {
        fs.writeFile(path,data instanceof Buffer?data:Buffer(data),mimetype,function (error) {
          if (error) reject(error);
          resolve(0)
        })      
      });
    }
  },
  shell : async function (exec,dir,cb) {
    var result;
    return result;
  },
  
  workdir : process.cwd()||'/',
}

var options= {
  args:[],
  echo: true,
  modules : {
    csv : csv,
    doc : doc,
    fs  : fs,
    readline : readline,
    readlineSync : readlineSync,
    yaml : yaml,
  },
  extensions : {
    numpy:numpy,
  },
  nameopts : {length:8, memorable:true, lowercase:true},
  Nameopts : {length:8, memorable:true, uppercase:true},
  output : null,
  renderer : renderer,
  server : false,
  verbose : 0,
  version : '1.20.1 ['+BuildDate+']',
}

function format(line) {
  var msg;
  switch (typeof line) {
    case 'boolean':   msg=line.toString(); break;
    case 'string':    msg=line; break;
    case 'number':    msg=line.toString(); break;
    case 'function':  msg=typeOf(line); break;
    case 'object':    msg=Io.inspect(line); break;
    default: msg='';
  }
  return msg;
}

function help() {
  var lines =[
'watcher(filename,callback,interval?)\n: File watcher with callback on change',
]
  return lines.map(function (item) {
    return item.replace(/\n:/,'\n  ')
  }).join('\n');
}
function fileWatcher(filename,callback,interval) {
  interval=interval||5000;
  var closed,_watcher,_fd,verbose=false,handle={
    close : function () {
      if (closed) return -1;
      closed=true;
      if (_fd) fs.close(_fd,function () {});
      if (_watcher) fs.unwatchFile(filename);
      _fd=null;
      _watcher=null;
      return 0;
    }
  };
  fs.open(filename, 'r', function(err, fd) {
    _fd=fd;
    if (closed) return;
    var size=fs.statSync(filename).size;
    fs.read(fd, new Buffer(size), 0,  size, 0, function(err, bytes, buffer) {
      if (verbose) console.log("err", err, "bytes", bytes, "buffer", buffer.length);
      if (callback) callback(buffer.toString());
    });
    _watcher=fs.watchFile(filename, {interval:interval}, function(cstat, pstat) {
      var delta = cstat.size - pstat.size;
      if (closed || delta <= 0) return;
      fs.read(fd, new Buffer(delta), 0, delta, pstat.size, function(err, bytes, buffer) {
        if (verbose) console.log("err", err, "delta", delta, "bytes", bytes, "buffer", buffer.length);
        if (callback) callback(buffer.toString());
      });
    });
  });
  return handle
}

/** Shell Interpreter Object
*
*/
function Shell (_options) {
  if (!(this instanceof Shell)) return new Shell(_options);
  this.options=Comp.obj.extend(options,_options);
  this.modules=options.modules||{};
  this.events = {};
  this.env = {that:{}};
  global.PATH=PATH;
  global.FS=FS;
  if (!this.options.renderer) {
    if (this.modules.doc) this.options.renderer=this.modules.doc.Renderer({lazy:true}); 
    else 
      this.options.renderer = function (text) {
        return text.replace(/\n:/g,'\n  ');
      }
  }
}

Shell.prototype.cmd = function () { return this.env }


Shell.prototype.emit = function (ev,arg1,arg2,arg3,arg4) {
  if (this.events[ev]) this.events[ev](arg1,arg2,arg3,arg4);
}


Shell.prototype.help = function() {
return this.options.renderer([
'# Usage',
' worksh [-p <serviceurl>]  [-v] [-e <shellcmd>] [script.js] [-- <script args>]',
'# Shell Commands',
'The following shell commands are avaiable:',
'',
].join('\n'));
}

/* Set-up the Interpreter
*
*/

Shell.prototype.init = function(callback) {
  var self=this;

  if (!this.options.server && this.modules.readline) {
    this.rl = this.modules.readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      completer : function (cmdline) {
          var args = Array.filter(String.split(' ', cmdline), function (str) {
              return str != '';
          });
          var completed=cmdline;
          var choices=[];
          return [choices,completed];
      }
    });

    this.rl.on('line', function (line) {
      self.cmdline = line;
      self.process(line)
      self.rl.prompt();
    });

    this.rl.on('close', function () {
    });
    if (this.modules.doc)
      this.output(this.modules.doc.Colors.bold('WorkBook Shell. Version '+this.options.version+' (C) Dr. Stefan Bosse'));
    else
      this.output('WorkBook Shell. Version '+this.options.version+' (C) Dr. Stefan Bosse');    
    this.rl.setPrompt('> ');
    this.rl.prompt();
  } else {
    if (this.options.verbose) this.output('WorkBook Shell. Version '+this.options.version+' (c) Dr. Stefan Bosse');
    // virtuel consoles (remote access)
    if (this.options.proxy) {
      this.consoles = {};
    }
  }
  
  function error(msg) {
    self.error('Error: '+msg);
  }

  this.tasks = [];
  
  this.env = {
    BufferSegment : Code.sms,
    BufferObjects  : BufferObjects,
    cache : cache,
    clear : function () {},
    clock : function () {
      var time=process.hrtime();
      return +time[0] * 1e9 + +time[1];
    },
    Encryptor : Encryptor,
    exit : function () {   process.exit() },
    error : function (msg) {
      if (msg instanceof Error) throw msg;
      else throw new Error(msg)
    },
    // get help () {  return self.help() },
    exists : function (path) { return fs.existsSync(path) },
    interface:TYPI.interface,
    help : function () {
      print(help ())
    },
    iter : Code.iter,
    Html:Html,
    Http:Http,
    json : {
      read : function (path) {
        var data = fs.readFileSync(path,'utf8');
        return JSON.parse(data);
      },
      write : function (path,data) {
        return fs.writeFileSync(path,JSON.stringify(data));
      },
    },
    kill  : Code.kill,
    later : Code.later,
    load:   function (file,mimetype) {
      if (mimetype && mimetype.match(/binary$/)) {
        return fs.readFileSync(file);
      }
      var obj,text = fs.readFileSync(file,'utf8');
      if (!text) return;
      if (!mimetype && file.match(/\.js$/))   mimetype='JS';
      if (!mimetype && file.match(/\.json$/)) mimetype='JSON';
      if (!mimetype && file.match(/\.csv/))   mimetype='CSV';
      
      switch (mimetype && mimetype.replace(/application\//,'')) {
        case 'text': 
          return text;
      };
      if (text.match(/^\s*{/)||text.match(/^\s*\[\s*{/)||text.match(/^\s*\[\s*\[/)) {
      }
      switch (mimetype && mimetype.replace(/application\//,'')) {
          case 'csv':
          case 'CSV':
            obj=self.env.csv.read(text,false,true);
            break;
          case 'javascript': 
          case 'JS': 
          case 'JSOB': 
          case 'jsob': 
            eval('"use strict"; obj = '+text);
            break; 
          case 'json':
          case 'JSON':
          default:
            obj=self.env.ofJSON(text);
      };
      return obj;
    },
    loadc : Require,
    list : function (pat,callback) {
      var path = PATH.dirname(pat);
      if (path=='' && pat[0]=='/') path='/';
      var _pat  = PATH.basename(pat);
      if (_pat) _pat=_pat.replace(/\./g,'\\.').replace(/\*/g,'.+')+'$';
      else _pat='.+$';
      _pat=RegExp(_pat);
      var list = fs.readdirSync(path||'.').filter(function (entry) {
        return _pat.test(entry);
      });
      if (callback) list.forEach(callback);
      return list;
    },
    loop : Code.loop,
    ofCSV : function (source,sep,convert) {
      if (typeof sep == 'boolean') { convert=sep; sep=undefined };
      try {
        csv.parse(source,{
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            data=results.data;
            if (convert) { // first line must be header
              header=data.shift();
              data=data.map(function (row) {
                var r={};
                header.forEach(function (col,i) { r[col]=row[i] });
                return r; 
              }) 
            }
          }
        });
        if (data && data[0].length==1) data=data.map(function (row) { return row[0] });
        return data;
      } catch (e) {
        return e;
      }
    },
  
    ofJSON:  function (text) {
      return JSONfn.parse(text,{})
    },
    
    ofYAML: function (text) {
      return yaml.eval(text);
    },
    
    on : function (event, handler) {
      switch (event) {
        case 'exit': process.on('exit',handler); process.on('SIGINT',function () { process.exit() }); break;
      }
    },
    pairs : function (data,callback) {
      if (Utils.isArray(data))
        for(var i in data) callback(i,data[i]);
      else if (Utils.isObject(data)) {
        var keys = Object.keys(data);
        for(var i in keys) callback(keys[i],data[keys[i]])
      } else if (typeof data == 'string') {
        for(var i in data) callback(i,data[i]);  
      }
    },
    printf : function () {
      return print(sprintf.apply(this,arguments));
    },
    printi : function () {
        var args=arguments,
            msg=Object.keys(args).map(function (index) { return args[index] }),
            id = msg.shift();
        if (id==undefined) {
          id = 0;
          return id;      
        }
        if (msg.length==1) {
          msg=msg[0]; 
          msg=(msg==undefined?'undefined':msg);
          if (typeof msg == 'object') msg=inspect(msg);
        } else {
          msg=msg.map(function (arg) {
            if (typeof arg=='object') return arg==undefined?'undefined':inspect(arg);
            else return arg;
          }).join(' , ');
        }
        line.stdout(msg);
    },
    read : function (path,mimetype) {
      mimetype=mimetype||'utf8';
      return fs.readFileSync(path,mimetype);
    },
    save : function (path,data,mimetype) {
      if (!mimetype && path.match(/\.json$/)) mimetype='JSON';
      if (!mimetype && path.match(/\.csv/)) mimetype='CSV';
      switch (mimetype && mimetype.replace(/application\//,'')) {
        case 'CSV':
          if (!Utils.isArray(data[0]))
            return self.env.csv.write(path,null,data);
          else
            return self.env.csv.write(path,data[0],data.slice(1));
          break;
        case 'JSON':
          if (typeof data == 'object') data=JSON.stringify(data);
          break;
      }
      return Io.write_file(path,data);
    },
    saveStream : function (path,callback) {
      var wstream = fs.createWriteStream(path);
      function writeToStream(i) {
        var next = callback(i);
        if (next!=undefined) {
          if (!wstream.write(next)) {
            // Wait for it to drain then start writing data from where we left off
            wstream.once('drain', function() {
              writeToStream(i + 1);
            });
            return;
          }
        }
        wstream.end();
      }
      writeToStream(0);
    },
    script: function (file) {
      var text=Io.read_file(file);
      text=text.replace(/^#[^\n]+\n/,'');
      if (typeof text != 'string') text=text.toString();
      self.process(null,text);
    },
    schedule : async function () {
      return new Promise(function (resolve,reject) {
        setTimeout(function () {
          var interrupt=Code.interrupt;
          Code.interrupt=false;
          resolve(!interrupt);
        },1);
      });
    },
    signature : TYPI.signature,
    sizeOf    : sizeOf,
    sleep : async function (tmo) {
      return new Promise(function (resolve,reject) {
        setTimeout(resolve,tmo);
      });
    },
    that:Code.this,
    time: function (stamp,extended) {
      function datetimestamp()
      {
        var today = new Date();
        var sToday = (1900+today.getYear()).toString().padStart(2, '0');
        sToday += (today.getMonth()+1).toString().padStart(2, '0');
        sToday += today.getDate().toString().padStart(2, '0');
        sToday += '@';
        sToday += today.getHours().toString().padStart(2, '0');
        sToday += today.getMinutes().toString().padStart(2, '0');
        return sToday;
      }
      function timestamp()
      {
        var today = new Date();
        var sToday = (1900+today.getYear()).toString().padStart(2, '0');
        sToday += '/';
        sToday += (today.getMonth()+1).toString().padStart(2, '0');
        sToday += '/';
        sToday += today.getDate().toString().padStart(2, '0');
        sToday += '@';
        sToday += today.getHours().toString().padStart(2, '0');
        sToday += ':';
        sToday += today.getMinutes().toString().padStart(2, '0');
        sToday += ':';
        sToday += today.getSeconds().toString().padStart(2, '0');
        return sToday;
      }
      
      return stamp?(extended?timestamp():datetimestamp()):Date.now()
    },
    toJSON:  function (o) {
      // return self.jam.Aios.Code.minimize(
      return JSONfn.stringify(o)
    },
    toCSV : function (data,header,sep) {
      var result=[];
      if (!sep) sep=',';
      function wrap(v) {
        if (!quote) return v;
        if (typeof v==Number) return v;
        else return quote+String(v)+quote;
      }
      var d1 = typeof data[0] != 'object';
      if (!header || header.length==0) {
        if (!convert)
          header=d1?['0']:data[0].map(function (x,i) { return String(i) });
        else {
          header=[];
          for (var p in data[0]) {
            header.push(p);
          }
        }
      }
      if (!d1) 
        for(i in data) {
          if (!convert)
            result.push(data[i].map(wrap).join(sep));
          else
            result.push(header.map(function (col) { return data[i][col]}).map(wrap).join(sep));
        }
      else
        for(i in data) {
          if (!convert)
            result.push(wrap(data[i]));
          else
            result.push(wrap(data[i][header[0]]));
        };
        
      return result.join('\n');
    },
    typeOf    : typeOf,    
    watcher : fileWatcher,
    write : function (path,data,mimetype) {
      mimetype=mimetype||'utf8';
      return fs.writeFileSync(path,data,mimetype);
    },
    Worker : Code.Worker,
  }
  this.env.of = {
    csv   : this.env.ofCSV,
    json  : this.env.ofJSON,
    yaml  : this.env.ofYAML,
  };
  this.env.to = {
    csv   : this.env.toCSV,
    json  : this.env.toJSON,
    yaml  : this.env.toYAML,
  };
  this.env.fs = {
    read  : this.env.read,
    write : this.env.write,
    list  : this.env.list,
    get workdir () {
    
    },
  }
  if (this.options.extensions) {
    for(var p in this.options.extensions) this.env[p]=this.options.extensions[p];
  }
  // Module dependent commands
  if (this.modules.http) this.env.http = {
    get: function (url,path,callback) {
      var snd=url2addr(url);
      if (!snd.port) snd.port=80;
      if (!path) path='';
      else if (path.charAt(0)!='/') path = '/'+path;
      if (!self.modules.http.xhr) {
        req = self.modules.http.request({
          host: snd.address,
          port: snd.port,
          path: path,
          method: 'GET',
          keepAlive: true,
          headers: {
          }
        } , function(res) {
          if (res.setEncoding != null) res.setEncoding('utf8');
          var body = '';
          res.on('data', function (chunk) {
            body = body + chunk;
          });
          res.once('end', function () {
            if (callback) callback(body);
          });
        });
        req.once('error', function(err) {
          print('Warning: request to '+addr2url(snd)+' failed: '+err);
        });
        req.end();
      } else {
        // XHR Browser
        self.modules.http.request({
          host: snd.address,
          port: snd.port,
          path:path,
          proto:'http',
          method: 'GET',
          keepAlive: true,
          headers: {
          }
        } , function(err,xhr,body) {
          if (err) {
            print('Warning: request to '+addr2url(snd)+' failed: '+err);
          } 
          if (callback) callback(body);
        });    
      }
    },
    put: function (url,path,data,callback) {
      var snd=url2addr(url);
      if (!snd.port) snd.port=80;
      if (!path) path='';
      else if (path.charAt(0)!='/') path = '/'+path;
      if (!self.modules.http.xhr) {
        req = self.modules.http.request({
          host: snd.address,
          port: snd.port,
          path: path,
          method: 'POST',
          keepAlive: this.options.keepalive,
          headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Content-Length': data.length
          }
        } , function(res) {
          if (res.setEncoding != null) res.setEncoding('utf8');
          // TODO body=+chunk, res.on('end') ..??
          res.once('data', function (chunk) {
            // TODO
          });
        });
        req.once('error', function(err) {
          print('Warning: request to '+addr2url(snd)+' failed: '+err);
        });

        // write data to request body
        req.write(data);
        req.end();
      } else {
        // XHR Browser
        self.modules.http.request({
          host: snd.address,
          port: snd.port,
          path: path,
          method: 'POST',
          body:data,
          keepAlive: this.options.keepalive,
          headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Content-Length': data.length
          }
        } , function(err,xhr,body) {
          if (err) {
            print('Warning: request to '+addr2url(snd)+' failed: '+err);
            return;
          }
          // TODO
        })
      }
    }
  }
  if (!this.rl && this.modules.readlineSync) {
    // we can implement ask
    this.env.ask = function (msg,choices) {
      var answer;
      if (!choices) {
        answer = self.modules.readlineSync.question(msg);
      }
      else while (choices.indexOf(answer)==-1)
        answer = self.modules.readlineSync.question(msg+'? ['+choices.join(',')+'] ');
      return answer;
    }
  }
  if (this.modules.csv)  {
    this.env.csv =  {
      detect : function (text) {
        return self.modules.csv.detect(text);
      },
      read: function (file,convert,isString) {
        var data,text;      
        if (self.options.verbose) self.log('CSV: Reading from '+(isString?'string':file));
        try {
          text=isString?file:Io.read_file(file);
          if (!text) throw 'CSV File read error: '+file;          
          if (self.options.verbose) self.log('CSV: Parsing '+(isString?'string':file));
          self.modules.csv.parse(text,{
            skipEmptyLines: true,
            dynamicTyping: true,
            complete: function(results) {
              if (self.options.verbose) 
                self.log('CSV parsed with DEL="'+results.meta.delimiter+
                         '" TRUNC='+results.meta.truncated+
                         ' ABORT='+results.meta.aborted);
              data=results.data;
              if (convert) { // first line must be header
                header=data.shift();
                data=data.map(function (row) {
                  var r={};
                  header.forEach(function (col,i) { r[col]=row[i] });
                  return r; 
                }) 
              }
            }
          });
          if (data && data[0].length==1) data=data.map(function (row) { return row[0] });
          return data;
        } catch (e) {
          return e;
        }
      },
      write: function (file,header,data,sep,quote) {
        var d1=false,fd,i,convert=!Comp.obj.isArray(data[0])&&Comp.obj.isObj(data[0]);
        if (!sep) sep=',';
        function wrap(v) {
          if (!quote) return v;
          if (typeof v==Number) return v;
          else return quote+String(v)+quote;
        }
        d1 = typeof data[0] != 'object';
        if (!header || header.length==0) {
          if (!convert)
            header=d1?['0']:data[0].map(function (x,i) { return String(i) });
          else {
            header=[];
            for (var p in data[0]) {
              header.push(p);
            }
          }
        }
        try {
          if (self.options.verbose) self.log('CSV: Wrting to '+file);
          fd=Io.open(file,'w+');
          Io.write_line(fd,header.map(wrap).join(sep));
          if (!d1) 
            for(i in data) {
              if (!convert)
                Io.write_line(fd,data[i].map(wrap).join(sep));
              else
                Io.write_line(fd,header.map(function (col) { return data[i][col]}).map(wrap).join(sep));
            }
          else
            for(i in data) {
              if (!convert)
                Io.write_line(fd,wrap(data[i]));
              else
                Io.write_line(fd,wrap(data[i][header[0]]));
            };
            
          Io.close(fd);
          return data.length
        } catch (e) {
          return e;
        }
      }
    }
  }
  /* environment context self reference */
  this.env.Context = this.env;
  this.env.require = require;
  
  if (this.modules.FS)      this.env.FS=this.modules.FS;
  if (this.options.script)  this.env.script(this.options.script);


  if (this.options.exec)    this.process(this.options.exec);
  if (this.options.proxy)   this.proxy(this.options.proxy);
  
  return this;
}

// Generic output
Shell.prototype.error = function (line) {
  var msg=format(line);
  if (this.options.output && msg.length) this.options.output(msg);
  if (this.rl && msg.length) this.rl.insertOutput(msg);
  if (msg.length) this.emit('error',msg);
}

Shell.prototype.log = function (line) {
  this.output('[WORKSH '+process.pid+'] '+line);
}

Shell.prototype.on = function (event,handler) {
  var self=this;
  if (this.events[event]) {
    // Implement callback function chain
    var funorig=events[event];
    this.events[event]=function () {
      funorig.apply(this,arguments);
      handler.apply(this,arguments);    
    };
  } else {
    this.events[event]=handler;
  }
}

// Generic output
Shell.prototype.output = function (line) {
  var msg=format(line);
  if (this.options.output && msg.length) this.options.output(msg);
  if (this.rl && msg.length) this.rl.insertOutput(msg);
  if (msg.length) this.emit('output',msg);
}


// Primary WebSocket message channel worker proxy server
Shell.prototype.proxy = function (url) {
  // url = PROTO://HOST:PORT[:KEY]
  var self=this,log=this.log.bind(this),
      urlparts=url.split(':'),
      config = {
        verbose:this.options.verbose,
        handleIndex:1000,
        proto:url.match(/^(http|https|ws)/)[1],
        key:null,
        port:null,
        version:options.version,
      },time=Date.now;
  if (urlparts.length<3) return console.log('proxy: invalid url '+url);
  config.port=Number(urlparts [2]);
  config.key=urlparts [3];
  async function rpc(request,connection /* WebSocket, bidir. conn. */ ) {
    if (options.verbose) print(request);
    /* remote worker id; message channel is multipelxed,
    ** the worker here is identified by handle (request), remotely (replies) by workerid
    */
    // console.log(request);
    /* remote worker id */
    var workerid = request.workerid; 
    try {
      switch (request.command) {
        case 'create':
          self.consoles[request.handle]={
            exit:0,
            tid:0,
            state:0,
            time:-1, // no garbage collection
          };
          // Create new worker process; create stdio handler
          var wid = Worker.create({
            forward : function (msg,id) {
              // out-of-order messages
              // need to add id to event
              msg.workerid=workerid;
              if (msg.event) {
                /* ready is extended by local worker id: remove here */
                if (/^ready/.test(msg.event)) {
                  msg.event='ready';
                  msg.data=wid;
                }
                msg.event += workerid;
              }
              return connection.send(JSON.stringify(msg));
            },
            gui : true,
            wss : true,
            workerid  : workerid,
          });
          self.consoles[request.handle].worker=wid;
          self.log('Worker #'+wid+' created.'+(workerid!=undefined?' (Remote id '+workerid+')':''));
          // reply the local worker handle!
          connection.send(JSON.stringify({command:'status',status:{status:'OK',handle:request.handle},workerid:workerid}));
          break;
        case 'forward':
          if (!self.consoles[request.handle] || self.consoles[request.handle].state!=0)
            break;
          // Send message to worker (eval, write, ..)
          Worker.message(self.consoles[request.handle].worker,request.data);
          break;
        case 'kill':
          if (!self.consoles[request.handle] || self.consoles[request.handle].state!=0)
            break;
          console.log('kill',request.handle,self.consoles[request.handle].state);
          // Kill the worker
          Worker.kill(self.consoles[request.handle].worker,request.immediate);
          if (request.immediate) self.log('Worker #'+self.consoles[request.handle].worker+' killed.');
          else self.log('Worker #'+self.consoles[request.handle].worker+' signaled to exit.');
          self.consoles[request.handle].state=-1;
          self.console.handle=null;
          break;
      }
    } catch (e) {
      status=e.toString();
    }
  }
 function parseUrl(url) {
    if (!url) return {};
    url = url.replace(/#[^$]+$/,'');
    var queryString = url.substring( url.indexOf('?') + 1 );
    if (queryString == url) return {};
    var params = {}, queries, temp, i, l;

    // Split into key/value pairs
    queries = queryString.split("&");

    // Convert the array of strings into an object
    for ( i = 0, l = queries.length; i < l; i++ ) {
        temp = queries[i].split('=');
        if (temp[1]==undefined) temp[1]='true';
        params[temp[0]] = temp[1].replace('%20',' ');
    }

    return params;
  }
  function server (proto,port,key) {
    if (typeof WebSocket == 'undefined') {
      return console.log("Server: No WebSocket module available");
    }
    switch (proto) {
      case 'ws':
        var wsconnid=0,
            created=[],
            wss = new WebSocket.Server({ port: port })

        wss.port = wss._server.address().port;
        wss.on('connection', function (ws,req) {
          var _url = req.url,
              parameters = parseUrl(_url)
              _key=parameters.key;
          log('WebSocket ws.connection.open (ws://localhost:'+wss.port+') '+_key)
          if (key && key!=_key) return ws.close();  // denied
          var id=wsconnid++;
          ws.on('message', function (message) {
            var cmd;
            try {
                // print(body)
                cmd=JSON.parse(message);
                // if (key && cmd.key!=key) return console.log('Invalid proxy access (key='+cmd.key+')');
                cmd.handle=(cmd.data && cmd.data.handle)||cmd.handle||config.handleIndex++;
                // cmd.id=id;
                if (cmd.command=='create') created.push(cmd.handle);
                // console.log(cmd)
                rpc(cmd,ws)            
            } catch (err) {
                log(err.toString())
                reply(response,JSON.stringify({err:err.toString()}));
            }
          })
          ws.on('error', function (err) {
            log('WebSocket ws.connection',err);
          })
          ws.on('close', function () {
            log('WebSocket ws.connection.close');
            // kill all remaining workers
            created.forEach(function (handle) {
              if (self.consoles[handle]) self.consoles[handle].time=0;
            }) 
          });
        })
        wss.on('error', function (error) {
          log('WebSocket',error)
        }) 
        log('WebSocket Proxy Service started (ws://localhost:'+port+')');
        log('WEB Proxy Ver. '+config.version);
        // Start garbage collector
        gc=setInterval(function () {
          var now = time();
          for(var i in self.consoles) {
            var console=self.consoles[i];
            if (!console || console.time==-1 /* wsconn, getting close notification */) continue;
            if ((console.time+5000)<now) {
              if (console.state==-1) {
                // already killed by remote endpoint; scavenge
                // self.log('Worker #'+console.worker+' killed by client.');
              } else {
                self.log('Killing worker '+console.worker+' '+now+' (access timeout)');
                Worker.kill(console.worker);
              }
              // 
              delete self.consoles[i];
            }
          }
        },1000);
        if (key) log('WEB Proxy security key: '+key);
        return wss;
    }
  }
  return server(config.proto,config.port,config.key);
}

Shell.prototype.process = function (line,script) {
  var self=this,context=this.env,turbo=true;
  if (error=Utils.analyze('(function () {'+(line||script)+'})()')) {
    return self.output(error);
  }
  function evaluate(code,context) {
    var pars = Object.keys(context),
        args = pars.map(function (key) { return context[key] });
    pars.unshift('__dummy');
    pars.push('return ('+code+')');
    try {
      var foo = new (Function.prototype.bind.apply(Function,pars));
      return foo.apply(this,args);
    } catch (e) {
      self.output(e.toString());
      return;
    }
  };
  function execute(code,context) {
    var pars = Object.keys(context),
        args = pars.map(function (key) { return context[key] });
    pars.unshift('__dummy');
    pars.push(code);
    try {
      var foo = new (Function.prototype.bind.apply(Function,pars));
      return foo.apply(this,args);
    } catch (e) {
      self.output(e.toString());
      return;
    }
  };
  if (script) {
    if (turbo) 
        return execute('var __error=error; try { (function () {'+script+'}).call(that) } catch (e) {'+
                       'var p; if (e.stack) {p=e.stack.match(/<anonymous>:([0-9]+):([0-9]+)/)};  __error(e+(p?" @"+p[1]+":"+p[2]:"")) }',
                       context);
    else
        return eval('with (context) { var __error=error; try { (function () {'+script+'}).call(that) } catch (e) {'+
                    'var p; if (e.stack) {p=e.stack.match(/<anonymous>:([0-9]+):([0-9]+)/)};  __error(e+(p?" @"+p[1]+":"+p[2]:"")) }}')
  } else {
    if (line.trim()=='exit') line='exit()';
    if (line.trim()=='help') line='help()';
    
    if (turbo) {
      try {
        if (line.match(/;[ \n]*$/))
          execute(line,context);
        else
          self.output(evaluate(line,context)); 
      } catch (e) {
        if (e.stack) {
          var line = e.stack.toString().match(/<anonymous>:([0-9]+):([0-9]+)\)/)
          self.output(e.toString()+(line?', at line '+line[1]:''));
        } else  self.output(e.toString())
        if (self.options.verbose>1) self.output(Io.sprintstack(e)); 
      }
    } else with(context) {
      try {
        if (line.match(/;[ \n]*$/))
          eval(line);
        else
          self.output(eval(line)); 
      } catch (e) {
        if (e.stack) {
          var line = e.stack.toString().match(/<anonymous>:([0-9]+):([0-9]+)\)/)
          self.output(e.toString()+(line?', at line '+line[1]:''));
        } else  self.output(e.toString())
        if (self.options.verbose>1) self.output(Io.sprintstack(e)); 
      }
    }
  }
}

process.on('uncaughtException', function (err) {
  console.error(err.stack);
  console.log("worksh not exiting...");
});
function help() {
  print ('usage: worksh [-e <command>] [-v] [-p <proxyurl>] [-s] script.js [ -- ] <script args>\n'+
         '       <proxyurl> = PORT|HOST:PORT|PROTO://HOST:PORT|<serviceurl>:KEY');
}
if (process.argv[1].match(/worksh$/)||process.argv[1].match(/worksh\.debug$/)) {
  var ind,argn=0;;
  options.vm = process.argv[0]; options.shell = process.argv[1];
  if (process.argv.indexOf('-h')>0) return help();
  if ((ind=process.argv.indexOf('-p'))>0) {
    options.server=true;
    options.output=console.log;
    options.proxy=process.argv[ind+1];
    if (!/^(http|https|ws)/.test(options.proxy)) options.proxy='ws://localhost:'+options.proxy;
    argn += 2;
  } 
  var scriptargv; 
  process.argv=process.argv.filter(function (arg,index) {
    if (scriptargv) { scriptargv.push(arg); return false };
    switch (arg) {
      case '-v': argn++; return true; 
      case '-s': argn++; return true; 
      case '--': scriptargv=[]; return false;
      case '-h':
      case '--help': help(); process.exit();
    }
    return true;
  })
  process.scriptargv=scriptargv||[]; 
  if ((ind=process.argv.indexOf('-e'))>0) {
    options.server=true;
    options.output=console.log;
    options.exec=process.argv[ind+1];
  } else if (process.argv.length>2+argn) {
    var script = process.argv.filter(function (arg,ind) {  
      return ind>1 && arg.indexOf(':') == -1 && arg.indexOf('-') != 0;
    });
    if (script.length == 1) {
      options.script=script[0];
      options.output=console.log;
      options.server=true;
    }
  }
  process.argv.forEach(function (arg) { 
    switch (arg) {
      case '-v': options.verbose++; break; 
      case '-s': options.server=false; break; 
    }
  })
  if (!options.server && options.verbose==0) options.verbose=1; 
  Shell(options).init();
} else if (typeof module != 'undefined') {
  module.exports = {
    Shell:Shell
  }
}



};
BundleModuleCode['aux/build']=function (module,exports){
BuildDate="03/02/22"
};
BundleModuleCode['linereader']=function (module,exports){
'use strict';
// Ver. 1.1.2

var fs = require('fs'),
    StringDecoder = require('string_decoder').StringDecoder;

/* createLineReader
 *
 */
function createLineReader(readStream, options, creationCb) {
  if (options instanceof Function) {
    creationCb = options;
    options = undefined;
  }
  if (!options) options = {};

  var encoding = options.encoding || 'utf8',
      separator = options.separator || /\r\n?|\n/,
      bufferSize = options.bufferSize || 1024,
      bufferStr = '',
      buffer,
      bufferCallback,
      bufferOffset,
      bufferRemain,
      bufferType,
      decoder = new StringDecoder(encoding),
      closed = false,
      eof = false,
      separatorIndex = -1,
      separatorLen,
      readDefer,
      moreToRead = false,
      readable = 0,
      findSeparator;
  var state = {
      cpos0 : 0,
      cpos1 : 0,
      fpos : 0,
      skipTo: 0, 
      filename: options.filename,
      size: options.filesize||0,
      mode:'text', // 'binary'
      code:'ascii',
  }
  
  if (separator instanceof RegExp) {
    findSeparator = function() {
      var result = separator.exec(bufferStr);
      if (result && (result.index + result[0].length < bufferStr.length || eof)) {
        separatorIndex = result.index;
        separatorLen = result[0].length;
      } else {
        separatorIndex = -1;
        separatorLen = 0;
      }
    };
  } else {
    separatorLen = separator.length;
    findSeparator = function() {
      separatorIndex = bufferStr.indexOf(separator);
    };
  }

  function getReadStream() {
    return readStream;
  }

  function close(cb) {
    if (!closed) {
      closed = true;
      if (typeof readStream.close == 'function') {
        readStream.close();
      }
      setImmediate(cb);
    }
  }

  function onFailure(err) {
    close(function(err2) {
      return creationCb(err || err2);
    });
  }

  function isOpen() {
    return !closed;
  }

  function isClosed() {
    return closed;
  }

  function waitForMoreToRead(cb) {
    if (moreToRead) {
      cb();
    } else {
      readDefer = cb;
    }
  }

  function resumeDeferredRead() {
    if (readDefer) {
      readDefer();
      readDefer = null;
    }
  }

  // Read text data, append chunks to bufferStr
  function readText(cb) {
    waitForMoreToRead(function() {
      var chunk;

      try {
        chunk = readStream.read(bufferSize);
      } catch (err) {
        cb(err);
      }
      if (chunk) {
        state.fpos += chunk.length;
        if (state.fpos>=state.skipTo) {
          
          var _chunk;
          if (state.skipTo>0) {
            _chunk=chunk.slice(state.fpos-state.skipTo, 
                               (state.fpos-state.skipTo));
          } else
            _chunk=chunk;
            
          bufferStr += decoder.write(_chunk);
          
          state.skipTo=0;
        }
      } else {
        moreToRead = false;
      }

      cb();
    });
  }
  var _counter=0;
  // Read binary data, store (encoded) chunk data in buffer
  function readBinary(cb) {
    waitForMoreToRead(function() {
      var chunk, _size=Math.min(bufferSize,bufferRemain);

      try {
        chunk = readStream.read(_size);
      } catch (err) {
        cb(err);
      }
      if (bufferRemain>0 && chunk) {
        state.fpos += chunk.length;
        if (state.fpos>state.skipTo) {
          var _chunk;
          if (state.skipTo>0) {
            _chunk=chunk.slice(_size-(state.fpos-state.skipTo), 
                               (state.fpos-state.skipTo));
          } else
            _chunk=chunk;
            
          state.skipTo=0;
          if (_chunk.length) {
            if (bufferType=='array') {
              _chunk.copy(Buffer(buffer),bufferOffset);
            } else 
              _chunk.copy(buffer,bufferOffset);
            bufferRemain -= _chunk.length;
            bufferOffset += _chunk.length;
            if (options.verbose && (++_counter % 10000)==0) print('Buffer # '+bufferRemain);
          }
        }

      } else {
        moreToRead = false;
      }
      cb();
    });
  }

  function onStreamReadable() {
    readable++;
    moreToRead = true;
    resumeDeferredRead();
  }

  function onStreamEnd() {
    eof = true;
    resumeDeferredRead();
  }

  readStream.on('readable', onStreamReadable);
  readStream.on('end', onStreamEnd);
  readStream.on('error', onFailure);

  function shouldReadMore() {
    findSeparator();
    return separatorIndex < 0 && !eof;
  }

  function callWhile(conditionFn, bodyFn, doneCallback) {
    if (conditionFn()) {
      bodyFn(function (err) {
        if (err) {
          doneCallback(err);
        } else {
          setImmediate(callWhile, conditionFn, bodyFn, doneCallback);
        }
      });
    } else {
      doneCallback();
    }
  }

  function readToSeparator(cb) {
    callWhile(shouldReadMore, readText, cb);
  }

  function hasNextLine() {
    return bufferStr.length > 0 || !eof;
  }

  function nextLine(cb) {
    if (closed) {
      return cb(new Error('LineReader has been closed'));
    }

    function getLine(err) {
      if (err) {
        return cb(err);
      }

      if (separatorIndex < 0 && eof) {
        separatorIndex = bufferStr.length;
      }
      var ret = bufferStr.substring(0, separatorIndex);
      state.cpos0=state.fpos-bufferStr.length;
      bufferStr = bufferStr.substring(separatorIndex + separatorLen);
      state.cpos1=state.fpos-bufferStr.length;
      separatorIndex = -1;
      cb(undefined, ret);
    }

    findSeparator();

    if (separatorIndex < 0) {
      if (eof) {
        if (hasNextLine()) {
          separatorIndex = bufferStr.length;
          getLine();
        } else {
          return cb(new Error('No more lines to read.'));
        }
      } else {
        readToSeparator(getLine);
      }
    } else {
      getLine();
    }
  }

  function currentPosition() {
    return [state.cpos0,state.cpos1];
  }

  function getSize() {
    return state.size;
  }
  
  function skipTo(offset) { /* absolute file position */
    if (options.verbose) print('skipTo',offset)
    if (offset > state.fpos) {
      state.skipTo=offset;
      bufferStr = '';
    } else if (offset > state.cpos1 ) {
      if (state.mode=='binary') {
        // copy already consumed bytes ..
        var _b = Buffer( bufferStr.substring(state.fpos-state.cpos1));
        _b.copy(buffer);
        bufferStr = "";
      } else
        bufferStr = bufferStr.substring(state.fpos-state.cpos1);
    }
  }
  
  function readBuffer(type, off,len, cb) {
    if (type == 'array') buffer = new ArrayBuffer(len);
    else buffer = Buffer(len);  // type = 'byte' | 'array' | ..
    bufferType=type;
    bufferCallback = function () { 
      if (cb) cb(buffer);
      buffer=undefined;
      bufferCallback=undefined;
      bufferOffset=0;
      state.mode='text';
      state.code='ascii';
    }
    bufferRemain = len;
    bufferOffset = 0;
    state.mode='binary';
    state.code=type;
    skipTo(off);
    moreToRead=true;
    callWhile(function () { return bufferRemain>0 }, readBinary, bufferCallback);
  }
  
  readToSeparator(function(err) {
    if (err) {
      onFailure(err);
    } else {
      return creationCb(undefined, {
        currentPosition:currentPosition,
        hasNextLine: hasNextLine,
        nextLine: nextLine,
        close: close,
        isOpen: isOpen,
        isClosed: isClosed,
        getReadStream: getReadStream,
        readBuffer : readBuffer,
        size:getSize, 
        skipTo : skipTo,
      });
    }
  });
}

/** Open
 *
 */
function open(filenameOrStream, options, cb) {
  if (options instanceof Function) {
    cb = options;
    options = {};
  }
  
  if (options==undefined) options={};
  
  var readStream;

  
  if (typeof filenameOrStream.read == 'function') {
    readStream = filenameOrStream;
  } else if (typeof filenameOrStream === 'string' || filenameOrStream instanceof String) {
    var stat=fs.statSync(filenameOrStream);
    options.filename=filenameOrStream;
    options.filesize=stat.size;    
    readStream = fs.createReadStream(filenameOrStream);
  } else {
    cb(new Error('Invalid file argument for LineReader.open.  Must be filename or stream.'));
    return;
  }

  readStream.pause();
  createLineReader(readStream, options, cb);
}

/* eachLine
 * typeof @iteratee= function (line ,last) -> boolean |  function (line ,last, cb) |  
 *                   function (line ,last, reader, unused) -> boolean
 */
 
function eachLine(filename, options, iteratee, cb) {
  if (options instanceof Function) {
    cb = iteratee;
    iteratee = options;
    options = undefined;
  }
  var asyncIteratee = iteratee.length === 3;  // function (line ,last, cb) 

  var theReader;
  var getReaderCb;

  open(filename, options, function(err, reader) {
    theReader = reader;
    if (getReaderCb) {
      getReaderCb(reader);
    }
    if (err) {
      if (cb) cb(err);
      return;
    }

    function finish(err) {
      reader.close(function(err2) {
        if (cb) cb(err || err2);
      });
    }

    function newRead() {
      if (reader.hasNextLine()) {
        setImmediate(readNext);
      } else {
        finish();
      }
    }

    function continueCb(continueReading) {
      if (continueReading !== false) {
        newRead();
      } else {
        finish();
      }
    }

    function readNext() {
      var next;
      reader.nextLine(function(err, line) {
        if (err) {
          finish(err);
        }

        var last = !reader.hasNextLine();

        if (asyncIteratee) {
          iteratee(line, last, continueCb);
        } else {
          next = iteratee(line, last, reader); 
          if (typeof next == 'object') {
            // { type, offset, length, next:boolean, callback }
            // read a buffer, reader.readBuffer ...
            reader.readBuffer(next.type||'byte',
                              next.offset,
                              next.length,
                              function (buffer) {
                                if (next.callback) next.callback(buffer);
                                if (next.next !== false) newRead(); else finish();
                              });    
          } else if ( next !== false) {
            newRead();
          } else {
            finish();
          }
        }
      });
    }

    newRead();
  });

  // this hook is only for the sake of testing; if you choose to use it,
  // please don't file any issues (unless you can also reproduce them without
  // using this).
  return {
    getReader: function(cb) {
      if (theReader) {
        cb(theReader);
      } else {
        getReaderCb = cb;
      }
    }
  };
}

module.exports.open = open;
module.exports.eachLine = eachLine;
};
BundleModuleCode['plugins/com/utils.js']=function (module,exports){
var fs      = require('fs');
var http    = require('http');
var deasync = require('deasync');
var util    = require('util');
try { var crypto = require("crypto") } catch (e) { }
var https;
try { https=require('https') } catch (e) {};

JSONfn = Require('plugins/com/jsonfn');

if (typeof print == 'undefined') print=console.log;

function POST(url, data, cb) {
  var params,headers;
  if (data && data.params && data.data != undefined) {
    params=data.params;
    headers=data.headers;
    data=data.data;
  }
  var ishttps= url.match(/https:/);
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  var post_data = typeof data == 'string'?data:JSONfn.stringify(data);
  var post_options = {
      host: host,
      port: port,
      path: '/'+path+params,
      method: 'POST',
      keepAlive: true,
      headers: headers || {
          'Content-Type': 'application/json', // ?? 'application/x-www-form-urlencoded',
          // 'Content-Length': Buffer.byteLength(post_data)
          'Content-Length': post_data.length,
      }
  };
  // console.log('POST', post_options,post_data)
  var post_req = (ishttps?https:http).request(post_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('POST: ',result);
        } catch (e) { print(data); result=e; }
        if (cb) cb(result);
      });
  });
  post_req.on('error',function (err) {
    if (cb) cb(err); else console.log(url,err)
  });
  post_req.setNoDelay();
  // console.log('POST: ',post_data);
  // post the data
  post_req.write(post_data);
  post_req.end();
}
var POSTsync = deasync(function(url,data,cb) {
  POST(url,data,function (result) {
    cb(null,result);
  })
})

function GET(url,params, cb) {
  var ishttps= url.match(/https:/)!=null;
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  path += params; 
  // print(host,path,port,ishttps)
  var get_options = {
      host: host,
      port: port,
      path: path,
      method: 'GET',
      keepAlive: true,
      headers: {
          // 'Content-Type': 'application/x-www-form-urlencoded',
      }
  };
  // console.log('GET', post_options,post_data)
  var get_req = (ishttps?https:http).request(get_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('GET: ',result);
        } catch (e) { result=e; }
        if (cb) cb(result);
      });
  });
  get_req.on('error',function (err) {
    // console.log(err)
    if (cb) cb(err); else console.log(url,err);
  });
  get_req.setNoDelay();
  // get_req.write();
  get_req.end();
}
var GETsync = deasync(function(url,params,cb) {
  GET(url,params,function (result) {
    cb(null,result)
  })
})

Common = {
  existFile: function (file) {
    try {
      var stat=fs.statSync(file);
      return stat?true:false;
    } catch (e) {
      return false;
    }
  },
  loadFile: function (file,callback) {
    try {
      var text = fs.readFileSync(file,'utf8');
      // var data = JSONfn.parse(text);
      if (callback) return callback(text);
      else return text;
    } catch (e) {
      if (callback) return callback(data);
      else return e
    }
  },
  saveFile: function (data,file,mimetype) {
    try {
      var data = typeof data=='string'?data:JSONfn.stringify(data);
      return fs.writeFileSync(file,data,'utf8');
    } catch (e) {
      return e
    }
  }
}

Utils = {

  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  deserialize : function (data) {
    return JSONfn.deserialize(data)
  },

  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  format : function (args) {
    // format array of arguments like console.log
    var s='',sep='';
    for(var i in args) {
      switch (typeof args[i]) {
        case 'number':
        case 'string':
        case 'boolean':
          s += (sep+args[i]);
          break;
        case'function':
          s += (sep+'[Function]');
          break;
        case'object':
          s += (sep+util.inspect(args[i]));
          break;
      }
      sep = ' ';
    }
    return s;
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*\([^\)]+\))/)[1];
    }
  },

  inspect : Require('util').inspect,

  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isArrayArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]) &&
                Utils.isArray(o[0][0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isBufferArray : function (o) {
    return (typeof ArrayBuffer != 'undefined' && o instanceof ArrayBuffer) ||
           (typeof SharedArrayBuffer != 'undefined' && o instanceof SharedArrayBuffer) ||
           (typeof Buffer != 'undefined' && o instanceof Buffer)
  },
  isMatrix: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return (Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isNumber(o) {
      return typeof o == "boolean"
  },
  isString: function isNumber(o) {
      return typeof o == "string"
  },
  isTypedArray: function isTypedArray(o) {
      return Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },

  network : function () {
    const results = Object.create(null); // Or just '{}', an empty object
    Object.defineProperty(results, 'first', {
      value: function () {
        var keys = Object.keys(this); 
        return keys.length? this[keys[0]][0]:null
      },
      writable: false,
      enumerable : false,
    });
    try { 
      const networkInterfaces  = require('os').networkInterfaces;
      const nets = networkInterfaces();
      for (const name of Object.keys(nets)) {
          for (const net of nets[name]) {
              // Skip over non-IPv4 and internal (i.e. 127.0.0.1) addresses
              if (net.family === 'IPv4' && !net.internal) {
                  if (!results[name]) {
                      results[name] = [];
                  }
                  results[name].push(net.address);
              }
          }
      }
    } catch (e) {};
    
    return results
  },
  
  serialize : function (data) {
    return JSONfn.serialize(data)
  },

  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },

  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
    if (ftyp==Int8Array) return 'Int8Array';
    if (ftyp==Uint8Array) return 'Uint8Array';
    if (ftyp==Int16Array) return 'Int16Array';
    if (ftyp==UInt16Array) return 'Uint16Array';
    if (ftyp==Int32Array) return 'Int32Array';
    if (ftyp==UInt32Array) return 'Uint32Array';
    if (ftyp==Float32Array) return 'Float32Array';
    if (ftyp==Float64Array) return 'Float64Array';
  },
  DataSize : {
    Int8:1,
    Uint8:1,
    Int16:2,
    Uint16:2,
    Int32:4,
    Uint32:4,
    Float32:4,
    Float64:4,
    Boolean:1,
    Number:8,  
  },

  uniqueID : function (length) {
    var s='',
        keys=['a','b','c','d','e','f','g','h','i','j','k','l','m','n',
              'o','p','q','r','s','t','u','v','w','x','y','z'];
    keys=keys.concat(keys,keys.map(function (k) { return k.toUpperCase() }));
    keys=keys.concat(['0','1','2','3','4','5','6','7','8','9']);
    if (typeof crypto == 'undefined') {
      for(var i=0;i<length;i++) {
        var b = (Math.random()*255)|0;
        s+= (keys[b%keys.length]);
      }
    } else {
      if (crypto.getRandomValues) { 
        var rav = new Uint8Array(length);
        crypto.getRandomValues(rav);
      }
      if (crypto.randomBytes) {
        var rav = crypto.randomBytes(length);
      } 
      for(var i=0;i<length;i++) {
        s+= (keys[rav[i]%keys.length]);
      };
    }
    return s;
  },
 
  UUIDv4 : function uuidv4() {
    if (typeof crypto != "undefined" && crypto.getRandomValues) { 
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    if (typeof crypto != "undefined" && crypto.randomBytes) { 
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.randomBytes(1)[0] & 15 >> c / 4).toString(16)
      );
    }
  },

  GET: function (url,params,cb) {
    if (!cb) return GETsync(url,params);
    else return GET(url,params,cb);
  },
  
  POST: function (url,data,cb,sync){
    if (!cb) return POSTsync(url,data);
    else return POST(url,data,cb);
  },

  version: '1.2.4'
}


Object.addProperty = function (obj,name,fun) {
  if (obj.prototype[name]) return;
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

Object.updateProperty = function (obj,name,fun) {
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

// Array static methods extensions
if (!Array.create) Array.create = function(length,init) {
      var arr = [], i = length;
      while (i--) {
        arr[i] = init;
      }
      return arr;
  }

if (!Array.matrix) Array.matrix = function (rows,cols,init) {
  if (init==undefined) init=0;
  var mat=[];
  for(var i=0;i<rows;i++) {
    var row=[];
    for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
    mat.push(row);
  }
  return mat;
};

// Array prototype extensions
Object.addProperty(Array,'last',function () { return this[this.length-1] });

// String static methods extensions
if (!String.create) String.create = function(size,init) {
      var i, s='';
      init=init||' ';
      for(i=0;i<size;i++) s=s+init;
      return s;
};
if (!String.copy) String.copy = function(src) {
      var i,dst='';
      for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
      return dst;
}; 
if (!String.get) String.get = function (str,index) {
      return str.charAt(index);
}
if (!String.hex) String.hex = function (n,len) {
      // format a hexadecimal number with 'len' figures.
      switch (len) {
          case 2: return (((n>>4) & 0xf).toString(16))+
                          ((n&0xf).toString(16));
          case 4: return (((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 6: return (((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 8: return (((n>>28) & 0xf).toString(16)+
                          ((n>>24) & 0xf).toString(16)+
                          ((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          default: return 'format_hex??';
      }
}; 
if (!String.set) String.set = function (str,index,char) {
  return str.substr(0, index) + char + str.substr(index+1)
}
// String prototype extensions
Object.addProperty(String,'contains', function (el) {
  return this.includes(el)
})
Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
});


};
BundleModuleCode['plugins/com/jsonfn']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  OJ=exports.stringify;
  JO=exports.parse;
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));


};
BundleModuleCode['plugins/com/code.js']=function (module,exports){
/* Code module for worksh */
Code = {
  config : {
    // default loop/iter schedul timeout
    scheduleTimeout : 1,
  },

  error: print,
  print: print,
  
  tasks:[],

  this : {},
  iter : async function (array,callback,final,async) {
    var counter=0;
    if (typeof final=='boolean') async=final;
    var timeout=Code.config.scheduleTimeout;
    if (!async) {
      for(counter in array) {
        callback(array[counter],counter,array);
      }
      if (typeof final=='function') final(counter); 
    }
    else if (async === true) {
      var id=Code.tasks.length;
      var timer=setTimeout(handler,timeout)
      async function handler() {
        if (Code.tasks[id]==undefined) return;
        try {
          var res=await callback(array[counter],counter,array);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
          res=e;
        }
        counter++;
        if (res instanceof Error || counter==array.length) {
          delete Code.tasks[id];
          if (typeof final=='function') 
            try { 
              final(counter,array);
            } catch (e) {
              if (typeof error != 'undefined') error(e);
              else Code.error(e);
            } 
        } else {
          timer=setTimeout(handler,timeout);
        }
      }
      Code.tasks[id]=timer;
      return id;
    } else if (async=='schedule'||async=='await') {
      var res=true;
      Code.tasks[id]=Math.random();
      while(res) {
        try {
          var res=await callback(array[counter],counter,array);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
          res=e;
        }
        counter++;
        if (res instanceof Error || counter==array.length) {
          delete Code.tasks[id];
          if (typeof final=='function') 
            try { 
              final(counter,array);
            } catch (e) {
              if (typeof error != 'undefined') error(e);
              else Code.error(e);
            } 
          return;
        } else {
          res=await Code.schedule(timeout);
          if (!res) {
            // interrupted
            console.log('loop.interrupt');
            Code.error('Interrupted.');
            delete Code.tasks[id];
            return;
          }
        }
      }
      delete Code.tasks[id];
      if (typeof final=='function') 
        try { 
          final(counter,counter);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
        } 
      return true;
    }
  },
  
  // Kill background tasks
  kill: function (id) {
    if (Code.tasks[id]) {
      if (typeof Code.tasks[id] == 'boolean') {
        Code.tasks[id]=false;
      } else {
        clearInterval(Code.tasks[id]);
        Code.tasks[id]=null;
      }
    }
  },
  
  later : function (timeout,callback,final) {
    var counter=0,id=Code.tasks.length;
    if (typeof timeout == 'function') {
      return setTimeout(timeout,0);
    }
    if (timeout <1) {
      while (callback(0,counter++)) {}
      return;
    }
    var timer=setInterval(function () {
      try {
        var res=callback(id,counter);
      } catch (e) {
        Code.error(e);
        res=0;
      }
      counter++;
      if (!res) {
        clearInterval(timer); 
        Code.tasks[id]=null;
        if (typeof final=='function') 
        try {
          final(counter,counter);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
        }
      }
    },timeout)
    Code.tasks[id]=timer;
    return id;
  },
    
  loop : async function (callback,final,async) {
    var counter=0;
    if (typeof final=='boolean') async=final;
    var timeout=Code.config.scheduleTimeout;
    if (!async) {
      while (callback(counter,counter++)) {};
      if (typeof final=='function') final(0,counter,counter); 
    }
    else if (async==true) {
      var id=Code.tasks.length;
      var timer=setTimeout(handler,timeout)
      async function handler() {
        if (Code.tasks[id]==undefined) return;
        try {
          var res=await callback(counter,counter);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
          res=0;
        }
        counter++;
        if (!res) {
          delete Code.tasks[id];
          if (typeof final=='function') 
            try { 
              final(counter,counter);
            } catch (e) {
              if (typeof error != 'undefined') error(e);
              else Code.error(e);
            } 
        } else {
          timer=setTimeout(handler,timeout);
        }
      }
      Code.tasks[id]=timer;
      return id;
    } else if (async=='schedule'||async=='await') {
      var res=true;
      Code.tasks[id]=Math.random();
      while(res) {
        try {
          var res=await callback(counter);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
          res=false;
        }
        counter++;
        if (res) {
          res=await Code.schedule(timeout);
          if (!res) {
            // interrupted
            console.log('loop.interrupt');
            Code.error('Interrupted.');
            delete Code.tasks[id];
            return;
          }
        }
      }
      delete Code.tasks[id];
      if (typeof final=='function') 
        try { 
          final(counter,counter);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
        } 
      return true;
    }
  },
  
  run : function (code) {
    if(typeof code == 'function') code.call(Code.this);
  },
  
  schedule : async function (timeout) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        var interrupt=Code.interrupt;
        resolve(!interrupt);
      },timeout||Code.config.scheduleTimeout);
    });
  },

  stop : function () {
    for(var i in Code.tasks) Code.kill(i);
    Code.interrupt=true;
  },
  
  version : '1.4.1',
}

Code.workerBook = {
  create : function () { return 0 },
  write : function (id,key,val) {}, 
}

// Generic synchronised channel object (super class)
Code.channel = {
  channelID:0,
  channels:[],
  create : function () {
    var id = Code.channel.channelID++;
    var chan = {
      waiters : [],
      queue : [],
      id : id,
      cancel : function () {
        this.waiters.forEach(function (waiter) {
          waiter(null);
        })
        this.waiters=[];
        this.queue=[];
      },
      destroy : function () {
        chan.cancel();
        delete Code.channels[id];
      },
      enqueue: function (data) {
        if (this.queue.length==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else this.queue.push(data);
      },
      send: function (data) {
        if (this.forward) {
          this.forward(data);
        } else if (this.queue.length==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else this.queue.push(data);
      },
      receive : function () {
        var self=this,data;
        if (this.queue.length) return this.queue.shift();
        // console.log('WAIT M');
        return new Promise(function (resolve) {
          self.waiters.push(function (data) {
            resolve(data);
          });
        });
      }
    }
    Code.channel.channels[id]=chan;
    return chan;
  }
}
try { Code.WebSocket = require('ws') } catch (e) {};

Code.wschannel = {
  channelID:0,
  channels:[],
  // Create channel pair from here to worker
  create : async function (workerUrl,name) {
    var id = Code.wschannel.channelID++,
        channel;
    if (!Code.WebSocket) return;
    function connectFrom(workerUrl,name,channel,resolve) {
      // Connect to worker service endpoint and create a private connection for this channel
      console.log('connectFrom',workerUrl,name);
      Code.print('connectFrom',workerUrl,name)
      var connection = new Code.WebSocket(workerUrl);
      connection.onopen = function () {
        // attach a channel pair endpoint
        console.log('channel.onopen');
        connection.send(JSON.stringify({
          command:'channel',
          assign :name,
        }));
        resolve(channel);
      };
      channel.forward = function (data) {
        connection.send(JSON.stringify({
          command:'send',
          data : data,
        }))
      }
      connection.onmessage = function (e) {
        var message;
        // console.log('onmessage',e.data);
        if (e.data) message=JSON.parse(e.data);
        // console.log('onmessage',waiters.length,data)
        if (!message) return;
        switch (message.command) {
          case 'send':
            channel.enqueue(message.data);
            break;
        }
      }    
    }
    channel = Code.channel.create();
    return new Promise(function (resolve) {
      connectFrom(workerUrl,name,channel,resolve);
    }) // returns channel if worker1=="main"
  }

}

};
BundleModuleCode['plugins/math/math.js']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.46.1X
 **
 **    $INFO:
 **
 **  Extended math Library
 **
 **    $ENDOFINFO
 */

if (typeof Utils == 'undefined') Require('plugins/com/utils')
var MatrixTA = Require('plugins/math/matrixTA')
  MatrixTA.EVD = Require('plugins/math/matrixTA-EVD');
  MatrixTA.SVD = Require('plugins/math/matrixTA-SVD');
  
var VectorTA = Require('plugins/math/vectorTA')
var Matrix  = Require('plugins/math/matrix')
var Vector  = Require('plugins/math/vector')
var Line    = Require('plugins/math/line')
var Plane   = Require('plugins/math/plane')
var Stats   = Require('plugins/math/stats')
var DWT     = Require('plugins/math/dwt5')
var Numeric = Require('plugins/math/numeric')
var Regression  = Require('plugins/math/regression')
var Polyfit     = Require('plugins/math/polyfit')
var Smoothers   = Require('plugins/math/smoothers')
var LinLogReg   = Require('plugins/ml/reg')
var Bin   = Require('plugins/math/data-bin')
Require('plugins/math/matja')

var MAN  = FileEmbedded('plugins/math/help.md','utf8');
Math.help = function (topic) {
  // TODO
  return MAN
}

// Generic array vector & matrix modules
Math.Line     = Line;
Math.Matrix   = Matrix;
Math.Plane    = Plane;
Math.Vector   = Vector;
Math.DWT      = DWT;
Math.numeric  = Numeric;
Math.regression = {
  polyfit : Polyfit,
  linlog  : LinLogReg,
  regression : Regression,
  smoothers : Smoothers,
};
Math.statistics = Stats;

// Typedarray vector & matrix modules
Math.MatrixTA = MatrixTA;
Math.VectorTA = VectorTA;

var FFT     = Require('plugins/math/fft')
Math.FFT    = FFT;
var CONV    = Require('plugins/math/conv')
Math.Convolution = CONV;

Math.version  = '1.46.1X'

var none = null;

// Dynamic array method extensions (more extension in MatrixTA!)
Object.addProperty(Array,'abs', function () {
  return this.map(Math.abs)
})
Object.addProperty(Array,'add', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b+v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b+v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]+v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]+v })});
  }
})
Object.addProperty(Array,'append', function (a) {
  for(var i=0;i<a.length;i++) this.push(a[i]);
  return this
})

Object.addProperty(Array,'contains', function (elements,test,single) {
  if (Utils.isArray(elements) && !single)  {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (this[i]==elements[j]) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (test(this[i],elements[j])) return true;  
      } 
  
  } else {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        if (this[i]==elements) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        if (test(this[i],elements)) return true;  
      } 
  }
  return false;
})
Object.addProperty(Array,'div', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b[j][i] })});
  }
})
Object.addProperty(Array,'extend', function (array) {
  for(var i=0;i<array.length;i++) this.push(array[i]);
  return this;
})
if (!Array.prototype.flat) {
  Object.addProperty(Array,'flat', function flat () {
    var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

    return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
      if (Array.isArray(cur)) {
        acc.push.apply(acc, flat.call(cur, depth - 1));
      } else {
        acc.push(cur);
      }
      return acc;
    }, []) : Array.prototype.slice.call(this);
  })
}

Object.addProperty(Array,'head', function (num) {
  return this.slice(0,num||1);
})

Object.addProperty(Array,'index', function (offset) {
  offset=offset||0;
  return this.map(function (v,i) { return i+offset });
})

Object.addProperty(Array,'mul', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b*v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b*v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]*v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]*v })});
  }
})

if (!Array.prototype.includes) {
  Object.addProperty(Array,'includes', function (r,e) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var t = Object(this),
            n = t.length >>> 0;
        if (0 === n) return !1;
        var i, o, a = 0 | e,
            u = Math.max(0 <= a ? a : n - Math.abs(a), 0);
        for (; u < n;) {
            if ((i = t[u]) === (o = r) || "number" == typeof i && "number" == typeof o && isNaN(i) && isNaN(o)) return !0;
            u++
        }
        return !1
    });
};
Object.addProperty(Array,'intersect', function (second) {
  var result=[];
  for(var i=0;i<this.length;i++) {
    for(var j=0;j<second.length;j++)
      if (Math.equal(this[i],second[j])) result.push(this[i]);
  }
  return result;
})

Object.addProperty(Array,'loop', function (callback,tmo) {
  var self=this;
  Code.later(tmo||1,function (id,index) {
    callback(self[index],index);
    return index<(self.length-1);
  })
})

Object.addProperty(Array,'match', function (test) {
  if (test.length != this.length) return false;
  for(var i=0;i<this.length;i++) if (this[i]!=test[i]) return false;
  return true;
})

Object.addProperty(Array,'pad', function (size,v,left) {
  v=v||0;
  if (size<this.length) return this.slice();
  var ext = Array.init(size-this.length,v);
  if (!left) return this.concat(ext);
  else return ext.concat(this);
})

Object.addProperty(Array,'sample', function (frag,filter) {
  var m = Math.floor(this.length/frag),
      i,
      fn,
      s=0,
      res=[];
  filter=filter||'mean';
  switch (filter) {
    case 'mean':
      fn=function (a,b,i) {
        if (i!=frag-1) return a+b;
        else return (a+b)/frag;
      };
      break;
    case 'peak':
      fn=function (a,b,i) {
        return a>b?a:b;
      };
      break;
  }
  for(i=0;i<m;i++) {
    s=this.slice(i*frag,i*frag+frag).reduce(fn);
    res.push(s);
  }
  return res;
})
Object.addProperty(Array,'search', function (test) {
  for(var i=0;i<this.length;i++) if (test(this[i])) return this[i];
  return
})

// Shuffle array randomly (uniform distribution)
// if weak is set true then the original
// element position acts like a magnet, i.e.,
// elements are stay mostly in their array original region
// (localized non-uniform distribution)
Object.addProperty(Array,'shuffle', function (weak) {
  if (weak) return this.slice().sort(function () { return Math.random()-0.5 });
  var array=this;
  for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;  
});

Object.addProperty(Array,'split', function (frag) {
  var rows = this.length/frag,
      cols = frag,
      j,
      mat=[];
  for(j=0;j<rows;j++) {
    mat.push(this.slice(j*cols,j*cols+cols));
  }
  return mat;
})
Object.addProperty(Array,'subtract', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b[j][i] })});
  }
})
Object.addProperty(Array,'tail', function (num) {
  return this.slice(this.length-(num||1));
})
Object.addProperty(Array,'toObject', function (keys) {
  var o={};
  for(var i=0;i<this.length;i++) {
    var key = keys?keys[i]||String(i):String(i);
    o[key]=this[i];
  }
  return o;
})
Object.addProperty(Array,'transpose', function () {
  var rows = this.length, i, cols = this[0].length, j;
  var elements = [], i = cols;
  while (i--) { j = rows;
    elements[i] = [];
    while (j--) {
      elements[i][j] = this[j][i];
    }
  }
  return elements;
})
if (!Array.prototype.unflat) {
  Object.addProperty(Array,'unflat', function unflat (n) {
      // suppports only 1d->2d transformation
      var rows = [];
      for(var i=0;i<=(this.length-n);i+=n) rows.push(this.slice(i,i+n));
      return rows;
  })
}
Object.addProperty(Array,'without', function (without) {
  if (Utils.isArray(without)) {
    return this.filter(function (el) {
      var found=false;
      for(var i=0;i<without.length;i++) 
        found = found  | Math.equal(el,without[i])
      return !found; 
    });
  } else return this.filter(function (el) { return !Math.equal(el,without) });
})

// Static array method extensions

// Simple array array matrix
Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
Array.matrix3d =  function (n,m,k,init) {
    var x,y,z,mat;
    mat=new Array(n);
    for(x=0;x<n;x++) {
      mat[x]=new Array(m);
      for(y=0;y<m;y++) {
        mat[x][y]=new Array(k);
        if (init!=undefined) {
          if (typeof init == 'function')
            for(var z=0;z<k;z++) mat[x][y][z]=init(x,y,z);
          else
            for(var z=0;z<k;z++) mat[x][y][z]=init; 
        }  
      }
    }
    return mat;
  };
Array.random = function (n,a,b) {
  var res=[];
  a=a||0;
  b=b||1;
  for(var i=0;i<n;i++) res.push(Math.random()*(b-a)+a);
  return res;
}

Array.sequence = function (a,b,step,func) {
  var res=[], preci=1;
  step=step||1;
  if (step < 1) {
    preci = Math.ceil(Math.log10(1/step))
    for(var i=a;i<=b;i += step) res.push(func?func(i):Math.precision(i,preci));
  } else for(var i=a;i<=b;i += step) res.push(func?func(i):i);
  return res;
}

// Transpose matrix (array of arrays) by swapping rows and columns
Array.transpose = function (matrix) {
  var t=[];
  for (var i=0;i<matrix[0].length;i++) {
    var row=[];
    for(var j=0;j<matrix.length;j++) {
      row.push(matrix[j][i]);
    }
    t.push(row);
  }
  return t;
}  
// Simple array vectorA
Array.vector = function (cols,init) {
  if (init==undefined) init=0;
  if (typeof init != 'function') return Array(cols).fill(init);
  var row=[];
  for(var j=0;j<cols;j++) row.push(init(j));
  return row;
};
Array.init=Array.vector;

// Dynamic Object method extensions

Object.addProperty(Object,'toArray', function () {
  var self=this;
  return Object.keys(this).map(function (key) {
    return self[key]
  })
})


// Angle of line (p1,p2)  or delty vector
// +---------X
// |    270
// | 180 *  0
// |    90 
// Y
Math.angle = function (p1,p2) {
  var pd=[],i=0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') {
        if (i==0) dx=(p1[p]-p2[p]);
        else if (i==1) dy=(p1[p]-p2[p]);
        i++;
      }
  } else { 
    for(var p in p1) {
        if (i==0) dx=p1[p];
        else if (i==1) dy=p1[p];
        i++;    
    }
  }
  var theta = Math.atan2(dy, dx); // range (-PI, PI]
  theta *= 180 / Math.PI;
  if (theta < 0) theta = 360 + theta; // range [0, 360)
  return theta;
}
Math.bin = Bin;

// mass of center of (optionally weighted) points
// typeof @pts = {x:numebr,y:number,weight?:number } | number [x,y] []
Math.center = function (pts) {
  var n,center,weight,totalmass=0,totalx=0,totaly=0;
  for (var i in pts)
  {
    n=pts[i]; if (n.length==2) n={x:n[0],y:n[1]};
    weight=(n.weight==undefined?1:n.weight);
    totalmass += weight;
    totalx += (n.x*weight);
    totaly += (n.y*weight);
  }
  center = {x:totalx/totalmass,y:totaly/totalmass}
  return center;
}

// Coding and Decoding

// Multi-level: Math.code(['A','B','C'],{A:1,B:2,C:4}) -> 7
// One-hot:     Math.code('A',['A','B','C']) -> [1,0,0]
Math.code = function (list,codes) {
  var y=0;
  if (typeof list == 'string' && Utils.isArray(codes)) {
    // One-hot
    var width = codes.length,
        index = codes.indexOf(list);
    y=[];
    for(var i=0;i<width;i++) y.push(i==index?1:0);
    return y;
  }
  // Multi-level
  if (!Utils.isArray(list)) list=[list];
  for(var i=0;i<list.length;i++) {
    if (list[i]!=undefined) y += (codes[list[i]]); 
  }
  return y; 
}
Math.code.onehot = function (classes,symbol,low,high) {
  if (low==undefined) low=0;
  if (high==undefined) high=1;
  return classes.map(function (c) { return symbol==c?high:low })
}
Math.code.interval = function (values,min,max,step,prefix,relative) {
  function code(x) {
    if (x<min) return (prefix?prefix:'')+'-';
    if (x > max) return (prefix?prefix:'')+'+';
    var xn = (x-min)/(max-min),
        sn = (step)/(max-min)
    return (prefix?prefix:0)+(relative?Math.floor(xn/sn):(min+Math.floor(xn/sn)*step))
  }
  if (Utils.isArray(values)) return values.map(code);
  else return code(values);
}
Math.contains = function (a,element) {
  if (Utils.isArray(a)) {
    return a.contains(element,Math.equal,true);
  } else if (Uitls.isObject(a)) {
    
  } else if (typeof a == 'string') {
    return a.indexOf(String(element))!=-1
  } 
}
// Returns dataspace and datatype of numerical objects
Math.dataspace = function (o) {
  if (Utils.isArrayArrayArray(o)) return [o.length,o[0].length,o[0][0].length];
  else if (Utils.isArrayArray(o)) return [o.length,o[0].length];
  else if (Utils.isArray(o))  return [o.length].concat(Math.dataspace(o[0]));
  else if (Math.Matrix.isMatrix(o)) return [o.rows,o.columns];
  else if (Math.MatrixTA.isMatrix(o)) return [o.rows,o.columns];
  else if (Utils.isBuffer(o)) return [o.length];
  return [];
}
Math.datatype = function (o,sig) {
  if (Utils.isArrayArray(o)) return Math.datatype(o[0][0],sig)+(sig?' [][]':'');
  else if (Utils.isArray(o))  return Math.datatype(o[0],sig)+(sig?' []':'');
  else if (Math.Matrix.isMatrix(o)) return Math.datatype(o.data[0][0],sig)+(sig?' Matrix':'');
  else if (Math.MatrixTA.isMatrix(o)) return o.datatype+(sig?' MatrixTA':'');
  else if (Utils.isBuffer(o)) return 'Buffer';
  else if (typeof o == 'object') return '{'+Object.keys(o).map(function (key) {
    return key+':'+Math.datatype(o[key],sig)
  }).join(',')+'}';
  return typeof o;
}

// Multi-level: Math.decode(7,{A:1,B:2,C:4}) -> ['A','B','C']
// One-hot:     Math.decode([1,0,0],['A','B','C'])
Math.decode = function (value, codes,mutual) {
  var list=[],y=value;
  if (Utils.isArray(value) && Utils.isArray(codes)) {
    // One-hot
    return codes[value.indexOf(value.max())]
  }
  // Multi-level
  if (mutual == undefined) {
    var sum=0;
    Object.keys(codes).forEach(function (code,index) {
      if (codes[code] & sum) mutual=true;
      if (codes[code]==0) mutual=true;
      sum += codes[code];
    })
  }
  Object.keys(codes).forEach(function (code) {
    if (mutual || y<0 || codes[code]<0) {
      if (y==codes[code]) list.push(code) 
    } 
    else 
    if ((y & codes[code]) ||
        y==codes[code]) list.push(code);
  })
  return list; 
}

// API changed! h/points swapped!
Math.derivative = function (data,order,h,points) {
  // https://math.stackexchange.com/questions/302160/correct-way-to-calculate-numeric-derivative-in-discrete-time
  var result;
  data=data.data||data; // comp. with Matrix
  order=order||1;
  points=points||2;
  h=h||1;
  if (Utils.isArray(data)) {
    result=[];
    switch (order) {
      case 1:
        switch (points) {
          case 1:
            for(var i=0; i<(data.length-1); i++) {
              result.push((data[i+1]-data[i])/h);
            }
            break;
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-data[i-1])/(2*h));
            }
            break;
          case 3:
            for(var i=2; i<(data.length-3); i++) {
              result.push((data[i-2]-8*data[i-1]+8*data[i+1]-data[i+2])/(12*h));
            }
            break;
        }
        break;
       case 2:
        switch (points) {
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-2*data[i]+data[i-1])/(h*h));
            }
            break;
        }
        break;
    }
  }
  return result;
} 
Math.delta = function (p1,p2) {
  var pd=p1.length?[]:{};
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') pd[p]=p1[p]-p2[p];
  } 
  return pd;
}
Math.distance = function (p1,p2,one) {
  var y=one?1:0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') y+=Math.pow(p1[p]-p2[p],2);
  } else {
    for(var p in p1) 
      if (typeof p1[p] == 'number') y+=Math.pow(p1[p],2);
  }
  return Math.sqrt(y)-(one?1:0) 
}
Math.deviation = function (values) {
  // d3.deviation comp. via variance (n-1)
  var v = Math.variance(values);
  return v ? Math.sqrt(v) : v;
}
// For sorting; sort down
Math.down = function (a,b) {
  return a>b?-1:1
}
Math.equal = function (a,b) {
    var i;
    if (Utils.isNumber(a) && Utils.isNumber(b)) return a==b;
    else if (Utils.isArray(a) && Utils.isArray(b)) {
      if (a.length!=b.length) return false;
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isObject(a) && Utils.isObject(b)) {
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isString(a) && Utils.isString(b))
      return (a.length==b.length && a==b)
    return false;
  }
Math.frac = function (x,frac) {
  if (frac<=1) {
    frac=(1/frac)|0;
    return Math.round(x*frac)/frac;
  } else {
    return Math.floor(x-(x%frac));
  }
}
Math.id = function (x) { return x }
Math.int = function (x) { return x|0 }
Math.decr = function (x) { return x-1 }
Math.incr = function (x) { return x+1 }

Math.isFloat = function (x) {
  function isFloat32Array(x) {
    if (typeof x[0] == 'object') return isFloat32Array(x[0]);
    if (typeof x.data == 'object') return isFloat32Array(x.data);
    return (x instanceof Array) ||
           (x instanceof Float32Array) ||
           (x instanceof Float64Array)
  }
  return typeof x == 'number'?true:
          (typeof x == 'object'?isFloat32Array(x):false)
}
Math.isNumber = function (x) {
  return !isNaN(Number(x)) 
}

// Hilbert transform using FFT (input data length must be a power of 2!) 
// Returns real, imaginary, and magnitude (norm) vectors (same length as input)
Math.hilbert = function hilbert(inp) {
  var N=inp.length,
      N2=N/2,
      fft = Math.FFT.FFT(N);
  var re1 = inp.slice();
  var im1 = Array.vector(N);
  fft.fft1d(re1,im1)
  var re2=re1.slice();
  var im2=im1.slice();
  for(var i=1;i<N2;i++) { re2[i]*=2; im2[i]*=2; }
  for(var i=N2+1;i<N;i++) { re2[i]=0; im2[i]=0; }  
  fft.ifft1d(re2,im2);
  return {re:re2, im:im2, mag:re2.map(function (r,i) {
      return Math.sqrt(r*r+im2[i]*im2[i]);
    })
  }
}

// Find and return nearest point in a point series {x=index in points,y=best value}
Math.nearest = function (points,valu,epsilon,test) {
  var best;
  if (!test) {
    for(var i in points) {
      if (epsilon==undefined) { // find any nearest value
        if (best==undefined ||
            Math.abs(points[i]-valu)<Math.abs(points[best]-valu))
          best=i;
      } else {
        if ((best!=undefined && Math.abs(points[i]-valu)<Math.abs(points[best]-valu))||
            (Math.abs(points[i]-valu) <= epsilon)) best=i;
      }
    }
  }
  if (best!=undefined) return {x:best,y:points[best]}
}

Math.precision = function (number, precision) {
  if (precision==undefined) {
    precision=number;
    return function (number) { return Math.precision(number,precision) }
  }
  var factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
}
// generate gaussian noise (Standard Normal variate using Box-Muller transform)
// https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
Math.random.gaussian = function (min,max,skew) {
    min=min||0;
    max=max||1;
    skew=skew||1;
    var u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    var num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) num = Math.random.gaussian(min, max, skew); // resample between 0 and 1 if out of range
    num = Math.pow(num, skew); // Skew
    num *= max - min; // Stretch to fill range
    num += min; // offset to min
    return num;
}
// uniform distribution
Math.random.int = function (n) {
  return (Math.random()*n)|0
}
Math.random.int8 = function () {
  return 128-((Math.random()*256)|0)
}
Math.random.uint8 = function () {
  return (Math.random()*256)|0
}
Math.random.int16 = function () {
  var R=65536;
  return (R/2)-((Math.random()*R)|0)
}
Math.random.uint16 = function () {
  var R=65536;
  return (Math.random()*R)|0
}
Math.random.int32 = function () {
  var R=65536*65536;
  return (R/2)-Math.floor(((Math.random()*R)))
}
Math.random.uint32 = function () {
  var R=65536*65536;
  return Math.floor((Math.random()*R))
}
Math.random.range = function(min,max) {
  return min+Math.random()*(max-min)
}
Math.random.interval = function(min,max) {
  return Math.round(min+Math.random()*(max-min))
}
Math.random.noise = function(val,eps,relative) {
  return relative?val+Math.random.gaussian(-Math.abs(val*eps),Math.abs(val*eps)):val+Math.random.gaussian(-eps,eps);
}
Math.random.frac = function (a,b,frac) {
    var r,n,p,i,keys,k;
    if (Utils.isArray(a)) {
      n = a.length;
      if (n>0)
        return a[Math.random.int(n)];  
      else
        return none;
    } else if (Utils.isObject(a)) {
      keys=Object.keys(a);
      n = keys.length;
      if (n>0)
        return a[keys[Math.random.int(n)]];  
      else
        return none;
    } else if (b==undefined) {b=a;a=0}; 
    if (!frac ||frac==1)
      return Math.random.interval(a,b);
    else {
      r=Math.random.range(a,b);
      return ((r/frac)|0)*frac;
    }
}

// Random selection (one or multiple samples from collection / array / object)
Math.random.select = function (o,samples) {
  var r,n,p,i,keys,k;
  if (samples) {
    var A=[],index;
    var data = Utils.isArray(o)?o:Utils.isObject(o)?Object.keys(o):[];
    function shuffle(array) {
      var m = array.length, t, i;
      // While there remain elements to shuffle
      while (m) {
        // Pick a remaining element
        i = Math.floor(Math.random() * m--);
        // And swap it with the current element.
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }
      return array;
    }
    index=Array(data.length).fill().map(function (x,i) { return i });
    index=shuffle(index);
    for(var i=0;i<samples;i++) {
      A.push(data[index[i]]);
    }
    if (Utils.isArray(o)) return A;
    else if (Utils.isObject(o)) {
      return A.map(function (key) { o[key] });
    }
  }
  if (Utils.isArray(o)) {
    n = o.length;
    if (n>0)
      return o[Math.random.int(n)];  
    else
      return none;
  } else if (Utils.isObject(o)) {
    keys=Object.keys(o);
    n = keys.length;
    if (n>0)
      return o[keys[Math.random.int(n)]];  
    else
      return none;
  }
}

Math.pulse = function (length,off,on,pulses) {
  var v = Array.init(length,off);
  if (!Utils.isMatrix(pulses)) pulses=[pulses];
  pulses.forEach(function (pulse) {
    if (Utils.isArray(pulse) && pulse.length==2) 
      for(var i=pulse[0];i<=pulse[1];i++) v[i]=on;
  });
  return v;
}

// Reshape an array or a matrix
Math.reshape = function (array, rows, cols ) {
  var dims = cols!=undefined?[rows,cols]:[rows];
  function _reshape (array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array
    var tmpArray2
    // for each dimensions starting by the last one and ignoring the first one
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex]
      tmpArray2 = []

      // aggregate the elements of the current tmpArray in elements of the requested size
      var length = tmpArray.length / size
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size))
      }
      // set it as the new tmpArray for the next loop turn or for return
      tmpArray = tmpArray2
    }

    return tmpArray
  }
  function _flatten (array) {
    var flat = []

    array.forEach(function callback (value) {
      if (Array.isArray(value)) {
        value.forEach(callback) // traverse through sub-arrays recursively
      } else {
        flat.push(value)
      }
    })
    return flat
  }
  return _reshape(_flatten(array),dims)
  
}

Math.scale = function (vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return scala.shift+(vrow-scala.off)*scala.k
    else if (scala.length)
      return scala[0].shift+(vrow-scala[0].off)*scala[0].k;
    else
      return scala.shift+(vrow-scala.off[0])*scala.k[0];
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off)*scala.k })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return scala[i].shift+(col-scala[i].off)*scala[i].k })
  else
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off[i])*scala.k[i] })
}

// Compute scaling descriptor for a given data set -> [0,1]
// Target output range of scaled data: [shift+0,shift+1] with shift=shift||0;
Math.scale0 = function (data,lower,upper) {
  var min=data.min(),
      max=data.max();
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  return {
    k:(upper-lower)/(max-min),
    off:min,
    shift:lower,
    min:min,
    max:max
  }
}
Math.scale1 = function (min,max,lower,upper) {
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  return {
    k:(upper-lower)/(max-min),
    off:min,
    shift:lower,
    min:min,
    max:max
  }
}

// Select column(s) from array rows (array array matrix)
// Start column ia a, end column is b (column range)
Math.select = function (data,a,b){
  if (b==undefined) {
    return data.map(function(object) { 
      return object[a]
    })
  }else {
    return data.map(function(object) {
      return object.slice(a,b+1)
    })
  }
}

// Returns a number sequence set
Math.sequence = Array.sequence;

// Math core extensions
Math.signal = {
  chirp : function (N,period,offset,width) {
    var limiter=Math.gaussian(Math.sequence(1,N),offset,width),
        wave = Math.sequence(0,N-1,1,function (i) { return Math.sin(i/period*2*Math.PI) }).mul(limiter);
    return wave;
  },
  energy: function (data) {
    if (Utils.isArray(data)) {
      var s=0;
      data.forEach(function (v) {
        s+= Math.pow(v,2);
      });
      return s/data.length;
    }
  },
  filter : {
    boxcar : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||3;
      switch (points) {
        case 3:
          for(var i=1;i<array.length-1;i++) result.push(
            (array[i-1]+array[i]+array[i+1])/3
          );
          return result;
          break;
      }
    },
    lowpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.z == undefined) state.z=0;
      t=(1-k)*x+state.z*k;
      y=t;
      state.z=t;
      return y;
    },
    highpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.y == undefined) state.y=0;
      if (state.x == undefined) state.x=0;
      // t=(1-k)*x+state.z*(-k);
      t=k*(state.y+x-state.x);
      y=t;
      state.y=t;
      state.x=x;
      return y;    
    },
    // Function constructors
    lowPass : function (k,state) {
      return function (x) { return Math.signal.filter.lowpass(x,k,state) }
    },
    highPass : function (k,state) {
      return function (x) { return Math.signal.filter.highpass(x,k,state) }
    },
    triangular : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||5;
      switch (points) {
        case 5:
          for(var i=2;i<array.length-2;i++) result.push(
            (array[i-2]+2*array[i-1]+3*array[i]+2*array[i+1]+array[i+2])/9
          );
          return result;
          break;
      }
    },
    
  },
  meanAbsoluteDeviation: function(data) {
    var mean = Math.signal.mean(data);
       return Math.signal.mean(data.map(function(num) {
         return Math.abs(num - mean);
       }));
  },
  mean:function (data) { return data.mean() },
  peak: function (data) {
    if (Utils.isArray(data)) {
      return Math.max(Math.abs(data.max()),Math.abs(data.min()));
    }  
  },
  rms: function (data) {
    return Math.sqrt(data.map(Math.sq).sum()/data.length)
  },
  sample : function (data,frag,filter) {
    return data.sample(frag,filter)
  },
  standardDeviation: function(data) {
    return Math.sqrt(Math.signal.variance(data));
  },
  variance: function (data) {
    if (Utils.isArray(data)) {
      return data.variance()
    }
  },
}

Math.sq = function (x) { return x*x }

Math.sum = function (a,b) {
  return a+b
}
// Return unique identifier name [a-zA-Z0-9]
Math.unique = function (length) {
  return Math.random().toString(36).substr(2, 2+length);
}
// For sorting; sort up
Math.up = function (a,b) {
  return a<b?-1:1
}

Math.variance = function (values) {
  var count = 0;
  var delta;
  var mean = 0;
  var sum = 0;
  for (var value of values) {
    if (value != null && (value = +value) >= value) {
      delta = value - mean;
      mean += delta / ++count;
      sum += delta * (value - mean);
    }
  }
  if (count > 1) return sum / (count - 1);
}

Math.window = {
  // window functions returning mask array of width w
  // https://github.com/scijs/window-function
  
  //////////////// WINDOWS ////////////////
  gaussian : function (w,sigma) {
    var res=[];
    sigma=sigma||0.4;
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i-nm12)/sigma/nm12,
          h=Math.exp(-0.5*f*f);
      res.push(h)
    }
    return res;
  },
  
  hamming : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 0.54 - 0.46 * Math.cos(Math.PI*2*i/(w-1));
      res.push(h)
    }
    return res;
  },
  
  hann: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      var t = -0.9999999+2*(i/(w+1));
      var h = Math.sqrt(2)/2 * (1+Math.cos(t*Math.PI)) / 
              Math.sqrt(1+Math.pow(Math.cos(t*Math.PI),2) ) * (
              Math.abs(t)<1?1:0);
      res.push(h)
    }
    return res;
  },
  
  rect: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      res.push(1)
    }
    return res;
  },
  
  triangular : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 1 - Math.abs( 2 * (i - 0.5*(w-1)) / w );
      res.push(h)
    }
    return res;
  },
  
  welch : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i - nm12)/nm12,
          h = 1 - f*f  ;
      res.push(h)
    }
    return res;
  },
  
  /////////////////////// MASKING /////////////////////  
  mask: function (data,off,width,win,arg) {
    var mask = (win||Math.window.hann)(width,arg);
    var res=[];
    for(var i=0;i<width;i++) res.push(data[off+i]*mask[i]);
    return res;
  },
  

}
Math.zip = function (v1,v2) {
  if (typeof v1[0]=='number' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return [row,v2[index]]
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return row.concat(v2[index])
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return row.concat([v2[index]])
    })
  if (typeof v1[0]=='number' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return [row].concat(v2[index])
    })
  
} 
if (typeof module != 'undefined') module.exports=Math
if (typeof window != 'undefined') console.log('Math '+Math.version+' loaded.');
};
BundleModuleCode['plugins/math/matrixTA']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.13.3X
 **
 **    $INFO:
 **
 **  Numerical Matrix Module associated with typed arrays, but with generic array compatibility. 
 **  A matrix provides a wrapper and multi-dimensional array view for one-dimensional byte arrays (typed arrays using buffers).
 **
 **  Examples:
 **
 ** // From shared array buffer:
 ** Math.MatrixTA({data:function (size) { return new SharedArrayBuffer(size) } OR data:SharedArrayBuffer(size),
 ** rows:10,columns:10,datatype:'Float32'})
 **
 ** // From shared memory segment
 ** var sm = BufferSegment(...);
 ** Math.MatrixTA({
 **  data : sm,
 **  rows:10,columns:10,datatype:'Float32'
 ** });
 **
 **
 **    $ENDOFINFO
 */

var version = "1.13.3X"

var utils  =  Require('plugins/math/matrixTA-utils');
var Vector =  Require('plugins/math/vectorTA');

var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

integer = function (v)  { return Math.floor(v) }
divide = function (a,b) { return Math.floor(a/b) }


var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString,
    DataSize = Utils.DataSize,
    TypedArrayOfName = Utils.TypedArrayOfName;


function todo (what) { throw ("Not implemented: Matrix."+what) }
function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(name+'must be a number');
  }
}
function transpose (layout) {
  switch (layout) {
    case 12: return 21;
    case 21: return 12;
  }
}
/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

// Most generic versions - always overwrite (polyfill/vector definitions)
Object.updateProperty(Array,'get', function (i,j,k) {
  if (k!=undefined)
   return this[i][j][k];
  else if (j!=undefined)
   return this[i][j];
  else
   return this[i];
})
Object.updateProperty(Array,'getRow', function (i) {
 return this[i];
})

Object.updateProperty(Array,'info', function () {
  var rows,columns,levels;
  if (isArrayArrayArray(this)) levels=this.length,rows=this[0].length,columns=this[0][0].length;
  else if (isArrayArray(this)) rows=this.length,columns=this[0].length;
  else columns=this.length;
  if (levels) return {
    dtn:'Array',
    size:levels*rows*columns,
    levels:levels,
    rows:rows,
    columns:columns,
    dims:3,
    offset:0,
  }; else if (rows) return {
    dtn:'Array',
    size:rows*columns,
    rows:rows,
    columns:columns,
    dims:2,
    offset:0,
  }; else return {
    dtn:'Array',
    size:columns,
    columns:columns,
    dims:1,
    offset:0,
  }
})


Object.updateProperty(Array,'mapRow', function (i,f) {
 return this[i].map(f);
})

Object.updateProperty(Array,'max', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] > m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] > m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.max.apply(null, this) // vector
  else   // matrix
    return Math.max.apply(null,this.map(function (row) { return Math.max.apply(null, row) }))
})


Object.updateProperty(Array,'mean', function () {
  if (typeof this[0] == 'number')
    return this.sum()/this.length // vector
  else   // matrix
    return this.sum()/(this.length*this[0].length)
})

// this and b can be vectors or matrix objects
// returns always a matrix
Object.updateProperty(Array,'merge', function (b,align) {
  var a=this;
  if (!b || a.length!=b.length) throw "array.merge: length mismatch";
  if (align && align.indexOf('c')==0) {
    // columns alignment ab
    if (Utils.isArray(a[0]))
      return a.map(function (row,index) {
        return Utils.isArray(row)?row.concat(b[index]):[row,b[index]];
      });
    else // a is vector
      return a.map(function (row,index) {
        return Utils.isArray(row)?[row].concat(b[index]):[row,b[index]];
      })
  } else if (!align || align.indexOf('r')==0) {
    // row alignment a
    //               b
    if (!Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b).map(function (row) { return [row] });
    else if (Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b.map(function (row) { return [row] }));
    else if (!Utils.isArray(a[0]) && Utils.isArray(b[0])) return a.map(function (row) { return [row] }).concat(b);
    else return a.concat(b);
  }
})

Object.updateProperty(Array,'min', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] < m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] < m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.min.apply(null, this) // vector
  else    // matrix
    return Math.min.apply(null,this.map(function (row) { return Math.min.apply(null, row) }))
})


Object.updateProperty(Array,'pluck', function (key) {
  var collection=this;
  return collection.map(function(object) {
    return object == null ? undefined : object[key];
  });
})

Object.updateProperty(Array,'print', function (format) {
  var i,j,k,s='',sep='', info=this.info();
  if (!format) format = '%4.2f';
  switch (info.dims) {
    case 1:
      for(j=0;j<info.columns;j++) {
        if (j!=0) s = s + '\n';
        s = s + sprintf(format,this[j]) ;
      }
      break;
    case 2:
      for(j=0;j<info.rows;j++) {
        sep = '';
        if (j!=0) s = s + '\n';
        for (i=0;i<info.columns;i++) {
          s = s + sep + sprintf(format,this[j][i]) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<info.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(j=0;j<info.rows;j++) {
          sep = '';
          if (j!=0) s = s + '\n';
          for (i=0;i<info.columns;i++) {
            s = s + sep + sprintf(format,this[k][j][i]) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
})

Object.updateProperty(Array,'prod', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a*b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a*b })
    }).reduce(function (a,b) { return a*b })
})

// sub(row number|[row0,row1]|[[rowa,rowb,rowc,..]],col number|[col0,col1]|[[cola,colb,colc,..]])
Object.updateProperty(Array,'sub', function (i /*row/col*/,j /*col?*/) {
  var res;
  if (typeof i == 'number') res = this[i];
  else if (isArrayArray(i)) {
    res=[]
    for(var k in i[0]) {
      res.push(this[i[0][k]])
    }
  } else if (isArray(i) && i.length==2) res = this.slice(i[0],i[1]+1);
  else res=this;
  if (!isArrayArray(res)) {
    if (typeof j == 'number') res = res[j];
    else if (isArrayArray(j)) {
      res=res.filter(function (col,coli) {
        return j[0].indexOf(coli)!=-1
      })
    } else if (isArray(j) && j.length==2) res = res(j[0],j[1]+1);
  } else if (isArray(res)) {
    if (typeof j == 'number') 
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a[j]]:a).concat([b[j]]) });
    else if (isArrayArray(j)) {
      res=res.map(function (row) {
        return row.filter(function (col,coli) {
          return j[0].indexOf(coli)!=-1
        })
      })
    } else if (isArray(j) && j.length==2)
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a.slice(j[0],j[1]+1)]:a)
                .concat([b.slice(j[0],j[1]+1)]) });
  }
  return res;
})

Object.updateProperty(Array,'set', function (a,b,c,d) {
  if (d!=undefined)
   return this[a][b][c]=d;
  else if (c!=undefined)
   return this[a][b]=c;
  else
   return this[a]=b;
})

Object.updateProperty(Array,'setRow', function (i,row) {
 return this[i]=row;
})

Object.updateProperty(Array,'sum', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a+b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a+b })
    }).reduce(function (a,b) { return a+b })
})

// [][] -> [] == flat
Object.updateProperty(Array,'unwrap', function () {
  return this.flat();
})

Object.updateProperty(Array,'variance', function () {
  // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
  var sigma1=0,sigma2=0,n=0;
  if (typeof this[0] == 'number') {
    for(var i=0;i<this.length;i++) {
      sigma1 += (this[i]*this[i]);
      sigma2 += this[i];
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/this.length)/this.length);
  } else {  // matrix
    for(var i=0;i<this.length;i++) {
      for(var j=0;j<this[i].length;j++) {
        sigma1 += (this[i][j]*this[i][j]);
        sigma2 += this[i][j];
        n++;
      }
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/n)/n);
  }
})

// [] -> [][]
Object.updateProperty(Array,'wrap', function () {
  return this.map(function (row) { return [row] });
})



/****************** MATRIX ***************************/
// Matrix object based on typed arrays!
// Supports mixed mode typed arrays and generic arrays!
// {type:function,dtn:string} specifies data type
//
// dataspace : [levels,rows,columns]
// Usage:
// Matrix(columns:number)
// Matrix(rows:number,columns:number)
// Matrix(rows:number,columns:number,levels:number)
// Matrix(rows:number,columns:number,options:{dtn:string})
// Matrix([])
// Matrix([][])
// Matrix([][][])
// Matrix({data:buffer|typedarray|SharedArrayBuffer,rows:numner,columns:number,dtn:..})
//
// typeof return = Matrix

function Matrix (a,b,c,d) {
  var self = this;
  var rows,columns,levels,dims=2,dtn,dt=Matrix.options.dt,data,
      layout=12,size,transpose,offset=0;
  var options = isObject(d)?d:(isObject(c)?c:(isObject(b)?b:{}));
  this.tag='MatrixTA';
  if (!(this instanceof Matrix)) return new Matrix(a,b,c,d);
  if (isNumber(a) && isNumber(b)) {
    // Create new empty matrix (2/3 dims)
    rows=a;
    columns=b;
    if (isNumber(c)) levels=c;
    dims=levels?3:2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    size=rows*columns;
    if (levels) size *= levels;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.data)
      data=new dt(options.data);
    else if (dt.name=='Array')
      data=new Array(rows).fill(null).map(function (row) { return new Array(columns).fill(0) });
    else
      data=new dt(size);
  } 
  else if (isNumber(a)) {
    // Create a new empty matrix vector (rows=1)
    rows=1;
    columns=a;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    size=columns;
    if (options.data)
      data=new dt(options.data);
    else
      data=new dt(size);
  } 
  else if (isArrayArray(a)) {
    if (options.datatype) options.dtn=options.datatype+'Array';
    rows=a.length;
    columns=a[0].length;
    if (isArrayArrayArray(a)) levels=rows,rows=a[0].length,columns=a[0][0].length;
    size=rows*columns;
    if (levels) size *= levels;
    dims=levels?3:2;
    if (options.type) dt=options.type;
    if (options.dtn)  {
      dt=TypedArrayOfName[options.dtn];
    }
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(size);
      switch (layout) {
        case 12:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[coli+rowi*columns]=col;
            })
          });
          break;
        case 21:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[rowi+coli*rows]=col;   // TBCHECK!
            })
          });
          break;
      }
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isArray(a)) {
    // Vector 
    rows=1;
    columns=a.length;
    size=columns;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=[a];
    }
  } else if (a instanceof Matrix) {
    if (options.transpose) {
      // transposeView !
      rows=a.columns;
      columns=a.rows;
      levels=a.levels;
      size=a.size;
      dims=a.dims;
      transpose=true;
      data=a.data;
      dtn=a.dtn;
      switch (a.layout) {
        case 12: layout=21; break;
        case 21: layout=12; break;
        case 123: layout=321; break;
        case 321: layout=123; break;
      }
    } else {
      // Copy (and convert?)
      if (options.datatype) options.dtn=options.datatype+'Array';
      rows=options.rows||a.rows;
      columns=options.columns||a.columns;
      levels=options.levels||a.levels;
      dims=a.dims;
      size=rows*columns;
      if(levels) size*=levels;
      transpose=false;
      scale=options.scale;
      if ((options.dtn && options.dtn != a.dtn) || size != a.size) {
        // convert or resize dtn
        dtn = options.dtn;
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      } else {
        dtn=a.dtn;
        if (dtn != 'Array')
          data=a.data.slice();
        else {
          // TODO dims=3
          data=a.data.map(function (row) { return row.slice() });
        }
      }
      if (a.scale) this.scale=a.scale;
      if (a.complex) this.complex=a.complex;
      layout=a.layout;
    }
  } else if (isObject(a)) {
      // Partial matrix object
      if (a.dataspace) {
        if (a.dataspace.length==1)
          a.rows=1,a.columns=a.dataspace[0];
        else if (a.dataspace.length==2) 
          a.rows=a.dataspace[0],
          a.columns=a.dataspace[1];
        else if (a.dataspace.length==3) 
          a.levels=a.dataspace[0],
          a.rows=a.dataspace[1],
          a.columns=a.dataspace[2];
      }
      if (a.datatype) a.dtn=a.datatype+'Array';
      rows=a.rows||(a.y && a.x);
      columns=a.columns||a.y||a.x;
      levels=a.levels||a.z;
      size=a.size||((rows?rows:1)*(columns?columns:1)*(levels?levels:1));
      dims=a.dims||(levels?3:(rows?2:1));
      layout=a.layout||(levels?123:(rows?12:1));
      dtn=a.dtn||'Float32Array';
      dt=TypedArrayOfName[a.dtn];
      if (!a.data) a.data=new dt(size);
      if (typeof BufferSegment != 'undefined' && a.data instanceof BufferSegment) {
        // Buffer segment allocated data
        this.block = a.data.object(a.dtn,size);
        a.data = this.block.data;
        delete this.block.data;
      } else if (typeof a.data == 'function') {
        // allocation function for a buffer returning array buffer or segment block with sliced buffer ..
        var block=a.data(size*DataSize[dtn.replace(/Array/,'')]);
        if (Utils.isBufferArray(block)) a.data=block; 
        else {
          this.block={addr:block.addr,size:block.size,segment:block.segment};
          a.data=block.data;
        }
      } else if (a.block) {
        // Buffer sgement allocated data, too
        this.block=a.block;
        var sm = BufferSegments[a.block.segment];
        if (sm) {
          var block = sm.object(dtn,size,this.block.addr);
          a.data=block.data;
        }
      } 
      
      if (Utils.isBuffer(a.data)) data=new dt(a.data.buffer,a.offset);
      else if (Utils.isBufferArray(a.data)) data=new dt(a.data,a.offset);
      else
        data=a.data;
  }
  if (levels) this.levels=levels;   // z
  this.rows     = rows;                   // x
  this.columns  = columns;             // x/y
  this.size     = size;              // number of elements
  this.layout   = layout;
  this.data     = data;
  this.dims     = dims;
  this.dataspace  = levels?[levels,rows,columns]:[rows,columns];
  this.length   = levels?levels:(rows?rows:columns);
  
  this.dtn=dtn||dt.name;
  this.datatype=this.dtn.replace(/Array/,'');
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  // get/set index order: 
  // 1. column(x)
  // 2. row(x),column(y)
  // 3. row(x),column(y),level(z)
  

  if (Matrix.options.compatLayout) {
    // Old WRONG layouts; but needed for backward compatibility! Enabled with Matrx.options.compatLayout=true;
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (column,row)   { return this.data[row][column] };
          this.set=function (column,row,v) { this.data[row][column]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[row][column][level] };
          this.set=function (row,column,level,v) { this.data[row][column][level]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 12:
        // x=row,y=column
        this.index = function (x,y)   { return x*this.columns+y}
        this.get = function (x,y)     { return this.data[x*this.columns+y] }
        this.set = function (x,y,v)   { return this.data[x*this.columns+y]=v }
        break;
      case 21:
        // x=row,y=column      
        this.index = function (x,y)   { return y*this.rows+x }
        this.get = function (x,y)     { return this.data[y*this.rows+x] }
        this.set = function (x,y,v)   { return this.data[y*this.rows+x]=v }
        break;
      case 123:
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+y*this.columns+x*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[z+y*this.levels*this.rows+x*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+y*this.levels*this.rows+x*this.levels]=v }
        break;
      case 321:
        // x=row,y=column,z=level
        // TBC
        this.index = function (x,y,z) { return x+y*this.rows+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[x+y*this.rows+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[x+y*this.rows+z*this.columns*this.rows]=v }
        break;
    }

  } else {
    // New correct layouts!
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (row,column)   { return this.data[column][row] };
          this.set=function (row,column,v) { this.data[column][row]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[level][row][column] };
          this.set=function (row,column,level,v) { this.data[level][row][column]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // C0,C1,..
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 21:
        // C0:R0R1..RM,C1:R0R1..RM,..
        // x=row,y=column
        this.index = function (x,y)   { return x+y*this.rows}
        this.get = function (x,y)     { return this.data[x+y*this.rows] }
        this.set = function (x,y,v)   { return this.data[x+y*this.rows]=v }
        break;
      case 12:
        // R0:C0C1..CN,R1:C0C1..CN,..
        // x=row,y=column      
        this.index = function (x,y)   { return y+x*this.columns }
        this.get = function (x,y)     { return this.data[y+this.columns*x] }
        this.set = function (x,y,v)   { return this.data[y+this.columns*x]=v }
        break;
      case 321:
        // C0: R0:L0L1..LO,R1:L0L1..LO,..
        // C1: ..
        // x=row,y=column,z=level
        // TBC??
        this.index = function (x,y,z) { return z+x*this.levels+y*this.levels*this.rows }
        this.get = function (x,y,z)   { return this.data[z+x*this.levels+y*this.levels*this.rows] }
        this.set = function (x,y,z,v) { return this.data[z+x*this.levels+y*this.levels*this.rows]=v }
        break;
      case 312:
        // RGB format!!!!!
        // R0: C0:L0L1..LO,C1:L0L1..LO,..
        // R1: ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+x*this.levels*this.columns+y*this.levels }
        this.get = function (x,y,z)   { return this.data[z+x*this.levels*this.columns+y*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+x*this.levels*this.columns+y*this.levels]=v }
        break;
      case 123:
        // Z0: R0:C0C1..CN,R1:C0C1..CN,.. 
        // Z1; ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return y+x*this.columns+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[y+x*this.columns+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[y+x*this.columns+z*this.columns*this.rows]=v }
        break;
    }
  }
  this.__constructor__='Math.MatrixTA';
}



Matrix.options = {
  // Degault TA change must be applied to dt (and dtn)!
  dt : Float32Array,
  dtn : 'Float32Array',
  compatLayout : false,   // old wrong matrix layout for backward compatibility
}


/******** STATIC MEMBERS ********/
Matrix.abs = function (m) {
  return Matrix.clone(m).abs();
}

Matrix.add = function (m,v) {
  return Matrix.clone(m).add(v);
}

Matrix.clone = function (src) {
  return Matrix(src);
}

Matrix.columnVector = function (array) {
  return Matrix(array)
}

// Return an (typed)array
Matrix.checkArray = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof _MatrixConstructor) return arrayOrMatrix.data;
  else return arrayOrMatrix;
}

// Return a Matrix
Matrix.checkMatrix = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof Matrix) return arrayOrMatrix;
  else return Matrix(arrayOrMatrix);
}

Matrix.checkMatrixSize = function (matrix1,matrix2) {
  if (matrix1.dims != matrix2.dims) return false;
  if (matrix1.rows != matrix2.rows ||
      matrix1.columns != matrix2.columns ||
      matrix1.levels != matrix2.levels ) return false;
}

Matrix.cos = function (m) {
  return Matrix.clone(m).cos();
}

Matrix.crop = function (m,bbox) {
  if (m.dims!=2) throw "Matrix.crop: matrix.dims<>2";
  if (Utils.isArray(bbox)) {
    // [x,y,w,h]
    return m.subMatrix(bbox[1],bbox[1]+bbox[3]-1,
                       bbox[0],bbox[0]+bbox[2]-1)
  } else if (Utils.isObject(bbox) && bbox.w && bbox.h) {
    // {x,y,w,h}
    return m.subMatrix(bbox.y,bbox.y+bbox.h-1,
                       bbox.x,bbox.x+bbox.w-1)  
  } else if (Utils.isObject(bbox) && bbox.width && bbox.height) {
    // {x,y,width,height}
    return m.subMatrix(bbox.y,bbox.y+bbox.height-1,
                       bbox.x,bbox.x+bbox.width-1)  
  }
}

Matrix.diag = function (array,rows,columns) {
  if (!rows) rows=array.length;
  if (!columns) columns=rows;
  if (rows!=columns) Matrix.error("Not a square matrix",'diag');
  return Matrix(rows,columns).fill(function (i,j) {
    return i==j?array[i]:0;
  })
}

Matrix.div = function (m,v) {
  return Matrix.clone(m).div(v);
}

Matrix.empty = function (rows,columns) {
  return Matrix(rows,columns);
}

Matrix.error = function (what,where,ref) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.errorRange = function (what,where,ref) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

Matrix.eye = function (rows,columns,val,options) {
  if (!val) val=1;
  if (!columns) columns=rows;
  return Matrix(rows,columns,options).fill(function (i,j) {
    return i==j?val:0;
  });
}
 
Matrix.exp = function (m) {
  return Matrix.clone(m).exp();
}

// create an Uint8 RGB Matrix from raw image data [3,rows,columns]
Matrix.fromImage = function (width,height,imgData) {
  // imgData is RGBA => RGB layout 123
  var mat = Matrix({
    rows:height,
    columns:width,
    levels:3,
    layouet:123,
    datatype : 'Uint8',
  })
  var row=0,col=0;
  for(var i=0;i<imgData.length;i=i+4) {
    var r=imgData[i],
        g=imgData[i+1],
        b=imgData[i+2],
        a=imgData[i+3]/255,
        r2=255,g2=255,b2 = 255;
    var r3 = Math.round(((1 - a) * r2) + (a * r))
    var g3 = Math.round(((1 - a) * g2) + (a * g))
    var b3 = Math.round(((1 - a) * b2) + (a * b))
    mat.set(row,col,0,r3);
    mat.set(row,col,1,g3);
    mat.set(row,col,2,b3);
    col++;
    if (col==width) { col=0; row++ };
  }
  return mat;
}

Matrix.isMatrix = function (o) {
  return (o instanceof Matrix)
}

// Identity matrix (squared)
Matrix.I = function (n,options) { return Matrix.eye(n,n,1,options) };

Matrix.max =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','max');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
    case 3:
      break;
  }
  return result;
}

Matrix.min =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','min');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, levels, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
  }
  return result;
}


Matrix.mod = function (m,v) {
  return Matrix.clone(m).mod(v);
}

Matrix.mul = function (m,v) {
  return Matrix.clone(m).mul(v);
}

Matrix.neg = function (m) {
  return Matrix.clone(m).neg();
}

Matrix.ones = function (rows,columns) {
  return Matrix(rows,columns).fill(1);
}

Matrix.rand = function (rows, columns, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return rng();
  });
}
/* rows, [cols,] [levels] options? */
Matrix.Random = function (a,b,c,d) {
  var dataspace=[],options={};
  if (typeof c == 'number') dataspace.push(c);  
  if (typeof a == 'number') dataspace.push(a);  
  if (typeof b == 'number') dataspace.push(b);  
  if (typeof a == 'object') options=a;
  if (typeof b == 'object') options=b;
  if (typeof c == 'object') options=c;
  if (typeof d == 'object') options=d;
  if (dataspace.length) options.dataspace=dataspace;
  if (!options.datatype) options.datatype='Float32';
  var mat = Matrix(options);
  var rng=Math.random;
  if (/int8/.test(options.datatype)) rng=function() { return (Math.random()*255)|0 };
  if (/int16/.test(options.datatype)) rng=function() { return (Math.random()*(65535))|0 };
  if (/int32/.test(options.datatype)) rng=function() { return (Math.random()*(4294967295))|0 };  
  mat.fill(rng);
  return mat
}
Matrix.randInt = function (rows, columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}
// resize a matrix (up- and downscaling) with different algorithms
// resize supports:
// 'nn': nearest neighbor algorihm (default, up- and down.scaling)
// 'mean': mean filter kernel (down-scaling)
// 'min': minimum value slection filter kernel (down-scaling)
// 'max': maximum value selection filter kernel (down-scaling)
// 'linear: bilinear filter kernel (up-sclaing)

Matrix.resize = function (src,a,b,c,d) {
  var dataspaceSrc=src.dataspace,
      datatype=src.datatype,
      meth='nn',
      options={},
      dataspaceDst=[];
  if (typeof a == 'number') dataspaceDst.push(a);
  if (typeof b == 'number') dataspaceDst.push(b);
  if (typeof c == 'number') dataspaceDst.push(c);
  if (typeof b == 'string') meth=b;
  if (typeof c == 'string') meth=c;
  if (typeof d == 'string') meth=d;  
  var dst = Matrix({dataspace:dataspaceDst,datatype:datatype});
  if (src.dims==2) {
    var rows=dst.rows,
        cols=dst.columns,
        rowsS=src.rows,
        colsS=src.columns,
        rowSD=rowsS/rows,
        colSD=colsS/cols;
    // default nearest neighbor method
    if (meth=='nn') {
      for(var i=0;i<rows;i++)
        for(var j=0;j<cols;j++) {
          var iS=Math.floor(i*rowSD),
              jS=Math.floor(j*colSD);
          dst.set(i,j,src.get(iS,jS)); 
      }
    } else if (meth=='mean') {
      if (rowSD>1 && colSD>1) {
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var sum=0,n=0;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { sum+=v;  } n++; /* padding with zeros? */
          }
          return sum/n;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='max' || meth=='peak') {
      if (rowSD>1 && colSD>1) {
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var max;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { max=max==undefined?v:Math.max(v,max) } 
          }
          return max;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='min') {
      if (rowSD>1 && colSD>1) {
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var min;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { min=min==undefined?v:Math.min(v,min) } 
          }
          return min;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='linear') {
      if (rowSD>1 && colSD>1) {
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var sum=0,n=0;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              var w = 1-Math.distance([i-row,j-col])/Math.distance([rowR,colR]);
              if (v!=undefined)  { sum+=(v*w); }  n++; /* padding with zeros? */
          }
          return sum/n;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else if (rowSD<1 && colSD<1) {
        // see https://chao-ji.github.io/jekyll/update/2018/07/19/BilinearResize.html
        var rowR=rowsS/rows,
            colR=colsS/cols;
        function kernel(i,j) {
          var x_l = Math.floor(colR * j), y_l = Math.floor(rowR * i)
              x_h = Math.ceil(colR * j),  y_h = Math.ceil(rowR * i);
          var x_weight = (colR * j) - x_l,
              y_weight = (rowR * i) - y_l;
          var a = src.get(y_l, x_l)||0,
              b = src.get(y_l, x_h)||0,
              c = src.get(y_h, x_l)||0,
              d = src.get(y_h, x_h)||0;
          return a * (1 - x_weight) * (1 - y_weight) + 
                 b * x_weight * (1 - y_weight) + 
                 c * y_weight * (1 - x_weight) + 
                 d * x_weight * y_weight
        }
        // up-scaling; extrapolation
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            dst.set(i,j,kernel(i,j));
        }
      } else throw "Matrix.resize: not supported resize method";
    } else throw "Matrix.resize: not supported resize method";
  }
  return dst;
}

Matrix.sin = function (m) {
  return Matrix.clone(m).sin();
}

Matrix.sub = function (m,v) {
  return Matrix.clone(m).sub(v);
}

Matrix.toImage = function (matrix) {
  switch (matrix.dims) {
    case 2:
      var data = new Uint8Array(matrix.size*4);
      matrix.forEach(function (v,row,col) {
        data[0+col*4+row*matrix.columns*4]=v;
        data[1+col*4+row*matrix.columns*4]=v;
        data[2+col*4+row*matrix.columns*4]=v;
        // set alpha to 255
        data[3+col*4+row*matrix.columns*4]=255;
      });
      break;
    case 3:
      var data = new Uint8Array(matrix.rows*matrix.columns*4);
      matrix.forEach(function (v,row,col,level) {
        data[level+col*4+row*matrix.columns*4]=v;
        // set alpha to 255
        data[3+col*4+row*matrix.columns*4]=255;
      });
      break;
  }
  return data;
}

Matrix.zero = function (rows,columns) {
  return Matrix(columns,rows).fill(0);
}

Matrix.version = version;

/********* INSTANCE MEMBERS *********/


Matrix.prototype.abs = function (v) {
  this.eval(Math.abs);
  return this; 
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.add = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] += v.data[i];
    return result;
  } else result.eval(function (x) {return x+v});
  return result; 
}

// Apply a function to all elements AND update the elements by the return value of f!
Matrix.prototype.apply = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        this.set(j,f.call(this,this.get(j),j))
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          this.set(i,j,f.call(this,this.get(i,j),i,j))
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            this.set(i,j,k,f.call(this,this.get(i,j,k),i,j,k))
      return this;
  }
}

// Iterate over all elements of matrix and apply function to matrix elements (w/o matrix update)
Matrix.prototype.forEach = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        f.call(this,this.get(j),j)
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          f.call(this,this.get(i,j),i,j)
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            f.call(this,this.get(i,j,k),i,j,k)
      return this;
  }
}

Matrix.prototype.checkIndex = function(x,y,z) {
  switch (this.dims) {
    case 1: return x>=0&&x<this.columns;
    case 2: return y>=0&&y<this.columns&&x>=0&&x<this.rows;
    case 3: return y>=0&&y<this.columns&&x>=0&&x<this.rows&&z>=0&&z<this.levels;
  }
}

Matrix.prototype.checkMatrixDims = function(dims) {
  if (this.dims != dims) this.errorRange('Matrix has not expected dimension '+dims);
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkColumnIndex = function(index, outer) {
  var max = outer ? this.columns : this.columns - 1;
  if (index < 0 || index > max) this.errorRange('Column index out of range');
}


/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkRowIndex = function(index, outer) {
  var max = outer ? this.rows : this.rows - 1;
  if (index < 0 || index > max)
    this.errorRange('Row index out of range');
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkRowVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.columns) 
    this.errorRange(
      'vector size must be the same as the number of columns'
    );
  
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkColumnVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.rows) 
    this.errorRange('vector size must be the same as the number of rows');
  
  return vector;
}

Matrix.prototype.checkIndices = function(rowIndices, columnIndices) {
  return {
    row: this.checkRowIndices(rowIndices),
    column: this.checkColumnIndices(columnIndices)
  };
}

Matrix.prototype.checkRowIndices = function(rowIndices) {
  var self=this;
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= self.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

Matrix.prototype.checkColumnIndices = function(columnIndices) {
  var self=this;
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= self.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

Matrix.prototype.checkRange = function(startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 4) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= this.rows ||
    endRow < 0 ||
    endRow >= this.rows ||
    startColumn < 0 ||
    startColumn >= this.columns ||
    endColumn < 0 ||
    endColumn >= this.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

Matrix.prototype.clone = function () {
  return Matrix(this);
}


// Return array or vector
Matrix.prototype.col = function (index,asVector) {
  var col=[];
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 2: col=this.data.pluck(index); break;
        case 3: throw new Error ('EINVALID');
      }
    default:
      switch (this.dims) {
        case 2: for(var i=0;i<this.rows;i++) col.push(this.get(i,index)); break;
        case 3: throw new Error ('EINVALID');
      }
  }
  return asVector?Math.VectorTA(col,{dtn:this.dtn}):col;
}

Matrix.prototype.getCol = Matrix.prototype.col;
Matrix.prototype.pluck = Matrix.prototype.col;

/** Copy (1) a sorurce array (vector) into this matrix (row/column w or w/o subrange), or (2) create a copy of this matrix (empty argument list)
 *
 * copy()
 * copy([a,b]|[],[v1,v2,...])
 * copy(number,[a,b]|[],[v1,v2,...])
 * copy([a,b]|[],number,[v1,v2,...])
 * copy(number,number,[a,b]|[],[v1,v2,...])
 * ..
 */
 
Matrix.prototype.copy = function (a,b,c,d) {
  var x,y,z,rx,ry,rz,i,j,k,src;

  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;

  if (isArray(d)) src=d;
  if (isVector(d)) src=d;
  
  if (!src && !d && (isArray(c) || isVector(c))) src=c,rz=undefined;
  if (!src && !c && (isArray(b) || isVector(b))) src=b,ry=undefined;
  if (!src && !a && (isArray(a) || isVector(a))) src=a,rx=[0,this.columns-1];  // 1-dim only
    
  if (isVector(src)) src=src.data;
  if (!src) return Matrix({
    rows:this.rows,
    columns:this.columns,
    levels:this.levels,
    dtn:this.dtn,
    layout:this.layout,
    data:this.data.slice()
  })
  
  if (!src) throw "Matrix.copy: no source array provided";
  if (rx && rx.length==0) rx=[0,this.rows-1];
  if (ry && ry.length==0) ry=[0,this.columns-1];
  if (rz && rz.length==0) rz=[0,this.levels-1];
  if (rx && (rx[1]-rx[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (ry && (ry[1]-ry[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (rz && (rz[1]-rz[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
   
  switch (this.dims) {
    case 1:
      for(x=rx[0];x<rx[1];x++) this.data[x]=src[x-rx[0]];
      break;
    case 2:
      if (rx && j != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j)]=src[x-rx[0]];
      else if (i != undefined && ry)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y)]=src[y-ry[0]];
      else todo('copy 2'); 
      break;   
    case 3:
      if (rx && j != undefined && k != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j,k)]=src[x-rx[0]];
      else if (ry && i != undefined && k != undefined)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y,k)]=src[y-ry[0]];
      else if (rz && i != undefined && j != undefined)
        for(z=rz[0];z<=rz[1];z++) 
          this.data[this.index(i,j,z)]=src[z-rz[0]];
      else todo('copy 3');    
      break;
  }
  return this;
}

/** Convert size using a data filter.
 ** TODO: actually only down-sizing is sipported! Need up-sizing, too
 ** The target size must be provided.
 *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
 */

Matrix.prototype.convert = function (a,b,c,d) {
  var i,j,k,l,p,v,m,ni,nj,nk,filter;
  
  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isString(b)) filter=b;
  if (isString(c)) filter=c;
  if (isString(d)) filter=d;
  if (!filter) filter='mean';

  if (!i) throw "Matrix.convert: no target size (number, first dim.)";
  if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";
    
  if (!k) k= {datatype:this.datatype,layout:this.layout}
  else l= {datatype:this.datatype,layout:this.layout}
  m = Matrix(i,j,k,l);
      
  if (typeof filter != 'function') switch (filter) {
    case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
    case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
    case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
    case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
    case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
    case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
    default:          filter = function () { return 0 }
  }
  switch (this.dims) {
    case 1:
      ni=Math.floor(this.columns/m.columns);
      if (ni>0) {
        for(i=0;i<m.columns;i++) {
          v=this.data[i*ni]; 
          for(p=1;p<ni;p++) {
            v=filter(v,this.data[i*ni+p],p,ni);
          }
          m.data[i]=v;
        }
      } else {
        // TODO up-sizing
      }
      break;
    case 2:
      // TBC
      ni=Math.floor(this.rows/m.rows);
      nj=Math.floor(this.columns/m.columns);
      if (ni>0 && nj>0) {
        for(i=0;i<m.rows;i++) {
          for(j=0;j<m.columns;j++) {
            for(p=0;p<ni;p++) {
              for(q=0;q<nj;q++) {
                if (p==0 && q==0) 
                  v=this.get(i*ni,j*nj);
                else
                  v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
              }
            }
            m.set(i,j,v);
          }
        }
      } else {
        // TODO: up-sizing
      }
      break;
  }
  return m;
}


Matrix.prototype.cos = function (v) {
  this.eval(Math.cos);
  return this; 
}

Matrix.prototype.diag = function (v) {
  // TODO Vector
  var a = [];
  if (this.rows!=this.columns) return;
  for(var i=0;i<this.rows;i++) a.push(this.data[i+i*this.i]);
  return a; 
}

Matrix.prototype.dim = function () {
  switch (this.dims) {
    case 1: return [this.columns];
    case 2: return [this.rows,this.columns];
    case 3: return [this.rows,this.columns,this.levels];
  }
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.div = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] /= v.data[i];
    return result;
  } else result.eval(function (x) {return x/v});
  return result; 
}

Matrix.prototype.divide = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)/b);
    case 2: return this.set(a,b,this.get(a,b)/c);
    case 3: return this.set(a,b,c,this.get(a,b,c)/d);
  }
}

Matrix.prototype.error = function (what,where) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.prototype.errorRange = function (what,where) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

// Evaluate all elements x of matrix by applying function f(x)
Matrix.prototype.eval = function (f) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            this.set(i,f(this.get(i)))
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              this.set(i,j,f(this.get(i,j)))
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                this.set(i,j,k,f(this.get(i,j,k)))
          break;
      }
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i]);
  }
  return this;
}

Matrix.prototype.exp = function (v) {
  this.eval(Math.exp);
  return this; 
}

Matrix.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
    switch (this.dims) {
      case 1:
        for(i=0; i < this.columns; i++) 
          this.set(i,valueOrFunction(i.j))
        return this;
      case 2:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            this.set(i,j,valueOrFunction(i,j))
        return this;
      case 3:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            for(k=0; k < this.levels; k++) 
              this.set(i,j,k,valueOrFunction(i,j,k))
        return this;
    }
  } else this.data.fill(valueOrFunction);
  return this;
}

// Flattens a matruix by reducing the dimension
// [level,rows,columns] -> [rows,columns]
// [rows,columns] -> [rows]
Matrix.prototype.flatten = function (flatten) {
  if (!flatten) flatten=function (vl) { return vl.reduce(function (a,b) { return a+b }) };
  switch (this.dims) {
    case 3:
      var mf = Matrix(this.rows,this.columns,{datatype:this.datatype});
      for (var row=0;row<this.rows;row++) {
        for (var col=0;col<this.columns;col++) {
          var vl=[];
          for (var z=0;z<this.levels;z++) {
            vl.push(this.get(row,col,z));
          }
          mf.set(row,col,flatten(vl)/this.levels);
        }
      }
      return mf;
      break;
  }
}
Matrix.prototype.forEach = function (f,linear) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            f.call(this,this.get(i),i)
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              f.call(this,this.get(i,j),i,j)
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                f.call(this,this.get(i,j,k),i,j,k)
          break;
      }
      break;
    default:
      if (linear) for(i=0;i<this.size;i++) {
        f.call(this,this.data[i],i);
      } else {
        switch (this.dims) {
          case 1:
            for(i=0; i < this.columns; i++) 
              f.call(this,this.get(i),i)
            break;
          case 2:
            for(i=0; i < this.rows;i++) 
              for(j=0; j < this.columns; j++) 
                f.call(this,this.get(i,j),i,j)
            break
          case 3:
            for(i=0; i < this.rows;i++) 
              for(j=0; j < this.columns; j++) 
                for(k=0; k < this.levels; k++) 
                  f.call(this,this.get(i,j,k),i,j,k)
            break;
        }      
      }
  }
  return this;
}

// x += delta
Matrix.prototype.incr = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)+b);
    case 2: return this.set(a,b,this.get(a,b)+c);
    case 3: return this.set(a,b,c,this.get(a,b,c)+d);
  }
}

Matrix.prototype.info = function () {
  var o = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    layout:this.layout,
    dims:this.dims,
    dataspace:this.dataspace,
    datatype:this.datatype,
  }
  if (this.rows) o.rows=this.rows;
  if (this.levels) o.levels=this.levels;
  if (this.scaler) o.scaler=this.scaler;
  if (this.complex) o.complex=true;
  return o;
}


Matrix.prototype.isColumnVector = function () {
   return this.columns === 1;
}

Matrix.prototype.isEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isEchelonForm = false;
        checked = true;
      }
    }
    i++;
  }
  return isEchelonForm;
}

Matrix.prototype.isReducedEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isReducedEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isReducedEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isReducedEchelonForm = false;
        checked = true;
      }
    }
    for (var k = j + 1; k < this.rows; k++) {
      if (this.get(i, k) !== 0) {
        isReducedEchelonForm = false;
      }
    }
    i++;
  }
  return isReducedEchelonForm;
}
Matrix.prototype.isRowVector = function () {
   return this.rows === 1;
}

Matrix.prototype.isSquare = function () {
  return this.rows==this.columns
}

Matrix.prototype.isSymmetric = function () {
  if (this.isSquare()) {
        for (var i = 0; i < this.rows; i++) {
          for (var j = 0; j <= i; j++) {
            if (this.get(i, j) !== this.get(j, i)) {
              return false;
            }
          }
        }
        return true;
      }
  return false;
}

/** Iterate over matrix elements
 * Parameter arrays specify iteration ranges, FORALL='*' specifies a target vector range
 * iter(function (@elem,@index,@array))
 * iter(number [],function)
 * iter(number [],number [],function)
 * iter(number [],number [],number [],function)
 * Examples: 
 *  m.iter(FORALL,[],[],f)   <=> for all x-vectors with y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([], FORALL,[],f)  <=> for all y-vectors with x in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([],[],[],f)       <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter(f)                <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *
 *
 */
  
Matrix.prototype.iter = function (a,b,c,d) {
  var func,rx,ry,rz,x,y,z,
      self=this;
  if (isFunction(a)) func=a;
  else if (isFunction(b)) func=b;
  else if (isFunction(c)) func=c;
  else if (isFunction(d)) func=d;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;
  if (isString(a)) rx=a;
  if (isString(b)) ry=b;
  if (isString(c)) rz=c;
  if (!func) throw "Matrx.iter: no function supplied";
  if (!rx && !ry && !rz) // linear iteration over all elements
    return this.data.forEach(func);
  switch (this.dims) {
    case 1: break;
  // TODO
      todo('iter 1')
    case 2: break;
  // TODO
      todo('iter 2')
    case 3:
      if (isArray(rx) && rx.length==0) rx=[0,this.rows];
      if (isArray(ry) && ry.length==0) ry=[0,this.columns];
      if (isArray(rz) && rz.length==0) rz=[0,this.levels];
      if (rz == FORALL) {
        for(x=rx[0];x<rx[1];x++) {
          for(y=ry[0];y<ry[1];y++) {
            func(x,y,this.subMatrixRange(x,y,ALL))
          }
        }
      } else if (rx==FORALL) {
  // TODO
        todo('iter 3.ryx=FORALL')
      
      } else if (ry==FORALL) {
  // TODO
        todo('iter 3.ry=FORALL')
      
      } else {
        // single data cell iteration
  // TODO
        todo('iter 3')
      }
  }
  // TODO
  return this;
}

Matrix.prototype.map = function (f,asArray) {
  var res,i,j,k;
  switch (this.dims) {
    case 1:
      res = Matrix(this.columns,{dtn:asArray?'Array':this.dtn});
      for(j=0;j<this.columns;j++)
        res.set(j,f(this.get(j),j));
      break;
    case 2:
      res = Matrix(this.rows,this.columns,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          res.set(i,j,f(this.get(i,j),i,j));
      break;
    case 3:
      res = Matrix(this.rows,this.columns,this.levels,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          for(k=0;k<this.levels;k++)
            res.set(i,j,k,f(this.get(i,j,k),i,j,k));
      break;
  }
  return res;
}


// Row mapping function
Matrix.prototype.mapRow = function (f) {
  var res=[];
  for(var row=0;row<this.rows;row++) {
    res.push(f(this.getRow(row),row));
  }
  return res;
}

/** Return minimum and maximum value of the matrix
 *
 */
Matrix.prototype.minmax = function () {
  var d0=Number.MAX_VALUE,d1=-Number.MAX_VALUE;
  for (i = 0;i < this.size; i++) {
    d0=Math.min(d0,this.data[i]);
    d1=Math.max(d1,this.data[i]);    
  }
  return { min:d0, max:d1 };
}
Matrix.prototype.max = function () {
  return this.minmax.max()
}
Matrix.prototype.min = function () {
  return this.minmax.min()
}
Matrix.prototype.mapToArray = function (f) {
  var res = new Array(this.size);
  for(var i=0;i<this.rows;i++)
    for(var j=0;j<this.columns;j++)
      res[i*this.columns+j]=f?f(this.get(i,j),i,j):this.get(i,j);
  return res;
}

Matrix.prototype.mapToArrayArray = function (f) {
  var res = new Array(this.rows);
  for(var i=0;i<this.rows;i++) {
    res[i]=new Array(this.columns);
    for(var j=0;j<this.columns;j++)
      res[i][j]=f?f(this.get(i,j),i,j):this.get(i,j);
  }
  return res;
}

Matrix.prototype.mapToArrayArrayArray = function (f) {
  var res = new Array(this.levels);
  for(var i=0;i<this.levels;i++) {
    res[i]=new Array(this.rows);
    for(var j=0;j<this.rows;j++) {
      res[i][j]=new Array(this.columns);
      for(var k=0;k<this.columns;k++) {
        res[i][j][k]=f?f(this.get(i,j,k),i,j,k):this.get(i,j,k);
      }
    }
  }
  return res;
}

// x *= k
Matrix.prototype.multiply = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)*b);
    case 2: return this.set(a,b,this.get(a,b)*c);
    case 3: return this.set(a,b,c,this.get(a,b,c)*d);
  }
}

Matrix.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Matrix.prototype.mod = function (v) {
  this.eval(function (x) {return x%v});
  return this; 
}

/**
     * Returns the matrix product between this and other
     * @param {Matrix} other
     * @return {Matrix}
     */
Matrix.prototype.mmul = function (other) {
  this.checkMatrixDims(2);
  other = Matrix.checkMatrix(other);
  if (this.columns !== other.rows) {
    // eslint-disable-next-line no-console
    console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
  }

  var m = this.rows;
  var n = this.columns;
  var p = other.columns;

  var result = Matrix(m, p, {dtn:this.dtn});

  var Bcolj = new Array(n);
  for (var j = 0; j < p; j++) {
    for (var k = 0; k < n; k++) {
      Bcolj[k] = other.get(k, j);
    }
    for (var i = 0; i < m; i++) {
      var s = 0;
      for (k = 0; k < n; k++) {
        s += this.get(i, k) * Bcolj[k];
      }
      result.set(i, j, s);
    }
  }
  return result;
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.mul = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] *= v.data[i];
    return result;
  } else result.eval(function (x) {return x*v});
  return result; 
}

Matrix.prototype.neg = function (v) {
  this.eval(function (x) {return -x});
  return this; 
}

Matrix.prototype.prod = function (v) {
  var i,j,k,v = 1;
  // Comp. mode
  switch (this.dtn+this.dims) {
    case 'Array1':
      for (i = 0; i < this.columns; i++) {
          v *= this.data[i];
      }
      break;
    case 'Array2':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          v *= this.data[i][j];
        }
      }
      break;
    case 'Array3':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          for (k = 0; k < this.levels; k++) {
            v *= this.data[i][j][k];
          }
        }
      }
      break;
    default:
      for (i = 0; i < this.size; i++) v *= this.data[i];
  }
  return v;
}

Matrix.prototype.print = function (format) {
  var i,j,k,s='',sep='';
  if (!format) format = '%4.2f';
  switch (this.dims) {
    case 1:
      for(i=0;i<this.columns;i++) {
        if (i!=0) s = s + '\n';
        s = s + sprintf(format,this.get(i)) ;
      }
      break;
    case 2:
      for(i=0;i<this.rows;i++) {
        sep = '';
        if (i!=0) s = s + '\n';
        for (j=0;j<this.columns;j++) {
          s = s + sep + sprintf(format,this.get(i,j)) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<this.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(i=0;i<this.rows;i++) {
          sep = '';
          if (i!=0) s = s + '\n';
          for (j=0;j<this.columns;j++) {
            s = s + sep + sprintf(format,this.get(i,j,k)) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
}

/** Reduce dimension: Linear matrix data reduction applying a function (a,b) -> c to all elements.
 *  Returns a scalar value or any other object accumulated by the supplied function
 */
Matrix.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

// Return array or vector (layout=12: matrix view if !copy)
Matrix.prototype.row = function (index,asVector,copy) {
  this.checkMatrixDims(2);
  this.checkRowIndex(index);
  var row,data,i,j;
  switch (this.dtn) {
    case 'Array':
      if (this.layout==12) {
        if (!asVector)
          return this.data[index];
        else
          return Vector(this.data[index]);
      } else {
        // transposed view
        if (!asVector) {
          row = new Array(this.columns);
          if (this.rows==1) return this.data;
          for (i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
        } else {
          if (this.rows==1) return this.data;
          row= Vector(this.columns,{dtn:this.dtn});
          for (i = 0; i < this.columns; i++) {
            row.set(i, this.get(index, i));
          };
        }  
      }
      break;
    default:
      // With advanced slicing
      if (!asVector) {
        row = new Array(this.columns);
        if (this.rows==1) return this.data.toArray();
        for (i = 0; i < this.columns; i++) {
          row[i] = this.get(index, i);
        }
      } else if (this.layout == 12) {
        if (copy) {
          data = this.data.slice(index*this.columns,(index+1)*this.columns);
          row= Vector({dtn:this.dtn,data:data,columns:this.columns});
        } else {
          row= Vector({dtn:this.dtn,data:this.data,offset:index*this.columns,columns:this.columns});
        }
      } else {
        if (this.rows==1) return this.data;
        row= Vector(this.columns,{dtn:this.dtn});
        for (i = 0; i < this.columns; i++) {
          row.set(i, this.get(index, i));
        };
      }   
  }
  
  return row;
}
Matrix.prototype.getRow=Matrix.prototype.row;

/** resize matrix
** NO: (only modifying meta data - not buffer data)
** YES: interpol/extrapol
 *  TODO: offset
 */
Matrix.prototype.resize = function (options) {
  for(var p in options) {
    switch (p) {
      case 'rows':
      case 'columns':
      case 'levels':
        this[p]=options[p];
        break;
      case 'offset':
        // TODO
        break;
    }
  }
  this.size=this.columns*(this.rows?this.rows:1)*(this.levels?this.levels:1);
  this.length=this.rows?this.rows:this.columns;
  return this
}


Matrix.prototype.reverseRow = function (row) {
  var t,len=this.columns;
  for(var i=0;i<(len/2)|0;i++) {
    t=this.get(row,i);
    this.set(row,i,this.get(row,len-i-1));
    this.set(row,len-i-1,t);
  }
  return this; 
}

/** Scale (and/or adjust offset optionally of) all matrix elements -= offset *= k
 * scale(k)
 * scale(k,inplace:boolean)
 * scale(k,offset)
 * scale(k,offset,inplace:boolean)
 */
 
Matrix.prototype.scale = function (a,b,c) {
  var m,k=1,offset,inplace=false;
  if (isNumber(a)) k=a;
  if (isBoolean(b)) inplace=b;
  else if (isBoolean(c)) inplace=c;
  if (isNumber(b)) offset=b;
  else if (isNumber(c)) offset=c;
  
  m = inplace?this:this.copy();
  if (k!=1) {
    if (offset)
      for(var i=0;i<m.data.length;i++) m.data[i]=(m.data[i]-offset)*k;
    else
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]*k;
  } else if (offset) {
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]-offset;  
  }
  return m;
}

/*
Return a new matrix based on a selection of rows and columns
selection(rowIndices: Array<number>, columnIndices: Array<number>): Matrix
Parameters
rowIndices (Array<number>) The row indices to select. Order matters and an index can be more than once.
columnIndices (Array<number>) The column indices to select. Order matters and an index can be use more than once.
Returns 
Matrix: The new matrix 
*/
Matrix.prototype.selection = function (rowIndices,columnIndices) {
  this.checkMatrixDims(2);
  var newMatrix = Matrix(rowIndices.length,columnIndices.length,{dtn:this.dtn});
  for (var i = 0; i < rowIndices.length; i++) {
    var rowIndex = rowIndices[i];
    for (var j = 0; j < columnIndices.length; j++) {
      var columnIndex = columnIndices[j];
      newMatrix.set(i,j, this.get(rowIndex, columnIndex));
    }
  }
  return newMatrix;
}


// Set a row of the matrix
Matrix.prototype.setRow = function (row,data) {
  data=Matrix.checkArray(data);
  for(var i=0;i<this.columns;i++) {
     this.set(row,i,data[i]); 
  }
}

// Share a matrix (data must be either a sharedarraybuffer or a buffer segment object
Matrix.prototype.__share = function () {
  if (this.block) {
    // Matrix buffer is part of a Shared Memory Segment Buffer (SMS) TODO
    return {
      data : { data : [], block : this.block, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn   : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  } else if (typeof SharedArrayBuffer != 'undefined' && this.data instanceof SharedArrayBuffer) {
    // Browser/Web Worker: Shared Array Buffer
    return {
      data : { data : this.data, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn  : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  } else if (typeof SharedArrayBuffer != 'undefined' && this.data.buffer instanceof SharedArrayBuffer) {
    // Browser/Web Worker: Shared Array Buffer
    return {
      data : { data : this.data.buffer, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn  : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  }
}
// Slice of data in major dimension
Matrix.prototype.slice = function (i,offset) {
  var rows,columns,levels;
  switch (this.dims) {
    case 1:
      return Matrix(this,{columns:i,offset:offset,slice:true});
      break;
    case 2:
    case 3:
      return Matrix(this,{rows:i,offset:offset,slice:true});
      break;
  }
}

Matrix.prototype.sin = function () {
  this.eval(Math.sin);
  return this;
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Matrix.prototype.size = function () {
  return  this.size;
}


// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.sub = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] -= v.data[i];
    return result;
  } else result.eval(function (x) {return x-v});
  return result; 
}


/** Return a sub-matrix (2 dims only)
 *
 */
Matrix.prototype.subMatrix = function (startRow, endRow, startColumn, endColumn) {
  this.checkMatrixDims(2);
  this.checkRange(startRow, endRow, startColumn, endColumn);
  var newMatrix = Matrix(endRow - startRow + 1, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = startRow; i <= endRow; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      newMatrix.set(i - startRow,j - startColumn, this.get(i, j));
    }
  }
  return newMatrix;
}

/** Return a sub-matrix (1-3 dims)
 *
 * rx:row,ry:column,rz?:level
 */
Matrix.prototype.subMatrixRange = function (rx,ry,rz) {
  var i,j,i0,i1,x0,x1,y0,y1,z0,z1,res;
  switch (this.dims) {
    case 1:
      // simple case, return sliced array
      x0=0,x1=this.i-1;
      if (isRange(rx)) x0=rx[0],x1=rx[1];
      else throw "Matrix.subMatrixRange: no range";
      var i0=x0,i1=i0+1+x1;
      return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
    case 2:
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    case 3:
      if ((isAll(rz) || (isRange(rz))) && isNumber(rx) && isNumber(ry) && (Matrix.options.compatLayout?this.layout==123:this.layout==321)) {
        // simple case, return sliced array (1-dim matrix)
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        var i0=this.index(rx,ry,z0),i1=i0+1+z1;
        return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
      } else if (isNumber(rz)) {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=rz;
        res = Matrix(x1-x0+1,y1-y0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            res.set(i-x0,j-y0, this.get(i,j,z0));
        return res;
      } else  {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        if (isNumber(rz)) z0=z1=rz;        
        res = Matrix(x1-x0+1,y1-y0+1,z1-z0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            for(var k=z0;k<=z1;k++)
              res.set(i-x0,j-y0,k-z0,this.get(i,j,k));
        return res;
      }
  }
}

Matrix.prototype.subMatrixRow = function (indices, startColumn, endColumn) {
  this.checkMatrixDims(2);
  if (startColumn === undefined) startColumn = 0;
  if (endColumn === undefined) endColumn = this.columns - 1;
  if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(indices.length, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      if (indices[i] < 0 || indices[i] >= this.rows) {
        throw new RangeError('Row index out of range: '+indices[i]);
      }
      newMatrix.set(i, j - startColumn, this.get(indices[i], j));
    }
  }
  return newMatrix;
}

Matrix.prototype.subMatrixColumn = function (indices, startRow, endRow) {
  this.checkMatrixDims(2);
  if (startRow === undefined) startRow = 0;
  if (endRow === undefined) endRow = this.rows - 1;
  if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(endRow - startRow + 1, indices.length, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startRow; j <= endRow; j++) {
      if (indices[i] < 0 || indices[i] >= this.columns) {
        throw new RangeError('Column index out of range: '+indices[i]);
      }
      newMatrix.set(j - startRow, i, this.get(j, indices[i]));
    }
  }
  return newMatrix;
}


Matrix.prototype.subRowVector = function (vector) {
  this.checkMatrixDims(2);
  vector = this.checkRowVector(vector);
  for (var i = 0; i < this.rows; i++) {
    for (var j = 0; j < this.columns; j++) {
      this.set(i, j, this.get(i, j) - vector[j]);
    }
  }
  return this;
}

Matrix.prototype.setSubMatrix = function (matrix, startRow, startColumn) {
  matrix = this.checkMatrix(matrix);
  this.checkMatrixDims(2);
  matrix.checkMatrixDims(2);
  var endRow = startRow + matrix.rows - 1;
  var endColumn = startColumn + matrix.columns - 1;
  this.checkRange(startRow, endRow, startColumn, endColumn);
  for (var i = 0; i < matrix.rows; i++) {
    for (var j = 0; j < matrix.columns; j++) {
      this.set(startRow + i,startColumn + j) = matrix.get(i, j);
    }
  }
  return this;
}

Matrix.prototype.sum = function (by) {
  var i,j,k,v=0;
  switch (by) {
    case 'row':
      return this.sumByRow();
    case 'column':
      return this.sumByColumn();
    default:
      switch (this.dtn+this.dims) {
        case 'Array1':
          for (i = 0; i < this.columns; i++) {
              v += this.data[i];
          }
          break;
        case 'Array2':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              v += this.data[i][j];
            }
          }
          break;
        case 'Array3':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              for (k = 0; k < this.levels; k++) {
                v += this.data[i][j][k];
              }
            }
          }
          break;
        default:
          for (i = 0; i < this.size; i++) v += this.data[i];
      }
      return v;
  }
}

Matrix.prototype.sumByRow = function () {
  var sum = Matrix.zeros(this.rows, 1);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.sumByColumn = function() {
  var sum = Matrix.zeros(1, this.columns);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.toCsv = function (sep) {
  sep=sep||',';
  switch (this.dims) {
    case 1: return Array.from(this.data).join('\n');
    case 2: return this.mapToArrayArray().map(function (row) {
      return row.join(sep);
    }).join('\n');
  }
}

Matrix.prototype.toArray = function (rx,ry,rz) {
  switch (this.dims) {
    case 1: return Array.from(this.data);
    case 2: return this.mapToArrayArray();
    case 3: return this.mapToArrayArrayArray();
  }
}

Matrix.prototype.toBuffer = function () {
  return this.data.buffer;
}

Matrix.prototype.toJson = function () {
  return JSON.stringify(this.toArray());
}

Matrix.prototype.transpose = function () {
  utils.checkMatrixDims(this,2);
  if (!Matrix.native || this.rows != this.columns || this.dtn != 'Float32Array') {
    var result = Matrix(this.columns, this.rows,{datatype:this.datatype});
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          result.set(j, i, this.get(i, j));
        }
    }
    return result;
  } else if (Matrix.native) {
    /* Native BLAS support */
    var res = Matrix(this.columns,this.rows,{dtn:this.dtn});
    if (this.dtn == 'Float32Array')
      Matrix.native.blas.stran_(Buffer(this.data.buffer),
                                Buffer(res.data.buffer),
                                Matrix.native.intPtr(this.rows),
                                Matrix.native.intPtr(this.columns));
    return res;
  }
}

Matrix.prototype.transposeView = function () {
  utils.checkMatrixDims(this,2);
  var res = Matrix(this,{transpose:true});
  return res;
}

Matrix.ALL=ALL;
Matrix.FOREACH=FOREACH;
Matrix.FORALL=FORALL;
Matrix.utils = utils;

module.exports = Matrix 
};
BundleModuleCode['plugins/math/matrixTA-utils']=function (module,exports){
// Matrix Utility Functions
// TypedArray version
// Ver. 1.3.1

'use strict';

function checkMatrixDims(matrix, dims) {
  if (matrix.dims != dims) throw new Error('Matrix has not expected dimension '+dims);
}
/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  var max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  var max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns'
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices)
  };
}

function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= matrix.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= matrix.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function getRange(from, to) {
  var arr = new Array(to - from + 1);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = from + i;
  }
  return arr;
}

function sumByRow(matrix) {
  var sum = Matrix.zeros(matrix.rows, 1);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  var sum = Matrix.zeros(1, matrix.columns);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumAll(matrix) {
  var i,j,k,v = 0;
  // Comp. mode
  switch (matrix.dtn) {
    case 'Array':
      for (i = 0; i < matrix.rows; i++) {
        for (j = 0; j < matrix.columns; j++) {
          v += matrix.data[i][j];
        }
      }
      break;
    default:
      for (i = 0; i < matrix.size; i++) v += matrix.data[i];
  }
  return v;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}

function getFilled2DArray(rows,columns,init) {
  var a = Array(rows);
  for(var i = 0;i < rows; i++) {
    a[i]=Array(columns).fill(init)
  }
  return a;
}

function hypotenuse(a, b) {
  var r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}

// function squaredEuclidean(p: number[], q: number[])
function squaredEuclidean(p, q) {
  var d = 0;
  for (var i = 0; i < p.length; i++) {
    d += (p[i] - q[i]) * (p[i] - q[i]);
  }
  return d;
}

// function euclidean(p: number[], q: number[]) 
function euclidean(p, q) {
  return Math.sqrt(squaredEuclidean(p, q));
}

var defaultOptions = {
  distanceFunction: squaredEuclidean
}
// function nearestVector(listVectors: Matrix, vector: number[],  options = defaultOptions)
function nearestVector(
  listVectors,
  vector,
  options
) {
  options=checkOptions(options,{distanceFunction: squaredEuclidean});
  const distanceFunction = checkOption(
    options.distanceFunction, defaultOptions.distanceFunction);
  const similarityFunction = checkOption(
    options.similarityFunction, defaultOptions.similarityFunction);

  let vectorIndex = -1;
  if (typeof similarityFunction === 'function') {
    // maximum similarity
    let maxSim = Number.MIN_VALUE;
    for (let j = 0; j < listVectors.rows; j++) {
      const sim = similarityFunction(vector, listVectors.getRow(j));
      if (sim > maxSim) {
        maxSim = sim;
        vectorIndex = j;
      }
    }
  } else if (typeof distanceFunction === 'function') {
    // minimum distance
    let minDist = Number.MAX_VALUE;
    for (let i = 0; i < listVectors.rows; i++) {
      const dist = distanceFunction(vector, listVectors.getRow(i));
      if (dist < minDist) {
        minDist = dist;
        vectorIndex = i;
      }
    }
  } else {
    throw new Error("A similarity or distance function it's required");
  }

  return vectorIndex;
}

// function findNearestVector(  vectorList: Matrix,  vector: Vector,  options: IOptions = defaultOptions) 
function findNearestVector(
  vectorList,
  vector,
  options
) {
  const index = nearestVector(vectorList, vector, options);
  return vectorList[index];
}

module.exports = {
  checkMatrixDims:checkMatrixDims,
  checkRowIndex:checkRowIndex,
  checkRowVector:checkRowVector,
  checkColumnIndex:checkColumnIndex,
  checkColumnVector:checkColumnVector,
  checkIndices:checkIndices,
  checkRowIndices:checkRowIndices,
  checkColumnIndices:checkColumnIndices,
  checkRange:checkRange,
  euclidean:euclidean,
  findNearestVector:findNearestVector,findNearestVector,
  getFilled2DArray:getFilled2DArray,
  getRange:getRange,
  hypotenuse:hypotenuse,
  nearestVector:nearestVector,nearestVector,
  sumByRow:sumByRow,
  sumByColumn:sumByColumn,
  sumAll:sumAll,
  squaredEuclidean:squaredEuclidean,
}
};
BundleModuleCode['plugins/math/vectorTA']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.6.1X
 **
 **    $INFO:
 ** 
 **   Vector module supporting typed and generic arrays.
 **   
 ** 
 **    $ENDOFINFO
 */

var isArray = Utils.isArray,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isString = Utils.isString,
    TypedArrayOfName = Utils.TypedArrayOfName;

/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

Object.addProperty(Array,'get', function (i) {
  return this[i];
})
Object.addProperty(Array,'set', function (a,b) {
  this[a]=b;
})

  
Object.addProperty(Array,'print', function (format) {
  var i,s='',sep='', columns=this.length,complex=isArray(this[0]);
  if (!format) format = '%4.2f';
  for(i=0;i<columns;i++) {
    if (i!=0) s = s + '\n';
    if (complex) 
      s = s + sprintf(format,this[i][0]) + ',' +
              sprintf(format,this[i][1]);
    else
      s = s + sprintf(format,this[i]) ;
  }    
  return s;
})


Object.addProperty(Array,'info', function () {
  return {
    dtn:'Array',
    size:this.length,
    columns:this.length,
    offset:0,
  }
})

Object.addProperty(Array,'unique', function () {
  var array=this;
  var length = array ? array.length : 0;
  function baseUniq(array) {
    var index = -1,
        length = array.length,
        seen,
        result = [];

    seen = result;
    outer:
    while (++index < length) {
      var value = array[index];
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === value) {
          continue outer;
        }
      }
      result.push(value);
    }
    return result;
  }
  if (!length) {
    return [];
  }
  return baseUniq(array);
})

Object.addProperty(Array,'min', function () {
  return Math.min.apply(null, this) 
})

Object.addProperty(Array,'max', function () {
  return Math.max.apply(null, this) 
})


Object.addProperty(Int16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Int32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float64Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})

/********************* STRING Conversion ******************************/
function toUTF8Array(str) {
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 
                      0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            charcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)
            utf8.push(0xf0 | (charcode >>18), 
                      0x80 | ((charcode>>12) & 0x3f), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}

function fromUTF8Array(data) { // array of bytes
    var str = '', i;
    for (i = 0; i < data.length; i++) {
        var value = data[i];
        if (value < 0x80) {
            str += String.fromCharCode(value);
        } else if (value > 0xBF && value < 0xE0) {
            str += String.fromCharCode((value & 0x1F) << 6 | data[i + 1] & 0x3F);
            i += 1;
        } else if (value > 0xDF && value < 0xF0) {
            str += String.fromCharCode((value & 0x0F) << 12 | (data[i + 1] & 0x3F) << 6 | data[i + 2] & 0x3F);
            i += 2;
        } else {
            // surrogate pair
            var charCode = ((value & 0x07) << 18 | (data[i + 1] & 0x3F) << 12 | (data[i + 2] & 0x3F) << 6 | data[i + 3] & 0x3F) - 0x010000;

            str += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00); 
            i += 3;
        }
    }
    return str;
}

var complex = {
  //-------------------------------------------------
  // Add two complex numbers
  //-------------------------------------------------
  add : function (a, b)
  {
      return [a[0] + b[0], a[1] + b[1]];
  },

  //-------------------------------------------------
  // Subtract two complex numbers
  //-------------------------------------------------
  subtract : function (a, b)
  {
      return [a[0] - b[0], a[1] - b[1]];
  },

  //-------------------------------------------------
  // Multiply two complex numbers
  //
  // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
  //-------------------------------------------------
  multiply : function (a, b) 
  {
      return [(a[0] * b[0] - a[1] * b[1]), 
              (a[0] * b[1] + a[1] * b[0])];
  },

  //-------------------------------------------------
  // Calculate |a + bi|
  //
  // sqrt(a*a + b*b)
  //-------------------------------------------------
  magnitude : function (offset,c) 
  {
      return Math.sqrt(c[offset]*c[offset] + c[offset+1]*c[offset+1]); 
  },
  
  phase : function (offset,c) 
  {
      return c[offset]!=0?Math.atan(c[offset+1]/c[offset])*180/Math.PI:(c[offset+1]>0?90:-90); 
  }

}

/*********** VECTOR ************/
function Vector(a,b) {
  var self = this;
  var i,columns,size,offset=0,dim=1,dtn,dt=Vector.options.dt,data;
  
  if (!(this instanceof Vector)) return new Vector(a,b);
  var options=isObject(b)?b:{};
  this.tag='VectorTA';
  
  if (isNumber(a)) {
    // Create a new empty vector (rows=1)
    columns=a;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    size=columns;
    if (options.complex) size *=2;
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(size);
  } else if (isArray(a)) {
    size=columns=a.length;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isObject(a)) {
    // partial object
    columns=a.columns;
    size=a.size||columns;
    scale=options.scale;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && a.dtn != options.dtn) {
      // convert dtn
      if (isArray(a.data) && !scale)
        data=new dt(a.data);
      else {
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      }
      dtn=options.dtn;
    } else {
      dtn=a.dtn;
      data=a.data;
      offset=a.offset;
    }
    if (a.scale) this.scale=a.scale;
    if (a.complex) this.complex=a.complex;
  } else if (isString(a)) {
    columns=a.length;
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(toUTF8Array(a));
  }
  
  this.columns=columns;
  this.size=this.length=size;
  this.layout=1;
  this.data=data;
  this.dims=dim;
  this.offset=offset;
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  this.dtn=dtn||dt.name;
  
  if (this.dtn=='Array') this._arrayFix();

  this.__constructor__='Math.VectorTA';
}
Vector.options = {
  dt : Float32Array,
  dtn : 'Float32Array'
}

/********* STATIC MEMBERS *********/
Vector.abs = function (m) {
  return Vector.clone(m).abs();
}

Vector.add = function (m,v) {
  return Vector.clone(m).add(v);
}

Vector.clone = function (src) {
  return Vector(src);
}

Vector.checkVector = function (o) {
  if (o instanceof Vector) return o;
  else return Vector(o);
}

Vector.cos = function (m) {
  return Vector.clone(m).cos();
}

Vector.div = function (m,v) {
  return Vector.clone(m).div(v);
}

Vector.empty = function (columns) {
  return Vector(columns);
}

Vector.exp = function (m) {
  return Vector.clone(m).exp();
}

Vector.init = function (columns,valueOrCallback) {
  return Vector(columns).fill(valueOrCallback);
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.max =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]= Math.max(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.min =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]=Math.min(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.mod = function (m,v) {
  return Vector.clone(m).mod(v);
}

Vector.mul = function (m,v) {
  return Vector.clone(m).mul(v);
}

Vector.neg = function (m) {
  return Vector.clone(m).neg();
}

Vector.ones = function (columns) {
  return Vector(columns).fill(1);
}

Vector.rand = function (columns, rng) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns).fill(function () {
    return rng();
  });
}
Vector.Random=Vector.rand;
Vector.randInt = function (columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}

Vector.sin = function (m) {
  return Vector.clone(m).sin();
}

Vector.sub = function (m,v) {
  return Vector.clone(m).sub(v);
}

Vector.zero = function (columns) {
  return Vector(columns).fill(0);
}



/********* INSTANCE MEMBERS *********/
// Fix some prototype methods for generic array data content
Vector.prototype._arrayFix = function () {
  var self=this;
  this.get=function (column)   { return self.data[self.offset+column] };
  this.set=function (column,v) { self.data[self.offset+column]=v };
}

Vector.prototype.abs = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.abs(this.data[i]);
  return this; 
}

Vector.prototype.add = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]+=v;
  return this; 
}

Vector.prototype.apply = function (f) {
  for(var i=0; i < this.columns; i++) 
    this.set(i,f.call(this,i))
  return this;
}

Vector.prototype.clone = function () {
  return Vector(this);
}

Vector.prototype.cos = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.cos(this.data[i]);
  return this; 
}

Vector.prototype.div = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]/=v;
  return this; 
}

Vector.prototype.divide = function (column,k) {
  return this.data[column] /= k;
}

// Evaluate all elements x of matrix by applying function f(x)
Vector.prototype.eval = function (f) {
  var i;
  switch (this.dtn) {
    case 'Array':
      for(i=0; i < this.columns; i++) 
        this.set(i,f(this.get(i)))
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i],i);
  }
  return this;
}

Vector.prototype.exp = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.exp(this.data[i]);
  return this; 
}

Vector.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
      for(var i=0;i<this.columns;i++) {
        this.data[i]=valueOrFunction(i);
      } 
  } else this.data.fill(valueOrFunction);
  return this;
}

Vector.prototype.filter = function (f,asArray) {
  var i,j=0,res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(i=0;i<this.columns;i++) {
    v=f(this.data[i],i);
    if (v) res.data[j]=this.data[i],j++;
  }
  return j<this.columns?res.slice(j):res;
}

Vector.prototype.get = function (column) {
  return this.data[this.offset+column];
}

Vector.prototype.imag = function (i) {
  if (this.complex) return this.get(i*2+1);
}

Vector.prototype.incr = function (column,delta) {
  return this.data[column] += delta;
}

Vector.prototype.info = function () {
  var i = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    offset:this.offset,
  }
  if (this.scaler) i.scaler=this.scaler;
  if (this.complex) i.complex=true;
  return i;
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.prototype.magnitude = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.magnitude(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.map = function (f,asArray) {
  var res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(var i=0;i<this.columns;i++)
    res.data[i]=f(this.data[i],i);
  return res;
}

Vector.prototype.multiply = function (column,k) {
  return this.data[column] *= k;
}

Vector.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Vector.prototype.mod = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=this.data[i]%v;
  return this; 
}

Vector.prototype.mul = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]*=v;
  return this; 
}

Vector.prototype.neg = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]=-this.data[i];
  return this; 
}

Vector.prototype.pad = function (n,v,left) { 
  var ext = Vector.init(n,v); 
  if (!left) ext.data.set(this.data);
  else ext.data.set(this.data,this.length);
  return ext;
}

Vector.prototype.phase = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.phase(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.prod = function (v) {
  var i,j,v = 1;
  for (i = 0; i < this.size; i++) v *= this.data[i];
  return v;
}

Vector.prototype.print = function (format,transpose) {
  var j, s='';
  if (!format) format = '%4.2f';
  if (!this.complex)
    for(j=0;j<this.columns;j++) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + sprintf(format,this.data[j]) ;
    }
  else
    for(j=0;j<this.columns;j=j+2) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + '('+sprintf(format,this.data[j])+','+sprintf(format,this.data[j+1])+')' ;
    }
  
  return s;
}

Vector.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

Vector.prototype.real = function (i) {
  if (this.complex) return this.get(i*2);
}

Vector.prototype.resize = function (options) {
  if ((options.offset && (options.columns+options.offset) > this.columns) ||
      !options.columns) throw new Error('Vecotr.resize: invalid argument(s)');
  this.columns=options.columns;
  if (options.offset) this.offset=options.offset;
  this.size=this.length=this.columns;
  if (options.slice) 
    this.data=options.offset?this.data.slice(options.offset,options.columns+offset):
                             this.data.slice(0,options.columns);
  return this;
}

Vector.prototype.set = function (column,val) {
  this.data[this.offset+column]=val;
  return this;
}

Vector.prototype.sin = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.sin(this.data[i]);
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Vector.prototype.size = function () {
  return  this.size;
}

/** Return new vecotr with sliced data
 *
 */
Vector.prototype.slice = function (columns,offset) {
  return Vector(this,{columns:columns,offset:offset,slice:true});
}

Vector.prototype.sub = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]-=v;
  return this; 
}

Vector.prototype.subRange = function (columns,offset) {
  offset=checkOption(offset,0);
  var res=Vector({columns:columns,data:this.data.slice(offset,columns+offset),dtn:this.dtn});
  return res;
}

Vector.prototype.sum = function () {
  var sum=0;
  for(var i=0;i<this.size;i++) sum += this.data[i];
  return sum
}

Vector.prototype.toArray = function () {
  if (!this.complex) return Array.prototype.slice.call(this.data);
}

module.exports = Vector;
};
BundleModuleCode['plugins/math/matrixTA-EVD']=function (module,exports){
// Matrix EigenvalueDecomposition
// TypedArray version 
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function EigenvalueDecomposition(matrix, options) {
  if (!(this instanceof EigenvalueDecomposition)) return new EigenvalueDecomposition(matrix,options);
  options=checkOptions(options);
  var assumeSymmetric = checkOption(options.assumeSymmetric,false);

  matrix = Matrix.checkMatrix(matrix);
  if (!matrix.isSquare()) {
    throw new Error('EigenvalueDecomposition: Matrix is not a square matrix');
  }

  var n = matrix.columns;
  var V = Matrix(n, n);
  var d = new Array(n);
  var e = new Array(n);
  var value = matrix;
  var i, j;

  var isSymmetric = false;
  if (assumeSymmetric) {
    isSymmetric = true;
  } else {
    isSymmetric = matrix.isSymmetric();
  }

  if (isSymmetric) {
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        V.set(i,j, value.get(i, j));
      }
    }
    tred2(n, e, d, V);
    tql2(n, e, d, V);
  } else {
    var H = Matrix(n, n);
    var ort = new Array(n);
    for (j = 0; j < n; j++) {
      for (i = 0; i < n; i++) {
        H.set(i,j,  value.get(i, j));
      }
    }
    orthes(n, H, ort, V);
    hqr2(n, e, d, V, H);
  }

  this.n = n;
  this.e = e;
  this.d = d;
  this.V = V;
}

EigenvalueDecomposition.prototype = {
  /**
   *
   * @return {Array<number>}
   */
  get realEigenvalues() {
    return this.d;
  },

  /**
   *
   * @return {Array<number>}
   */
  get imaginaryEigenvalues() {
    return this.e;
  },

  /**
   *
   * @return {Matrix}
   */
  get eigenvectorMatrix() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    var n = this.n;
    var e = this.e;
    var d = this.d;
    var X = new Matrix(n, n);
    var i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i,j,0);
      }
      X.set(i,i,d[i]);
      if (e[i] > 0) {
        X.set(i,i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i,i - 1,e[i]);
      }
    }
    return X;
  },
}

function tred2(n, e, d, V) {
  var f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1,j);
        V.set(i,j, 0);
        V.set(j,i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j,i,f);
        g = e[j] + V.get(j,j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k,j) * d[k];
          e[k] += V.get(k,j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.incr(k,j, -(f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1,j);
        V.set(i,j,0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1,i, V.get(i,i));
    V.set(i,i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k,i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k,i + 1) * V.get(k,j);
        }
        for (k = 0; k <= i; k++) {
          V.incr(k,j, -(g * d[k]));
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k,i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
    V.set(n - 1,j, 0);
  }

  V.set(n - 1,n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  var f = 0;
  var tst1 = 0;
  var eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      iter = 0;
      do {
        iter = iter + 1;

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k,i + 1);
            V.set(k,i + 1, s * V.get(k,i) + c * h);
            V.set(k,i, c * V.get(k,i) - s * h);
          }
        }

        p = -s * s2 * c3 * el1 * e[l] / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j,i);
        V.set(j,i, V.get(j,k));
        V.set(j,k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  var low = 0;
  var high = n - 1;
  var f, g, h, i, j, m;
  var scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i,m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i,m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i,j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.incr(i,j, -(f * ort[i]));
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i,j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.incr(i,j, -(f * ort[j]));
        }
      }

      ort[m] = scale * ort[m];
      H.set(m,m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i,j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m,m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i,m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i,j);
        }

        g = g / ort[m] / H.get(m,m - 1);
        for (i = m; i <= high; i++) {
          V.incr(i,j, g * ort[i]);
        }
      }
    }
  }
}


function hqr2(nn, e, d, V, H) {
  var n = nn - 1;
  var low = 0;
  var high = nn - 1;
  var eps = Number.EPSILON;
  var exshift = 0;
  var norm = 0;
  var p = 0;
  var q = 0;
  var r = 0;
  var s = 0;
  var z = 0;
  var iter = 0;
  var i, j, k, l, m, t, w, x, y;
  var ra, sa, vr, vi;
  var notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i,i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i,j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1,l - 1)) + Math.abs(H.get(l,l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l,l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.incr(n,n,exshift);
      d[n] = H.get(n,n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n,n - 1) * H.get(n - 1,n);
      p = (H.get(n - 1,n - 1) - H.get(n,n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.incr(n,n,exshift);
      H.incr(n - 1,n - 1,exshift);
      x = H.get(n,n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n,n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1,j);
          H.set(n - 1,j, q * z + p * H.get(n,j));
          H.set(n,j, q * H.get(n,j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i,n - 1);
          H.set(i,n - 1, q * z + p * H.get(i,n));
          H.set(i,n, q * H.get(i,n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i,n - 1);
          V.set(i,n - 1, q * z + p * V.get(i,n));
          V.set(i,n,  q * V.get(i,n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n,n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1,n - 1);
        w = H.get(n,n - 1) * H.get(n - 1,n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.incr(i,i, -x);
        }
        s = Math.abs(H.get(n,n - 1)) + Math.abs(H.get(n - 1,n - 2));
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.incr(i,i, -s);
          }
          exshift += s;
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m,m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1,m) + H.get(m,m + 1);
        q = H.get(m + 1,m + 1) - z - r - s;
        r = H.get(m + 2,m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m,m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1,m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1,m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i,i - 2, 0);
        if (i > m + 2) {
          H.set(i,i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k,k - 1);
          q = H.get(k + 1,k - 1);
          r = notlast ? H.get(k + 2,k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k,k - 1, -s * x);
          } else if (l !== m) {
            H.set(k,k - 1, -H.get(k,k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k,j) + q * H.get(k + 1,j);
            if (notlast) {
              p = p + r * H.get(k + 2,j);
              H.incr(k + 2,j, -(p * z));
            }

            H.incr(k,j, -(p * x));
            H.incr(k + 1,j, -(p * y));
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i,k) + y * H.get(i,k + 1);
            if (notlast) {
              p = p + z * H.get(i,k + 2);
              H.incr(i,k + 2, -(p * r));
            }

            H.incr(i,k, -p);
            H.incr(i,k + 1, -(p * q));
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i,k) + y * V.get(i,k + 1);
            if (notlast) {
              p = p + z * V.get(i,k + 2);
              V.incr(i,k + 2 , -(p * r));
            }

            V.incr(i,k,-p);
            V.incr(i,k + 1,-(p * q));
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n,n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i,i, -p);
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i,j) * H.get(j,n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i,n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i,n, t);
            H.set(i + 1,n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z);
          }

          t = Math.abs(H.get(i,n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n, t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n,n - 1)) > Math.abs(H.get(n - 1,n))) {
        H.set(n - 1,n - 1, q / H.get(n,n - 1));
        H.set(n - 1,n, -(H.get(n,n) - p) / H.get(n,n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1,n), H.get(n - 1,n - 1) - p, q);
        H.set(n - 1,n - 1, cdivres[0]);
        H.set(n - 1,n,  cdivres[1]);
      }

      H.set(n,n - 1,  0);
      H.set(n,n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i,j) * H.get(j,n - 1);
          sa = sa + H.get(i,j) * H.get(j,n);
        }

        w = H.get(i,i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi
            );
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(i + 1,n - 1,(-ra - w * H.get(i,n - 1) + q * H.get(i,n)) / x);
              H.set(i + 1,n, (-sa - w * H.get(i,n) - q * H.get(i,n - 1)) / x);
            } else {
              cdivres = cdiv(-r - y * H.get(i,n - 1), -s - y * H.get(i,n), z, q);
              H.set(i + 1,n - 1, cdivres[0]);
              H.set(i + 1,n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i,n - 1)), Math.abs(H.get(i,n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n - 1, t);
              H.divide(j,n, t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i,j,  H.get(i,j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i,k) * H.get(k,j);
      }
      V.set(i,j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  var r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}

module.exports = EigenvalueDecomposition
};
BundleModuleCode['plugins/math/matrixTA-SVD']=function (module,exports){
// Matrix SingularValueDecomposition
// TypedArray version
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function SingularValueDecomposition(matrix, options) {
  if (!(this instanceof SingularValueDecomposition)) return new SingularValueDecomposition(matrix,options);
  options=checkOptions(options);
  var value = Matrix.checkMatrix(matrix);

  var m = value.rows;
  var n = value.columns;

  var computeLeftSingularVectors = checkOption(options.computeLeftSingularVectors,true)
  var computeRightSingularVectors = checkOption(options.computeRightSingularVectors,true)
  var autoTranspose = checkOption(options.autoTranspose,false)

  var wantu = Boolean(computeLeftSingularVectors);
  var wantv = Boolean(computeRightSingularVectors);

  var swapped = false;
  var a;
  if (m < n) {
    if (!autoTranspose) {
      a = value.clone();
      // eslint-disable-next-line no-console
      console.warn(
        'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
      );
    } else {    
      a = value.transpose();
      m = a.rows;
      n = a.columns;
      swapped = true;
      var aux = wantu;
      wantu = wantv;
      wantv = aux;
    }
  } else {
    a = value.clone();
  }

  var nu = Math.min(m, n);
  var ni = Math.min(m + 1, n);
  var s = new Array(ni);
  var U = Matrix(m, nu, {dtn:value.dtn}); 
  var V = Matrix(n, n,  {dtn:value.dtn});  

  var e = new Array(n);
  var work = new Array(m);

  var si = new Array(ni);
  for (var i = 0; i < ni; i++) si[i] = i;

  var nct = Math.min(m - 1, n);
  var nrt = Math.max(0, Math.min(n - 2, m));
  var mrc = Math.max(nct, nrt);
  
  for (var k = 0; k < mrc; k++) {
    if (k < nct) {
      s[k] = 0;
      for (var i = k; i < m; i++) {
        s[k] = hypotenuse(s[k], a.get(i,k));
      }
      if (s[k] !== 0) {
        if (a.get(k,k) < 0) {
          s[k] = -s[k];
        }
        for (var i = k; i < m; i++) {
          a.divide(i,k,s[k]);
        }
        a.incr(k,k,1);
      }
      s[k] = -s[k];
    }

    for (var j = k + 1; j < n; j++) {
      if (k < nct && s[k] !== 0) {
        var t = 0;
        for (var i = k; i < m; i++) {
          t += a.get(i,k) * a.get(i,j);
        }
        t = -t / a.get(k,k);
        for (var i = k; i < m; i++) {
          a.incr(i,j, t * a.get(i,k));
        }
      }
      e[j] = a.get(k,j);
    }
    
    if (wantu && k < nct) {
      for (var i = k; i < m; i++) {
        U.set(i,k, a.get(i,k));
      }
    }
    
    if (k < nrt) {
      e[k] = 0;
      for (var i = k + 1; i < n; i++) {
        e[k] = hypotenuse(e[k], e[i]);
      }
      if (e[k] !== 0) {
        if (e[k + 1] < 0) {
          e[k] = 0 - e[k];
        }
        for (var i = k + 1; i < n; i++) {
          e[i] /= e[k];
        }
        e[k + 1] += 1;
      }
      e[k] = -e[k];
      if (k + 1 < m && e[k] !== 0) {
        for (var i = k + 1; i < m; i++) {
          work[i] = 0;
        }
        for (var i = k + 1; i < m; i++) {
          for (var j = k + 1; j < n; j++) {
            work[i] += e[j] * a.get(i,j);
          }
        }
        for (var j = k + 1; j < n; j++) {
          var t = -e[j] / e[k + 1];
          for (var i = k + 1; i < m; i++) {
            a.incr(i,j, t * work[i]);
          }
        }
      }
      if (wantv) {
        for (var i = k + 1; i < n; i++) {
          V.set(i,k, e[i]);
        }
      }
    }
  }

  var p = Math.min(n, m + 1);
  if (nct < n) {
    s[nct] = a.get(nct,nct);
  }
  if (m < p) {
    s[p - 1] = 0;
  }
  if (nrt + 1 < p) {
    e[nrt] = a.get(nrt,p - 1);
  }
  e[p - 1] = 0;

  if (wantu) {
    for (var j = nct; j < nu; j++) {
      for (var i = 0; i < m; i++) {
        U.set(i,j, 0);
      }
      U.set(j,j, 1);
    }
    for (var k = nct - 1; k >= 0; k--) {
      if (s[k] !== 0) {
        for (var j = k + 1; j < nu; j++) {
          var t = 0;
          for (var i = k; i < m; i++) {
            t += U.get(i,k) * U.get(i,j);
          }
          t = -t / U.get(k,k);
          for (var i = k; i < m; i++) {
            U.incr(i,j, t * U.get(i,k));
          }
        }
        for (var i = k; i < m; i++) {
          U.set(i,k, -U.get(i,k));
        }
        U.incr(k,k,1); // = 1 + U[k][k];
        for (var i = 0; i < k - 1; i++) {
          U.set(i,k,0);
        }
      } else {
        for (var i = 0; i < m; i++) {
          U.set(i,k,0);
        }
        U.set(k,k,1);
      }
    }
  }

  if (wantv) {
    for (var k = n - 1; k >= 0; k--) {
      if (k < nrt && e[k] !== 0) {
        for (var j = k + 1; j < n; j++) {
          var t = 0;
          for (var i = k + 1; i < n; i++) {
            t += V.get(i,k) * V.get(i,j);
          }
          t = -t / V.get(k + 1,k);
          for (var i = k + 1; i < n; i++) {
            V.incr(i,j, t * V.get(i,k));
          }
        }
      }
      for (var i = 0; i < n; i++) {
        V.set(i,k,0);
      }
      V.set(k,k, 1);
    }
  }
  
  var pp = p - 1;
  var iter = 0;
  var eps = Number.EPSILON;
  
  while (p > 0) {
    var k, kase;
    for (k = p - 2; k >= -1; k--) {
      if (k === -1) {
        break;
      }
      const alpha =
        Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
      if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
        e[k] = 0;
        break;
      }
    }
    if (k === p - 2) {
      kase = 4;
    } else {
      var ks;
      for (ks = p - 1; ks >= k; ks--) {
        if (ks === k) {
          break;
        }
        var t =
          (ks !== p ? Math.abs(e[ks]) : 0) +
          (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
        if (Math.abs(s[ks]) <= eps * t) {
          s[ks] = 0;
          break;
        }
      }
      if (ks === k) {
        kase = 3;
      } else if (ks === p - 1) {
        kase = 1;
      } else {
        kase = 2;
        k = ks;
      }
    }

    k++;

    switch (kase) {
      case 1: {
        var f = e[p - 2];
        e[p - 2] = 0;
        for (var j = p - 2; j >= k; j--) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          if (j !== k) {
            f = -sn * e[j - 1];
            e[j - 1] = cs * e[j - 1];
          }
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,p - 1);
              V,set(i,p - 1, -sn * V.get(i,j) + cs * V.get(i,p - 1));
              V.set(i,j, t);
            }
          }
        }
        break;
      }
      case 2: {
        var f = e[k - 1];
        e[k - 1] = 0;
        for (var j = k; j < p; j++) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          f = -sn * e[j];
          e[j] = cs * e[j];
          if (wantu) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U[i][k - 1];
              U.set(i,k - 1, -sn * U.get(i,j) + cs * U.get(i,k - 1));
              U.set(i,j,t);
            }
          }
        }
        break;
      }
      case 3: {
        const scale = Math.max(
          Math.abs(s[p - 1]),
          Math.abs(s[p - 2]),
          Math.abs(e[p - 2]),
          Math.abs(s[k]),
          Math.abs(e[k])
        );
        const sp = s[p - 1] / scale;
        const spm1 = s[p - 2] / scale;
        const epm1 = e[p - 2] / scale;
        const sk = s[k] / scale;
        const ek = e[k] / scale;
        const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
        const c = sp * epm1 * (sp * epm1);
        var shift = 0;
        if (b !== 0 || c !== 0) {
          if (b < 0) {
            shift = 0 - Math.sqrt(b * b + c);
          } else {
            shift = Math.sqrt(b * b + c);
          }
          shift = c / (b + shift);
        }
        var f = (sk + sp) * (sk - sp) + shift;
        var g = sk * ek;
        for (var j = k; j < p - 1; j++) {
          var t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          var cs = f / t;
          var sn = g / t;
          if (j !== k) {
            e[j - 1] = t;
          }
          f = cs * s[j] + sn * e[j];
          e[j] = cs * e[j] - sn * s[j];
          g = sn * s[j + 1];
          s[j + 1] = cs * s[j + 1];
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,j + 1);
              V.set(i,j + 1, -sn * V.get(i,j) + cs * V.get(i,j + 1));
              V.set(i,j, t);
            }
          }
          t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          cs = f / t;
          sn = g / t;
          s[j] = t;
          f = cs * e[j] + sn * s[j + 1];
          s[j + 1] = -sn * e[j] + cs * s[j + 1];
          g = sn * e[j + 1];
          e[j + 1] = cs * e[j + 1];
          if (wantu && j < m - 1) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U.get(i,j + 1);
              U.set(i,j + 1,  -sn * U.get(i,j) + cs * U.get(i,j + 1));
              U.set(i,j, t);
            }
          }
        }
        e[p - 2] = f;
        iter = iter + 1;
        break;
      }
      case 4: {
        if (s[k] <= 0) {
          s[k] = s[k] < 0 ? -s[k] : 0;
          if (wantv) {
            for (var i = 0; i <= pp; i++) {
              V.set(i,k, -V.get(i,k));
            }
          }
        }
        while (k < pp) {
          if (s[k] >= s[k + 1]) {
            break;
          }
          var t = s[k];
          s[k] = s[k + 1];
          s[k + 1] = t;
          if (wantv && k < n - 1) {
            for (var i = 0; i < n; i++) {
              t = V.get(i,k + 1);
              V.set(i,k + 1, V.get(i,k));
              V.set(i,k, t);
            }
          }
          if (wantu && k < m - 1) {
            for (var i = 0; i < m; i++) {
              t = U.get(i,k + 1);
              U.set(i,k + 1,  U.get(i,k));
              U.set(i,k, t);
            }
          }
          k++;
        }
        iter = 0;
        p--;
        break;
      }
      // no default
    }
  }

  if (swapped) {
    var tmp = V;
    V = U;
    U = tmp;
  }

  this.m = m;
  this.n = n;
  this.s = s;
  this.U = U;
  this.V = V;

    
}

SingularValueDecomposition.prototype = {
  /**
   *
   * @return {number}
   */
  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  },

  /**
   *
   * @return {number}
   */
  get norm2() {
    return this.s[0];
  },

  /**
   *
   * @return {number}
   */
  get rank() {
    var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    var r = 0;
    var s = this.s;
    for (var i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  },

  /**
   *
   * @return {Array<number>}
   */
  get diagonal() {
    return this.s;
  },

  /**
   *
   * @return {number}
   */
  get threshold() {
    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
  },

  /**
   *
   * @return {Matrix}
   */
  get leftSingularVectors() {
    if (!Matrix.isMatrix(this.U)) {
      this.U = new Matrix(this.U);
    }
    return this.U;
  },

  /**
   *
   * @return {Matrix}
   */
  get rightSingularVectors() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    return Matrix.diag(this.s);
  }
}
  /**
   * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
   * var svd = SingularValueDecomposition(A);
   * var x = svd.solve(b);
   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
   * @return {Matrix} - The vector x
   */
SingularValueDecomposition.prototype.solve = function(value) {
  var Y = value;
  var e = this.threshold;
  var scols = this.s.length;
  var Ls = Matrix.zeros(scols, scols);

  for (var i = 0; i < scols; i++) {
    if (Math.abs(this.s[i]) <= e) {
      Ls.set(i,i, 0);
    } else {
      Ls.set(i,i, 1 / this.s[i]);
    }
  }

  var U = this.U;
  var V = this.rightSingularVectors;

  var VL = V.mmul(Ls);
  var vrows = V.rows;
  var urows = U.length;
  var VLU = Matrix.zeros(vrows, urows);

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < scols; k++) {
        sum += VL.get(i,k) * U.get(j,k);
      }
      VLU.set(i,j, sum);
    }
  }

  return VLU.mmul(Y);
}

  /**
   *
   * @param {Array<number>} value
   * @return {Matrix}
   */
SingularValueDecomposition.prototype.solveForDiagonal = function (value) {
  return this.solve(Matrix.diag(value));
}

  /**
   * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
   * var svd = SingularValueDecomposition(A);
   * var inverseA = svd.inverse();
   * @return {Matrix} - The approximation of the inverse of the matrix
   */
SingularValueDecomposition.prototype.inverse = function () {
  var V = this.V;
  var e = this.threshold;
  var vrows = V.rows;
  var vcols = V.columns;
  var X = Matrix(vrows, this.s.length, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < vcols; j++) {
      if (Math.abs(this.s[j]) > e) {
        X.set(i,j, V.get(i,j) / this.s[j]);
      } else {
        X.set(i,j, 0);
      }
    }
  }

  var U = this.U;

  var urows = U.rows;
  var ucols = U.columns;
  var Y = Matrix(vrows, urows, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < ucols; k++) {
        sum += X.get(i,k) * U.get(j,k);
      }
      Y.set(i,j, sum);
    }
  }

  return Y;
}

module.exports = SingularValueDecomposition;
};
BundleModuleCode['plugins/math/matrix']=function (module,exports){
/* Matrix array objects
** Version 1.3.4
*/
var version = "1.4.1"
var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;

// elements:[rows,columns,levels] (3D not supported by methods)
function Matrix(elements,options,aux) {
  if (!(this instanceof Matrix)) return new Matrix(elements,options,aux);
  options=options||{};
  this.tag='Matrix';
  var space=[];
  if (Utils.isNumber(elements)) space.push(elements);
  if (Utils.isNumber(options)) space.push(options);  
  if (Utils.isNumber(aux)) space.unshift(aux); // !!!
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.data=Array(space[0]).fill(0);
    if (space.length>1) for(var i=0;i<space[0];i++) this.data[i]=Array(space[1]).fill(0);
    if (space.length>2) for(var i=0;i<space[0];i++) 
                          for(var j=0;j<space[1];j++) this.data[i][j]=Array(space[2]).fill(0);
    this.dims=space.length;
    
  } else  
    this.setData(elements,options.reference);
  this.__constructor__='Math.Matrix';
};

Matrix.version=version;

Matrix.create = Matrix
// var $M = Matrix.create;

Matrix.isMatrix = function (o) {
  return o instanceof Matrix
}

Matrix.I = function(n) {
  var els = [], i = n, j;
  while (i--) { j = n;
    els[i] = [];
    while (j--) {
      els[i][j] = (i === j) ? 1 : 0;
    }
  }
  return Matrix.create(els);
};

Matrix.Init = function(rows,columns,callback) {
  var els = [], i = rows, j;
  while (i--) { j = columns;
    els[i] = [];
    if (typeof callback == 'function')
    while (j--) {
      els[i][j] = callback(i,j);
    }
    else
    while (j--) {
      els[i][j] = callback; // constant value
    }
  }
  return Matrix.create(els);
};

Matrix.Diagonal = function(elements) {
  var i = elements.length;
  var M = Matrix.I(i);
  while (i--) {
    M.data[i][i] = elements[i];
  }
  return M;
};

Matrix.Rotation = function(theta, a) {
  if (!a) {
    return Matrix.create([
      [Math.cos(theta),  -Math.sin(theta)],
      [Math.sin(theta),   Math.cos(theta)]
    ]);
  }
  var axis = a.dup();
  if (axis.data.length !== 3) { return null; }
  var mod = axis.modulus();
  var x = axis.data[0]/mod, y = axis.data[1]/mod, z = axis.data[2]/mod;
  var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
  // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
  // That proof rotates the co-ordinate system so theta becomes -theta and sin
  // becomes -sin here.
  return Matrix.create([
    [ t*x*x + c, t*x*y - s*z, t*x*z + s*y ],
    [ t*x*y + s*z, t*y*y + c, t*y*z - s*x ],
    [ t*x*z - s*y, t*y*z + s*x, t*z*z + c ]
  ],{reference:true});
};

Matrix.RotationX = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  1,  0,  0 ],
    [  0,  c, -s ],
    [  0,  s,  c ]
  ],{reference:true});
};
Matrix.RotationY = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c,  0,  s ],
    [  0,  1,  0 ],
    [ -s,  0,  c ]
  ],{reference:true});
};
Matrix.RotationZ = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c, -s,  0 ],
    [  s,  c,  0 ],
    [  0,  0,  1 ]
  ],{reference:true});
};

Matrix.Random = function(n, m) {
  return Matrix.Zero(n, m).map(
    function() { return Math.random(); }
  );
};

Matrix.Zero = function(n, m) {
  var els = [], i = n, j;
  while (i--) { j = m;
    els[i] = [];
    while (j--) {
      els[i][j] = 0;
    }
  }
  return Matrix.create(els,{reference:true});
};

Matrix.prototype = {

  add: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x + M[i][j]; });
  },

  addColumn : function (index,data) {
    var T = this, cols = T.data[0].length;
    if (index==cols) {
      // simple, append on right side
      T.data.forEach(function (row,i) {
        row.push(data[i])
      })
    }
    return T;
  },
  
  apply: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        this.data[i][j]=fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  augment: function(matrix) {
    if (this.data.length === 0) { return this.dup(); }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    var T = this.dup(), cols = T.data[0].length;
    var i = T.data.length, nj = M[0].length, j;
    if (i !== M.length) { return null; }
    while (i--) { j = nj;
      while (j--) {
        T.data[i][cols + j] = M[i][j];
      }
    }
    return T;
  },

  canMultiplyFromLeft: function(matrix) {
    if (this.data.length === 0) { return false; }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    // this.columns should equal matrix.rows
    return (this.data[0].length === M.length);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b,c,d) {
    var i,j,k,p,v,m,ni,nj,nk,filter;

    if (isNumber(a)) i=a;
    if (isNumber(b)) j=b;
    if (isNumber(c)) k=c;
    if (isString(b)) filter=b;
    if (isString(c)) filter=c;
    if (isString(d)) filter=d;
    if (!filter) filter='mean';

    if (!i) throw "Matrix.convert: no target size (number, first dim.)";
    if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";

    m = Matrix(i,j,k);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.rows/m.rows);
    nj=Math.floor(this.columns/m.columns);
    for(i=0;i<m.rows;i++) {
      for(j=0;j<m.columns;j++) {
        for(p=0;p<ni;p++) {
          for(q=0;q<nj;q++) {
            if (p==0 && q==0) 
              v=this.get(i*ni,j*nj);
            else
              v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
          }
        }
        m.set(i,j,v);
      }
    }
    return m;
  },

  col: function(j,asVector) {
    if (this.data.length === 0) { return null; }
    if (j >= this.data[0].length) { return null; }
    var col = [], n = this.data.length;
    for (var i = 0; i < n; i++) { col.push(this.data[i][j]); }
    return asVector?Math.Vector.create(col):col;
  },

  cols: function() {
    if (this.data.length === 0) { return 0; }
    return this.data[0].length;
  },

  derivative : function (order,points,h) {
    // TODO >1dim return Matrix.create(Math.derivative(this.data,order,points,h),{reference:true});
  },
  
  determinant: function() {
    if (this.data.length === 0) { return 1; }
    if (!this.isSquare()) { return null; }
    var M = this.toRightTriangular();
    var det = M.data[0][0], n = M.data.length;
    for (var i = 1; i < n; i++) {
      det = det * M.data[i][i];
    }
    return det;
  },

  diagonal: function() {
    if (!this.isSquare) { return null; }
    var els = [], n = this.data.length;
    for (var i = 0; i < n; i++) {
      els.push(this.data[i][i]);
    }
    return Math.Vector.create(els);
  },

  dimensions: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return {rows: this.data.length, cols: cols};
  },

  dup: function() {
    return Matrix.create(this.data);
  },

  // row,col
  e: function(i,j) {
    if (i < 1 || i > this.data.length || j < 1 || j > this.data[0].length) { return null; }
    return this.data[i-1][j-1];
  },

  eql: function(matrix) {
    var M = matrix.data || matrix;
    if (!M[0] || typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0 || M.length === 0) {
      return this.data.length === M.length;
    }
    if (this.data.length !== M.length) { return false; }
    if (this.data[0].length !== M[0].length) { return false; }
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j] - M[i][j]) > Math.precision) { return false; }
      }
    }
    return true;
  },

  forEach: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  get: function (i,j) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j];    
  },

  get rows () {
    return this.data.length;
  },
  get columns () {
    return this.data[0].length;
  },

  indexOf: function(x) {
    if (this.data.length === 0) { return null; }
    var index = null, ni = this.data.length, i, nj = this.data[0].length, j;
    for (i = 0; i < ni; i++) {
      for (j = 0; j < nj; j++) {
        if (this.data[i][j] === x) { return {i: i+1, j: j+1}; }
      }
    }
    return null;
  },

  inspect: function() {
    var matrix_rows = [];
    var n = this.data.length;
    if (n === 0) return '[]';
    for (var i = 0; i < n; i++) {
      matrix_rows.push(Math.Vector.create(this.data[i]).inspect());
    }
    return matrix_rows.join('\n');
  },

  inverse: function() {
    if (this.data.length === 0) { return null; }
    if (!this.isSquare() || this.isSingular()) { return null; }
    var n = this.data.length, i= n, j;
    var M = this.augment(Matrix.I(n)).toRightTriangular();
    var np = M.data[0].length, p, els, divisor;
    var inverse_elements = [], new_element;
    // Matrix. is non-singular so there will be no zeros on the
    // diagonal. Cycle through rows from last to first.
    while (i--) {
      // First, normalise diagonal elements to 1
      els = [];
      inverse_elements[i] = [];
      divisor = M.data[i][i];
      for (p = 0; p < np; p++) {
        new_element = M.data[i][p] / divisor;
        els.push(new_element);
        // Shuffle off the current row of the right hand side into the results
        // array as it will not be modified by later runs through this loop
        if (p >= n) { inverse_elements[i].push(new_element); }
      }
      M.data[i] = els;
      // Then, subtract this row from those above it to give the identity matrix
      // on the left hand side
      j = i;
      while (j--) {
        els = [];
        for (p = 0; p < np; p++) {
          els.push(M.data[j][p] - M.data[i][p] * M.data[j][i]);
        }
        M.data[j] = els;
      }
    }
    return Matrix.create(inverse_elements);
  },

  isSameSizeAs: function(matrix) {
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0) { return M.length === 0; }
    return (this.data.length === M.length &&
        this.data[0].length === M[0].length);
  },

  isSingular: function() {
    return (this.isSquare() && this.determinant() === 0);
  },

  isSquare: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return (this.data.length === cols);
  },

  iter: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  loop: function(fn, context, tmo) {
    var tmo=typeof context=='number'?context:(tmo||1);
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    var timer = setInterval(tmo,function () {
      if (i<ni) { 
        if (j<nj) {
          fn.call(context, this.data[i][j], i, j);
          j++;
        } else j = 0,i++;
      } else clearInterval(timer);
    });
    return this;
  },
  
  max: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] > m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) > Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  map: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        els[i][j] = fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  mapRow : function (f) {
    var res=[];
    for(var row=0;row<this.rows;row++) {
      res.push(f(this.data[row],row));
    }
    return res;
  },

  min: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] < m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) < Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minor: function(a, b, c, d) {
    if (this.data.length === 0) { return null; }
    var elements = [], ni = c, i, nj, j;
    var rows = this.data.length, cols = this.data[0].length;
    while (ni--) { i = c - ni - 1;
      elements[i] = [];
      nj = d;
      while (nj--) { j = d - nj - 1;
        elements[i][j] = this.data[(a+i-1)%rows][(b+j-1)%cols];
      }
    }
    return Matrix.create(elements);
  },

  multiply: function(matrix) {
    if (this.data.length === 0) { return null; }
    if (!matrix.data) {
      return this.map(function(x) { return x * matrix; });
    }
    var returnVector = matrix.modulus ? true : false;
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.canMultiplyFromLeft(M)) { return null; }
    var i = this.data.length, nj = M[0].length, j;
    var cols = this.data[0].length, c, elements = [], sum;
    while (i--) { j = nj;
      elements[i] = [];
      while (j--) { c = cols;
        sum = 0;
        while (c--) {
          sum += this.data[i][c] * M[c][j];
        }
        elements[i][j] = sum;
      }
    }
    var M = Matrix.create(elements);
    return returnVector ? M.col(0,true) : M;
  },

  print : function (preci) {
    return this.dims==3?this.data.map(function (m) { return m.print() }).join('\n\n'):this.data.print(preci)
  },
  
  rank: function() {
    if (this.data.length === 0) { return 0; }
    var M = this.toRightTriangular(), rank = 0;
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(M.data[i][j]) > Math.precision) { rank++; break; }
      }
    }
    return rank;
  },

  // typeof @options = { rows, columns, algorithm?:'bilinear', ..}
  resize : function (options) {
    var space=this.dataspace,
        new_space=[],
        interp = 'nearest-neighbor',  // resize with interpolation 
        offset=[];
    if (Utils.isArray(options)) { // [row0,col0,row1,col1]
      switch (options.length) {
        case 2:
          new_space=[options[1]-options[0]];
          offset=[options[0]];
          break;
        case 4:
          new_space=[options[2]-options[0], options[3]-options[1]];
          offeset=[options[0],options[1]];
          break;
      }
    } else for(var p in options) {
      switch (p) {
        case 'rows':    new_space[0]=options[p]; break;
        case 'columns': new_space[1]=options[p]; break;
        case 'levels':  new_space[2]=options[p]; break;
        case 'dataspace': new_space=dataspace; break;
        case 'algorithm': interp=options[p]; break;
        case 'offset':
          offset=options[p];
          break;
      }
    }
    if (typeof offset == 'number') offset=[offset];
    
    // from https://github.com/LinusU/resize-image-data
    function nearestNeighbor (src, dst) {
      for (var y = 0; y < dst.rows; y++) {
        for (var x = 0; x < dst.columns; x++) {
          var srcX = Math.floor(x * src.columns / dst.columns)
          var srcY = Math.floor(y * src.rows / dst.rows)
          dst.data[y][x]=src.data[srcY][srcX];
        }
      }
    }
    function bilinearInterpolation (src, dst) {
      function interpolate (k, kMin, kMax, vMin, vMax) {
        return ((k - kMin) * vMax + (kMax - k) * vMin)
      }
      function interpolateHorizontal (x, y, xMin, xMax) {
        var vMin = src.data[y][xMin]
        if (xMin === xMax) return vMin;
        var vMax = src.data[y][xMax];
        return interpolate(x, xMin, xMax, vMin, vMax)
      }
      function interpolateVertical (x, xMin, xMax, y, yMin, yMax) {
        var vMin = interpolateHorizontal(x, yMin, xMin, xMax);
        if (yMin === yMax) return vMin;
        var vMax = interpolateHorizontal(x, yMax, xMin, xMax);
        return interpolate(y, yMin, yMax, vMin, vMax)
      }
      for (var y = 0; y < dst.rows; y++) {
        for (var x = 0; x < dst.columns; x++) {
          var srcX = x * src.columns / dst.columns
          var srcY = y * src.rows / dst.rows
          var xMin = Math.floor(srcX)
          var yMin = Math.floor(srcY)
          var xMax = Math.min(Math.ceil(srcX), src.columns - 1)
          var yMax = Math.min(Math.ceil(srcY), src.rows - 1)
          dst.data[y][x] = interpolateVertical(srcX, xMin, xMax, srcY, yMin, yMax)
         }
      }
    }
    
    switch (new_space.length) {
      case 0:
        // shrink rows
        if (offset.length==1) {
          return this.slice(offset[0]);        
        }
        break;
      case 1:
        // shrink/expand rows
        if (new_space[0]<space[0]) {
          offset=offset[0]||0;
          return this.slice(offset,offset+new_space[0]);
        }
        break;
      case 2:
        switch (interp) {
          case 'biliniear-interpolation':
          case 'bilinear':
            var src = this,
                dst = Matrix(new_space[0],new_space[1]);
            bilinearInterpolation(src,dst);
            return dst;
            break;
          case 'nearest-neighbor':
          case 'nearest':
          default:
            var src = this,
                dst = Matrix(new_space[0],new_space[1]);
            nearestNeighbor(src,dst);
            return dst;
            break;
        }
     
    }
    return new Error('ENOTSUPPORTED');
  },
  
  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  row: function(i,asVector) {
    if (i >= this.data.length) { return null; }
    return asVector?Math.Vector.create(this.data[i]):this.data[i];
  },

  snapTo: function(x) {
    return this.map(function(p) {
      return (Math.abs(p - x) <= Math.precision) ? x : p;
    });
  },

  set: function (i,j,v) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j]=v;    
  },

  setData: function(els,ref) {
    var i, j, elements = els.data || els;
    this.datatype='number';
    this.dataspace=Math.dataspace(elements);
    if (ref) { this.data=els; return this};
    if (elements[0] && typeof(elements[0][0]) !== 'undefined') {
      i = elements.length;
      this.data = [];
      while (i--) { j = elements[i].length;
        this.data[i] = [];
        while (j--) {
          this.data[i][j] = elements[i][j];
        }
      }
      return this;
    }
    var n = elements.length;
    this.data = [];
    for (i = 0; i < n; i++) {
      this.data.push([elements[i]]);
    }
    return this;
  },
  
  // Slice of data in major dimension
  slice : function (a,b,inplace) {
    if (b==undefined) b=this.rows;
    return inplace?
            Matrix(this.data.slice(a,b))
            : Matrix(this.data.slice(a,b).map(function (row) { return row.slice() }));
  },
  
  subMatrix : function (startRow, endRow, startColumn, endColumn) {
    var data = [];
    switch (this.dataspace.length) {
      case 1:
        for(var i=startRow;i<=endRow;i++) {
          data.push(this.data[i]);
        }
        return Vector(data);
        break;
      case 2:
        for(var i=startRow;i<endRow;i++) {
          var row=[];
          for(var j=startColumn;j<=endColumn;j++) {
            row.push(this.data[i][j]);
          }
          data.push(row);
        }
        return Matrix(data);
        break;
    }
  },
  
  // rx:rows,ry:columns,rz:levels
  subMatrixRange : function (rx,ry,rz) {
    var data=[];
    function copy(x) { return x.slice() }
    if (this.dataspace.length!=2) throw "subMatrixRange: dim not supported"
    if (isNumber(rx) && isAll(ry)) {
      return Matrix([this.data[rx].slice()]);
    } else if (isRange(rx) && isAll(ry)) {
      return Matrix(this.data.slice(rx[0],rx[1]+1).map(copy)); 
    } else {
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    }
  },
  
  
  subtract: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x - M[i][j]; });
  },

  toArray : function () { return this.data },
  
  toRightTriangular: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var M = this.dup(), els;
    var n = this.data.length, i, j, np = this.data[0].length, p;
    for (i = 0; i < n; i++) {
      if (M.data[i][i] === 0) {
        for (j = i + 1; j < n; j++) {
          if (M.data[j][i] !== 0) {
            els = [];
            for (p = 0; p < np; p++) { els.push(M.data[i][p] + M.data[j][p]); }
            M.data[i] = els;
            break;
          }
        }
      }
      if (M.data[i][i] !== 0) {
        for (j = i + 1; j < n; j++) {
          var multiplier = M.data[j][i] / M.data[i][i];
          els = [];
          for (p = 0; p < np; p++) {
            // Elements with column numbers up to an including the number of the
            // row that we're subtracting can safely be set straight to zero,
            // since that's the point of this routine and it avoids having to
            // loop over and correct rounding errors later
            els.push(p <= i ? 0 : M.data[j][p] - M.data[i][p] * multiplier);
          }
          M.data[j] = els;
        }
      }
    }
    return M;
  },

  trace: function() {
    if (this.data.length === 0) { return 0; }
    if (!this.isSquare()) { return null; }
    var tr = this.data[0][0], n = this.data.length;
    for (var i = 1; i < n; i++) {
      tr += this.data[i][i];
    }
    return tr;
  },
  
  transpose: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var rows = this.data.length, i, cols = this.data[0].length, j;
    var elements = [], i = cols;
    while (i--) { j = rows;
      elements[i] = [];
      while (j--) {
        elements[i][j] = this.data[j][i];
      }
    }
    return Matrix.create(elements);
  },
};

Matrix.prototype.toUpperTriangular = Matrix.prototype.toRightTriangular;
Matrix.prototype.det = Matrix.prototype.determinant;
Matrix.prototype.tr = Matrix.prototype.trace;
Matrix.prototype.rk = Matrix.prototype.rank;
Matrix.prototype.inv = Matrix.prototype.inverse;
Matrix.prototype.x = Matrix.prototype.multiply;
Matrix.prototype.pluck = Matrix.prototype.col;

module.exports = Matrix;
};
BundleModuleCode['plugins/math/vector']=function (module,exports){
/*
** Vector array objects
**
** Ver. 1.4.1
*/
var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;
    
var Vector = function(elements,options) {
  if (!(this instanceof Vector)) return new Vector(elements,options);
  options=options||{};
  var space=[];
  this.tag='Vector';
  if (typeof elements == 'number') space.push(elements);
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.columns=space[0];
    this.data=Array(space[0]).fill(0);
  } else {
    this.columns=elements.length;
    this.setData(elements,options.reference);
  }
  this.__constructor__='Math.Vector';
};

Vector.isVector = function (o) {
  return o instanceof Vector
}

Vector.create = Vector

// var $V = Vector.create;
Vector.Init = function(n,valueOrCallback) {
  var elements = [],i=0;
  if (typeof valueOrCallback == 'function')
    while (i<n) { elements.push(valueOrCallback(i)); i++; }
  else
    while (i<n) { elements.push(valueOrCallback); i++; }
  return Vector.create(elements);
};

Vector.Random = function(n) {
  var elements = [];
  while (n--) { elements.push(Math.random()); }
  return Vector.create(elements);
};

Vector.Sequence = function(a,b,step) {
  if (!step) step=1;
  var elements = [];
  var i=a;
  while (i<b) { 
    elements.push(i);
    i += step; 
  }
  return Vector.create(elements);
};

Vector.Zero = function(n) {
  var elements = [];
  while (n--) { elements.push(0); }
  return Vector.create(elements);
};

Vector.prototype = {
  e: function(i) {
    return (i < 1 || i > this.data.length) ? null : this.data[i-1];
  },


  add: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x + V[i-1]; });
  },

  angleFrom: function(vector) {
    var V = vector.data || vector;
    var n = this.data.length, k = n, i;
    if (n !== V.length) { return null; }
    var dot = 0, mod1 = 0, mod2 = 0;
    // Work things out in parallel to save time
    this.each(function(x, i) {
      dot += x * V[i-1];
      mod1 += x * x;
      mod2 += V[i-1] * V[i-1];
    });
    mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
    if (mod1*mod2 === 0) { return null; }
    var theta = dot / (mod1*mod2);
    if (theta < -1) { theta = -1; }
    if (theta > 1) { theta = 1; }
    return Math.acos(theta);
  },

  cross: function(vector) {
    var B = vector.data || vector;
    if (this.data.length !== 3 || B.length !== 3) { return null; }
    var A = this.data;
    return Vector.create([
      (A[1] * B[2]) - (A[2] * B[1]),
      (A[2] * B[0]) - (A[0] * B[2]),
      (A[0] * B[1]) - (A[1] * B[0])
    ]);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b) {
    var i,p,v,m,ni,filter;

    if (isNumber(a)) i=a;
    if (isString(b)) filter=b;
    if (!filter) filter='mean';

    if (!i) throw "Vector.convert: no target size (number, first dim.)";

    m = Vector(i);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.columns/m.columns);
    for(i=0;i<m.columns;i++) {
        v=this.data[i*ni]; 
        for(p=1;p<ni;p++) {
          v=filter(v,this.data[i*ni+p],p,ni);
        }
        m.data[i]=v;
    }
    return m;
  },

  derivative : function (order,points,h) {
    return Vector.create(Math.derivative(this.data,order,points,h),{reference:true});
  },

  dimensions: function() {
    return this.data.length;
  },

  distanceFrom: function(obj) {
    if (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    var V = obj.data || obj;
    if (V.length !== this.data.length) { return null; }
    var sum = 0, part;
    this.each(function(x, i) {
      part = x - V[i-1];
      sum += part * part;
    });
    return Math.sqrt(sum);
  },

  dot: function(vector) {
    var V = vector.data || vector;
    var i, product = 0, n = this.data.length;
    if (n !== V.length) { return null; }
    while (n--) { product += this.data[n] * V[n]; }
    return product;
  },

  dup: function() {
    return Vector.create(this.data);
  },

  eql: function(vector) {
    var n = this.data.length;
    var V = vector.data || vector;
    if (n !== V.length) { return false; }
    while (n--) {
      if (Math.abs(this.data[n] - V[n]) > Math.precision) { return false; }
    }
    return true;
  },

  forEach: function(fn, context) {
    var n = this.data.length;
    for (var i = 0; i < n; i++) {
      fn.call(context, this.data[i], i+1);
    }
  },
  
  get : function (i) { return this.data[i] },

  indexOf: function(x) {
    var index = null, n = this.data.length;
    for (var i = 0; i < n; i++) {
      if (index === null && this.data[i] === x) {
        index = i + 1;
      }
    }
    return index;
  },

  inspect: function() {
    return '[' + this.data.join(', ') + ']';
  },

  // resize vector to any new size with interpolation
  interpolate : function (newpoints) {
    // http://hevi.info/do-it-yourself/interpolating-and-array-to-fit-another-size/
    function linearInterpolate(before, after, atPoint) {
	    return before + (after - before) * atPoint;
    };
    function interpolateArray(data, fitCount) {
	    var newData = new Array();
	    var springFactor = new Number((data.length - 1) / (fitCount - 1));
	    newData[0] = data[0]; // for new allocation
	    for ( var i = 1; i < fitCount - 1; i++) {
		    var tmp = i * springFactor;
		    var before = new Number(Math.floor(tmp)).toFixed();
		    var after = new Number(Math.ceil(tmp)).toFixed();
		    var atPoint = tmp - before;
		    newData[i] = linearInterpolate(data[before], data[after], atPoint);
		    }
	    newData[fitCount - 1] = data[data.length - 1]; // for new allocation
	    return newData;
    };
    return Vector(interpolateArray(this.data,newpoints));
  },
  
  isParallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (angle <= Math.precision);
  },

  isAntiparallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (Math.abs(angle - Math.PI) <= Math.precision);
  },

  isPerpendicularTo: function(vector) {
    var dot = this.dot(vector);
    return (dot === null) ? null : (Math.abs(dot) <= Math.precision);
  },

  liesOn: function(line) {
    return line.contains(this);
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  get length () {
    return this.data.length
  },
  
  map: function(fn, context) {
    var elements = [];
    this.each(function(x, i) {
      elements.push(fn.call(context, x, i));
    });
    return Vector.create(elements);
  },

  max: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] > m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) > Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  min: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] < m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    var m = 0, i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) < Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  modulus: function() {
    return Math.sqrt(this.dot(this));
  },

  multiply: function(k) {
    return this.map(function(x) { return x*k; });
  },

  pad : function (n,v,left) {
    return Vector(this.data.pad(n,v,left));
  },

  print : function () {
    return this.data.print()
  },

  reflectionIn: function(obj) {
    if (obj.anchor) {
      // obj is a plane or line
      var P = this.data.slice();
      var C = obj.pointClosestTo(P).data;
      return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
    } else {
      // obj is a point
      var Q = obj.data || obj;
      if (this.data.length !== Q.length) { return null; }
      return this.map(function(x, i) { return Q[i-1] + (Q[i-1] - x); });
    }
  },

  rotate: function(t, obj) {
    var V, R = null, x, y, z;
    if (t.determinant) { R = t.data; }
    switch (this.data.length) {
      case 2:
        V = obj.data || obj;
        if (V.length !== 2) { return null; }
        if (!R) { R = Math.Matrix.Rotation(t).data; }
        x = this.data[0] - V[0];
        y = this.data[1] - V[1];
        return Vector.create([
          V[0] + R[0][0] * x + R[0][1] * y,
          V[1] + R[1][0] * x + R[1][1] * y
        ]);
        break;
      case 3:
        if (!obj.direction) { return null; }
        var C = obj.pointClosestTo(this).data;
        if (!R) { R = Math.Matrix.Rotation(t, obj.direction).data; }
        x = this.data[0] - C[0];
        y = this.data[1] - C[1];
        z = this.data[2] - C[2];
        return Vector.create([
          C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
          C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
          C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
        ]);
        break;
      default:
        return null;
    }
  },

  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  set : function (i,v) { return this.data[i]=v },

  setData: function(els,ref) {
    this.datatype='number';
    this.dataspace=[els.length];
    if (ref) { this.data=(els.data || els); return this};
    this.data = (els.data || els).slice();
    return this;
  },
  
  snapTo: function(x) {
    return this.map(function(y) {
      return (Math.abs(y - x) <= Math.precision) ? x : y;
    });
  },

  subtract: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x - V[i-1]; });
  },

  toArray : function () { return this.data },

  to3D: function() {
    var V = this.dup();
    switch (V.data.length) {
      case 3: break;
      case 2: V.data.push(0); break;
      default: return null;
    }
    return V;
  },

  toDiagonalMatrix: function() {
    return Math.Matrix.Diagonal(this.data);
  },

  toUnitVector: function() {
    var r = this.modulus();
    if (r === 0) { return this.dup(); }
    return this.map(function(x) { return x/r; });
  },


};

Vector.prototype.x = Vector.prototype.multiply;
Vector.prototype.each = Vector.prototype.forEach;
Vector.prototype.sample = function (frag,filter) { return Vector(this.data.sample(frag,filter)) };

Vector.i = Vector.create([1,0,0]);
Vector.j = Vector.create([0,1,0]);
Vector.k = Vector.create([0,0,1]);

module.exports = Vector;
};
BundleModuleCode['plugins/math/line']=function (module,exports){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 

var Line = function(anchor, direction) {
  if (!(this instanceof Line)) return new Line(anchor, direction);
  this.setVectors(anchor, direction);
};

Line.prototype = {
  eql: function(line) {
    return (this.isParallelTo(line) && this.contains(line.anchor));
  },

  dup: function() {
    return Line.create(this.anchor, this.direction);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Line.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.direction);
  },

  isParallelTo: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }
    var theta = this.direction.angleFrom(obj.direction);
    return (Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    if (obj.direction) {
      // obj is a line
      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }
      var N = this.direction.cross(obj.direction).toUnitVector().data;
      var A = this.anchor.data, B = obj.anchor.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, D = this.direction.data;
      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
      if (modPA === 0) return 0;
      // Assumes direction vector is normalized
      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
      var sin2 = 1 - cosTheta*cosTheta;
      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
    }
  },

  contains: function(obj) {
    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }
    var dist = this.distanceFrom(obj);
    return (dist !== null && dist <= Math.precision);
  },

  positionOf: function(point) {
    if (!this.contains(point)) { return null; }
    var P = point.data || point;
    var A = this.anchor.data, D = this.direction.data;
    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  intersects: function(obj) {
    if (obj.normal) { return obj.intersects(this); }
    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Math.precision);
  },

  intersectionWith: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }
    if (!this.intersects(obj)) { return null; }
    var P = this.anchor.data, X = this.direction.data,
        Q = obj.anchor.data, Y = obj.direction.data;
    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
    var XdotX = X1*X1 + X2*X2 + X3*X3;
    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
  },

  pointClosestTo: function(obj) {
    if (obj.start && obj.end) {
      // obj is a line segment
      var P = obj.pointClosestTo(this);
      return (P === null) ? null : this.pointClosestTo(P);
    } else if (obj.direction) {
      // obj is a line
      if (this.intersects(obj)) { return this.intersectionWith(obj); }
      if (this.isParallelTo(obj)) { return null; }
      var D = this.direction.data, E = obj.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
      // Create plane containing obj and the shared normal and intersect this
      // with it Thank you:
      // http://www.cgafaq.info/wiki/Line-line_distance
      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];
      var P = Math.Plane.create(obj.anchor, N);
      return P.intersectionWith(this);
    } else {
      // obj is a point
      var P = obj.data || obj;
      if (this.contains(P)) { return Vector.create(P); }
      var A = this.anchor.data, D = this.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
      var k = this.distanceFrom(P) / V.modulus();
      return Vector.create([
        P[0] + V.data[0] * k,
        P[1] + V.data[1] * k,
        (P[2] || 0) + V.data[2] * k
      ]);
    }
  },

  // Returns a copy of the line rotated by t radians about the given line. Works
  // by finding the argument's closest point to this line's anchor point (call
  // this C) and rotating the anchor about C. Also rotates the line's direction
  // about the argument's. Be careful with this - the rotation axis' direction
  // affects the outcome!
  rotate: function(t, line) {
    // If we're working in 2D
    if (typeof(line.direction) === 'undefined') { line = Line.create(line.to3D(), Vector.k); }
    var R = Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, D = this.direction.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Line.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
    ]);
  },

  reverse: function() {
    return Line.create(this.anchor, this.direction.x(-1));
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, D = this.direction.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the line's direction vector to its anchor, then mirror that in the plane
      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
      var Q = obj.pointClosestTo([AD1, AD2, AD3]).data;
      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
      return Line.create(newA, newD);
    } else if (obj.direction) {
      // obj is a line - reflection obtained by rotating PI radians about obj
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point - just reflect the line's anchor in it
      var P = obj.data || obj;
      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
    }
  },

  setVectors: function(anchor, direction) {
    // Need to do this so that line's properties are not references to the
    // arguments passed in
    anchor = Vector.create(anchor);
    direction = Vector.create(direction);
    if (anchor.data.length === 2) {anchor.data.push(0); }
    if (direction.data.length === 2) { direction.data.push(0); }
    if (anchor.data.length > 3 || direction.data.length > 3) { return null; }
    var mod = direction.modulus();
    if (mod === 0) { return null; }
    this.anchor = anchor;
    this.direction = Vector.create([
      direction.data[0] / mod,
      direction.data[1] / mod,
      direction.data[2] / mod
    ]);
    return this;
  }
};

Line.create = Line;

Line.X = Line.create(Vector.Zero(3), Vector.i);
Line.Y = Line.create(Vector.Zero(3), Vector.j);
Line.Z = Line.create(Vector.Zero(3), Vector.k);


module.exports = Line;
};
BundleModuleCode['plugins/math/plane']=function (module,exports){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 
var Line   = Require('plugins/math/line') 

var Plane = function(anchor, v1, v2) {
  if (!(this instanceof Plane)) return  new Plane(anchor, v1, v2);
  this.setVectors(anchor, v1, v2);
};

Plane.prototype = {
  eql: function(plane) {
    return (this.contains(plane.anchor) && this.isParallelTo(plane));
  },

  dup: function() {
    return Plane.create(this.anchor, this.normal);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Plane.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.normal);
  },

  isParallelTo: function(obj) {
    var theta;
    if (obj.normal) {
      // obj is a plane
      theta = this.normal.angleFrom(obj.normal);
      return (Math.abs(theta) <= Math.precision || Math.abs(Math.PI - theta) <= Math.precision);
    } else if (obj.direction) {
      // obj is a line
      return this.normal.isPerpendicularTo(obj.direction);
    }
    return null;
  },

  isPerpendicularTo: function(plane) {
    var theta = this.normal.angleFrom(plane.normal);
    return (Math.abs(Math.PI/2 - theta) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (this.intersects(obj) || this.contains(obj)) { return 0; }
    if (obj.anchor) {
      // obj is a plane or line
      var A = this.anchor.data, B = obj.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
    }
  },

  contains: function(obj) {
    if (obj.normal) { return null; }
    if (obj.direction) {
      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));
    } else {
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
      return (diff <= Math.precision);
    }
  },

  intersects: function(obj) {
    if (typeof(obj.direction) === 'undefined' && typeof(obj.normal) === 'undefined') { return null; }
    return !this.isParallelTo(obj);
  },

  intersectionWith: function(obj) {
    if (!this.intersects(obj)) { return null; }
    if (obj.direction) {
      // obj is a line
      var A = obj.anchor.data, D = obj.direction.data,
          P = this.anchor.data, N = this.normal.data;
      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);
    } else if (obj.normal) {
      // obj is a plane
      var direction = this.normal.cross(obj.normal).toUnitVector();
      // To find an anchor point, we find one co-ordinate that has a value of
      // zero somewhere on the intersection, and remember which one we picked
      var N = this.normal.data, A = this.anchor.data,
          O = obj.normal.data, B = obj.anchor.data;
      var solver = Matrix.Zero(2,2), i = 0;
      while (solver.isSingular()) {
        i++;
        solver = Matrix.create([
          [ N[i%3], N[(i+1)%3] ],
          [ O[i%3], O[(i+1)%3]  ]
        ]);
      }
      // Then we solve the simultaneous equations in the remaining dimensions
      var inverse = solver.inverse().data;
      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
      var intersection = [
        inverse[0][0] * x + inverse[0][1] * y,
        inverse[1][0] * x + inverse[1][1] * y
      ];
      var anchor = [];
      for (var j = 1; j <= 3; j++) {
        // This formula picks the right element from intersection by cycling
        // depending on which element we set to zero above
        anchor.push((i === j) ? 0 : intersection[(j + (5 - i)%3)%3]);
      }
      return Line.create(anchor, direction);
    }
  },

  pointClosestTo: function(point) {
    var P = point.data || point;
    var A = this.anchor.data, N = this.normal.data;
    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
  },

  rotate: function(t, line) {
    var R = t.determinant ? t.data : Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, N = this.normal.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Plane.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
    ]);
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, N = this.normal.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the plane's normal to its anchor, then mirror that in the other plane
      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
      var Q = obj.pointClosestTo([AN1, AN2, AN3]).data;
      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
      return Plane.create(newA, newN);
    } else if (obj.direction) {
      // obj is a line
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point
      var P = obj.data || obj;
      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
    }
  },

  setVectors: function(anchor, v1, v2) {
    anchor = Vector.create(anchor);
    anchor = anchor.to3D(); if (anchor === null) { return null; }
    v1 = Vector.create(v1);
    v1 = v1.to3D(); if (v1 === null) { return null; }
    if (typeof(v2) === 'undefined') {
      v2 = null;
    } else {
      v2 = Vector.create(v2);
      v2 = v2.to3D(); if (v2 === null) { return null; }
    }
    var A1 = anchor.data[0], A2 = anchor.data[1], A3 = anchor.data[2];
    var v11 = v1.data[0], v12 = v1.data[1], v13 = v1.data[2];
    var normal, mod;
    if (v2 !== null) {
      var v21 = v2.data[0], v22 = v2.data[1], v23 = v2.data[2];
      normal = Vector.create([
        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
      ]);
      mod = normal.modulus();
      if (mod === 0) { return null; }
      normal = Vector.create([normal.data[0] / mod, normal.data[1] / mod, normal.data[2] / mod]);
    } else {
      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
      if (mod === 0) { return null; }
      normal = Vector.create([v1.data[0] / mod, v1.data[1] / mod, v1.data[2] / mod]);
    }
    this.anchor = anchor;
    this.normal = normal;
    return this;
  }
};

Plane.create = Plane


Plane.XY = Plane.create(Vector.Zero(3), Vector.k);
Plane.YZ = Plane.create(Vector.Zero(3), Vector.i);
Plane.ZX = Plane.create(Vector.Zero(3), Vector.j);
Plane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;

Plane.fromPoints = function(points) {
  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);
  for (i = 0; i < np; i++) {
    P = Vector.create(points[i]).to3D();
    if (P === null) { return null; }
    list.push(P);
    n = list.length;
    if (n > 2) {
      // Compute plane normal for the latest three points
      A = list[n-1].data; B = list[n-2].data; C = list[n-3].data;
      N = Vector.create([
        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
      ]).toUnitVector();
      if (n > 3) {
        // If the latest normal is not (anti)parallel to the previous one, we've
        // strayed off the plane. This might be a slightly long-winded way of
        // doing things, but we need the sum of all the normals to find which
        // way the plane normal should point so that the points form an
        // anticlockwise list.
        theta = N.angleFrom(prevN);
        if (theta !== null) {
          if (!(Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision)) { return null; }
        }
      }
      totalN = totalN.add(N);
      prevN = N;
    }
  }
  // We need to add in the normals at the start and end points, which the above
  // misses out
  A = list[1].data; B = list[0].data; C = list[n-1].data; D = list[n-2].data;
  totalN = totalN.add(Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).toUnitVector()).add(Vector.create([
    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),
    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),
    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])
  ]).toUnitVector());
  return Plane.create(list[0], totalN);
};
};
BundleModuleCode['plugins/math/stats']=function (module,exports){
// https://github.com/simple-statistics/simple-statistics
// Version 1.3.2

'use strict';

var exports = module.exports;
function log2(n) {
  return Math.log(n) / Math.log(2);
}

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0,
            sumY = 0,
            sumXX = 0,
            sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    } else if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0],
        // store the mode as we find new modes
        value = NaN,
        // store how many times we've seen the mode
        maxSeen = 0,
        // how many times the current candidate for the mode
        // has been seen
        seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(nlog(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, min is
        // undefined and is thus made the minimum element in the array
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, max is
        // undefined and is thus made the maximum element in the array
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    // The mad of nothing is null
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // chose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample.slice(), randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0,
        lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix.length - 1) {
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "geometricMean requires only positive numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.2174396181152126432e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Infinity;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    "1": {
        "0.995": 0,
        "0.99": 0,
        "0.975": 0,
        "0.95": 0,
        "0.9": 0.02,
        "0.5": 0.45,
        "0.1": 2.71,
        "0.05": 3.84,
        "0.025": 5.02,
        "0.01": 6.63,
        "0.005": 7.88
    },
    "2": {
        "0.995": 0.01,
        "0.99": 0.02,
        "0.975": 0.05,
        "0.95": 0.1,
        "0.9": 0.21,
        "0.5": 1.39,
        "0.1": 4.61,
        "0.05": 5.99,
        "0.025": 7.38,
        "0.01": 9.21,
        "0.005": 10.6
    },
    "3": {
        "0.995": 0.07,
        "0.99": 0.11,
        "0.975": 0.22,
        "0.95": 0.35,
        "0.9": 0.58,
        "0.5": 2.37,
        "0.1": 6.25,
        "0.05": 7.81,
        "0.025": 9.35,
        "0.01": 11.34,
        "0.005": 12.84
    },
    "4": {
        "0.995": 0.21,
        "0.99": 0.3,
        "0.975": 0.48,
        "0.95": 0.71,
        "0.9": 1.06,
        "0.5": 3.36,
        "0.1": 7.78,
        "0.05": 9.49,
        "0.025": 11.14,
        "0.01": 13.28,
        "0.005": 14.86
    },
    "5": {
        "0.995": 0.41,
        "0.99": 0.55,
        "0.975": 0.83,
        "0.95": 1.15,
        "0.9": 1.61,
        "0.5": 4.35,
        "0.1": 9.24,
        "0.05": 11.07,
        "0.025": 12.83,
        "0.01": 15.09,
        "0.005": 16.75
    },
    "6": {
        "0.995": 0.68,
        "0.99": 0.87,
        "0.975": 1.24,
        "0.95": 1.64,
        "0.9": 2.2,
        "0.5": 5.35,
        "0.1": 10.65,
        "0.05": 12.59,
        "0.025": 14.45,
        "0.01": 16.81,
        "0.005": 18.55
    },
    "7": {
        "0.995": 0.99,
        "0.99": 1.25,
        "0.975": 1.69,
        "0.95": 2.17,
        "0.9": 2.83,
        "0.5": 6.35,
        "0.1": 12.02,
        "0.05": 14.07,
        "0.025": 16.01,
        "0.01": 18.48,
        "0.005": 20.28
    },
    "8": {
        "0.995": 1.34,
        "0.99": 1.65,
        "0.975": 2.18,
        "0.95": 2.73,
        "0.9": 3.49,
        "0.5": 7.34,
        "0.1": 13.36,
        "0.05": 15.51,
        "0.025": 17.53,
        "0.01": 20.09,
        "0.005": 21.96
    },
    "9": {
        "0.995": 1.73,
        "0.99": 2.09,
        "0.975": 2.7,
        "0.95": 3.33,
        "0.9": 4.17,
        "0.5": 8.34,
        "0.1": 14.68,
        "0.05": 16.92,
        "0.025": 19.02,
        "0.01": 21.67,
        "0.005": 23.59
    },
    "10": {
        "0.995": 2.16,
        "0.99": 2.56,
        "0.975": 3.25,
        "0.95": 3.94,
        "0.9": 4.87,
        "0.5": 9.34,
        "0.1": 15.99,
        "0.05": 18.31,
        "0.025": 20.48,
        "0.01": 23.21,
        "0.005": 25.19
    },
    "11": {
        "0.995": 2.6,
        "0.99": 3.05,
        "0.975": 3.82,
        "0.95": 4.57,
        "0.9": 5.58,
        "0.5": 10.34,
        "0.1": 17.28,
        "0.05": 19.68,
        "0.025": 21.92,
        "0.01": 24.72,
        "0.005": 26.76
    },
    "12": {
        "0.995": 3.07,
        "0.99": 3.57,
        "0.975": 4.4,
        "0.95": 5.23,
        "0.9": 6.3,
        "0.5": 11.34,
        "0.1": 18.55,
        "0.05": 21.03,
        "0.025": 23.34,
        "0.01": 26.22,
        "0.005": 28.3
    },
    "13": {
        "0.995": 3.57,
        "0.99": 4.11,
        "0.975": 5.01,
        "0.95": 5.89,
        "0.9": 7.04,
        "0.5": 12.34,
        "0.1": 19.81,
        "0.05": 22.36,
        "0.025": 24.74,
        "0.01": 27.69,
        "0.005": 29.82
    },
    "14": {
        "0.995": 4.07,
        "0.99": 4.66,
        "0.975": 5.63,
        "0.95": 6.57,
        "0.9": 7.79,
        "0.5": 13.34,
        "0.1": 21.06,
        "0.05": 23.68,
        "0.025": 26.12,
        "0.01": 29.14,
        "0.005": 31.32
    },
    "15": {
        "0.995": 4.6,
        "0.99": 5.23,
        "0.975": 6.27,
        "0.95": 7.26,
        "0.9": 8.55,
        "0.5": 14.34,
        "0.1": 22.31,
        "0.05": 25,
        "0.025": 27.49,
        "0.01": 30.58,
        "0.005": 32.8
    },
    "16": {
        "0.995": 5.14,
        "0.99": 5.81,
        "0.975": 6.91,
        "0.95": 7.96,
        "0.9": 9.31,
        "0.5": 15.34,
        "0.1": 23.54,
        "0.05": 26.3,
        "0.025": 28.85,
        "0.01": 32,
        "0.005": 34.27
    },
    "17": {
        "0.995": 5.7,
        "0.99": 6.41,
        "0.975": 7.56,
        "0.95": 8.67,
        "0.9": 10.09,
        "0.5": 16.34,
        "0.1": 24.77,
        "0.05": 27.59,
        "0.025": 30.19,
        "0.01": 33.41,
        "0.005": 35.72
    },
    "18": {
        "0.995": 6.26,
        "0.99": 7.01,
        "0.975": 8.23,
        "0.95": 9.39,
        "0.9": 10.87,
        "0.5": 17.34,
        "0.1": 25.99,
        "0.05": 28.87,
        "0.025": 31.53,
        "0.01": 34.81,
        "0.005": 37.16
    },
    "19": {
        "0.995": 6.84,
        "0.99": 7.63,
        "0.975": 8.91,
        "0.95": 10.12,
        "0.9": 11.65,
        "0.5": 18.34,
        "0.1": 27.2,
        "0.05": 30.14,
        "0.025": 32.85,
        "0.01": 36.19,
        "0.005": 38.58
    },
    "20": {
        "0.995": 7.43,
        "0.99": 8.26,
        "0.975": 9.59,
        "0.95": 10.85,
        "0.9": 12.44,
        "0.5": 19.34,
        "0.1": 28.41,
        "0.05": 31.41,
        "0.025": 34.17,
        "0.01": 37.57,
        "0.005": 40
    },
    "21": {
        "0.995": 8.03,
        "0.99": 8.9,
        "0.975": 10.28,
        "0.95": 11.59,
        "0.9": 13.24,
        "0.5": 20.34,
        "0.1": 29.62,
        "0.05": 32.67,
        "0.025": 35.48,
        "0.01": 38.93,
        "0.005": 41.4
    },
    "22": {
        "0.995": 8.64,
        "0.99": 9.54,
        "0.975": 10.98,
        "0.95": 12.34,
        "0.9": 14.04,
        "0.5": 21.34,
        "0.1": 30.81,
        "0.05": 33.92,
        "0.025": 36.78,
        "0.01": 40.29,
        "0.005": 42.8
    },
    "23": {
        "0.995": 9.26,
        "0.99": 10.2,
        "0.975": 11.69,
        "0.95": 13.09,
        "0.9": 14.85,
        "0.5": 22.34,
        "0.1": 32.01,
        "0.05": 35.17,
        "0.025": 38.08,
        "0.01": 41.64,
        "0.005": 44.18
    },
    "24": {
        "0.995": 9.89,
        "0.99": 10.86,
        "0.975": 12.4,
        "0.95": 13.85,
        "0.9": 15.66,
        "0.5": 23.34,
        "0.1": 33.2,
        "0.05": 36.42,
        "0.025": 39.36,
        "0.01": 42.98,
        "0.005": 45.56
    },
    "25": {
        "0.995": 10.52,
        "0.99": 11.52,
        "0.975": 13.12,
        "0.95": 14.61,
        "0.9": 16.47,
        "0.5": 24.34,
        "0.1": 34.28,
        "0.05": 37.65,
        "0.025": 40.65,
        "0.01": 44.31,
        "0.005": 46.93
    },
    "26": {
        "0.995": 11.16,
        "0.99": 12.2,
        "0.975": 13.84,
        "0.95": 15.38,
        "0.9": 17.29,
        "0.5": 25.34,
        "0.1": 35.56,
        "0.05": 38.89,
        "0.025": 41.92,
        "0.01": 45.64,
        "0.005": 48.29
    },
    "27": {
        "0.995": 11.81,
        "0.99": 12.88,
        "0.975": 14.57,
        "0.95": 16.15,
        "0.9": 18.11,
        "0.5": 26.34,
        "0.1": 36.74,
        "0.05": 40.11,
        "0.025": 43.19,
        "0.01": 46.96,
        "0.005": 49.65
    },
    "28": {
        "0.995": 12.46,
        "0.99": 13.57,
        "0.975": 15.31,
        "0.95": 16.93,
        "0.9": 18.94,
        "0.5": 27.34,
        "0.1": 37.92,
        "0.05": 41.34,
        "0.025": 44.46,
        "0.01": 48.28,
        "0.005": 50.99
    },
    "29": {
        "0.995": 13.12,
        "0.99": 14.26,
        "0.975": 16.05,
        "0.95": 17.71,
        "0.9": 19.77,
        "0.5": 28.34,
        "0.1": 39.09,
        "0.05": 42.56,
        "0.025": 45.72,
        "0.01": 49.59,
        "0.005": 52.34
    },
    "30": {
        "0.995": 13.79,
        "0.99": 14.95,
        "0.975": 16.79,
        "0.95": 18.49,
        "0.9": 20.6,
        "0.5": 29.34,
        "0.1": 40.26,
        "0.05": 43.77,
        "0.025": 46.98,
        "0.01": 50.89,
        "0.005": 53.67
    },
    "40": {
        "0.995": 20.71,
        "0.99": 22.16,
        "0.975": 24.43,
        "0.95": 26.51,
        "0.9": 29.05,
        "0.5": 39.34,
        "0.1": 51.81,
        "0.05": 55.76,
        "0.025": 59.34,
        "0.01": 63.69,
        "0.005": 66.77
    },
    "50": {
        "0.995": 27.99,
        "0.99": 29.71,
        "0.975": 32.36,
        "0.95": 34.76,
        "0.9": 37.69,
        "0.5": 49.33,
        "0.1": 63.17,
        "0.05": 67.5,
        "0.025": 71.42,
        "0.01": 76.15,
        "0.005": 79.49
    },
    "60": {
        "0.995": 35.53,
        "0.99": 37.48,
        "0.975": 40.48,
        "0.95": 43.19,
        "0.9": 46.46,
        "0.5": 59.33,
        "0.1": 74.4,
        "0.05": 79.08,
        "0.025": 83.3,
        "0.01": 88.38,
        "0.005": 91.95
    },
    "70": {
        "0.995": 43.28,
        "0.99": 45.44,
        "0.975": 48.76,
        "0.95": 51.74,
        "0.9": 55.33,
        "0.5": 69.33,
        "0.1": 85.53,
        "0.05": 90.53,
        "0.025": 95.02,
        "0.01": 100.42,
        "0.005": 104.22
    },
    "80": {
        "0.995": 51.17,
        "0.99": 53.54,
        "0.975": 57.15,
        "0.95": 60.39,
        "0.9": 64.28,
        "0.5": 79.33,
        "0.1": 96.58,
        "0.05": 101.88,
        "0.025": 106.63,
        "0.01": 112.33,
        "0.005": 116.32
    },
    "90": {
        "0.995": 59.2,
        "0.99": 61.75,
        "0.975": 65.65,
        "0.95": 69.13,
        "0.9": 73.29,
        "0.5": 89.33,
        "0.1": 107.57,
        "0.05": 113.14,
        "0.025": 118.14,
        "0.01": 124.12,
        "0.005": 128.3
    },
    "100": {
        "0.995": 67.33,
        "0.99": 70.06,
        "0.975": 74.22,
        "0.95": 77.93,
        "0.9": 82.36,
        "0.5": 99.33,
        "0.1": 118.5,
        "0.05": 124.34,
        "0.025": 129.56,
        "0.01": 135.81,
        "0.005": 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z,
        tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI$1) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the cumulative distribution function of the normal distribution.
 * It is used to find the probability that a statistic is observed below,
 * above, or between values on the standard normal distribution, and by
 * extension, any normal distribution.
 *
 * The probabilities are calculated using the
 * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).
 * The table used is the cumulative, and not cumulative from 0 to mean
 * (even though the latter has 5 digits precision, instead of 4).
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return +(1 - standardNormalTable[index]).toFixed(4);
    }
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'"
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}


// More statistics: enrtopy ...

// Finds element with highest occurrence in a list
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;
  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}
exports.mostCommon = mostCommon;

// Probe for a value
function probe(value, list) {
  var occurrences = list.filter(function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probe = probe;
/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probeEps(value, list, eps) {
  var occurrences = list.filter(function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probeEps = probeEps;


exports.unique = function (list) { return list.unique() };
function uniqueSorted (array) {
  var set = array.unique().sort(function (a,b) { return a<b?-1:1 });
  return set;
}
function uniqueEps(array,eps) {
  var result=[];
  array.forEach(function (x) {
    var found;
    if (!result.length) result.push(x);
    else {
      result.forEach(function (y) {
        if (found) return;
        found = Math.abs(x-y)<=eps;
      }); 
      if (!found) result.push(x);
    }
  });
  return result;
}
exports.uniqueEps = uniqueEps;

// Entropy of data vectors
function entropy(vals) {
  var uniqueVals = vals.unique();
  var probs = uniqueVals.map(function(x) {
    return probe(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropy = entropy;

function entropyEps(vals,eps) {
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probeEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropyEps = entropyEps;

// Entropy of target variable partitioned feature vector
function entropyT(data,featureIndex,targetIndex,targets) {
  var en = 0;
  var col =  pluck(data,featureIndex);
  var uniqueVals = unique(col);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2==v) cn++,frac[targets.indexOf(data[row][targetIndex])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyT = entropyT;

function entropyTEps(data,feature,target,targets,eps) {
  var en = 0;
  var col =  pluck(data,feature);
  var uniqueVals = uniqueEps(col,eps);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2>=v-eps && v2<=v+eps) cn++,frac[targets.indexOf(data[row][target])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyTEps = entropyTEps;


function gainEps(data,feature,target,targets,eps) {
  var et = entropy(data.pluck(target));
  return et/entropyTEps(data,feature,target,targets,eps)
}


function maxGainEps(data,features,target,targets,eps) {
  var maxgain=max(features, function(feature,index) {
    var g = gainEps(data,feature,target,targets,selectEps(eps,index));
    return g;
  });
  return maxgain;
}

function distribution (table) {
  var d={};
  table.forEach(function (row) {
    if (Utils.isArray(row)) row.forEach(function (v) { 
      if (d[v]==undefined) d[v]=1; else d[v]++ });
    else { if (d[row]==undefined) d[row]=1; else d[row]++ };
  })
  return d;
}
function histogram (vector,delta,min,max) {
  if (min==undefined) min=vector.min();
  if (max==undefined) max=vector.max();
  var n = Math.ceil((max-min)/delta);
  var h = Array.init(n);
  for(var i=0;i<vector.length;i++) {
    var chan=Math.floor((vector[i]-min)/delta);
    h[chan]++;
  }
  return h;
}

function smN (vector,N) {
  var xm=vector.sum()/vector.length;
  return vector.map(function (x) { return Math.pow(x-xm,N) }).sum() 
}
function nans(vector) {
  var n=0; for(var i in vector) if (isNaN(vector[i])) n++;
  return n
}
function zeros(vector) {
  var n=0; for(var i in vector) if (vector[i]==0) n++;
  return n
}
exports.BayesianClassifier = BayesianClassifier;
exports.PerceptronModel = PerceptronModel;
exports.addToMean = addToMean;
exports.average = mean;
exports.averageSimple = meanSimple;
exports.bayesian = BayesianClassifier;
exports.bernoulliDistribution = bernoulliDistribution;
exports.binomialDistribution = binomialDistribution;
exports.bisect = bisect;
exports.chiSquaredDistributionTable = chiSquaredDistributionTable;
exports.chiSquaredGoodnessOfFit = chiSquaredGoodnessOfFit;
exports.chunk = chunk;
exports.ckmeans = ckmeans;
exports.combinations = combinations;
exports.combinationsReplacement = combinationsReplacement;
exports.combineMeans = combineMeans;
exports.combineVariances = combineVariances;
exports.cumulativeStdNormalProbability = cumulativeStdNormalProbability;
exports.distribution = distribution;
exports.epsilon = epsilon;
exports.equalIntervalBreaks = equalIntervalBreaks;
exports.erf = errorFunction;
exports.errorFunction = errorFunction;
exports.extent = extent;
exports.extentSorted = extentSorted;
exports.factorial = factorial;
exports.gamma = gamma;
exports.gammaln = gammaln;
exports.geometricMean = geometricMean;
exports.harmonicMean = harmonicMean;
exports.histogram = histogram;
exports.interquartileRange = interquartileRange;
exports.inverseErrorFunction = inverseErrorFunction;
exports.iqr = interquartileRange;
exports.kde = kernelDensityEstimation;
exports.kernelDensityEstimation = kernelDensityEstimation;
exports.linearRegression = linearRegression;
exports.linearRegressionLine = linearRegressionLine;
exports.mad = medianAbsoluteDeviation;
exports.max = max;
exports.maxSorted = maxSorted;
exports.mean = mean;
exports.meanSimple = meanSimple;
exports.median = median;
exports.medianAbsoluteDeviation = medianAbsoluteDeviation;
exports.medianSorted = medianSorted;
exports.min = min;
exports.minSorted = minSorted;
exports.mode = mode;
exports.modeFast = modeFast;
exports.modeSorted = modeSorted;
exports.nans = nans;
exports.numericSort = numericSort;
exports.perceptron = PerceptronModel;
exports.permutationTest = permutationTest;
exports.permutationsHeap = permutationsHeap;
exports.poissonDistribution = poissonDistribution;
exports.probit = probit;
exports.product = product;
exports.quantile = quantile;
exports.quantileRank = quantileRank;
exports.quantileRankSorted = quantileRankSorted;
exports.quantileSorted = quantileSorted;
exports.quickselect = quickselect;
exports.rSquared = rSquared;
exports.rms = rootMeanSquare;
exports.rootMeanSquare = rootMeanSquare;
exports.sample = sample;
exports.sampleCorrelation = sampleCorrelation;
exports.sampleCovariance = sampleCovariance;
exports.sampleKurtosis = sampleKurtosis;
exports.sampleSkewness = sampleSkewness;
exports.sampleStandardDeviation = sampleStandardDeviation;
exports.sampleVariance = sampleVariance;
exports.sampleWithReplacement = sampleWithReplacement;
exports.shuffle = shuffle;
exports.shuffleInPlace = shuffleInPlace;
exports.sign = sign;
exports.standardDeviation = standardDeviation;
exports.standardNormalTable = standardNormalTable;
exports.subtractFromMean = subtractFromMean;
exports.sm2 = function (v) { return smN(v,2) };
exports.sm3 = function (v) { return smN(v,3) };
exports.sm4 = function (v) { return smN(v,4) };
exports.sum = sum;
exports.sumNthPowerDeviations = sumNthPowerDeviations;
exports.sumSimple = sumSimple;
exports.tTest = tTest;
exports.tTestTwoSample = tTestTwoSample;
exports.uniqueCountSorted = uniqueCountSorted;
exports.uniqueSorted = uniqueSorted;
exports.variance = variance;
exports.zeros = zeros;
exports.zScore = zScore;


// Full statistical analysis of a data set
function analysis (data,options) {
  var i,numeric,column;
  options=options||{};
  function analize(column,options) {
    var numeric=options.numeric;
    if (numeric == undefined) {
        numeric = column.filter(function (row) {
        return isNaN(Number(row))
      }).length==0; 
    }
    if (numeric) {
      var sm2=smN(column,2),sm3=smN(column,3),
          sm4=smN(column,4),n = column.length;;
      return {
        covariance : sampleCovariance(column,column),
        kurtosis : n*sm4/(sm2*sm2),
        mean    : mean(column),
        median  : median(column),
        medianAbsoluteDeviation:medianAbsoluteDeviation(column),
        min     : min(column),
        max     : max(column),
        n       : n,
        nan     : nans(column),
        rootMeanSquare:rootMeanSquare(column),
        skewness : Math.sqrt(n)*sm3/(sm2*Math.sqrt(sm2)),
        sm2     : sm2,
        sm3     : sm3,
        sm4     : sm4,
        standardDeviation:standardDeviation(column),
        sum     : sum(column),
        uniqueCountSorted:uniqueCountSorted(column),
        variance:variance(column),
        zeros   : zeros(column),
      }
    } else {
      return {
        distribution:distribution(column),
        entropy:entropy(column),
        mostCommon:mostCommon(column),
        unique:uniqueSorted(column),
      }
    }
  }
  if (Utils.isMatrix(data)) {
    return data[0].map(function (x,i) {
      return analize(data.pluck(i),{
        numeric:typeof options.numeric == 'boolean'?options.numeric:
                (Utils.isArray(options.numeric)?options.numeric[i]:undefined)
      });
    })
  } else
    return analize(data,options); // todo: matrix
}
exports.analysis = analysis;

};
BundleModuleCode['plugins/math/dwt5']=function (module,exports){
/* https://github.com/Symmetronic/discrete-wavelets */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.wt = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /**
     * Antisymmetric padding.
     */
    var ANTISYMMETRIC_PADDING = 'antisymmetric';
    /**
     * Returns a single value of antisymmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function antisymmetricPadding$$1(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        var dirChanges = Math.floor(index / data.length);
        var sign = (dirChanges % 2 === 0) ? -1 : 1;
        return sign * symmetricPadding(data, index, inverse);
    }

    /**
     * Constant padding.
     */
    var CONSTANT_PADDING = 'constant';
    /**
     * Returns a single value of constant padding.
     * @param  data    Input values.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function constantPadding(data, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine constant padding for data of zero length.');
        }
        /* Determine constant padding. */
        return (!inverse)
            ? data[data.length - 1]
            : data[0];
    }

    /**
     * Periodic padding.
     */
    var PERIODIC_PADDING = 'periodic';
    /**
     * Returns a single value of periodic padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function periodicPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine periodic padding for data of zero length.');
        }
        /* Determine periodic padding. */
        return (!inverse)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Reflect padding.
     */
    var REFLECT_PADDING = 'reflect';
    /**
     * Returns a single value of reflect padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function reflectPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine reflect padding for data of zero length.');
        }
        /* Return constant value for data of length one. */
        if (data.length === 1)
            return data[0];
        /* Determine reflect padding. */
        var dirChanges = Math.floor(index / (data.length - 1));
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % (data.length - 1) + 1]
            : data[data.length - 2 - (index % (data.length - 1))];
    }

    /**
     * Smooth padding.
     */
    var SMOOTH_PADDING = 'smooth';
    /**
     * Returns a single value of smooth padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function smoothPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine smooth padding for data of zero length.');
        }
        /* Determine line equation. */
        var end = data.length - 1;
        var offset = (inverse) ? data[0] : data[end];
        var slope = (inverse)
            ? (data.length === 1) ? data[0] : data[0] - data[1]
            : (data.length === 1) ? -data[0] : data[end] - data[end - 1];
        return offset + (index + 1) * slope;
    }

    /**
     * Symmetric padding.
     */
    var SYMMETRIC_PADDING = 'symmetric';
    /**
     * Returns a single value of symmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function symmetricPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine symmetric padding for data of zero length.');
        }
        /* Determine symmetric padding. */
        var dirChanges = Math.floor(index / data.length);
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Zero padding.
     */
    var ZERO_PADDING = 'zero';
    /**
     * Returns a single value of zero padding.
     * @return         Single padding value.
     */
    function zeroPadding() {
        return 0;
    }

    /**
     * Supported signal extension modes.
     */
    var PADDING_MODES = {
        antisymmetric: ANTISYMMETRIC_PADDING,
        constant: CONSTANT_PADDING,
        periodic: PERIODIC_PADDING,
        reflect: REFLECT_PADDING,
        smooth: SMOOTH_PADDING,
        symmetric: SYMMETRIC_PADDING,
        zero: ZERO_PADDING,
        modes: [
            ZERO_PADDING,
            CONSTANT_PADDING,
            SYMMETRIC_PADDING,
            PERIODIC_PADDING,
            SMOOTH_PADDING,
            REFLECT_PADDING,
            ANTISYMMETRIC_PADDING,
        ],
    };

    // SOURCE: https://github.com/PyWavelets/pywt/blob/master/pywt/_extensions/c/wavelets_coeffs.template.h
    /**
     * Haar wavelet scaling numbers.
     */
    var HaarWavelet = [
        1 / Math.SQRT2,
        1 / Math.SQRT2
    ];
    /**
     * Daubechies 2 scaling numbers.
     */
    var Db2Wavelet = [
        (1 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 - Math.sqrt(3)) / (4 * Math.SQRT2),
        (1 - Math.sqrt(3)) / (4 * Math.SQRT2)
    ];
    /**
     * Daubechies 3 scaling numbers.
     */
    var Db3Wavelet = [
        3.326705529500826159985115891390056300129233992450683597084705e-01,
        8.068915093110925764944936040887134905192973949948236181650920e-01,
        4.598775021184915700951519421476167208081101774314923066433867e-01,
        -1.350110200102545886963899066993744805622198452237811919756862e-01,
        -8.544127388202666169281916918177331153619763898808662976351748e-02,
        3.522629188570953660274066471551002932775838791743161039893406e-02
    ];
    /**
     * Daubechies 4 scaling numbers.
     */
    var Db4Wavelet = [
        2.303778133088965008632911830440708500016152482483092977910968e-01,
        7.148465705529156470899219552739926037076084010993081758450110e-01,
        6.308807679298589078817163383006152202032229226771951174057473e-01,
        -2.798376941685985421141374718007538541198732022449175284003358e-02,
        -1.870348117190930840795706727890814195845441743745800912057770e-01,
        3.084138183556076362721936253495905017031482172003403341821219e-02,
        3.288301166688519973540751354924438866454194113754971259727278e-02,
        -1.059740178506903210488320852402722918109996490637641983484974e-02
    ];
    /**
     * Daubechies 5 scaling numbers.
     */
    var Db5Wavelet = [
        1.601023979741929144807237480204207336505441246250578327725699e-01,
        6.038292697971896705401193065250621075074221631016986987969283e-01,
        7.243085284377729277280712441022186407687562182320073725767335e-01,
        1.384281459013207315053971463390246973141057911739561022694652e-01,
        -2.422948870663820318625713794746163619914908080626185983913726e-01,
        -3.224486958463837464847975506213492831356498416379847225434268e-02,
        7.757149384004571352313048938860181980623099452012527983210146e-02,
        -6.241490212798274274190519112920192970763557165687607323417435e-03,
        -1.258075199908199946850973993177579294920459162609785020169232e-02,
        3.335725285473771277998183415817355747636524742305315099706428e-03
    ];
    /**
     * Daubechies 6 scaling numbers.
     */
    var Db6Wavelet = [
        1.115407433501094636213239172409234390425395919844216759082360e-01,
        4.946238903984530856772041768778555886377863828962743623531834e-01,
        7.511339080210953506789344984397316855802547833382612009730420e-01,
        3.152503517091976290859896548109263966495199235172945244404163e-01,
        -2.262646939654398200763145006609034656705401539728969940143487e-01,
        -1.297668675672619355622896058765854608452337492235814701599310e-01,
        9.750160558732304910234355253812534233983074749525514279893193e-02,
        2.752286553030572862554083950419321365738758783043454321494202e-02,
        -3.158203931748602956507908069984866905747953237314842337511464e-02,
        5.538422011614961392519183980465012206110262773864964295476524e-04,
        4.777257510945510639635975246820707050230501216581434297593254e-03,
        -1.077301085308479564852621609587200035235233609334419689818580e-03
    ];
    /**
     * Daubechies 7 scaling numbers.
     */
    var Db7Wavelet = [
        7.785205408500917901996352195789374837918305292795568438702937e-02,
        3.965393194819173065390003909368428563587151149333287401110499e-01,
        7.291320908462351199169430703392820517179660611901363782697715e-01,
        4.697822874051931224715911609744517386817913056787359532392529e-01,
        -1.439060039285649754050683622130460017952735705499084834401753e-01,
        -2.240361849938749826381404202332509644757830896773246552665095e-01,
        7.130921926683026475087657050112904822711327451412314659575113e-02,
        8.061260915108307191292248035938190585823820965629489058139218e-02,
        -3.802993693501441357959206160185803585446196938467869898283122e-02,
        -1.657454163066688065410767489170265479204504394820713705239272e-02,
        1.255099855609984061298988603418777957289474046048710038411818e-02,
        4.295779729213665211321291228197322228235350396942409742946366e-04,
        -1.801640704047490915268262912739550962585651469641090625323864e-03,
        3.537137999745202484462958363064254310959060059520040012524275e-04
    ];
    /**
     * Daubechies 8 scaling numbers.
     */
    var Db8Wavelet = [
        5.441584224310400995500940520299935503599554294733050397729280e-02,
        3.128715909142999706591623755057177219497319740370229185698712e-01,
        6.756307362972898068078007670471831499869115906336364227766759e-01,
        5.853546836542067127712655200450981944303266678053369055707175e-01,
        -1.582910525634930566738054787646630415774471154502826559735335e-02,
        -2.840155429615469265162031323741647324684350124871451793599204e-01,
        4.724845739132827703605900098258949861948011288770074644084096e-04,
        1.287474266204784588570292875097083843022601575556488795577000e-01,
        -1.736930100180754616961614886809598311413086529488394316977315e-02,
        -4.408825393079475150676372323896350189751839190110996472750391e-02,
        1.398102791739828164872293057263345144239559532934347169146368e-02,
        8.746094047405776716382743246475640180402147081140676742686747e-03,
        -4.870352993451574310422181557109824016634978512157003764736208e-03,
        -3.917403733769470462980803573237762675229350073890493724492694e-04,
        6.754494064505693663695475738792991218489630013558432103617077e-04,
        -1.174767841247695337306282316988909444086693950311503927620013e-04
    ];
    /**
     * Daubechies 9 scaling numbers.
     */
    var Db9Wavelet = [
        3.807794736387834658869765887955118448771714496278417476647192e-02,
        2.438346746125903537320415816492844155263611085609231361429088e-01,
        6.048231236901111119030768674342361708959562711896117565333713e-01,
        6.572880780513005380782126390451732140305858669245918854436034e-01,
        1.331973858250075761909549458997955536921780768433661136154346e-01,
        -2.932737832791749088064031952421987310438961628589906825725112e-01,
        -9.684078322297646051350813353769660224825458104599099679471267e-02,
        1.485407493381063801350727175060423024791258577280603060771649e-01,
        3.072568147933337921231740072037882714105805024670744781503060e-02,
        -6.763282906132997367564227482971901592578790871353739900748331e-02,
        2.509471148314519575871897499885543315176271993709633321834164e-04,
        2.236166212367909720537378270269095241855646688308853754721816e-02,
        -4.723204757751397277925707848242465405729514912627938018758526e-03,
        -4.281503682463429834496795002314531876481181811463288374860455e-03,
        1.847646883056226476619129491125677051121081359600318160732515e-03,
        2.303857635231959672052163928245421692940662052463711972260006e-04,
        -2.519631889427101369749886842878606607282181543478028214134265e-04,
        3.934732031627159948068988306589150707782477055517013507359938e-05
    ];
    /**
     * Daubechies 10 scaling numbers.
     */
    var Db10Wavelet = [
        2.667005790055555358661744877130858277192498290851289932779975e-02,
        1.881768000776914890208929736790939942702546758640393484348595e-01,
        5.272011889317255864817448279595081924981402680840223445318549e-01,
        6.884590394536035657418717825492358539771364042407339537279681e-01,
        2.811723436605774607487269984455892876243888859026150413831543e-01,
        -2.498464243273153794161018979207791000564669737132073715013121e-01,
        -1.959462743773770435042992543190981318766776476382778474396781e-01,
        1.273693403357932600826772332014009770786177480422245995563097e-01,
        9.305736460357235116035228983545273226942917998946925868063974e-02,
        -7.139414716639708714533609307605064767292611983702150917523756e-02,
        -2.945753682187581285828323760141839199388200516064948779769654e-02,
        3.321267405934100173976365318215912897978337413267096043323351e-02,
        3.606553566956169655423291417133403299517350518618994762730612e-03,
        -1.073317548333057504431811410651364448111548781143923213370333e-02,
        1.395351747052901165789318447957707567660542855688552426721117e-03,
        1.992405295185056117158742242640643211762555365514105280067936e-03,
        -6.858566949597116265613709819265714196625043336786920516211903e-04,
        -1.164668551292854509514809710258991891527461854347597362819235e-04,
        9.358867032006959133405013034222854399688456215297276443521873e-05,
        -1.326420289452124481243667531226683305749240960605829756400674e-05
    ];

    /**
     * Mapping of wavelet type keys to scaling numbers.
     */
    var ScalingNumbers = {
        'db1': HaarWavelet,
        'db2': Db2Wavelet,
        'db3': Db3Wavelet,
        'db4': Db4Wavelet,
        'db5': Db5Wavelet,
        'db6': Db6Wavelet,
        'db7': Db7Wavelet,
        'db8': Db8Wavelet,
        'db9': Db9Wavelet,
        'db10': Db10Wavelet,
        'D2': HaarWavelet,
        'D4': Db2Wavelet,
        'D6': Db3Wavelet,
        'D8': Db4Wavelet,
        'D10': Db5Wavelet,
        'D12': Db6Wavelet,
        'D14': Db7Wavelet,
        'D16': Db8Wavelet,
        'D18': Db9Wavelet,
        'D20': Db10Wavelet,
        'haar': HaarWavelet,
    };

    /**
     * Calculates the element-wise sum of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Element-wise sum.
     */
    function add(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate element-wise sum. */
        return a.map(function (value, index) { return value + b[index]; });
    }
    /**
     * Asserts if approximation and detail coefficients are valid or throws an
     * error if they are invalid.
     * @param  approx Approximation coefficients.
     * @param  detail Detail coefficients.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidApproxDetail(approx, detail) {
        /* Check if coefficients have equal length. */
        if (approx.length !== detail.length) {
            throw new Error('Approximation and detail coefficients must have equal length.');
        }
        /* Check for coefficients of zero length. */
        if (approx.length === 0) {
            throw new Error('Approximation and detail coefficients must not have zero length.');
        }
        return true;
    }
    /**
     * Asserts if coefficients are valid or throws an error if they are invalid.
     * @param  coeffs Coefficients to test.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidCoeffs(coeffs) {
        /* Check if at least an array of approximation coefficients is given. */
        if (coeffs.length < 1) {
            throw new Error('Invalid coefficients. Array length must not be zero.');
        }
        return true;
    }
    /**
     * Asserts if wavelet filters are valid or throws an error if they are invalid.
     * @param  filters Wavelet filters to test.
     * @return         True if the wavelet filters are valid, otherwise throws an error.
     */
    function assertValidFilters(filters) {
        /* Check if high-pass and low-pass filters have equal length. */
        if (filters.high.length !== filters.low.length) {
            throw new Error('High-pass and low-pass filters have to have equal length.');
        }
        /* Check if filter length is larger than or equal to two. */
        if (filters.low.length < 2) {
            throw new Error('Wavelet filter length has to be larger than or equal to two.');
        }
        return true;
    }
    /**
     * Determines a wavelet basis from a wavelet type or basis.
     * @param  wavelet Wavelet type or basis.
     * @return         Wavelet basis.
     */
    function basisFromWavelet(wavelet) {
        return (typeof wavelet !== 'string')
            ? wavelet
            : waveletFromScalingNumbers(ScalingNumbers[wavelet]);
    }
    /**
     * Creates an array and populates it.
     * @param  length   Length of the array.
     * @param  populate Function to populate the array.
     * @return          Populated array with specified length.
     */
    function createArray(length, populate) {
        if (populate === void 0) { populate = 0; }
        /* Check for non-integer length. */
        if (!Number.isInteger(length)) {
            throw new Error('Length has to be an integer.');
        }
        /* Check for length less than zero. */
        if (length < 0) {
            throw new Error('Length must not be smaller than zero.');
        }
        /* Create and populate array. */
        return Array.apply(null, Array(length)).map(function (_, index) {
            return (typeof populate === 'function')
                ? populate(index)
                : populate;
        });
    }
    /**
     * Calculates the dot product of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Dot product.
     */
    function dot(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate dot product. */
        return a.reduce(function (dot, value, index) { return dot + value * b[index]; }, 0);
    }
    /**
     * Multiplies an array with a scalar value.
     * @param  scalar Scalar value.
     * @param  array  Array of numbers.
     * @return        Array multiplied with scalar value.
     */
    function mulScalar(scalar, array) {
        return array.map(function (value) { return scalar * value; });
    }
    /**
     * Returns a single padding element.
     * @param  data    Input data.
     * @param  index   Index of padding element.
     * @param  inverse True if the padding direction is inversed.
     * @param  mode    Signal extension mode.
     * @return         Single padding element.
     */
    function padElement(data, index, inverse, mode) {
        switch (mode) {
            case PADDING_MODES.antisymmetric:
                return antisymmetricPadding$$1(data, index, inverse);
            case PADDING_MODES.constant:
                return constantPadding(data, inverse);
            case PADDING_MODES.periodic:
                return periodicPadding(data, index, inverse);
            case PADDING_MODES.reflect:
                return reflectPadding(data, index, inverse);
            case PADDING_MODES.smooth:
                return smoothPadding(data, index, inverse);
            case PADDING_MODES.symmetric:
                return symmetricPadding(data, index, inverse);
            case PADDING_MODES.zero:
                return zeroPadding();
            default:
                throw new Error('Unknown signal extension mode: "' + mode + '"');
        }
    }
    /**
     * Determines the padding widths.
     * @param  dataLength   Length of signal.
     * @param  filterLength Length of filter.
     * @return              Padding widths.
     */
    function padWidths(dataLength, filterLength) {
        /* Check for valid data length. */
        if (dataLength <= 0) {
            throw new Error('Cannot determine padding widths for data of length less than or equal to zero.');
        }
        /* Check for valid filter length. */
        if (filterLength < 2) {
            throw new Error('Cannot determine padding widths for filter of length less than two.');
        }
        /* Determine padding widths. */
        return [
            filterLength - 2,
            ((dataLength + filterLength) % 2 === 0)
                ? filterLength - 2
                : filterLength - 1
        ];
    }
    /**
     * Determines a wavelet basis from scaling numbers.
     * @param  scalingNumbers Wavelet scaling numbers.
     * @return                Wavelet basis.
     */
    function waveletFromScalingNumbers(scalingNumbers) {
        /* Check if length is larger than or equal to two. */
        if (scalingNumbers.length < 2) {
            throw new Error('Scaling numbers length has to be larger than or equal to two.');
        }
        /* Determine wavelet numbers. */
        var waveletNumbers = scalingNumbers.slice() // Copy array
            .reverse()
            .map(function (value, index) { return (index % 2 === 0) ? value : -value; });
        /* Determine wavelet basis. */
        return {
            dec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers
            },
            rec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers.slice()
            },
        };
    }

    /**
     * Default padding mode to use.
     */
    var DEFAULT_PADDING_MODE = PADDING_MODES.symmetric;
    /**
     * Collection of methods for Discrete Wavelet Transform (DWT).
     */
    var DiscreteWavelets = /** @class */ (function () {
        function DiscreteWavelets() {
        }
        /**
         * Single level Discrete Wavelet Transform.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @return         Approximation and detail coefficients as result of the transform.
         */
        DiscreteWavelets.dwt = function (data, wavelet, mode) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.dec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Add padding. */
            data = this.pad(data, padWidths(data.length, filterLength), mode);
            /* Initialize approximation and detail coefficients. */
            var approx = [];
            var detail = [];
            /* Calculate coefficients. */
            for (var offset = 0; offset + filterLength <= data.length; offset += 2) {
                /* Determine slice of values. */
                var values = data.slice(offset, offset + filterLength);
                /* Calculate approximation coefficients. */
                approx.push(dot(values, filters.low));
                /* Calculate detail coefficients. */
                detail.push(dot(values, filters.high));
            }
            /* Return approximation and detail coefficients. */
            return [approx, detail];
        };
        /**
         * Calculates the energy as sum of squares of an array of data or
         * coefficients.
         * @param  values Array of data or coefficients.
         * @return        Energy of values as the sum of squares.
         */
        DiscreteWavelets.energy = function (values) {
            var energy = 0;
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var value = values_1[_i];
                if (!Array.isArray(value))
                    energy += Math.pow(value, 2);
                else
                    energy += this.energy(value);
            }
            return energy;
        };
        /**
         * Single level inverse Discrete Wavelet Transform.
         * @param  approx  Approximation coefficients. If undefined, it will be set to an array of zeros with length equal to the detail coefficients.
         * @param  detail  Detail coefficients. If undefined, it will be set to an array of zeros with length equal to the approximation coefficients.
         * @param  wavelet Wavelet to use.
         * @return         Approximation coefficients of previous level of transform.
         */
        DiscreteWavelets.idwt = function (approx, detail, wavelet) {
            /* Fill empty array with zeros. */
            if (approx === undefined && detail !== undefined) {
                approx = createArray(detail.length, 0);
            }
            if (detail === undefined && approx !== undefined) {
                detail = createArray(approx.length, 0);
            }
            /* Check if some coefficients are undefined. */
            if (approx === undefined || detail === undefined) {
                throw new Error('Coefficients must not be undefined.');
            }
            assertValidApproxDetail(approx, detail);
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.rec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Initialize transform. */
            var coeffLength = approx.length;
            var pad = createArray(filterLength + (coeffLength - 1) * 2, 0);
            /* Perform inverse Discrete Wavelet Transform. */
            for (var i = 0; i < coeffLength; i++) {
                var offset = 2 * i;
                /* Calculate values. */
                var values = pad.slice(offset, offset + filterLength);
                values = add(values, mulScalar(approx[i], filters.low));
                values = add(values, mulScalar(detail[i], filters.high));
                /* Update values. */
                pad.splice.apply(pad, __spreadArrays([offset, filterLength], values));
            }
            /* Remove padding. */
            return pad.slice(filterLength - 2, pad.length - (filterLength - 2));
        };
        /**
         * Determines the maximum level of useful decomposition.
         * @param  dataLength Length of input data.
         * @param  wavelet    Wavelet to use.
         * @return            Maximum useful level of decomposition.
         */
        DiscreteWavelets.maxLevel = function (dataLength, wavelet) {
            /* Check for non-integer length. */
            if (!Number.isInteger(dataLength)) {
                throw new Error('Length of data is not an integer. This is not allowed.');
            }
            /* Check for invalid input. */
            if (dataLength < 0) {
                throw new Error('Data length cannot be less than zero.');
            }
            /* Return zero for data of zero length. */
            if (dataLength === 0)
                return 0;
            /* Determine wavelet basis. */
            var waveletBasis = basisFromWavelet(wavelet);
            /* Determine length of filter. */
            var filterLength = waveletBasis.dec.low.length;
            // SOURCE: https://pywavelets.readthedocs.io/en/latest/ref/dwt-discrete-wavelet-transform.html#maximum-decomposition-level-dwt-max-level-dwtn-max-level
            return Math.max(0, Math.floor(Math.log2(dataLength / (filterLength - 1))));
        };
        /**
         * Extends a signal with a given padding mode.
         * @param  data      Input data.
         * @param  padWidths Widths of padding at front and back.
         * @param  mode      Signal extension mode.
         * @return           Data with padding.
         */
        DiscreteWavelets.pad = function (data, padWidths$$1, mode) {
            /* Check for undefined data. */
            if (!data) {
                throw new Error('Cannot add padding to empty data.');
            }
            /* Initialize. */
            var front = padWidths$$1[0];
            var back = padWidths$$1[1];
            /* Add padding. */
            return createArray(front, function (index) {
                return padElement(data, (front - 1 - index), true, mode);
            })
                .concat(data)
                .concat(createArray(back, function (index) {
                return padElement(data, index, false, mode);
            }));
        };
        
        /**
         *  Expand each row of the data matrix (returned, e.g., by wavedec) with respect
         *  to the widest row. Mode specifies the interpolation function (default: 'step').
         */
        DiscreteWavelets.expand = function (data, mode) {
          var len=0,dataX=[];
          for(var row in data) len=Math.max(len,data[row].length); 
          switch (mode) {
            case 'step':
            default:
              // simple; extend each data point
              for(row in data) {
                if (data[row].length!=len) {
                  var frag=Math.floor(len/data[row].length);
                  dataX[row]=[];
                  for(var col=0; col < data[row].length; col++) {
                    dataX[row].push(Array.init(frag,data[row][col]));
                  }
                  dataX[row]=dataX[row].flat();
                } else dataX.push(data[row]);
              }
          }
          return dataX;
        };
        
        /**
         * 1D wavelet decomposition. Transforms data by calculating multi-level coefficients from
         * input data.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @param  level   Decomposition level. Defaults to level calculated by maxLevel function.
         * @return         Coefficients as result of the transform.
         */
        DiscreteWavelets.wavedec = function (data, wavelet, mode, level) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine decomposition level. */
            if (level === undefined)
                level = this.maxLevel(data.length, wavelet);
            if (level < 0) {
                throw new Error('Decomposition level must not be less than zero');
            }
            /*  Initialize transform. */
            var coeffs = [];
            var approx = data;
            /* Transform. */
            for (var l = 1; l <= level; l++) {
                /* Perform single level transform. */
                var approxDetail = this.dwt(approx, wavelet, mode);
                approx = approxDetail[0];
                var detail = approxDetail[1];
                /* Prepend detail coefficients. */
                coeffs.unshift(detail);
            }
            /* Prepend last approximation. */
            // coeffs.unshift(approx);
            /* Return coefficients. */
            return coeffs.reverse();
        };
        /**
         * 1D wavelet reconstruction. Inverses a transform by calculating input data
         * from coefficients.
         * @param  coeffs  Coefficients as result of a transform.
         * @param  wavelet Wavelet to use.
         * @return         Input data as result of the inverse transform.
         */
        DiscreteWavelets.waverec = function (coeffs, wavelet) {
            /* Check if coefficients are valid. */
            assertValidCoeffs(coeffs);
            /* Determine wavelet. */
            wavelet = basisFromWavelet(wavelet);
            /* Initialize transform. */
            var approx = coeffs[0];
            /* Transform. */
            for (var i = 1; i < coeffs.length; i++) {
                /* Initialize detail coefficients. */
                var detail = coeffs[i];
                // TODO: Check if problem of different coefficient lengths because of padding can be solved in a more elegant way.
                if (approx.length === detail.length + 1) {
                    approx = approx.slice(0, approx.length - 1);
                }
                /* Calculate previous level of approximation. */
                approx = this.idwt(approx, detail, wavelet);
            }
            /* Return data. */
            return approx;
        };
        /**
         * Contains static information about the signal extension modes.
         */
        DiscreteWavelets.Modes = PADDING_MODES;
        return DiscreteWavelets;
    }());

    return DiscreteWavelets;

})));
//# sourceMappingURL=discrete-wavelets.umd.js.map
};
BundleModuleCode['plugins/math/numeric']=function (module,exports){
// https://github.com/sloisel/numeric

"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
};
BundleModuleCode['plugins/math/regression']=function (module,exports){
// https://github.com/Tom-Alexander/regression-js
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.regression = mod.exports;
  }
})(this, function (module) {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

  /**
  * Determine the coefficient of determination (r^2) of a fit from the observations
  * and predictions.
  *
  * @param {Array<Array<number>>} data - Pairs of observed x-y values
  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
  *
  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
  */
  function determinationCoefficient(data, results) {
    var predictions = [];
    var observations = [];

    data.forEach(function (d, i) {
      if (d[1] !== null) {
        observations.push(d);
        predictions.push(results[i]);
      }
    });

    var sum = observations.reduce(function (a, observation) {
      return a + observation[1];
    }, 0);
    var mean = sum / observations.length;

    var ssyy = observations.reduce(function (a, observation) {
      var difference = observation[1] - mean;
      return a + difference * difference;
    }, 0);

    var sse = observations.reduce(function (accum, observation, index) {
      var prediction = predictions[index];
      var residual = observation[1] - prediction[1];
      return accum + residual * residual;
    }, 0);

    return 1 - sse / ssyy;
  }

  /**
  * Determine the solution of a system of linear equations A * x = b using
  * Gaussian elimination.
  *
  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
  * @param {number} order - How many degrees to solve for
  *
  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
  */
  function gaussianElimination(input, order) {
    var matrix = input;
    var n = input.length - 1;
    var coefficients = [order];

    for (var i = 0; i < n; i++) {
      var maxrow = i;
      for (var j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (var k = i; k < n + 1; k++) {
        var tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (var _j = i + 1; _j < n; _j++) {
        for (var _k = n; _k >= i; _k--) {
          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
        }
      }
    }

    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
      var total = 0;
      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
        total += matrix[_k2][_j2] * coefficients[_k2];
      }

      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
    }

    return coefficients;
  }

  /**
  * Round a number to a precision, specificed in number of decimal places
  *
  * @param {number} number - The number to round
  * @param {number} precision - The number of decimal places to round to:
  *                             > 0 means decimals, < 0 means powers of 10
  *
  *
  * @return {numbr} - The number, rounded
  */
  function round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
  * The set of all fitting methods
  *
  * @namespace
  */
  var methods = {
    linear: function linear(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = 0;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          len++;
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      var run = len * sum[2] - sum[0] * sum[0];
      var rise = len * sum[3] - sum[0] * sum[1];
      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [gradient, intercept],
        r2: round(determinationCoefficient(data, points), options.precision),
        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
      };
    },
    exponential: function exponential(data, options) {
      var sum = [0, 0, 0, 0, 0, 0];

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
      var coeffA = round(a, options.precision);
      var coeffB = round(b, options.precision);
      var predict = function predict(x) {
        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    logarithmic: function logarithmic(data, options) {
      var sum = [0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      var coeffB = round(a, options.precision);
      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    power: function power(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
      var a = (sum[2] - b * sum[0]) / len;
      var coeffA = round(Math.exp(a), options.precision);
      var coeffB = round(b, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'x^' + coeffB,
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    polynomial: function polynomial(data, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var len = data.length;
      var k = options.order + 1;

      for (var i = 0; i < k; i++) {
        for (var l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        var c = [];
        for (var j = 0; j < k; j++) {
          for (var _l = 0; _l < len; _l++) {
            if (data[_l][1] !== null) {
              b += Math.pow(data[_l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      var coefficients = gaussianElimination(rhs, k).map(function (v) {
        return round(v, options.precision);
      });

      var predict = function predict(x) {
        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      var string = [];
      for (var _i = 0; _i <coefficients.length; _i++) {
        if (_i > 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*Math.pow(x,' + _i + '))');
        } else if (_i === 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*x)');
        } else if (coefficients[_i] !== 0) {
          string.push('('+coefficients[_i]+')');
        }
      }
      string=string.join('+');

      return {
        string: string,
        points: points,
        predict: predict,
        equation: [].concat(_toConsumableArray(coefficients)),
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    }
  };

  function createWrapper() {
    var reduce = function reduce(accumulator, name) {
      return _extends({
        _round: round
      }, accumulator, _defineProperty({}, name, function (data, supplied) {
        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
      }));
    };

    return Object.keys(methods).reduce(reduce, {});
  }

  module.exports = createWrapper();
});
};
BundleModuleCode['plugins/math/polyfit']=function (module,exports){
// Requirement: https://github.com/sloisel/numeric/blob/master/src/numeric.js

var numeric = Require('plugins/math/numeric')

// Find the best-fit curve for an nth order polynomial.
function polyfit(xArray, yArray, order) {

  if (xArray.length <= order) console.warn("Warning: Polyfit may be poorly conditioned.")

  var xMatrix = []
  var yMatrix = numeric.transpose([yArray])

  for (var i = 0; i < xArray.length; i++) {

    var temp = []

    for (var j = 0; j <= order; j++) {

      temp.push(Math.pow(xArray[i], j))

    }

    xMatrix.push(temp)

  }

  var xMatrixT = numeric.transpose(xMatrix)

  var dot1 = numeric.dot(xMatrixT, xMatrix)
  var dot2 = numeric.dot(xMatrixT, yMatrix)

  var dotInv = numeric.inv(dot1)

  var coefficients = numeric.dot(dotInv, dot2)

  return coefficients.unwrap().reverse()

}

// Predict y given x.
function predict(x, coefficients) {

  var prediction = 0

  for (var i = 0; i < coefficients.length; i++) {

    prediction += coefficients[i] * Math.pow(x, i)

  }

  return prediction

}

// Evaluate model accuracy.
function rSquared(x, y, coefficients) {

  var regressionSquaredError = 0
  var totalSquaredError = 0

  var yMean = y.reduce((a, b) => a + b) / y.length

  for (var i = 0; i < x.length; i++) {

    regressionSquaredError += Math.pow(y[i] - predict(x[i], coefficients), 2)
    totalSquaredError += Math.pow(y[i] - yMean, 2)

  }

  return 1 - (regressionSquaredError / totalSquaredError)

}

module.exports = polyfit
};
BundleModuleCode['plugins/math/smoothers']=function (module,exports){
/*********************/
/* Helper Functions. */
/* http://madrury.github.io/smoothers */
/*********************/
var numeric = Require('plugins/math/numeric')

/* Compute the dot product of two vectors. */
var dot = function(v1, v2) {
    var s = 0;
    for(var i = 0; i < v1.length; i++) {
        s += v1[i] * v2[i];
    }
    return s
}

/* Construct a linear function given a slope and an intercept. */
var linear_function = function(m, b) {
    return function(x) {
        return b + m * x;
    }
}

/* Compute the weighted mean of x with weights w.  Weights may be
   un-normalized.
*/
var wmean = function(x, w) {
    var r = [];
    for(i = 0; i < x.length; i++) {
        r.push(x[i]*w[i]);
    }
    return r.sum() / w.sum();
}

/* The sum of squared errors of a data set when making a prediction equal
   to the mean.
*/
var sum_of_squared_errors = function(xs) {
    return xs.map(x => x - xs.mean()).map(x => x*x).reduce((a, b) => a + b, 0);
}

/* Fit a simple linear regression on data (ys, xs).

   This returns a linear function, i.e. the prediction function from the
   fit linear regression.
*/
var linear_regressor = function(xs, ys) {
    var xmean = xs.mean();
    var ymean = ys.mean();
    var xymean = (Math.zip(xs, ys).map(p => p[0]*p[1])).mean();
    var xsqmean = (Math.zip(xs, xs).map(p => p[0]*p[1])).mean();
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var intercept = ymean - beta * xmean;
    return linear_function(beta, intercept);
};

/* Simple linear regression with sample weights. */
var weighted_linear_regressor = function(xs, ys, ws) {
    var xmean = wmean(xs, ws);
    var ymean = wmean(ys, ws);
    var xymean = wmean(Math.zip(xs, ys).map(p => p[0]*p[1]), ws);
    var xsqmean = wmean(Math.zip(xs, xs).map(p => p[0]*p[1]), ws);
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var betaz = ymean - beta * xmean;
    return linear_function(beta, betaz)
};

/* Given a function from numbers to numbers, return one that maps arrays to
   arrays through mapping.
*/
var vectorize = function(f) {
    return function(arr) {
        return arr.map(f)
    }
}

/* Undo a zip operation */
var unzip = function(ps, i) {
    return ps.map(p => p[i]);
}

/* Sort ordered pairs of x, y data by x. */
var sort_data = function(xs, ys) {
    var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
    var xsort = unzip(psort, 0);
    var ysort = unzip(psort, 1);
    return [xsort, ysort];
}


/*******************************************/
/* Ridge Regression with Basis Expansions. */
/*******************************************/

/* Fit a ridge regression to data X and response ys with regularization
   strength lambda.

   This returns an object containing the data needed to score the fitted
   regression:
   
   {
       "betas": <array of standardized parameter estiamtes>,
       "Xsd": <standardizer data for X>,
       "ysd": <standardizer data for y>
   }
*/
var fit_ridge_regression = function(X, ys, lambda) {
    /* Construct a square matrix of size n with lambdas along the main
       diagonal, and a zero in the (0, 0) position.  This type of matrix is
       useful in ridge regression.
    */
    var make_ridge_shrinkage_matrix = function(n, lambda) {
        var shrink_matrix = numeric.diag(numeric.rep([n + 1], lambda));
        /* Dont shrink the linear term in basis expansion regressions. */
        shrink_matrix[0][0] = 0;
        return shrink_matrix
    }

    /* Compute the translation and scale factors necessary to standardize the
      columns of a matrix.

      This returns an object with two attributes:

      { "mean": [<array of translation factors>],
        "sd": [<array of scale factors>] }
    */
    var compute_matrix_standardization = function(X) {
        var standardization = {"mean": [], "sd": []};
        /* It is easier to iterate over the rows of a matrix than the columns. */
        var Xt = numeric.transpose(X);
        for(var i = 0; i < Xt.length; i++) {
            var standardized_row = compute_vector_standardization(Xt[i]);
            standardization.mean.push(standardized_row.mean);
            standardization.sd.push(standardized_row.sd);
        }
        return standardization;
    }

    /* Compute the translation and scale factor necessary to standardize a
      vector.

      This returns an object with two attributes:

      {"mean": <mean of vector>, "sd": <standard deviation of vector>}
    */
    var compute_vector_standardization = function(v) {
        var mean = v.mean();
        var sd = Math.deviation(v);
        return {'mean': mean, 'sd': sd}
    }

    var X_standardization = compute_matrix_standardization(X);
    var Xsd = standardize_matrix(X, X_standardization);
    var y_standardization = compute_vector_standardization(ys);
    var ysd = standardize_vector(ys, y_standardization);
    // Compute the regression.
    var Xsdt = numeric.transpose(Xsd);
    var XtX = numeric.dot(Xsdt, Xsd);
    var Xty = numeric.dot(Xsdt, ysd);
    var shrink_matrix = make_ridge_shrinkage_matrix(X[0].length, lambda);
    var betas = numeric.solve(numeric.add(XtX, shrink_matrix), Xty);

    return {
        "betas": betas,
        "Xsd": X_standardization,
        "ysd": y_standardization
    }
}

/* Apply standardization data to a matrix.  Returns a standardized version
   of the matrix, i.e. a matrix with standardized columns.
*/
var standardize_matrix = function(X, standardization) {
    /* It is easier to iterate over the rows of a matrix than the columns. */
    var Xt = numeric.transpose(X);
    var S = []
    for(var i = 0; i < Xt.length; i++) {
        var row_standardization = {
            "mean": standardization.mean[i],
            "sd": standardization.sd[i]
        };
        var standardized_row = standardize_vector(Xt[i], row_standardization);
        S.push(standardized_row);
    }
    return numeric.transpose(S);
}

/* Apply standardization data to a vector. */
var standardize_vector = function(v, standardization) {
    return v.map(x => (x - standardization.mean) / standardization.sd)
}


/* Basies for fitting basis expansion models. 

   A basis is a linearly independent sequence of functions [f_1, f_2, ..., f_k].
   A basis expansion is a transformation of a vector v into a matrix..  The
   columns of the basis expanded matrix are created by mapping each of the
   functions in the basis expansion over the vector in turn.
*/
var basies = {

    /* Polynomial basis expansion.

         x -> [1, x, x^2, ...]
    */
    polynomial_basis: function(d) {
        var basis = [];
        function push(i) {
          basis.push(function (x) { return  Math.pow(x, i) })
        }
        for(var i = 1; i <= d; i++) {
          push(i)
        }
        return basis;
    },

    /* Piecewise linear spline basis.

       This basis depends on a sequence of knots: k_1, k_2, ...
       The basis expansion is given by the sequence of functions
       x -> max(0, x - k_i).

       Models fit using a PL basis expansion as predictors result in piecewise
       linear prediction functions.
    */
    pl_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        function push(i) {
          basis.push(function (x) { return  Math.max(x - knots[i], 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis;
    },

    /* Quadratic spline basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a quadratic spline basis expansion as predictors reult
       in a peicewise quadratic prediction function.
    */ 
    quadratic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        function push(i) {
          basis.push(function (x) { return  Math.pow(x - knots[i], 2)*((x - knots[i]) >= 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a cubic spline basis expansion as predictors reult
       in a peicewise cubic prediction function.
    */ 
    cubic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        basis.push(x => x*x*x);
        function push(i) {
          basis.push(function (x) { return  Math.max(Math.pow(x - knots[i], 3), 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Natural cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a natural cubic spline basis expansion as predictors
       reult in a peicewise cubic prediction function, but with the extra
       feature that the function is linear outside of the leftmost and
       rightmost knots.
    */ 
    natural_cubic_spline_basis: function(knots) {
        n_knots = knots.length;
        var basis = [];
        basis.push(x => x);
        var ppart = (t => Math.max(t, 0))
        var cube = (t => t*t*t);
        var d = function(knot_idx) {
            return function(x) {
                return (
                    // Sure would be nice if this was scheme.
                    (cube(ppart(x - knots[knot_idx], 0)) 
                        - cube(ppart(x - knots[n_knots - 1], 0)))
                    / (knots[n_knots - 1] - knots[knot_idx]));
            };
        };
        function push(k) {
          basis.push(function (x) { return  d(k)(x) - d(n_knots - 2)(x) })
        }
        for(var k = 0; k < n_knots - 2; k++) {
          push(k)
        }
        return basis
    }
}

/* Construct a regression operator given a basis of functions, and a
   regularization strength.

   This constructs a function witht he following signature:
       (xs, ys) => (x => _)
   I.e. a function that consumes data, and returns a prediction function.
   The prediction function is constructed by fitting a ridge regression
   on the data (xs, ys) after applying the given basis expansion.
*/
var make_basis_expansion_regression = function(basis, lambda) {
    /* Map a basis expansion across a vector. The result is a vector. */
    var evaluate_basis_expansion = function(basis, xs) {
        return xs.map(x => basis.map(s => s(x)))
    }

    return function(xs, ys) {
        var X = evaluate_basis_expansion(basis, xs);
        var ridge = fit_ridge_regression(X, ys, lambda);
        var smooth_value = function(newx) {
            // There is a small hack here.  After getting the basis
            // expansion, we have a vector.  We immediately wrap this in a
            // list, creating a one row matrix.  This allows us to use
            // standardize_matrix, avoiding duplication of some logic.
            var basis_expansion = [basis.map(s => s(newx))]
            var standardized_basis_expansion = 
                standardize_matrix(basis_expansion, ridge.Xsd)[0];

            return (
                numeric.dot(ridge.betas, standardized_basis_expansion) * ridge.ysd.sd
                + ridge.ysd.mean); 
        }
        return Object.assign(vectorize(smooth_value),{parameter:ridge});
    };
}

/* Consume a basis expansion representing a spline basis, and return a function
   that consumes a object of parameters (the only parameter being the number of
   knots), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_spline_regression = function(spline_basis_function) {

    return function(parameters) {
        var n = Number(parameters["n"]);
        var knots = make_knots(n);
        var sp = spline_basis_function(knots);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(sp, lambda);
    }
}

/* Make a set of equally spaced knots in the interval [0, 1] */
var make_knots = function(n) {
    return numeric.linspace(0, 1, n + 2).slice(1, n + 1);
}

/* Consume a basis expansion representing a polynomial basis, and return a
   function that consumes a object of parameters (the only parameter being the
   degree), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_polynomial_regression = function(polynomial_basis_function) {
    return function(parameters) {
        var d = Number(parameters["degree"]);
        var p = polynomial_basis_function(d);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(p, lambda);
    }
}


/********************/
/* Regression Trees */
/********************/

/* Construct a function that fits regression trees of a specified depth.

   Returns a function ((xs, ys) => (x => _)) that fits a regression tree
   to the supplied xs, ys data.
*/
var make_regression_tree = function(parameters) {
    var depth = Number(parameters["depth"]);
    return function(xs, ys) {
        /* We sort the data once up front, it will stay sorted as we
           decend the tree.
        */
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var tree = fit_regression_tree(xsorted, ysorted, depth);
        var regression_tree_predict_pointwise = function(x) {
            return score_regression_tree(x, tree);
        }
        var fs = vectorize(regression_tree_predict_pointwise);
        fs.tree=tree;
        return fs;
    }
}

/* Fit a regression tree to data of a specified depth.

   Returns a simple object (informally of type tree) representing a fit
   regression tree.  A tree object has the following shape.

    {
        "is_leaf": <boolean: is this tree a lead node?>,
        "value": <float: The value to predict in this node, if a leaf>,
        "left_child_condition": <function: f(x) answers "is x in the reigon
                                 defined by the left child node>
        "left_child": <tree: A fit regression tree to those xs, ys in the left
                       child>,
        "right_child": <tree: A fit regression tree to those xs, ys in the
                        right child>,
    }

    The field "value" is only defined for leaf nodes.  The fields
    "left_child_condition", "left_child", and "right_child" are only defined if
    *not* a lead node.
*/
var fit_regression_tree = function(xs, ys, depth) {
    if(depth === 0 || ys.length <= 1) {
        /* Base case step. */
        var tree = make_tree_object();
        tree.is_leaf = true;
        tree.value = ys.mean();
        return tree;
    } else {
        /* Recursive step. */
        var split = compute_split_point(xs, ys);
        var condition = function(x) {return x <= split}
        var ps = Math.zip(xs, ys);
        var left_data = ps.filter(p => condition(p[0]));
        var right_data = ps.filter(p => !condition(p[0]));
        /* Construct and return the tree */
        var tree = make_tree_object();
        tree.left_child_condition = condition;
        tree.left_child = fit_regression_tree(
            unzip(left_data, 0), unzip(left_data, 1), depth - 1);
        tree.right_child = fit_regression_tree(
            unzip(right_data, 0), unzip(right_data, 1), depth - 1);
        return tree;
    }
}


/* Construct an empty tree object. */
var make_tree_object = function() {
    return {
        "is_leaf": false,
        "left_child_condition": null,
        "left_child": null,
        "right_child": null,
        "value": null
    }
}

/* Compute the optimal split point in data xs, ys.

   The split point is the midpoint between two data points, so that grouping
   the ys data into those left of and right of the split point produces the
   least total varaince.

   Note: This function assumes that the xs, ys data is sorted in increasing
         xs order.
*/
var compute_split_point = function(xs, ys) {
    var best_sosd = Infinity;
    var best_split = null;
    for(var i = 1; i <= ys.length - 1; i++) {
        var left_ys = ys.slice(0, i);
        var right_ys = ys.slice(i, ys.length);
        var this_sosd = sum_of_squared_errors(left_ys) + 
                        sum_of_squared_errors(right_ys);
        if(this_sosd <= best_sosd) {
            best_sosd  = this_sosd;
            best_split = (xs[i-1] + xs[i]) / 2;
        }
    }
    return best_split;
}

/* Generate a predictor from a regression tree at a point x */
var score_regression_tree = function(x, tree) {
    if(tree.is_leaf == true) {
        return tree.value;
    } else {
        if(tree.left_child_condition(x)) {
            return score_regression_tree(x, tree.left_child);
        } else {
            return score_regression_tree(x, tree.right_child);
        }
    }
}


/*********************/
/* Gradient Boosting */
/*********************/

/* Construct a function that fits a gradient boosted regression.

   Returns a function ((xs, ys) => (x => _)) that fits a gradient booster
   to the supplied xs, ys data.
*/
var make_boosted_model = function(parameters) {
    var learning_rate = Number(parameters["learning_rate"]);
    var n_trees = Number(parameters["n_trees"]);
    var tree_depth = Number(parameters["tree_depth"]);
    return function(xs, ys) {
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var booster = fit_boosted_model(xs, ys, n_trees, learning_rate, tree_depth);
        var boosted_model_predict_pointwise = function(x) {
            return score_boosted_model(x, booster);
        }
        return vectorize(boosted_model_predict_pointwise);
    }
}

/* Fit a gradient boosted regression to data of a specified depth.

   Returns a simple object (informally of type booster) representing a fit
   boosted model.  A booster object has the following shape.

   {
       "intercept": <The mean of the training data, used as the 0'th
                     boosting stage>,
       "trees": [<Array of tree objects, the boosting stages>],
       "learning_rate": <The learning rate of the boosted model>
   }
*/
var fit_boosted_model = function(xs, ys, n_trees, learning_rate, tree_depth) {
    var boosted_model = new_boosted_model();
    boosted_model.learning_rate = learning_rate;
    var working_ys = ys.slice(); // Copy.
    /* Fit the first stage */
    boosted_model.intercept = ys.mean();
    working_ys = working_ys.map(y => y - boosted_model.intercept);
    /* Boost */
    for(var i = 0; i <= n_trees; i++) {
        var tree = fit_regression_tree(xs, working_ys, tree_depth);
        working_ys = 
            Math.zip(xs, working_ys)
              .map(p => p[1] - learning_rate * score_regression_tree(p[0], tree));
        boosted_model.trees.push(tree);
    }
    return boosted_model;
}

/* Construct a booster object. */
var new_boosted_model = function() {
    return {"intercept": null, "trees": [], "learning_rate": null};
}

/* Make predictions on a new datapoint from a booster object. */
var score_boosted_model = function(x, booster) {
    var y_hat = booster.intercept;
    for(var i = 0; i < booster.trees.length; i++) {
        y_hat += booster.learning_rate * score_regression_tree(x, booster.trees[i]);
    }
    return y_hat;
}

/************************/
/* Smoothing Algorithms */
/************************/

/* A namespace for scatterplot smoother objects.

  Each smoother object has three attributes:

    - label: A short description of the smoother.  Appears in a select input
      field.
    - smoother: A smoother function.  Each smoother function has the form

          parameters => ((xs, ys) => (x => _))

      where parameters is a dictionary containing the values of huperparameters
      for the smoother, and xs, ys are equal length vectors of x-coordinates
      and y-coordinates of data points to be smoothed.
    - parameters: Configuration objects for hyperparameters.  These are used
      to populate input slider elements in the user interface.
*/
var smoothers = {

    /* Trivial global mean smoother.

    Simply return the mean of the y values as the smoothed data.

    Hyperparamters: None
    */
    "smooth-type-mean": {

        "label": "Constant Mean",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var mean = ys.mean();
                return vectorize(x => mean)
            }
        },

        "parameters": []
    },

    /* Running mean smoother. 

    The smoothed value y at a given x is the mean value of the y data for
    those data with the closest k x data.

    Hyperparameters:
        k: Number of data points included in each side of the symmetric nbhd.
    */
    "smooth-type-runmean": {

        "label": "Running Mean",
    
        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var xysorted = sort_data(xs, ys), xsort = xysorted[0], ysort = xysorted[1];
                var mean_of_symm_nbrd = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length - 1, pos_in_array + k)
                    ];
                    return (ysort.slice(cutoffs[0], cutoffs[1])).mean();
                };
                return vectorize(mean_of_symm_nbrd);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 1, "max": 20, "step": 1, "default": 2}
        ]
    },

    /* Simple linear regression smoother. 
    
    Hyperparameters:
        None.
    */
    "smooth-type-linreg": {

        "label": "Linear Regression",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var linreg = linear_regressor(xs, ys);
                return vectorize(linreg);
            };
        },

        "parameters": []

    },

    /* Gaussian kernel smoother.

    Hyperparmeters:
        lambda: Width of the gaussian kernel.
    */
    "smooth-type-gaussk": {

        "label": "Gaussian Kernel Smoother",

        "smoother": function(parameters) {
            var lambda = Number(parameters["lambda"]);
            return function(xs, ys) {
                var gauss_kern_smooth = function(x) {
                    var ds = xs.map(function(xi) {return x - xi;});
                    var ws = ds.map(function(di) {return Math.exp(-di*di/lambda);});
                    var normc = ws.sum(); 
                    var normws = ws.map(function(wi) {return wi / normc;});
                    return (Math.zip(normws, ys).map(function(p) {return p[0]*p[1]})).sum();
                };
                return vectorize(gauss_kern_smooth)
            };
        },

        "parameters": [
            {"label": "Width of Kernel", "name": "lambda",
             "min": .001, "max": .05, "step": .001, "default": .01}
        ]

    },

    /* Running line smoother.

       To calculate the smoothed value of y at a given x, we first take
       together the k data points closest to x.  Then fit a simple linear
       regression to these k data points.  The smoothed value of y is the value
       f(x), where f is the prediction function of this linear regression.

    Hyperparameters:
        k: The number of neighbours to consider when fitting the local linear
           regressions.
    */
    "smooth-type-runline": {

        "label": "Running Line",

        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
                var xsort = psort.map(function(p) {return p[0]});
                var ysort = psort.map(function(p) {return p[1]});
                var loc_lin_approx = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    // TODO: Check that you lined up the fenceposts.
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length, pos_in_array + k)
                    ];
                    var locx =  xsort.slice(cutoffs[0], cutoffs[1]);
                    var locy =  ysort.slice(cutoffs[0], cutoffs[1]);
                    return linear_regressor(locx, locy)(newx);
                }
                return vectorize(loc_lin_approx);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 2, "max": 20, "step": 1, "default": 2}
        ]

    },

    /* Ridge regression with a polynomial basis expansion.

    Hyperparameters:
        degree: The maximum degree of polynomial in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-polyreg": {
    
        "label": "Polynomial Ridge Regression",

        "smoother": make_polynomial_regression(basies.polynomial_basis),

        "parameters": [
            {"label": "Polynomial Degree", "name": "degree",
             "min": 1, "max": 20, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ]

    },

    /* Ridge regression with a piecewise linear basis expansion.

    Hyperparameters:
        n: The number of knots to use in the PL basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-pl": {

        "label": "Piecewise Linear Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.pl_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .1, "step": .0001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise quadratic basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
     */
    "smooth-type-quad": {

        "label": "Quadratic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.quadratic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise cubic (unrestricted) basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-spline": {

        "label": "Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a natural cubic spline basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-natural-spline": {

        "label": "Natural Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.natural_cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 3},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Regression tree smoother.

    Hyperparameters:
        depth: The maximum depth in the fit tree.  The final tree has 2**depth
               leaf nodes.
    */
    "smooth-type-regression-tree": {
    
        "label": "Regression Tree",

        "smoother": make_regression_tree,

        "parameters": [
            {"label": "Maximum Tree Depth", "name": "depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },

    /* Gradient boosting to minimize the sum of squared errors.

    Hyperparameters:
        n_trees: The number of boosting stages.
        learning_rate: Learning rate.
        tree_depth: The maximum depth of the individual trees.
    */
    "smooth-type-boosting": {
    
        "label": "Gradient Boosting Regression",

        "smoother": make_boosted_model,

        "parameters": [
            {"label": "Number of Boosting Stages", "name": "n_trees",
             "min": 0, "max": 250, "step": 1, "default": 5},
            {"label": "Learning Rate", "name": "learning_rate",
             "min": 0, "max": 1, "step": 0.01, "default": 0.05},
            {"label": "Maximum Tree Depth", "name": "tree_depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },
/*
    // Locally weighted linear regression smoother.
    "smooth-type-loess": function(xs, ys) {
        var k = 5
        var loess = function(x) {
            // Sort by increasing absolute distance from x.
            var psort = d3.zip(xs, ys).sort(function(a, b) {
                return Math.abs(x - a[0]) - Math.abs(x - b[0])}
            );
            var xsort = psort.map(function(p) {return p[0]}).slice(0, 7);
            var ysort = psort.map(function(p) {return p[1]}).slice(0, 7);
            var nearest_nbrs = psort.slice(0, 7);
            var ds = nearest_nbrs.map(function(p) {return Math.abs(p[0] - x)});
            var dsmax = d3.max(ds);
            var ws = ds.map(function(d) {
                return Math.pow(1 - d*d*d, 3) / (dsmax * dsmax * dsmax)
            });
            return weighted_linear_regressor(xsort, ysort, ws)(x);
        };
        return vectorize(loess)
    },
*/
};

// fourier-polynomial.js
//
// A class modeling a fourier polynomial (finite degree).

var FourierPolynomial = function(cs) {
  
  var _coefs = cs

  return {
  
    get degree() {
      return _coefs.length - 1
    },

    // The maximum possible value obtained by the polynomial
    get pmax() {
      var s, i
      s = 0
      for(i = 0; i < _coefs.length; i++) {
        s += Math.abs(_coefs[i])
      }
      return s
    },

    // Evaluate the polynomial at a number after shifting by a given 
    // phase.
    _eval: function(x, phase) {
      var acc, i
      phase = phase || 0
      acc = 0
      for(i = 0; i <= this.degree; i++) {
        acc += _coefs[i] * Math.sin(2 * i * Math.PI * (x - phase))
      }
      return acc
    },

    // Evaluate teh polynomial at an array after shifting a given 
    // pahse.
    eval: function(xs, phase) {
      that = this
      var ys = xs.map(function(x) {return that._eval(x, phase)})
      that = null // Destruct
      return ys
    },

  }
}

var _runif = function(low, high) {
    return (high - low) * Math.random() + low
}

var randomPolynomial = function(degree) {
    var coefs = []
    for(var i = 0; i <= degree; i++) {
        coefs.push(_runif(-1, 1))
    }
    //coefs = coefs.sort(function(a, b) {return b - a})
    console.log(coefs)
    return new FourierPolynomial(coefs)
}

module.exports = smoothers;

};
BundleModuleCode['plugins/ml/reg']=function (module,exports){
/* https://github.com/chen0040/js-regression */
var jsregression = jsregression || {};

(function (jsr) {
    'use strict';
	var LinearRegression = function (config) {
        config = config || {};
        
        if (!config.iterations) {
            config.iterations = 1000;
        }
        if (!config.alpha) {
            config.alpha = 0.001;
        }
        if (!config.lambda) {
            config.lambda = 0.0;
        }
        if(!config.trace) {
            config.trace = false;
        }
        
        this.iterations = config.iterations;
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.costThres = config.cost||0;
        this.errorThres = config.error||0;
        this.trace = config.trace;
        this.dynamic = config.dynamic;  // dynamic alpha rate
    };
    
    LinearRegression.prototype.fit = function (data) {
        var N = data.length, X = [], Y = [];
        this.dim = data[0].length;

    
        for (var i=0; i < N; ++i) {
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j) {
                x_i.push(row[j]);
            }
            Y.push(y_i);
            X.push(x_i);
        }
        
        this.theta = [];
        
        for (var d = 0; d < this.dim; ++d) {
            this.theta.push(0.0);
        }
        
        var cost,lastCost=0, lastVx, lastTheta, alpha=this.alpha;
        for (var k = 0; k < this.iterations; ++k) {
            var Vx = this.grad(X, Y, this.theta);
            
            for(var d = 0; d < this.dim; ++d) {
                this.theta[d] = this.theta[d] - alpha * Vx[d];
                if (isNaN(this.theta[d])) 
                 throw Error ('LinearRegression.fit: parameter overflow, probably alpha rate to high! (alpha:'+alpha+', step:'+k+')')
            }
            
            if (this.errorThres && this.error(X,Y,this.theta) < this.errorThres) break;
            if (this.costThres && this.cost(X,Y,this.theta) < this.costThres) break;
            if (this.dynamic) {
              // experimental dynamic aloha rate adaptation
              if (lastVx) {
                var gMax=0, gradVx = lastVx.map(function (vx,index) {
                  var g = Math.abs(Vx[index]/vx);
                  gMax = Math.max(gMax,g)
                  return g
                })
                // if some gradVx > XX then lower alpha
                if (gMax > 2) {
                  alpha /= 2;
                } else if (gMax < 1 && (1-gMax) < 0.01) alpha *= 2;
              }
              lastVx = Vx.slice();
              lastTheta = this.theta.slice();
              // console.log(alpha,Vx);
            }
            if(this.trace) {
                console.log('theta: ',this.theta)
                console.log('cost at iteration ' + k + ': ' + cost+' alpha:'+alpha);
            }
        }
        
        return {
            theta: this.theta,
            dim: this.dim,
            cost: this.cost(X, Y, this.theta),
            error: this.error(X, Y, this.theta),
            iterations : k,
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        };
    };
    
    LinearRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        
        var Vtheta = [];
        
        for(var d = 0; d < this.dim; ++d){
            var g = 0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var y_i = Y[i];
                
                var predicted = this.h(x_i, theta);
                
                g += (predicted - y_i) * x_i[d];  
            }
            
            g = (g + this.lambda * theta[d]) / N;
            
            Vtheta.push(g);
        }
        
        return Vtheta;
    };
    
    LinearRegression.prototype.h = function(x_i, theta) {
        var predicted = 0.0;
        for(var d = 0; d < this.dim; ++d) {
            predicted += x_i[d] * theta[d];
        }
        return predicted;
    }
    
    LinearRegression.prototype.cost = function(X, Y, theta) {
      
        var N = X.length;
        var cost = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            cost += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        for(var d = 0; d < this.dim; ++d) {
            cost += this.lambda * theta[d] * theta[d];
        }
        
        return cost / (2.0 * N);
    };

    LinearRegression.prototype.error = function(X, Y, theta) {
      
        var N = X.length;
        var err = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            err += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        
        return err / (N);
    };
    
    LinearRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        // x is a row vector
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    };

    LinearRegression.prototype.toFunction = function () {
      var self=this, foo;
      var fcode = 'foo=function (x) { return '
      fcode += (self.theta.map(function (p,index) {
        var xx=[]; for (var i=0;i<index;i++) xx.push('x');
        return self.theta[index]+(xx.length?'*'+xx.join('*'):'');
      }).join('+'))
      fcode += '}';
      eval(fcode);
      return foo
    }
    
    jsr.LinearRegression = LinearRegression;
    
    var LogisticRegression = function(config) {
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    }
    
    LogisticRegression.prototype.fit = function(data) {
        this.dim = data[0].length;
        var N = data.length;
        
        var X = [];
        var Y = [];
        for(var i=0; i < N; ++i){
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j){
                x_i.push(row[j]);
            }
            X.push(x_i);
            Y.push(y_i);
        }
        
        this.theta = [];
        for(var d = 0; d < this.dim; ++d){
            this.theta.push(0.0);
        }
        
        for(var iter = 0; iter < this.iterations; ++iter){
            var theta_delta = this.grad(X, Y, this.theta);
            for(var d = 0; d < this.dim; ++d){
                this.theta[d] = this.theta[d] - this.alpha * theta_delta[d];        
            }
        }
        
        this.threshold = this.computeThreshold(X, Y);
        
        return {
            theta: this.theta,
            threshold: this.threshold,
            cost: this.cost(X, Y, this.theta),
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        }
    };
    
    LogisticRegression.prototype.computeThreshold = function(X, Y){
        var threshold=1.0, N = X.length;
        
        for (var i = 0; i < N; ++i) {
            var prob = this.transform(X[i]);
            if(Y[i] == 1 && threshold > prob){
                threshold = prob;
            }
        }
        
        return threshold;
    }
    
    LogisticRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        var Vx = [];
        for(var d = 0; d < this.dim; ++d) {
            var sum = 0.0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var predicted = this.h(x_i, theta);
                sum += ((predicted - Y[i]) * x_i[d] + this.lambda * theta[d]) / N;
            }    
            Vx.push(sum);
        }
        
        return Vx;
        
    }
    
    LogisticRegression.prototype.h = function(x_i, theta) {
        var gx = 0.0;
        for(var d = 0; d < this.dim; ++d){
            gx += theta[d] * x_i[d];
        }
        return 1.0 / (1.0 + Math.exp(-gx));
    }
    
    LogisticRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    }
    
    LogisticRegression.prototype.cost = function(X, Y, theta) {
        var N = X.length;
        var sum = 0;
        for(var i = 0; i < N; ++i){
            var y_i = Y[i];
            var x_i = X[i];
            sum += - (y_i * Math.log(this.h(x_i, theta)) + (1-y_i) * Math.log(1 - this.h(x_i, theta))) / N;
        }
        
        for(var d = 0; d < this.dim; ++d) {
            sum += (this.lambda * theta[d] * theta[d]) / (2.0 * N);
        }
        return sum;
    };
    
    jsr.LogisticRegression = LogisticRegression;
    
    var MultiClassLogistic = function(config){
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    };
    
    MultiClassLogistic.prototype.fit = function(data, classes) {
        this.dim = data[0].length;
        var N = data.length;
        
        if(!classes){
            classes = [];
            for(var i=0; i < N; ++i){
                var found = false;
                var label = data[i][this.dim-1];
                for(var j=0; j < classes.length; ++j){
                    if(label == classes[j]){
                        found = true;
                        break;
                    }
                }
                if(!found){
                    classes.push(label);
                }
            }
        }
        
        this.classes = classes;
        
        this.logistics = {};
        var result = {};
        for(var k = 0; k < this.classes.length; ++k){
            var c = this.classes[k];
            this.logistics[c] = new jsr.LogisticRegression({
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations
            });
            var data_c = [];
            for(var i=0; i < N; ++i){
                var row = [];
                for(var j=0; j < this.dim-1; ++j){
                    row.push(data[i][j]);
                }
                row.push(data[i][this.dim-1] == c ? 1 : 0);
                data_c.push(row);
            }
            result[c] = this.logistics[c].fit(data_c);
        }
        return result;
    };
    
    MultiClassLogistic.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        
        
        var max_prob = 0.0;
        var best_c = '';
        for(var k = 0; k < this.classes.length; ++k) {
            var c = this.classes[k];
            var prob_c = this.logistics[c].transform(x);
            if(max_prob < prob_c){
                max_prob = prob_c;
                best_c = c;
            }
        }
        
        return best_c;
    }
    
    
    
    jsr.MultiClassLogistic = MultiClassLogistic;

})(jsregression);

var module = module || {};
if(module) {
	module.exports = jsregression;
}
};
BundleModuleCode['plugins/math/data-bin']=function (module,exports){
// https://github.com/mhyfritz/bin-data

// included from https://github.com/d3/d3-array/tree/main/src
var pickRepresentatives = {
  max:function max(values, valueof) {
    var max;
    if (valueof === undefined) {
      for (const value of values) {
        if (value != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    }
    return max;
  },
  mean:function mean(values, valueof) {
    var count = 0;
    var sum = 0;
    if (valueof === undefined) {
      for (var value of values) {
        if (value != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    }
    if (count) return sum / count;
  },
  min:function min(values, valueof) {
    var min;
    if (valueof === undefined) {
      for (var value of values) {
        if (value != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    }
    return min;
  }
}
function bin(data, numChunks, pickRepresentative ) {
  if (typeof pickRepresentative=='string') pickRepresentative=pickRepresentatives[pickRepresentative];
  pickRepresentative=pickRepresentative|| pickRepresentatives.max
  if (!Array.isArray(data)) {
    data = Array.from(data);
  }

  var chunks = chunk(data, numChunks);
  return chunks.map(chunk => pickRepresentative(chunk.data));
}

function chunk(data, numChunks) {
  var chunks = new Array(numChunks);
  var binSize = data.length / numChunks;

  for (var i = 0, start = 0, end = 0; i < numChunks; i += 1) {
    end = Math.round((i + 1) * binSize);
    var slice = data.slice(start, end);
    chunks[i] = {
      start,
      end: end - 1,
      data: slice
    };
    start = end;
  }

  return chunks;
}

module.exports = bin;
};
BundleModuleCode['plugins/math/matja']=function (module,exports){
// MatLab math compatibility and related extensions
Math.gaussian = function (x,pos,wid) {
  if(typeof(x)==='number' && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //numerator
    var num = Math.pow((x-pos),2)
    //Divison
    var res = num/den;
    //Exponent of total result
    var result = Math.exp(-res)
    return result;
  }
  else if(Utils.isArrayArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function (row) { return  row.map(function (element) { return  element - pos})});
    //numerator
     var num = sub.map(function (row) { return row.map(function (element) { return Math.pow(element,2) }) });
    //Division
    var res = num.map(function (row) { return row.map(function (element) { return element/den }) });
    //Exponent of result
    var result = res.map(function (row) { return row.map(function (element) { return Math.exp(-element) }) });
    return result;
  }
  else if(Utils.isArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function(value) {
      return value - pos;
    });
    //numerator
    var num = sub.map(function (num,i) { return Math.pow(num,2) });
    ////Division
    var res = num.map(function(value) {
      return value/den;
    });
    //Exponent of result
    var result = res.map(function(value) {
      return Math.exp(-value);
    });
    return result;
  }
  else {
    throw 'EINVALID'
  } 
}


Math.sign = function (x) { return x<0?-1:x>0?1:0 }

// Sequence of numbers (discrete number ranges)
// [first:increment:second]
$S = function (first,incrementOrSecond,second) {
  if (second==undefined) return Math.sequence(first,incrementOrSecond);
  else return Math.sequence(first,second,incrementOrSecond);
}

// Right-hand side array selector
// A(first:last)
$RS = function (A,first,last) {
  if (Utils.isArray(A)) return A.slice(first,last+1)
}
// Left-hand side array selector
// A(first:last) = B
$WS = function (A,first,last,B) {
  if (Utils.isArray(A) && Utils.isArray(B)) 
    for(var i=0;i<last-first+1;i++) A[first+i]=B[i];
}

};
BundleModuleCode['plugins/math/fft']=function (module,exports){
/**
 * Fast Fourier Transform module
 * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)
 */
 
/* Version 1.3.1 */

(function() {
  var FFT= function (n,n2) { if (!(this instanceof FFT)) return new FFT(n,n2); this.init(n,n2) };           // top-level namespace
  var _root = this;  // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FFT=FFT;
  } else {
    window.FFT = FFT;
  }

  FFT.prototype = {
    init : function(n,n2) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        this._n = n;
        this._n2 = n2;
        this._initArray();
        this._makeBitReversalTable();
        this._makeCosSinTable();
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // 1D-FFT
    fft1d : function(re, im) {
      if (Utils.isArray(re))
        this.fft(re, im, 1);
      else if (Math.Vector.isVector(re)) 
        this.fft(re.data,im.data,1);
      else if (Math.VectorTA.isVector(re)) 
        this.fft(re.data,im.data,1);      
    },
    // 1D-IFFT
    ifft1d : function(re, im) {
      var k = 1/this._n;
      this.fft(re, im, -1);
      for(var i=0; i<this._n; i++) {
        re[i] *= k;
        im[i] *= k;
      }
    },
    // 2D-FFT
    fft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      if (Utils.isArray(re) && !Utils.isArrayArray(re)) {
        // x-axis
        for(var y=0; y<this._n; y++) {
          i = y*this._n;
          for(var x1=0; x1<this._n; x1++) {
            tre[x1] = re[x1 + i];
            tim[x1] = im[x1 + i];
          }
          this.fft1d(tre, tim);
          for(var x2=0; x2<this._n; x2++) {
            re[x2 + i] = tre[x2];
            im[x2 + i] = tim[x2];
          }
        }
        // y-axis
        for(var x=0; x<this._n; x++) {
          for(var y1=0; y1<this._n; y1++) {
            i = x + y1*this._n;
            tre[y1] = re[i];
            tim[y1] = im[i];
          }
          this.fft1d(tre, tim);
          for(var y2=0; y2<this._n; y2++) {
            i = x + y2*this._n;
            re[i] = tre[y2];
            im[i] = tim[y2];
          }
        }
      } else if (Utils.isArrayArray(re) || Math.Matrix.isMatrix(re)) {
        // TODO
      } else if (Math.MatrixTA.isMatrix(re)) {
        // TODO
      }
    },
    // 2D-IFFT
    ifft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<this._n; y++) {
        i = y*this._n;
        for(var x1=0; x1<this._n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        this.ifft1d(tre, tim);
        for(var x2=0; x2<this._n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<this._n; x++) {
        for(var y1=0; y1<this._n; y1++) {
          i = x + y1*this._n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        this.ifft1d(tre, tim);
        for(var y2=0; y2<this._n; y2++) {
          i = x + y2*this._n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // core operation of FFT
    fft : function(re, im, inv) {
      var d, h, ik, m, tmp, wr, wi, xr, xi,
          n4 = this._n >> 2;
      // bit reversal
      for(var l=0; l<this._n; l++) {
        m = this._bitrev[l];
        if(l < m) {
          tmp = re[l];
          re[l] = re[m];
          re[m] = tmp;
          tmp = im[l];
          im[l] = im[m];
          im[m] = tmp;
        }
      }
      // butterfly operation
      for(var k=1; k<this._n; k<<=1) {
        h = 0;
        d = this._n/(k << 1);
        for(var j=0; j<k; j++) {
          wr = this._cstb[h + n4];
          wi = inv*this._cstb[h];
          for(var i=j; i<this._n; i+=(k<<1)) {
            ik = i + k;
            xr = wr*re[ik] + wi*im[ik];
            xi = wr*im[ik] - wi*re[ik];
            re[ik] = re[i] - xr;
            re[i] += xr;
            im[ik] = im[i] - xi;
            im[i] += xi;
          }
          h += d;
        }
      }
    },
    // returns spectrum of signal array
    signalSpectrum : function (data,islog,norm,scale) {
      var re=data.slice(),
          im = data.map(function () { return 0 });
      this.fft1d(re,im);
      return this.spectrum(re,im,islog,norm,scale).slice(0,data.length/2);
    },
    // returns shifted spectrum array of signal input array
    signalSpectrumWindow : function (data,islog,norm,scale) {
      var res=[];
      for(var off=0;off<(data.length-this._n);off++) {
        var re = data.slice(off,off+this._n),
            im = re.map(function () { return 0 });
        this.fft1d(re,im);
        res.push(this.spectrum(re,im,islog,norm,scale).slice(0,this._n/2)); 
      }
      return res;
    },
    // returns amplitude spectrum array from re/im fft output
    spectrum : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
     // returns phase spectrum
    phase : function (re,im,islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          n2 = this._n*(this._n2||1),
          log = Math.log,
          atan = Math.atan;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(atan(im[i]/re[i]));
        } else {
          spectrum[i] = atan(im[i]/re[i]);
        }
      }
      return spectrum;
    },
    // returns power spectrum
    power : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log((re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = (re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
    // initialize the array (supports TypedArray)
    _initArray : function() {
      if(typeof Uint8Array !== 'undefined') {
				if(this._n<=256)
                                        this._bitrev = new Uint8Array(this._n);
				else if(this._n<=65536)
					this._bitrev = new Uint16Array(this._n);
				else
					this._bitrev = new Uint32Array(this._n);
      } else {
        this._bitrev = [];
      }
      if(typeof Float64Array !== 'undefined') {
        this._cstb = new Float64Array(this._n*1.25);
      } else {
        this._cstb = [];
      }
    },
    // zero padding
    _paddingZero : function() {
      // TODO
    },
    // makes bit reversal table
    _makeBitReversalTable : function() {
      var i = 0,
          j = 0,
          k = 0;
      this._bitrev[0] = 0;
      while(++i < this._n) {
        k = this._n >> 1;
        while(k <= j) {
          j -= k;
          k >>= 1;
        }
        j += k;
        this._bitrev[i] = j;
      }
    },
    // makes trigonometiric function table
    _makeCosSinTable : function() {
      var n2 = this._n >> 1,
          n4 = this._n >> 2,
          n8 = this._n >> 3,
          n2p4 = n2 + n4,
          t = Math.sin(Math.PI/this._n),
          dc = 2*t*t,
          ds = Math.sqrt(dc*(2 - dc)),
          c = this._cstb[n4] = 1,
          s = this._cstb[0] = 0;
      t = 2*dc;
      for(var i=1; i<n8; i++) {
        c -= dc;
        dc += t*c;
        s += ds;
        ds -= t*s;
        this._cstb[i] = s;
        this._cstb[n4 - i] = c;
      }
      if(n8 !== 0) {
        this._cstb[n8] = Math.sqrt(0.5);
      }
      for(var j=0; j<n4; j++) {
        this._cstb[n2 - j]  = this._cstb[j];
      }
      for(var k=0; k<n2p4; k++) {
        this._cstb[k + n2] = -this._cstb[k];
      }
    }
  };
}).call(this);

/**
 * Spatial Frequency Filtering
 * High-pass/Low-pass/Band-pass Filter
 * Windowing using hamming window
 */
(function() {
  var FrequencyFilter={};  // top-level namespace
  var _root = this;     // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FrequencyFilter=FrequencyFilter;
  } else if(typeof exports !== 'undefined') {
    FrequencyFilter = exports;   // for CommonJS
  } else {
    FrequencyFilter = _root.FrequencyFilter = {};
  }

  // core operations
  var _n = 0;
  var core = {
    init : function(n) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        _n = n;
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // swaps quadrant
    swap : function(re, im) {
      var xn, yn, i, j, k, l, tmp,
          len = _n >> 1;
      for(var y=0; y<len; y++) {
        yn = y + len;
        for(var x=0; x<len; x++) {
          xn = x + len;
          i = x + y*_n;
          j = xn + yn*_n;
          k = x + yn*_n;
          l = xn + y*_n;
          tmp = re[i];
          re[i] = re[j];
          re[j] = tmp;
          tmp = re[k];
          re[k] = re[l];
          re[l] = tmp;
          tmp = im[i];
          im[i] = im[j];
          im[j] = tmp;
          tmp = im[k];
          im[k] = im[l];
          im[l] = tmp;
        }
      }
    },
    // applies High-Pass Filter
    HPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Low-Pass Filter
    LPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r > radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Band-Pass Filter
    BPF : function(re, im, radius, bandwidth) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius || r > (radius + bandwidth)) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // windowing using hamming window
    windowing : function(data, inv) {
      var len = data.length,
          pi = Math.PI,
          cos = Math.cos;
      for(var i=0; i<len; i++) {
        if(inv === 1) {
          data[i] *= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        } else {
          data[i] /= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        }
      }
    }
  };
  // aliases (public APIs)
  var apis = ['init', 'swap', 'HPF', 'LPF', 'BPF', 'windowing'];
  for(var i=0; i<apis.length; i++) {
    FrequencyFilter[apis[i]] = core[apis[i]];
  }
}).call(this);

/**
 * FFT Power Spectrum Viewer
 */
(function() {
  var SpectrumViewer={};  // top-level namespace
  var _root = this;    // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.SpectrumViewer=SpectrumViewer;
  } else if(typeof exports !== 'undefined') {
    SpectrumViewer = exports;   // for CommonJS
  } else {
    SpectrumViewer = _root.SpectrumViewer = {};
  }

  // core operations
  var _context = null,
      _n = 0,
      _img = null,
      _data = null;
  var core = {
    init : function(context) {
      _context = context;
      _n = context.canvas.width,
      _img = context.getImageData(0, 0, _n, _n);
      _data = _img.data;
    },
    // renders FFT power spectrum on the canvas
    render : function(re, im, islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = _n*_n,
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(Math.sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      for(var j=0; j<n2; j++) {
        spectrum[j] = spectrum[j]*255*imax;
      }
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x=0; x<_n; x++) {
          val = spectrum[i + x];
          p = (i << 2) + (x << 2);
          _data[p] = 0;
          _data[p + 1] = val;
          _data[p + 2] = val >> 1;
        }
      }
      _context.putImageData(_img, 0, 0);
    }
  };
  // aliases (public APIs)
  SpectrumViewer.init = core.init;
  SpectrumViewer.render = core.render;
}).call(this);
};
BundleModuleCode['plugins/math/conv']=function (module,exports){
/*
** Convolution and correlation of vectors and matrix objects
** using FFT
*/
function setup(a,b) {
  var N = a.length,
      M = Math.pow(2,Math.ceil(Math.log2(N))),
      N2  = M*2;
  var data1 = a.data?a.toArray():a,
      data2 = b.data?b.toArray():b;
  if (N!=M) {
    data1=data1.pad(M);
    data2=data2.pad(M);
  }
  var fft   = Math.FFT.FFT(N2);
  var re1   = data1.pad(N2,0);
  var im1   = Array.init(re1.length);
  fft.fft1d(re1,im1);
  var re2   = data2.pad(N2,0);
  var im2   = Array.init(re2.length);
  fft.fft1d(re2,im2);
  return {
    fft:fft,
    reA:re1,
    imA:im2,
    reB:re2,
    imB:im2
  }
}
Convolution = {
  convolute1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('convolute: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB);
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.add(im).slice(0,N),
          ca = Convolution.correlate1d(a,a), // ??
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.add(im).slice(0,N)
  },
  correlate1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('correlate: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB.mul(-1));
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.sub(im).slice(0,N),
          ca = Convolution.correlate1d(a,a),
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.sub(im).slice(0,N)
  }
}

module.exports = Convolution;
};
BundleModuleCode['plugins/db/db.js']=function (module,exports){
if (typeof window != 'undefined') alert('db.lib: Browser target not supported!');
Require('plugins/com/utils')
Require('./db')
Require('./db.sql')
Require('./db.sqlds')
Require('./db.sqldoc')
Require('./db.sqlproj')


};
BundleModuleCode['plugins/com/utils']=function (module,exports){
var fs      = require('fs');
var http    = require('http');
var deasync = require('deasync');
var util    = require('util');
try { var crypto = require("crypto") } catch (e) { }
var https;
try { https=require('https') } catch (e) {};

JSONfn = Require('plugins/com/jsonfn');

if (typeof print == 'undefined') print=console.log;

function POST(url, data, cb) {
  var params,headers;
  if (data && data.params && data.data != undefined) {
    params=data.params;
    headers=data.headers;
    data=data.data;
  }
  var ishttps= url.match(/https:/);
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  var post_data = typeof data == 'string'?data:JSONfn.stringify(data);
  var post_options = {
      host: host,
      port: port,
      path: '/'+path+params,
      method: 'POST',
      keepAlive: true,
      headers: headers || {
          'Content-Type': 'application/json', // ?? 'application/x-www-form-urlencoded',
          // 'Content-Length': Buffer.byteLength(post_data)
          'Content-Length': post_data.length,
      }
  };
  // console.log('POST', post_options,post_data)
  var post_req = (ishttps?https:http).request(post_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('POST: ',result);
        } catch (e) { print(data); result=e; }
        if (cb) cb(result);
      });
  });
  post_req.on('error',function (err) {
    if (cb) cb(err); else console.log(url,err)
  });
  post_req.setNoDelay();
  // console.log('POST: ',post_data);
  // post the data
  post_req.write(post_data);
  post_req.end();
}
var POSTsync = deasync(function(url,data,cb) {
  POST(url,data,function (result) {
    cb(null,result);
  })
})

function GET(url,params, cb) {
  var ishttps= url.match(/https:/)!=null;
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  path += params; 
  // print(host,path,port,ishttps)
  var get_options = {
      host: host,
      port: port,
      path: path,
      method: 'GET',
      keepAlive: true,
      headers: {
          // 'Content-Type': 'application/x-www-form-urlencoded',
      }
  };
  // console.log('GET', post_options,post_data)
  var get_req = (ishttps?https:http).request(get_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('GET: ',result);
        } catch (e) { result=e; }
        if (cb) cb(result);
      });
  });
  get_req.on('error',function (err) {
    // console.log(err)
    if (cb) cb(err); else console.log(url,err);
  });
  get_req.setNoDelay();
  // get_req.write();
  get_req.end();
}
var GETsync = deasync(function(url,params,cb) {
  GET(url,params,function (result) {
    cb(null,result)
  })
})

Common = {
  existFile: function (file) {
    try {
      var stat=fs.statSync(file);
      return stat?true:false;
    } catch (e) {
      return false;
    }
  },
  loadFile: function (file,callback) {
    try {
      var text = fs.readFileSync(file,'utf8');
      // var data = JSONfn.parse(text);
      if (callback) return callback(text);
      else return text;
    } catch (e) {
      if (callback) return callback(data);
      else return e
    }
  },
  saveFile: function (data,file,mimetype) {
    try {
      var data = typeof data=='string'?data:JSONfn.stringify(data);
      return fs.writeFileSync(file,data,'utf8');
    } catch (e) {
      return e
    }
  }
}

Utils = {

  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  deserialize : function (data) {
    return JSONfn.deserialize(data)
  },

  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  format : function (args) {
    // format array of arguments like console.log
    var s='',sep='';
    for(var i in args) {
      switch (typeof args[i]) {
        case 'number':
        case 'string':
        case 'boolean':
          s += (sep+args[i]);
          break;
        case'function':
          s += (sep+'[Function]');
          break;
        case'object':
          s += (sep+util.inspect(args[i]));
          break;
      }
      sep = ' ';
    }
    return s;
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*\([^\)]+\))/)[1];
    }
  },

  inspect : Require('util').inspect,

  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isArrayArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]) &&
                Utils.isArray(o[0][0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isBufferArray : function (o) {
    return (typeof ArrayBuffer != 'undefined' && o instanceof ArrayBuffer) ||
           (typeof SharedArrayBuffer != 'undefined' && o instanceof SharedArrayBuffer) ||
           (typeof Buffer != 'undefined' && o instanceof Buffer)
  },
  isMatrix: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return (Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isNumber(o) {
      return typeof o == "boolean"
  },
  isString: function isNumber(o) {
      return typeof o == "string"
  },
  isTypedArray: function isTypedArray(o) {
      return Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },

  network : function () {
    const results = Object.create(null); // Or just '{}', an empty object
    Object.defineProperty(results, 'first', {
      value: function () {
        var keys = Object.keys(this); 
        return keys.length? this[keys[0]][0]:null
      },
      writable: false,
      enumerable : false,
    });
    try { 
      const networkInterfaces  = require('os').networkInterfaces;
      const nets = networkInterfaces();
      for (const name of Object.keys(nets)) {
          for (const net of nets[name]) {
              // Skip over non-IPv4 and internal (i.e. 127.0.0.1) addresses
              if (net.family === 'IPv4' && !net.internal) {
                  if (!results[name]) {
                      results[name] = [];
                  }
                  results[name].push(net.address);
              }
          }
      }
    } catch (e) {};
    
    return results
  },
  
  serialize : function (data) {
    return JSONfn.serialize(data)
  },

  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },

  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
    if (ftyp==Int8Array) return 'Int8Array';
    if (ftyp==Uint8Array) return 'Uint8Array';
    if (ftyp==Int16Array) return 'Int16Array';
    if (ftyp==UInt16Array) return 'Uint16Array';
    if (ftyp==Int32Array) return 'Int32Array';
    if (ftyp==UInt32Array) return 'Uint32Array';
    if (ftyp==Float32Array) return 'Float32Array';
    if (ftyp==Float64Array) return 'Float64Array';
  },
  DataSize : {
    Int8:1,
    Uint8:1,
    Int16:2,
    Uint16:2,
    Int32:4,
    Uint32:4,
    Float32:4,
    Float64:4,
    Boolean:1,
    Number:8,  
  },

  uniqueID : function (length) {
    var s='',
        keys=['a','b','c','d','e','f','g','h','i','j','k','l','m','n',
              'o','p','q','r','s','t','u','v','w','x','y','z'];
    keys=keys.concat(keys,keys.map(function (k) { return k.toUpperCase() }));
    keys=keys.concat(['0','1','2','3','4','5','6','7','8','9']);
    if (typeof crypto == 'undefined') {
      for(var i=0;i<length;i++) {
        var b = (Math.random()*255)|0;
        s+= (keys[b%keys.length]);
      }
    } else {
      if (crypto.getRandomValues) { 
        var rav = new Uint8Array(length);
        crypto.getRandomValues(rav);
      }
      if (crypto.randomBytes) {
        var rav = crypto.randomBytes(length);
      } 
      for(var i=0;i<length;i++) {
        s+= (keys[rav[i]%keys.length]);
      };
    }
    return s;
  },
 
  UUIDv4 : function uuidv4() {
    if (typeof crypto != "undefined" && crypto.getRandomValues) { 
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    if (typeof crypto != "undefined" && crypto.randomBytes) { 
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.randomBytes(1)[0] & 15 >> c / 4).toString(16)
      );
    }
  },

  GET: function (url,params,cb) {
    if (!cb) return GETsync(url,params);
    else return GET(url,params,cb);
  },
  
  POST: function (url,data,cb,sync){
    if (!cb) return POSTsync(url,data);
    else return POST(url,data,cb);
  },

  version: '1.2.4'
}


Object.addProperty = function (obj,name,fun) {
  if (obj.prototype[name]) return;
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

Object.updateProperty = function (obj,name,fun) {
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

// Array static methods extensions
if (!Array.create) Array.create = function(length,init) {
      var arr = [], i = length;
      while (i--) {
        arr[i] = init;
      }
      return arr;
  }

if (!Array.matrix) Array.matrix = function (rows,cols,init) {
  if (init==undefined) init=0;
  var mat=[];
  for(var i=0;i<rows;i++) {
    var row=[];
    for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
    mat.push(row);
  }
  return mat;
};

// Array prototype extensions
Object.addProperty(Array,'last',function () { return this[this.length-1] });

// String static methods extensions
if (!String.create) String.create = function(size,init) {
      var i, s='';
      init=init||' ';
      for(i=0;i<size;i++) s=s+init;
      return s;
};
if (!String.copy) String.copy = function(src) {
      var i,dst='';
      for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
      return dst;
}; 
if (!String.get) String.get = function (str,index) {
      return str.charAt(index);
}
if (!String.hex) String.hex = function (n,len) {
      // format a hexadecimal number with 'len' figures.
      switch (len) {
          case 2: return (((n>>4) & 0xf).toString(16))+
                          ((n&0xf).toString(16));
          case 4: return (((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 6: return (((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 8: return (((n>>28) & 0xf).toString(16)+
                          ((n>>24) & 0xf).toString(16)+
                          ((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          default: return 'format_hex??';
      }
}; 
if (!String.set) String.set = function (str,index,char) {
  return str.substr(0, index) + char + str.substr(index+1)
}
// String prototype extensions
Object.addProperty(String,'contains', function (el) {
  return this.includes(el)
})
Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
});


};
BundleModuleCode['./db']=function (module,exports){
// A virtual JSON database file system
/* type entry = { kind:'object'|'table'|'db'|'fs'|'file'|'data'|'dir'|'matrix', 
                 data?:buffer|string,  url?:string,
                 name:string, mimetype?:string, meta?:{}, path?:string, }
   type mimetype = 
    'application/octet-stream' |
    'text/plain'
   ..

   SQL (entry='db')
      
   Hierarchical Structuring
   
   type HdFTable = Column {
    id: integer primary key,
    type: integer,
    mimetype: varchar(128),
    createTime: integer,
    lastModTime: integer,
    size: integer,
    name: varchar(512),
    parent: integer,
    meta: varchar (),
    data: blob
   } with Column.fsType = 0:directory,1:file,2:meta,3:table, (4:dataset,5:group)
     
   Meta Data for datasets (YAML format):
    dataspace :
       dimensions : [x,y,..]
    datatype : string | integer | int16 | ..
    attribute1 : ..
   
   type ProjTable = Column {
     id: varchar()|integer,
     type:integer is project or folder,    
     name: varchar(1000),
     description: varchar(1000),
     time: varchar()|integer,
     data: blob|varchar(1000000) is project or folder,
   } with Column.type = 0:directory,1:document
   
   type DocTable = Column {
     id: integer primary key,
     type:integer,
     mimetype: varchar(100),
     description: varchar(65000),
     template: varchar(65000),
     size:integer,
     time:integer,
     content:blob|varchar(1000000)
   } with Column.type = 0:directory,1:document,2:media

  
  Hierarchical DataSet Organisation
  --------------------------------- 
  
  meta data: { datatype:string,dataspace:number [], index?:number, chunk?:[] }
  type DataSetTable = Column {
     id         : integer primary key,
     type       : integer,  --  0:group, 1:direct data, 2:indirect, referenced indexed DataTable
     name       : varchar(),
     time       : integer,
     meta       : varchar(), -- YAML/JSON
     data       : blob|integer|varchar() -- DataTable name or serialized data
   }
   type DataTable = Columns {
     index      : integer primary key,
     type       : integer,  --  1:direct data, 2: indirect data, referenced indexed DataTable
     meta       : varchar(), -- optional, YAML/JSON, for chunks ?
     data       : blob,  
   }
   
  JSON API
  ========
  
  type table = {
    table : key string,
    meta?: {},
    rows : dataset|datagroup|data []
  }
  type dataset = {
    data : key string,
    meta : {},
    dataspace : number [] | [],
    datatype : datatype,
    data : []
  }
  type datagroup = {
    group : key string,
    meta? : {},
    rows : dataset | datagroup [],
  }
  
  type datatype = 'number' | 'float32' | 'float64' | 'int8' | 'int16' | 'int32' | ..
                  'json' | 'string' | 'object'
  type url = string with format "host:port" | "host:port:key1:key2:.." 
*/


DB = {
  // Multiple API views can exist for one physical SQL DB! (sql,sqlfs,sqlproj,sqldoc)
  addDB   : function (path,url,flags) {
    var db;
    var pel = path.split('/'),
        root=DB.store,
        entry;
    if (pel.length==1) entry=path;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[entry]) return new Error('EEXIST');
    if ((!url || url==':memory:') && SQL) {
      db = new SQL.Database();
      root.nodes[entry] = {
        kind  : 'db',
        db    : db,
        name  : entry,
        time  : DB.time(),
        id    : db.db,
        flags : flags||'',
        exec : {
          // TODO
          create: function () {},
          select: function () {},
        }
      }
    } else {
      var db
      if (!flags) db = DB.sql(url);
      else if (flags.indexOf('sqlproj')==0) db = DB.sqlproj(url);
      else if (flags.indexOf('sqlfs')==0)   db = DB.sqlfs(url);
      else if (flags.indexOf('sqldoc')==0)  db = DB.sqldoc(url);
      // Remote SQL DB
      root.nodes[entry] = {
        kind  : 'db',
        name  : entry,
        url   : url,
        time  : DB.time(),
        flags : flags||'',
        exec  : db,
      }
    }
    return root.nodes[entry];
  },
  
  // Add a dataset root table with sqlds API
  addDS : function (path,url,table) {
    var pel = path.split('/'),
        root=DB.store,
        node;
    if (pel.length==1) file=path;
    else {
      node=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[node]) return new Error('EEXIST');
    var db=DB.sqlds(url,table,{});
    // Remote SQL DB
    root.nodes[node] = {
        kind  : 'db',
        name  : node,
        url   : url,
        time  : DB.time(),
        flags : 'sqldataset',
        exec  : db,
      }
    return root.nodes[node];    
  },

  // add JSONfs API (local FS server)
  addFS : function (path,url,flags) {
    var pel = path.split('/'),
        root=DB.store,
        entry;
    if (pel.length==1) entry=path;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[entry]) return new Error('EEXIST');
    // Remote WEX Server
    root.nodes[entry] = {
        kind  : 'fs',
        name  : entry,
        url   : url,
        time  : DB.time(),
        flags : flags||'',
        exec  : DB.wex(url),
    }
    return root.nodes[entry];
  },
  
  addData : function (path,data,meta) {
    var pel = path.split('/'),
        root=DB.store,
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[file]) return new Error('EEXIST');
    root.nodes[file] = {
      kind : 'data',
      data : data,
      size : 0,
      time : DB.time(),
      merta : meta ||{},
      name : file,
    }
    return root.nodes[file];
  },
  
  addFile : function (path,data,mimetype) {
    var pel = path.split('/'),
        root=DB.store,
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[file]) return new Error('EEXIST');
    root.nodes[file] = {
      kind : 'file',
      data : data,
      size : data.length||0,
      time : DB.time(),
      mimetype : mimetype||(typeof data=='string'?'text/plain':'application/javascript'),
      name : file,
    }
    return root.nodes[file];
  },

  // pack generic number arrays into byte buffer (with support for array arrays)  
  array2buffer : function (array,typ,space) {
    var size=array.length,dsize=4;
    typ=typ||'uint32';
    if (!space && Utils.isArray(array[0])) {
      space=[size,array[0].length];
      if (Utils.isArray(array[0][0])) space.push(array[0][0].length);
    }
    if (space) size=space.reduce(function (a,b) { return a*b });
    if (!space) space=[size];
    switch (typ.toLowerCase()) {
        case 'number': dsize=8; break;
        case 'uint16': dsize=2; break;
        case 'uint32': dsize=4; break;
        case 'int16':  dsize=2; break;
        case 'int32':  dsize=4; break;
        case 'float32': dsize=4; break;
        case 'float64': dsize=8; break;
    }
    var b=Buffer(size*dsize);
    function set(v,off) {
      switch (typ.toLowerCase()) {
        case 'uint16':  b.writeUInt16LE(v,off); break;
        case 'uint32':  b.writeUInt32LE(v,off); break;
        case 'int16':   b.writeInt16LE(v,off); break;
        case 'int32':   b.writeInt32LE(v,off); break;
        case 'float32': b.writeFloatLE(v,off); break;
        case 'float64': 
        case 'number':
        default:
          b.writeDoubleLE(v,off); break;
      }    
    }
    var v,off=0;
    for(var i=0;i<array.length;i++) {
      switch (space.length) {
        case 1:
          v=array[i];
          set(v,off);
          off += dsize;
          break;
        case 2:
          for (var j=0;j<space[1];j++) {
            v=array[i][j];
            set(v,off);
            off += dsize;    
          }
          break;
        case 3:
          for (var j=0;j<space[1];j++) {
            for (var k=0;k<space[2];k++) {
              v=array[i][j][k];
              set(v,off);
              off += dsize;    
            }
          }
          break;
      }
    }
    return b;
  },
  
  // unpack generic number arrays from buffer (with support for array arrays)
  buffer2array : function (buffer,typ,space) {
    var dsize=4,bsize=(buffer.size||buffer.length),size,length,array=[];
    typ=typ||'uint32';
    if (buffer instanceof Array) return buffer;
    buffer=(buffer instanceof Uint8Array)?Buffer(buffer):buffer;
    if (typ=='number') dsize=8;
    else if (typ.indexOf('64')>0) dsize=8;
    else if (typ.indexOf('32')>0) dsize=4;
    else if (typ.indexOf('16')>0) dsize=2;
    else if (typ.indexOf('8')>0) dsize=1;
    typ=typ.toLowerCase();
    if (space)  size=space.reduce(function (a,b) { return a*b });
    if (!space) space=[bsize/dsize];
    if (size && (size*dsize)!=buffer.length) return new Error('EINVALID');

    function get(off) {
      switch (typ.toLowerCase()) {
        case 'uint8':   return buffer.readUInt8(off); break;
        case 'uint16':  return buffer.readUInt16LE(off); break;
        case 'uint32':  return buffer.readUInt32LE(off); break;
        case 'int8':    return buffer.readInt8(off); break;
        case 'int16':   return buffer.readInt16LE(off); break;
        case 'int32':   return buffer.readInt32LE(off); break;
        case 'float32': return buffer.readFloatLE(off); break;
        case 'float64': 
        case 'number':
        default:
          return buffer.readDoubleLE(off); break;
      }    
    }
    var v,off=0;
    for(var i=0;i<space[0];i++) {
      switch (space.length) {
        case 1:
          v=get(off);
          array[i]=v;
          off += dsize;
          break;
        case 2:
          array[i]=[];
          for (var j=0;j<space[1];j++) {
            v=get(off);
            array[i][j]=v;
            off += dsize; 
          }
          break;
        case 3:
          array[i]=[];
          for (var j=0;j<space[1];j++) {  
            array[i][j]=[];
            for (var k=0;k<space[2];k++) {
              v=get(off);
              array[i][j][k]=v;
              off += dsize;    
            }
          }
          break;
      }
    }

    return array;
  },

  basename : function (path,extension) {
    if (path[path.length-1]=='/') return '/';
    return extension?
            path.split('/').reverse()[0].replace(RegExp(extension.replace(/\./,'\\.')+'$'),'')
            :
            path.split('/').reverse()[0];
  },
  
  config : {
    // standard default ports
    ports : {
      sqldoc  : 5558, 
      sqlproj : 5550,
    }
  },
  
  delete : function (path,cb) {
    var pel = path.split('/'),
        root=DB.store, base='',
        entry;
    if (pel.length==1) return 0;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry] && root.nodes[entry].kind) {
      delete root.nodes[entry];
      return 1;
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (more.root.flags.contains('sqlproj')) {
            if (more.remains[0]=='projects') more.remains.shift();
            return more.root.exec.delete('/'+more.remains.concat([entry]).join('/'),cb);
          }
          if (more.root.flags.contains('sqldoc')) {
            return more.root.exec.delete('/'+more.remains.concat([entry]).join('/'),cb);
          }
          if (more.remains[0]=='tables') {
            result = root.exec.drop(entry);
            if (!result || result.error) return 0;
            else return 1;
          }
          break;
      }
    }
    return 0;
  },
  
  dirname : function (path) {
    var el=path.split('/');
    el.pop();
    return el.join('/');
  },
  
  error : function (result) {
    try {
      if (typeof result == 'number') return result>=0?false:new Error(result);
      if (!result) return new Error('EIO');
      if (result instanceof Error) return result;
      if (typeof XMLHttpRequestException != 'undefined' &&
          result instanceof XMLHttpRequestException) return new Error(result.message);
      if (typeof result == 'string' && result.indexOf('Error')!=-1) return new Error(result);
      if (result.error) return new Error(result.error);
      if (result.fs) result=result.fs;
      result=result[Object.keys(result)[0]];
      if (!result) return false;
      if (result.error) return new Error(result.error);
      else return false;
    } catch (e) {
      console.log(e,result);
      return e;
    }
  },
  
   
  fok : function (cb) {
    return function (result) { cb(DB.ok(result)) };
  },
  
  // Convert matrix to sql row [dataspace,datatype,layout,data]
  fromMatrix : function (mat,options) {
    options=options||{}
    if (Math.MatrixTA && mat instanceof Math.MatrixTA) {
      return Object.assign({
        dataspace:JSON.stringify(mat.dataspace),
        datatype:mat.datatype,
        layout:mat.layout,
        data:DB.toBuffer(mat)
      },options)
    }
  },
  // Convert matrix to sql row [dataspace,datatype,data]
  fromVector : function (vec,options) {
    options=options||{}
    if (Math.VectorTA && vec instanceof Math.VectorTA) {
      return Object.assign({
        dataspace:JSON.stringify(vec.dataspace),
        datatype:vec.datatype,
        layout:1,
        data:DB.toBuffer(vec)
      },options)
    }
  },
  
  init : function () {
    if (typeof SQL != 'undefined') {
      var db = new SQL.Database();
    }
  },
  
  list : function (path,root,cb) {
    var pel = path.split('/'),
        base='',head=path.charAt(0),
        result;
    root=root||DB.store;
    if (pel.length==2 && pel[0]=='' && pel[1]=='')
      return root.nodes;
    else {
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (pel.length==0 && root && root.nodes)
      return root.nodes;
    else if (root) {
      var more = { remains:pel, base:base, root:root };
      if (more.root.kind == 'db') {
        if (more.root.flags.contains('sqlproj')) {
          return more.root.exec.list('/'+more.remains.join('/'),cb);
        }
        if (more.root.flags.contains('sqldoc')) {
          return more.root.exec.list('/'+more.remains.join('/'),cb);
        }
      }
    }
    return new Error('ENOTFOUND');
  },
  
  // Resolve path and return entry descriptor
  // db:          { kind:'dir',name,time,nodes:[] } 
  // sql/tables:  { tables : [], url }  
  // sql:         { kind:'db', name, time, url, exec} 
  // fs:          { name,dir,size,time, nodes?:[] }
  // error:       null|error string
  lookup: function (path,root,cb) {
    var pel = path.split('/'),
        base='',head=path.charAt(0),
        entry, result;
    root=root||DB.store;
    if (pel.length==1) entry=pel[0];
    else if (pel.length==2 && pel[0]=='' && pel[1]=='')
      return root;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    
    if (pel.length==0 && root && root.nodes)
      return root.nodes[entry];
    else {
      pel.push(entry);
      var more = { remains:pel, base:base, root:root };
      if (more.root.kind == 'db') {
        switch (more.remains[0]) {
          case 'tables':
            if (!more.remains[1]) {
              var tables = more.root.exec.tables();
              return { tables : Utils.isArray(tables)?tables.map(function (name) {
                return {
                  name:name,
                  schema:more.root.exec.schema(name)
                }
              }):tables, url:more.root.url};
            } else if (more.remains.length==2) 
              return more.root.exec.select(more.remains[1],'*'); 
            break;
          case 'projects':
            return more.root.exec.select('ProjTable','*');
          case 'documents':
            return more;
          default:
            if (more.root.flags.contains('sqlproj')) {
              return more.root.exec.lookup('/'+more.remains.join('/'),cb);               
            }
            return more;
        }
      }  
      if (more.root.kind == 'fs' && more.root.exec) {
        if (cb) {
        
        } else {
          result = more.root.exec.lookup('/'+more.remains.join('/'));
          if (Utils.isObject(result) && result.dir) {
            result.nodes = more.root.exec.list('/'+more.remains.join('/'));
            if (result.nodes.files || result.nodes.dirs) 
              result.nodes=result.nodes.dirs.concat(result.nodes.files);
          }
        }
        return result;
      }
    }
    return new Error('ENOTFOUND');
  },
  
  mimeType: function (data) {
    if (typeof data == 'string')
      return data.replace(/[^\x20-\x7E\n\r\t\s]+/g, '').length==data.length?
              'text/plain':'application/octet-stream';
    else {
      for(var i=0;i<data.length;i++) {
        if ((data[i]<0x20 || data[i]>0x7e) && 
            data[i] != 0x0a && 
            data[i] != 0x0d && 
            data[i] != 0x09) return 'application/octet-stream'; 
      }
      return 'text/plain';
    }
  },
  
  
  mkdir : function (path,root,cb) {
    var pel = path.split('/'),
        root=root||DB.store,
        base='',
        entry;
    if (pel[0]=='') pel=pel.slice(1);
    while (pel.length) {
      base += ('/'+pel[0]);
      if (root && root.nodes[pel[0]] && root.nodes[pel[0]].kind != 'dir') {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
        break;
      } else if (!root.nodes[pel[0]]) root.nodes[pel[0]]={
        kind:'dir',
        time : Date(),
        nodes:{}
      }
      root=root.nodes[pel[0]];
      pel=pel.slice(1);
    }
    if (pel.length==0) return 1;
    
    if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc')) {
            return root.exec.mkdir('/'+more.remains.join('/'),null,cb);
          }
          break;
      }
      return 0;
    } else return 1;

  },
    
  ok : function (result) {
    if (!result) return new Error('ENOTFOUND');
    if (result instanceof Error) return result;
    if (typeof result=='string') return new Error(result);
    if (result.error) return new Error(result.error);
    if (result.fs) result=result.fs;
    result=result[Object.keys(result)[0]];
    if (!result) return new Error('EIO');
    if (result.error) return new Error(result.error);
    else if (result.result) return result.result;
    else return result;
  },
  
  // Read file or document
  // Returns: string|buffer|null 
  read : function (path,mimetype,cb) {
    var pel = path.split('/'),
        root=DB.store,base='',
        entry;
    if (pel.length==1) entry=pel[0];
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else
          break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry]) {
      return root.nodes[entry].data;
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc'))
            return root.exec.read('/'+more.remains.concat([entry]).join('/'),cb);
          if (pel[0]=='tables') {
            return root.exec.select(entry,'*',cb);
          }
          break;
        case 'fs':
          return root.exec.read('/'+more.remains.join('/'),entry,mimetype,cb);
          break;
      }
    }
    return null;
  },
  
  rename : function (path,name) {
    var entry=DB.basename(path),
        parent = DB.lookup(DB.dirname(path));
    if (parent && parent.nodes) {
      var node=parent.nodes[entry];
      if (node) {
        if (node.name) node.name=name;
        delete parent.nodes[entry];
        parent.nodes[name]=node;
        return node;
      }
    }
  },
  
  resolve : function (path) {
    var parts = path.split('/'),
        start = path.charAt(0),
        rparts = [];
    parts.forEach(function (part) {
      if (part=='.') return;
      if (part=='..' && rparts.length) return rparts.pop();
      else if (part=='..') return;
      rparts.push(part);
    });
    return rparts.length==1 && rparts[0]==''?start:rparts.join('/').replace(/\/\//g,'/');
  },
  
  save : function (path) {
    var pel = path.split('/'),
        root=DB.store,base='',
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (pel.length==0 && root && root.nodes) {
      var entry = root.nodes[file];
      if (!entry) return;
      if (entry.kind=='file')
        Common.saveFile(entry.data, entry.name, entry.mimetype);
      else if (entry.kind=='object')
        Common.saveFile(JSONfn.stringify(entry.data), entry.name, 'text/plain');
      else if (entry.kind=='db') {
        var tables = entry.exec.tables();
        var db = {
          tables : {}
        }
        for(var i in tables) {
          db.tables[tables[i]]={}
          db.tables[tables[i]].schema=entry.exec.schema(tables[i]);
          db.tables[tables[i]].rows=entry.exec.select(tables[i],'*');
        }
        Common.saveFile(JSONfn.stringify(db), entry.name, 'text/plain');        
      }
    } else {
    
    }
  },
  
  shortName: function (name,length,cache) {
    var chars = [],off=4;
    name=name.toUpperCase().replace(/\.[a-zA-Z0-9]+$/,'').replace(/[_,\.\~\- \/\°\$\%\!\&]/g,''); 
    if (name.length <= length) {
      chars=name.split('');
    } else {
      for(var i = 0; i < 4; i++)
        chars.push(name[i]);
      for(var i = 4; i < length; i++) {
        off += Math.max(1,((name.length-4)/(length-4))|0);
        chars.push(name[off]);      
      }
    }
    chars=chars.join('');
    var index=0;
    while (cache && cache[chars]) chars=chars.replace(/(..)$/,function (all,c) {
      var digits=index++;
      return String(Math.floor(digits/10))+String(digits%10);
    })
    if (cache) cache[chars]=1;
    return chars;;
  },
  
  store : {
    kind:'dir',
    name:'/',
    flags:'',
    time:Date(),
    nodes:{}
  },
    
  strict:false,
  
  time : function (format) {
    switch (format) {
      case 'milli':
      case 'ms':
        return Date.now();
      case 'YYYYMMDD':
        var today = new Date();
        return (today.getYear()+1900)+
               (today.getMonth()<9?'0'+(today.getMonth()+1):today.getMonth()+1)+
               (today.getDate()<10?'0'+today.getDate():today.getDate())
      case 'YYYYMMDD@HHMM':
        var today = new Date();
        return (today.getYear()+1900)+
               (today.getMonth()<9?'0'+(today.getMonth()+1):today.getMonth()+1)+
               (today.getDate()<10?'0'+(today.getDate()):today.getDate())+
               '@'+
               (today.getHours()<9?'0'+(today.getHours()+1):today.getHours()+1)+
               (today.getMinutes()<10?'0'+(today.getMinutes()):today.getMinutes())              
      default:
        return Date().toString();
    }
  },
  
  timeCompare : function (t1,t2) {
    if (isNaN(Number(t1))) t1=Date.parse(t1);
    if (isNaN(Number(t2))) t2=Date.parse(t2);
    t1=Number(t1); t2=Number(t2);
    return t1<t2?-1:(t1>t2?1:0);
  },
  
  toArray: function (buff,ftyp,dims,layout) {
    if (typeof ftyp=='string') {
      if (!/Array/.test(ftyp)) ftyp += 'Array';
      ftyp=Utils.TypedArrayOfName[ftyp];
      if (!ftyp) throw "DB.toArray: invalid ftyp argument"
    }
    var ta = DB.toTypedArray(buff,ftyp);
    if (!layout) layout=123;
    if (!ta) throw "DB.toArray: conversion of buffer to typedarray failed";
    if (!dims) dims=[ta.length];
    switch (dims.length) {
      case 1: return Array.prototype.slice.call(ta);
      case 2:
        var a=[];
        for(var i=0;i<dims[0];i++) {
          var row=[];
          for(var j=0;j<dims[1];j++) row[j]=ta[i*dims[1]+j];
          a.push(row);
        }
        return a;
    }
  },

  toBuffer : function (a,typ) {
    if (Utils.isBuffer(a)) return a;
    if (Utils.isArray(a)) {
      return DB.array2buffer(a,typ)
    }
    if (Utils.isTypedArray(a)) {
      return Buffer(a.buffer)
    }
    if (Utils.isMatrix(a,true)) {
      if (Utils.isTypedArray(a.data))
        return Buffer(a.data.buffer) // Matrix??
    }
    if (Utils.isVector(a,true)) {
      if (Utils.isTypedArray(a.data))
        return Buffer(a.data.buffer) // Matrix??
    }
  },
  
  // function toMatrix(buff:buffer,ftyp:function|datatype:string,dims:number[],layout)
  // function toMatrix(row:{rows:number,columns:number,datatype:string,data:buffer,layout?:number})
  toMatrix: function (buff,ftyp,dims,layout) {
    if (!Math.MatrixTA) return new Error('Math.MatrixTA not defined');
    if (typeof buff == 'object' && buff.rows && buff.columns && buff.datatype && buff.data) {
      // compact direct version
      var row=buff;   // returned from sqljson
      dims=[row.rows,row.columns];
      ftyp = Utils.TypedArrayOfName[row.datatype]||Utils.TypedArrayOfName[row.datatype+'Array'];
      var ta = DB.toTypedArray(row.data,ftyp);
      return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:row.layout});
    }
    if (!Utils.isArray(dims)) throw 'DB.toMatrix: invalid dimension array';
    if (typeof ftyp == 'string') {
      ftyp = Utils.TypedArrayOfName[ftyp]||Utils.TypedArrayOfName[ftyp+'Array'];
    }
    if (!Utils.isFunction(ftyp)) throw 'DB.toMatrix: invalid datatype or typedarray constructor';
    var ta = DB.toTypedArray(buff,ftyp);
    return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:layout});
  },
  
  toTypedArray: function (buff,ftyp) {
    var i,ta;
    if (buff.buffer instanceof ArrayBuffer) {
      switch (ftyp) {
        case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
        case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
        case Int8Array:    return new Int8Array((new Uint8Array(buff)).buffer);
        case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
        case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
        case Uint8Array:    return new Uint8Array((new Uint8Array(buff)).buffer);
        case Uint16Array:   return new Uint16Array((new Uint8Array(buff)).buffer);
        case Uint32Array:   return new Unt32Array((new Uint8Array(buff)).buffer);
      }
    } else if (typeof Uint8Array.from != 'undefined') {
      switch (ftyp) {
        case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
        case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
        case Int8Array:    return new Int8Array(Uint8Array.from(buff).buffer);
        case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
        case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
        case Uint8Array:   return new Uint8Array(Uint8Array.from(buff).buffer);
        case Uint16Array:   return new Uint16Array(Uint8Array.from(buff).buffer);
        case Uint32Array:   return new Uint32Array(Uint8Array.from(buff).buffer);
      }
    } else {
      // Fall-back conversion
      switch (ftyp) {
        case Float32Array: 
          ta=new Float32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readFloatLE(i*4);
          return ta;
        case Float64Array: 
          ta=new Float64Array(buff.length/8);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readDoubleLE(i*8);
          return ta;
        case Int8Array: 
          ta=new Int9Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt8(i*2);
          return ta;
        case Int16Array: 
          ta=new Int16Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt16LE(i*2);
          return ta;
        case Int32Array: 
          ta=new Int32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt32LE(i*4);
          return ta;
        case Uint8Array: 
          ta=new Uint9Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt8(i*2);
          return ta;
        case Uint16Array: 
          ta=new Uint16Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt16LE(i*2);
          return ta;
        case Uint32Array: 
          ta=new Uint32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt32LE(i*4);
          return ta;
      }
    }
  },
  
  toVector: function (buff,ftyp,dims,layout) {
    if (!Math.MatrixTA) return new Error('Math.VectorTA not defined');
    if (typeof buff == 'object' && buff.rows && buff.columns && buff.datatype && buff.data) {
      // compact direct version
      var row=buff;   // returned from sqljson
      dims=[row.rows,row.columns];
      ftyp = Utils.TypedArrayOfName[row.datatype]||Utils.TypedArrayOfName[row.datatype+'Array'];
      var ta = DB.toTypedArray(row.data,ftyp);
      return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:row.layout});
    }
    if (!Utils.isArray(dims)) throw 'DB.toVector: invalid dimension array';
    if (typeof ftyp == 'string') {
      ftyp = Utils.TypedArrayOfName[ftyp]||Utils.TypedArrayOfName[ftyp+'Array'];
    }
    if (!Utils.isFunction(ftyp)) throw 'DB.toVector: invalid datatype or typedarray constructor';
    var ta = DB.toTypedArray(buff,ftyp);
    return Math.VectorTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:layout});
  },
  
  toSQL: function (obj,schema) {
    var row={},meta= {},keys=Object.keys(obj),datatype,dataspace;

    for(var i in keys) {
      var key=keys[i],attr=obj[key];
      if (key=='meta') { meta.meta=attr; continue }
      if (Utils.isArray(attr) && Utils.isNumber(attr[0])) {
        datatype='Float32';
        dataspace=[attr.length]
        meta[key]={datatype:datatype,dataspace:dataspace,object:'array'}
        row[key]=DB.toBuffer(obj[key],datatype);
        continue;
      }
      if (Utils.isArray(attr) && Utils.isArray(attr[0]) && Utils.isNumber(attr[0][0])) {
        if (schema) {}
        datatype='Float32';
        dataspace=[attr.length,attr[0].length]
        meta[key]={datatype:datatype,dataspace:dataspace,object:'array'}
        row[key]=DB.toBuffer(obj[key],datatype);
        continue;
      }
    }
    row.meta=JSON.stringify(meta);
    return row;
  },
  
  // Try to convert SQL row to JS object using meta table or extended schema
  // schema|row.meta : { $col : { datatype:'float32'|'string'.., dataspace?:number [], target:'array'|'typedarray'|'matrixta'|..
  toJS: function (row,schema) {
    try {
      var meta,obj={},keys=Object.keys(row);
      if (typeof row.meta == 'string') row.meta=JSON.parse(row.meta);
      meta=row.meta;
      if (!row.meta) return row;
      for(var i in keys) {
        var key=keys[i];
        if (key=='meta') continue;
        if (row[key] instanceof Buffer && meta[key]) {
          switch (meta[key].object.toLowerCase()) {
            case 'array':
              if (meta[key].datatype && meta[key].dataspace)
                row[key]=DB.toArray(row[key],meta[key].datatype,meta[key].dataspace);
              break;
          }
        }
        if (typeof row[key] == 'string' && meta[key] && meta[key].object=='object') 
          row[key]=JSON.parse(row[key]);
           
      }
      if (row.meta.meta) row.meta=row.meta.meta;
      return row;
    } catch (e) { return e }
  },
  // Create tree representation of store
  tree : function (root,options) {
    var top={},nodes,root=root||DB.store;

    function add(node,entry) {
      if (node.kind=='dir') {
        var nodes={}
        Object.keys(node.nodes).forEach(function (name) {
              //nodes[name]=DB.tree(root.nodes[entry].nodes[name]);
          // return nodes on opening/construction of sub-tree
          nodes[name]={ _constructor:function () { 
            var _nodes=DB.tree(node.nodes[name]);
            return _nodes;
          }}
        });
        return nodes;
      }
      if (node.kind=='db') { 
        var entry={
          name:node.name,
          kind:node.kind,
          time:node.time,
        }
        if (node.exec && node.exec.tables) {
          // tables = root.nodes[entry].exec.tables();
          entry.tables={ _constructor:function () { 
            try {
              var o={},tables;
              tables = node.exec.tables();
              if (Utils.isArray(tables)) {
                  var coll = node.exec.schema(tables)
                  tables.forEach(function (name,index) {
                    var columns='?',result = coll && coll[index];
                    if (result && result.length) {
                      columns={};
                      result.forEach(function (col) {
                        var tokens = col.split(' ');
                        columns[tokens[0]]=tokens.slice(1).join(' ');
                      })
                    }
                    var rows=node.exec.count?node.exec.count(name):[];
                    o[name]= {
                      name:name,
                      kind:'table',
                      columns:columns,
                      rows:!DB.error(rows)?rows[0]:-1,
                    }
                  });
                }
                return o;
              } catch (e) {console.log(e); return o}
          }} 
        }
        // console.log(node)
        if (node.flags && node.flags.contains('sqlproj')) {
          entry.projects= { _constructor:function () { 
            var o={};
            var rows = node.exec.list('/');
            if (Utils.isArray(rows)) {
              rows.forEach(function (row,index) {
                o[row.name]= { }
              });
            }
            return o;
          }}
        }
        if (node.size != undefined)      entry.size     = node.size;
        if (node.id != undefined)        entry.id       = node.id;
        if (node.mimetype != undefined)  entry.mimetype = node.mimetype;
        if (node.url != undefined)       entry.url      = node.url;
        if (node.async != undefined)     entry.async    = node.async;
        return entry;
      }
      return {
          name:entry,
          kind:node.kind,
          time:node.time,
      }
    }
    if (root.nodes) Object.keys(root.nodes).forEach(function(entry) {
      top[entry]=add(root.nodes[entry],entry);
    }); else top=add(root);
    return top;
  },
  
  types : [
    'application/octet-stream',
    'application/javascript',
    'text/plain',  
  ],
  // return unique identifier
  unique : function (length) {
    length=length||8;
    return Math.random().toString(36).substr(2, 2+length);
  },
  wex : function (url,async) {
    return {
      lookup : function (path,cb) {
        Utils.POST('localhost:11111',{
          cmd:  'lookup',
          path:  path,
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          if (cb) cb(res.reply);
          else result=res.reply;
        },!async)
        return result;
      },
      list : function (dir,cb) {
        var result;
        Utils.POST('localhost:11111',{
          cmd:  'list',
          dir:  dir,
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          var dirs=res.reply.filter(function (entry) { return entry.dir })
                            .sort(function (a,b) { return a.name<b.name?-1:1 }),
              files=res.reply.filter(function (entry) { return !entry.dir })
                             .sort(function (a,b) { return a.name<b.name?-1:1 });
          if (cb) cb({files:files,dirs:dirs});
          else result={files:files,dirs:dirs};
        },!async);
        return result;
      },
      read:  function (dir,entry,mimetype,cb) {
        Utils.POST('localhost:11111',{
          cmd:  'load',
          dir:  dir,
          file: entry,
          mimetype:mimetype||'text',
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          if (cb) cb(res.reply);
          else result=res.reply;
        },!async)
        return result;      
      },
      url:url,
    }
  },
  
  write : function (path,data,cb) {
    var pel = path.split('/'),
        root=DB.store,base='',
        entry;
    if (pel.length==1) entry=pel[0];
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else
          break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry]) {
      root.nodes[entry].data=data;
      return data.length
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc'))
            return root.exec.write('/'+more.remains.concat([entry]).join('/'),data,cb);
          break;
      }
    }
    return -1;
  },
  
  version : '1.8.1',
}


};
BundleModuleCode['./db.sql']=function (module,exports){
// Operational DB (SQLJSON) rights  
DB.Rights = {
  READ : 1,
  MODIFY : 2,
  CREATE : 4,
  DELETE : 8,
  TABLE  : 16,
  DATABASE : 32
}
  // SQL operations API (generic)
DB.sql  = function (url,options) { 
    var cap = options && options.capability; 
    function S(req) { if (cap) req.capability=cap; return req };
    return {
    attach : function (name,dir,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name:name,
        }},
      }), cb?DB.fok(cb):null,cb!=undefined))    
    },
    // copy an entire table from this DB to another (dst: sqljson API)
    // Hierarchical tables (e.g., sqlds) must be copied by the respective API (e.g, sqlds.copy)
    copy : function (name,dst,options,cb) {
      options=options||{};
      if (!Utils.isObject(dst)) return new Error('EINVALID');
      if (!cb) {
        var result,stat,first=1,last;
        var schema = this.schema(name);
        if (stat=DB.error(schema)) return stat;
        if (options.overwrite) {
          result = dst.drop(name);
          stat=DB.error(result);
          if (stat) return stat;
        }
        result = dst.create(name,schema);
        stat=DB.error(result);
        if (stat) return stat;
        var rows = this.count(name);
        if (DB.error(rows)) return DB.error(rows);
        rows=DB.ok(rows);
        if (options && options.rows) {
          first=options.rows[0];
          last=options.rows[1];
        } else last=rows;
        for (var i=first;i<=last;i++) {
          var data = this.select(name,'*','rowid="'+i+'"');
          if (DB.error(data)) return DB.error(data);
          if (!data.length) return Error("EEMPTY");
          result=dst.insert(name,DB.ok(data));
          stat=DB.error(result);
          if (options.progress) options.progress(i,first,last,DB.ok(result));
          if (stat) return stat;
        }
        return (last-first+1);
      }
    },
    count : function (name,count,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        select: name,
        count:count||'*'
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // create a new table (or database: {database:name},dir,url,cb}
    create: function (name,columns,cb,aux) {
      if (typeof name == 'object' && name.table) name=name.table;
      else if (typeof name == 'object' && name.database) return this.createDB(name.database,columns,cb,aux);
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        create: { table: name },
        columns:columns
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // create a new database or open if existing
    // new: support of VFS on the fly
    // new: memory db: createDB(dbname+':memory:')
    createDB: function (name,dir,url,cb) {
      var vfs;
      if (typeof url == 'function') { cb=url; url=undefined };
      if (typeof dir == 'object') {
        vfs=dir;
        dir=null;
      }
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name+'.sql':name+'.sql',
          url   : url,
          vfs   : vfs,
        } },
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    databases: function (cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        databases: {}
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    delete: function (name,where,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        delete: name,
        where:where
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    do: function (cmd,cb) {
      // TODO
    },
    drop: function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        drop: name,
        forced : ifnotexists
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    dropDB: function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        drop: { database: name },
        forced : ifnotexists
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // parse an sql query, return reply
    eval : function (query,cb) {
      var tokens = query.split(' '); // TODO:!!!
      switch (tokens[0].toLowerCase()) {
        case 'databases': return this.databases(cb);
        case 'tables': return this.tables(cb);
      }
    },
    // returns { changes: number, lastInsertROWID: number, time: number }
    insert: function (name,values,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        insert: name,
        values:values
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // open/select a database

    open: function (name,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        open: name,
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    select: function (name,columns,where,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        select: name,
        columns:columns,
        where:where
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    schema: function (name, cb) {
      var matched;
      var result = DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        schema:  name
      }), cb?DB.fok(function (result) { 
        if (Utils.isError(result)) return cb(result);
        if (typeof result == 'string')
          cb((matched=result.match(/\((.+)\)$/)) && matched[1].split(','))
        else if (Array.isArray(result))
          result.forEach(function (part) { cb((matched=part.match(/\((.+)\)$/)) && matched[1].split(',')) });
        else
          cb(result)}):null,cb!=undefined));
      if (Utils.isError(result)) return result;
      if (typeof result == 'string')
        return (matched=result.match(/\((.+)\)$/)) && matched[1].split(',')
      else if (Array.isArray(result))
        return result.map(function (part) { return (matched=part.match(/\((.+)\)$/)) && matched[1].split(',') });
    },
    tables: function (cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        tables: {}
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    update: function (name,values,where,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        update: name,
        values:values,
        where:where,
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    sessionID: DB.unique(),
    url : url,
  }}
  
  // complete async/promise version
  // MUST BE USED in async functions only!
DB.sqlA  = function (url,options) { var cap = options && options.capability; var self = {
    attach : async function (name,dir,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          create: { database: {
            name  : name,
            path  : dir?dir+'/'+name:name,
          } },
        }, DB.fok(resolve),true))          
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name:name,
        } },
      }, DB.fok(cb),true))    
    },
    // copy an entire table from this DB to another (dst: sqljson API)
    // Hierarchical tables (e.g., sqlds) must be copied by the respective API (e.g, sqlds.copy)
    copy : async function (name,dst,options,cb) {
      options=options||{};
      if (!Utils.isObject(dst)) return new Error('EINVALID');
      if (!cb) {
        var result,stat,first=1,last;
        var schema = await this.schema(name);
        if (stat=DB.error(schema)) return stat;
        if (options.overwrite) {
          result = await dst.drop(name,true);
          stat=DB.error(result);
          if (stat) return stat;
        }
        result = await dst.create(name,schema);
        stat=DB.error(result);
        if (stat) return stat;
        var rows = await this.count(name);
        if (DB.error(rows)) return DB.error(rows);
        rows=DB.ok(rows);
        if (options && options.rows) {
          first=options.rows[0];
          last=options.rows[1];
        } else last=rows;
        for (var i=first;i<=last;i++) {
          var data  =  await this.select(name,'*','rowid="'+i+'"');
          if (DB.error(data)) return DB.error(data);
          if (!data.length)   return Error('EEMPTY');
          result    = await dst.insert(name,DB.ok(data));
          stat      = DB.error(result);
          if (options.progress) options.progress(i,first,last,DB.ok(result));
          if (stat) return stat;
        }
        return (last-first+1);
      }
    },
    count : async function (name,count,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          select  : name,
          count   : count||'*'
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        select: name,
        count:count||'*'
      }, DB.fok(cb),true))
    },
    // create a new table (or database: {database:name},dir,url,cb}
    create: function (name,columns,cb,aux) {
      if (typeof name == 'object' && name.table) name=name.table;
      else if (typeof name == 'object' && name.database) return this.createDB(name.database,columns,cb,aux);
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          create: { table: name },
          columns:columns
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        create: { table: name },
        columns:columns
      }, DB.fok(cb),true))
    },
    // create a new database or open if existing
    // new: support of VFS on the fly
    // new: memory db: createDB(dbname+':memory:')
    createDB: async function (name,dir,url,cb) {
      var vfs;
      if (typeof url == 'function') { cb=url; url=undefined };
      if (typeof dir == 'object') {
        vfs=dir;
        dir=undefined;
      }
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          create: { database: {
            name  : name,
            path  : dir?dir+'/'+name+'.sql':name+'.sql',
            url   : url,
            vfs   : vfs,
          } },
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name+'.sql':name+'.sql',
          url   : url,
          vfs   : vfs,
        } },
      }, DB.fok(cb),true))
    },
    databases: async function (cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          databases: {}
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        databases: {}
      }, DB.fok(cb),true))
    },
    delete: async function (name,where,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          delete: name,
          where:where
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        delete: name,
        where:where
      }, DB.fok(cb),true))
    },
    do: function (cmd,cb) {
      // TODO
    },
    drop: async function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          drop: name,
          forced : ifnotexists
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        drop: name,
        forced : ifnotexists
      }, DB.fok(cb),true))
    },
    dropDB: async function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          drop: { database : name },
          forced : ifnotexists
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        drop: { database : name },
        forced : ifnotexists
      }, DB.fok(cb),true))
    },
    // parse an sql query, return reply
    eval : function (query,cb) {
      var tokens = query.split(' '); // TODO:!!!
      switch (tokens[0].toLowerCase()) {
        case 'databases': return this.databases(cb);
        case 'tables': return this.tables(cb);
      }
    },
    // returns { changes: number, lastInsertROWID: number, time: number }
    insert: async function (name,values,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          insert: name,
          values:values
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        insert: name,
        values:values
      }, DB.fok(cb),true))
    },
    // open/select a database
    open: async function (name,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          open : name,
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        open : name,
      }, DB.fok(cb),true))
    },
    select: async function (name,columns,where,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          select: name,
          columns:columns,
          where:where
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        select: name,
        columns:columns,
        where:where
      }, DB.fok(cb),true))
    },
    schema: async function (name, cb) {
      var matched;
      function exec(cb) {
        var result = DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          schema:  name
        }, DB.fok(function (result) { 
          if (Utils.isError(result)) return cb(result);
          if (typeof result == 'string')
            cb((matched=result.match(/\((.+)\)$/)) && matched[1].split(','))
          else if (Array.isArray(result))
            result.forEach(function (part) { cb((matched=part.match(/\((.+)\)$/)) && matched[1].split(',')) });
          else
            cb(result)}),true));      
      }
      if (!cb) return new Promise(function (resolve,reject) {
        exec(resolve);
      });
      else return exec(cb);
    },
    tables: async function (cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          tables: {}
        }, DB.fok(resolve),true))
      }); 
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        tables: {}
      }, DB.fok(cb),true))
    },
    update: async function (name,values,where,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          update: name,
          values:values,
          where:where,
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        update: name,
        values:values,
        where:where,
      }, DB.fok(cb),true))
    },
    sessionID: DB.unique(),
    url : url,
  }; return self}
   

  
  // SQLjson RPC client request (with optional access key)
  // format url = ["proto://"] ("host:port" | "host:port:K1:K2:K3:..")  
DB.sqljson = function (url,request,callback,async) {
    var proto  = url.match(/^([a-zA-Z]+):\/\//),
        tokens = url.split(':'),
        sessionID = url.match(/#([^$]+)$/);
    if (proto) proto=proto[1];
    if (sessionID) {
      sessionID=sessionID[1];
      tokens[tokens.length-1]=tokens[tokens.length-1].replace(/#[^$]+$/,'');
      request.sessionID=sessionID;
      url=url.replace(/#[^$]+$/,'');
    }
    if (tokens.length>(2+(proto?1:0))) { 
      url = tokens.slice(0,2+(proto?1:0)).join(':'); 
      request.key= tokens.slice(2+(proto?1:0)).join(':'); 
    }
    // console.log('sqljson',url,request)
    if (!async && !callback) {
      return Utils.POST(url,request,null,true);
    } else if (callback) {
      return Utils.POST(url,request, function (res) {
        // console.log(res);
        callback(res);
      },!async);
    };
  }

};
BundleModuleCode['./db.sqlds']=function (module,exports){
/*
  Hierarchical DataSet Organisation
  --------------------------------- 
  
  meta data: { datatype:string,dataspace:number [], index?:number, chunk?:[] }
  type DataSetTable = Column {
     id         : integer primary key,
     type       : integer,  --  0:group, 1:direct data, 2:indirect, referenced indexed DataTable
     name       : varchar(),
     time       : integer,
     meta       : varchar(), -- YAML/JSON
     data       : blob|integer|varchar() -- DataTable name or serialized data
   }
   type DataTable = Columns {
     index      : integer primary key,
     type       : integer,  --  1:direct data, 2: indirect data, referenced indexed DataTable
     meta       : varchar(), -- optional, YAML/JSON, for chunks ?
     data       : blob,  
   }
   type meta = JSON {
     datatype   : string,
     dataspace  : [],
     index ?    : number,   // type==2
     meta : *,
   }
   
  JSON API
  ========
  
  type table = {
    table : key string,
    meta?: {},
    rows : dataset|datagroup|data []
  }
  type dataset = {
    name : key string,
    meta : {},
    dataspace : number [] | [],
    datatype : datatype,
    index?: number, // indexed data tables (dimension index)
    data : []
  }
  type datagroup = {
    group : key string,
    meta? : {},
    rows : dataset | datagroup [],
  }
  
  type datatype = 'number' | 'float32' | 'float64' | 'int8' | 'int16' | 'int32' | ..
                  'json' | 'string' | 'object'
  type url = string with format "host:port" | "host:port:key1:key2:.." 

*/

// Hierarchical DataSet Tables
// format url = "host:port" | "host:port:KEY1:KEY2:.."
// type datatype = 'text' | 'utf8' | 'buffer' | 'array' | 'object' | 'Int16' | ..
// There is one sqlds instance for each dataset table in the data base !

DB.sqlds = function (url,table,options) {
  function incr(x) { return x+1 };
  return {
    types : [
        'GROUP',
        // date table reference, table organized by indexed rows, repr. 1 dim of dataspace
        'DATALINK',
        // data embedded in table row (monolithic, index==null) 
        'DATA',   
    ],
    // Append one row to a data table; data is serialized
    append : function (handle,data,meta,cb) {
      var stat;
      if (stat=this.checkData(handle,data)) return stat; 
      if (handle.datatable) {
        // append row to linked datatable
        var buffer = DB.toBuffer(data,handle.datatype);
        result = DB.sqljson(this.url,{
          insert : handle.datatable,
          values : {
            row   : null,
            type  : 1,   // direct data
            meta  : meta||'',
            data  : buffer
          }
        });
        if (DB.error(result)) return DB.error(result);
        result=DB.ok(result);
        return result.lastInsertROWID;         
      }
    },

    // Check Table; report and perform GC (gc=true)
    check: function (cb,gc) {
      if (!cb) {
        var result;
        result = DB.sqljson(this.url,{
            tables : {}
        });
        if (DB.error(result)) return DB.error(result);
        result=DB.ok(result);
        if (result.contains(this.table)) return true;
        else throw "Dataset table "+this.table+" not found!";          
      }    
    },


    // is data confirming to handle meta data?
    checkData : function (handle,data) {
      var format;
      if (handle.datatype=='object' || handle.datatype=='buffer' || handle.datatype=='text' || handle.datatype=='utf8') return;
      if (handle.dataspace) {
        switch (handle.index) {
          case 1:
            format=handle.dataspace.slice(1);
            break;
          case 2:
            format=[handle.dataspace[0]].concat(handle.dataspace.slice(2));
            break;
          case 3:
            format=[handle.dataspace[0],handle.dataspace[1]].concat(handle.dataspace.slice(3));
            break;
          case undefined:
            format=handle.dataspace;
        }
        if (format) {
          var dataspace=this.toDataspace(data);
          if (dataspace.length != format.length) return new Error('EDIM');
          for(var i in format) {
            if (format[i]==0) continue;
            if (format[i]!=dataspace[i]) return new Error('ESIZE');
          }
        }
      }
      return;
    },

    close : function (handle) {
      // Nothing todo!
    },

    // Creates a new data table (DataSetTable for vector/matrix/object/..) 
    // and inserts table in the root table;
    // Indexed data tables creates new physical table (each row associated to the index dimension);
    // Non-indexed data tables are embedded in the root data table row.
    // returns ds handle for the new data table
    create : function (name,meta,cb) {
      var self=this;
      if (!meta || !meta.dataspace || !meta.datatype) return new Error('EINVALID');
      var handle = {
        datatype  : meta.datatype,
        dataspace : meta.dataspace,
        index     : meta.index,     // no index -> embedded DS
      }
      if (!cb) {
        if (meta.index != undefined) {
          // An indexed dataset
          // 1. Create DataTable table 
          var result = DB.sqljson(this.url,{
              create : { table : this.table+':'+name },
              columns : 
                { row    : 'integer primary key',
                  type   : 'integer',
                  meta   : 'varchar(100)',
                  data   : 'blob', // |integer|varchar() -- DataTable name or serialized data
                }
          });
          if (DB.error(result)) return DB.error(result);
          // 2. Append DataTable table to DataSetTable
          result = DB.sqljson(this.url,{
            insert : this.table,
            values : {
              name  : name,
              type  : 2,
              time  : DB.time(),
              meta  : JSON.stringify(meta), 
              data  : this.table+':'+name,
            }
          });
          if (DB.error(result)) return DB.error(result);
          handle.name=name;
          handle.datatable = this.table+':'+name;
          handle.append = function (data,meta,cb) {
            return self.append(handle,data,meta,cb);
          }
          handle.meta = function (cb) {
            // update dataspace
            return self.meta(handle,cb);
          }
          handle.read = function (index,cb) {
            return self.read(handle,index,cb);
          }
          handle.update = function (more,cb) {
            // update dataspace
            return self.update(handle,more,cb);
          }
          handle.write = function (index,data,cb) {
            return self.write(handle,index,data,cb);
          }
        } else {
          // Direct data: A monolithic data set embedded in dataset root table
          result = DB.sqljson(this.url,{
            insert : this.table,
            values : {
              name  : name,
              type  : 1,
              time  : DB.time(),
              meta  : JSON.stringify(meta), 
              data  : Buffer(0),
            }
          });
          if (DB.error(result)) return DB.error(result);
          handle.name=name;
          handle.data=Buffer(0);
          handle.meta = function (cb) {
            // update dataspace
            return self.meta(handle,cb);
          }
          handle.read = function (cb) {
            return self.read(handle,null,cb);
          }
          handle.update = function (more,cb) {
            // update dataspace
            return self.update(handle,more,cb);
          }
          handle.write = function (data,cb) {
            return self.write(handle,null,data,cb);
          }            
        }
        for(var key in meta) {
          if (typeof meta[key]=='function' ||
            key == 'name' ||
            key == 'data' ||
            key == 'convert') continue;
            handle[key]=meta[key];
        }
        return handle;

      }      
    },


    // Deletes a data table row in the root dataset table 
    delete : function (name,cb) {
      var result;
      if (!cb) {
        if (name!='*') {
          result = DB.sqljson(this.url,{
            select : this.table,
            columns : '*',
            where : 'name="'+name+'"'
          });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result)[0];
          if (!result) return -1;  // not existing 
          handle=JSON.parse(result.meta);
          if (result.type==2) {
            handle.datatable=result.data;
            result = DB.sqljson(this.url, {
              drop : handle.datatable,
              forced : true,
            });
            if (DB.error(result)) return DB.error(result);         
          }
          result = DB.sqljson(this.url, {
            delete : this.table,
            where  : 'name="'+name+'"'
          });
          if (DB.error(result)) return DB.error(result);
          return 0;
        } else {
          // Delete all rows of table!
          result = DB.sqljson(this.url, {
            delete : this.table,
          });
          if (DB.error(result)) return DB.error(result);
          return 0;            
        }
      }        
    },

    info : function (name,cb) {
      var meta;
      if (!cb) {
        var result;
        if (name!='*') 
          result = DB.sqljson(this.url,{
            select : this.table,
            columns : 'name,type,time,meta',
            where : 'name="'+name+'"'
          }); 
        else
          result = DB.sqljson(this.url,{
            select : this.table,
            columns : 'name,type,time,meta',
          }) ;
        if (DB.error(result)) return DB.error(result);
        result=DB.ok(result);
        if (!result[0]) return new Error('ENOTFOUND');
        if (name=='*')
        return result.map(function (row) {
          return {
            name:row.name,
            type:row.type,
            time:row.time,
            meta:JSON.parse(row.meta)
          }
        });
        meta=JSON.parse(result[0].meta);
        meta.type=result[0].type;
        return meta;          
      }

    },

    // Return all rows of the current table
    list : function (cb) {
      if (!cb) {
        var result = DB.sqljson(this.url,{
          select : this.table,
          columns : 'name,type,time,meta'
        });
        if (DB.error(result)) return DB.error(result);
        result=DB.ok(result);
        return result.map(function (row) {
          if (row.meta) row.meta=JSON.parse(row.meta);
          return row
        });
      }

    },

    // Get or set meta data of a dataset/data table (in a dataset group)
    // if handle == null || 'meta', a row with name 'meta' is created or read
    meta : function (handle,meta) {
      var result;
      if (typeof handle == 'string') {
        // root table entry
        if  (Utils.isObject(meta)) {
          // write meta data row
          result = DB.sqljson(this.url,{
            insert : this.table,
            values : {
              name  : handle,
              type  : 3,
              time  : DB.time(),
              meta  : JSON.stringify(meta), 
              data  : Buffer(0),
            }
          });
          if (DB.error(result)) {
            // exists already? update table
            if (DB.error(result).toString().contains('UNIQUE constraint failed')) {
              result = DB.sqljson(this.url,{
                update : this.table,
                values : {
                  type  : 3,
                  time  : DB.time(),
                  meta  : JSON.stringify(meta), 
                },
                where : 'name=\''+handle+'\''
              });
              if (DB.error(result)) return DB.error(result);
              return meta;
            }
            return DB.error(result);
          }
          return 0;
        } else if (!meta) {
          // read meta data row
          result = DB.sqljson(this.url,{
            select : this.table,
            columns : 'name,type,time,meta',
            where : 'name=\''+handle+'\''
          });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result)[0];
          if (!result) return new Error('ENOTFOUND');
          return JSON.parse(result.meta);
        }
        return;
      }
      // Get meta data of specific data set 
      meta={};
      if (handle.datatable) {
          // get number of rows from secondary data table
          var rows = DB.sqljson(this.url,{
                select  : handle.datatable,
                columns : 'rowid',
              });
          if (DB.error(rows)) return DB.error(rows);
          rows=DB.ok(rows);
          if (handle.index!=undefined) {
            handle.dataspace[handle.index-1]=rows.length;
          }
      }
      for(var key in handle) {
        if (typeof handle[key]=='function' ||
            key == 'data' ||
            key == 'name' ||
            key == 'convert') continue;
        meta[key]=handle[key];
      }
      return meta;
    },

    // Open a dataset and return handle for a specific data table (entry) in
    // the root table
    open : function (name,cb)  {
      var self=this,handle;
      if (!cb) {
        var result = DB.sqljson(this.url,{
          select : this.table,
          columns : '*',
          where : 'name="'+name+'"'
        });
        if (DB.error(result)) return DB.error(result);
        result=DB.ok(result)[0];
        if (!result) return new Error('ENOTFOUND');
        handle=JSON.parse(result.meta);
        handle.name=name;
        if (result.type==1) {
          handle.data = result.data;
          handle.meta = function (cb) {
            // update dataspace
            return self.meta(handle,cb);
          }
          handle.read = function (cb) {
            return self.read(handle,null,cb);
          }
          handle.update = function (more,cb) {
            // update dataspace
            return self.update(handle,more,cb);
          }
          handle.write = function (data,cb) {
            return self.write(handle,null,data,cb);
          }          
        } else if (result.type==2) {
          handle.datatable=result.data;
          handle.append = function (data,meta,cb) {
            return self.append(handle,data,meta,cb);
          }
          handle.meta = function (cb) {
            // update dataspace
            return self.meta(handle,cb);
          }
          handle.read = function (index,cb) {
            return self.read(handle,index,cb);
          }
          handle.update = function (more,cb) {
            // update dataspace
            return self.update(handle,more,cb);
          }
          handle.write = function (index,data,cb) {
            return self.write(handle,index,data,cb);
          }
        }
        return handle;          
      }
    },

    // read a row, multiple rows, or the entire dataset (embedded data)
    // meta data of linked datatable rows are added to the resulting data object
    read : function (handle,index,cb) {
      var data;
      if (!cb) {
        if (handle.datatable) {
          // Linked Datatable
          var result = DB.sqljson(this.url,{
            select : handle.datatable,
            columns : '*',
            where : Utils.isArray(index)?
                    'row in('+index.map(incr).join(',')+')':
                    'row='+(index+1)
          });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result);
          if (result.length==0) return new Error('ENOTFOUND');
          for (var i in result) if (!result[i].data) return  new Error('ENODATA');
          if (Utils.isArray(index)) {
            if (!handle.convert) data = result.map(function (row) {
              var data = DB.buffer2array(row.data,handle.datatype); 
              data.meta = row.meta;
              return data;
            }); else {
              data = result.map(function (row) { 
                row.data.meta=row.meta;
                return row.data 
              });
            }
          } else {
            if (!handle.convert) data = DB.buffer2array(result[0].
                                                        data,handle.datatype,
                                                        this.subDataspace(handle));
            else {
              switch (handle.convert) {
                case 'Array' :  data = DB.buffer2array(result[0].data,handle.datatype); break;
                case 'Buffer':  data = result[0].data; break;
                case 'Matrix':
                case 'MatrixTA':
                  if (!Utils.TypedArrayOfName[handle.datatype+'Array']) 
                    return  new Error('Invalid data type for Matrix conversion ('+handle.datatype+')');
                  data = DB.toMatrix(result[0].data,
                                     Utils.TypedArrayOfName[handle.datatype+'Array'],
                                     this.subDataspace(handle),handle.layout)

              }
            }
            data.meta = result[0].meta;
          }
        } else if (handle.data) {
          // Embedded Data
          if (handle.data.length==0) return new Error('EEMPTY');
          switch (handle.datatype) {
            case 'text':    
            case 'utf8':    
              data = handle.data; break;
            case 'object':  
              data = JSON.parse(handle.data); break;
            default:
              switch (handle.convert) {
                case 'Buffer':  data = handle.data; break;
                case 'Matrix':
                case 'MatrixTA':
                  data = DB.toMatrix(handle.data,
                                     Utils.TypedArrayOfName[handle.datatype+'Array'],
                                     this.subDataspace(handle),handle.layout)
                default:
                  data = DB.buffer2array(handle.data,handle.datatype,handle.dataspace);
              }
          }
        }
        return data;
      }
    },
    // Creates  dataset root table (DataSetTable) ifnotexist
    setup : function (ifnotexist,cb) {
      if (!cb) {
        var result;
        if (ifnotexist) {
          result = DB.sqljson(this.url,{
            tables : {}
          });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result);
          if (result.contains(this.table)) return 'Found table '+this.table;          
        }
        result = DB.sqljson(this.url,{
            create : { table : this.table },
            columns : 
              { name    : 'varchar(300) primary key',
                type  : 'integer',  // 0:group, 1:embedded data, 2:referenced DataTable
                time  : 'integer',
                meta  : 'varchar(1000)', // YAML/JSON
                data  : 'blob', // |integer|varchar() -- DataTable name or serialized data
              }}) 
        if (DB.error(result)) return DB.error(result);
        else return 'Created table '+this.table;
      }    
    },

    // Returns type path signature of full or sub data set
    signature : function (handle) {
    
    }, 
    subDataspace : function (handle) {
      // assuming only one hierarchy level
      if (handle.dataspace) {
        switch (handle.index) {
          case 1:
            format=handle.dataspace.slice(1);
            break;
          case 2:
            format=[handle.dataspace[0]].concat(handle.dataspace.slice(2));
            break;
          case 3:
            format=[handle.dataspace[0],handle.dataspace[1]].concat(handle.dataspace.slice(3));
            break;
          case undefined:
            format=handle.dataspace;
        }
        return format;
      }
    },

    toDataspace : function (o) {
      if (Utils.isArrayArrayArray(o)) return [o.length,o[0].length,o[0][0].length];
      else if (Utils.isArrayArray(o)) return [o.length,o[0].length];
      else if (Utils.isArray(o))  return [o.length].concat(this.dataspaceOfData(o[0]));
      else if (Utils.isMatrix(o)) return o.dataspace?o.dataspace:(o.levels?[o.levels,o.rows,o.columns]:[o.rows,o.columns]);
      else if (Utils.isBuffer(o)) return [o.length];
      return [];
    },


    // Update a DataTable or DataSetTable meta data
    // set actual dataspace (update handle meta data)
    // return meta data
    update : function (handle,more,cb) {
      var meta={};
      if (handle.datatable) {
        // linked data
          var rows = DB.sqljson(this.url,{
                select  : handle.datatable,
                columns : 'rowid',
              });
          if (DB.error(rows)) return DB.error(rows);
          rows=DB.ok(rows);
          if (handle.index!=undefined) {
            handle.dataspace[handle.index-1]=rows.length;
          }
      } else {
        // embedded data
        switch (handle.datatype) {

        } 
      }
      for(var key in handle) {
        if (typeof handle[key]=='function' ||
            key == 'name' ||
            key == 'data' ||
            key == 'convert') continue;
        meta[key]=handle[key];
      }
      if (more) for(var key in more) {
        meta[key]=more[key];
      }
      var result = DB.sqljson(this.url,{
            update : this.table,
            values : 
              handle.data?
              { 
                data  : handle.data,
                meta  : JSON.stringify(meta), // YAML/JSON
              }
              :
              { 
                meta  : JSON.stringify(meta), // YAML/JSON
              },
            where : 'name="'+handle.name+'"'
      });
      if (DB.error(result)) return DB.error(result);
      return meta;
    },

    // Encode data and modifiy (or add) dataset row (or entire dataset)
    write : function (handle,index,data,cb) {
      var stat;
      if (stat=this.checkData(handle,data)) return stat; 
      if (!cb) {
        if (handle.data) {
          // Embbeded data
          switch (handle.datatype) {
            case 'text':
            case 'utf8':
              handle.data=data;
              break;
            case 'object':
              handle.data=JSON.stringify(data);
              break;
            default:
             if (Utils.isArray(data))
               handle.data = DB.array2buffer(data,handle.datatype,handle.dataspace);
             else if (Utils.isMatrix(data) && Utils.isTypedArray(data.data))
               handle.data = DB.toBuffer(data);            
             else if (data.data && Utils.isArray(data.data))
               handle.data = DB.array2buffer(data.data,handle.datatype,handle.dataspace); 
          }
          stat=this.update(handle);
          if (DB.error(stat)) return stat;
          return handle.data.length;
        }
      }
    },
    url : url,
    table : table,    // root table
    version : '1.4.1',
  }
}
};
BundleModuleCode['./db.sqldoc']=function (module,exports){

// SQLdoc API
// typeof @options = {table:string }
// format url = "host:port" | "host:port:KEY1:KEY2:.."
// SQLdoc API
DB.sqldoc = function (url,options) {
  if (typeof options == 'string') options={table:options};
  options=options||{};
  if (!options.table) options.table='DocTable';
  if (!url.match(/:[0-9]+$/)) url += (':'+DB.config.ports.sqldoc);
  return {
      types : [
        'SECTION',
        'DOCUMENT',
        'MEDIA',
      ],
      // Append document or media to directory (section)
      append : function (dir,node) {
        var root = typeof dir=='object'?dir:this.lookup(dir);
        var result;
        if (root && root.type==0) {
          // check if row exists already 
          if (this.lookupDirRow(root,node.name)) return 'Error: Exists';
          root.content.push(node.id);
          root.content=DB.array2buffer(root.content);
          root.time=DB.time();
          result = DB.sqljson(this.url,{
            update  : this.table,
            values  : root,
            where   : 'id='+root.id
          });   
          if (DB.error(result)) return DB.error(result);        
          else return DB.ok(result);            
        }                    
      },

      // Check DocTable; report and perform GC (gc=true)
      check: function (gc,log) {
        var result;
        var rows = DB.sqljson(this.url,{
                select : this.table,
                columns : '*',
                exclude : { content: 'type!=0' },
                });
        if (DB.error(rows)) return DB.error(rows);
        var table=[],i,j,top=0;
        rows=DB.ok(rows);
        for(i=0;i<rows.length;i++) {
          var row=rows[i];
          top=Math.max(top,row.id);
          if (row.type==0) row.content=DB.buffer2array(row.content);
          row.parent=[];
          table[row.id]=row;
        }
        // mark
        for(i=0;i<=top;i++) {
          var row = table[i];
          if (!row) continue;
          if (row.type==0) {
            var children = row.content;
            for(j in children) {
              table[children[j]].parent.push(i);
            }
          }
        }
        var orphans = [];
        for(i=0;i<=top;i++) {
          var row = table[i];
          if (!row || row.id==1) continue;
          if (row.parent.length==0) {
            orphans.push(row);
          }
        }
        if (gc && orphans.length) {
          log=log||print;
          log('Found '+orphans.length+' oprhans. Cleaning up ...');
          for(i in orphans) {
              var row = orphans[i];
              result = DB.sqljson(this.url,{
                delete  : this.table,
                where   : 'id='+row.id
              });   
              if (DB.error(result)) return DB.error(result);
              else log('Removed i-node '+row.id+': '+Utils.inspect(DB.ok(result)));                  
          }
        }
        return {table:table,orphans:orphans};
      },

      // create document
      createDocument : function (name,description,text) {
          var node = { id:null,
                name:name,
                type:1,
                mimetype:'markdown/text',
                description:description||'',
                template:'',
                size:this.version>1?text.length:undefined,
                time:DB.time(),
                content:text||''
              },
              result = DB.sqljson(this.url,{
                insert : options.table,
                values:node
                });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result);
          node.id=result.lastInsertROWID;
          return node;     
      },

      createFS : function (cb) {
        if (!cb) {
          var result = DB.sqljson(this.url,{
            drop: options.table,
          })
          //if (DB.error(result)) return DB.error(result);*/

          result = DB.sqljson(this.url,{
            create : this.table,
            columns : 
              { id:'integer primary key',
                name:'varchar(256)',
                type:'integer',
                mimetype:'varchar(100)',
                description:'varchar(65000)',
                template:'varchar(65000)',
                size:this.version>1?'integer':null,
                time:'integer',
                content:'blob'
              }}) 
          if (DB.error(result)) return DB.error(result);
          result = DB.sqljson(this.url,{
            insert : this.table,
            values:
              { id:null,
                name:'/',
                type:0,
                mimetype:'dir',
                description:'root',
                template:'',
                size:this.version>1?0:null,
                time:DB.time(),
                content:DB.array2buffer([])
              }})
          return DB.ok(result);
        }
      },

      // add media file
      createMedia : function (name,data,mimetype) {
          var node = { id:null,
                name:name,
                type:2,
                mimetype:mimetype||'stream/octet',
                description:'',
                template:'',
                size:this.version>1?data.length:null,
                time:DB.time(),
                content:data
              },
              result = DB.sqljson(this.url,{
                insert : options.table,
                values:node
                });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result);
          node.id=result.lastInsertROWID;
          return node;     
      },

      delete : function (path,cb) {
        var dir=DB.dirname(path),entry=DB.basename(path);
        if (!cb) {
          var root = this.lookup(dir);
          if (root) {
            var row = this.lookupDirRow(root,entry,true);
            if (row) {
              // unlink from parent row
              root.content=root.content.filter(function (id) {
                return id!=row.id;
              });
              root.content=DB.array2buffer(root.content);
              root.time=DB.time();
              var result = DB.sqljson(this.url,{
                update  : this.table,
                values  : root,
                where   : 'id='+root.id
              });   
              if (DB.error(result)) return DB.error(result);       
              // Remove entry row, too!
              result = DB.sqljson(this.url,{
                delete  : this.table,
                where   : 'id='+row.id
              });   
              if (DB.error(result)) return DB.error(result);       
              else return 1;            

            }
          }
        }  
        return 0;
      },

      list : function (path,cb) {
        if (!cb) {
          var root;
          if (path=='*') {
            // return all rows
            var rows = DB.sqljson(this.url,{
                select : this.table,
                columns : '*',
                exclude : { content: 'type!=0' },
                });
            if (DB.error(rows)) return DB.error(rows);
            rows=DB.ok(rows);
            for(var i in rows) if (rows[i].type==0) 
              rows[i].content=DB.buffer2array(rows[i].content);
            return rows
          }
          if (path=='/') {
            root=DB.sqljson(this.url, {
              select  : this.table,
              columns : '*',
              where   : 'id=1',
              exclude : { content: 'type!=0' },
            });
            if (DB.error(root)) return DB.error(root);
            root=DB.ok(root)[0];
            if (root.type==0) root.content=DB.buffer2array(root.content);
          } else
            root=this.lookup(path);
          if (DB.error(root)) return DB.error(root);
          if (root.type==0) {
            // console.log('id in ('+root.content.join(',')+')')
            var rows = DB.sqljson(this.url,{
                select : this.table,
                columns : 'id,name,type,mimetype,'+(this.version>1?'size,':'')+'description,time',
                where   : 'id in ('+root.content.join(',')+')'
                });
            if (DB.error(rows)) return DB.error(rows);
            return DB.ok(rows);
          }
        } 
      },

      lookup : function (path,cb,info) {
        // remove leading slash
        path=path.replace(/^\//,'');
        var rpc = {
            loop : {
              vars : { node : {}, rows:[], result:{}, parts:path.split('/'), index:0, found:{}, },
              init : [
                {
                  select : this.table,
                  columns : '*',
                  where : 'id=1',
                  target : 'node',
                  decode : { content:'uint32' },
                  index : 0,
                },
              ],
              cond : 'node && node.type==0 && index < parts.length',
              make : [
                {
                  select : this.table,
                  columns : info?'id,name,type,mimetype,'+(this.version>1?'size,':'')+'description,time':'*',
                  where : 'idlist(node.content)',
                  target : 'rows',
                },
                {
                  find : '$.name==parts[index]',
                  source : 'rows',
                  target : 'found',
                },
                {
                  ifthen  : '!found',
                  raise : 'ENOTFOUND', // reserved words: break, continue
                },
                { ifthen : 'found.type==0',
                  make : [
                    { decode : { $:'found', content:'uint32' }}
                  ]
                },
                { incr : 'index'},
                { assign : 'node=found'},
              ],
              finalize : [
                { result : 'node' }
              ],
              //error : [
              //  { result : { error : 'EFAILED' }}
              //],
            }
        };        
        if (!cb) {
          // SQLjson microprogram iterating path on server
          var result = DB.sqljson(this.url,rpc);
          if (DB.error(result)) return DB.error(result);
          if (result.type==0 && !info) result.content=DB.buffer2array(result.content);
          return result;
        } else {
          return DB.sqljson(this.url,rpc,function (result) {
            if (DB.error(result)) return cb(DB.error(result));
            if (result.type==0 && !info) result.content=DB.buffer2array(result.content);
            cb(result);
          },true);
        }
      },

      lookupDirRow: function (root,entry,info) {
        if (root && root.content && root.content.length) {
          var ids,rows;
          if (root.content) ids=DB.buffer2array(root.content);
          ids = ids.map(function (id) { return 'id='+id}).join(' or ');
          rows = DB.sqljson(this.url,{
                select  : this.table,
                columns : info?'id,name,type,mimetype,'+(this.version>1?'size,':'')+'description,time':'*',
                where   : ids,
                exclude : { content: 'type!=0' },
            });
          if (DB.error(rows)) return DB.error(rows);
          else rows=DB.ok(rows);
          var found;
          for(var p in rows) if (rows[p].name==entry) {found=rows[p]; break};
          if (!found) return;
          else {
            if (found.type==0 && !info) found.content=DB.buffer2array(found.content);
            return found;
          }
        } else return;
      },

      lookupDirRows: function (root,info,cb) {
        if (root && root.content && root.content.length) {
          var ids,rows;
          if (root.content) ids=DB.buffer2array(root.content);
          ids = ids.map(function (id) { return 'id='+id}).join(' or ');
          rows = DB.sqljson(this.url,{
                select  : this.table,
                columns : info?'id,name,type,mimetype,description,time':'*',
                where   : ids,
                exclude : { content: 'type!=0' },
              });
          if (DB.error(rows)) return [];
          else rows=DB.ok(rows);
          for(var p in rows) 
            if (rows[p].type==0 && !info) 
              rows[p].content=DB.buffer2array(rows[p].content);
          return rows;
        } else return [];
      },

      mkdir : function (path,dirname,cb) {
        if (!dirname) dirname=DB.basename(path),
                      path=DB.dirname(path);
        var row = this.lookup(path);
        var result2;
        if (row && row.type==0) {
          // check if folder already exists
          if (this.lookupDirRow(row,dirname)) return 'Error: Exists';
          var result = DB.sqljson(this.url,{
            insert : this.table,
            values:
              { id:null,
                name:dirname,
                type:0,
                mimetype:'dir',
                size:this.version>1?0:undefined,
                description:'',
                template:'',
                time:DB.time(),
                content:DB.array2buffer([])
              }})
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result);
          row.content.push(result.lastInsertROWID);
          row.content=DB.array2buffer(row.content);
          result2 = DB.sqljson(this.url,{
            update :  this.table,
            values  : row,
            where   : 'id='+row.id
            });   
          if (DB.error(result2)) return DB.error(result2);        
          else return DB.ok(result);            
        }          
      },

      // return node content
      read: function (path,cb) {
        if (!cb) {
          var node=this.lookup(path,cb);
          if (DB.error(node)) return DB.error(node);
          if (node.content) return node.content;
        } else return this.lookup(path,function (node) {
            if (DB.error(node)) return cb(DB.error(node));
            return cb(node.content);
        });
      },

      // Synchronize two DocTables
      // @second : sqldoc {}  
      sync : function (second,log,verbose) {
        var i,result,
            left  = this.list('*'),
            right = second.list('*');
        log=log||print;
        if (Utils.isError(left)) return left;
        if (Utils.isError(right)) return right;
        // Find differences
        var table0=[],table1=[];
        if (verbose) log('left',left);
        if (verbose) log('right',right);
        
        for(i in left)  table0[left[i].id]  = left[i];        
        for(i in right) table1[right[i].id] = right[i];
        // Run from left to right
        for(i in table0) {
            if (table1[i]) {
              if (table0[i].type != table1[i].type ||
                  table0[i].name != table1[i].name) {
                log('Row #'+i+' inconsistent! Left: '+
                    Utils.inspect(table0[i])+' Right: '+
                    Utils.inspect(table1[i]));
                continue;
              }
              var delta = DB.timeCompare(table0[i].time,table1[i].time);
              if (delta>0) {
                log('Updating newer row #'+i+' '+table0[i].name+
                    ' '+this.url+' -> '+second.url);
                result = DB.sqljson(this.url,{
                  select : this.table,
                  columns : '*',
                  where   : 'id='+i
                });
                if (DB.error(result)) return DB.error(result);
                result=DB.ok(result)[0];
                if (!result) return new Error ('ENOTFOUND');
                result = DB.sqljson(second.url,{
                  update : second.table,
                  values  : result,
                  where   : 'id='+result.id
                });
                if (DB.error(result)) return DB.error(result);                  
              } else if (table0[i].type==0) {
                // different table content!? Be careful
                delta=0;
                for(var j=0;j<table0[i].content.length;j++) {
                  if (table0[i].content[j]!=table1[i].content[j]) {
                    if (table0[i].content[j]==undefined || table1[i].content[j]==undefined)
                      delta++;
                  }
                }
                if (delta && table0[i].content.length>=table1[i].content.length) {
                  log('Row (dir) #'+i+' '+table0[i].name+' is incomplete on '+second.url+'. Updating ..');
                  result = DB.sqljson(this.url,{
                    select : this.table,
                    columns : '*',
                    where   : 'id='+i
                  });
                  if (DB.error(result)) return DB.error(result);
                  result=DB.ok(result)[0];
                  if (!result) return new Error ('ENOTFOUND');
                  result.rowid=Number(i);
                  result = DB.sqljson(second.url,{
                    update : second.table,
                    values  : result,
                    where   : 'id='+result.id
                  });
                  if (DB.error(result)) return DB.error(result);                                  
                } else if (delta) log('Inconsisting rows (dir) found ['+i+']');
              }
            } else {
              log('Row #'+i+' '+table0[i].name+' is missing on '+second.url+'. Adding ..');
                result = DB.sqljson(this.url,{
                  select : this.table,
                  columns : '*',
                  where   : 'id='+i
                });
                if (DB.error(result)) return DB.error(result);
                result=DB.ok(result)[0];
                if (!result) return new Error ('ENOTFOUND');
                result.rowid=Number(i);
                result = DB.sqljson(second.url,{
                  insert : second.table,
                  values  : result,
                });
                if (DB.error(result)) return DB.error(result);                                  
            }
        }  
      },

      // update entire doctable row
      update : function (node) {
          node.time=DB.time();
          var result = DB.sqljson(this.url,{
                update : this.table,
                values  : node,
                where   : 'id='+node.id
              });
          if (DB.error(result)) return DB.error(result);
          result=DB.ok(result);
          return result;   
      },

      write : function (path,data,cb) {
        var root,node,dir=DB.dirname(path),entry=DB.basename(path);
        if (!cb) {
          var root = this.lookup(dir);
          if (root) {
            node  = this.lookupDirRow(root,entry);
            if (node) {
              node.content=data; // encode data?
              var res = this.update(node);
              if (res && res.changes) return data.length;
            } else {
              // create file
              var doc,mimetype = typeof cb=='string'?cb:DB.mimeType(data);
              if (mimetype.indexOf('text')==0)
                doc=this.createDocument(entry,'',data);
              else
                doc=this.createMedia(entry,'',data);
              if (DB.error(doc)) return doc;
              res=this.append(root,doc);
              if (DB.error(res)) return DB.error(res);
              if (res && res.changes) return data.length;
            }
          }
        }
      },

      url:url,
      table:options.table,
      version:'1.1.2',
  } 
}
};
BundleModuleCode['./db.sqlproj']=function (module,exports){
// SQLproj API (project orga)
// TODO: directories
DB.sqlproj = function (url,options) {
  options=options||{};
  if (!options.table) options.table='ProjTable';
  if (!url.match(/:[0-9]+$/)) url += (':'+DB.config.ports.sqlproj);
  return {
    // Check Table; report and perform GC (gc=true)
    check: function (gc) {

    },

    delete : function (path,cb ) {
      var parts = path.split('/');
      if (parts.length > 2) return 0; // TODO dirs
      if (!cb) {
        var name = parts[1]||parts[0];
        var result = DB.sqljson(this.url,{
            delete : this.table,
            where : 'name="'+name+'"'
        });
        return result?1:0;  
      }      
    },

    list : function (path, cb) {
      if (path!='' && path!='/') return; // TODO dirs
      if (!cb) {
        var rows = this.sql.select(this.table,'name,time,description');
        return rows||[];
      }
    },

    lookup : function (name,cb) {
      if (name=='/') return this.list(name,cb);
      var rows = this.sql.select(this.table,'*','name="'+name+'"',cb?function (row) {
        if (rows && rows.length==1) cb(rows[0]); else cb();
      }:null);
      if (rows && rows.length==1) return rows[0];
    },

    read: function (name,cb) {
      var rows = this.sql.select(this.table,'*','name="'+name+'"',cb?function (rows) {
        if (rows && rows.length==1) cb(rows[0].data);
      }:null);
      if (rows && rows.length==1) return rows[0].data;
    },

    // if the root project table does not exist creat the table
    setup : function () {

    },

    sync : function (second,log,test) {
      var i,result,
          left  = this.list('/'),
          right = second.list('/');

      log=log||print;
      if (Utils.isError(left)) return left;
      if (Utils.isError(right)) return right;
      // Find differences
      var table0=[],table1=[];
      for(i in left)  table0[left[i].name]  = left[i];        
      for(i in right) table1[right[i].name] = right[i];
      // Run from left to right
      for(i in table0) {
          if (table1[i]) {
            var delta = DB.timeCompare(table0[i].time,table1[i].time);
            if (delta>0) {
              log('Updating newer row "'+i+'" '+
                  this.url+' -> '+second.url);
              result = DB.sqljson(this.url,{
                select : this.table,
                columns : '*',
                where   : 'name=\''+i+'\''
              });
              if (DB.error(result)) return DB.error(result);
              result=DB.ok(result)[0];
              if (!result) return new Error ('ENOTFOUND');
              if (test) continue;
              result = DB.sqljson(second.url,{
                update : second.table,
                values  : result,
                where   : 'name=\''+result.name+'\''
              });
              if (DB.error(result)) return DB.error(result);                  
            }
          } else {
            log('Row "'+i+'" is missing on '+second.url+'. Adding ..');
              result = DB.sqljson(this.url,{
                select : this.table,
                columns : '*',
                where   : 'name=\''+i+'\''
              });
              if (DB.error(result)) return DB.error(result);
              result=DB.ok(result)[0];
              if (!result) return new Error ('ENOTFOUND');
              if (test) continue;
              result = DB.sqljson(second.url,{
                insert : second.table,
                values  : result,
              });
              if (DB.error(result)) return DB.error(result);                                  
          }
      }  
    },
    write : function (name,data,description,cb) {
      var row = this.sql.select(this.table,'*','name="'+name+'"');
      if (row.length==0) {
        var result = this.sql.insert(this.table,{
          id:DB.shortName(name,8),
          name:name,
          description:description||'',
          time:DB.time(),
          data:data
        });
      } else if (row.length==1) {
        row=row[0];
        row.data=data;
        row.time=DB.time();
        if (description!='') row.description=description;
        result = this.sql.update(this.table,row,'name="'+name+'"');
      }

    },
    sql : DB.sql(url),
    url : url,
    table : options.table,
  } 
}
};
BundleModuleCode['plugins/fft/fft.js']=function (module,exports){
/**
 * Fast Fourier Transform module
 * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)
 */
 
/* Version 1.3.1 */

(function() {
  var FFT= function (n,n2) { if (!(this instanceof FFT)) return new FFT(n,n2); this.init(n,n2) };           // top-level namespace
  var _root = this;  // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FFT=FFT;
  } else {
    window.FFT = FFT;
  }

  FFT.prototype = {
    init : function(n,n2) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        this._n = n;
        this._n2 = n2;
        this._initArray();
        this._makeBitReversalTable();
        this._makeCosSinTable();
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // 1D-FFT
    fft1d : function(re, im) {
      if (Utils.isArray(re))
        this.fft(re, im, 1);
      else if (Math.Vector.isVector(re)) 
        this.fft(re.data,im.data,1);
      else if (Math.VectorTA.isVector(re)) 
        this.fft(re.data,im.data,1);      
    },
    // 1D-IFFT
    ifft1d : function(re, im) {
      var k = 1/this._n;
      this.fft(re, im, -1);
      for(var i=0; i<this._n; i++) {
        re[i] *= k;
        im[i] *= k;
      }
    },
    // 2D-FFT
    fft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      if (Utils.isArray(re) && !Utils.isArrayArray(re)) {
        // x-axis
        for(var y=0; y<this._n; y++) {
          i = y*this._n;
          for(var x1=0; x1<this._n; x1++) {
            tre[x1] = re[x1 + i];
            tim[x1] = im[x1 + i];
          }
          this.fft1d(tre, tim);
          for(var x2=0; x2<this._n; x2++) {
            re[x2 + i] = tre[x2];
            im[x2 + i] = tim[x2];
          }
        }
        // y-axis
        for(var x=0; x<this._n; x++) {
          for(var y1=0; y1<this._n; y1++) {
            i = x + y1*this._n;
            tre[y1] = re[i];
            tim[y1] = im[i];
          }
          this.fft1d(tre, tim);
          for(var y2=0; y2<this._n; y2++) {
            i = x + y2*this._n;
            re[i] = tre[y2];
            im[i] = tim[y2];
          }
        }
      } else if (Utils.isArrayArray(re) || Math.Matrix.isMatrix(re)) {
        // TODO
      } else if (Math.MatrixTA.isMatrix(re)) {
        // TODO
      }
    },
    // 2D-IFFT
    ifft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<this._n; y++) {
        i = y*this._n;
        for(var x1=0; x1<this._n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        this.ifft1d(tre, tim);
        for(var x2=0; x2<this._n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<this._n; x++) {
        for(var y1=0; y1<this._n; y1++) {
          i = x + y1*this._n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        this.ifft1d(tre, tim);
        for(var y2=0; y2<this._n; y2++) {
          i = x + y2*this._n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // core operation of FFT
    fft : function(re, im, inv) {
      var d, h, ik, m, tmp, wr, wi, xr, xi,
          n4 = this._n >> 2;
      // bit reversal
      for(var l=0; l<this._n; l++) {
        m = this._bitrev[l];
        if(l < m) {
          tmp = re[l];
          re[l] = re[m];
          re[m] = tmp;
          tmp = im[l];
          im[l] = im[m];
          im[m] = tmp;
        }
      }
      // butterfly operation
      for(var k=1; k<this._n; k<<=1) {
        h = 0;
        d = this._n/(k << 1);
        for(var j=0; j<k; j++) {
          wr = this._cstb[h + n4];
          wi = inv*this._cstb[h];
          for(var i=j; i<this._n; i+=(k<<1)) {
            ik = i + k;
            xr = wr*re[ik] + wi*im[ik];
            xi = wr*im[ik] - wi*re[ik];
            re[ik] = re[i] - xr;
            re[i] += xr;
            im[ik] = im[i] - xi;
            im[i] += xi;
          }
          h += d;
        }
      }
    },
    // returns spectrum of signal array
    signalSpectrum : function (data,islog,norm,scale) {
      var re=data.slice(),
          im = data.map(function () { return 0 });
      this.fft1d(re,im);
      return this.spectrum(re,im,islog,norm,scale).slice(0,data.length/2);
    },
    // returns shifted spectrum array of signal input array
    signalSpectrumWindow : function (data,islog,norm,scale) {
      var res=[];
      for(var off=0;off<(data.length-this._n);off++) {
        var re = data.slice(off,off+this._n),
            im = re.map(function () { return 0 });
        this.fft1d(re,im);
        res.push(this.spectrum(re,im,islog,norm,scale).slice(0,this._n/2)); 
      }
      return res;
    },
    // returns amplitude spectrum array from re/im fft output
    spectrum : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
     // returns phase spectrum
    phase : function (re,im,islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          n2 = this._n*(this._n2||1),
          log = Math.log,
          atan = Math.atan;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(atan(im[i]/re[i]));
        } else {
          spectrum[i] = atan(im[i]/re[i]);
        }
      }
      return spectrum;
    },
    // returns power spectrum
    power : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log((re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = (re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
    // initialize the array (supports TypedArray)
    _initArray : function() {
      if(typeof Uint8Array !== 'undefined') {
				if(this._n<=256)
                                        this._bitrev = new Uint8Array(this._n);
				else if(this._n<=65536)
					this._bitrev = new Uint16Array(this._n);
				else
					this._bitrev = new Uint32Array(this._n);
      } else {
        this._bitrev = [];
      }
      if(typeof Float64Array !== 'undefined') {
        this._cstb = new Float64Array(this._n*1.25);
      } else {
        this._cstb = [];
      }
    },
    // zero padding
    _paddingZero : function() {
      // TODO
    },
    // makes bit reversal table
    _makeBitReversalTable : function() {
      var i = 0,
          j = 0,
          k = 0;
      this._bitrev[0] = 0;
      while(++i < this._n) {
        k = this._n >> 1;
        while(k <= j) {
          j -= k;
          k >>= 1;
        }
        j += k;
        this._bitrev[i] = j;
      }
    },
    // makes trigonometiric function table
    _makeCosSinTable : function() {
      var n2 = this._n >> 1,
          n4 = this._n >> 2,
          n8 = this._n >> 3,
          n2p4 = n2 + n4,
          t = Math.sin(Math.PI/this._n),
          dc = 2*t*t,
          ds = Math.sqrt(dc*(2 - dc)),
          c = this._cstb[n4] = 1,
          s = this._cstb[0] = 0;
      t = 2*dc;
      for(var i=1; i<n8; i++) {
        c -= dc;
        dc += t*c;
        s += ds;
        ds -= t*s;
        this._cstb[i] = s;
        this._cstb[n4 - i] = c;
      }
      if(n8 !== 0) {
        this._cstb[n8] = Math.sqrt(0.5);
      }
      for(var j=0; j<n4; j++) {
        this._cstb[n2 - j]  = this._cstb[j];
      }
      for(var k=0; k<n2p4; k++) {
        this._cstb[k + n2] = -this._cstb[k];
      }
    }
  };
}).call(this);

/**
 * Spatial Frequency Filtering
 * High-pass/Low-pass/Band-pass Filter
 * Windowing using hamming window
 */
(function() {
  var FrequencyFilter={};  // top-level namespace
  var _root = this;     // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FrequencyFilter=FrequencyFilter;
  } else if(typeof exports !== 'undefined') {
    FrequencyFilter = exports;   // for CommonJS
  } else {
    FrequencyFilter = _root.FrequencyFilter = {};
  }

  // core operations
  var _n = 0;
  var core = {
    init : function(n) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        _n = n;
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // swaps quadrant
    swap : function(re, im) {
      var xn, yn, i, j, k, l, tmp,
          len = _n >> 1;
      for(var y=0; y<len; y++) {
        yn = y + len;
        for(var x=0; x<len; x++) {
          xn = x + len;
          i = x + y*_n;
          j = xn + yn*_n;
          k = x + yn*_n;
          l = xn + y*_n;
          tmp = re[i];
          re[i] = re[j];
          re[j] = tmp;
          tmp = re[k];
          re[k] = re[l];
          re[l] = tmp;
          tmp = im[i];
          im[i] = im[j];
          im[j] = tmp;
          tmp = im[k];
          im[k] = im[l];
          im[l] = tmp;
        }
      }
    },
    // applies High-Pass Filter
    HPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Low-Pass Filter
    LPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r > radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Band-Pass Filter
    BPF : function(re, im, radius, bandwidth) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius || r > (radius + bandwidth)) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // windowing using hamming window
    windowing : function(data, inv) {
      var len = data.length,
          pi = Math.PI,
          cos = Math.cos;
      for(var i=0; i<len; i++) {
        if(inv === 1) {
          data[i] *= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        } else {
          data[i] /= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        }
      }
    }
  };
  // aliases (public APIs)
  var apis = ['init', 'swap', 'HPF', 'LPF', 'BPF', 'windowing'];
  for(var i=0; i<apis.length; i++) {
    FrequencyFilter[apis[i]] = core[apis[i]];
  }
}).call(this);

/**
 * FFT Power Spectrum Viewer
 */
(function() {
  var SpectrumViewer={};  // top-level namespace
  var _root = this;    // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.SpectrumViewer=SpectrumViewer;
  } else if(typeof exports !== 'undefined') {
    SpectrumViewer = exports;   // for CommonJS
  } else {
    SpectrumViewer = _root.SpectrumViewer = {};
  }

  // core operations
  var _context = null,
      _n = 0,
      _img = null,
      _data = null;
  var core = {
    init : function(context) {
      _context = context;
      _n = context.canvas.width,
      _img = context.getImageData(0, 0, _n, _n);
      _data = _img.data;
    },
    // renders FFT power spectrum on the canvas
    render : function(re, im, islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = _n*_n,
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(Math.sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      for(var j=0; j<n2; j++) {
        spectrum[j] = spectrum[j]*255*imax;
      }
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x=0; x<_n; x++) {
          val = spectrum[i + x];
          p = (i << 2) + (x << 2);
          _data[p] = 0;
          _data[p + 1] = val;
          _data[p + 2] = val >> 1;
        }
      }
      _context.putImageData(_img, 0, 0);
    }
  };
  // aliases (public APIs)
  SpectrumViewer.init = core.init;
  SpectrumViewer.render = core.render;
}).call(this);
};
BundleModuleCode['plugins/csp/csp.js']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     29-5-19 by sbosse.
 **    $VERSION:     1.3.1
 **
 **    $INFO:
 **
 **  Universal Constraint Solver Programming Module
 **
 **    $ENDOFINFO
 */
 
var Io = Require('com/io');
var Comp = Require('com/compat');
var simple = Require('plugins/csp/cspS');
var casso  = Require('plugins/csp/cassowary');
var constr = Require('plugins/csp/constrained');
var fmin   = Require('plugins/csp/fmin');
var checkOptions = Io.checkOptions,
    checkOption = Io.checkOption;

CSP = {
  /* Add constraint */
  C : function (model,v1,v2,f) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        model.constraints.push([v1,v2,f]);
        break;
      case CSP.CSP.CASSOWARY:
        model.solver.addConstraint(v1);
        model.constraints.push(v1);
        break;
      case CSP.CSP.CONSTRAINED:
        model.solver.addConstraint(v1);
        model.constraints.push(v1);
        break;
      case CSP.CSP.FMIN:
        model.constraints.push(v1);
        break;
    }    
  },
  
  // Create Equation
  EQ: function (model,x1,x2) {
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        var eq = new casso.Equation(x1,x2);
        model.equations.push(eq);
        return eq;
        break;
    }   
  },
  // Add constant
  N : function (model,name,val) {
    switch (model.algorithm) {
      case CSP.CSP.CONSTRAINED:
        model.constants[name]=val;
        return model.solver.addConstant(name, model.constants, name);
        break;
      case CSP.CSP.FMIN:
        model.constants[name]=val;
        break;
    }    
    return model.variables[name];
  },

  NEQ: function (model,x1,op,x2) {
    var expr;
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        switch (op) {
          case '<=':
          case '<':
            expr = new casso.Inequality(x1,casso.LEQ,x2);
            break;
          case '>=':
          case '>':
            expr = new casso.Inequality(x1,casso.GEQ,x2);
            break;
        }
        return expr;
        break;
    }   
  },


  // Create Expression
  EXPR: function (model,x1,op,x2) {
    var expr;
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        switch (op) {
          case '+':
            expr = casso.plus(x1,x2);
            break;
          case '-':
            expr = casso.minus(x1,x2);
            break;
          case '<':
            expr = new casso.Inequality(x1,casso.LEQ,x2);
            break;
          case undefined:
            expr = new casso.Expression(x1);
            break;
        }
        return expr;
        break;
    }   
  },
  
  // Add variable
  V : function (model,name,val) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        model.variables[name]=val;
        break;
      case CSP.CSP.CASSOWARY:
        model.variables[name]=new casso.Variable({value:val});
        break;
      case CSP.CSP.CONSTRAINED:
        model.variables[name]=val;
        return model.solver.addVariable(name, model.variables, name);
        break;
      case CSP.CSP.FMIN:
        model.variables[name]=val;
        break;
    }    
    return model.variables[name];
  },


  model2loss : function (model) {
    var objvar,expr,
        vars  = Object.keys(model.variables),
        constraints = model.constraints;
    // only equality constraints are supported!
    if (typeof constraints[0]=='function') 
     return constraints[0];
    if (constraints.length==1 && constraints[0].indexOf('=')>0) {
      var eq = constraints[0].split('=');
      if (objvar=eq[1].match(/[ ]([a-zA-Z0-9]+)/)) {
        objvar=objvar[1];
        expr=eq[0].trim();
      }
    }
    if (objvar && expr && model.constants[objvar]!=undefined) {
      var fcode = 'function loss(_x){';
      fcode += 'var ';
      fcode += vars.map(function (v,index) {  return (v+'=_x['+index+']') }).join(',');
      fcode += '; var err = ';
      fcode += expr;
      fcode += ('-'+model.constants[objvar]);
      fcode += '; return err*err}';
      eval(fcode);
      return loss;
    }
  },
  
  range : function (a,b,step) {
    var res=[];
    if (step==undefined) step=1;
    for(var i=a;i<=b;i=i+step) res.push(i);
    return res;
  },
  
  /* Create a new solver */
  solver : function (options) {
    var model={}
    options=checkOptions(options,{});
    options.algorithm=checkOption(options.algorithm,CSP.CSP.SIMPLE);
    model.algorithm=options.algorithm;
    switch (options.algorithm) {
      case CSP.CSP.SIMPLE:
        model.variables= {}
        model.constraints = []
        break;
      case CSP.CSP.CASSOWARY:
        model.variables= {}
        model.constraints = []
        model.equations = []
        model.solver = new casso.SimplexSolver();
        break;
      case CSP.CSP.CONSTRAINED:
        model.constants= {}
        model.variables= {}
        model.constraints = []
        model.solver = new constr.System();
        break;
      case CSP.CSP.FMIN:
        model.variables= {}
        model.constants= {}
        model.constraints = []
        model.algorithm2=options.solver||'nelderMead';
        model.solver = fmin[model.algorithm2];
        break;
    }
    return model
  },
  /* Solve the problem, return solutions */
  solve : function (model,options) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        return simple.solve(model)
      case CSP.CSP.CASSOWARY:
        model.solver.resolve();
        return model.solver.getInternalInfo()
      case CSP.CSP.CONSTRAINED:
        if (options && options.minimize) return model.solver.minimize(options.minimize);
        if (options && options.maximize) return model.solver.maximize(options.maximize);
        model.solver.resolve();
        return model.variables
      case CSP.CSP.FMIN:
        // here is the main work: construct a loss function from variables, constants, and constraint(s)
        var loss = CSP.model2loss(model);
        var solution = model.solver(loss,
                                    Object.keys(model.variables).map(function (v) {
                                      return model.variables[v]
                                    }));
        return solution
        break;
    }  
  },
  CSP:{
    SIMPLE    : 'SIMPLE',
    DISCRETE  : 'SIMPLE',
    CASSOWARY : 'CASSOWARY',
    LINEAR    : 'CASSOWARY',
    CONSTRAINED : 'CONSTRAINED',
    FMIN : 'FMIN',
  },
  CASSOWARY:casso,
  version: '1.3.1'
}

module.exports = CSP;


};
BundleModuleCode['com/compat']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     30-3-15 by sbosse.
 **    $VERSION:     1.23.6X
 **
 **    $INFO:
 **
 **  JavaScript-OCaML Compatibility Module
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Path = Require('com/path');
var Sprintf = Require('com/sprintf');

/*******************************
** Some global special "values"
********************************/

/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var any = undefined;
/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var _ = undefined;

/**
 *
 * @type {null}
 */
var none = null;
/**
 *
 * @type {null}
 */
var empty = null;

var NL = '\n';

global.int = function (v) {return v|0};
global.div = function (a,b) {return a/b|0};

if (!Object.prototype.forEach) {
	Object.defineProperties(Object.prototype, {
		'forEach': {
			value: function (callback) {
				if (this == null) {
					throw new TypeError('Not an object');
				}
				var obj = this;
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						callback.call(obj, obj[key], key, obj);
					}
				}
			},
			writable: true
		}
	});
}
/** Just transfer parent prototypes to child
 *
 */
function inherit(child,parent) {
  for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}

/** Portable class inheritance and instanceOf polyfill
 *
 */
// SomeObject.prototype.__proto__=SomeObject2.prototype;
// Child class inherits prototype from parent using __proto__
function inheritPrototype(child,parent) {
  var __proto__=child.__proto__;
  child.prototype.__proto__=parent.prototype;
  if (!__proto__) for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}
// Polyfill fir o instanceof c with inheritance check (checking __proto__)
function instanceOf(obj,cla) {
  var p=obj.__proto__;
  if (obj instanceof cla) return true;
  while (p) {
    if (p === cla.prototype) return true;
    p=p.__proto__
  }
  return false;
}
// Polyfill for __defineGetter__ / __defineSetter__
function defineGetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    get:fun
  });
}
function defineSetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    set:fun
  });

}

var inherit = inherit;
var inheritPrototype = inheritPrototype;
var instanceOf = instanceOf;
var defineGetter = defineGetter;
var defineSetter = defineSetter;

/**
 *
 */
var assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
};
global.assert=assert;

function forof(obj,f) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = obj[Symbol.iterator](), _step; 
         !(_iteratorNormalCompletion = (_step = _iterator.next()).done); 
         _iteratorNormalCompletion = true) {
      element = _step.value;

      f(element);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}


global.forof=forof;

/** OBJ
 *
 */
var obj = {
    /** Compact an object:
     * [{a:b},[c:d},..] -> {a:b,c:d,..}
     * {a:[b]} -> {a:b}
     *
     */
    compact: function (o) {
      var a;
      if (obj.isArray(o)) {
        if (o.length==1 && obj.isObject(o[0])) return obj.compact(o[0]);
        else return o;
      } else if (obj.isObject(o)) for (a in o) {
          var elem=o[a];
          o[a]=obj.compact(elem);
      }
      return o;
    },
    copy: function (o) {
      if (o === null || typeof o !== 'object') {
        return o;
      }
 
      var temp = (o instanceof Array) ? [] : {};
      for (var key in o) {
        temp[key] = obj.copy(o[key]);
      }
 
      return temp;    
    },
    equal: function (o1,o2) {
      if (!o1 || !o2) return false;
      for(var i in o1) if (o1[i]!=o2[i]) return false;
      for(var i in o2) if (o1[i]!=o2[i]) return false;
      return true;
    },
    extend: function (o1,o2) {
      for(var i in o2) o1[i]=o2[i];
      return o1;
    },
    find: function(obj,fun) {
      var p;
      for(p in obj) {
          if (fun(obj[p],p)) return obj[p];
      }
    },

    hasProperty: function (o,p) {
      return o[p]!=undefined || (p in o);
    },
    head:function(o) {
      for (var p in o) return p;
      return undefined;
    },
    // transfer src attributes to dst recusively (no object overwrite)
    inherit: function (dst,src) {
      for(var i in src) {
        if (typeof dst[i] == 'object' && typeof src[i] == 'object')
          inherit(dst[i],src[i]);
        else if (typeof dst[i] == 'undefined')
          dst[i]=src[i];
      }
      return dst;
    },
    isArray:function (o) {
      if (o==_ || o ==null) return false;
      else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
    },
    isMatrix:function (o) {
      if (o==_ || o ==null) return false;
      else return obj.isArray(o) &&
                  obj.isArray(o[0]);
    },
    isEmpty: function (o) {
      for(var prop in o) {
         if (o[prop]!=undefined) return false;
      }
      return true;  
    },
    isFunction: function (o) {
        return typeof o == "function";
    },
    isObj:function (o) {
        return typeof o == "object";
    },
    isObject:function (o) {
        return typeof o == "object";
    },
    isRegex: function (o) {
        return o instanceof RegExp;
    },
    isString: function (o) {
        return typeof o == "string" || (typeof o == "object" && o.constructor === String);
    },
    isNumber: function (o) {
        return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
    },


    iter: function(obj,fun) {
      var p;
      for(p in obj) {
        fun(obj[p],p)
      }
    }
};

/** ARRAY
 *
 */
var array = {
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean conjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    and: function(array,fun) {
        var res=true;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res&&fun(element,i)
        }
        return res;
    },
    /** Append one element at the end of the array.
     *
     * @param {* []} array
     * @param {*} element
     * @returns {* []}
     */
    append : function(array,element) {
        array.push(element);
        return array;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    call: function(array,args) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            element()
        }
    },
    /** Check for an elenment in the array by using a check function.
     *
     * @param array
     * @param fun
     * @returns {boolean}
     */
    check: function(array,fun) {
        var i,exist;
        exist=false;
        loop: for(i in array) {
            var element=array[i];
            if (fun(element,i)) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Append array2 at the end of array inplace. The extended array is returned.
     *  Source array (1) will be modified.
     *
     * @param {*[]} array
     * @param {*[]} array2
     * @returns {*[]}
     */
    concat : function(array,array2) {
        for(var i in array2) {
            array.push(array2[i]);
        }
        return array;
    },
    /** Create the conjunction set of two arrays
     *
     */
    conjunction :function (set1,set2,fun) {
      return array.union(set1,set2,fun);
    },
    /**
     *
     * @param {*[]} array
     * @param {number|string|*|*[]} elements
     * @param {function} [fun] Optional equality test function
     * @returns {boolean}
     */
    contains : function(array,elements,fun) {
        var i = array.length;
        if (!fun) fun=function(o1,o2) {return o1===o2};
        if (obj.isArray(elements)) {
          while (i--) {
            var j = elements.length;
            while (j--) {
              if (fun(array[i],elements[j])) {
                  return true;
              }          
            }
          }
        }
        else while (i--) {
            if (fun(array[i],elements)) {
                return true;
            }
        }
        return false;
    },
    /** Return a fresh copy of the source array or copy src array to dst.
     *
     * @param array
     * @returns {Array.<T>|string|Blob|ArrayBuffer}
     */
    copy: function(src,dst) {
        var i;
        if (dst) {
          for(i in src) dst[i]=src[i];  
        } else return src.slice();
    },
    /** Create a new array with initial element values.
     *
     * @param length
     * @param init
     * @returns {Array}
     */
    create : function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    },
    /** Create a matrix (array of array) with initial element values.
     *
     */
    create_matrix : function(rows,cols,init) {
        var m = [];
        var r = [];
        var i,j;
        for (i = 0; i < rows; i++) {
            r=[];
            for(j=0;j<cols;j++) r.push(init);
            m.push(r);
        }
        return m;
    },
    /** Create the (inclusive) disjunction set of two arrays.
     *  Source arrays will not be modified.
     *
     */
    disjunction :function (set1,set2,fun) {
      return array.merge(set1,set2);
    },
    /**
     *
     * @param array
     * @returns {boolean}
     */
    empty : function (array) {
      return (array==undefined ||
              array.length==0)
    },
    
    /** Test for equality
    */
    equal: function (a1,a2) {
      if (a1.length != a2.length) return false;
      for(var i in a1) if (a1[i]!=a2[i]) return false;
      return true;
    },
    
    /** Create the (exclusive) disjunction set of two arrays. 
     *  Source arrays will not be modified.
     *
     */
    exclusive :function (set1,set2,fun) {
        var i,j,found,res = [];
        for (i in set1) {
          found=false;
          loop1: for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) {found=true; break loop1;}
            else if (fun == undefined && set1[i]==set2[j]) {found=true; break loop1;};
          }
          if (!found) res.push(set1[i]);
        }
        for (i in set2) {
          found=false;
          loop2: for (j in set1) {
            if (fun != undefined && fun(set2[i],set1[j])) {found=true; break loop2;}
            else if (fun == undefined && set2[i]==set1[j]) {found=true; break loop2;};
          }
          if (!found) res.push(set2[i]);
        }
        return res;
    },
    /** Find an element in an array and return it (or none);
     *
     * @param array
     * @param fun
     * @returns {undefined|*}
     */
    find: function(array,fun) {
        var i;
        for(i in array) {
          if (fun(array[i],i)) return array[i];
        }
        return none;
    },
    /** Search and map an element of an array using a test&map function.
     *
     * @param array
     * @param {function(*,number):*} fun
     * @returns {undefined|*}
     */
    findmap: function(array,fun) {
        var i,found;
        for(i in array) {
          found=fun(array[i],i);
          if (found) return found;
        }
        return none;
    },
    /** Filter out elements using a test function.
     *
     * @param {* []} array
     * @param {function(*,number):boolean} fun
     * @returns {* []}
     */
    filter: function(array,fun) {
      if (array.filter) return array.filter(fun);
      else {
        var res=[],
            len=array.length,
            element,i;
        for(i=0;i<len;i++) {
            element=array[i];
            if (fun(element,i)) res.push(element);
        }
        return res;
      }
    },
    /** Filter out and map elements using a test&map function.
     *
     * @param {* []} array
     * @param {function(*,number):*|undefined} fun
     * @returns {* []}
     */
    filtermap: function(array,fun) {
        var res=[],
            len=array.length,
            element,mapped,i;
        for(i=0;i<len;i++) {
            element=array[i];
            mapped=fun(element,i);
            if (mapped!=undefined) res.push(mapped);
        }
        return res;
    },
    /** Flattens an array consting of arrays (and elements)
     *
     * @param array
     * @returns {Array}
     */
    flatten: function (array) {
        var res=[];
        var len=array.length;
        var i;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (!obj.isArray(element)) res.push(element);
            else {
                var j;
                var len2=element.length;
                for(j=0;j<len2;j++) {
                    var element2=element[j];
                    res.push(element2);
                }
            }
        }
        return res;

    },
    /**
     *
     * @param array
     * @returns {*}
     */
    head : function(array) {
        return array[0];
    },
    /**
     *
     * @param length
     * @param fun
     * @returns {Array}
     */
    init : function(length,fun) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = fun(i);
        }
        return arr;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter: function(array,fun) {
      /*
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            fun(array[i],i)
        }
      */
      array.forEach(fun);
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     */
    iter2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.iter2: arrays of different lengths'));
        /*
        var len=array1.length;
        for(i=0;i<len;i++) {
            fun(array1[i],array2[i],i)
        }
        */
        array1.forEach(function (e1,i) { fun(e1,array2[i],i) });
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun Returning a true value leaves iteration loop
     */
    iter_break: function(array,fun) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (fun(element,i)) return;
        }
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter_rev: function(array,fun) {
        var i;
        var len=array.length;
        for(i=len-1;i>=0;i--) {
            fun(array[i],i)
        }
    },
    /** Return last element of array.
     *
     */
    last : function(array) {
      var len=array.length;
      if (len==0) return none;
      else return array[len-1];
    },
    
    length : function(array) {
        return array.length;
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     * @returns {* []}
     */
    map2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.map2: arrays of different lengths'));
        var len=array1.length;
        var res=[];
        for(i=0;i<len;i++) {
            res.push(fun(array1[i],array2[i],i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     * @returns {* []}
     */
    map: function(array,fun) {
        var i=0;
        var len=array.length;
        var res=[];
        for(i=0;i<len;i++) {
            var element=array[i];
            res.push(fun(element,i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hdtl  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match: function(array,fun_hdtl,fun_empty) {
        if (array.length == 0) {
            if (fun_empty) fun_empty();
        } else if (array.length>1) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else fun_hdtl(this.head(array),[]);
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hd1hd2  - function(hd1,hd2)
     * @param {Function} [fun_hdtl]  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match2: function(array,fun_hd1hd2,fun_hdtl,fun_empty) {
        if (array.length == 0 && fun_empty)
            fun_empty();
        else if (array.length == 2) {
            var hd1 = this.head(array);
            var hd2 = this.second(array);
            fun_hd1hd2(hd1,hd2);
        }
        else if (array.length>1 && fun_hdtl) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else if (fun_hdtl) fun_hdtl(this.head(array),[]);
    },
    /** Return the maximum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    max : function (array,fun) {        
        var res,max,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (max==undefined) { max=num; res=array[i] } 
            else if (num > max) { max=num; res=array[i] }
        }
        return res;
    },
    /** Return the minimum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    min : function (array,fun) {        
        var res,min,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (min==undefined) { min=num; res=array[i] }
            else if (num < min) { min=num; res=array[i] }
        }
        return res;
    },
    /** Check for an element in the array.
     *
     * @param {(number|string|boolean) []} array
     * @param {number|string|boolean} element
     * @returns {boolean}
     */
    member: function(array,element) {
        var i,exist;
        var len=array.length;
        exist=false;
        loop: for(i=0;i<len;i++) {
            var _element=array[i];
            if (_element==element) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Merge all arrays and return a new array.
     *
     * @param {Array} array1
     * @param {Array} array2
     * @param {Array} [array3]
     * @param {Array} [array4]
     * @returns {Array}
     */
    merge: function(array1,array2,array3,array4) {
        var arraynew=array1.slice();
        arraynew=arraynew.concat(array2);
        if (array3!=undefined) arraynew=arraynew.concat(array3);
        if (array4!=undefined) arraynew=arraynew.concat(array4);
        return arraynew;
    },
    /** Return the next element from array after val (next element after last is first!)
     * @param {Array} array
     * @param {number|string} val
     * @returns {number|string}
     */
    next: function(array,val) {
        var i;
        var len=array.length;
        if (obj.isString(val))
          for(i=0;i<len;i++) {
            if (string.equal(array[i],val)) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
        else
          for(i=0;i<len;i++) {
            if (array[i]==val) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
          
        return none;
    },
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean disjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    or: function(array,fun) {
        var res=false;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res||fun(element,i)
        }
        return res;
    },
    
   /**
     * Gets the property value of `key` from all elements in `collection`.
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * pluck(users, 'user');
     * // => ['barney', 'fred']
     */
    pluck: function(collection, key) {
      return collection.map(function(object) {
          return object == null ? undefined : object[key];
        });
    },
    /*
     ** Push/pop head elements (Stack behaviour)
     */
    /** Remove and return top element of array.
     *
     * @param array
     * @returns {*}
     */
    pop : function(array) {
        var element=array[0];
        array.shift();
        return element;
    },
    print: function(array) {
        var i;
        var len=array.length;
        var str='[';
        for(i=0;i<len;i++) {
            var cell=array[i];
            str=str+cell;
        }
        return str+']';
    },
    /** Add new element at top of array.
     *
     * @param array
     * @param element
     */
    push : function(array,element) {
        array.unshift(element);
    },
    /** Create an ordered array of numbers {a,a+1,..b}
     *
     * @param a
     * @param b
     * @returns {Array}
     */
    range : function(a,b) {
        var i;
        var array=[];
        for(i=a;i<=b;i++) array.push(i);
        return array;
    },
    /** Remove elements from an array.
     *  [1,2,3,4,5,6] (begin=2,end=4) => [1,2,6]
     * @param {* []} array
     * @returns {* []}
     */
    remove: function(array,begin,end) {
      var i,a;
      if (end==undefined) end=begin+1;
      if (begin<0 || end >= array.length) return [];
      a=array.slice(0,begin);
      for(i=end;i<array.length;i++) a.push(array[i]);
      return a;
    },
    
    second : function(array) {
        return array[1];
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,*):number} fun   (1:a gt. b by the ordering criterion,-1: a lt. b, 0: a eq. b)
     * @returns {* []}
     */
    sort: function(array,fun) {
        var array2=array.slice();
        array2.sort(fun);
        return array2;
    },
    /** Split an array at position 'pos', i.e., remove 'len' (1) elements starting at 
     *  position 'pos'.
     *  ==> use remove!!! split should return two arrays!!
     *
     * @param array
     * @param pos
     * @param [len]
     * @param element
     */    
    split: function(array,pos,len) {
      if (pos==0) return array.slice((len||1));
      else {
        var a1=array.slice(0,pos);
        var a2=array.slice(pos+(len||1));
        return a1.concat(a2);
      }
    },
    /** Return the sum number of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    sum : function (array,fun) {        
        var res=0;
        for(var i in array) {
            var num=0;
            if (fun) num=fun(array[i]); else num=array[i];
            if (!obj.isNumber(num)) return undefined;
            res += num;
        }
        return res;
    },
    /** Return a new array w/o the head element (or optional 
     *  w/o the first top elements).
     *
     */
    tail : function(array,top) {
        var array2=array.slice();
        array2.shift();
        if (top) for(;top>1;top--) array2.shift();
        return array2;
    },
    /** Return union of two sets (== conjunction set)
     *
     * @param {* []} set1 
     * @param {* []} set2
     * @param {function} [fun]  Equality test
     * @returns {* []}
     */
    union : function(set1,set2,fun) {
        var i,j,res = [];
        for (i in set1) {
          for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) res.push(set1[i]);
            else if (fun == undefined && set1[i]==set2[j]) res.push(set1[i]);
          }
        }
        return res;
    },
    
    /**
     * Creates a duplicate-free version of an array
     */
    unique: function(array) {
      var length = array ? array.length : 0;
      function baseUniq(array) {
        var index = -1,
            length = array.length,
            seen,
            result = [];

        seen = result;
        outer:
        while (++index < length) {
          var value = array[index];
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        return result;
      }
      if (!length) {
        return [];
      }
      return baseUniq(array);
    },
    
    /**
     * Creates an array excluding all provided values
     * without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    without: function () {
      var array,
          values=[];
      for(var i in arguments) {
        if (i==0) array=arguments[0];
        else values.push(arguments[i]);
      }
      return array.filter(function (e) {
        return values.indexOf(e) == -1;
      });
    },
    /** Test for zero elements {0, '', false, undefined, ..}
    */
    zero: function (array) {
      for(var i in array) if (!!array[i]) return false;
      return true;
    },
};

/** STRING
 *
 */
var string = {
    /** Is pattern conatined in template?
     *
     */
    contains: function (template,pattern) {
      return template.indexOf(pattern)>-1;
    },
    copy: function(src) {
        var i;
        var dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
    },
    /**
     *
     * @param {number} size
     * @returns {string} filled with spaces
     */
    create: function(size)
    {
        var i;
        var s='';
        var init=' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    endsWith : function (str,tail) {
        return str.indexOf(tail)==(str.length-tail.length);
    },
    empty: function (str) {
      return this.equal(str,'');
    },
    equal:  function(str1,str2) {
        var i;
        var eq=true;
        if (str1.length != str2.length) return false;
        for(i=0;i<str1.length;i++) { if (string.get(str1,i)!=string.get(str2,i)) eq=false;}
        return eq;
    },
    find: function (search,str) {
        return str.indexOf(search);
    },
    format_hex: function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
    },
    /**
     *
     * @param {string} str
     * @param {number} index
     * @returns {string}
     */
    get: function (str,index) {
        assert((str != undefined && index < str.length && index >= 0)||('string.get ('+str.length+')'));
        return str.charAt(index);
    },
    isBoolean: function (str) {
        return (str=='true' || str=='false')
    },
    isNumeric: function (str) {
        return !isNaN(parseFloat(str)) && isFinite(str);
    },
    isText: function (s) {
      var is_text=true;
      string.iter(s,function (ch,i) {
        string.match(ch,[
          ['a','z',function () {}],
          ['A','Z',function () {}],
          ['0','9',function () {if (i==0) is_text=false;}],
          function () {is_text=false;}
        ]);
      });
      return is_text;
    },
    /**
     *
     * @param {string} str
     * @param {function(string,number)} fun
     */
    iter: function(str,fun) {
        var i;
        var len=str.length;
        for (i = 0; i < len; i++)  {
            var c = str.charAt(i);
            fun(c,i);
        }
    },
    /**
     *
     * @param str
     * @returns {*}
     */
    length: function(str) {
        if (str!=undefined) return str.length;
        else return 0;
    },
    /**
     *
     * @param str
     * @returns {string}
     */
    lowercase : function (str) {
        return str.toLowerCase();
    },
    /**
     *
     * @param {number} size
     * @param {string} init
     * @returns {string}
     */
    make: function(size,init)
    {
        var i;
        var s='';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    /** Map a string with a set of (test,reuslt) transformation rules.
     * 
     * @param {string} str
     * @param {* [] []} case - ([string,string] | fun) []
     */
    map: function(str,mapping) {
        var i;
        var map;
        for(i in mapping) {
            map=mapping[i];
            if (obj.isFunction(map)) return map(str);
            else if (this.equal(str,map[0])) return map[1];
        }          
    },
    /** Match a string with different patterns and apply a matching function.
     *
     * @param {string} str
     * @param {* [] []} cases - ([string,fun] | [string [<case1>,<case2>,..],fun] | [<range1>:string,<range2>:string,fun] | fun) []
     */
    match: function(str,cases) {
        var i,j;
        var cas,cex,cv;
        for(i in cases) {
            cas=cases[i];
            if (obj.isArray(cas)) {
              switch (cas.length) {
                case 2:
                  // Multi-value-case
                  cex=cas[0];
                  if (!obj.isArray(cex)) {
                      if (this.equal(str,cex)) {
                          cas[1]();
                          return;
                      }
                  } else {
                      for(j in cex) {
                          cv=cex[j];
                          if (this.equal(str,cv)) {
                              cas[1]();
                              return;
                          }
                      }
                  }
                  break;
                case 3:
                  // Character range check
                  try {
                    j=pervasives.int_of_char(str);
                    if (j>= pervasives.int_of_char(cas[0]) && j<=pervasives.int_of_char(cas[1])) {
                      cas[2](str);
                      return;
                    }
                  } catch(e) {
                    return
                  };
                  break;
                case 1:
                  cas[0](str); // Default case - obsolete
                  return;
                default: 
                  throw 'String.match #args';
              }
            } else if (obj.isFunction(cas)) {
                // Default case
                cas(str);
                return;
            }
        }
    },
    /** Pad a string on the left (pre-str.length) if pre>0,
     *  right (post-str.length) if post>0, or centered (pre>0&post>0).
     *
     */
     
    pad: function (str,pre,post,char) {
      var len = str.length;
      if (pre>0 && post==0) return string.make(len-pre,char||' ')+str;
      else if (post>0 && pre==0) return str+string.make(post-len,char||' ');
      else return string.make(len-pre/2,char||' ')+str+string.make(len-post/2,char||' ');
    },
    /**
     *
     * @param str
     * @param pos
     * @param len
     * @returns {Number}
     */
    parse_hex: function (str,pos,len) {
        // parse a hexadecimal number in string 'str' starting at position 'pos' with 'len' figures.
        return parseInt(this.sub(str,pos,len),16);
    },
    /** Return the sub-string after a point in the source string ('.' or optional point string).
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    postfix: function (str,point) {
      var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(n+1);
    },
    /** Return the sub-string before a point in the source string ('.' or optional point string)
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    prefix: function (str,point) {
        var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(0,n);
    },
    replace_first: function (pat,repl,str) {
        return str.replace(pat,repl);
    },
    replace_all: function (pat,repl,str) {
        return str.replace('/'+pat+'/g',repl);
    },
    /**
     *
     * @param str
     * @param index
     * @param char
     * @returns {string}
     */
    set: function (str,index,char) {
        assert((str != undefined && index < str.length && index >= 0)||'string.get');
        return str.substr(0, index) + char + str.substr(index+1)
    },
    /**
     *
     * @param delim
     * @param str
     * @returns {*|Array}
     */
    split: function (delim,str) {
        return str.split(delim);
    },
    startsWith : function (str,head) {
        return !str.indexOf(head);
    },
    /** Return a sub-string.
     * 
     * @param str
     * @param off
     * @param [len] If not give, return a sub-string from off to end
     * @returns {string}
     */
    sub: function (str,off,len) {
        if (len)
            return str.substr(off,len);
        else
            return str.substr(off);
    },
    /** Remove leading and trailing characters from string
     *
     * @param str
     * @param {number} pref number of head characters to remove
     * @param {number} post number of tail characters to remove
     * @returns {*}
     */
    trim: function (str,pref,post) {
        if (str.length==0 ||
            pref>str.length ||
            post>str.length ||
            pref < 0 || post < 0 ||
            (pref==0 && post==0)
        ) return str;
        return str.substr(pref,str.length-pref-post);
    },
    /** Return a string with all characters converted to uppercase letters.
     *
     * @param str
     * @returns {string}
     */
    uppercase : function (str) {
        return str.toUpperCase();
    },
    /** Return a string with first character converted to uppercase letter.
     *
     * @param str
     * @returns {string}
     */
    Uppercase : function (str) {
        var len = str.length;
        if (len > 1) {
            var head = str.substr(0,1);
            var tail = str.substr(1,len-1);
            return head.toUpperCase()+tail.toLowerCase()
        } if (len==1) return str.toUpperCase();
        else return '';
    }
};

/** RANDOM
 *
 */
var rnd = Math.random;
/* Antti Syk�ri's algorithm adapted from Wikipedia MWC
** Returns a random generator function [0.0,1.0| with seed initialization
*/
var seeder = function(s) {
    var m_w  = s;
    var m_z  = 987654321;
    var mask = 0xffffffff;

    return function() {
      m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
      m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;

      var result = ((m_z << 16) + m_w) & mask;
      result /= 4294967296;

      return result + 0.5;
    }
}
 
var random = {
    float: function(max) {
        return rnd()*max
    }, 
    int: function(max) {
        return Math.floor(rnd()*max+0)
    },
    // integer
    interval: function(min,max) {
        return Math.round(min+rnd()*(max-min))
    },
    // float
    range: function(min,max) {
        return min+rnd()*(max-min)
    },
    seed: function (s) {
      // Create a new initialized random generator
      rnd=seeder(s);
    }
};

/** PRINTF
 *
 */
var printf = {
    /** Trim string(s).
     *
     * @param str
     * @param indent
     * @param [width]
     * @param {string} [tab]
     * @returns {string}
     */
    align: function (str,indent,width,tab) {
        var lines = string.split('\n',str);
        var form = '';
        var sp = printf.spaces(indent);
        var spbreak = sp;

        array.iter(lines,function(line){
            var rest;
            function breakit(spbreak,str) {
                if (width < (str.length + spbreak.length)) {
                    return spbreak+string.sub(str,0,width-spbreak.length)+'\n'+
                           breakit(spbreak,string.sub(str,width-spbreak.length,str.length-width+spbreak.length));
                } else return spbreak+str+'\n';
            }
            if (width && width < (line.length + indent)) {
                if (tab) {
                    var pos = string.find(tab,line);
                    if (pos > 0 && pos < width) spbreak=printf.spaces(pos+indent+1);
                    else spbreak=sp;
                }
                form=form+sp+string.sub(line,0,width-indent)+'\n';
                rest=string.sub(line,width-indent,line.length-width+indent);
                form=form+breakit(spbreak,rest);
            }
            else
                form=form+sp+line+'\n';
        });
        return form;
    },
    /** Format a list of array elements using the (optional) mapping
     *  function <fun> and the separator <sep> (optional, too, default is ',').
     * 
     */
    list: function (array,fun,sep) {
      var i, str='';
      if (sep==undefined) sep=',';
      if (fun==undefined) fun=function (s) {return s;};
      if (!obj.isArray(array)) array=[array];
      for (i in array) {
        if (str==='') str=fun(array[i]);
        else str=str+sep+fun(array[i]);
      }
      return str;
    },
    /**
     *
     * @param n
     * @returns {string}
     */
    spaces: function (n){
        return string.make(n,' ');
    },
    /** Formatted printer (simplified)
     *
     * @param {* []} args (['%format',arg]|string) []  format=%s,%d,%f,%c,%x,%#d,%#s,..
     * @returns {string}
     */
    sprintf2: function(args) {
        var str='';
        array.iter(args,function(fmtarg) {
            var len, n,fs;
            if (obj.isArray(fmtarg)) {
                if (fmtarg.length==2) {
                    var fmt=fmtarg[0];
                    var arg=fmtarg[1];
                    var fc='';
                    var fn=0;
                    string.iter(fmt,function(c) {
                        if (c=='s' || c=='d' || c=='f' || c=='x') {
                            fc=c;
                        } else if (c!='%') {
                            fn=fn*10;
                            n=parseInt(c);
                            if (!isNaN(n)) fn=fn+n;
                        }
                    });
                    if (fc=='s' && obj.isString(arg)) {
                        str=str+arg;
                        if (fn!=0) {
                            len=arg.length;
                            if (len<fn) str=str+string.create(fn-len);
                        }
                    } else if (fc=='d' && obj.isNumber(arg)) {
                        fs = pervasives.string_of_int(arg);
                        if (fn!=0) {
                            len = fs.length;
                            if (len < fn) {
                                str=str+string.create(fn-len);
                            }
                        }
                        str=str+fs;
                    } else if (fc=='x' && obj.isNumber(arg)) {
                        fs = string.format_hex(arg,fn||8);
                        str=str+fs;
                    }
                }
            } else if (obj.isString(fmtarg)) {
                str = str + fmtarg;
            }
        });
        return str;
    },
    sprintf:Sprintf.sprintf
};

/** FILENAME
 *
 */
var filename = {
    /**
     *
     * @param path
     * @returns {string}
     */
    basename : function (path) {
        return Path.basename(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    dirname : function (path) {
        return Path.dirname(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    extname : function (path) {
        return Path.extname(path)
    },
    /**
     *
     * @param path
     * @returns {boolean}
     */
    is_relative: function(path) {
        return !(path.length > 0 && path[0] == '/');
    },
    /**
     *
     * @param pathl
     * @param absolute
     * @returns {string}
     */
    join: function (pathl,absolute) {
        var path=(absolute?'/':'');
        array.iter(pathl,function (name,index) {
            if (index>0) {
                path=path+'/'+name;
            }
            else {
                path=path+name;
            }
        });
        return path;
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    normalize : function (path) {
        return Path.normalize(path)
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    path_absolute: function (path) {
        if (this.is_relative(path)) {
            var workdir = Io.workdir();
            return this.path_normalize(workdir + '/' + path);
        } else return this.path_normalize(path);
    },
    /** Duplicate of Path.normalize!?
     *
     * @param path
     * @returns {string}
     */
    path_normalize: function (path) {
        var i;
        if (string.equal(path, '')) path = '/';
        var relpath = !(string.get(path, 0) == '/');
        var pathlist = path.split('/');
        var pathlist2 = pathlist.filter(function (s) {
            return (!string.equal(s, '') && !string.equal(s, '.'))
        });
        var pathlist3 = [];
        array.iter(pathlist2, function (pe) {
            if (!string.equal(pe, '..')) {
                array.push(pathlist3, pe)
            } else {
                if (pathlist3.length == 0) return '';
                else
                    pathlist3 = array.tail(pathlist3);
            }
        });
        var path2 = '';
        i = 0;
        array.iter(pathlist3, function (pe) {
            var sep;
            if (i == 0) sep = ''; else sep = '/';
            path2 = pe + sep + path2;
            i++;
        });
        if (relpath) return path2; else return '/' + path2;
    },
    removeext: function (path) {
      return path.substr(0, path.lastIndexOf('.'));
    }
};

/** PERVASIVES
 *
 *
 */
var pervasives = {
    assert:assert,
    char_of_int: function (i) {return String.fromCharCode(i)},
    div: function(a,b) {return a/b|0;},
    failwith: function(msg) {Io.err(msg);},
    float_of_string: function(s) {var num=parseFloat(s); if (isNaN(num)) throw 'NaN'; else return num;},
    int_of_char: function(c) {return c.charCodeAt()},
    int_of_float: function(f) {return f|0;},
    int_of_string: function(s) {      
      var num=parseInt(s); if (isNaN(num)) throw 'NaN'; else return num;
    },

    /** Try to find a value in a search list and return a mapping value.
     *
     * @param {*} value
     * @param {* []} mapping [testval,mapval] []
     * @returns {*}
     */
    map: function(value,mapping) {
        function eq(v1,v2) {
            if (v1==v2) return true;
            if (obj.isString(v1) && obj.isString(v2)) return string.equal(v1,v2);
            return false;
        }
        if (!array.empty(mapping)) {
          var hd=array.head(mapping);
          var tl=array.tail(mapping);
          if (eq(hd[0],value)) return hd[1];
          else return pervasives.map(value,tl);
        }  else return undefined;
    },
    /** Apply a matcher function to a list of cases with case handler functions.
     * A case is matched if the matcher function returns a value/object.
     *
     * The result of the matcher function is passed as an argument ot the case handler function.
     * The return value of the case handler fucntion is finally returned by this match function
     * or undefined if there was no matching case.
     *
     * @param {function(*,*):*} matcher function(expr,pat)
     * @param {*} expr
     * @param {*[]} cases (pattern,handler function | handler function) []
     * @returns {*|undefined}
     */
    match: function (matcher,expr,cases) {
        var ret = undefined;
        array.iter_break(cases, function (match) {
            var quit, succ, pat, fun;

            if (match.length == 2) {
                /*
                 ** Pattern, Function
                 */
                pat = match[0];
                fun = match[1];
                succ = matcher(expr, pat);
                if (succ) ret = fun(succ);
                quit = succ!=undefined;
            } else if (match.length == 1) {
                /*
                 ** Default case, Function
                 */
                fun = match[0];
                ret = fun();
                quit= true;
            }
            return quit;
        });
        return ret;
    },
    mtime: function () {var time = new Date(); return time.getTime();},
    min: function(a,b) { return (a<b)?a:b},
    max: function(a,b) { return (a>b)?a:b},
    string_of_float: function(f) {return f.toString()},
    string_of_int: function(i) {return i.toString()},
    string_of_int64: function(i) {return i.toString()},
    time: function () {var time = new Date(); return (time.getTime()/1000)|0;}
};

/** BIT
 *
 */
var bit = {
    get: function (v,b) {return (v >> b) && 1;},
    isSet: function (v,b) {return ((v >> b) && 1)==1;},
    set: function (v,b) {return v & (1 << b);}
};

/** ARGS
 *
 */
var args = {
    /** Parse process or command line arguments (array argv). The first offset [1] arguments are
     ** ignored. The numarg pattern '*' consumes all remaining arguments.
     *
     * @param {string []} argv
     * @param {*[]} map  [<argname>,<numargs:0..3|'*'>,<handler(up to 3 arguments|[])>]|[<defhandler(val)>] []
     * @param {number} [offset]
     */
    parse: function(argv,map,offset) {
        var shift=undefined,
            in_shift=0,
            shift_args=[],
            names,
            mapfun,
            numarg,
            len=argv.length;

        if (offset==undefined) offset=1;

        argv.forEach(function (val, index) {
            var last=index==(len-1);
            if(index>=offset) {
                if (in_shift==0) {
                    array.check(map,function (onemap) {
                        assert(onemap!=undefined||'map');
                        if (onemap.length==3) {
                            names  = onemap[0];
                            numarg = onemap[1];
                            mapfun = onemap[2];
                            if (!obj.isArray(names)) names=[names];
                            var found = array.find(names,function (name) {
                                if (string.equal(val, name)) return name; else _;
                            });
                            if (found) {
                                if (numarg==0) mapfun(found);
                                else {
                                    in_shift=numarg;
                                    shift_args=[];
                                    shift=mapfun;
                                }
                                return true;
                            }
                        } else if (obj.isFunction(onemap)) {
                          onemap(val);
                          return true;                        
                        } else if (onemap.length==1) {
                            mapfun = onemap[0];
                            mapfun(val);
                            return true;
                        }
                        return false;
                    });
                } else {
                    shift_args.push(val);
                    if (in_shift!='*') in_shift--;
                    if (in_shift==0 && shift!=undefined) {
                        numarg=shift_args.length;
                        switch (numarg) {
                            case 0: shift(val);break;
                            case 1: shift(shift_args[0],val); break;
                            case 2: shift(shift_args[0],shift_args[1],val); break;
                            case 3: shift(shift_args[0],shift_args[1],shift_args[2],val); break;
                            default: break;
                        }
                        shift=undefined;
                    } else if (in_shift=='*' && last) shift(shift_args);
                }
            }
        });
    }

};

/** HASHTBL
 *
 */
var hashtbl = {
    add: function(hash,key,data) {
        hash[key]=data;
    },
    create: function(initial) {
        return [];
    },
    empty: function(hash) {
        for (var key in hash) return false;
        return true;
    },
    find: function(hash,key) {
        return hash[key];
    },
    invalidate: function(hash,key) {
        hash[key]=undefined;
    },
    iter: function(hash,fun) {
        for (var key in hash) {
            if (hash[key]!=undefined) fun(key,hash[key]);
        }
    },
    mem: function(hash,key) {
        return hash[key] != undefined;
    },
    remove: function(hash,key) {
        // TODO: check, its wrong!
        if (!hash.hasOwnProperty(key))
            return;
        if (isNaN(parseInt(key)) || !(hash instanceof Array))
            delete hash[key];
        else
            hash.splice(key, 1)
    }
};

var types = [];
/**
 * 
 * @param name
 * @returns {number}
 */
function register_type(name) {
    var typoff = 1000+types.length*1000;
    if (array.member(types,name)) throw('[COMP] register_type: type '+name+' exists already.');
    types.push(name);
    return typoff;
}

/**
 *
 * @typedef {{v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tuple
 */
/**
 *
 * @typedef {{t:number, v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tagged_tuple
 */

module.exports = {
    args:args,
    assert: assert,
    array:array,
    bit:bit,
    defineGetter : defineGetter,
    defineSetter : defineSetter,
    div:pervasives.div,
    filename:filename,
    hashtbl:hashtbl,
    inherit : inherit,
    inheritPrototype : inheritPrototype,
    instanceOf : instanceOf,
    isNodeJS: function () {
        return (typeof global !== "undefined" &&
                {}.toString.call(global) == '[object global]');
    },
    obj:obj,
    pervasives:pervasives,
    printf:printf,
    random:random,
    string:string,
    isArray: obj.isArray,
    isString: obj.isString,
    isNumber: obj.isNumber,

    register_type:register_type,
    /**
     *
     * @param tag
     * @param [val1]
     * @param [val2]
     * @param [val3]
     * @returns {(tagged_tuple)}
     */
    Tuple: function (tag,val1,val2,val3) {
        if(val3) return {t:tag,v1:val1,v2:val2,v3:val3};
        else if (val2) return {t:tag,v1:val1,v2:val2};
        else if (val1) return {t:tag,v1:val1};
        else return {t:tag};
    }
};
};
BundleModuleCode['plugins/csp/cspS']=function (module,exports){
var CSP = {},
    FAILURE = 'FAILURE',
    stepCounter = 0;

CSP.solve = function solve(csp) {
  // Solves a constraint satisfaction problem.
  // `csp` is an object that should have the properties:
  //    `variables`  : object that holds variable names and their domain.
  //    `constraints`: list of constraints where each element is an 
  //                   array of [head node, tail node, constraint function]
  //    `cb`: optional callback function.

  var result = backtrack({}, csp.variables, csp);
  if (result == FAILURE) { return result; }
  // Unwrap values from array containers.
  for (var key in result) {
    result[key] = result[key][0];
  }
  if (csp.cb) csp.cb(result);
  return result;
}

function backtrack(_assigned, unassigned, csp) {
  // Backtracking search.
  
  // Copying assigned in necessary because we modify it. Without copying
  // the object over, modifying assigned would also change values for old
  // assigned objects (which are used in callbacks).
  var assigned = {};
  for (var key in _assigned) { assigned[key] = _assigned[key]; }

  if (finished(unassigned)) { return assigned; } // Base case.
  var nextKey = selectUnassignedVariable(unassigned),
      values = orderValues(nextKey, assigned, unassigned, csp);
  delete unassigned[nextKey];

  for (var i = 0; i < values.length; i++) {
    stepCounter++;
    assigned[nextKey] = [values[i]]; // Assign a value to a variable.
    var consistent = enforceConsistency(assigned, unassigned, csp);
    var newUnassigned = {}, newAssigned = {};
    for (var key in consistent) {
      if (assigned[key]) { newAssigned[key] = assigned[key].slice(); }
      else { newUnassigned[key] = consistent[key].slice(); }
    }
    if (anyEmpty(consistent)) { continue; } // Empty domains means failure.
    var result = backtrack(newAssigned, newUnassigned, csp);
    if (result != FAILURE) { return result; }
  }

  return FAILURE;
}

function finished(unassigned) {
  // Checks if there are no more variables to assign.
  return Object.keys(unassigned).length == 0;
}

function anyEmpty(consistent) {
  // Checks if any variable's domain is empty.
  for (var key in consistent) {
    if (consistent[key].length == 0) { return true; }
  }
  return false;
}

function partialAssignment(assigned, unassigned) {
  // Combine unassigned and assigned for use in enforceConsistency.
  var partial = {};
  for (var key in unassigned) { partial[key] = unassigned[key].slice(); }
  for (var key in assigned) { partial[key] = assigned[key].slice(); }
  return partial;
}

function enforceConsistency(assigned, unassigned, csp) {
  // Enforces arc consistency by removing inconsistent values from
  // every constraint's tail node.

  function removeInconsistentValues(head, tail, constraint, variables) {
    var hv,tv,validHeadValues,validTailValues,removed;
    if (tail) {
      // Removes inconsistent values from the tail node. A value is
      // inconsistent when if the `tail` is assigned that value, there are
      // no values in `head`'s domain that satisfies the constraint.
      // - binray constraint
      hv = variables[head], tv = variables[tail];
      validTailValues = tv.filter(function (t) {
        return hv.some(function (h) {
          return constraint(h, t);
        });
      });
      removed = tv.length != validTailValues.length;
      variables[tail] = validTailValues;
    } else {
      // unary constraint - modify head
      hv = variables[head];
      validHeadValues = hv.filter(function (h) {
          return constraint(h);
      });
      removed = hv.length != validHeadValues.length;
      variables[head] = validHeadValues;
    }
    return removed;
  }

  function incomingConstraints(node) {
    // Returns all the constraints where `node` is the head node.
    return csp.constraints.filter(function (c) {
      return c[0] == node;
    });
  }
  
  var queue = csp.constraints.slice(), 
      variables = partialAssignment(assigned, unassigned);
  while (queue.length) { // While there are more constraints to test.
    var c = queue.shift(), head = c[0], tail = c[1], constraint = c[2];
    if (removeInconsistentValues(head, tail, constraint, variables)) {
      // If values from the tail have been removed, incoming constraints
      // to the tail must be rechecked.
      queue = queue.concat(incomingConstraints(tail));
    }
  }
  return variables;
}

function selectUnassignedVariable(unassigned) {
  // Picks the next variable to assign according to the Minimum
  // Remaining Values heuristic. Pick the variable with the fewest
  // values remaining in its domain. This helps identify domain
  // failures earlier.
  var minKey = null, minLen = Number.POSITIVE_INFINITY;
  for (var key in unassigned) {
    var len = unassigned[key].length;
    if (len < minLen) { minKey = key, minLen = len; }
  }
  return minKey;
}

function orderValues(nextKey, assigned, unassigned, csp) {
  // Orders the values of an unassigned variable according to the
  // Least Constraining Values heuristic. Perform arc consistency
  // on each possible value, and order variables according to the
  // how many values were eliminated from all the domains (fewest
  // eliminated in the front). This helps makes success more likely
  // by keeping future options open.
  
  function countValues(vars) {
    var sum = 0;
    for (var key in vars) { sum += vars[key].length; }
    return sum;
  }

  function valuesEliminated(val) {
    assigned[nextKey] = [val];
    var newLength = countValues(enforceConsistency(assigned, unassigned, csp));
    delete assigned[nextKey];
    return newLength;
  }

  // Cache valuesEliminated to be used in sort.
  var cache = {}, values = unassigned[nextKey];
  values.forEach(function(val) {
    cache[val] = valuesEliminated(val);
  });
  // Descending order based on the number of domain values remaining.
  values.sort(function (a, b) { return cache[b] - cache[a]; });
  return values;
}

module.exports = CSP;
};
BundleModuleCode['plugins/csp/cassowary']=function (module,exports){
/**
 * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
 * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
 *
 * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
 *
 * This is a compiled version of Cassowary/JS. For source versions or to
 * contribute, see the github project:
 *
 *  https://github.com/slightlyoff/cassowary.js/
 *  https://github.com/slightlyoff/cassowary-js-refactor
 *
 */

(function() {
!function(a){"use strict";var b="undefined"!=typeof a.HTMLElement,c=function(a){for(var b=null;a&&a!=Object.prototype;){if(a.tagName){b=a.tagName;break}a=a.prototype}return b||"div"},d=1e-8,e={},f=function(a,b){if(a&&b){if("function"==typeof a[b])return a[b];var c=a.prototype;if(c&&"function"==typeof c[b])return c[b];if(c!==Object.prototype&&c!==Function.prototype)return"function"==typeof a.__super__?f(a.__super__,b):void 0}},g=!1;try{var h=new Map;h.set("foo","bar");var i=h.values();i.next(),h.forEach(function(){});var k=new Map(h);if(k.get("foo")!=h.get("foo"))throw"ctor fail";g=!0}catch(l){}var m=a.c=function(){return m._api?m._api.apply(this,arguments):void 0};m._functionalMap=g,m.GEQ=1,m.LEQ=2;var n=b?function(b,d,e){if(d&&d.prototype instanceof a.HTMLElement){var g=b,h=c(e),i=function(a){return a.__proto__=e,g.apply(a,arguments),e.created&&a.created(),e.decorate&&a.decorate(),a};m.extend(e,{upgrade:i}),b=function(){return i(a.document.createElement(h))},b.prototype=e,m.extend(b,{ctor:g})}return b}:function(a){return a};m.inherit=function(a){var b=null,c=null;a["extends"]&&(c=a["extends"],delete a["extends"]),a.initialize&&(b=a.initialize,delete a.initialize);var d=b||function(){};Object.defineProperty(d,"__super__",{value:c?c:Object,enumerable:!1,configurable:!0,writable:!1}),a._t&&(e[a._t]=d);var f=d.prototype=Object.create(c?c.prototype:Object.prototype);return m.extend(f,a),n(d,c,f,a)},m.own=function(b,c,d){return Object.getOwnPropertyNames(b).forEach(c,d||a),b},m.extend=function(a,b){return m.own(b,function(c){var d=Object.getOwnPropertyDescriptor(b,c);if("function"==typeof d.get||"function"==typeof d.set)Object.defineProperty(a,c,d);else if("function"==typeof d.value||"_"===c.charAt(0))d.writable=!0,d.configurable=!0,d.enumerable=!1,Object.defineProperty(a,c,d);else try{a[c]=b[c]}catch(e){}}),a},m.assert=function(a,b){if(!a)throw new m.InternalError("Assertion failed: "+b)};var o=function(a){return"number"==typeof a?m.Expression.fromConstant(a):a instanceof m.Variable?m.Expression.fromVariable(a):a};m.plus=function(a,b){return a=o(a),b=o(b),a.plus(b)},m.minus=function(a,b){return a=o(a),b=o(b),a.minus(b)},m.times=function(a,b){return a=o(a),b=o(b),a.times(b)},m.divide=function(a,b){return a=o(a),b=o(b),a.divide(b)},m.approx=function(a,b){return a=+a,b=+b,a===b?!0:0==a?Math.abs(b)<d:0==b?Math.abs(a)<d:Math.abs(a-b)<Math.abs(a)*d};var p=1;m._inc=function(){return p++},m.parseJSON=function(a){return JSON.parse(a,function(a,b){if("object"!=typeof b||"string"!=typeof b._t)return b;var c=b._t,d=e[c];if(c&&d){var g=f(d,"fromJSON");if(g)return g(b,d)}return b})},"function"==typeof define&&define.amd?define(m):"object"==typeof module&&module.exports?module.exports=m:a.c=m}(this),function(a){"use strict";if(a._functionalMap)a.HashTable=a.inherit({initialize:function(b){this.hashCode=a._inc(),this._store=b instanceof a.HashTable?new Map(b._store):new Map},clone:function(){return new a.HashTable(this)},get:function(a){var b=this._store.get(a.hashCode);return void 0===b?null:b[1]},clear:function(){this._store.clear()},get size(){return this._store.size},set:function(a,b){return this._store.set(a.hashCode,[a,b])},has:function(a){return this._store.has(a.hashCode)},"delete":function(a){return this._store.delete(a.hashCode)},each:function(a,b){this._store.forEach(function(c){return a.call(b||null,c[0],c[1])},b)},escapingEach:function(a,b){if(this._store.size)for(var c,e,f=this._store.values(),e=f.next();!e.done;){if(c=a.call(b||null,e.value[0],e.value[1])){if(void 0!==c.retval)return c;if(c.brk)break}e=f.next()}},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c in this._store.keys())if(void 0==b._store.get(c))return!1;return!0}});else{var b={},c=function(a,b){Object.keys(a).forEach(function(c){b[c]=a[c]})};a.HashTable=a.inherit({initialize:function(){this.size=0,this._store={},this._deleted=0},set:function(a,b){var c=a.hashCode;"undefined"==typeof this._store[c]&&this.size++,this._store[c]=[a,b]},get:function(a){if(!this.size)return null;a=a.hashCode;var b=this._store[a];return"undefined"!=typeof b?b[1]:null},clear:function(){this.size=0,this._store={}},_compact:function(){var a={};c(this._store,a),this._store=a},_compactThreshold:100,_perhapsCompact:function(){this._size>30||this._deleted>this._compactThreshold&&(this._compact(),this._deleted=0)},"delete":function(a){a=a.hashCode,this._store.hasOwnProperty(a)&&(this._deleted++,delete this._store[a],this.size>0&&this.size--)},each:function(a,b){if(this.size){this._perhapsCompact();var c=this._store;for(var d in this._store)this._store.hasOwnProperty(d)&&a.call(b||null,c[d][0],c[d][1])}},escapingEach:function(a,c){if(this.size){this._perhapsCompact();for(var d=this,e=this._store,f=b,g=Object.keys(e),h=0;h<g.length;h++)if(function(b){d._store.hasOwnProperty(b)&&(f=a.call(c||null,e[b][0],e[b][1]))}(g[h]),f){if(void 0!==f.retval)return f;if(f.brk)break}}},clone:function(){var b=new a.HashTable;return this.size&&(b.size=this.size,c(this._store,b._store)),b},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c=Object.keys(this._store),d=0;d<c.length;d++){var e=c[d];if(this._store[e][0]!==b._store[e][0])return!1}return!0},toString:function(){var b="";return this.each(function(a,c){b+=a+" => "+c+"\n"}),b},toJSON:function(){return{_t:"c.HashTable"}},fromJSON:function(){var c=new a.HashTable;return c}})}}(this.c||module.parent.exports||{}),function(a){"use strict";a.HashSet=a._functionalMap?a.inherit({_t:"c.HashSet",initialize:function(b){this.hashCode=a._inc(),this._store=b instanceof a.HashSet?new Map(b._store):new Map},add:function(a){return this._store.set(a.hashCode,a)},has:function(a){return this._store.has(a.hashCode)},get size(){return this._store.size},clear:function(){this._store.clear()},values:function(){for(var a=[],b=this._store.values(),c=b.next();!c.done;)a.push(c.value),c=b.next();return a},first:function(){var a=this._store.values(),b=a.next();return b.done?null:b.value},"delete":function(a){this._store.delete(a.hashCode)},each:function(a,b){var c=this;this._store.forEach(function(d){return a.call(b||null,d,d,c)},b)},escapingEach:function(a,b){this.size&&this._store.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a[a.length]=b.toJSON()}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c._store=b.data),c}}):a.inherit({_t:"c.HashSet",initialize:function(){this._store=[],this.size=0,this.hashCode=a._inc()},add:function(a){var b=this._store;b.indexOf(a),-1==b.indexOf(a)&&(b[b.length]=a),this.size=b.length},values:function(){return this._store},first:function(){return this._store[0]},has:function(a){return-1!=this._store.indexOf(a)},"delete":function(a){var b=this._store.indexOf(a);return-1==b?null:(this._store.splice(b,1)[0],this.size=this._store.length,void 0)},clear:function(){this._store.length=0},each:function(a,b){this.size&&this._store.forEach(a,b)},escapingEach:function(a,b){this.size&&this._store.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a[a.length]=b.toJSON()}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c._store=b.data),c}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Error=a.inherit({initialize:function(a){a&&(this._description=a)},_name:"c.Error",_description:"An error has occured in Cassowary",set description(a){this._description=a},get description(){return"("+this._name+") "+this._description},get message(){return this.description},toString:function(){return this.description}});var b=function(b,c){return a.inherit({"extends":a.Error,initialize:function(){a.Error.apply(this,arguments)},_name:b||"",_description:c||""})};a.ConstraintNotFound=b("c.ConstraintNotFound","Tried to remove a constraint never added to the tableu"),a.InternalError=b("c.InternalError"),a.NonExpression=b("c.NonExpression","The resulting expression would be non"),a.NotEnoughStays=b("c.NotEnoughStays","There are not enough stays to give specific values to every variable"),a.RequiredFailure=b("c.RequiredFailure","A required constraint cannot be satisfied"),a.TooDifficult=b("c.TooDifficult","The constraints are too difficult to solve")}(this.c||module.parent.exports||{}),function(a){"use strict";var b=1e3;a.SymbolicWeight=a.inherit({_t:"c.SymbolicWeight",initialize:function(){this.value=0;for(var a=1,c=arguments.length-1;c>=0;--c)this.value+=arguments[c]*a,a*=b},toJSON:function(){return{_t:this._t,value:this.value}}})}(this.c||module.parent.exports||{}),function(a){a.Strength=a.inherit({initialize:function(b,c,d,e){this.name=b,this.symbolicWeight=c instanceof a.SymbolicWeight?c:new a.SymbolicWeight(c,d,e)},get required(){return this===a.Strength.required},toString:function(){return this.name+(this.required?"":":"+this.symbolicWeight)}}),a.Strength.required=new a.Strength("<Required>",1e3,1e3,1e3),a.Strength.strong=new a.Strength("strong",1,0,0),a.Strength.medium=new a.Strength("medium",0,1,0),a.Strength.weak=new a.Strength("weak",0,0,1)}(this.c||("undefined"!=typeof module?module.parent.exports.c:{})),function(a){"use strict";a.AbstractVariable=a.inherit({isDummy:!1,isExternal:!1,isPivotable:!1,isRestricted:!1,_init:function(b,c){this.hashCode=a._inc(),this.name=(c||"")+this.hashCode,b&&("undefined"!=typeof b.name&&(this.name=b.name),"undefined"!=typeof b.value&&(this.value=b.value),"undefined"!=typeof b.prefix&&(this._prefix=b.prefix))},_prefix:"",name:"",value:0,valueOf:function(){return this.value},toJSON:function(){var a={};return this._t&&(a._t=this._t),this.name&&(a.name=this.name),"undefined"!=typeof this.value&&(a.value=this.value),this._prefix&&(a._prefix=this._prefix),this._t&&(a._t=this._t),a},fromJSON:function(b,c){var d=new c;return a.extend(d,b),d},toString:function(){return this._prefix+"["+this.name+":"+this.value+"]"}}),a.Variable=a.inherit({_t:"c.Variable","extends":a.AbstractVariable,initialize:function(b){this._init(b,"v");var c=a.Variable._map;c&&(c[this.name]=this)},isExternal:!0}),a.DummyVariable=a.inherit({_t:"c.DummyVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"d")},isDummy:!0,isRestricted:!0,value:"dummy"}),a.ObjectiveVariable=a.inherit({_t:"c.ObjectiveVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"o")},value:"obj"}),a.SlackVariable=a.inherit({_t:"c.SlackVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"s")},isPivotable:!0,isRestricted:!0,value:"slack"})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Point=a.inherit({initialize:function(b,c,d){if(b instanceof a.Variable)this._x=b;else{var e={value:b};d&&(e.name="x"+d),this._x=new a.Variable(e)}if(c instanceof a.Variable)this._y=c;else{var f={value:c};d&&(f.name="y"+d),this._y=new a.Variable(f)}},get x(){return this._x},set x(b){b instanceof a.Variable?this._x=b:this._x.value=b},get y(){return this._y},set y(b){b instanceof a.Variable?this._y=b:this._y.value=b},toString:function(){return"("+this.x+", "+this.y+")"}})}(this.c||module.parent.exports||{}),function(a){"use strict";var b=function(a,b){return"number"==typeof a?a:b};a.Expression=a.inherit({initialize:function(c,d,e){this.constant=b(e,0),this.terms=new a.HashTable,this.externalVariables=new a.HashSet,Object.defineProperty(this,"solver",{enumerable:!1,configurable:!0,writable:!0,value:null}),c instanceof a.AbstractVariable?(d=b(d,1),this.setVariable(c,d)):"number"==typeof c&&(isNaN(c)?console.trace():this.constant=c)},initializeFromHash:function(a,b){return this.constant=a,this.terms=b.clone(),this},multiplyMe:function(a){this.constant*=a;var b=this.terms;return b.each(function(c,d){b.set(c,d*a)}),this},clone:function(){var b=a.Expression.empty();return b.initializeFromHash(this.constant,this.terms),b.solver=this.solver,b},times:function(b){if("number"==typeof b)return this.clone().multiplyMe(b);if(this.isConstant)return b.times(this.constant);if(b.isConstant)return this.times(b.constant);throw new a.NonExpression},plus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,1):b instanceof a.Variable?this.clone().addVariable(b,1):void 0},minus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,-1):b instanceof a.Variable?this.clone().addVariable(b,-1):void 0},divide:function(b){if("number"==typeof b){if(a.approx(b,0))throw new a.NonExpression;return this.times(1/b)}if(b instanceof a.Expression){if(!b.isConstant)throw new a.NonExpression;return this.times(1/b.constant)}},addExpression:function(c,d,e){return c instanceof a.AbstractVariable&&(c=a.Expression.fromVariable(c)),d=b(d,1),this.constant+=d*c.constant,c.terms.each(function(a,b){this.addVariable(a,b*d,e),this._updateIfExternal(a)},this),this},addVariable:function(b,c,d){null==c&&(c=1);var e=this.terms.get(b);if(e){var f=e+c;0==f||a.approx(f,0)?(this.solver&&this.solver.noteRemovedVariable(b,d),this.terms.delete(b)):this.setVariable(b,f)}else a.approx(c,0)||(this.setVariable(b,c),this.solver&&this.solver.noteAddedVariable(b,d));return this},_updateIfExternal:function(a){a.isExternal&&(this.externalVariables.add(a),this.solver&&this.solver._noteUpdatedExternal(a))},setVariable:function(a,b){return this.terms.set(a,b),this._updateIfExternal(a),this},anyPivotableVariable:function(){if(this.isConstant)throw new a.InternalError("anyPivotableVariable called on a constant");var b=this.terms.escapingEach(function(a){return a.isPivotable?{retval:a}:void 0});return b&&void 0!==b.retval?b.retval:null},substituteOut:function(b,c,d){var e=this.solver;if(!e)throw new a.InternalError("Expressions::substituteOut called without a solver");var f=this.setVariable.bind(this),g=this.terms,h=g.get(b);g.delete(b),this.constant+=h*c.constant,c.terms.each(function(b,c){var i=g.get(b);if(i){var j=i+h*c;a.approx(j,0)?(e.noteRemovedVariable(b,d),g.delete(b)):f(b,j)}else f(b,h*c),e&&e.noteAddedVariable(b,d)})},changeSubject:function(a,b){this.setVariable(a,this.newSubject(b))},newSubject:function(a){var b=1/this.terms.get(a);return this.terms.delete(a),this.multiplyMe(-b),b},coefficientFor:function(a){return this.terms.get(a)||0},get isConstant(){return 0==this.terms.size},toString:function(){var b="",c=!1;if(!a.approx(this.constant,0)||this.isConstant){if(b+=this.constant,this.isConstant)return b;c=!0}return this.terms.each(function(a,d){c&&(b+=" + "),b+=d+"*"+a,c=!0}),b},equals:function(b){return b===this?!0:b instanceof a.Expression&&b.constant===this.constant&&b.terms.equals(this.terms)},Plus:function(a,b){return a.plus(b)},Minus:function(a,b){return a.minus(b)},Times:function(a,b){return a.times(b)},Divide:function(a,b){return a.divide(b)}}),a.Expression.empty=function(b){var c=new a.Expression(void 0,1,0);return c.solver=b,c},a.Expression.fromConstant=function(b,c){var d=new a.Expression(b);return d.solver=c,d},a.Expression.fromValue=function(b,c){b=+b;var d=new a.Expression(void 0,b,0);return d.solver=c,d},a.Expression.fromVariable=function(b,c){var d=new a.Expression(b,1,0);return d.solver=c,d}}(this.c||module.parent.exports||{}),function(a){"use strict";a.AbstractConstraint=a.inherit({initialize:function(b,c){this.hashCode=a._inc(),this.strength=b||a.Strength.required,this.weight=c||1},isEdit:!1,isInequality:!1,isStay:!1,get required(){return this.strength===a.Strength.required},toString:function(){return this.strength+" {"+this.weight+"} ("+this.expression+")"}});var b=a.AbstractConstraint.prototype.toString,c=function(b,c,d){a.AbstractConstraint.call(this,c||a.Strength.strong,d),this.variable=b,this.expression=new a.Expression(b,-1,b.value)};a.EditConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isEdit:!0,toString:function(){return"edit:"+b.call(this)}}),a.StayConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isStay:!0,toString:function(){return"stay:"+b.call(this)}});var d=a.Constraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(b,c,d){a.AbstractConstraint.call(this,c,d),this.expression=b}});a.Inequality=a.inherit({"extends":a.Constraint,_cloneOrNewCle:function(b){return b.clone?b.clone():new a.Expression(b)},initialize:function(b,c,e,f,g){var h=b instanceof a.Expression,i=e instanceof a.Expression,j=b instanceof a.AbstractVariable,k=e instanceof a.AbstractVariable,l="number"==typeof b,m="number"==typeof e;if((h||l)&&k){var n=b,o=c,p=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else if(j&&(i||m)){var n=e,o=c,p=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else{if(h&&m){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(l&&i){var s=e,o=c,t=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(h&&i){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(t),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(s));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(s),-1)}}else{if(h)return d.call(this,b,c,e);if(c==a.GEQ)d.call(this,new a.Expression(e),f,g),this.expression.multiplyMe(-1),this.expression.addVariable(b);else{if(c!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");d.call(this,new a.Expression(e),f,g),this.expression.addVariable(b,-1)}}}},isInequality:!0,toString:function(){return d.prototype.toString.call(this)+" >= 0) id: "+this.hashCode}}),a.Equation=a.inherit({"extends":a.Constraint,initialize:function(b,c,e,f){if(b instanceof a.Expression&&!c||c instanceof a.Strength)d.call(this,b,c,e);else if(b instanceof a.AbstractVariable&&c instanceof a.Expression){var g=b,h=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.AbstractVariable&&"number"==typeof c){var g=b,k=c,i=e,j=f;d.call(this,new a.Expression(k),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.Expression&&c instanceof a.AbstractVariable){var h=b,g=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else{if(!(b instanceof a.Expression||b instanceof a.AbstractVariable||"number"==typeof b)||!(c instanceof a.Expression||c instanceof a.AbstractVariable||"number"==typeof c))throw"Bad initializer to c.Equation";b=b instanceof a.Expression?b.clone():new a.Expression(b),c=c instanceof a.Expression?c.clone():new a.Expression(c),d.call(this,b,e,f),this.expression.addExpression(c,-1)}a.assert(this.strength instanceof a.Strength,"_strength not set")},toString:function(){return d.prototype.toString.call(this)+" = 0)"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.EditInfo=a.inherit({initialize:function(a,b,c,d,e){this.constraint=a,this.editPlus=b,this.editMinus=c,this.prevEditConstant=d,this.index=e},toString:function(){return"<cn="+this.constraint+", ep="+this.editPlus+", em="+this.editMinus+", pec="+this.prevEditConstant+", index="+this.index+">"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Tableau=a.inherit({initialize:function(){this.columns=new a.HashTable,this.rows=new a.HashTable,this._infeasibleRows=new a.HashSet,this._externalRows=new a.HashTable},noteRemovedVariable:function(a,b){var c=this.columns.get(a);b&&c&&c.delete(b)},noteAddedVariable:function(a,b){b&&this.insertColVar(a,b)},getInternalInfo:function(){return"Tableau Information:\nRows: "+this.rows.size+" (= "+(this.rows.size-1)+" constraints)"+"\nColumns: "+this.columns.size+"\nInfeasible Rows: "+this._infeasibleRows.size+"\nExternal basic variables: "+this._externalRows.size},toString:function(){var a="Tableau:\n";return this.rows.each(function(b,c){a+=b+" <==> "+c+"\n"}),a+="\nColumns:\n",a+=this.columns,a+="\nInfeasible rows: ",a+=this._infeasibleRows,a+="External basic variables: ",a+=this._externalRows},insertColVar:function(b,c){var d=this.columns.get(b);d||(d=new a.HashSet,this.columns.set(b,d)),d.add(c)},addRow:function(a,b){this.rows.set(a,b),b.terms.each(function(b){this.insertColVar(b,a)},this),a.isExternal&&this._externalRows.set(a,b)},removeColumn:function(a){var b=this.columns.get(a);b&&(this.columns.delete(a),b.each(function(b){var c=this.rows.get(b);c.terms.delete(a)},this)),a.isExternal&&this._externalRows.delete(a)},removeRow:function(b){var c=this.rows.get(b);return a.assert(null!=c),c.terms.each(function(a){var d=this.columns.get(a);null!=d&&d.delete(b)},this),this._infeasibleRows.delete(b),b.isExternal&&this._externalRows.delete(b),this.rows.delete(b),c},substituteOut:function(a,b){var c=this.columns.get(a);c.each(function(c){var d=this.rows.get(c);d.substituteOut(a,b,c,this),c.isExternal&&this._updatedExternals.add(c),c.isRestricted&&d.constant<0&&this._infeasibleRows.add(c)},this),a.isExternal&&this._externalRows.set(a,b),this.columns.delete(a)},columnsHasKey:function(a){return!!this.columns.get(a)}})}(this.c||module.parent.exports||{}),function(a){var b=a.Tableau,c=b.prototype,d=1e-8,e=a.Strength.weak,f={eplus:null,eminus:null,prevEConstant:null};a.SimplexSolver=a.inherit({"extends":a.Tableau,initialize:function(){a.Tableau.call(this),this._stayMinusErrorVars=[],this._stayPlusErrorVars=[],this._errorVars=new a.HashTable,this._markerVars=new a.HashTable,this._objective=new a.ObjectiveVariable({name:"Z"}),this._editVarMap=new a.HashTable,this._editVarList=[],this._slackCounter=0,this._artificialCounter=0,this._dummyCounter=0,this.autoSolve=!0,this._needsSolving=!1,this._optimizeCount=0,this.rows.set(this._objective,a.Expression.empty(this)),this._editVariableStack=[0],this._updatedExternals=new a.HashSet},_noteUpdatedExternal:function(a){this._updatedExternals.add(a)},add:function(){for(var a=0;a<arguments.length;a++)this.addConstraint(arguments[a]);return this},addEditVar:function(b,c,d){var e=new a.EditConstraint(b,c||a.Strength.strong,d);return this.addEditConstraint(e),this},addEditConstraint:function(a){var b=f;return this.addConstraint(a),this._addEditConstraint(a,b.eplus,b.eminus,b.prevEConstant),this},_addEditConstraint:function(b,c,d,e){var f=this._editVarMap.size,g=new a.EditInfo(b,c,d,e,f);this._editVarMap.set(b.variable,g),this._editVarList[f]={v:b.variable,info:g}},addConstraint:function(b){if(b instanceof a.Constraint){var c=this;b.expression.externalVariables.each(function(a){c._noteUpdatedExternal(a)})}var d=this.newExpression(b);return d.solver=this,this.tryAddingDirectly(d)||this.addWithArtificialVariable(d),this._needsSolving=!0,this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},addConstraintNoException:function(a){try{return this.addConstraint(a),!0}catch(b){return console.error(b),!1}},beginEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this._infeasibleRows.clear(),this._resetStayConstants(),this._editVariableStack[this._editVariableStack.length]=this._editVarMap.size,this},endEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this.resolve(),this._editVariableStack.pop(),this.removeEditVarsTo(this._editVariableStack[this._editVariableStack.length-1]),this},removeAllEditVars:function(){return this.removeEditVarsTo(0)},removeEditVarsTo:function(b){try{for(var c=this._editVarList.length,d=b;c>d;d++)this._editVarList[d]&&this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);return this._editVarList.length=b,a.assert(this._editVarMap.size==b,"_editVarMap.size == n"),this}catch(e){throw new a.InternalError("Constraint not found in removeEditVarsTo")}},addPointStays:function(a){return a.forEach(function(a,b){this.addStay(a.x,e,Math.pow(2,b)),this.addStay(a.y,e,Math.pow(2,b))},this),this},addStay:function(b,c,d){var f=new a.StayConstraint(b,c||e,d||1);return this.addConstraint(f)},setConstant:function(a,b){this._setConstant(a,b),this.resolve()},removeConstraint:function(b){this._needsSolving=!0,this._resetStayConstants();var c=this.rows.get(this._objective),d=this._errorVars.get(b);null!=d&&d.each(function(a){var d=this.rows.get(a);null==d?c.addVariable(a,-b.weight*b.strength.symbolicWeight.value,this._objective,this):c.addExpression(d,-b.weight*b.strength.symbolicWeight.value,this._objective,this)},this);var e=this._markerVars.get(b);if(this._markerVars.delete(b),null==e)throw new a.InternalError("Constraint not found in removeConstraintInternal");if(null==this.rows.get(e)){var f=this.columns.get(e),g=null,h=0;f.each(function(b){if(b.isRestricted){var c=this.rows.get(b),d=c.coefficientFor(e);if(0>d){var f=-c.constant/d;(null==g||h>f||a.approx(f,h)&&b.hashCode<g.hashCode)&&(h=f,g=b)}}},this),null==g&&f.each(function(a){if(a.isRestricted){var b=this.rows.get(a),c=b.coefficientFor(e),d=b.constant/c;(null==g||h>d)&&(h=d,g=a)}},this),null==g&&(0==f.size?this.removeColumn(e):f.escapingEach(function(a){return a!=this._objective?(g=a,{brk:!0}):void 0},this)),null!=g&&this.pivot(e,g)}if(null!=this.rows.get(e)&&this.removeRow(e),null!=d&&d.each(function(a){a!=e&&this.removeColumn(a)},this),b.isStay){if(null!=d)for(var j=0;j<this._stayPlusErrorVars.length;j++)d.delete(this._stayPlusErrorVars[j]),d.delete(this._stayMinusErrorVars[j])}else if(b.isEdit){var k=this._editVarMap.get(b.variable);this.removeColumn(k.editMinus),this._editVarMap.delete(b.variable)}return null!=d&&this._errorVars.delete(d),this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},reset:function(){throw new a.InternalError("reset not implemented")},resolveArray:function(a){var b=a.length;this._editVarMap.each(function(c,d){var e=d.index;b>e&&this.suggestValue(c,a[e])},this),this.resolve()},resolvePair:function(a,b){this.suggestValue(this._editVarList[0].v,a),this.suggestValue(this._editVarList[1].v,b),this.resolve()},resolve:function(){this.dualOptimize(),this._setExternalVariables(),this._infeasibleRows.clear(),this._resetStayConstants()},suggestValue:function(b,c){var d=this._editVarMap.get(b);if(!d)throw new a.Error("suggestValue for variable "+b+", but var is not an edit variable");var e=c-d.prevEditConstant;return d.prevEditConstant=c,this.deltaEditConstant(e,d.editPlus,d.editMinus),this},solve:function(){return this._needsSolving&&(this.optimize(this._objective),this._setExternalVariables()),this},setEditedValue:function(b,c){if(!this.columnsHasKey(b)&&null==this.rows.get(b))return b.value=c,this;if(!a.approx(c,b.value)){this.addEditVar(b),this.beginEdit();try{this.suggestValue(b,c)}catch(d){throw new a.InternalError("Error in setEditedValue")}this.endEdit()}return this},addVar:function(b){if(!this.columnsHasKey(b)&&null==this.rows.get(b))try{this.addStay(b)}catch(c){throw new a.InternalError("Error in addVar -- required failure is impossible")}return this},getInternalInfo:function(){var a=c.getInternalInfo.call(this);return a+="\nSolver info:\n",a+="Stay Error Variables: ",a+=this._stayPlusErrorVars.length+this._stayMinusErrorVars.length,a+=" ("+this._stayPlusErrorVars.length+" +, ",a+=this._stayMinusErrorVars.length+" -)\n",a+="Edit Variables: "+this._editVarMap.size,a+="\n"},getDebugInfo:function(){return this.toString()+this.getInternalInfo()+"\n"},toString:function(){var a=c.getInternalInfo.call(this);return a+="\n_stayPlusErrorVars: ",a+="["+this._stayPlusErrorVars+"]",a+="\n_stayMinusErrorVars: ",a+="["+this._stayMinusErrorVars+"]",a+="\n",a+="_editVarMap:\n"+this._editVarMap,a+="\n"},addWithArtificialVariable:function(b){var c=new a.SlackVariable({value:++this._artificialCounter,prefix:"a"}),d=new a.ObjectiveVariable({name:"az"}),e=b.clone();this.addRow(d,e),this.addRow(c,b),this.optimize(d);var f=this.rows.get(d);if(!a.approx(f.constant,0))throw this.removeRow(d),this.removeColumn(c),new a.RequiredFailure;var g=this.rows.get(c);if(null!=g){if(g.isConstant)return this.removeRow(c),this.removeRow(d),void 0;var h=g.anyPivotableVariable();this.pivot(h,c)}a.assert(null==this.rows.get(c),"rowExpression(av) == null"),this.removeColumn(c),this.removeRow(d)},tryAddingDirectly:function(a){var b=this.chooseSubject(a);return null==b?!1:(a.newSubject(b),this.columnsHasKey(b)&&this.substituteOut(b,a),this.addRow(b,a),!0)},chooseSubject:function(b){var c=null,d=!1,e=!1,f=b.terms,g=f.escapingEach(function(a,b){if(d){if(!a.isRestricted&&!this.columnsHasKey(a))return{retval:a}}else if(a.isRestricted){if(!e&&!a.isDummy&&0>b){var f=this.columns.get(a);(null==f||1==f.size&&this.columnsHasKey(this._objective))&&(c=a,e=!0)}}else c=a,d=!0},this);if(g&&void 0!==g.retval)return g.retval;if(null!=c)return c;var h=0,g=f.escapingEach(function(a,b){return a.isDummy?(this.columnsHasKey(a)||(c=a,h=b),void 0):{retval:null}},this);if(g&&void 0!==g.retval)return g.retval;if(!a.approx(b.constant,0))throw new a.RequiredFailure;return h>0&&b.multiplyMe(-1),c},deltaEditConstant:function(a,b,c){var d=this.rows.get(b);if(null!=d)return d.constant+=a,d.constant<0&&this._infeasibleRows.add(b),void 0;var e=this.rows.get(c);if(null!=e)return e.constant+=-a,e.constant<0&&this._infeasibleRows.add(c),void 0;var f=this.columns.get(c);f||console.log("columnVars is null -- tableau is:\n"+this),f.each(function(b){var d=this.rows.get(b),e=d.coefficientFor(c);d.constant+=e*a,b.isExternal&&this._noteUpdatedExternal(b),b.isRestricted&&d.constant<0&&this._infeasibleRows.add(b)},this)},dualOptimize:function(){for(var b=this.rows.get(this._objective);this._infeasibleRows.size;){var c=this._infeasibleRows.first();this._infeasibleRows.delete(c);var d=null,e=this.rows.get(c);if(e&&e.constant<0){var g,f=Number.MAX_VALUE,h=e.terms;if(h.each(function(c,e){if(e>0&&c.isPivotable){var h=b.coefficientFor(c);g=h/e,(f>g||a.approx(g,f)&&c.hashCode<d.hashCode)&&(d=c,f=g)}}),f==Number.MAX_VALUE)throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");this.pivot(d,c)}}},newExpression:function(b){var c=f;c.eplus=null,c.eminus=null,c.prevEConstant=null;var d=b.expression,e=a.Expression.fromConstant(d.constant,this),g=new a.SlackVariable,h=new a.DummyVariable,i=new a.SlackVariable,j=new a.SlackVariable,k=d.terms;if(k.each(function(a,b){var c=this.rows.get(a);c?e.addExpression(c,b):e.addVariable(a,b)},this),b.isInequality){if(++this._slackCounter,g=new a.SlackVariable({value:this._slackCounter,prefix:"s"}),e.setVariable(g,-1),this._markerVars.set(b,g),!b.required){++this._slackCounter,i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),e.setVariable(i,1);var l=this.rows.get(this._objective);l.setVariable(i,b.strength.symbolicWeight.value*b.weight),this.insertErrorVar(b,i),this.noteAddedVariable(i,this._objective)}}else if(b.required)++this._dummyCounter,h=new a.DummyVariable({value:this._dummyCounter,prefix:"d"}),c.eplus=h,c.eminus=h,c.prevEConstant=d.constant,e.setVariable(h,1),this._markerVars.set(b,h);else{++this._slackCounter,j=new a.SlackVariable({value:this._slackCounter,prefix:"ep"}),i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),e.setVariable(j,-1),e.setVariable(i,1),this._markerVars.set(b,j);
var l=this.rows.get(this._objective),m=b.strength.symbolicWeight.value*b.weight;l.setVariable(j,m),this.noteAddedVariable(j,this._objective),l.setVariable(i,m),this.noteAddedVariable(i,this._objective),this.insertErrorVar(b,i),this.insertErrorVar(b,j),b.isStay?(this._stayPlusErrorVars[this._stayPlusErrorVars.length]=j,this._stayMinusErrorVars[this._stayMinusErrorVars.length]=i):b.isEdit&&(c.eplus=j,c.eminus=i,c.prevEConstant=d.constant)}return e.constant<0&&e.multiplyMe(-1),e},optimize:function(b){this._optimizeCount++;var c=this.rows.get(b);a.assert(null!=c,"zRow != null");for(var g,h,e=null,f=null;;){if(g=0,h=c.terms,h.escapingEach(function(a,b){return a.isPivotable&&g>b?(g=b,e=a,{brk:1}):void 0},this),g>=-d)return;var i=Number.MAX_VALUE,j=this.columns.get(e),k=0;if(j.each(function(b){if(b.isPivotable){var c=this.rows.get(b),d=c.coefficientFor(e);0>d&&(k=-c.constant/d,(i>k||a.approx(k,i)&&b.hashCode<f.hashCode)&&(i=k,f=b))}},this),i==Number.MAX_VALUE)throw new a.InternalError("Objective function is unbounded in optimize");this.pivot(e,f)}},pivot:function(a,b){var c=!1;c&&console.time(" SimplexSolver::pivot"),null==a&&console.warn("pivot: entryVar == null"),null==b&&console.warn("pivot: exitVar == null"),c&&console.time("  removeRow");var d=this.removeRow(b);c&&console.timeEnd("  removeRow"),c&&console.time("  changeSubject"),d.changeSubject(b,a),c&&console.timeEnd("  changeSubject"),c&&console.time("  substituteOut"),this.substituteOut(a,d),c&&console.timeEnd("  substituteOut"),c&&console.time("  addRow"),this.addRow(a,d),c&&console.timeEnd("  addRow"),c&&console.timeEnd(" SimplexSolver::pivot")},_resetStayConstants:function(){for(var a=this._stayPlusErrorVars,b=a.length,c=0;b>c;c++){var d=this.rows.get(a[c]);null===d&&(d=this.rows.get(this._stayMinusErrorVars[c])),null!=d&&(d.constant=0)}},_setExternalVariables:function(){var a=[];this._updatedExternals.each(function(b){var c=b.value,d=this._externalRows.get(b);return d?(b.value=d.constant,c!==b.value&&a.push({type:"update",name:b.name,variable:b,oldValue:c}),void 0):(b.value=0,void 0)},this),this._updatedExternals.clear(),this._needsSolving=!1,this._informCallbacks(a),a.length&&this.onsolved(a)},onsolved:function(){},_informCallbacks:function(a){this._callbacks&&this._callbacks.forEach(function(b){b(a)})},_addCallback:function(a){var b=this._callbacks||(this._callbacks=[]);b[b.length]=a},insertErrorVar:function(b,c){var d=this._errorVars.get(b);d||(d=new a.HashSet,this._errorVars.set(b,d)),d.add(c)}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Timer=a.inherit({initialize:function(){this.isRunning=!1,this._elapsedMs=0},start:function(){return this.isRunning=!0,this._startReading=new Date,this},stop:function(){return this.isRunning=!1,this._elapsedMs+=new Date-this._startReading,this},reset:function(){return this.isRunning=!1,this._elapsedMs=0,this},elapsedTime:function(){return this.isRunning?(this._elapsedMs+(new Date-this._startReading))/1e3:this._elapsedMs/1e3}})}(this.c||module.parent.exports||{}),this.c.parser=function(){function a(a){return'"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,escape)+'"'}var b={parse:function(b,c){function k(a){g>e||(e>g&&(g=e,h=[]),h.push(a))}function l(){var a,b,c,d,f;if(d=e,f=e,a=A(),null!==a){for(b=[],c=m();null!==c;)b.push(c),c=m();null!==b?(c=A(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)}else a=null,e=f;return null!==a&&(a=function(a,b){return b}(d,a[1])),null===a&&(e=d),a}function m(){var a,b,c,d;return c=e,d=e,a=Q(),null!==a?(b=t(),null!==b?a=[a,b]:(a=null,e=d)):(a=null,e=d),null!==a&&(a=function(a,b){return b}(c,a[0])),null===a&&(e=c),a}function n(){var a;return b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),a}function o(){var a;return/^[a-zA-Z]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[a-zA-Z]")),null===a&&(36===b.charCodeAt(e)?(a="$",e++):(a=null,0===f&&k('"$"')),null===a&&(95===b.charCodeAt(e)?(a="_",e++):(a=null,0===f&&k('"_"')))),a}function p(){var a;return a=o(),null===a&&(/^[0-9]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[0-9]"))),a}function q(){var a;return f++,/^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\t\\x0B\\f \\xA0\\uFEFF]")),f--,0===f&&null===a&&k("whitespace"),a}function r(){var a;return/^[\n\r\u2028\u2029]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\n\\r\\u2028\\u2029]")),a}function s(){var a;return f++,10===b.charCodeAt(e)?(a="\n",e++):(a=null,0===f&&k('"\\n"')),null===a&&("\r\n"===b.substr(e,2)?(a="\r\n",e+=2):(a=null,0===f&&k('"\\r\\n"')),null===a&&(13===b.charCodeAt(e)?(a="\r",e++):(a=null,0===f&&k('"\\r"')),null===a&&(8232===b.charCodeAt(e)?(a="\u2028",e++):(a=null,0===f&&k('"\\u2028"')),null===a&&(8233===b.charCodeAt(e)?(a="\u2029",e++):(a=null,0===f&&k('"\\u2029"')))))),f--,0===f&&null===a&&k("end of line"),a}function t(){var a,c,d;return d=e,a=A(),null!==a?(59===b.charCodeAt(e)?(c=";",e++):(c=null,0===f&&k('";"')),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=z(),null!==a?(c=s(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=A(),null!==a?(c=u(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d))),a}function u(){var a,c;return c=e,f++,b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),f--,null===a?a="":(a=null,e=c),a}function v(){var a;return f++,a=w(),null===a&&(a=y()),f--,0===f&&null===a&&k("comment"),a}function w(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function x(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=r()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=r()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function y(){var a,c,d,g,h,i,j;if(h=e,"//"===b.substr(e,2)?(a="//",e+=2):(a=null,0===f&&k('"//"')),null!==a){for(c=[],i=e,j=e,f++,d=r(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,d=r(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?(d=r(),null===d&&(d=u()),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function z(){var a,b;for(a=[],b=q(),null===b&&(b=x(),null===b&&(b=y()));null!==b;)a.push(b),b=q(),null===b&&(b=x(),null===b&&(b=y()));return a}function A(){var a,b;for(a=[],b=q(),null===b&&(b=s(),null===b&&(b=v()));null!==b;)a.push(b),b=q(),null===b&&(b=s(),null===b&&(b=v()));return a}function B(){var a,b;return b=e,a=D(),null===a&&(a=C()),null!==a&&(a=function(a,b){return{type:"NumericLiteral",value:b}}(b,a)),null===a&&(e=b),a}function C(){var a,c,d;if(d=e,/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]")),null!==c)for(a=[];null!==c;)a.push(c),/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]"));else a=null;return null!==a&&(a=function(a,b){return parseInt(b.join(""))}(d,a)),null===a&&(e=d),a}function D(){var a,c,d,g,h;return g=e,h=e,a=C(),null!==a?(46===b.charCodeAt(e)?(c=".",e++):(c=null,0===f&&k('"."')),null!==c?(d=C(),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)):(a=null,e=h),null!==a&&(a=function(a,b){return parseFloat(b.join(""))}(g,a)),null===a&&(e=g),a}function E(){var a,c,d,g;if(g=e,/^[\-+]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\-+]")),a=null!==a?a:"",null!==a){if(/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]")),null!==d)for(c=[];null!==d;)c.push(d),/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]"));else c=null;null!==c?a=[a,c]:(a=null,e=g)}else a=null,e=g;return a}function F(){var a,b;return f++,b=e,a=G(),null!==a&&(a=function(a,b){return b}(b,a)),null===a&&(e=b),f--,0===f&&null===a&&k("identifier"),a}function G(){var a,b,c,d,g;if(f++,d=e,g=e,a=o(),null!==a){for(b=[],c=p();null!==c;)b.push(c),c=p();null!==b?a=[a,b]:(a=null,e=g)}else a=null,e=g;return null!==a&&(a=function(a,b,c){return b+c.join("")}(d,a[0],a[1])),null===a&&(e=d),f--,0===f&&null===a&&k("identifier"),a}function H(){var a,c,d,g,h,i,j;return i=e,a=F(),null!==a&&(a=function(a,b){return{type:"Variable",name:b}}(i,a)),null===a&&(e=i),null===a&&(a=B(),null===a&&(i=e,j=e,40===b.charCodeAt(e)?(a="(",e++):(a=null,0===f&&k('"("')),null!==a?(c=A(),null!==c?(d=Q(),null!==d?(g=A(),null!==g?(41===b.charCodeAt(e)?(h=")",e++):(h=null,0===f&&k('")"')),null!==h?a=[a,c,d,g,h]:(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j),null!==a&&(a=function(a,b){return b}(i,a[2])),null===a&&(e=i))),a}function I(){var a,b,c,d,f;return a=H(),null===a&&(d=e,f=e,a=J(),null!==a?(b=A(),null!==b?(c=I(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)):(a=null,e=f),null!==a&&(a=function(a,b,c){return{type:"UnaryExpression",operator:b,expression:c}}(d,a[0],a[2])),null===a&&(e=d)),a}function J(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"')),null===a&&(33===b.charCodeAt(e)?(a="!",e++):(a=null,0===f&&k('"!"')))),a}function K(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=I(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=L(),null!==d?(f=A(),null!==f?(g=I(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=L(),null!==d?(f=A(),null!==f?(g=I(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"MultiplicativeExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function L(){var a;return 42===b.charCodeAt(e)?(a="*",e++):(a=null,0===f&&k('"*"')),null===a&&(47===b.charCodeAt(e)?(a="/",e++):(a=null,0===f&&k('"/"'))),a}function M(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=K(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=N(),null!==d?(f=A(),null!==f?(g=K(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=N(),null!==d?(f=A(),null!==f?(g=K(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"AdditiveExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function N(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"'))),a}function O(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=M(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=P(),null!==d?(f=A(),null!==f?(g=M(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=P(),null!==d?(f=A(),null!==f?(g=M(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"Inequality",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function P(){var a;return"<="===b.substr(e,2)?(a="<=",e+=2):(a=null,0===f&&k('"<="')),null===a&&(">="===b.substr(e,2)?(a=">=",e+=2):(a=null,0===f&&k('">="')),null===a&&(60===b.charCodeAt(e)?(a="<",e++):(a=null,0===f&&k('"<"')),null===a&&(62===b.charCodeAt(e)?(a=">",e++):(a=null,0===f&&k('">"'))))),a}function Q(){var a,c,d,g,h,i,j,l,m;if(j=e,l=e,a=O(),null!==a){for(c=[],m=e,d=A(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=A(),null!==h?(i=O(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==d;)c.push(d),m=e,d=A(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=A(),null!==h?(i=O(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==c?a=[a,c]:(a=null,e=l)}else a=null,e=l;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"Equality",operator:c[e][1],left:d,right:c[e][3]};return d}(j,a[0],a[1])),null===a&&(e=j),a}function R(a){a.sort();for(var b=null,c=[],d=0;d<a.length;d++)a[d]!==b&&(c.push(a[d]),b=a[d]);return c}function S(){for(var a=1,c=1,d=!1,f=0;f<Math.max(e,g);f++){var h=b.charAt(f);"\n"===h?(d||a++,c=1,d=!1):"\r"===h||"\u2028"===h||"\u2029"===h?(a++,c=1,d=!0):(c++,d=!1)}return{line:a,column:c}}var d={start:l,Statement:m,SourceCharacter:n,IdentifierStart:o,IdentifierPart:p,WhiteSpace:q,LineTerminator:r,LineTerminatorSequence:s,EOS:t,EOF:u,Comment:v,MultiLineComment:w,MultiLineCommentNoLineTerminator:x,SingleLineComment:y,_:z,__:A,Literal:B,Integer:C,Real:D,SignedInteger:E,Identifier:F,IdentifierName:G,PrimaryExpression:H,UnaryExpression:I,UnaryOperator:J,MultiplicativeExpression:K,MultiplicativeOperator:L,AdditiveExpression:M,AdditiveOperator:N,InequalityExpression:O,InequalityOperator:P,LinearExpression:Q};if(void 0!==c){if(void 0===d[c])throw new Error("Invalid rule name: "+a(c)+".")}else c="start";var e=0,f=0,g=0,h=[],T=d[c]();if(null===T||e!==b.length){var U=Math.max(e,g),V=U<b.length?b.charAt(U):null,W=S();throw new this.SyntaxError(R(h),V,U,W.line,W.column)}return T},toSource:function(){return this._source}};return b.SyntaxError=function(b,c,d,e,f){function g(b,c){var d,e;switch(b.length){case 0:d="end of input";break;case 1:d=b[0];break;default:d=b.slice(0,b.length-1).join(", ")+" or "+b[b.length-1]}return e=c?a(c):"end of input","Expected "+d+" but "+e+" found."}this.name="SyntaxError",this.expected=b,this.found=c,this.message=g(b,c),this.offset=d,this.line=e,this.column=f},b.SyntaxError.prototype=Error.prototype,b}(),function(a){"use strict";var b=new a.SimplexSolver,c={},d={},e=a.Strength.weak;a.Strength.medium,a.Strength.strong,a.Strength.required;var i=function(f){if(d[f])return d[f];switch(f.type){case"Inequality":var g="<="==f.operator?a.LEQ:a.GEQ,h=new a.Inequality(i(f.left),g,i(f.right),e);return b.addConstraint(h),h;case"Equality":var h=new a.Equation(i(f.left),i(f.right),e);return b.addConstraint(h),h;case"MultiplicativeExpression":var h=a.times(i(f.left),i(f.right));return b.addConstraint(h),h;case"AdditiveExpression":return"+"==f.operator?a.plus(i(f.left),i(f.right)):a.minus(i(f.left),i(f.right));case"NumericLiteral":return new a.Expression(f.value);case"Variable":return c[f.name]||(c[f.name]=new a.Variable({name:f.name})),c[f.name];case"UnaryExpression":console.log("UnaryExpression...WTF?")}},j=function(a){return a.map(i)};a._api=function(){var c=Array.prototype.slice.call(arguments);if(1==c.length){if("string"==typeof c[0]){var d=a.parser.parse(c[0]);return j(d)}"function"==typeof c[0]&&b._addCallback(c[0])}}}(this.c||module.parent.exports||{});
}).call(
  (typeof module != "undefined") ?
      (module.compiled = true && module) : this
);
};
BundleModuleCode['plugins/csp/constrained']=function (module,exports){
/* https://github.com/Wizcorp/constrained */
var _modules={};
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
})({
    1: [function(require, module, exports) {
        /**
         * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
         * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
         *
         * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
         *
         * This is a compiled version of Cassowary/JS. For source versions or to
         * contribute, see the github project:
         *
         *  https://github.com/slightlyoff/cassowary-js-refactor
         *
         */

        (function() {
            ! function(a) {
                "use strict";
                var b = "undefined" != typeof a.HTMLElement,
                    c = function(a) {
                        for (var b = null; a && a != Object.prototype;) {
                            if (a.tagName) {
                                b = a.tagName;
                                break
                            }
                            a = a.prototype
                        }
                        return b || "div"
                    },
                    d = 1e-8,
                    e = {},
                    f = function(a, b) {
                        if (a && b) {
                            if ("function" == typeof a[b]) return a[b];
                            var c = a.prototype;
                            if (c && "function" == typeof c[b]) return c[b];
                            if (c !== Object.prototype && c !== Function.prototype) return "function" == typeof a.__super__ ? f(a.__super__, b) : void 0
                        }
                    },
                    g = !1;
                try {
                    var h = new Map;
                    h.set("foo", "bar");
                    var i = h.values();
                    i.next(), h.forEach(function() {});
                    var k = new Map(h);
                    if (k.get("foo") != h.get("foo")) throw "ctor fail";
                    g = !0
                } catch (l) {}
                var m = a.c = function() {
                    return m._api ? m._api.apply(this, arguments) : void 0
                };
                m._functionalMap = g, m.GEQ = 1, m.LEQ = 2;
                var n = b ? function(b, d, e) {
                    if (d && d.prototype instanceof a.HTMLElement) {
                        var g = b,
                            h = c(e),
                            i = function(a) {
                                return a.__proto__ = e, g.apply(a, arguments), e.created && a.created(), e.decorate && a.decorate(), a
                            };
                        m.extend(e, {
                            upgrade: i
                        }), b = function() {
                            return i(a.document.createElement(h))
                        }, b.prototype = e, m.extend(b, {
                            ctor: g
                        })
                    }
                    return b
                } : function(a) {
                    return a
                };
                m.inherit = function(a) {
                    var b = null,
                        c = null;
                    a["extends"] && (c = a["extends"], delete a["extends"]), a.initialize && (b = a.initialize, delete a.initialize);
                    var d = b || function() {};
                    Object.defineProperty(d, "__super__", {
                        value: c ? c : Object,
                        enumerable: !1,
                        configurable: !0,
                        writable: !1
                    }), a._t && (e[a._t] = d);
                    var f = d.prototype = Object.create(c ? c.prototype : Object.prototype);
                    return m.extend(f, a), n(d, c, f, a)
                }, m.own = function(b, c, d) {
                    return Object.getOwnPropertyNames(b).forEach(c, d || a), b
                }, m.extend = function(a, b) {
                    return m.own(b, function(c) {
                        var d = Object.getOwnPropertyDescriptor(b, c);
                        if ("function" == typeof d.get || "function" == typeof d.set) Object.defineProperty(a, c, d);
                        else if ("function" == typeof d.value || "_" === c.charAt(0)) d.writable = !0, d.configurable = !0, d.enumerable = !1, Object.defineProperty(a, c, d);
                        else try {
                            a[c] = b[c]
                        } catch (e) {}
                    }), a
                }, m.assert = function(a, b) {
                    if (!a) throw new m.InternalError("Assertion failed: " + b)
                };
                var o = function(a) {
                    return "number" == typeof a ? m.Expression.fromConstant(a) : a instanceof m.Variable ? m.Expression.fromVariable(a) : a
                };
                m.plus = function(a, b) {
                    return a = o(a), b = o(b), a.plus(b)
                }, m.minus = function(a, b) {
                    return a = o(a), b = o(b), a.minus(b)
                }, m.times = function(a, b) {
                    return a = o(a), b = o(b), a.times(b)
                }, m.divide = function(a, b) {
                    return a = o(a), b = o(b), a.divide(b)
                }, m.approx = function(a, b) {
                    return a = +a, b = +b, a === b ? !0 : 0 == a ? Math.abs(b) < d : 0 == b ? Math.abs(a) < d : Math.abs(a - b) < Math.abs(a) * d
                };
                var p = 1;
                m._inc = function() {
                    return p++
                }, m.parseJSON = function(a) {
                    return JSON.parse(a, function(a, b) {
                        if ("object" != typeof b || "string" != typeof b._t) return b;
                        var c = b._t,
                            d = e[c];
                        if (c && d) {
                            var g = f(d, "fromJSON");
                            if (g) return g(b, d)
                        }
                        return b
                    })
                }, "function" == typeof define && define.amd ? define(m) : "object" == typeof module && module.exports ? module.exports = m : a.c = m
            }(this),
            function(a) {
                "use strict";
                if (a._functionalMap) a.HashTable = a.inherit({
                    initialize: function(b) {
                        this.hashCode = a._inc(), this._store = b instanceof a.HashTable ? new Map(b._store) : new Map
                    },
                    clone: function() {
                        return new a.HashTable(this)
                    },
                    get: function(a) {
                        var b = this._store.get(a.hashCode);
                        return void 0 === b ? null : b[1]
                    },
                    clear: function() {
                        this._store.clear()
                    },
                    get size() {
                        return this._store.size
                    },
                    set: function(a, b) {
                        return this._store.set(a.hashCode, [a, b])
                    },
                    has: function(a) {
                        return this._store.has(a.hashCode)
                    },
                    "delete": function(a) {
                        return this._store.delete(a.hashCode)
                    },
                    each: function(a, b) {
                        this._store.forEach(function(c) {
                            return a.call(b || null, c[0], c[1])
                        }, b)
                    },
                    escapingEach: function(a, b) {
                        if (this._store.size)
                            for (var c, e, f = this._store.values(), e = f.next(); !e.done;) {
                                if (c = a.call(b || null, e.value[0], e.value[1])) {
                                    if (void 0 !== c.retval) return c;
                                    if (c.brk) break
                                }
                                e = f.next()
                            }
                    },
                    equals: function(b) {
                        if (b === this) return !0;
                        if (!(b instanceof a.HashTable) || b._size !== this._size) return !1;
                        for (var c in this._store.keys())
                            if (void 0 == b._store.get(c)) return !1;
                        return !0
                    }
                });
                else {
                    var b = {},
                        c = function(a, b) {
                            Object.keys(a).forEach(function(c) {
                                b[c] = a[c]
                            })
                        };
                    a.HashTable = a.inherit({
                        initialize: function() {
                            this.size = 0, this._store = {}, this._deleted = 0
                        },
                        set: function(a, b) {
                            var c = a.hashCode;
                            "undefined" == typeof this._store[c] && this.size++, this._store[c] = [a, b]
                        },
                        get: function(a) {
                            if (!this.size) return null;
                            a = a.hashCode;
                            var b = this._store[a];
                            return "undefined" != typeof b ? b[1] : null
                        },
                        clear: function() {
                            this.size = 0, this._store = {}
                        },
                        _compact: function() {
                            var a = {};
                            c(this._store, a), this._store = a
                        },
                        _compactThreshold: 100,
                        _perhapsCompact: function() {
                            this._size > 30 || this._deleted > this._compactThreshold && (this._compact(), this._deleted = 0)
                        },
                        "delete": function(a) {
                            a = a.hashCode, this._store.hasOwnProperty(a) && (this._deleted++, delete this._store[a], this.size > 0 && this.size--)
                        },
                        each: function(a, b) {
                            if (this.size) {
                                this._perhapsCompact();
                                var c = this._store;
                                for (var d in this._store) this._store.hasOwnProperty(d) && a.call(b || null, c[d][0], c[d][1])
                            }
                        },
                        escapingEach: function(a, c) {
                            if (this.size) {
                                this._perhapsCompact();
                                for (var d = this, e = this._store, f = b, g = Object.keys(e), h = 0; h < g.length; h++)
                                    if (function(b) {
                                            d._store.hasOwnProperty(b) && (f = a.call(c || null, e[b][0], e[b][1]))
                                        }(g[h]), f) {
                                        if (void 0 !== f.retval) return f;
                                        if (f.brk) break
                                    }
                            }
                        },
                        clone: function() {
                            var b = new a.HashTable;
                            return this.size && (b.size = this.size, c(this._store, b._store)), b
                        },
                        equals: function(b) {
                            if (b === this) return !0;
                            if (!(b instanceof a.HashTable) || b._size !== this._size) return !1;
                            for (var c = Object.keys(this._store), d = 0; d < c.length; d++) {
                                var e = c[d];
                                if (this._store[e][0] !== b._store[e][0]) return !1
                            }
                            return !0
                        },
                        toString: function() {
                            var b = "";
                            return this.each(function(a, c) {
                                b += a + " => " + c + "\n"
                            }), b
                        },
                        toJSON: function() {
                            return {
                                _t: "c.HashTable"
                            }
                        },
                        fromJSON: function() {
                            var c = new a.HashTable;
                            return c
                        }
                    })
                }
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.HashSet = a._functionalMap ? a.inherit({
                    _t: "c.HashSet",
                    initialize: function(b) {
                        this.hashCode = a._inc(), this._store = b instanceof a.HashSet ? new Map(b._store) : new Map
                    },
                    add: function(a) {
                        return this._store.set(a.hashCode, a)
                    },
                    has: function(a) {
                        return this._store.has(a.hashCode)
                    },
                    get size() {
                        return this._store.size
                    },
                    clear: function() {
                        this._store.clear()
                    },
                    values: function() {
                        for (var a = [], b = this._store.values(), c = b.next(); !c.done;) a.push(c.value), c = b.next();
                        return a
                    },
                    first: function() {
                        var a = this._store.values(),
                            b = a.next();
                        return b.done ? null : b.value
                    },
                    "delete": function(a) {
                        this._store.delete(a.hashCode)
                    },
                    each: function(a, b) {
                        var c = this;
                        this._store.forEach(function(d) {
                            return a.call(b || null, d, d, c)
                        }, b)
                    },
                    escapingEach: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    toString: function() {
                        var a = this.size + " {",
                            b = !0;
                        return this.each(function(c) {
                            b ? b = !1 : a += ", ", a += c
                        }), a += "}\n"
                    },
                    toJSON: function() {
                        var a = [];
                        return this.each(function(b) {
                            a[a.length] = b.toJSON()
                        }), {
                            _t: "c.HashSet",
                            data: a
                        }
                    },
                    fromJSON: function(b) {
                        var c = new a.HashSet;
                        return b.data && (c.size = b.data.length, c._store = b.data), c
                    }
                }) : a.inherit({
                    _t: "c.HashSet",
                    initialize: function() {
                        this._store = [], this.size = 0, this.hashCode = a._inc()
                    },
                    add: function(a) {
                        var b = this._store;
                        b.indexOf(a), -1 == b.indexOf(a) && (b[b.length] = a), this.size = b.length
                    },
                    values: function() {
                        return this._store
                    },
                    first: function() {
                        return this._store[0]
                    },
                    has: function(a) {
                        return -1 != this._store.indexOf(a)
                    },
                    "delete": function(a) {
                        var b = this._store.indexOf(a);
                        return -1 == b ? null : (this._store.splice(b, 1)[0], this.size = this._store.length, void 0)
                    },
                    clear: function() {
                        this._store.length = 0
                    },
                    each: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    escapingEach: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    toString: function() {
                        var a = this.size + " {",
                            b = !0;
                        return this.each(function(c) {
                            b ? b = !1 : a += ", ", a += c
                        }), a += "}\n"
                    },
                    toJSON: function() {
                        var a = [];
                        return this.each(function(b) {
                            a[a.length] = b.toJSON()
                        }), {
                            _t: "c.HashSet",
                            data: a
                        }
                    },
                    fromJSON: function(b) {
                        var c = new a.HashSet;
                        return b.data && (c.size = b.data.length, c._store = b.data), c
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Error = a.inherit({
                    initialize: function(a) {
                        a && (this._description = a)
                    },
                    _name: "c.Error",
                    _description: "An error has occured in Cassowary",
                    set description(a) {
                        this._description = a
                    },
                    get description() {
                        return "(" + this._name + ") " + this._description
                    },
                    get message() {
                        return this.description
                    },
                    toString: function() {
                        return this.description
                    }
                });
                var b = function(b, c) {
                    return a.inherit({
                        "extends": a.Error,
                        initialize: function() {
                            a.Error.apply(this, arguments)
                        },
                        _name: b || "",
                        _description: c || ""
                    })
                };
                a.ConstraintNotFound = b("c.ConstraintNotFound", "Tried to remove a constraint never added to the tableu"), a.InternalError = b("c.InternalError"), a.NonExpression = b("c.NonExpression", "The resulting expression would be non"), a.NotEnoughStays = b("c.NotEnoughStays", "There are not enough stays to give specific values to every variable"), a.RequiredFailure = b("c.RequiredFailure", "A required constraint cannot be satisfied"), a.TooDifficult = b("c.TooDifficult", "The constraints are too difficult to solve")
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                var b = 1e3;
                a.SymbolicWeight = a.inherit({
                    _t: "c.SymbolicWeight",
                    initialize: function() {
                        this.value = 0;
                        for (var a = 1, c = arguments.length - 1; c >= 0; --c) this.value += arguments[c] * a, a *= b
                    },
                    toJSON: function() {
                        return {
                            _t: this._t,
                            value: this.value
                        }
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                a.Strength = a.inherit({
                    initialize: function(b, c, d, e) {
                        this.name = b, this.symbolicWeight = c instanceof a.SymbolicWeight ? c : new a.SymbolicWeight(c, d, e)
                    },
                    get required() {
                        return this === a.Strength.required
                    },
                    toString: function() {
                        return this.name + (this.required ? "" : ":" + this.symbolicWeight)
                    }
                }), a.Strength.required = new a.Strength("<Required>", 1e3, 1e3, 1e3), a.Strength.strong = new a.Strength("strong", 1, 0, 0), a.Strength.medium = new a.Strength("medium", 0, 1, 0), a.Strength.weak = new a.Strength("weak", 0, 0, 1)
            }(this.c || ("undefined" != typeof module ? module.parent.exports.c : {})),
            function(a) {
                "use strict";
                a.AbstractVariable = a.inherit({
                    isDummy: !1,
                    isExternal: !1,
                    isPivotable: !1,
                    isRestricted: !1,
                    _init: function(b, c) {
                        this.hashCode = a._inc(), this.name = (c || "") + this.hashCode, b && ("undefined" != typeof b.name && (this.name = b.name), "undefined" != typeof b.value && (this.value = b.value), "undefined" != typeof b.prefix && (this._prefix = b.prefix))
                    },
                    _prefix: "",
                    name: "",
                    value: 0,
                    valueOf: function() {
                        return this.value
                    },
                    toJSON: function() {
                        var a = {};
                        return this._t && (a._t = this._t), this.name && (a.name = this.name), "undefined" != typeof this.value && (a.value = this.value), this._prefix && (a._prefix = this._prefix), this._t && (a._t = this._t), a
                    },
                    fromJSON: function(b, c) {
                        var d = new c;
                        return a.extend(d, b), d
                    },
                    toString: function() {
                        return this._prefix + "[" + this.name + ":" + this.value + "]"
                    }
                }), a.Variable = a.inherit({
                    _t: "c.Variable",
                    "extends": a.AbstractVariable,
                    initialize: function(b) {
                        this._init(b, "v");
                        var c = a.Variable._map;
                        c && (c[this.name] = this)
                    },
                    isExternal: !0
                }), a.DummyVariable = a.inherit({
                    _t: "c.DummyVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "d")
                    },
                    isDummy: !0,
                    isRestricted: !0,
                    value: "dummy"
                }), a.ObjectiveVariable = a.inherit({
                    _t: "c.ObjectiveVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "o")
                    },
                    value: "obj"
                }), a.SlackVariable = a.inherit({
                    _t: "c.SlackVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "s")
                    },
                    isPivotable: !0,
                    isRestricted: !0,
                    value: "slack"
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Point = a.inherit({
                    initialize: function(b, c, d) {
                        if (b instanceof a.Variable) this._x = b;
                        else {
                            var e = {
                                value: b
                            };
                            d && (e.name = "x" + d), this._x = new a.Variable(e)
                        }
                        if (c instanceof a.Variable) this._y = c;
                        else {
                            var f = {
                                value: c
                            };
                            d && (f.name = "y" + d), this._y = new a.Variable(f)
                        }
                    },
                    get x() {
                        return this._x
                    },
                    set x(b) {
                        b instanceof a.Variable ? this._x = b : this._x.value = b
                    },
                    get y() {
                        return this._y
                    },
                    set y(b) {
                        b instanceof a.Variable ? this._y = b : this._y.value = b
                    },
                    toString: function() {
                        return "(" + this.x + ", " + this.y + ")"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                var b = function(a, b) {
                    return "number" == typeof a ? a : b
                };
                a.Expression = a.inherit({
                    initialize: function(c, d, e) {
                        this.constant = b(e, 0), this.terms = new a.HashTable, this.externalVariables = new a.HashSet, Object.defineProperty(this, "solver", {
                            enumerable: !1,
                            configurable: !0,
                            writable: !0,
                            value: null
                        }), c instanceof a.AbstractVariable ? (d = b(d, 1), this.setVariable(c, d)) : "number" == typeof c && (isNaN(c) ? console.trace() : this.constant = c)
                    },
                    initializeFromHash: function(a, b) {
                        return this.constant = a, this.terms = b.clone(), this
                    },
                    multiplyMe: function(a) {
                        this.constant *= a;
                        var b = this.terms;
                        return b.each(function(c, d) {
                            b.set(c, d * a)
                        }), this
                    },
                    clone: function() {
                        var b = a.Expression.empty();
                        return b.initializeFromHash(this.constant, this.terms), b.solver = this.solver, b
                    },
                    times: function(b) {
                        if ("number" == typeof b) return this.clone().multiplyMe(b);
                        if (this.isConstant) return b.times(this.constant);
                        if (b.isConstant) return this.times(b.constant);
                        throw new a.NonExpression
                    },
                    plus: function(b) {
                        return b instanceof a.Expression ? this.clone().addExpression(b, 1) : b instanceof a.Variable ? this.clone().addVariable(b, 1) : void 0
                    },
                    minus: function(b) {
                        return b instanceof a.Expression ? this.clone().addExpression(b, -1) : b instanceof a.Variable ? this.clone().addVariable(b, -1) : void 0
                    },
                    divide: function(b) {
                        if ("number" == typeof b) {
                            if (a.approx(b, 0)) throw new a.NonExpression;
                            return this.times(1 / b)
                        }
                        if (b instanceof a.Expression) {
                            if (!b.isConstant) throw new a.NonExpression;
                            return this.times(1 / b.constant)
                        }
                    },
                    addExpression: function(c, d, e) {
                        return c instanceof a.AbstractVariable && (c = a.Expression.fromVariable(c)), d = b(d, 1), this.constant += d * c.constant, c.terms.each(function(a, b) {
                            this.addVariable(a, b * d, e), this._updateIfExternal(a)
                        }, this), this
                    },
                    addVariable: function(b, c, d) {
                        null == c && (c = 1);
                        var e = this.terms.get(b);
                        if (e) {
                            var f = e + c;
                            0 == f || a.approx(f, 0) ? (this.solver && this.solver.noteRemovedVariable(b, d), this.terms.delete(b)) : this.setVariable(b, f)
                        } else a.approx(c, 0) || (this.setVariable(b, c), this.solver && this.solver.noteAddedVariable(b, d));
                        return this
                    },
                    _updateIfExternal: function(a) {
                        a.isExternal && (this.externalVariables.add(a), this.solver && this.solver._noteUpdatedExternal(a))
                    },
                    setVariable: function(a, b) {
                        return this.terms.set(a, b), this._updateIfExternal(a), this
                    },
                    anyPivotableVariable: function() {
                        if (this.isConstant) throw new a.InternalError("anyPivotableVariable called on a constant");
                        var b = this.terms.escapingEach(function(a) {
                            return a.isPivotable ? {
                                retval: a
                            } : void 0
                        });
                        return b && void 0 !== b.retval ? b.retval : null
                    },
                    substituteOut: function(b, c, d) {
                        var e = this.solver;
                        if (!e) throw new a.InternalError("Expressions::substituteOut called without a solver");
                        var f = this.setVariable.bind(this),
                            g = this.terms,
                            h = g.get(b);
                        g.delete(b), this.constant += h * c.constant, c.terms.each(function(b, c) {
                            var i = g.get(b);
                            if (i) {
                                var j = i + h * c;
                                a.approx(j, 0) ? (e.noteRemovedVariable(b, d), g.delete(b)) : f(b, j)
                            } else f(b, h * c), e && e.noteAddedVariable(b, d)
                        })
                    },
                    changeSubject: function(a, b) {
                        this.setVariable(a, this.newSubject(b))
                    },
                    newSubject: function(a) {
                        var b = 1 / this.terms.get(a);
                        return this.terms.delete(a), this.multiplyMe(-b), b
                    },
                    coefficientFor: function(a) {
                        return this.terms.get(a) || 0
                    },
                    get isConstant() {
                        return 0 == this.terms.size
                    },
                    toString: function() {
                        var b = "",
                            c = !1;
                        if (!a.approx(this.constant, 0) || this.isConstant) {
                            if (b += this.constant, this.isConstant) return b;
                            c = !0
                        }
                        return this.terms.each(function(a, d) {
                            c && (b += " + "), b += d + "*" + a, c = !0
                        }), b
                    },
                    equals: function(b) {
                        return b === this ? !0 : b instanceof a.Expression && b.constant === this.constant && b.terms.equals(this.terms)
                    },
                    Plus: function(a, b) {
                        return a.plus(b)
                    },
                    Minus: function(a, b) {
                        return a.minus(b)
                    },
                    Times: function(a, b) {
                        return a.times(b)
                    },
                    Divide: function(a, b) {
                        return a.divide(b)
                    }
                }), a.Expression.empty = function(b) {
                    var c = new a.Expression(void 0, 1, 0);
                    return c.solver = b, c
                }, a.Expression.fromConstant = function(b, c) {
                    var d = new a.Expression(b);
                    return d.solver = c, d
                }, a.Expression.fromValue = function(b, c) {
                    b = +b;
                    var d = new a.Expression(void 0, b, 0);
                    return d.solver = c, d
                }, a.Expression.fromVariable = function(b, c) {
                    var d = new a.Expression(b, 1, 0);
                    return d.solver = c, d
                }
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.AbstractConstraint = a.inherit({
                    initialize: function(b, c) {
                        this.hashCode = a._inc(), this.strength = b || a.Strength.required, this.weight = c || 1
                    },
                    isEdit: !1,
                    isInequality: !1,
                    isStay: !1,
                    get required() {
                        return this.strength === a.Strength.required
                    },
                    toString: function() {
                        return this.strength + " {" + this.weight + "} (" + this.expression + ")"
                    }
                });
                var b = a.AbstractConstraint.prototype.toString,
                    c = function(b, c, d) {
                        a.AbstractConstraint.call(this, c || a.Strength.strong, d), this.variable = b, this.expression = new a.Expression(b, -1, b.value)
                    };
                a.EditConstraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function() {
                        c.apply(this, arguments)
                    },
                    isEdit: !0,
                    toString: function() {
                        return "edit:" + b.call(this)
                    }
                }), a.StayConstraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function() {
                        c.apply(this, arguments)
                    },
                    isStay: !0,
                    toString: function() {
                        return "stay:" + b.call(this)
                    }
                });
                var d = a.Constraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function(b, c, d) {
                        a.AbstractConstraint.call(this, c, d), this.expression = b
                    }
                });
                a.Inequality = a.inherit({
                    "extends": a.Constraint,
                    _cloneOrNewCle: function(b) {
                        return b.clone ? b.clone() : new a.Expression(b)
                    },
                    initialize: function(b, c, e, f, g) {
                        var h = b instanceof a.Expression,
                            i = e instanceof a.Expression,
                            j = b instanceof a.AbstractVariable,
                            k = e instanceof a.AbstractVariable,
                            l = "number" == typeof b,
                            m = "number" == typeof e;
                        if ((h || l) && k) {
                            var n = b,
                                o = c,
                                p = e,
                                q = f,
                                r = g;
                            if (d.call(this, this._cloneOrNewCle(n), q, r), o == a.LEQ) this.expression.multiplyMe(-1), this.expression.addVariable(p);
                            else {
                                if (o != a.GEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                this.expression.addVariable(p, -1)
                            }
                        } else if (j && (i || m)) {
                            var n = e,
                                o = c,
                                p = b,
                                q = f,
                                r = g;
                            if (d.call(this, this._cloneOrNewCle(n), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addVariable(p);
                            else {
                                if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                this.expression.addVariable(p, -1)
                            }
                        } else {
                            if (h && m) {
                                var s = b,
                                    o = c,
                                    t = e,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(s), q, r), o == a.LEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(t));
                                else {
                                    if (o != a.GEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(t), -1)
                                }
                                return this
                            }
                            if (l && i) {
                                var s = e,
                                    o = c,
                                    t = b,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(s), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(t));
                                else {
                                    if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(t), -1)
                                }
                                return this
                            }
                            if (h && i) {
                                var s = b,
                                    o = c,
                                    t = e,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(t), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(s));
                                else {
                                    if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(s), -1)
                                }
                            } else {
                                if (h) return d.call(this, b, c, e);
                                if (c == a.GEQ) d.call(this, new a.Expression(e), f, g), this.expression.multiplyMe(-1), this.expression.addVariable(b);
                                else {
                                    if (c != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    d.call(this, new a.Expression(e), f, g), this.expression.addVariable(b, -1)
                                }
                            }
                        }
                    },
                    isInequality: !0,
                    toString: function() {
                        return d.prototype.toString.call(this) + " >= 0) id: " + this.hashCode
                    }
                }), a.Equation = a.inherit({
                    "extends": a.Constraint,
                    initialize: function(b, c, e, f) {
                        if (b instanceof a.Expression && !c || c instanceof a.Strength) d.call(this, b, c, e);
                        else if (b instanceof a.AbstractVariable && c instanceof a.Expression) {
                            var g = b,
                                h = c,
                                i = e,
                                j = f;
                            d.call(this, h.clone(), i, j), this.expression.addVariable(g, -1)
                        } else if (b instanceof a.AbstractVariable && "number" == typeof c) {
                            var g = b,
                                k = c,
                                i = e,
                                j = f;
                            d.call(this, new a.Expression(k), i, j), this.expression.addVariable(g, -1)
                        } else if (b instanceof a.Expression && c instanceof a.AbstractVariable) {
                            var h = b,
                                g = c,
                                i = e,
                                j = f;
                            d.call(this, h.clone(), i, j), this.expression.addVariable(g, -1)
                        } else {
                            if (!(b instanceof a.Expression || b instanceof a.AbstractVariable || "number" == typeof b) || !(c instanceof a.Expression || c instanceof a.AbstractVariable || "number" == typeof c)) throw "Bad initializer to c.Equation";
                            b = b instanceof a.Expression ? b.clone() : new a.Expression(b), c = c instanceof a.Expression ? c.clone() : new a.Expression(c), d.call(this, b, e, f), this.expression.addExpression(c, -1)
                        }
                        a.assert(this.strength instanceof a.Strength, "_strength not set")
                    },
                    toString: function() {
                        return d.prototype.toString.call(this) + " = 0)"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.EditInfo = a.inherit({
                    initialize: function(a, b, c, d, e) {
                        this.constraint = a, this.editPlus = b, this.editMinus = c, this.prevEditConstant = d, this.index = e
                    },
                    toString: function() {
                        return "<cn=" + this.constraint + ", ep=" + this.editPlus + ", em=" + this.editMinus + ", pec=" + this.prevEditConstant + ", index=" + this.index + ">"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Tableau = a.inherit({
                    initialize: function() {
                        this.columns = new a.HashTable, this.rows = new a.HashTable, this._infeasibleRows = new a.HashSet, this._externalRows = new a.HashTable
                    },
                    noteRemovedVariable: function(a, b) {
                        var c = this.columns.get(a);
                        b && c && c.delete(b)
                    },
                    noteAddedVariable: function(a, b) {
                        b && this.insertColVar(a, b)
                    },
                    getInternalInfo: function() {
                        return "Tableau Information:\nRows: " + this.rows.size + " (= " + (this.rows.size - 1) + " constraints)" + "\nColumns: " + this.columns.size + "\nInfeasible Rows: " + this._infeasibleRows.size + "\nExternal basic variables: " + this._externalRows.size
                    },
                    toString: function() {
                        var a = "Tableau:\n";
                        return this.rows.each(function(b, c) {
                            a += b + " <==> " + c + "\n"
                        }), a += "\nColumns:\n", this.columns.each(function(b, c) {
                            a += b + " <==> " + c
                        }), a += "\nInfeasible rows: ", a += this._infeasibleRows, a += "External basic variables: ", a += this._externalRows
                    },
                    insertColVar: function(b, c) {
                        var d = this.columns.get(b);
                        d || (d = new a.HashSet, this.columns.set(b, d)), d.add(c)
                    },
                    addRow: function(a, b) {
                        this.rows.set(a, b), b.terms.each(function(b) {
                            this.insertColVar(b, a)
                        }, this), a.isExternal && this._externalRows.set(a, b)
                    },
                    removeColumn: function(a) {
                        var b = this.columns.get(a);
                        b && (this.columns.delete(a), b.each(function(b) {
                            var c = this.rows.get(b);
                            c.terms.delete(a)
                        }, this)), a.isExternal && this._externalRows.delete(a)
                    },
                    removeRow: function(b) {
                        var c = this.rows.get(b);
                        return a.assert(null != c), c.terms.each(function(a) {
                            var d = this.columns.get(a);
                            null != d && d.delete(b)
                        }, this), this._infeasibleRows.delete(b), b.isExternal && this._externalRows.delete(b), this.rows.delete(b), c
                    },
                    substituteOut: function(a, b) {
                        var c = this.columns.get(a);
                        c.each(function(c) {
                            var d = this.rows.get(c);
                            d.substituteOut(a, b, c, this), c.isExternal && this._updatedExternals.add(c), c.isRestricted && d.constant < 0 && this._infeasibleRows.add(c)
                        }, this), a.isExternal && this._externalRows.set(a, b), this.columns.delete(a)
                    },
                    columnsHasKey: function(a) {
                        return !!this.columns.get(a)
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                var b = a.Tableau,
                    c = b.prototype,
                    d = 1e-8,
                    e = a.Strength.weak,
                    f = {
                        eplus: null,
                        eminus: null,
                        prevEConstant: null
                    };
                a.SimplexSolver = a.inherit({
                    "extends": a.Tableau,
                    initialize: function() {
                        a.Tableau.call(this), this._stayMinusErrorVars = [], this._stayPlusErrorVars = [], this._errorVars = new a.HashTable, this._markerVars = new a.HashTable, this._objective = new a.ObjectiveVariable({
                            name: "Z"
                        }), this._editVarMap = new a.HashTable, this._editVarList = [], this._slackCounter = 0, this._artificialCounter = 0, this._dummyCounter = 0, this.autoSolve = !0, this._needsSolving = !1, this._optimizeCount = 0, this.rows.set(this._objective, a.Expression.empty(this)), this._editVariableStack = [0], this._updatedExternals = new a.HashSet
                    },
                    _noteUpdatedExternal: function(a) {
                        this._updatedExternals.add(a)
                    },
                    add: function() {
                        for (var a = 0; a < arguments.length; a++) this.addConstraint(arguments[a]);
                        return this
                    },
                    addEditVar: function(b, c, d) {
                        var e = new a.EditConstraint(b, c || a.Strength.strong, d);
                        return this.addEditConstraint(e), this
                    },
                    addEditConstraint: function(a) {
                        var b = f;
                        return this.addConstraint(a), this._addEditConstraint(a, b.eplus, b.eminus, b.prevEConstant), this
                    },
                    _addEditConstraint: function(b, c, d, e) {
                        var f = this._editVarMap.size,
                            g = new a.EditInfo(b, c, d, e, f);
                        this._editVarMap.set(b.variable, g), this._editVarList[f] = {
                            v: b.variable,
                            info: g
                        }
                    },
                    addConstraint: function(b) {
                        if (b instanceof a.Constraint) {
                            var c = this;
                            b.expression.externalVariables.each(function(a) {
                                c._noteUpdatedExternal(a)
                            })
                        }
                        var d = this.newExpression(b);
                        return d.solver = this, this.tryAddingDirectly(d) || this.addWithArtificialVariable(d), this._needsSolving = !0, this.autoSolve && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    addConstraintNoException: function(a) {
                        try {
                            return this.addConstraint(a), !0
                        } catch (b) {
                            return console.error(b), !1
                        }
                    },
                    beginEdit: function() {
                        return a.assert(this._editVarMap.size > 0, "_editVarMap.size > 0"), this._infeasibleRows.clear(), this._resetStayConstants(), this._editVariableStack[this._editVariableStack.length] = this._editVarMap.size, this
                    },
                    endEdit: function() {
                        return a.assert(this._editVarMap.size > 0, "_editVarMap.size > 0"), this.resolve(), this._editVariableStack.pop(), this.removeEditVarsTo(this._editVariableStack[this._editVariableStack.length - 1]), this
                    },
                    removeAllEditVars: function() {
                        return this.removeEditVarsTo(0)
                    },
                    removeEditVarsTo: function(b) {
                        try {
                            for (var c = this._editVarList.length, d = b; c > d; d++) this._editVarList[d] && this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);
                            return this._editVarList.length = b, a.assert(this._editVarMap.size == b, "_editVarMap.size == n"), this
                        } catch (e) {
                            throw new a.InternalError("Constraint not found in removeEditVarsTo")
                        }
                    },
                    addPointStays: function(a) {
                        return a.forEach(function(a, b) {
                            this.addStay(a.x, e, Math.pow(2, b)), this.addStay(a.y, e, Math.pow(2, b))
                        }, this), this
                    },
                    addStay: function(b, c, d) {
                        var f = new a.StayConstraint(b, c || e, d || 1);
                        return this.addConstraint(f)
                    },
                    setConstant: function(a, b) {
                        this._setConstant(a, b), this.resolve()
                    },
                    removeConstraint: function(b) {
                        this._needsSolving = !0, this._resetStayConstants();
                        var c = this.rows.get(this._objective),
                            d = this._errorVars.get(b);
                        null != d && d.each(function(a) {
                            var d = this.rows.get(a);
                            null == d ? c.addVariable(a, -b.weight * b.strength.symbolicWeight.value, this._objective, this) : c.addExpression(d, -b.weight * b.strength.symbolicWeight.value, this._objective, this)
                        }, this);
                        var e = this._markerVars.get(b);
                        if (this._markerVars.delete(b), null == e) throw new a.InternalError("Constraint not found in removeConstraintInternal");
                        if (null == this.rows.get(e)) {
                            var f = this.columns.get(e),
                                g = null,
                                h = 0;
                            f.each(function(b) {
                                if (b.isRestricted) {
                                    var c = this.rows.get(b),
                                        d = c.coefficientFor(e);
                                    if (0 > d) {
                                        var f = -c.constant / d;
                                        (null == g || h > f || a.approx(f, h) && b.hashCode < g.hashCode) && (h = f, g = b)
                                    }
                                }
                            }, this), null == g && f.each(function(a) {
                                if (a.isRestricted) {
                                    var b = this.rows.get(a),
                                        c = b.coefficientFor(e),
                                        d = b.constant / c;
                                    (null == g || h > d) && (h = d, g = a)
                                }
                            }, this), null == g && (0 == f.size ? this.removeColumn(e) : f.escapingEach(function(a) {
                                return a != this._objective ? (g = a, {
                                    brk: !0
                                }) : void 0
                            }, this)), null != g && this.pivot(e, g)
                        }
                        if (null != this.rows.get(e) && this.removeRow(e), null != d && d.each(function(a) {
                                a != e && this.removeColumn(a)
                            }, this), b.isStay) {
                            if (null != d)
                                for (var j = 0; j < this._stayPlusErrorVars.length; j++) d.delete(this._stayPlusErrorVars[j]), d.delete(this._stayMinusErrorVars[j])
                        } else if (b.isEdit) {
                            var k = this._editVarMap.get(b.variable);
                            this.removeColumn(k.editMinus), this._editVarMap.delete(b.variable)
                        }
                        return null != d && this._errorVars.delete(d), this.autoSolve && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    reset: function() {
                        throw new a.InternalError("reset not implemented")
                    },
                    resolveArray: function(a) {
                        var b = a.length;
                        this._editVarMap.each(function(c, d) {
                            var e = d.index;
                            b > e && this.suggestValue(c, a[e])
                        }, this), this.resolve()
                    },
                    resolvePair: function(a, b) {
                        this.suggestValue(this._editVarList[0].v, a), this.suggestValue(this._editVarList[1].v, b), this.resolve()
                    },
                    resolve: function() {
                        this.dualOptimize(), this._setExternalVariables(), this._infeasibleRows.clear(), this._resetStayConstants()
                    },
                    suggestValue: function(b, c) {
                        var d = this._editVarMap.get(b);
                        if (!d) throw new a.Error("suggestValue for variable " + b + ", but var is not an edit variable");
                        var e = c - d.prevEditConstant;
                        return d.prevEditConstant = c, this.deltaEditConstant(e, d.editPlus, d.editMinus), this
                    },
                    solve: function() {
                        return this._needsSolving && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    setEditedValue: function(b, c) {
                        if (!this.columnsHasKey(b) && null == this.rows.get(b)) return b.value = c, this;
                        if (!a.approx(c, b.value)) {
                            this.addEditVar(b), this.beginEdit();
                            try {
                                this.suggestValue(b, c)
                            } catch (d) {
                                throw new a.InternalError("Error in setEditedValue")
                            }
                            this.endEdit()
                        }
                        return this
                    },
                    addVar: function(b) {
                        if (!this.columnsHasKey(b) && null == this.rows.get(b)) try {
                            this.addStay(b)
                        } catch (c) {
                            throw new a.InternalError("Error in addVar -- required failure is impossible")
                        }
                        return this
                    },
                    getInternalInfo: function() {
                        var a = c.getInternalInfo.call(this);
                        return a += "\nSolver info:\n", a += "Stay Error Variables: ", a += this._stayPlusErrorVars.length + this._stayMinusErrorVars.length, a += " (" + this._stayPlusErrorVars.length + " +, ", a += this._stayMinusErrorVars.length + " -)\n", a += "Edit Variables: " + this._editVarMap.size, a += "\n"
                    },
                    getDebugInfo: function() {
                        return this.toString() + this.getInternalInfo() + "\n"
                    },
                    toString: function() {
                        var a = c.getInternalInfo.call(this);
                        return a += "\n_stayPlusErrorVars: ", a += "[" + this._stayPlusErrorVars + "]", a += "\n_stayMinusErrorVars: ", a += "[" + this._stayMinusErrorVars + "]", a += "\n", a += "_editVarMap:\n" + this._editVarMap, a += "\n"
                    },
                    addWithArtificialVariable: function(b) {
                        var c = new a.SlackVariable({
                                value: ++this._artificialCounter,
                                prefix: "a"
                            }),
                            d = new a.ObjectiveVariable({
                                name: "az"
                            }),
                            e = b.clone();
                        this.addRow(d, e), this.addRow(c, b), this.optimize(d);
                        var f = this.rows.get(d);
                        if (!a.approx(f.constant, 0)) throw this.removeRow(d), this.removeColumn(c), new a.RequiredFailure;
                        var g = this.rows.get(c);
                        if (null != g) {
                            if (g.isConstant) return this.removeRow(c), this.removeRow(d), void 0;
                            var h = g.anyPivotableVariable();
                            this.pivot(h, c)
                        }
                        a.assert(null == this.rows.get(c), "rowExpression(av) == null"), this.removeColumn(c), this.removeRow(d)
                    },
                    tryAddingDirectly: function(a) {
                        var b = this.chooseSubject(a);
                        return null == b ? !1 : (a.newSubject(b), this.columnsHasKey(b) && this.substituteOut(b, a), this.addRow(b, a), !0)
                    },
                    chooseSubject: function(b) {
                        var c = null,
                            d = !1,
                            e = !1,
                            f = b.terms,
                            g = f.escapingEach(function(a, b) {
                                if (d) {
                                    if (!a.isRestricted && !this.columnsHasKey(a)) return {
                                        retval: a
                                    }
                                } else if (a.isRestricted) {
                                    if (!e && !a.isDummy && 0 > b) {
                                        var f = this.columns.get(a);
                                        (null == f || 1 == f.size && this.columnsHasKey(this._objective)) && (c = a, e = !0)
                                    }
                                } else c = a, d = !0
                            }, this);
                        if (g && void 0 !== g.retval) return g.retval;
                        if (null != c) return c;
                        var h = 0,
                            g = f.escapingEach(function(a, b) {
                                return a.isDummy ? (this.columnsHasKey(a) || (c = a, h = b), void 0) : {
                                    retval: null
                                }
                            }, this);
                        if (g && void 0 !== g.retval) return g.retval;
                        if (!a.approx(b.constant, 0)) throw new a.RequiredFailure;
                        return h > 0 && b.multiplyMe(-1), c
                    },
                    deltaEditConstant: function(a, b, c) {
                        var d = this.rows.get(b);
                        if (null != d) return d.constant += a, d.constant < 0 && this._infeasibleRows.add(b), void 0;
                        var e = this.rows.get(c);
                        if (null != e) return e.constant += -a, e.constant < 0 && this._infeasibleRows.add(c), void 0;
                        var f = this.columns.get(c);
                        f || console.log("columnVars is null -- tableau is:\n" + this), f.each(function(b) {
                            var d = this.rows.get(b),
                                e = d.coefficientFor(c);
                            d.constant += e * a, b.isExternal && this._noteUpdatedExternal(b), b.isRestricted && d.constant < 0 && this._infeasibleRows.add(b)
                        }, this)
                    },
                    dualOptimize: function() {
                        for (var b = this.rows.get(this._objective); this._infeasibleRows.size;) {
                            var c = this._infeasibleRows.first();
                            this._infeasibleRows.delete(c);
                            var d = null,
                                e = this.rows.get(c);
                            if (e && e.constant < 0) {
                                var g, f = Number.MAX_VALUE,
                                    h = e.terms;
                                if (h.each(function(c, e) {
                                        if (e > 0 && c.isPivotable) {
                                            var h = b.coefficientFor(c);
                                            g = h / e, (f > g || a.approx(g, f) && c.hashCode < d.hashCode) && (d = c, f = g)
                                        }
                                    }), f == Number.MAX_VALUE) throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");
                                this.pivot(d, c)
                            }
                        }
                    },
                    newExpression: function(b) {
                        var c = f;
                        c.eplus = null, c.eminus = null, c.prevEConstant = null;
                        var d = b.expression,
                            e = a.Expression.fromConstant(d.constant, this),
                            g = new a.SlackVariable,
                            h = new a.DummyVariable,
                            i = new a.SlackVariable,
                            j = new a.SlackVariable,
                            k = d.terms;
                        if (k.each(function(a, b) {
                                var c = this.rows.get(a);
                                c ? e.addExpression(c, b) : e.addVariable(a, b)
                            }, this), b.isInequality) {
                            if (++this._slackCounter, g = new a.SlackVariable({
                                    value: this._slackCounter,
                                    prefix: "s"
                                }), e.setVariable(g, -1), this._markerVars.set(b, g), !b.required) {
                                ++this._slackCounter, i = new a.SlackVariable({
                                    value: this._slackCounter,
                                    prefix: "em"
                                }), e.setVariable(i, 1);
                                var l = this.rows.get(this._objective);
                                l.setVariable(i, b.strength.symbolicWeight.value * b.weight), this.insertErrorVar(b, i), this.noteAddedVariable(i, this._objective)
                            }
                        } else if (b.required) ++this._dummyCounter, h = new a.DummyVariable({
                            value: this._dummyCounter,
                            prefix: "d"
                        }), c.eplus = h, c.eminus = h, c.prevEConstant = d.constant, e.setVariable(h, 1), this._markerVars.set(b, h);
                        else {
                            ++this._slackCounter, j = new a.SlackVariable({
                                value: this._slackCounter,
                                prefix: "ep"
                            }), i = new a.SlackVariable({
                                value: this._slackCounter,
                                prefix: "em"
                            }), e.setVariable(j, -1), e.setVariable(i, 1), this._markerVars.set(b, j);
                            var l = this.rows.get(this._objective),
                                m = b.strength.symbolicWeight.value * b.weight;
                            l.setVariable(j, m), this.noteAddedVariable(j, this._objective), l.setVariable(i, m), this.noteAddedVariable(i, this._objective), this.insertErrorVar(b, i), this.insertErrorVar(b, j), b.isStay ? (this._stayPlusErrorVars[this._stayPlusErrorVars.length] = j, this._stayMinusErrorVars[this._stayMinusErrorVars.length] = i) : b.isEdit && (c.eplus = j, c.eminus = i, c.prevEConstant = d.constant)
                        }
                        return e.constant < 0 && e.multiplyMe(-1), e
                    },
                    optimize: function(b) {
                        this._optimizeCount++;
                        var c = this.rows.get(b);
                        a.assert(null != c, "zRow != null");
                        for (var g, h, e = null, f = null;;) {
                            if (g = 0, h = c.terms, h.escapingEach(function(a, b) {
                                    return a.isPivotable && g > b ? (g = b, e = a, {
                                        brk: 1
                                    }) : void 0
                                }, this), g >= -d) return;
                            var i = Number.MAX_VALUE,
                                j = this.columns.get(e),
                                k = 0;
                            if (j.each(function(b) {
                                    if (b.isPivotable) {
                                        var c = this.rows.get(b),
                                            d = c.coefficientFor(e);
                                        0 > d && (k = -c.constant / d, (i > k || a.approx(k, i) && b.hashCode < f.hashCode) && (i = k, f = b))
                                    }
                                }, this), i == Number.MAX_VALUE) throw new a.InternalError("Objective function is unbounded in optimize");
                            this.pivot(e, f)
                        }
                    },
                    pivot: function(a, b) {
                        var c = !1;
                        c && console.time(" SimplexSolver::pivot"), null == a && console.warn("pivot: entryVar == null"), null == b && console.warn("pivot: exitVar == null"), c && console.time("  removeRow");
                        var d = this.removeRow(b);
                        c && console.timeEnd("  removeRow"), c && console.time("  changeSubject"), d.changeSubject(b, a), c && console.timeEnd("  changeSubject"), c && console.time("  substituteOut"), this.substituteOut(a, d), c && console.timeEnd("  substituteOut"), c && console.time("  addRow"), this.addRow(a, d), c && console.timeEnd("  addRow"), c && console.timeEnd(" SimplexSolver::pivot")
                    },
                    _resetStayConstants: function() {
                        for (var a = this._stayPlusErrorVars, b = a.length, c = 0; b > c; c++) {
                            var d = this.rows.get(a[c]);
                            null === d && (d = this.rows.get(this._stayMinusErrorVars[c])), null != d && (d.constant = 0)
                        }
                    },
                    _setExternalVariables: function() {
                        var a = [];
                        this._updatedExternals.each(function(b) {
                            var c = b.value,
                                d = this._externalRows.get(b);
                            return d ? (b.value = d.constant, c !== b.value && a.push({
                                type: "update",
                                name: b.name,
                                variable: b,
                                oldValue: c
                            }), void 0) : (b.value = 0, void 0)
                        }, this), this._updatedExternals.clear(), this._needsSolving = !1, this._informCallbacks(a), a.length && this.onsolved(a)
                    },
                    onsolved: function() {},
                    _informCallbacks: function(a) {
                        this._callbacks && this._callbacks.forEach(function(b) {
                            b(a)
                        })
                    },
                    _addCallback: function(a) {
                        var b = this._callbacks || (this._callbacks = []);
                        b[b.length] = a
                    },
                    insertErrorVar: function(b, c) {
                        var d = this._errorVars.get(b);
                        d || (d = new a.HashSet, this._errorVars.set(b, d)), d.add(c)
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Timer = a.inherit({
                    initialize: function() {
                        this.isRunning = !1, this._elapsedMs = 0
                    },
                    start: function() {
                        return this.isRunning = !0, this._startReading = new Date, this
                    },
                    stop: function() {
                        return this.isRunning = !1, this._elapsedMs += new Date - this._startReading, this
                    },
                    reset: function() {
                        return this.isRunning = !1, this._elapsedMs = 0, this
                    },
                    elapsedTime: function() {
                        return this.isRunning ? (this._elapsedMs + (new Date - this._startReading)) / 1e3 : this._elapsedMs / 1e3
                    }
                })
            }(this.c || module.parent.exports || {}), this.c.parser = function() {
                    function a(a) {
                        return '"' + a.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"'
                    }
                    var b = {
                        parse: function(b, c) {
                            function k(a) {
                                g > e || (e > g && (g = e, h = []), h.push(a))
                            }

                            function l() {
                                var a, b, c, d, f;
                                if (d = e, f = e, a = A(), null !== a) {
                                    for (b = [], c = m(); null !== c;) b.push(c), c = m();
                                    null !== b ? (c = A(), null !== c ? a = [a, b, c] : (a = null, e = f)) : (a = null, e = f)
                                } else a = null, e = f;
                                return null !== a && (a = function(a, b) {
                                    return b
                                }(d, a[1])), null === a && (e = d), a
                            }

                            function m() {
                                var a, b, c, d;
                                return c = e, d = e, a = Q(), null !== a ? (b = t(), null !== b ? a = [a, b] : (a = null, e = d)) : (a = null, e = d), null !== a && (a = function(a, b) {
                                    return b
                                }(c, a[0])), null === a && (e = c), a
                            }

                            function n() {
                                var a;
                                return b.length > e ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("any character")), a
                            }

                            function o() {
                                var a;
                                return /^[a-zA-Z]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[a-zA-Z]")), null === a && (36 === b.charCodeAt(e) ? (a = "$", e++) : (a = null, 0 === f && k('"$"')), null === a && (95 === b.charCodeAt(e) ? (a = "_", e++) : (a = null, 0 === f && k('"_"')))), a
                            }

                            function p() {
                                var a;
                                return a = o(), null === a && (/^[0-9]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[0-9]"))), a
                            }

                            function q() {
                                var a;
                                return f++, /^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\t\\x0B\\f \\xA0\\uFEFF]")), f--, 0 === f && null === a && k("whitespace"), a
                            }

                            function r() {
                                var a;
                                return /^[\n\r\u2028\u2029]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\n\\r\\u2028\\u2029]")), a
                            }

                            function s() {
                                var a;
                                return f++, 10 === b.charCodeAt(e) ? (a = "\n", e++) : (a = null, 0 === f && k('"\\n"')), null === a && ("\r\n" === b.substr(e, 2) ? (a = "\r\n", e += 2) : (a = null, 0 === f && k('"\\r\\n"')), null === a && (13 === b.charCodeAt(e) ? (a = "\r", e++) : (a = null, 0 === f && k('"\\r"')), null === a && (8232 === b.charCodeAt(e) ? (a = "\u2028", e++) : (a = null, 0 === f && k('"\\u2028"')), null === a && (8233 === b.charCodeAt(e) ? (a = "\u2029", e++) : (a = null, 0 === f && k('"\\u2029"')))))), f--, 0 === f && null === a && k("end of line"), a
                            }

                            function t() {
                                var a, c, d;
                                return d = e, a = A(), null !== a ? (59 === b.charCodeAt(e) ? (c = ";", e++) : (c = null, 0 === f && k('";"')), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d), null === a && (d = e, a = z(), null !== a ? (c = s(), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d), null === a && (d = e, a = A(), null !== a ? (c = u(), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d))), a
                            }

                            function u() {
                                var a, c;
                                return c = e, f++, b.length > e ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("any character")), f--, null === a ? a = "" : (a = null, e = c), a
                            }

                            function v() {
                                var a;
                                return f++, a = w(), null === a && (a = y()), f--, 0 === f && null === a && k("comment"), a
                            }

                            function w() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "/*" === b.substr(e, 2) ? (a = "/*", e += 2) : (a = null, 0 === f && k('"/*"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? ("*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function x() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "/*" === b.substr(e, 2) ? (a = "/*", e += 2) : (a = null, 0 === f && k('"/*"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null === d && (d = r()), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null === d && (d = r()), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? ("*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function y() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "//" === b.substr(e, 2) ? (a = "//", e += 2) : (a = null, 0 === f && k('"//"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, d = r(), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, d = r(), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? (d = r(), null === d && (d = u()), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function z() {
                                var a, b;
                                for (a = [], b = q(), null === b && (b = x(), null === b && (b = y())); null !== b;) a.push(b), b = q(), null === b && (b = x(), null === b && (b = y()));
                                return a
                            }

                            function A() {
                                var a, b;
                                for (a = [], b = q(), null === b && (b = s(), null === b && (b = v())); null !== b;) a.push(b), b = q(), null === b && (b = s(), null === b && (b = v()));
                                return a
                            }

                            function B() {
                                var a, b;
                                return b = e, a = D(), null === a && (a = C()), null !== a && (a = function(a, b) {
                                    return {
                                        type: "NumericLiteral",
                                        value: b
                                    }
                                }(b, a)), null === a && (e = b), a
                            }

                            function C() {
                                var a, c, d;
                                if (d = e, /^[0-9]/.test(b.charAt(e)) ? (c = b.charAt(e), e++) : (c = null, 0 === f && k("[0-9]")), null !== c)
                                    for (a = []; null !== c;) a.push(c), /^[0-9]/.test(b.charAt(e)) ? (c = b.charAt(e), e++) : (c = null, 0 === f && k("[0-9]"));
                                else a = null;
                                return null !== a && (a = function(a, b) {
                                    return parseInt(b.join(""))
                                }(d, a)), null === a && (e = d), a
                            }

                            function D() {
                                var a, c, d, g, h;
                                return g = e, h = e, a = C(), null !== a ? (46 === b.charCodeAt(e) ? (c = ".", e++) : (c = null, 0 === f && k('"."')), null !== c ? (d = C(), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)) : (a = null, e = h), null !== a && (a = function(a, b) {
                                    return parseFloat(b.join(""))
                                }(g, a)), null === a && (e = g), a
                            }

                            function E() {
                                var a, c, d, g;
                                if (g = e, /^[\-+]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\-+]")), a = null !== a ? a : "", null !== a) {
                                    if (/^[0-9]/.test(b.charAt(e)) ? (d = b.charAt(e), e++) : (d = null, 0 === f && k("[0-9]")), null !== d)
                                        for (c = []; null !== d;) c.push(d), /^[0-9]/.test(b.charAt(e)) ? (d = b.charAt(e), e++) : (d = null, 0 === f && k("[0-9]"));
                                    else c = null;
                                    null !== c ? a = [a, c] : (a = null, e = g)
                                } else a = null, e = g;
                                return a
                            }

                            function F() {
                                var a, b;
                                return f++, b = e, a = G(), null !== a && (a = function(a, b) {
                                    return b
                                }(b, a)), null === a && (e = b), f--, 0 === f && null === a && k("identifier"), a
                            }

                            function G() {
                                var a, b, c, d, g;
                                if (f++, d = e, g = e, a = o(), null !== a) {
                                    for (b = [], c = p(); null !== c;) b.push(c), c = p();
                                    null !== b ? a = [a, b] : (a = null, e = g)
                                } else a = null, e = g;
                                return null !== a && (a = function(a, b, c) {
                                    return b + c.join("")
                                }(d, a[0], a[1])), null === a && (e = d), f--, 0 === f && null === a && k("identifier"), a
                            }

                            function H() {
                                var a, c, d, g, h, i, j;
                                return i = e, a = F(), null !== a && (a = function(a, b) {
                                    return {
                                        type: "Variable",
                                        name: b
                                    }
                                }(i, a)), null === a && (e = i), null === a && (a = B(), null === a && (i = e, j = e, 40 === b.charCodeAt(e) ? (a = "(", e++) : (a = null, 0 === f && k('"("')), null !== a ? (c = A(), null !== c ? (d = Q(), null !== d ? (g = A(), null !== g ? (41 === b.charCodeAt(e) ? (h = ")", e++) : (h = null, 0 === f && k('")"')), null !== h ? a = [a, c, d, g, h] : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j), null !== a && (a = function(a, b) {
                                    return b
                                }(i, a[2])), null === a && (e = i))), a
                            }

                            function I() {
                                var a, b, c, d, f;
                                return a = H(), null === a && (d = e, f = e, a = J(), null !== a ? (b = A(), null !== b ? (c = I(), null !== c ? a = [a, b, c] : (a = null, e = f)) : (a = null, e = f)) : (a = null, e = f), null !== a && (a = function(a, b, c) {
                                    return {
                                        type: "UnaryExpression",
                                        operator: b,
                                        expression: c
                                    }
                                }(d, a[0], a[2])), null === a && (e = d)), a
                            }

                            function J() {
                                var a;
                                return 43 === b.charCodeAt(e) ? (a = "+", e++) : (a = null, 0 === f && k('"+"')), null === a && (45 === b.charCodeAt(e) ? (a = "-", e++) : (a = null, 0 === f && k('"-"')), null === a && (33 === b.charCodeAt(e) ? (a = "!", e++) : (a = null, 0 === f && k('"!"')))), a
                            }

                            function K() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = I(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = L(), null !== d ? (f = A(), null !== f ? (g = I(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = L(), null !== d ? (f = A(), null !== f ? (g = I(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "MultiplicativeExpression",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function L() {
                                var a;
                                return 42 === b.charCodeAt(e) ? (a = "*", e++) : (a = null, 0 === f && k('"*"')), null === a && (47 === b.charCodeAt(e) ? (a = "/", e++) : (a = null, 0 === f && k('"/"'))), a
                            }

                            function M() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = K(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = N(), null !== d ? (f = A(), null !== f ? (g = K(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = N(), null !== d ? (f = A(), null !== f ? (g = K(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "AdditiveExpression",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function N() {
                                var a;
                                return 43 === b.charCodeAt(e) ? (a = "+", e++) : (a = null, 0 === f && k('"+"')), null === a && (45 === b.charCodeAt(e) ? (a = "-", e++) : (a = null, 0 === f && k('"-"'))), a
                            }

                            function O() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = M(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = P(), null !== d ? (f = A(), null !== f ? (g = M(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = P(), null !== d ? (f = A(), null !== f ? (g = M(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "Inequality",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function P() {
                                var a;
                                return "<=" === b.substr(e, 2) ? (a = "<=", e += 2) : (a = null, 0 === f && k('"<="')), null === a && (">=" === b.substr(e, 2) ? (a = ">=", e += 2) : (a = null, 0 === f && k('">="')), null === a && (60 === b.charCodeAt(e) ? (a = "<", e++) : (a = null, 0 === f && k('"<"')), null === a && (62 === b.charCodeAt(e) ? (a = ">", e++) : (a = null, 0 === f && k('">"'))))), a
                            }

                            function Q() {
                                var a, c, d, g, h, i, j, l, m;
                                if (j = e, l = e, a = O(), null !== a) {
                                    for (c = [], m = e, d = A(), null !== d ? ("==" === b.substr(e, 2) ? (g = "==", e += 2) : (g = null, 0 === f && k('"=="')), null !== g ? (h = A(), null !== h ? (i = O(), null !== i ? d = [d, g, h, i] : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m); null !== d;) c.push(d), m = e, d = A(), null !== d ? ("==" === b.substr(e, 2) ? (g = "==", e += 2) : (g = null, 0 === f && k('"=="')), null !== g ? (h = A(), null !== h ? (i = O(), null !== i ? d = [d, g, h, i] : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m);
                                    null !== c ? a = [a, c] : (a = null, e = l)
                                } else a = null, e = l;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "Equality",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(j, a[0], a[1])), null === a && (e = j), a
                            }

                            function R(a) {
                                a.sort();
                                for (var b = null, c = [], d = 0; d < a.length; d++) a[d] !== b && (c.push(a[d]), b = a[d]);
                                return c
                            }

                            function S() {
                                for (var a = 1, c = 1, d = !1, f = 0; f < Math.max(e, g); f++) {
                                    var h = b.charAt(f);
                                    "\n" === h ? (d || a++, c = 1, d = !1) : "\r" === h || "\u2028" === h || "\u2029" === h ? (a++, c = 1, d = !0) : (c++, d = !1)
                                }
                                return {
                                    line: a,
                                    column: c
                                }
                            }
                            var d = {
                                start: l,
                                Statement: m,
                                SourceCharacter: n,
                                IdentifierStart: o,
                                IdentifierPart: p,
                                WhiteSpace: q,
                                LineTerminator: r,
                                LineTerminatorSequence: s,
                                EOS: t,
                                EOF: u,
                                Comment: v,
                                MultiLineComment: w,
                                MultiLineCommentNoLineTerminator: x,
                                SingleLineComment: y,
                                _: z,
                                __: A,
                                Literal: B,
                                Integer: C,
                                Real: D,
                                SignedInteger: E,
                                Identifier: F,
                                IdentifierName: G,
                                PrimaryExpression: H,
                                UnaryExpression: I,
                                UnaryOperator: J,
                                MultiplicativeExpression: K,
                                MultiplicativeOperator: L,
                                AdditiveExpression: M,
                                AdditiveOperator: N,
                                InequalityExpression: O,
                                InequalityOperator: P,
                                LinearExpression: Q
                            };
                            if (void 0 !== c) {
                                if (void 0 === d[c]) throw new Error("Invalid rule name: " + a(c) + ".")
                            } else c = "start";
                            var e = 0,
                                f = 0,
                                g = 0,
                                h = [],
                                T = d[c]();
                            if (null === T || e !== b.length) {
                                var U = Math.max(e, g),
                                    V = U < b.length ? b.charAt(U) : null,
                                    W = S();
                                throw new this.SyntaxError(R(h), V, U, W.line, W.column)
                            }
                            return T
                        },
                        toSource: function() {
                            return this._source
                        }
                    };
                    return b.SyntaxError = function(b, c, d, e, f) {
                        function g(b, c) {
                            var d, e;
                            switch (b.length) {
                                case 0:
                                    d = "end of input";
                                    break;
                                case 1:
                                    d = b[0];
                                    break;
                                default:
                                    d = b.slice(0, b.length - 1).join(", ") + " or " + b[b.length - 1]
                            }
                            return e = c ? a(c) : "end of input", "Expected " + d + " but " + e + " found."
                        }
                        this.name = "SyntaxError", this.expected = b, this.found = c, this.message = g(b, c), this.offset = d, this.line = e, this.column = f
                    }, b.SyntaxError.prototype = Error.prototype, b
                }(),
                function(a) {
                    "use strict";
                    var b = new a.SimplexSolver,
                        c = {},
                        d = {},
                        e = a.Strength.weak;
                    a.Strength.medium, a.Strength.strong, a.Strength.required;
                    var i = function(f) {
                            if (d[f]) return d[f];
                            switch (f.type) {
                                case "Inequality":
                                    var g = "<=" == f.operator ? a.LEQ : a.GEQ,
                                        h = new a.Inequality(i(f.left), g, i(f.right), e);
                                    return b.addConstraint(h), h;
                                case "Equality":
                                    var h = new a.Equation(i(f.left), i(f.right), e);
                                    return b.addConstraint(h), h;
                                case "MultiplicativeExpression":
                                    var h = a.times(i(f.left), i(f.right));
                                    return b.addConstraint(h), h;
                                case "AdditiveExpression":
                                    return "+" == f.operator ? a.plus(i(f.left), i(f.right)) : a.minus(i(f.left), i(f.right));
                                case "NumericLiteral":
                                    return new a.Expression(f.value);
                                case "Variable":
                                    return c[f.name] || (c[f.name] = new a.Variable({
                                        name: f.name
                                    })), c[f.name];
                                case "UnaryExpression":
                                    console.log("UnaryExpression...WTF?")
                            }
                        },
                        j = function(a) {
                            return a.map(i)
                        };
                    a._api = function() {
                        var c = Array.prototype.slice.call(arguments);
                        if (1 == c.length) {
                            if ("string" == typeof c[0]) {
                                var d = a.parser.parse(c[0]);
                                return j(d)
                            }
                            "function" == typeof c[0] && b._addCallback(c[0])
                        }
                    }
                }(this.c || module.parent.exports || {});
        }).call(
            (typeof module != "undefined") ?
            (module.compiled = true && module) : this
        );

    }, {}],
    2: [function(require, module, exports) {
        function Expression() {
            this._left = null;
            this._right = null;
        }
        module.exports = Expression;

        Expression.prototype.addExpressions = function(left, right) {
            this._left = left;
            this._right = right;
        };

        // Overridable method
        Expression.prototype.construct = function() {};
    }, {}],
    3: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var primitives = require('./primitives.js');
        var operators = require('./operators.js');
        var parseExpression = require('./parser.js');

        var Numeral = primitives.Numeral;
        var Constant = primitives.Constant;
        var Variable = primitives.Variable;

        var Equality = operators.Equality;
        var Multiplication = operators.Multiplication;

        function System() {
            if ((this instanceof System) === false) {
                return new System();
            }

            this._solver = new cassowary.SimplexSolver();
            this._solver.autoSolve = false;

            this._variables = [];
            this._constants = [];
            this._constraints = {};
            this._parameters = {};

            // Callback and its parameters
            // Yes it is possible to pass the parameters of the callback
            // to allow the user to avoid keeping closures around (closures keep objects in memory!)
            this._onNewSolution = null;
            this._onNewSolutionParams = null;

            this._forceResolving = true;

            // Optimization parameters
            this.z = 0;
            this._objectiveVariable = null;
            this._optimization = false;
            this._minimization = true;

            // Callback function when a parameter is missing
            // when parsing an expression
            var self = this;
            this._onParameterMissing = function(name) {
                return self.addVariable(name, {
                    x: 0
                }, 'x').getVariable(name);
            };
        }
        module.exports = System;

        System.prototype.onNewSolution = function(onNewSolution, onNewSolutionParams) {
            this._onNewSolution = onNewSolution;
            this._onNewSolutionParams = onNewSolutionParams;
            return this;
        };

        System.prototype._optimize = function(expression) {
            if (expression instanceof Variable === true) {
                this._objectiveVariable = expression;
                this._solver.optimize(expression._variable);
            } else {
                this._objectiveVariable = new Variable('z', {
                    z: 0
                }, 'z');
                this.addConstraint(new Equality(this._objectiveVariable, expression));
                this._solver.optimize(this._objectiveVariable._variable);
            }

            this._forceResolving = true;
            this._optimization = true;
        };

        System.prototype.minimize = function(expression) {
            if (typeof(expression) === 'string') {
                expression = parseExpression(expression, this._parameters, this._onParameterMissing);
            }

            this._optimize(expression);
            this._minimization = true;
            return this;
        };

        System.prototype.maximize = function(expression) {
            if (typeof(expression) === 'string') {
                expression = parseExpression(expression, this._parameters, this._onParameterMissing);
            }

            this._optimize(new Multiplication(expression, new Numeral(-1)));
            this._minimization = false;
            return this;
        };

        System.prototype.addVariable = function(name, object, property) {
            var variable = new Variable(name, object, property);
            this._variables.push(variable);
            this._parameters[name] = variable;
            return this;
        };

        System.prototype.addConstant = function(name, object, property) {
            var constant = new Constant(name, object, property);
            this._constants.push(constant);
            this._parameters[name] = constant;
            return this;
        };

        System.prototype.getVariable = function(name) {
            for (var v = 0; v < this._variables.length; v += 1) {
                if (this._variables[v]._name === name) {
                    return this._variables[v];
                }
            }
        };

        System.prototype.addConstraint = function(constraint) {
            if (typeof(constraint) === 'string') {
                constraint = parseExpression(constraint, this._parameters, this._onParameterMissing);
            }

            if (this._constraints[constraint._id] !== undefined) {
                console.warn('[System.addConstraint] Constraint already present in the system:', constraint);
                return;
            }

            this._solver.addConstraint(constraint.construct());
            this._constraints[constraint._id] = constraint;

            this._forceResolving = true;
            return this;
        };

        System.prototype.removeConstraint = function(constraint) {
            if (this._constraints[constraint._id] === undefined) {
                console.warn('[System.removeConstraint] Constraint not present in the system:', constraint);
                return;
            }

            constraint._unregisterFromPrimitives();
            this._solver.removeConstraint(constraint._constraint);
            delete this._constraints[constraint._id];

            this._forceResolving = true;
            return this;
        };

        System.prototype.resolve = function(slacking) {
            var c0, c1, constraint;

            var systemIsSameSameButDifferent = this._forceResolving;
            this._forceResolving = false;

            // Checking whether a constant has changed
            // var constraintsToUpdate = null;
            for (c0 = 0; c0 < this._constants.length; c0 += 1) {
                var constant = this._constants[c0];
                if (constant.refresh()) {
                    // The value of the constant has changed

                    // // At least one constraint will be updated
                    // if (constraintsToUpdate === null) {
                    // 	constraintsToUpdate = {};
                    // }

                    // // Updating all the constraints containing the constant
                    // var constraints = constant._constraints;
                    // for (c1 = 0; c1 < constraints.length; c1 += 1) {
                    // 	constraint = constraints[c1];
                    // 	constraintsToUpdate[constraint.id] = constraint;
                    // }

                    // Therefore it will need resolving
                    systemIsSameSameButDifferent = true;
                }
            }

            // // Updating constraints for which a constant has changed
            // if (constraintsToUpdate !== null) {
            // 	var constraintIds = Object.keys(constraintsToUpdate);
            // 	for (c1 = 0; c1 < constraintIds.length; c1 += 1) {
            // 		constraint = constraintsToUpdate[constraintIds[c1]];
            // 		// (Inefficient) Process to update a constraint:
            // 		// 1 - Remove the constraint
            // 		this._solver.removeConstraint(constraint._constraint);
            // 		// 2 - Reconstructing to consider the new constant value
            // 		constraint.construct();
            // 		// 3 - Add back the constraint
            // 		this._solver.addConstraint(constraint._constraint);

            // 		// Should be:
            // 		// constraint.updateConstant(constant);
            // 	}
            // }

            // Reconstructing the whole problem even if only one constant has changed
            if (systemIsSameSameButDifferent === true) {
                this._solver = new cassowary.SimplexSolver();
                this._solver.autoSolve = false;

                var constraintIds = Object.keys(this._constraints);
                for (c1 = 0; c1 < constraintIds.length; c1 += 1) {
                    constraint = this._constraints[constraintIds[c1]];
                    this._solver.addConstraint(constraint.construct());
                }
            }

            // Skip the resolution if no constant has changed and solver is required to slack
            if (systemIsSameSameButDifferent === false && slacking === true) {
                return;
            }

            // Resolving the problem
            this._solver.resolve();

            // Refreshing variables so that their corresponding objects get updated
            // with the newly computed feasible solution
            var solutionIsSameSameButDifferent = false;
            for (var v = 0; v < this._variables.length; v += 1) {
                if (this._variables[v].refresh() === true) {
                    solutionIsSameSameButDifferent = true;
                }
            }

            // Refreshing objective variable, if any
            if (this._optimization === true) {
                this._objectiveVariable.refresh();
                this.z = (this._minimization === true) ? this._objectiveVariable._value : -this._objectiveVariable._value;
            }

            // Triggering callback if the solution has changed
            if (solutionIsSameSameButDifferent === true) {
                if (this._onNewSolution !== null) {
                    this._onNewSolution(this._onNewSolutionParams);
                }
            }

            return this;
        };

        System.prototype.log = function() {
            for (var v = 0; v < this._variables.length; v += 1) {
                var variable = this._variables[v];
                console.log(variable._name, '=', variable._value);
            }

            console.log('objective value =', this.z);
        };

        System.prototype.getValue = function(name) {
            return this._parameters[name]._value;
        };

        System.prototype.getObjectiveValue = function() {
            return this.z;
        };
    }, {
        "../deps/cassowary.js": 1,
        "./operators.js": 5,
        "./parser.js": 6,
        "./primitives.js": 7
    }],
    4: [function(require, module, exports) {
        (function(global) {
            var primitives = require('./primitives.js');
            var operators = require('./operators.js');

            var System = require('./System.js');
            var Numeral = primitives.Numeral;

            var Addition = operators.Addition;
            var Subtraction = operators.Subtraction;
            var Multiplication = operators.Multiplication;
            var Division = operators.Division;
            var GreaterOrEqual = operators.GreaterOrEqual;
            var LowerOrEqual = operators.LowerOrEqual;
            var Equality = operators.Equality;

            var Constrained = {
                // System of constraints
                System: System,

                // Expression operators
                plus: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Addition(expression1, expression2);
                },

                minus: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Subtraction(expression1, expression2);
                },

                times: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Multiplication(expression1, expression2);
                },

                dividedBy: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Division(expression1, expression2);
                },

                // Constraint generators
                greaterThan: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new GreaterOrEqual(expression1, expression2, strength, weight);
                },

                lowerThan: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new LowerOrEqual(expression1, expression2, strength, weight);
                },

                equals: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Equality(expression1, expression2, strength, weight);
                }
            };

            // window within a browser, global within node
            var root;
            if (typeof(window) !== 'undefined') {
                root = window;
            } else if (typeof(global) !== 'undefined') {
                root = global;
            } else {
                console.warn('[TINA] Your environment might not support TINA.');
                root = this;
            }

            module.exports = root.Constrained = Constrained;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "./System.js": 3,
        "./operators.js": 5,
        "./primitives.js": 7
    }],
    5: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var Expression = require('./Expression.js');

        function Addition(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Addition.prototype = Object.create(Expression.prototype);
        Addition.prototype.constructor = Addition;
        Addition.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.plus(right);
        };

        function Subtraction(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Subtraction.prototype = Object.create(Expression.prototype);
        Subtraction.prototype.constructor = Subtraction;
        Subtraction.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.minus(right);
        };

        function Multiplication(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Multiplication.prototype = Object.create(Expression.prototype);
        Multiplication.prototype.constructor = Multiplication;
        Multiplication.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.times(right);
        };

        function Division(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Division.prototype = Object.create(Expression.prototype);
        Division.prototype.constructor = Division;
        Division.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.divide(right);
        };

        var constraintCount = 0;

        function Constraint(expression1, expression2, strength, weight) {
            this._expression1 = expression1;
            this._expression2 = expression2;
            this._strength = strength;
            this._weight = weight;

            this._constraint = null;
            this._id = (constraintCount++).toString();

            this._registerToPrimitives();
        }

        Constraint.prototype._registerToPrimitives = function() {
            var stack = [this._expression1, this._expression2];
            while (stack.length !== 0) {
                var expression = stack.pop();
                if (expression._left === null) {
                    expression._register(this);
                } else {
                    stack.push(expression._left);
                    stack.push(expression._right);
                }
            }
        };

        Constraint.prototype._unregisterFromPrimitives = function() {
            var stack = [this._expression1, this._expression2];
            while (stack.length !== 0) {
                var expression = stack.pop();
                if (expression._left === null) {
                    expression._unregister(this);
                } else {
                    stack.push(expression._left);
                    stack.push(expression._right);
                }
            }
        };

        function LowerOrEqual(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        LowerOrEqual.prototype = Object.create(Constraint.prototype);
        LowerOrEqual.prototype.constructor = LowerOrEqual;
        LowerOrEqual.prototype.construct = function() {
            this._constraint = new cassowary.Inequality(
                this._expression1.construct(),
                cassowary.LEQ,
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        function GreaterOrEqual(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        GreaterOrEqual.prototype = Object.create(Constraint.prototype);
        GreaterOrEqual.prototype.constructor = GreaterOrEqual;
        GreaterOrEqual.prototype.construct = function() {
            this._constraint = new cassowary.Inequality(
                this._expression1.construct(),
                cassowary.GEQ,
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        function Equality(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        Equality.prototype = Object.create(Constraint.prototype);
        Equality.prototype.constructor = Equality;
        Equality.prototype.construct = function() {
            this._constraint = new cassowary.Equation(
                this._expression1.construct(),
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        module.exports = {
            Addition: Addition,
            Subtraction: Subtraction,
            Multiplication: Multiplication,
            Division: Division,
            LowerOrEqual: LowerOrEqual,
            GreaterOrEqual: GreaterOrEqual,
            Equality: Equality
        };
    }, {
        "../deps/cassowary.js": 1,
        "./Expression.js": 2
    }],
    6: [function(require, module, exports) {
        var systemOperators = require('./operators.js');
        var systemPrimitives = require('./primitives.js');

        var Addition = systemOperators.Addition;
        var Subtraction = systemOperators.Subtraction;
        var Multiplication = systemOperators.Multiplication;
        var Division = systemOperators.Division;
        var GreaterOrEqual = systemOperators.GreaterOrEqual;
        var LowerOrEqual = systemOperators.LowerOrEqual;
        var Equality = systemOperators.Equality;

        var Numeral = systemPrimitives.Numeral;

        //���������������������������������������������������������������������������
        /**
         * @class  Expression Parser
         * @author Cedric Stoquer
         *
         * @param {String} str - string buffer
         *
         *
         * Simple expression parser with the following features:
         * - parse variables, integer and float numbers, string constants, unary and binary operators,
         *   parenthesis, predefined functions with any number of parameters.
         * - correctly resolve operator precedence.
         *
         * Originaly designed to parse BASIC programs
         */
        function Parser(str) {
            this.str = str;
            this.parameterMap = null;
            this.onParameterMissing = null;
        }

        function parseExpression(str, parameterMap, onParameterMissing) {
            var parser = new Parser(str);
            parser.parameterMap = parameterMap;
            parser.onParameterMissing = onParameterMissing;
            return parser.parseExpression();
        }

        module.exports = parseExpression;

        //���������������������������������������������������������������������������

        var operators = [
            // { id: ';',   precedence: 0 },
            // { id: 'AND', precedence: 1 },
            // { id: 'OR',  precedence: 1 },
            // { id: 'XOR', precedence: 1 },
            // { id: '<>',  precedence: 2 },
            {
                id: '>=',
                precedence: 2,
                class: GreaterOrEqual
            }, {
                id: '<=',
                precedence: 2,
                class: LowerOrEqual
            }, {
                id: '=',
                precedence: 2,
                class: Equality
            },
            // { id: '>',   precedence: 2 },
            // { id: '<',   precedence: 2 },
            {
                id: '+',
                precedence: 3,
                class: Addition
            }, {
                id: '-',
                precedence: 3,
                class: Subtraction
            },
            // { id: '\\',  precedence: 4 },
            // { id: 'MOD', precedence: 4 },
            {
                id: '*',
                precedence: 4,
                class: Multiplication
            }, {
                id: '/',
                precedence: 4,
                class: Division
            }
        ];

        var unaryOperators = [
            // { id: '!' }
        ];

        var functions = [
            // { id: 'ABS',      parameters: 1 },
            // { id: 'ATN',      parameters: 1 },
            // { id: 'CIN',      parameters: 1 },
            // { id: 'COS',      parameters: 1 },
            // { id: 'EXP',      parameters: 1 },
            // { id: 'INT',      parameters: 1 },
            // { id: 'LOG10',    parameters: 1 },
            // { id: 'LOG',      parameters: 1 },
            // { id: 'MAX',      parameters: '*' },
            // { id: 'MIN',      parameters: '*' },
            // { id: 'PI',       parameters: 0 },
            // { id: 'ROUND',    parameters: [1, 2] },
            // { id: 'SGN',      parameters: 1 },
            // { id: 'SIN',      parameters: 1 },
            // { id: 'SQR',      parameters: 1 },
            // { id: 'TAN',      parameters: 1 }
        ];

        //���������������������������������������������������������������������������

        Parser.prototype.removeWhiteSpace = function() {
            var t = this;
            // while (t.str[0] === ' ' || t.str[0] === '\n') t.str = t.str.substring(1);
            t.str = t.str.replace(' ', '');
            t.str = t.str.replace('\n', '');
        };

        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������

        /** @method parseParenthesis
         */
        Parser.prototype.parseParenthesis = function() {
            var t = this;
            if (t.str[0] !== '(') throw new Error('An opening parenthesis is missing.');
            //consume first parenthesis
            t.str = t.str.substring(1);
            var res = '';
            var stackParenthesis = 0;
            while (!(t.str[0] === ')' && stackParenthesis === 0)) {
                if (t.str[0] === '(') stackParenthesis++;
                if (t.str[0] === ')') stackParenthesis--;
                if (stackParenthesis < 0) throw new Error('Too much closing parenthesis.');
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Parenthesis expression doesn\'t resolve');
            }
            // consume last parenthesis
            t.str = t.str.substring(1);

            // parse expression inside parenthesis
            res = parseExpression(res, t.parameterMap, t.onParameterMissing);
            // res = {
            // 	type: 'parenthesis',
            // 	arg: res
            // };
            return res;
        };

        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������

        /** @method getParenthesisList
         * Parse a list of comma separated arguments
         */
        Parser.prototype.getParenthesisList = function() {
            var t = this;
            // parse parenthesis content: (expr, expr, ...)
            if (t.str[0] !== '(') throw new Error('An opening parenthesis is missing.');
            // consume first "("
            t.str = t.str.substring(1);
            var args = [];
            var arg = '';
            var stackParenthesis = 0;
            while (!(t.str[0] === ')' && stackParenthesis === 0)) {
                if (t.str[0] === '(') stackParenthesis++;
                if (t.str[0] === ')') stackParenthesis--;
                if (stackParenthesis < 0) throw new Error('Too much closing parenthesis.');
                if (t.str[0] === ',' && stackParenthesis === 0) {
                    arg = parseExpression(arg);
                    args.push(arg);
                    arg = '';
                } else {
                    arg += t.str[0];
                }
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Parenthesis expression doesn\'t resolve');
            }
            // push last parameter
            arg = parseExpression(arg);
            args.push(arg);
            // consume last ")"
            t.str = t.str.substring(1);
            return args;
        };

        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������

        /** @method parseString
         */
        Parser.prototype.parseString = function() {
            var t = this;
            var res = '';
            if (t.str[0] !== '"') throw new Error('An opening quote is missing.');
            // consume first double quote
            t.str = t.str.substring(1);
            while (t.str[0] !== '"') {
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Closing quote not found.');
            }
            // consume last double quote
            t.str = t.str.substring(1);
            return {
                type: 'string',
                value: res
            };
        };

        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������

        /** @method parseNumber
         */
        Parser.prototype.parseNumber = function() {
            var t = this;
            var type = 'int';
            var res = '';

            // check for a negative number
            if (t.str[0] === '-') {
                res = '-';
                t.str = t.str.substring(1);
                t.removeWhiteSpace();
            }

            if (t.str === '') throw new Error('End of line before number.');

            if (t.str[0].search(/[0-9]/) === -1) throw new Error('Not a digit character');
            while (t.str[0].search(/[0-9]/) === 0) {
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') break;
            }

            // check for a decimal point
            if (t.str[0] === '.') {
                type = 'float';
                res += '.';
                t.str = t.str.substring(1);
                // continue to consume decimal digits
                while (t.str[0].search(/[0-9]/) === 0) {
                    res += t.str[0];
                    t.str = t.str.substring(1);
                    if (t.str === '') break;
                }
            }

            // var value = Number(res);
            return new Numeral(parseFloat(res));
        };

        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������

        /** @method parseFunction
         * @desc   get function parameters content
         * @param {Object} func - function definition object
         *
         * A function have the following syntax:
         * - without parameters                : FUNC
         * - parameters defined in parenthesis : FUNC(X)
         * - and comma separated               : FUNC(X1, X2, X3, ...)
         */
        Parser.prototype.parseFunction = function(func) {
            var t = this;
            // function name has already been consumed.
            var res = {
                type: 'function',
                id: func.id
            };
            var parameters = func.parameters;
            // parameters can be:
            // 0 -> no parameters, thus no parenthesis
            if (parameters === 0) return res;

            // int   -> a fixed number of parameter
            // array -> various number of parameters is possible
            // '*'   -> number of parameters is free (but at least 1)

            // special case: if function can have 0 or more parameters,
            // then if we have 0 parameters, there are no parenthesis
            if (Array.isArray(parameters) && parameters.indexOf(0) !== -1 && t.str[0] !== '(') {
                return res;
            }

            var args = t.getParenthesisList();

            // check parameters count
            var count = args.length;
            // there are no parameter (but there are brackets)
            if (count === 0) throw new Error('There is no arguments inside function brackets.');
            // number of parameters is incorrect
            if (!isNaN(parameters) && count !== parameters) throw new Error('Incorrect number of arguments.');
            // check when various number of parameters are possible
            if (Array.isArray(parameters)) {
                var ok = false;
                for (var i = 0, len = parameters.length; i < len; i++) {
                    if (count === parameters[i]) {
                        ok = true;
                        break;
                    }
                }
                if (!ok) throw new Error('Incorrect number of arguments.');
            }

            // add parameters in result
            res.args = args;
            return res;
        };


        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������

        /** @method parseVariable
         */
        Parser.prototype.parseVariable = function() {
            var t = this;
            var res = '';
            // default type for locomotive basic are float
            var varType = 'float';

            // first character must be a letter
            if (t.str[0].search(/[A-Za-z]/) === -1) throw new Error('Invalid variable name');
            res += t.str[0];
            t.str = t.str.substring(1);

            // following character could be letters or numbers
            while (t.str !== '' && t.str[0].search(/[A-Za-z0-9]/) !== -1) {
                res += t.str[0];
                t.str = t.str.substring(1);
            }

            // variable name can ends with one of these special characters : $ % !
            if (t.str[0] === '$' || t.str[0] === '%' || t.str[0] === '!') {
                res += t.str[0];
                switch (t.str[0]) {
                    case '$':
                        varType = 'string';
                        break;
                    case '%':
                        varType = 'int';
                        break;
                    case '!':
                        varType = 'float';
                        break;
                }
                t.str = t.str.substring(1);
            }

            /*res = {
            	type: 'variable',
            	varType: varType,
            	id: res,
            };

            // if variable is an array, following character is a opening bracket
            if (t.str[0] === '(') {
            	// extract parenthesis content
            	res.indexes = t.getParenthesisList();
            	// set variable as an array
            	res.isArray = true;
            }

            return res;*/

            var parameter = t.parameterMap[res];
            return (parameter === undefined) ? t.onParameterMissing(res) : parameter;
        };

        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������

        /** @method getNextObject
         *
         * next object should be one of these:
         *  ~  (e)     an expression in parenthesis
         *  ~  -1      a number (possibly negative). NOTA: no whitespace allowed between "-" operator and the number
         *  ~  -e      unary operator applied to an expression
         *  ~  NOT e   unary boolean operator NOT
         *  ~  F(e,e)  a function (function names are known, see table)
         *  ~  X       a variable name
         */
        Parser.prototype.getNextObject = function() {
            var t = this;
            t.removeWhiteSpace();

            if (t.str === '') return null;

            // check if next object is an expression in parenthesis
            if (t.str[0] === '(') return t.parseParenthesis();

            // check if next object is a string
            if (t.str[0] === '"') return t.parseString();

            // TODO: hexadecimal number

            // check for unary '-' operator (not with number)
            if (t.str[0] === '-' && t.str[1].search(/[0-9]/) === -1) {
                // consume '-'
                t.str = t.str.substring(1);
                return new Multiplication(new Numeral(-1), t.getNextObject());
                // return { type: 'unaryOp', id: '-', arg: t.getNextObject() };
            }

            // check for unary operators
            var i;
            for (i = 0; i < unaryOperators.length; i++) {
                var operatorId = unaryOperators[i].id;
                var strLen = operatorId.length;
                if (t.str.substring(0, strLen) === operatorId) {
                    // consume operator
                    t.str = t.str.substring(strLen);
                    return new unaryOperators[i].class(t.getNextObject());
                    // return { type: 'unaryOp', id: operatorId, arg: t.getNextObject() };
                }
            }

            // check if next object is a number
            if (t.str[0].search(/[\-0-9]/) !== -1) return t.parseNumber();

            // check if next object is a function
            for (i = 0; i < functions.length; i++) {
                var fLen = functions[i].id.length;
                if (t.str.substring(0, fLen) === functions[i].id) {
                    // consume funtion name
                    t.str = t.str.substring(fLen);
                    // get parameters and return function object
                    return t.parseFunction(functions[i]);
                }
            }

            // check if next object is a variable name
            if (t.str[0].search(/[A-Za-z]/) !== -1) return t.parseVariable();

            // not recognized object
            return null;
        };

        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������

        /** @method getNextOperator
         *
         * next token is an operator in the list
         */
        Parser.prototype.getNextOperator = function() {
            var t = this;
            t.removeWhiteSpace();

            // check end of stream
            if (t.str === '') return null;

            // check each of operators
            for (var i = 0; i < operators.length; i++) {
                var oLen = operators[i].id.length;
                if (t.str.substring(0, oLen) === operators[i].id) {
                    // consume token
                    t.str = t.str.substring(oLen);
                    // return operator
                    return operators[i];
                }
            }

            // next element is not a token
            return null;
        };

        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������

        /** @method parseExpression
         *
         * next token is an operator in the list
         */
        Parser.prototype.parseExpression = function() {
            // get all tokens
            var operator;
            var objects = [];
            var operators = [];
            while (true) {
                objects.push(this.getNextObject());
                operator = this.getNextOperator();
                if (operator === null) break;
                operators.push(operator);
            }

            // parse expression
            var i = 0;
            while (operators.length > 0) {
                operator = operators[i];
                var lookahead = operators[i + 1];
                if (!lookahead || operator.precedence >= lookahead.precedence) {
                    // reducing object[i] operator[i] object[i+1]
                    // var object = {
                    // 	type: 'operator',
                    // 	id:   operator.id,
                    // 	arg1: objects[i],
                    // 	arg2: objects[i+1]
                    // };

                    var object = new operator.class(objects[i], objects[i + 1]);

                    objects.splice(i, 2, object);
                    operators.splice(i, 1);
                    i = 0;
                    continue;
                }
                i += 1;
            }
            return objects[0];
        };



    }, {
        "./operators.js": 5,
        "./primitives.js": 7
    }],
    7: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var Expression = require('./Expression.js');

        function Numeral(value) {
            this._value = value;
            Expression.call(this);
        }
        Numeral.prototype = Object.create(Expression.prototype);
        Numeral.prototype.constructor = Numeral;

        Numeral.prototype.construct = function() {
            return new cassowary.Expression(this._value);
        };

        Numeral.prototype._register = function() {};
        Numeral.prototype._unregister = function() {};


        function ObjectBinder(name, object, property) {
            this._name = name;
            this._object = object;
            this._property = property;
            this._value = object[property];

            this._constraints = [];
        }

        ObjectBinder.prototype._register = function(constraint) {
            this._constraints.push(constraint);
        };

        ObjectBinder.prototype._unregister = function(constraint) {
            var idx = this._constraints.indexOf(constraint);
            if (idx === -1) {
                this._constraints.splice(idx, 1);
            }
        };


        function Constant(name, object, property) {
            if ((this instanceof Constant) === false) {
                return new Constant(object, property);
            }

            ObjectBinder.call(this, name, object, property);
            Expression.call(this);
        }
        Constant.prototype = Object.create(Expression.prototype);
        Constant.prototype.constructor = Constant;
        Constant.prototype._register = ObjectBinder.prototype._register;
        Constant.prototype._unregister = ObjectBinder.prototype._unregister;

        Constant.prototype.construct = function() {
            return new cassowary.Expression(this._object[this._property]);
        };

        Constant.prototype.refresh = function() {
            if (this._value !== this._object[this._property]) {
                this._value = this._object[this._property];
                return true;
            }

            return false;
        };


        function Variable(name, object, property) {
            if ((this instanceof Variable) === false) {
                return new Variable(object, property);
            }

            // Callback and its parameters
            // Yes it is possible to pass the parameters of the callback
            // to allow the user to avoid keeping closures around (closures keep objects in memory!)
            this._onChange = null;
            this._onChangeParams = null;

            ObjectBinder.call(this, name, object, property);
            Expression.call(this);

            this._variable = new cassowary.Variable({
                name: this._name,
                value: this._value
            });
        }
        Variable.prototype = Object.create(cassowary.Variable.prototype);
        Variable.prototype.constructor = Variable;
        Variable.prototype._register = ObjectBinder.prototype._register;

        Variable.prototype.construct = function() {
            return new cassowary.Expression(this._variable, 1);
        };

        Variable.prototype.refresh = function() {
            if (this._value !== this._variable.value) {
                this._object[this._property] = this._variable.value;
                if (this._onChange !== null) {
                    this._onChange(this._onChangeParams, this._variable.value, this._value);
                }
                this._value = this._variable.value;
                return true;
            }

            return false;
        };

        Variable.prototype.onChange = function(onChange, onChangeParams) {
            this._onChange = onChange;
            this._onChangeParams = onChangeParams;
            return this;
        };

        module.exports = {
            Numeral: Numeral,
            Constant: Constant,
            Variable: Variable
        };
    }, {
        "../deps/cassowary.js": 1,
        "./Expression.js": 2
    }]
}, _modules , [4]);

module.exports = _modules[4].exports;
};
BundleModuleCode['plugins/csp/fmin']=function (module,exports){
/* https://github.com/benfred/fmin */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.fmin = global.fmin || {})));
}(this, function (exports) { 'use strict';

    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    function bisect(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
        }

        if (fA === 0) return a;
        if (fB === 0) return b;

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    }

    // need some basic operations on vectors, rather than adding a dependency,
    // just define here
    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

    function dot(a, b) {
        var ret = 0;
        for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
        }
        return ret;
    }

    function norm2(a)  {
        return Math.sqrt(dot(a, a));
    }

    function scale(ret, value, c) {
        for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
        }
    }

    function weightedSum(ret, w1, v1, w2, v2) {
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
        }
    }

    /** minimizes a function using the downhill simplex method */
    function nelderMead(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.05,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-6,
            minTolerance = parameters.minErrorDelta || 1e-5,
            rho = (parameters.rho !== undefined) ? parameters.rho : 1,
            chi = (parameters.chi !== undefined) ? parameters.chi : 2,
            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
            maxDiff;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        simplex[0].id = 0;
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
            simplex[i+1].id = i+1;
        }

        function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
                simplex[N][i] = value[i];
            }
            simplex[N].fx = value.fx;
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        var centroid = x0.slice(),
            reflected = x0.slice(),
            contracted = x0.slice(),
            expanded = x0.slice();

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
                // copy the simplex (since later iterations will mutate) and
                // sort it to have a consistent order between iterations
                var sortedSimplex = simplex.map(function (x) {
                    var state = x.slice();
                    state.fx = x.fx;
                    state.id = x.id;
                    return state;
                });
                sortedSimplex.sort(function(a,b) { return a.id - b.id; });

                parameters.history.push({x: simplex[0].slice(),
                                         fx: simplex[0].fx,
                                         simplex: sortedSimplex});
            }

            maxDiff = 0;
            for (i = 0; i < N; ++i) {
                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
                (maxDiff < minTolerance)) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            weightedSum(reflected, 1+rho, centroid, -rho, worst);
            reflected.fx = f(reflected);

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx < simplex[0].fx) {
                weightedSum(expanded, 1+chi, centroid, -chi, worst);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    updateSimplex(expanded);
                }  else {
                    updateSimplex(reflected);
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                    // do an inside contraction
                    weightedSum(contracted, 1+psi, centroid, -psi, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < reflected.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // if we don't contract here, we're done
                    if (sigma >= 1) break;

                    // do a reduction
                    for (i = 1; i < simplex.length; ++i) {
                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            } else {
                updateSimplex(reflected);
            }
        }

        simplex.sort(sortOrder);
        return {fx : simplex[0].fx,
                x : simplex[0]};
    }

    /// searches along line 'pk' for a point that satifies the wolfe conditions
    /// See 'Numerical Optimization' by Nocedal and Wright p59-60
    /// f : objective function
    /// pk : search direction
    /// current: object containing current gradient/loss
    /// next: output: contains next gradient/loss
    /// returns a: step size taken
    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),
            phi = phi0, phi_old = phi0,
            phiPrime = phiPrime0,
            a0 = 0;

        a = a || 1;
        c1 = c1 || 1e-6;
        c2 = c2 || 0.1;

        function zoom(a_lo, a_high, phi_lo) {
            for (var iteration = 0; iteration < 16; ++iteration) {
                a = (a_lo + a_high)/2;
                weightedSum(next.x, 1.0, current.x, a, pk);
                phi = next.fx = f(next.x, next.fxprime);
                phiPrime = dot(next.fxprime, pk);

                if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                    (phi >= phi_lo)) {
                    a_high = a;

                } else  {
                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                        return a;
                    }

                    if (phiPrime * (a_high - a_lo) >=0) {
                        a_high = a_lo;
                    }

                    a_lo = a;
                    phi_lo = phi;
                }
            }

            return 0;
        }

        for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);
            if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                (iteration && (phi >= phi_old))) {
                return zoom(a0, a, phi_old);
            }

            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                return a;
            }

            if (phiPrime >= 0 ) {
                return zoom(a, a0, phi);
            }

            phi_old = phi;
            a0 = a;
            a *= 2;
        }

        return a;
    }

    function conjugateGradient(f, initial, params) {
        // allocate all memory up front here, keep out of the loop for perfomance
        // reasons
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            yk = initial.slice(),
            pk, temp,
            a = 1,
            maxIterations;

        params = params || {};
        maxIterations = params.maxIterations || initial.length * 20;

        current.fx = f(current.x, current.fxprime);
        pk = current.fxprime.slice();
        scale(pk, current.fxprime,-1);

        for (var i = 0; i < maxIterations; ++i) {
            a = wolfeLineSearch(f, pk, current, next, a);

            // todo: history in wrong spot?
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     alpha: a});
            }

            if (!a) {
                // faiiled to find point that satifies wolfe conditions.
                // reset direction for next iteration
                scale(pk, current.fxprime, -1);

            } else {
                // update direction using Polak–Ribiere CG method
                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);

                var delta_k = dot(current.fxprime, current.fxprime),
                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);

                weightedSum(pk, beta_k, pk, -1, next.fxprime);

                temp = current;
                current = next;
                next = temp;
            }

            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        if (params.history) {
            params.history.push({x: current.x.slice(),
                                 fx: current.fx,
                                 fxprime: current.fxprime.slice(),
                                 alpha: a});
        }

        return current;
    }

    function gradientDescent(f, initial, params) {
        params = params || {};
        var maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 0.001,
            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};

        for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice()});
            }

            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        return current;
    }

    function gradientDescentLineSearch(f, initial, params) {
        params = params || {};
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 1,
            pk = initial.slice(),
            c1 = params.c1 || 1e-3,
            c2 = params.c2 || 0.1,
            temp,
            functionCalls = [];

        if (params.history) {
            // wrap the function call to track linesearch samples
            var inner = f;
            f = function(x, fxprime) {
                functionCalls.push(x.slice());
                return inner(x, fxprime);
            };
        }

        current.fx = f(current.x, current.fxprime);
        for (var i = 0; i < maxIterations; ++i) {
            scale(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);

            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     functionCalls: functionCalls,
                                     learnRate: learnRate,
                                     alpha: learnRate});
                functionCalls = [];
            }


            temp = current;
            current = next;
            next = temp;

            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;
        }

        return current;
    }

    exports.bisect = bisect;
    exports.nelderMead = nelderMead;
    exports.conjugateGradient = conjugateGradient;
    exports.gradientDescent = gradientDescent;
    exports.gradientDescentLineSearch = gradientDescentLineSearch;
    exports.zeros = zeros;
    exports.zerosM = zerosM;
    exports.norm2 = norm2;
    exports.weightedSum = weightedSum;
    exports.scale = scale;

}));
};
BundleModuleCode['plugins/ml/ml.js']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     8-2-16 by sbosse.
 **    $VERSION:     1.29.1X
 **
 **    $INFO:
 **
 **  JavaScript Machine Learning API
 **
 ** type algorithm = {'dti','dt','id3','c45','kmeans','knn','knn2','mlp','slp','rl','svm','txt','cnn'}
 **
 **
 ** id3: Symbolic Decision Tree algorithm
 ** -------------------------------------
 **
 ** typeof @options = {
 **   algorithm='id3',
 **   data:{x1:number,x2:number,..,y:*} []
 **   target:string is e.g. 'y'
 **   features: string [] is e.g. ['x1','x2',..]
 ** }
 **
 ** ice: decision tree algorithm supporting numbers with eps intervals (hybrid C45/ID3)
 ** -------------------------------------
 **
 ** General feature variable set:
 **
 ** typeof @options = {
 **   algorithm='dt',
 **   data:{x1:number,x2:number,..,y:*} [],
 **   target:string is e.g. 'y',
 **   features: string [] is e.g. ['x1','x2',..],
 **   eps:number is e.g. '5',
 ** }
 ** 
 ** dti: interval decision tree algorithm
 ** -------------------------------------
 **
 ** General feature variable set:
 **
 ** typeof @options = {
 **   algorithm='dti',
 **   data:{x1:number,x2:number,..,y:*} []
 **   target:string is e.g. 'y'
 **   features: string [] is e.g. ['x1','x2',..]
 **   eps:number is e.g. '5',
 **   maxdepth:number,
 ** }
 ** 
 ** Or vector feature variables (i.e., features=[0,1,2,...n-1], target=n):
 **
 ** typeof @options = {
 **   algorithm='dti',
 **   x:* [] [],
 **   y:* [],
 **   eps:number is e.g. '5',
 **   maxdepth:number,
 ** }
 **
 ** knn: k-Nearest-Neighbour Algorithm
 ** ----------------------------------
 **
 ** typeof @options = {
 **   algorithm='knn',
 **   x: number [][], 
 **   y: * []
 ** }
 **
 ** mlp: single/multi layer perceptron Algorithm
 ** ----------------------------------
 **
 ** typeof @options = {
 **   algorithm='mlp',
 **   x: number [][], 
 **   y: number [] [] | * [],
 **   hidden_layers?:number [],
 **   lr?:number,
 **   epochs?:number,
 **   labels?:string [], 
 **   features?: string [], 
 **   normalize?, 
 **   verbose?:number
 ** }
 **
 ** ann: Universal ANN (neataptic)
 ** ----------------------------------
 **
 ** typeof @learner.options = {
 **   algorithm='ann',
 **   layers:number [],
 **   architecture : archtyp string [],
 **   activation? : actfun string | actfun string [] 
 ** }
 ** with actfun = 'RELU'|'LOGISTC'|'IDENTITY'|'STEP'|'TANH'|.. and
         acttyp = 'LSTM'|'GRU'|'Dense'|
 ** typeof @train.options = {
 **   alpah?: number,
 **   gamma?: number,
 **   iterations? : number,
 **   error?: number,
 ** }
 **
 ** cnn: Convolutional Neural Network for numerial (2D) data
 ** -------------------------------------
 **
 ** General feature variable set:
 **
 ** typeof @options = {
 **   algorithm='cnn',
 **   data:{x:[]|[][],y:'a} []
 **   layers: layer [],
 **   trainer:trainer,
 ** }
 ** type layer = 
 **  {type:'input', out_sx:number, out_sy:number, out_depth:number} | // Input Layer
 **  {type:'conv', sx:number, filters:number, stride:number, pad:number, activation:string} | // Convolution Layer
 **  {type:'pool', sx:number, stride:number} | // Pooling Layer
 **  {type:'softmax', num_classes:number} | // Classifier Layers
 **  {type:'svm', num_classes:number| // Classifier Layers
 **  {type:'fc', num_neurons:number, activation:string} // Fully Connected Layer
 **
 ** typeof activation = 'relu'| 'maxout' | 'sigmoid' | 'tanh' ..
 **
 ** type trainer = 
 **  {method: 'sgd', learning_rate:number,  momentum: number, batch_size:number, l2_decay:number} |
 **  {method: 'adadelta', learning_rate:number,  eps: number, ro:number, batch_size:number, l2_decay:number} |
 **  {method: 'adam', learning_rate:number, eps: number, beta1: number, beta2: number, batch_size: number, l2_decay:number} |
 **  ..
 **
 ** text: text analysis (similarity checking)
 ** -----------------------------------------
 **   classify(model,string) -> {match:number [0..1],string:string }
 **   learn({algorithm:ML.TXT, data:string []]) -> model
 **   test({algorithm:ML.TXT,string:string}|model,string) -> number [0..1]
 **   similarity(string,string) -> number [0..1]
 ** 
 **
 ** simulated annealing
 ** -------------------
 **
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var _ = undefined;
var none = null;


var ICE = Require('plugins/ml/ice'); // ICE ID3/C45 eps
var DTI = Require('plugins/ml/dti');
var KNN = Require('plugins/ml/knn');
var KMN = Require('plugins/ml/kmeans');
var SVM = Require('plugins/ml/svm');
var MLP = Require('plugins/ml/mlp');
var ID3 = Require('plugins/ml/id3');
var C45 = Require('plugins/ml/C45');
var TXT = Require('plugins/ml/text');
var RF  = Require('plugins/ml/rf');
var RL  = Require('plugins/ml/rl');
var RT  = Require('plugins/ml/rt');
var STAT= Require('plugins/ml/stats');
var CNN = Require('plugins/ml/cnn');
var ANN = Require('plugins/ml/ann');
var PCA = Require('plugins/ml/pca');
var DBCLUST = Require('plugins/ml/dbclust');
var REG = Require('plugins/ml/reg');
var MATH    = Require('plugins/ml/math');
var PRE = Require('plugins/ml/pre');
var SA  = Require('plugins/ml/sa');

var HELP  = Require('plugins/ml/helpers');

var MAN  = FileEmbedded('plugins/ml/help.md','utf8');

var array2Object = PRE.array2Object,
    autoScale = PRE.autoScale,
    getOptions = HELP.getOptions,
    obj2Array = PRE.obj2Array,
    objSlice = PRE.objSlice,
    preprocess = PRE.preprocess,
    relax=PRE.relax,
    _scale = PRE.scale,
    split=PRE.split,
    toScale=PRE.toScale,
    unscale = PRE.unscale,
    updateOptions=HELP.updateOptions,
    wrap=PRE.wrap;
function scale (data, scales) {
  if (Utils.isMatrix(data)) {
    return data.map(function (row) {
      return _scale(row,scales)
    })
  } else if (Utils.isObject(data[0])) {
    return data.map(function (obj) {
      var objS = {}
      for(var key in obj) {
        objS[key]=_scale(obj[key],scales[key]||scales);
      }
      return objS
    })
  } return _scale(data,scales)
}
function scale0 (data,lower,upper) {
  if (Utils.isMatrix(data)) {
    return Object.keys(data[0]).map(function (attr) {
      var min,max;
      for(var i in data) {
        if (i==0) { min=max=data[i][attr] }
        else { 
          min=Math.min(min,data[i][attr]); 
          max=Math.max(max,data[i][attr]); 
        }
      }
      return toScale(min,max,lower,upper);
    })
  } else if (Utils.isObject(data[0])) {
    var scales=[]
    Object.keys(data[0]).map(function (attr) {
      var min,max;
      for(var i in data) {
        if (i==0) { min=max=data[i][attr] }
        else { 
          min=Math.min(min,data[i][attr]); 
          max=Math.max(max,data[i][attr]); 
        }
      }
      scales[attr]=toScale(min,max,lower,upper);
    })
    return scales;
  }
}
var current=none;
var Aios=none;

var options = {
  version: '1.29.1X'
}

// Some definitions
var ML = {
  // Algorithms
  ANN   : 'ann',    // neataptic NN 
  C45   : 'c45',
  CNN   : 'cnn',
  ICE   : 'ice',   // ICE ID3/C45 eps
  DT    : 'ice',   // ICE ID3/C45 eps
  DTI   : 'dti',
  ID3   : 'id3',
  KMN   : 'kmeans',
  KNN   : 'knn',
  KNN2  :'knn2',
  MLP   : 'mlp',
  REG   : 'reg',   // Function Rregression
  RF    : 'rf',    // Random Forest
  RL    : 'rl',    // Reinforcement Leerner
  RT    : 'rt',    // Regression Tree
  SLP   : 'slp',  // Synonym for MLP (but single layer)
  SVM   : 'svm',
  TXT   : 'txt',
  SA    : 'simuan', // Simulated Annelaing optimisation
  // Some Functions
  EUCL  : 'euclidean',
  PEAR  : 'pearson',
  
  // loaded on demand (wasm)
  XGBOOST : 'xgboost',
  
  // RL agents
  DPAgent   : 'DPAgent',
  TDAgent   : 'TDAgent',
  DQNAgent  : 'DQNAgent',
};


// API
var  ml = {
  // only RL
  action : function (model,arg) {
    switch (model.algorithm) {
      // Selects and returns next action from set of actions
      case ML.RL:
        switch (model.kind) {
          case ML.DQNAgent:
            // arg == state array
            return model.actions[RL.DQNAgent.code.act(model,arg)];   
            break;
          case ML.DPAgent:
            // arg == state (integer number)
            return model.actions[RL.DPAgent.code.act(model,arg)];   
            break;
          case ML.TDAgent:
            // arg == state (integer number)
            return model.actions[RL.TDAgent.code.act(model,arg)];   
            break;
        }
        break;   
    }
  },
  
  compact: function (model) {
    switch (model.algorithm) {
      case ML.DTI:
      default:
        return DTI.compactTree(model);
    }
  },
  
  depth: function (model) {
    switch (model.algorithm) {
      case ML.DTI:
        return DTI.depth(model);
      case ML.DT:
      case ML.ICE:
        return ICE.depth(model);
      case ML.C45:
        return C45.depth(model);
      case ML.ID3:
        return ID3.depth(model);
    }
  },
  
  
  evaluate: function (model,target,samples) {
    switch (model.algorithm) {
      case ML.DTI:
      default:
        return DTI.evaluate(model,target,samples);
    }
  },

  
  info: function (model) {
    switch (model.algorithm) {
      case ML.C45:
        return C45.info(model);
      case ML.DT:
      case ML.ICE:
        return ICE.info(model);
      case ML.ID3:
        return ID3.info(model);
    }
  },
  
  help : function (topic) {
    var i,j,Models = Object.keys(ML),
        models = Models.map(function(k) { return ML[k] });
    if ((i=Models.indexOf(topic))!=-1 || (j=models.indexOf(topic))!=-1) {
      if (j!=undefined && j!=-1) topic=Models[j]
      var result=[],start=MAN.indexOf('\n## '+topic),stop=MAN.indexOf('\n##',start+3);
      if (start!=-1 && stop!=-1) return MAN.slice(start+1,stop-1);
      else if (start!=-1) return MAN.slice(start+1);
    }
    return MAN
  },
  /** Learning: Create a learner instance and a classification model from training data (or an empty model that can be updated/trained later)
   *
   */
  learner: function (options) {
    var model,data,data2,x,y,features,featureTypes,test,target,more,
        result,cols,n_ins,n_outs,x,y,xscale,xoffset,xshift,yscale,yoffset,yshift,key,err,
        t0=Io.time();
    if (!options.algorithm || typeof options.algorithm != 'string') throw 'ML.learner: Invalid options (algorithm is missing)';
    switch (options.algorithm) {
    
      case ML.ANN:
        // Neataptic ANN Framework
        // typeof options = { x,y,features?,target?, 
        //                    equal?, iterations?:number, error?:number, rate?:number, clear?:boolean,  
        //                    layers:number [], architect?:string|string []}
        if (options.x && options.y) data = preprocess(options,'io',options);
        model={};
        model.algorithm=options.algorithm
        if (!options.layers && !options.network) throw 'ML.learn.ANN: Invalid options';
        if (options.architect) {
          // Special MLP
          if (options.architect instanceof Array) {
            // Different architectures in each layer
            if (options.architect.length != options.layers.length) throw "ML.trainer.ANN: layers & architect array must have same size";
            var layers = ANN.architect.Layers(options);
            model.network = ANN.architect.Construct(layers);
          } else {
            switch (options.architect) {
              case 'LSTM':
                more={}; // memoryToMemory, outputToMemory, outputToGates, inputToOutput, inputToDeep
                // model.network = new (Constructor(ANN.architect.LSTM,options.layers.concat(more)));
                model.network = ANN.architect.LSTM.apply(null,options.layers.concat(options));
                if (data) model.network.train(data,options);
                break;
              case 'GRU':
                more={}; // memoryToMemory, outputToMemory, outputToGates, inputToOutput, inputToDeep
                // model.network = new (Constructor(ANN.architect.LSTM,options.layers.concat(more)));
                model.network = ANN.architect.GRU.apply(null,options.layers);
                if (data) model.network.train(data,options);
                break;
            }
          }
        } else {
          // SLP/MLP
          if (options.network)
            model.network = new ANN.Network.fromJSON(options.network);
          else {
            model.network = ANN.architect.Network.apply(null,options.layers);
            model.network.configure({
              activation:options.activation,  // act. function
            });
          }
          if (data) model.network.train(data,options);
        }
        model.options=options;
        model.time=Io.time()-t0;
        return model;
        break;      
        

      case ML.CNN:
        // typeof options = {x:[][],y:[],..}
        model = CNN.create(options);
        model.algorithm=options.algorithm;
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.C45:
        // typeof options = {data: {}[], target:string, features: string []} |
        //                  {data: [][], target?:string, features?: string []} |
        //                  {x: number [][], y:[]} |
        //                  {data: {x,y}[] }
        var model = C45.create();
        if (options.x && options.y) {
          features=options.x[0].map(function (col,i) { return String(i) }); 
          featureTypes=options.x[0].map(function (col,i) { return 'number' });
          data=options.x.map(function (row,i) { row=row.slice(); row.push(options.y[i]); return row});
          target='y';
        } else if (options.data && Comp.obj.isMatrix(options.data)) {
          data=options.data;
          features=options.features||options.data[0].slice(0,-1).map(function (col,i) { return String(i) });
          featureTypes=options.data[0].slice(0,-1).map(function (col,i) { return typeof col == 'number'?'number':'category' });
          target=options.target||'y';
        } else if (options.data && Comp.obj.isObj(options.data[0]) && options.data[0].x && options.data[0].y!=undefined) {
          data=options.data.map(function (row) { return row.x.concat(row.y) });
          features=options.features||options.data[0].x.slice(0,-1).map(function (col,i) { return String(i) });
          featureTypes=options.data[0].x.slice(0,-1).map(function (col,i) { return typeof col == 'number'?'number':'category' });
          target=options.target||'y';
        } else if (options.data && Comp.obj.isArray(options.data) && Comp.obj.isObj(options.data[0]) && 
                   options.target && options.features) {
          rowNames=Comp.obj.isArray(options.target)?options.features.concat(options.target):
                                                    options.features.concat([options.target]);
          data=options.data.map(function (row) { return obj2Array(row,rowNames) })
          features=options.features;
          featureTypes=data[0].slice(0,-1).map(function (col,i) { return typeof col == 'number'?'number':'category' });
          target=options.target;
        } else throw 'ML.learn.C45: Invalid options';

        C45.train(model,{
          data: data,
          target: target,
          features: features,
          featureTypes: featureTypes
        });
        model.algorithm=options.algorithm
        model.time=Io.time()-t0;
        return model;
        break;


      case ML.DTI:
        // typeof options = {data: {}[], target:string, features: string [], eps;number, maxdepth} |
        //                   {x: number [][], y:[], eps;number, maxdepth}
        if (options.eps==_) options.eps=0;
        if (options.maxdepth==_) options.maxdepth=20;
        if (options.data && options.target && options.features)
          model = DTI.create(options);
        else if (options.x && options.y) {
          if (options.x.length != options.y.length) throw 'ML.learn.DTI: X and Y vector have different length';
          data=options.x.map(function (row,i) { row=row.slice(); row.push(options.y[i]); return row});
          features=Comp.array.init(data[0].length-1,function (i) { return String(i)});
          target=String(data[0].length-1);
          // console.log(data,features,target)
          model = DTI.create({
            data:data,
            features:features,
            target:target,
            eps:options.eps,
            maxdepth:options.maxdepth
          });
        } else throw 'ML.learn.DTI: Invalid options';
        model.algorithm=options.algorithm;
        model.time=Io.time()-t0;
        return model;


      case ML.ICE:
      case ML.DT:
        if (options.eps==_) options.eps=0;
        if (options.data && options.target && options.features)
          model = ICE.create(options);                  
        else if (options.x && options.y) {
          if (options.x.length != options.y.length) throw 'ML.learn.ICE: X and Y vector have different length';
          data=options.x.map(function (row,i) { row=row.slice(); row.push(options.y[i]); return row});
          features=Comp.array.init(data[0].length-1,function (i) { return String(i)});
          target=String(data[0].length-1);
          model = ICE.create({
            data:data,
            features:features,
            target:target,
            eps:options.eps,
          });
        } else throw 'ML.learn.ICE: Invalid options';
        model.algorithm=options.algorithm;
        model.eps=options.eps;
        model.time=Io.time()-t0;
        return model;
        break;      

      case ML.ID3:
        if (options.data && options.target && options.features)
          model = ID3.createTree(options.data,options.target,
                                 options.features);
        else throw 'ML.learn.ID3: Invalid options';
        model.algorithm=options.algorithm
        model.time=Io.time()-t0;
        return model;
        break;      
          
      case ML.KNN:
        // typeof @options = {data: {}[]|[][], distance?:function|string,k?:number}
        // typeof @options = {x:number [][], y:number [], 
        //                    distance?:function|string,k?:number}
        if (options.features && options.target) target=options.target,features = options.features;
        else {
          features = [];
          if (options.data) {
            for(key in options.data[0]) features.push(key);
            target = features.pop()
          } else if (options.x) {
            for(key in options.x[0]) features.push('x'+key);
            target='y';
          }
        }
        if (options.data && Comp.obj.isObj(options.data[0])) {
          x = options.data.map(function (row) { return obj2Array(row,features) });
          y = options.data.map(function (row) { return row[target] })
        } else if (options.data && Comp.obj.isMatrix(options.data)) {
          x = options.data,map(function (row) { return row.slice(0,row.length-1) });
          y = options.data,map(function (row) { return row[row.length-1] });
        } else if (options.x && options.y) {
          x = options.x;
          y = options.y;
        }
        model = KNN.create(
          x,
          y,
          {
            distance:options.distance,
            k:options.k
          });
        model.algorithm = options.algorithm
        model.features  = features
        model.target    = target
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.KNN2:
        // typeof @options = {data: {}[]|[][], distance?:function|string,k?:number}
        // typeof @options = {x:number [][], y:number [], 
        //                    distance?:function|string,k?:number}
        if (options.features && options.target) target=options.target,features = options.features;
        else {
          features = [];
          if (options.data) {
            for(key in options.data[0]) features.push(key);
            target = features.pop()
          } else if (options.x) {
            for(key in options.x[0]) features.push('x'+key);
            target='y';
          }
        }
        if (options.data && Comp.obj.isObj(options.data[0])) {
          x = options.data.map(function (row) { return obj2Array(row,features) });
          y = options.data.map(function (row) { return row[target] })
        } else if (options.data && Comp.obj.isMatrix(options.data)) {
          x = options.data,map(function (row) { return row.slice(0,row.length-1) });
          y = options.data,map(function (row) { return row[row.length-1] });
        } else if (options.x && options.y) {
          x = options.x;
          y = options.y;
        }
        model = KNN.create2(
          {
            x : x,
            y : y,
            distance:options.distance,
            k:options.k
          });
        model.algorithm=options.algorithm
        model.features = features
        model.target = target
        model.time=Io.time()-t0;
        return model;
        break;
        
      case ML.KMN:
        if (options.data && Comp.obj.isMatrix(options.data)) {
          data=options.data;
        } 
        model = KMN.cluster({
          data:data,
          k:options.k,
          distance:options.distance,
          epochs:options.epochs,
        })
        model.algorithm=options.algorithm
        model.data = data
        model.time=Io.time()-t0;
        return model;
        break;
                
      // Function Regression
      case ML.REG:
        /* typeof @options = {
          alpha : number is paramter change rate,
          lambda,
          iterations,
          dynamic?: boolean,
          cost? number,  
          error?:number,
          order : number,
          trace?: boolean.
        }
        */
        model={}
        options.alpha   = options.alpha||0.001;
        options.lambda  = options.lambda||0;
        options.iterations = options.iterations||1000;
        options.order = options.order||1;
        options.algorithm2 = options.algorithm2||'LinearRegression';
        model.regression = new REG[options.algorithm2]({
            alpha               : options.alpha,
            lambda              : options.lambda,
            iterations          : options.iterations,
            cost                : options.cost,
            error               : options.error,
            trace               : options.verbose||options.trace,
            dynamic             : options.dynamic,
          });
        model.algorithm=options.algorithm;
        model.options=options;
        return model;
        break;

      case ML.RF:
        var model={};
        // Single Binary RF (y={-1,1}) or Multi-RF (y:string is in labels)
        // typeof options = {data: {}[], target:string, features: string []} |
        //                  {data: [][], target?:string, features?: string []} |
        //                  {x: number [][], y: {-1,1} []} |
        //                  {data: {x,y}[] }
        //                  {data: {x,y}[], labels: string [] }
        if (!options.x || !options.y) throw 'ML.learn.RF: Invalid options';
        // data=preprocess(data,'xmy',{features:features,target:target})
        data={x:options.x,y:options.y}; // TODO 
        if (options.labels) {
          // multi-RF
          model.labels = options.labels;
          model.rfs = model.labels.map (function (label) { return RF() });
          model.rfs.forEach (function (rf,i) {
            var y = data.y.map(function (label) { return label==model.labels[i]?1:-1} );
            RF.code.train(rf,options.x,y,{
              numTrees:options.numTrees,
              maxDepth:options.maxDepth,
              numTries:options.numTries,
              type:options.weakType,
            });
          });
        } else {
          model = RF();
          features=options.x[0].map(function (col,i) { return String(i) }); 
          target='y';
        
          RF.code.train(model,
            options.x,
            options.y,
            {
              numTrees:options.numTrees,
              maxDepth:options.maxDepth,
              numTries:options.numTries,
              type:options.weakType,
            });    
        }
        model.algorithm=options.algorithm
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.RL:
        // Create learner instance
        model = {}
        if (!options.actions || !options.states) throw 'ML.learn.RL: Invalid options';
        options.environment=Io.checkOptions(options.environment,{});
        options.environment.getMaxNumActions=
          Io.checkOption(options.environment.getMaxNumActions,
                      function () { return options.actions.length })
        options.environment.getNumStates=
          Io.checkOption(options.environment.getNumStates,
                      function () { return options.states.length })
        var allowedActions=Io.checkOption(options.environment.allowedActions, function () { return options.actions });
        options.environment.allowedActions=
          // Ensure that allowedActions return number array!
          function (state) { 
            return allowedActions(state).map(function (a) {
              return options.actions.indexOf(a)
            })
          }  
        var nextState = options.environment.nextState;
        if (nextState) {
          options.environment.nextState = function (state,action) {
            return nextState(state,options.actions[action])
          }
        }
        switch (options.kind) {
          case ML.DQNAgent:                          
            model = RL.DQNAgent(
              options.environment,  
              {
                alpha:options.alpha,gamma:options.gamma,epsilon:options.epsilon,
                experience_add_every:options.experience_add_every,
                experience_size:options.experience_size,
                learning_steps_per_iteration:options.learning_steps_per_iteration,
                tderror_clamp:options.tderror_clamp,
                num_hidden_units:options.num_hidden_units,
                update:options.update,
               }
            )
            break;
          case ML.DPAgent:
            model = RL.DPAgent(
              options.environment,  
              {alpha:options.alpha,beta:options.beta,gamma:options.gamma,
               epsilon:options.epsilon,lambda:options.lambda}
            )
            break;
          case ML.TDAgent:
            model = RL.TDAgent(
              options.environment,  
              // specs
              {alpha:options.alpha,beta:options.beta,gamma:options.gamma,
               epsilon:options.epsilon,lambda:options.lambda,
               replacing_traces:options.replacing_traces,
               smooth_policy_update:options.smooth_policy_update,
               update:options.update,
               planN:options.planN}
            )
            break;
        }
        model.algorithm = options.algorithm;
        model.kind      = options.kind;
        if (options.actions)  model.actions   = options.actions;
        if (options.states)   model.states    = options.states;
        if (options.rewards)  model.rewards   = options.rewards;
        model.options   = options;
        return model;
        break;


      // typeof @options = { features : {name,categorical?:boolean,exclude?:boolean} [],
      //                     target   : {name,categorical?:boolean},
      //                     minPercentVarianceReduction?: number ?= 0.5,
      //                     minLeafNodeItems?: number ?= 10,
      //                     minSplitCandidateItems?: number ?= 30,
      //                     minAvgChildrenItems?: number ?= 2,
      //                     data?: {$attr:number|string} []
      case ML.RT:
        if (options.target && options.features) {
          if (!options.target.target) options.target.target=true;
          var columns = options.features.slice(),
              parameter = updateOptions({
                minPercentVarianceReduction:0.5,
                minLeafNodeItems:10,
                minSplitCandidateItems:30,
                minAvgChildrenItems:2,
              },options);
          model = RT();
          columns.push(options.target);
          model.defineConfig( columns, parameter );
          if (!options.featuresList) {
            options.featuresList=options.features.map(function (desc) { return desc.name });
          }
        } else throw 'ML.learn.RT: Invalid options';
        model.algorithm=options.algorithm;
        if (options.data) {
          // TODO
        }
        options.columns=columns;
        model.options=options;
        model.time=Io.time()-t0;
        return model;
        break;      

      case ML.SLP:
      case ML.MLP:
        // typeof options = {x?: number [][], 
        //                   y?: number number [][] | string [],
        //                   data?: number number [], features: number [], target: number [],
        //                   epochs?:number,
        //                   layers?:number [], 
        //                   hidden_layers?: number[],
        //                   verbose?:number,
        //                   labels?:string [], features?: string [], 
        //                   regression?,
        //                   normalize?, bipolar?, eps?:number | number [], verbose?}
        //
        // y and MLP(learn) require [[p1,p2,..],[p1,p2,..],..] with 0>=p>=1
        //                                                           p:label probability
        if (!options.x && !options.y && !options.data && options.layers){
          // create model only; layres must be defined!
          model = MLP({
            n_ins   : options.layers[0],
            n_outs  : options.layers[options.layers.length-1],
            hidden_layer_sizes  : options.layers.slice(1,options.layers.length-1),
            verbose : options.verbose||0,
          });
          model.algorithm = options.algorithm;
          return model;
        }
        if (options.data && options.features && options.target) {
          data=preprocess(options.data,'xmy',options);
          x=data.x;
          y=data.y;
        } else if (options.x && options.y) {
          x=options.x;
          y=options.y;
        } else if (options.data && options.data.x && options.data.y) {
          x=data.x;
          y=data.y;        
        } else throw 'ML.learn.MLP: invalid options';
        if (Comp.obj.isArray(options.x) && typeof options.x[0] == 'number') 
          x=wrap(options.x);   
        if (Comp.obj.isMatrix(options.y)) 
          y=options.y;
        else if (Comp.obj.isArray(options.y) && typeof options.y[0] == 'number') 
          y=wrap(options.y);        
        else if (Comp.obj.isArray(options.y) && options.labels) {
          y=options.y.map(function (l1) {
            return options.labels.map(function (l2) {
              return l1==l2?1:0;
            });
          });
        } else throw 'ML.learn.MLP: invalid options';
        if (options.normalize) {
          // normalize each variable independently!?
          var max=x[0].map(function (col) { return col}),
              min=x[0].map(function (col) { return col});
          x.forEach(function (row) { row.forEach(function (col,i) { 
            max[i]=Math.max(max[i],col);
            min[i]=Math.min(min[i],col) }) });
          xshift=options.bipolar?-1:0;
          xscale=max.map(function (x,i) { return (xshift?2:1)/((x-min[i])==0?1:x-min[i])});
          xoffset=min;
          x=x.map(function (row) { return row.map(function (col,i) { return xshift+(col-xoffset[i])*xscale[i] }) });
          if (options.regression) {
            // scale y, too, [0,1]
            max=y[0].map(function (col) { return col});
            min=y[0].map(function (col) { return col});
            y.forEach(function (row) { row.forEach(function (col,i) { 
              max[i]=Math.max(max[i],col);
              min[i]=Math.min(min[i],col) }) });
          
            yshift=options.bipolar?-1:0;
            yscale=max.map(function (x,i) { return (yshift?2:1)/((x-min[i])==0?1:x-min[i])});
            yoffset=min;
            y=y.map(function (row) { return row.map(function (col,i) { return yshift+(col-yoffset[i])*yscale[i] }) });
          }
        }
        model = MLP({
          input   : x,
          output  : y,
          n_ins   : x[0].length,
          n_outs  : y[0].length,
          hidden_layer_sizes:options.algorithm==ML.SLP?[]:(options.hidden_layers||[]),
          verbose:options.verbose||0,
        });
        model.algorithm=options.algorithm;
        model.labels=options.labels;
        model.features=options.features;
        model.xscale=options.normalize?{k:xscale,off:xoffset,shift:xshift}:undefined;
        model.yscale=options.normalize&&options.regression?{k:yscale,off:yoffset,shift:yshift}:undefined;
        model.nOutputs=y[0].length;
        
        MLP.code.train(model,{
          epochs : options.epochs||20000
        });
        model.time=Io.time()-t0;
        return model;
        break;


      // Simulated Annealing (final solution in model.state)
      case ML.SA:
        /* typeof @options = {
                coolingFactor: number =? 0.09,
		stabilizingFactor: number =? 1.005,
		freezingTemperature: number =? 0.001,
		initialTemperature: number =? 15,
		initialStabilizer: number =? 30,
                generateNewSolution : function () -> current:'a,
                generateNeighbor : function (current) -> current:'a,
                getCost : function (current:'a) -> cost:number
        }
        */
        var state = {
          final:null,
          current:null,
        }
        model = SA.SimulatedAnnealing({
            coolingFactor       : options.coolingFactor||0.09,
            stabilizingFactor   : options.stabilizingFactor||1.005,
            freezingTemperature : options.freezingTemperature||0.001,
            initialTemperature  : options.initialTemperature||15,
            initialStabilizer   : options.initialStabilizer||30,
          },
          /* */ function generateNewSolution () {
            state.current=state.final=options.generateNewSolution();
            return options.getCost(state.current)
          },
          /* */    function generateNeighbor () {
            state.current=options.generateNeighbor(state.final);
            return options.getCost(state.current)
          },
          /*  */     function acceptNeighbor () {
            state.final=state.current;
          }
        );
        model.current = null;
        model.state = state;
        model.algorithm=options.algorithm;
        return model;
        break;

      case ML.SVM:
        // typeof options = {x: number [][], 
        //                   y: ({-1,1}|string) [],
        //                   labels?:string|number [],
        //                   threshold?:number|false,
        //                   C?:numer,tol?:number,max_passes?:number,alpha_tol?:number,kernel?:{}}
        
        // If classes then multi-SVM (one for each class to be separated)!
        if (!options.labels) {
          model = SVM({
            x:options.x,
            y:options.y,
            threshold:options.threshold,
          });
          model.algorithm=options.algorithm
          SVM.code.train(model,{
            C:options.C||1.0,
            tol:options.tol||1e-4,
            max_passes:options.max_passes||20,
            alpha_tol:options.alpha_tol||1e-5,
            kernel:options.kernel
          });
        } else {
          model={};
          model.algorithm=options.algorithm;
          model._labels=options.labels;
          model.svms=options.labels.map(function (cl) {
            return SVM({
              x:options.x,
              y:options.y.map(function (y) { return y==cl?1:-1 }),
              threshold:options.threshold,
            });
          });
          
          model.svms.forEach(function (svm) {
            SVM.code.train(svm,{
              C:options.C||1.0,
              tol:options.tol||1e-4,
              max_passes:options.max_passes||20,
              alpha_tol:options.alpha_tol||1e-5,
              kernel:options.kernel
            });
          });
          // Create one SVM for each class
          // Transform y vector          
        }
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.TXT:
        // typeof options = {data: string []}
        model = TXT.create(options.data,{
        });
        model.algorithm=options.algorithm
        return model;
        break;
    }
  },

  // add gaussian (!!) absolute or relative noise (0,1] to numerical data to create synthetic data
  // v + [-noise,+noise] | v + [-noise*v,noise*v]
  noise: function (data,noise,uniform,relative) {
    var rnd = uniform?
      function () {
        return Math.random()*2-1  
      }:function () {
        return STAT.utils.gaussian(-1,1)
      };
    function noisy(v,noise) {
      if (!relative) return v+rnd()*noise;
      else return v+rnd()*noise*v;
    }
    if (Comp.obj.isMatrix(data)) {
      return data.map(function (row) {
        return row.map(function (v,i) {
          if (typeof noise == 'number')
            return noisy(v,noise);
          else return noise[i]?noisy(v,noise[i]):v;
        })
      })
    } else if (Comp.obj.isArray(data) && Comp.obj.isObject(data[0])) {
      return data.map(function (row) {
        var o={};
        if (row.input && row.output) 
          return { input:row.input.map(function (col,index) { 
                      if (typeof noise.input == 'number') return noisy(col,noise.input);
                      else if (noise.input!=undefined) return noise.input[index]?noisy(col,noise.input[index]):col;
                      else return col;
                   }),
                   output:row.output.map(function (col,index) { 
                      if (typeof noise.output == 'number') return noisy(col,noise.output);
                      else if (noise.output!=undefined) return noise.output[index]?noisy(col,noise.output[index]):col;          
                      else return col;
                   })
                 };
        for (var p in row) {
          if (typeof noise == 'number')
            o[p] = noisy(row[p],noise);
          else o[p] = noise[p]?noisy(row[p],noise[p]):row[p];
        }
        return o;
      })      
    } else if (Comp.obj.isArray(data)) {
        return data.map(function (v,i) {
          if (typeof noise == 'number')
            return noisy(v,noise);
          else return noise[i]?noisy(v,noise[i]):v;
        })    
    } else if (typeof data == 'number') {
      return noisy(data,noise);
    }
  },

  /** Classification (prediction): Apply sample data to learned model.
   *  Returns prediction result.
   *
   */ 
  predict: function (model,samples) {
    var x,y,solutions,result,data;
    switch (model.algorithm) {
    
      case ML.ANN:
        if (Comp.obj.isMatrix(samples)) 
          return samples.map(function (sample) { 
            x=sample;          
            if (model.options.xscale) 
              x=x.map(function (row) { return scale(row,model.options.xscale) });
            y=model.network.activate(x);
            if (model.options.yscale)
              y=unscale(y,model.options.yscale);
            if (model.options.labels) // categorical classifier
            return y.map(function (v,i) { return { value:model.options.labels[i], prob:v } });
            return y;
          });
        else {
          x=samples;          
          if (model.options.xscale) 
            x=x.map(function (row) { return scale(row,model.options.xscale) });
          y=model.network.activate(x);
          if (model.options.labels) // categorical classifier
            return y.map(function (v,i) { return { value:model.options.labels[i], prob:v } });
          else 
            return y
        }
      case ML.CNN:
        if (Comp.obj.isMatrix(samples))
          return samples.map(function (sample) {
            return CNN.predict(model,sample);
          });
        else
          return CNN.predict(model,samples);
        break;

      case ML.C45:
        // Sample row format: [x1,x2,..,xn]
        if (Comp.obj.isMatrix(samples)) {
          return samples.map(function (sample) {
            return C45.classify(model,sample);
          });
        } else if (Comp.obj.isArray(samples) && !Comp.obj.isObj(samples[0])) {
          return C45.classify(model,samples);
        } else if (Comp.obj.isArray(samples) &&  Comp.obj.isObj(samples[0])) {
          return samples.map(function (sample) {
            return C45.classify(model,sample); 
          });
        } else if (Comp.obj.isObj(samples)) {
          return C45.classify(model,samples);
        }
        break;

      case ML.DT:
      case ML.ICE:
        if (Comp.obj.isMatrix(samples) ||
            Comp.obj.isArray(samples) && Comp.obj.isObj(samples[0])) 
          return samples.map(function (sample) { 
            return ICE.predict(model,sample) 
          });
        else 
          return ICE.predict(model,samples);

      case ML.DTI:
        if (Comp.obj.isMatrix(samples)) 
          return samples.map(function (sample) { 
            return DTI.predict(model,sample) 
          });
        else
          return DTI.predict(model,samples);

      case ML.ID3:
        if (Comp.obj.isArray(samples)) 
          return samples.map(function (sample) { 
            return ID3.predict(model,sample) 
          });
        else
          return ID3.predict(model,samples);

      case ML.KNN:
        if (Comp.obj.isMatrix(samples))
          return KNN.predict(model,samples);        
        else if (Comp.obj.isArray(samples) && Comp.obj.isObj(samples[0]))
          return KNN.predict(model,samples.map(function (sample) { 
            return obj2Array(sample,model.features)}));
        else if (Comp.obj.isObj(samples))
          return KNN.predict(model,obj2Array(samples,model.features));
        else
          return KNN.predict(model,samples);
        break;

      case ML.KNN2:
        if (Comp.obj.isMatrix(samples))
          return samples.map(function (sample) {
            return KNN.predict2(model,sample);
          });
        else if (Comp.obj.isArray(samples) && Comp.obj.isObj(samples[0]))
          return samples.map(function (sample) {
             return KNN.predict2(model,obj2Array(sample,model.features))
            })
        else if (Comp.obj.isObj(samples))
          return KNN.predict2(model,obj2Array(samples,model.features));
        else
          return KNN.predict2(model,samples);
        break;

      case ML.KMN:
        return model.clusters
        break;

      // Function Regression
      case ML.REG:
        // requires [x,x*x,x*x*x,..,y] [] data
        if (typeof samples == 'number') samples=[samples];
        if (model.options.order) {
          data=samples.map(function (xx) {
            if (typeof xx=='number') xx=[xx];
            var x=xx[0];
            for (var i=2;i<=model.options.order;i++)
              xx.push(Math.pow(x,i));
            return xx
          })
        }
          else data=samples;

        return model.regression.transform(data);
        break;

      case ML.RF:
        if (model.labels) {
          if (Comp.obj.isMatrix(samples)) {
            return samples.map(function (sample) {
              return model.rfs.map(function (rf) {
                return RF.code.predictOne(rf,sample);
              }).map(function (v,i) {
                return { value:model.labels[i], prob:v }
              })
            });
          } else if (Comp.obj.isArray(samples) && typeof samples[0] == 'number') {
            return model.rfs.map(function (rf) {
              return RF.code.predictOne(rf,samples);
            }).map(function (v,i) {
                return { value:model.labels[i], prob:v }
            })
          } // TODO
        } else {
          // Sample row format: [x1,x2,..,xn]
          if (Comp.obj.isMatrix(samples)) {
            return samples.map(function (sample) {
              return RF.code.predictOne(model,sample);
            });
          } else if (Comp.obj.isArray(samples) && typeof samples[0] == 'number') {
            return RF.predictOne(model,samples);
          } // TODO
        }
        // preprocess(samples,'m')
        break;
                
      case ML.RT:
        if (Comp.obj.isArray(samples)) {
          return samples.map(function (sample) { 
            if (!Comp.obj.isArray(sample))
              return model.predict(sample);
            else {
              // map to object
              data = array2Object(sample,model.options.featuresList);
              return model.predict(data);
            }
          });
        } else {
          if (!Comp.obj.isArray(samples))
            return model.predict(samples);
          else {
            // map to object
            data = array2Object(samples,model.options.featuresList);
            return model.predict(data);
          }
        }
        break;
        
      case ML.SVM:
        if (!model._labels) {
          // Single SVM 
          if (Comp.obj.isMatrix(samples))
            return samples.map(function (sample) {
              return SVM.code.predict(model,sample);
            });
          else
            return SVM.code.predict(model,samples);
        } else {
          // Multi SVM
          if (Comp.obj.isMatrix(samples))
            return samples.map(function (sample) {
              solutions=model.svms.map(function (svm,index) { 
                if (svm.threshold==false)
                  return SVM.code.predict(svm,sample)
                else
                  return SVM.code.predict(svm,sample); 
              });
              return solutions.map(function (v,i) { return { value:model._labels[i], prob:v } });
            });
          else {
            solutions=model.svms.map(function (svm,index) { 
                if (svm.threshold==false)
                  return SVM.code.predict(svm,samples)
                else
                  return SVM.code.predict(svm,samples)==1; 
            })
            return solutions.map(function (v,i) { return { value:model._labels[i], prob:v } });
          }
        }
        break;
        
      case ML.SLP:
      case ML.MLP:
        // returns always [y1,y2,..][] w/o label coding and even if |y|=1
        if (Comp.obj.isMatrix(samples)) {
          x=samples;          
          if (model.xscale) 
            x=x.map(function (row) { return scale(row,model.xscale) });
          result = model.labels?MLP.code.predict(model,x).map(function (r) {
            var o={};
            r.forEach(function (v,i) { o[model.labels[i]]=v });
            return o;
          }):/*relax*/(MLP.code.predict(model,x));
        } else if (Comp.obj.isArray(samples)) {
          x=samples;
          if (model.xscale) 
            x=scale(x,model.xscale);
          result = model.labels?MLP.code.predict(model,[x]).map(function (r) {
            var o={};
            r.forEach(function (v,i) { o[model.labels[i]]=v });
            return o;
          })[0]:/*relax*/(MLP.code.predict(model,[x])[0]);
        } else if (Comp.obj.isObj(samples) && model.features) {
          x=model.features.map(function (f) { return samples[f] });
          if (model.xscale) 
            x=scale(x,model.xscale);
          result = model.labels?MLP.code.predict(model,[x]).map(function (r) {
            var o={};
            r.forEach(function (v,i) { o[model.labels[i]]=v });
            return o;
          })[0]:/*relax*/(MLP.code.predict(model,[x])[0]); 
        }
        if (Comp.obj.isArray(result)) {
          return model.yscale?result.map(function (y) { return unscale(y,model.yscale) }):result;
        } else {
          // TODO??
        }
        break;
        
       case ML.TXT:
        // typeof options = {data: string []}
        if (Comp.obj.isArray(samples))
          return samples.map(function (sample) { return TXT.classify(model,sample) });
        else
          return TXT.classify(model,samples);
        break;

   }
  },

  preprocess:preprocess,

  print: function (model,indent,compact) {
    switch (model.algorithm) {
      case ML.DTI:
        return DTI.print(model,indent,compact);
      case ML.DT:
      case ML.ICE:
        return ICE.print(model,indent);
      case ML.C45:
        return C45.print(model,indent);
      case ML.ID3:
        return ID3.print(model,indent);
    }
  },
  
  // Only text module
  similarity : TXT.similarity,
  
  stats : STAT,
  
  // Check model consistency with training or test data (input: x/y data table!)
  test: function (model,samples,options) {
    var x,y,data,res,p=0.0,error;
    switch (model.algorithm) {
    
      case ML.ANN:
        if (Comp.obj.isArray(samples)) {
          data=preprocess(samples,'xy',model.options); // data.x/data.y
          result=ml.predict(model,data.x);
          if (!options)
            return result.map(function (row,i) {
              return {y0:data.y[i],y:row};
            }); 
          else if (options.error) {
            
            error=result.map(function (row,i) {
              return options.error(data.y[i],row);
            }); 
            if (options.finally) return options.finally(error);
            else return error;
          }
        } else {
          data={x:samples.input,y:samples.output };
        }
        break;
        
      case ML.C45:
        // Sample row format: [x1,x2,..,y]
        if (Comp.obj.isMatrix(samples)) {
          samples.forEach(function (sample) {
            x=sample.slice(0,sample.length-1);
            y=sample[sample.length-1];
            res= C45.classify(model,x);
            if (res==y) p += 1;
          });
          return p/samples.length;
        } else if (Comp.obj.isArray(samples)  && !Comp.obj.isObject(samples[0])) {
          x=samples.slice(0,samples.length-1);
          y=samples[samples.length-1];
          res = C45.classify(model,x);
          return res==y?1.0:0.0
        } else if (Comp.obj.isObj(samples) && model.features) {
        }
        break;

      case ML.ICE:
        data=preprocess(samples,'xy',{features:model.features,target:model.target});
        data.x.forEach(function (sample,index) {
          res= ML.classify(model,sample);
          if (res==data.y[index]) p += 1;
        });
        return p/data.x.length;
        break;
        
      case ML.TXT:
        var model = model.string?{ data : [model.string] }:model;
        if (Comp.obj.isArray(samples))
          return samples.map(function (sample) { 
            return TXT.classify(model,sample).match
          });
        else
          return TXT.classify(model,samples).match;
        break;

        
    }
  },
  

  /** Update an already learned or train a new model
   *
   */
  train: function (model,options,more) {
    var data,t0;
    // if (!options) return ml.learn(options); // backward comp.
    switch (model.algorithm||options.algorithm) {
    
      case ML.ANN:
        Object.assign(model.options,more||{})
        data = preprocess(options,'io',model.options);
        if (!data) throw "ML.train.ANN: invalid data (not convertable to io format)";
        t0=Io.time();
        result=model.network.train(data,model.options);
        model.time=Io.time()-t0;
        return result;
        break;
        
      case ML.CNN:
        // typeof @options = { x,y,.. }
        return CNN.train(model,options);
        break;

      case ML.DTI:
        // typeof @options = {data: number [][], target:string, features: string [], eps?:number, maxdepth?:number} |
        //                   {x: number [][], y:[], eps?:number, maxdepth?:number}
        t0=Io.time();
        if (options.eps==_) options.eps=0;
        if (options.maxdepth==_) options.maxdepth=20;
        if (options.data && options.target && options.features)
          model = DTI.update(model,options);
        else if (options.x && options.y) {
          if (options.x.length != options.y.length) throw 'ML.update.DTI: X and Y vector have different length';
          data=options.x.slice();
          data=data.map(function (row,i) {row.push(options.y[i]); return row});
          features=Comp.array.init(data[0].length-1,function (i) { return String(i)});
          target=String(data[0].length-1);
          // console.log(data,features,target)
          model = DTI.update(model,{
            data:data,
            features:features,
            target:target,
            eps:options.eps,
            maxdepth:options.maxdepth
          });
        } else throw 'ML.update.DTI: Invalid options';
          
        model.time=Io.time()-t0;
        model.algorithm=options.algorithm;
        return model;

      // Function Regression
      case ML.REG:
        // requires [x,x*x,x*x*x,..,y] [] data
        if (model.options.order) {
          data=options.map(function (xy) {
            var x=xy[0],y=xy.pop();
            for (var i=2;i<=model.options.order;i++)
              xy.push(Math.pow(x,i));
            xy.push(y);
            return xy
          })
        }
          else data=options;
        return model.regression.fit(data);
        break;
            
      case ML.RL:
        switch (model.kind) {
          case ML.DQNAgent:
            return RL.DQNAgent.code.learn(model,options);
            break;
          case ML.DPAgent:  
            return RL.DPAgent.code.learn(model,options);
            break;
          case ML.TDAgent:
            return RL.TDAgent.code.learn(model,options);
            break;
        }
        break;

      case ML.RT:
        data=options;
        // data must be [][] with exact column order features@target!
        // if {}[], convert
        if (data[0] && !Comp.obj.isArray(data[0])) {
          data = data = ml.preprocess(data,'m',{
            features  : model.options.columns.pluck('name') 
          }).data;
        } 
        // console.log(data)
        for(var i in data) model.ingest(data[i]);
        
        return model.learn();
        break;
        
      case ML.SLP:
      case ML.MLP:
        // typoeof options = { x:[][],y:[][],data: number [][],features: number [], target:number [], epochs:number }
        // TODO scale/normalize/convert
        t0=Io.time();
        if (options.x && options.y) {
          MLP.code.train(model,{
            x      : options.x,
            y      : options.y,
            epochs : options.epochs||20000
          });
        } else if (options.data && options.features && options.target) {
          data = preprocess(options.data,'xmy',options);
          MLP.code.train(model,{
            x      : data.x,
            y      : data.y,
            epochs : options.epochs||20000
          });
        } else if (options.data && options.data.x && options.data.y) {
          data = preprocess(options.data,'xmy',options);
          MLP.code.train(model,{
            x      : data.x,
            y      : data.y,
            epochs : options.epochs||20000
          });
        } else throw "ML.MLP.train: Invalid options";
        model.time=Io.time()-t0;
        return { time:model.time, error:model.error, crossEntropy:model.crossEntropy };
        break;
        
        
      case ML.SA:
        var more=true,n=1E6,i=0;
        t0=Io.time();
        if (typeof options == 'number') n=options;
        while (more && i<n) {
          more = model.Do();
          if (!more) break;
          i++;
        }
        model.time=Io.time()-t0;
        return {
          temperature : model.GetCurrentTemperature(),
          energy      : model.GetCurrentEnergy(),   // last cost
          final       : model.state.final,
          more        : more,
          steps       : i,
          time        : model.time,
        }
        break;
    }
  },
  // Returns an unified JSON-like representation of the core model, e.g., for graph drawing
  // Types: Node or graoh function structure, parametrised function, tables
  toGraph: function (model,options) {
    var j,nodes,connections,map;
    options=options||{};
    switch (model.algorithm||options.algorithm) {
      case ML.ANN:
        // nodes, connections, input, output
        var ir = model.network.toJSON();
        if (options.native) return ir;
        nodes = ir.nodes.map(function (node) {
          return {
            type    : node.type,
            index   : node.index,
            bias    : node.bias,
            eval    : ['SUM',node.squash],
            attributes : {
              layerid : node.layerid,
              groupid : node.groupid,
              mask    : node.mask,
            }
          }
        })
        //
        j = {
          type      : 'graph',
          attributes  : ['directed','ANN'],
          nodes       : nodes,
          connections : ir.connections, // TODO: unification
          parameter : {
            layers    : model.options.layers,
            algorithm : model.algorithm,
            functions : {
              SUM: 'function (node,connections) { return node.bias+connections.sum(function (c) { return c.from.y*c.weight })',
              LOGISTIC:'function (x) { return 1 / (1 + Math.exp(-x)) }',
            }
          }
        };   
        break;
      case ML.ID3:
        nodes=[];
        results=[];
        resultsMap=[];
        connections=[];
        map=[];
        function iter1(node) {
          if (node.type=='feature') {
            var index=nodes.length;
            var _node = {
              type  : 'feature',
              name  : node.name, 
              index : index
            }
            map[index]=node
            nodes.push(_node);
            node.vals.forEach(function (e) {
              iter1(e.child)
            })
          }
        }
        function iter2(node) {
          if (node.type=='feature') {
            node.vals.forEach(function (e) {
              iter2(e.child)
            })
          } else if (node.type=='result') {
            var index=nodes.length;
            if (results.indexOf(node.name)!=-1) return;
            var _node = {
              type  : 'result',
              name  : node.name,
              value : node.value, 
              index : index
            }
            map[index]=node;
            results.push(node.name);
            resultsMap.push(_node);
            nodes.push(_node);              
          }
        }
        function iter3(node) {
          if (node.type=='feature') {
            var from = map.indexOf(node);
            node.vals.forEach(function (e) {
              if (e.child.type=='feature') connections.push({
                from  : from,
                to    : map.indexOf(e.child),
                value : e.value
              }); else if (e.child.type=='result') connections.push({
                from  : from,
                to    : resultsMap[results.indexOf(e.child.name)].index,
                value : e.value
              })
            })
            node.vals.forEach(function (e) {
              iter3(e.child)
            })           
          } 
        }
        iter1(model)
        iter2(model)
        iter3(model)
        j = {
          type        : 'graph',
          attributes  : ['directed','DT'],
          nodes       : nodes,
          connections : connections,
        }
        break;
      case ML.MLP:
        map=[];
        nodes=[];
        connections=[];
        var input = model.sigmoidLayers[0].W;
        map[0]=[];
        input = input.map(function (v,i) {
          var index=nodes.length;
          var node = {
            type : 'input',
            eval : ['ID'],
            index : index,
            attributes : {
              layreid : 0,
            }
          };
          nodes.push(node);
          map[0].push(node);
          return node;
        });
        model.sigmoidLayers.forEach(function (layer,layerIndex) {
          map[layerIndex+1]=[];
          layer.b.forEach(function (b,bi) {
            var index=nodes.length;
            var node = {
              type : layerIndex==model.sigmoidLayers.length-1?'output':'hidden',
              bias : b,
              eval : ['SUM','SIGMOID'],
              index : index,
              attributes : {
                layreid : layerIndex+1
              }
            };
            nodes.push(node);
            map[layerIndex+1].push(node);
          });        
        });
        model.sigmoidLayers.forEach(function (layer,layerIndex) {  
          input = layer.b.map(function (b,bi) {
            layer.W.forEach(function (w,wi) {
              connections.push({
                from : input[wi].index,
                to   : map[layerIndex+1][bi].index,
                weight : w[bi]
              });
            })
            return map[layerIndex+1][bi]
          });        
        });
        j = {
          type        : 'graph',
          attributes  : ['directed','ANN'],
          nodes       : nodes,
          connections : connections,
          functions : {
            ID:'function (x) { return x }',
            SUM: 'function (node,connections) { return node.bias+connections.sum(function (c) { return c.from.y*c.weight })',
            SIGMOID:'function (x) { return 1 / (1 + Math.exp(-x)) }',
          }
        }
        break;
      case ML.RT:
        j=model.exportJSON();
        break;
    }  
    return j;
  },
  // Create a model JSON data object that can be saved and restored! Not supported by all algorithms!
  // !!! NEW unified JSON format: { algorith, network, options } // breaks old code!
  toJSON : function (model,options) {
    options=options||{};
    switch (model.algorithm||options.algorithm) {
      case ML.ANN:
        // nodes, connections, input, output
        return {
          algorithm : ML.ANN, 
          network   : model.network.toJSON(),
          options   : model.options,
        }
      case ML.CNN:
        return {
          algorithm : ML.CNN, 
          network   : model.network.toJSON(),
          options   : getOptions(model.options,['width','height','depth','layers','targets','normalize','trainer']),
        };
        break;
      case ML.MLP:
        return model; 
      default:
        // TODO
        return 'Not supported';
    }    
  },
  // restore a model from JSON
  fromJSON : function (model) {
    if (typeof model=='string') model=JSON.parse(model);
    switch (model.algorithm) {
      case ML.ANN:
        return ml.learner({
          algorithm : ML.ANN,
          network   : model.network
        })
      case ML.CNN:
        return ml.learner(Object.assign(model.options,{
          algorithm : ML.CNN,
          network   : model.network
        }))
        break;
      default:
        // TODO
        throw 'ML.fromJSON: Algorithm not supproted';
    }
  },
  
  utils : {
    scale:scale,
    toScale:toScale,
  },
  
  ML:ML,
};
  
ICE.ml=ml;
CNN.ml=ml;
ml.classify=ml.predict;
ml.update=ml.train;
ml.best=ml.stats.utils.best;
ml.learn=ml.learner;
// loaded on demand
ml.xgboost = null;

module.exports = {
  action:ml.action,
  best:STAT.utils.best,
  classify:ml.classify,
  column:ml.column,
  convert : function (data,format,options) {
    // simplified {}[] <-> [][] data table conversion
    options=options||{};
    if (Comp.obj.isObject(format)) options=format,format=undefined;
    if (!format) {
      if (Comp.obj.isArray(data) && !Comp.obj.isArray(data[0]) && Comp.obj.isObject(data[0])) format='m';
      if (Comp.obj.isArray(data) && Comp.obj.isArray(data[0])) format='r';
    }
    if (format.toLowerCase()=='record') format='r';
    if (format.toLowerCase()=='array') format='m';
    if (format.toLowerCase()=='matrix') format='m';
    var result = preprocess(data,format,options);
    if (result && result.data) return result.data;
    else return result;
  },
  compact:ml.compact,
  depth:ml.depth,
  entropy:STAT.entropy,
  entropyN:STAT.entropyN,
  entropyDep:STAT.entropyDep,
  evaluate:ml.evaluate,
  fromJSON:ml.fromJSON,
  help:ml.help,
  info:ml.info,
  learn:ml.learn,
  learner:ml.learner,
  noise:ml.noise,
  options:options,
  pca:PCA,
  predict:ml.predict,
  preprocess:preprocess,
  print:ml.print,
  scale:scale,
  scale0:scale0,
  split:split,
  statistics:STAT,
  test:ml.test,
  toScale:toScale,
  train:ml.train,
  toJSON:ml.toJSON,
  unique:ml.stats.unique,
  unscale:unscale,
  update:ml.update,
  ANN:ANN,
  CNN:CNN,
  // set logging function
  log:function (f) {
    MLP.code.log=f;
  },
  ML:ML,
  DBCLUST:DBCLUST,
  math:MATH,
  version : options.version
}

if (typeof window != 'undefined') console.log('ML '+options.version+' loaded.');

};
BundleModuleCode['plugins/ml/ice']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2014, Ankit Kuwadekar
 **    $MODIFIED:    (C) 2006-2018 bLAB by sbosse
 **    $VERSION:     1.3.2X
 **
 **    $INFO:
 **
 ** ICE: C45/ID3 Decision Tree Algorithm supporting feature variables with eps intervals
 **
 ** Portable model
 **
 ** New:
 **        typeof eps = number | [epsx1:number,epsx2:number,..]
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var that;
var _ = undefined;
var none = null;

/**
 * Map of valid tree node types
 * @constant
 * @static
 */
var NODE_TYPES = {
  RESULT: 'result',
  FEATURE: 'feature',
  FEATURE_VALUE: 'feature_value'
};

var NL ='\n'

/**
 * Creates a new tree
 */
function createTree(data, target, features, eps) {
  var ml = that.ml;

  var targets = ml.stats.unique(ml.stats.utils.column(data, target));
  if (targets.length == 1) {
    return {
      type: NODE_TYPES.RESULT,
      name: targets[0],
    };
  }

  if (features.length == 0) {
    var topTarget = ml.stats.mostCommon(targets);
    return {
      type: NODE_TYPES.RESULT,
      name: topTarget,
    };
  }

  
  var split = ml.stats.splitEps(data,features,target,targets,eps);
  var bestFeature = split.feature;
  var index = features.indexOf(bestFeature);
  var remainingFeatures = split.remainingFeatures;
  var remainingEps = 
    typeof eps == 'number'?eps:remainingFeatures.map(function (v) { return eps[features.indexOf(v)] });
  var possibleValues = split.possibleValues;

  var node = {
    type: NODE_TYPES.FEATURE,
    name: bestFeature,
    index: index,
    eps: that.ml.stats.utils.selectEps(eps,index)
  };

  node.vals = split.choices.map(function (c) {
    var child_node = {
      val : c.val,
      eps : that.ml.stats.utils.selectEps(eps,index),
      type: NODE_TYPES.FEATURE_VALUE
    };

    child_node.child = createTree(c.data, target, remainingFeatures, remainingEps);
    return child_node;
    
  })
  return node;
}


function depth(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return 1;
    case NODE_TYPES.FEATURE: 
      return 1+Comp.array.max(model.vals.map(function (val) {
        return depth(val);
      }));
    case NODE_TYPES.FEATURE_VALUE: 
      return 1+depth(model.child);   
  }
  return 0;
}

function info(model) {
  var vl = vars(model);
  return {
    depth:depth(model),
    nodes:vl.length,
    vars:vl.unique(),
  }
}

function predictEps(model,sample,prob,eps) {
  var root = model;
  if (!prob) prob=1;
  while (root.type !== NODE_TYPES.RESULT) {
    var attr = root.name;
    var sampleVal = sample[attr];
    // kNN approximation
    var childNode = null;
    root.vals.forEach(function(node) {
      var fit=Math.abs(node.val-sampleVal);
      if (!childNode || fit < childNode.fit) childNode={fit:fit,node:node};
    });
    if (childNode){
      // with fit quality propagation
      prob = prob * (1-Math.abs(childNode.fit/that.ml.stats.utils.selectEps(eps,root.index))/4) 
      root = childNode.node.child;
    } else {
      root = root.vals[0].child;
    }
  }
  return {value:root.name,prob:prob};
};


function printModel(model,indent) {
  var line='',sep;
  if (indent==undefined) indent=0;
  if (!model) return '';
  var sp = function () {var s=''; for(var i=0;i<indent;i++) s+=' '; return s};
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return sp()+'-> '+model.name+NL;
    case NODE_TYPES.FEATURE:
      line=sp()+'$'+model.name+'?'+NL;
      model.vals.forEach(function (v) {
        line += printModel(v,indent+2);
      }); 
      return line;
    case NODE_TYPES.FEATURE_VALUE: 
      line=sp()+'=['+(model.val-model.eps)+','+(model.val+model.eps)+']'+NL;
      return line+printModel(model.child,indent+2); 
  }
  return 'model?';
}

function vars(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return [];
    case NODE_TYPES.FEATURE: 
      return [model.name].concat(Comp.array.flatten(model.vals.map(vars)));
    case NODE_TYPES.FEATURE_VALUE: 
      return vars(model.child);   
  }
  return [];
}

that = module.exports = {
  create: function (options) {
    return createTree(options.data,
                      options.target,
                      options.features,
                      options.eps)
  },
  depth:depth,
  info:info,
  ml:{},
  predict:function (model,sample) {
    return predictEps(model,sample,1,model.eps)
  },
  print:printModel,
}
};
BundleModuleCode['plugins/ml/dti']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2018 bLAB
 **    $CREATED:     03-03-16 by sbosse.
 **    $VERSION:     1.4.2X
 **
 **    $INFO:
 **
 ** Interval Decision Tree Learner
 **
 ** Modified ID3-based Decision Tree Algorithm that wraps all data with 2-eps intervals and uses
 ** interval instead single value arithmetic for entropy calculation and feature selection.
 ** The classification bases on a nearest-neighbourhood look-up of best matching results.
 **
 ** Two different algorithms are supported:
 **
 **   1. Static (using learn), the DTI learner using attribute selection based on entropy.
 **      The training data must be available in advance.
 **   2. Dynamic (using update), the DTI learrner using attribute selection based on significance.
 **      The training data is applied sequentielly (stream learning) updating the model.
 **
 **   Though in principle the both algrotihms can be mixed (first static, then dynamic updating), 
 **   the resulting model will have poor classification quality. Either use static or only dynamic
 **   (stream) learning.
 **   
 ** Portable model
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var min = Comp.pervasives.min;
var max = Comp.pervasives.max;
var _ = undefined;
var none = null;

/**
 * Map of valid tree node types
 * @constant
 * @static
 */
var NODE_TYPES = {
  RESULT: 'result',
  FEATURE: 'feature',
  FEATURE_VALUE: 'feature_value'
};


function Result(key) {
  return {
    type:NODE_TYPES.RESULT,
    name:key
  }
}

function Feature(name,vals) {
  return {
    type:NODE_TYPES.FEATURE,
    name:name,
    vals:vals
  }
}

// A value can be a scalar or a range {a,b} object
function Value(val,child) {
  return {
    type:NODE_TYPES.FEATURE_VALUE,
    val:val,
    child:child
  }
}

/** Add a new training set with optional data set merging and value interval expansion.
 * 
 */
function add_training_set(data,set,merge) {
  if (merge) {
    // Merge a data set with an existing for a specific key; create value ranges
  } else
    data.push(set);  
} 


/**
 * Computes Log with base-2
 * @private
 */
function log2(n) {
  return Math.log(n) / Math.log(2);
}




function results(model) {
  var line='',sep;
  if (!model) return '';
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return model.name;
    case NODE_TYPES.FEATURE:
      sep='';
      line='';
      Comp.array.iter(model.vals,function (v) {
        line += sep+results(v);
        sep=',';
      }); 
      return line;
    case NODE_TYPES.FEATURE_VALUE: 
      return results(model.child);   
  }
  return 'result?';
}


/**
 * Finds element with highest occurrence in a list
 * @private
 */
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;

  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}

function addVal(v1,v2) {
  if (v1.a!=undefined) {
    if (v2.a!=undefined) return {a:v1.a+v2.a,b:v1.b+v2.b};
    else return {a:v1.a+v2,b:v2.b+v2};
  } else if (v2.a!=undefined) return {a:v2.a+v1,b:v2.b+v1};
  else return v1+v2;
}

function lowerBound(v) {
  if (v.a==undefined) return v; else return v.a;
}

function upperBound(v) {
  if (v.b==undefined) return v; else return v.b;
}

function equal(v1,v2) {
  return (v1==v2 ||
          (upperBound(v1) == upperBound(v2) &&
          (lowerBound(v1) == lowerBound(v2))))
}

function overlap(v1,v2) {
  return (upperBound(v1) >= lowerBound(v2) && upperBound(v1) <= upperBound(v2)) ||
         (upperBound(v2) >= lowerBound(v1) && upperBound(v2) <= upperBound(v1))
}

function containsVal(vl,v) {
  for (var i in vl) {
    var v2=vl[i];
    if (overlap(v,v2)) return true;
  }
  return false;
}

function centerVal(v) {
  if (v.a==undefined) return v; else return (v.a+v.b)/2;
}

function distanceVal (v1,v2) {
  return Math.abs(centerVal(v1)-centerVal(v2));
}

function Bounds(vl,v) {
  if (vl.length==0) return {a:v,b:v};
  else if (v==undefined) return {a:Min(vl),b:Max(vl)};
  else return {a:Min([Min(vl),v]),b:Max([Max(vl),v])};
}

function Min(vals) {
  var min=none;
  Comp.array.iter(vals, function (val) {
    if (min==none) min=(val.a==undefined?val:val.a);
    else min=val.a==undefined?(val<min?val:min):(val.a<min?val.a:min);
  });
  return min;
}

function Max(vals) {
  var max=none;
  Comp.array.iter(vals,function (val) {
    if (max==none) max=(val.b==undefined?val:val.b);
    else max=(val.b==undefined?(val>max?val:max):(val.b>max?val.a:max));
  });
  return max;
}

// Return interval of a value x with a<=x_center-eps, b>=x_center+eps
function epsVal(x,eps) {
  if (x.a == undefined) return {a:x-eps,b:x+eps};
  else if ((x.b-x.a) < 2*eps) return {a:centerVal(x)-eps,b:centerVal(x)+eps}; 
  else return x;
}
/** Filter out unique values that are spaced at least by eps
 *
 */
function uniqueEps(data,eps) {
  var results=[];
  Comp.array.iter(data,function (x) {
    var found;
    if (!results.length) results.push(x);
    else {
      Comp.array.iter(results,function (y,i) {
        if (found) return;
        found = Math.abs(centerVal(x)-centerVal(y))<eps;
        if (found) // create new overlapping value with +-eps extensions 
          results[i]={a:Min([x,y])-eps,b:Max([x,y])+eps}
      }); 
      if (!found) results.push(x);
    }
  });
  return results;
}

/** Compact tree, merge nodes and intervals.
 ** adjust=true: Adjust overlapping feature variable value intervals!!!
 */

function compactTree(model,adjust) {
  var i,j,vi,vj,_vals,merged;
  function target(model) {
    var line;
    switch (model.type) {
      case NODE_TYPES.RESULT: 
        return model.name;
      case NODE_TYPES.FEATURE:      
        line = model.name+'?'+target;
        Comp.array.iter(model.vals,function (v) {
          line += target(v);
        }); 
        return line;  
      case NODE_TYPES.FEATURE_VALUE: 
        line='='+(model.val.a==undefined?model.val:'['+model.val.a+','+model.val.b+']')+NL;
        return line+target(model.child); 
    }
  }
  if (!model) return model;
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return model;
      break;
    case NODE_TYPES.FEATURE:
      _vals=[];
      // 1. Merge
      for (i in model.vals) {
        vi=model.vals[i];
        assert((vi.type==NODE_TYPES.FEATURE_VALUE)||'vi.type==NODE_TYPES.FEATURE_VALUE');
        merged=false;
        loopj: for(j in _vals) {
          vj=_vals[j];
          if (target(vi.child)==target(vj.child)) {
            merged=true;
            vj.val={a:Min([vi.val,vj.val]),b:Max([vi.val,vj.val])}
            break loopj;
          }
        }
        if (!merged) {
          _vals.push(vi);
          vi.child=compactTree(vi.child);
        }
      }
      // 2. Adjust overlapping value intervals!
      if (adjust) {
        // TODO: approach too simple!!!! 
        for (i in _vals) {
          i=Comp.pervasives.int_of_string(i);
          if (_vals[i+1]) {
            if (upperBound(_vals[i].val) > lowerBound(_vals[i+1].val)) {
              if (_vals[i].val.b) _vals[i].val.b=lowerBound(_vals[i+1].val)-1;
              else _vals[i+1].val.a=upperBound(_vals[i].val)+1;
            }
          }
        }
      }
      
      model.vals=_vals;
      return model;
      break;
    case NODE_TYPES.FEATURE_VALUE:
      return model;
      break;
  }
}



/** Creates a new tree from training data (data)
 *
 *  data is {x1:v1,x2:v2,..,y:vn} []
 *  target is classification key name
 *  features is ['x1','x2,',..]  w/o target variable
 *  eps is interval applied to all data values
 *
 */
function createTree(data, target, features, options) {
  var _newS,child_node,bounds;
      
  var targets = Comp.array.unique(Comp.array.pluck(data, target));
  // console.log(targets)  
  if (options.maxdepth==undefined) options.maxdepth=1;
  if (options.maxdepth==0) return Result('-');
  // console.log(data);
  // console.log(features);

  //Aios.aios.log('createTree:'+targets.length);
  //try {Aios.aios.CP();} catch (e) {throw 'DTI.createTree: '+options.maxdepth };
  if (Aios) Aios.aios.CP();
  if (targets.length == 1) return Result(targets[0]);

  if (features.length == 0) {
    var topTarget = mostCommon(targets);
    return Result(topTarget)
  }
  var bestFeatures = getBestFeatures(data, target, features, options.eps);
  var bestFeature = bestFeatures[0];

  var remainingFeatures = Comp.array.filtermap(bestFeatures,function (feat) {
    if (feat.name!=bestFeature.name) return feat.name;
    else return none;
  });
/*  
  var possibleValues = Comp.array.sort(Comp.array.pluck(data, bestFeature.name), function (x,y) {
    if (upperBound(x) < lowerBound(y)) return -1; else return 1; // increasing value order
  });
*/
  var possibleValues = getPossibleVals(data,bestFeature.name);
  
  var vals=[];
  
  //console.log(bestFeatures);
  //console.log(possibleValues);
  var partitions=partitionVals(possibleValues,options.eps);
  // Aios.aios.log(partitions);
  //console.log(bestFeatures);
  //console.log(possibleValues);
  if (partitions.length==1) {
    // no further 2*eps separation possible, find best feature by largest distance
    // resort best feature list with respect to value deviation
    bestFeatures.sort(function (ef1,ef2) {
      if (ef1.d > ef2.d) return -1; else return 1;
    });
    bestFeature = bestFeatures[0];
    possibleValues = getPossibleVals(data,bestFeature.name);
    Comp.array.iter(mergeVals(possibleValues),function (val,i) {

      _newS = data.filter(function(x) {
        // console.log(x[bestFeature.name],val,overlap(val,x[bestFeature.name]))
        
        return overlap(val,x[bestFeature.name]);
      });
      child_node = Value(val);
      options.maxdepth--;
      child_node.child = createTree(_newS, target, remainingFeatures, options);
      //console.log(_newS);
      vals.push(child_node);
    })    
    
  } else Comp.array.iter(partitions,function (partition,i) {
    
    _newS = data.filter(function(x) {
      // console.log(x[bestFeature.name],v,overlap(x[bestFeature.name],v))
      return containsVal(partition,x[bestFeature.name]);
    });
    bounds = Bounds(partition);
    child_node = Value(options.eps==0?{a:bounds.a,b:bounds.b}:{a:bounds.a-options.eps,b:bounds.b+options.eps});
      options.maxdepth--;
    child_node.child = createTree(_newS, target, remainingFeatures, options);
    //console.log(_newS);
    vals.push(child_node);
  });
  
  return Feature(bestFeature.name,vals);
}

/** Return the depth of the tree
 *
 */
function depth(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return 0;
    case NODE_TYPES.FEATURE: 
      return 1+Comp.array.max(model.vals,function (val) {
        return depth(val);
      });
    case NODE_TYPES.FEATURE_VALUE: 
      return depth(model.child);   
  }
  return 0;
}

/** Computes entropy of a list with 2-epsilon intervals
 *
 */

function entropyEps(vals,eps) {
  // TODO: overlapping value intervals
  var uniqueVals = Comp.array.unique(vals);
  var probs = uniqueVals.map(function(x) {
    return probEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(function(a, b) {
    return a + b
  }, 0);
}

function entropyEps2(vals,eps) {
  // TODO: overlapping value intervals
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probEps2(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(function(a, b) {
    return a + b
  }, 0);
}


function getBestFeatures(data,target,features,eps) {
  var bestfeatures=[];
  function deviation(vals) {
    var n = vals.length;
    var mu=Comp.array.sum(vals,function (val) {
      return (lowerBound(val)+upperBound(val))/2;
    })/n;
    var dev=Comp.array.sum(vals,function (val) {
      return Math.pow(((lowerBound(val)+upperBound(val))/2)-mu,2);
    })/n;
    return dev;
  }
  for (var feature in features) {
    if (features[feature]==undefined) throw 'DTI.getBestFeatures: invalid feature vector';
    var vals=Comp.array.pluck(data, features[feature]).map(function (val) {return val==undefined?0:val});
    var e = entropyEps(vals,eps);
    var d = deviation(vals);
    var min = Min(vals);
    var max = Max(vals);
    bestfeatures.push({e:e,d:d,range:{a:min,b:max},name:features[feature]});
  }
  bestfeatures.sort(function (ef1,ef2) {
    if (ef1.e > ef2.e) return -1; else return 1;
  });
  return bestfeatures;
}

/** Find in one data set the most significant feature variable (i.e., with highest value)
 */
function getSignificantFeature(data,features) {
  var f,sig;
  for (f in features) {
    if (sig==undefined || sig.val < data[features[f]]) sig={name:features[f],val:data[features[f]]};
  }
  return sig;
}

function getPossibleVals(data,feature) {
  return Comp.array.sort(Comp.array.pluck(data, feature), function (x,y) {
    if (upperBound(x) < lowerBound(y)) return -1; else return 1; // increasing value order
  });
}

/** Merge values and intervals
 */
function mergeVals(vals) {
  var _vals,
      merged,i,j;
  for (i in vals) {
    var vi = vals[i];
    if (!_vals) _vals=[vi];
    else {
      // Find overlapping values and merge
      merged=false;
      loopj: for (j in _vals) {
        var vj = _vals[j];
        if (equal(vi,vj)) {
          merged=true;
          break loopj;          
        }
        else if (overlap(vi,vj)) {
          merged=true;
          _vals[j]={a:Min([vi,vj]),b:Max([vi,vj])};
          break loopj;
        }
      }
      if (!merged) _vals.push(vi);
    }
  }
  //Aios.aios.log(_vals);
  return _vals||[];
}

/**
 * Predicts class for sample
 */
function nearestVal(vals,sample,fun) {
  var best=none;
  for (var v in vals) {
    var d=fun?distanceVal(fun(vals[v]),sample):distanceVal(vals[v],sample);
    if (best==none) 
      best={v:vals[v],d:d};
    else if (best.d > d)
      best={v:vals[v],d:d};    
  }
  if (best) return best.v;
  else return none;
}


/** Parttition an ordered set of values
 *  Each partition of values has at least 2*eps distance to the next partition.
 *
 */
function partitionVals(vals,eps) {
  var last=none;
  var partitions=[];
  var partition=[];
  for(var i in vals) {
    var val0=vals[i];
    var val1=vals[i-1];

    if (val1==undefined) partition.push(val0);
    else if ( upperBound(val0) < upperBound(addVal(val1,2*eps))) partition.push(val0);    
    else {
      partitions.push(partition);
      partition=[val0];
    }
  }
  if (partition.length>0) partitions.push(partition);
  return partitions;
}

/** Make a predicition with sample data
 *
 */
function predict(model,sample) {
  var root = model;
  while (root && root.type !== NODE_TYPES.RESULT) {
    var attr = root.name;
    var sampleVal = sample[attr];
    var childNode = nearestVal(root.vals,sampleVal,function (node) {
      return node.val;
    });

    if (childNode){
      root = childNode.child;
    } else {
      root = none;
    }
  }
  if (root) return root.name||root.val;
  else return none;
};

/** Print the tree
 *
 */
function print(model,indent, compact) {
  var line='',sep;
  if (compact) return results(model);
  if (indent==undefined) indent=0;
  if (!model) return '';
  var sp = function () {return Comp.string.create(indent);};
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return sp()+'-> '+model.name+NL;
    case NODE_TYPES.FEATURE:
      line=sp()+'$'+model.name+'?'+NL;
      Comp.array.iter(model.vals,function (v) {
        line += print(v,indent+2);
      }); 
      return line;
    case NODE_TYPES.FEATURE_VALUE: 
      line=sp()+'='+(model.val.a==undefined?model.val:'['+model.val.a+','+model.val.b+']')+NL;
      return line+print(model.child,indent+2); 
  }
  return 'model?';
}

/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probEps(value, list, eps) {
  // TODO: ranges
  var occurrences = Comp.array.filter(list, function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

function probEps2(value, list, eps) {
  // TODO: ranges
  var occurrences = Comp.array.filter(list, function(element) {
    return overlap(epsVal(value), epsVal(element));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

/** Incremental update of the model with new training set(s). Can be executed with an empty model.
 *  The current tree can be week for a new training set (new target).
 *  This can result in a classification of the new target with insignificant variables.
 *  Therefore, the last tree node must be exapnded with an additional strong (most significant)
 *  variable of the new data set (but it is still a heuristic for future updates). 
 */
function updateTree(model,data, target, features, options) {
  var eps = options.eps,
      maxdepth = options.maxdepth,
      verbose = options.verbose;
  var featuresINm={},   // All current tree feature variables and their value interval
      results=[],       // All current tree result leafs
      set,i,v,feature,remainingFeatures,exists,sigFeature;
  // 1. Analysis of existing model
 
  var analyze = function (model,feature) {
    var feature2;
    if (!model) return;
    switch (model.type) {
      case NODE_TYPES.RESULT:
        if (!Comp.array.contains(results,model.name)) results.push(model.name); 
        break;
      case NODE_TYPES.FEATURE:
        feature2={name:model.name};
        if (!featuresINm[model.name]) featuresINm[model.name]=feature2;
        Comp.array.iter(model.vals,function (v) { analyze(v,featuresINm[model.name]) });
        break;
      case NODE_TYPES.FEATURE_VALUE:
        if (!feature.val) feature.val={
          a:(model.val.a==undefined?model.val:model.val.a),
          b:(model.val.a==undefined?model.val:model.val.b)
        }; else {
          feature.val.a=min(feature.val.a,
                            (model.val.a==undefined?model.val:model.val.a));
          feature.val.b=max(feature.val.b,
                            (model.val.a==undefined?model.val:model.val.b));
        }                  
        analyze(model.child);
        break; 
    }   
  }

  
  analyze(model);
  // console.log(featuresINm);
  // console.log(results);
  
  exists=Comp.array.contains(results,data[target]);

  
  // 2a. Empty model, add first training set with two significant feature variable nodes
  function init(set) {
    set=data[i];
      sigFeature1=getSignificantFeature(set,features);
      remainingFeatures=Comp.array.filter(features,function (feat) {
        return sigFeature1.name!=feat;
      });
      sigFeature2=getSignificantFeature(set,remainingFeatures);

      featuresINm[sigFeature1.name]={name:sigFeature1.name,
                                    val:{a:sigFeature1.val-eps,b:sigFeature1.val+eps}};
      featuresINm[sigFeature2.name]={name:sigFeature2.name,
                                    val:{a:sigFeature2.val-eps,b:sigFeature2.val+eps}};
      results.push(set[target]);
      model=Feature(sigFeature1.name,[
                    Value({a:set[sigFeature1.name]-eps,b:set[sigFeature1.name]+eps},
                          Feature(sigFeature2.name,[
                                 Value({a:sigFeature2.val-eps,b:sigFeature2.val+eps},
                                       Result(set[target])) 
                                  ]))]);
      return model;
  }
  
  remainingFeatures=Comp.array.filter(features,function (feat) {
    return !featuresINm[feat];
  });
  
  // 2b. Update the tree with the new training set
  var update = function (model,set,feature) {
    var feature2,p;
    if (!model) return;
    switch (model.type) {
    
      case NODE_TYPES.RESULT:
        if (model.name != set[target] && verbose)
          console.log('Cannot insert new training set '+set[target]+' in tree. No more separating variables!');
        break;
        
      case NODE_TYPES.FEATURE:
        // console.log(set[target]+': '+ model.name+'='+set[model.name]);
        if (set[model.name]<(featuresINm[model.name].val.a-eps) ||
            set[model.name]>(featuresINm[model.name].val.b+eps)) {
          // add new training set; done
          // the current decision tree can  be week, thus add another strong variable node, too! 
          sigFeature=getSignificantFeature(set,remainingFeatures);
          featuresINm[sigFeature.name]={name:sigFeature.name,
                                        val:{a:sigFeature.val-eps,b:sigFeature.val+eps}};
          featuresINm[model.name].val.a=min(featuresINm[model.name].val.a,set[model.name]-eps);
          featuresINm[model.name].val.b=max(featuresINm[model.name].val.b,set[model.name]+eps);
          if (!Comp.array.contains(results,set[target])) results.push(set[target]);

          model.vals.push(Value({a:set[model.name]-eps,b:set[model.name]+eps},
                          Feature(sigFeature.name,[
                            Value({a:sigFeature.val-eps,b:sigFeature.val+eps},
                                  Result(set[target]))
                          ])));
          model.vals=Comp.array.sort(model.vals,function (v1,v2) {return (lowerBound(v1.val)<lowerBound(v2.val))?-1:1});  
        } else {
          // go deeper, but extend the interval of the best matching child node with new data variable
          Comp.array.iter_break(model.vals,function (fv) {
            // console.log(model.name,fv.val,overlap(fv.val,{a:set[model.name]-eps,b:set[model.name]+eps})) 
            if (overlap(fv.val,{a:set[model.name]-eps,b:set[model.name]+eps})) {
              fv.val.a=min(lowerBound(fv.val),set[model.name]-eps);
              fv.val.b=max(upperBound(fv.val),set[model.name]+eps);
              update(fv,set,model.name);
              return true;
            } else return false;
          });
        }
        break;
        
      case NODE_TYPES.FEATURE_VALUE:
        update(model.child,set);
        break; 
    }   
  }

  for (i in data) {
    set=data[i];
    if (model==undefined || model.type==undefined)
      model=init(set);
    else
      update(model,set);
  }
  return model;
}

module.exports =  {
  NODE_TYPES:NODE_TYPES,
  compactTree:compactTree,
  create:function (options) {
    // type options = {data number [][], target:string, features: string [], eps;number, maxdepth}
    return createTree(options.data,options.target,options.features,options)
  },
  depth:depth,
  entropy:entropyEps,
  evaluate:function evaluate(model,target,samples){},
  predict:predict,
  print:print,
  results:results,
  update:function (model,options) {
    // type options = {data number [][], target:string, features: string [], eps:number, maxdepth}
    return updateTree(model,options.data,options.target,options.features,options)
  },
  current:function (module) { current=module.current; Aios=module;}
};


};
BundleModuleCode['plugins/ml/knn']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2014, Ankit Kuwadekar
 **    $MODIFIED:    (C) 2006-2019 bLAB by sbosse
 **    $VERSION:     1.2.1
 **
 **    $INFO:
 **
 ** KNN: k-nearest-neighbour Algorithm
 ** A General purpose k-nearest neighbor classifier algorithm based on the 
 ** k-d tree Javascript library develop by Ubilabs.
 **
 ** Portable models (KNN/KNN2)
 **
 **    $ENDOFINFO
 */
var options = {
  version:'1.2.1'
}
var Comp = Require('com/compat');
var math = Require('plugins/ml/math');
var euclideanDistance = math.euclidean;

/*
 * Original code from:
 *
 * k-d Tree JavaScript - V 1.01
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */

function Node(obj, dimension, parent) {
    var N = {}
    N.obj = obj;
    N.left = null;
    N.right = null;
    N.parent = parent;
    N.dimension = dimension;
    return N;
}

/* KDTree
 *
 */

function KDTree(points, metric) {
    // if (!(this instanceof KDTree)) return new KDTree(points, metric);
    // If points is not an array, assume we're loading a pre-built tree
    var K ={}
    if (!Array.isArray(points)) {
        K.dimensions = points.dimensions;
        K.root = points;
        restoreParent(K.root);
    } else {
        K.dimensions = new Array(points[0].length);
        for (var i = 0; i < K.dimensions.length; i++) {
            K.dimensions[i] = i;
        }
        K.root = buildTree(points, 0, null, K.dimensions);
    }
    K.metric = metric;
    return K;
}

// Convert to a JSON serializable structure; this just requires removing
// the `parent` property
KDTree.code = {
  nearest : function(K, point, maxNodes, maxDistance) {
    var metric = K.metric;
    var dimensions = K.dimensions;
    var i;

    var bestNodes = BinaryHeap(
        function (e) {
            return -e[1];
        }
    );

    function nearestSearch(node) {
        var dimension   = dimensions[node.dimension];
        var ownDistance = metric(point, node.obj);
        var linearPoint = {};
        var bestChild,
            linearDistance,
            otherChild,
            i;
        function saveNode(node, distance) {
            BinaryHeap.code.push(bestNodes,[node, distance]);
            if (BinaryHeap.code.size(bestNodes) > maxNodes) {
                BinaryHeap.code.pop(bestNodes);
            }
        }

        for (i = 0; i < dimensions.length; i += 1) {
            if (i === node.dimension) {
                linearPoint[dimensions[i]] = point[dimensions[i]];
            } else {
                linearPoint[dimensions[i]] = node.obj[dimensions[i]];
            }
        }

        linearDistance = metric(linearPoint, node.obj);
        if (node.right === null && node.left === null) {
            if (BinaryHeap.code.size(bestNodes) < maxNodes || ownDistance < BinaryHeap.code.peek(bestNodes)[1]) {
                saveNode(node, ownDistance);
            }
            return;
        }

        if (node.right === null) {
            bestChild = node.left;
        } else if (node.left === null) {
            bestChild = node.right;
        } else {
            if (point[dimension] < node.obj[dimension]) {
                bestChild = node.left;
            } else {
                bestChild = node.right;
            }
        }

        nearestSearch(bestChild);

        if (BinaryHeap.code.size(bestNodes) < maxNodes || ownDistance < BinaryHeap.code.peek(bestNodes)[1]) {
            saveNode(node, ownDistance);
        }

        if (BinaryHeap.code.size(bestNodes) < maxNodes || Math.abs(linearDistance) < BinaryHeap.code.peek(bestNodes)[1]) {
            if (bestChild === node.left) {
                otherChild = node.right;
            } else {
                otherChild = node.left;
            }
            if (otherChild !== null) {
                nearestSearch(otherChild);
            }
        }
    }

    if (maxDistance) {
        for (i = 0; i < maxNodes; i += 1) {
            BinaryHeap.code.push(bestNodes,[null, maxDistance]);
        }
    }

    if (K.root) {
        nearestSearch(K.root);
    }

    var result = [];
    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
        if (bestNodes.content[i][0]) {
            result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);
        }
    }
    return result;
  }
}

function buildTree(points, depth, parent, dimensions) {
    var dim = depth % dimensions.length;

    if (points.length === 0) {
        return null;
    }
    if (points.length === 1) {
        return Node(points[0], dim, parent);
    }

    points.sort(function (a, b) { a[dimensions[dim]] - b[dimensions[dim]]});

    var median  = Math.floor(points.length / 2);
    var node    = Node(points[median], dim, parent);
    node.left   = buildTree(points.slice(0, median), depth + 1, node, dimensions);
    node.right  = buildTree(points.slice(median + 1), depth + 1, node, dimensions);

    return node;
}

function restoreParent(root) {
    if (root.left) {
        root.left.parent = root;
        restoreParent(root.left);
    }

    if (root.right) {
        root.right.parent = root;
        restoreParent(root.right);
    }
}
/** BinaryHeap
 *
 */
 
// Binary heap implementation from:
// http://eloquentjavascript.net/appendix2.html
function BinaryHeap (scoreFunction) {
  var B={}
    //if (!(this instanceof BinaryHeap)) return new BinaryHeap (scoreFunction);
  B.content = [];
  B.scoreFunction = scoreFunction;
  return B;
}


BinaryHeap.code = {
  push : function(B,element) {
    // Add the new element to the end of the array.
    B.content.push(element);
    // Allow it to bubble up.
    BinaryHeap.code.bubbleUp(B,B.content.length - 1);
  },
  pop : function(B) {
    // Store the first element so we can return it later.
    var result = B.content[0];
    // Get the element at the end of the array.
    var end = B.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it sink down.
    if (B.content.length > 0) {
        B.content[0] = end;
        BinaryHeap.code.sinkDown(B,0);
    }
    return result;
  },
  peek : function(B) {
    return B.content[0];
  },
  size : function(B) {
    return B.content.length;
  },
  bubbleUp : function(B,n) {
    // Fetch the element that has to be moved.
    var element = B.content[n];
    // When at 0, an element can not go up any further.
    while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = Math.floor((n + 1) / 2) - 1;
        var parent = B.content[parentN];
        // Swap the elements if the parent is greater.
        if (B.scoreFunction(element) < B.scoreFunction(parent)) {
            B.content[parentN] = element;
            B.content[n] = parent;
            // Update 'n' to continue at the new position.
            n = parentN;
        } else { // Found a parent that is less, no need to move it further.
            break;
        }
    }
  },
  sinkDown : function(B,n) {
    // Look up the target element and its score.
    var length = B.content.length;
    var element = B.content[n];
    var elemScore = B.scoreFunction(element);

    while (true) {
        // Compute the indices of the child elements.
        var child2N = (n + 1) * 2;
        var child1N = child2N - 1;
        // This is used to store the new position of the element,
        // if any.
        var swap = null;
        // If the first child exists (is inside the array)...
        if (child1N < length) {
            // Look it up and compute its score.
            var child1 = B.content[child1N];
            var child1Score = B.scoreFunction(child1);
            // If the score is less than our element's, we need to swap.
            if (child1Score < elemScore) {
                swap = child1N;
            }
        }
        // Do the same checks for the other child.
        if (child2N < length) {
            var child2 = B.content[child2N];
            var child2Score = B.scoreFunction(child2);
            if (child2Score < (swap === null ? elemScore : child1Score)) {
                swap = child2N;
            }
        }

        // If the element needs to be moved, swap it, and continue.
        if (swap !== null) {
            B.content[n] = B.content[swap];
            B.content[swap] = element;
            n = swap;
        } else {
            // Otherwise, we are done.
            break;
        }
    }
  }
}

/** KNN
 *
 */

/**
 ** typeof @dataset = number [] []
 ** typeof @labels  = number []
 ** typeof @options = { distance?:function, k?:number }
 */
function KNN(dataset, labels, options) {
    var L = {}
    if (!options) options={};
    if (dataset === true) {
        var model = labels;
        L.kdTree = KDTree(model.kdTree, options);
        L.k = model.k;
        L.classes = new Set(model.classes);
        L.isEuclidean = model.isEuclidean;
        return L;
    }
    var classes = new Set(labels);

    var distance = getDistanceFunction(options.distance),
        k = options.k||classes.size + 1;

    var points = new Array(dataset.length);
    for (var i = 0; i < points.length; ++i) {
        points[i] = dataset[i].slice();
    }

    for (i = 0; i < labels.length; ++i) {
        points[i].push(labels[i]);
    }

    L.kdTree = KDTree(points, distance);
    L.k = k;
    L.distance = distance;
    L.classes = classes;
    L.isEuclidean = distance === euclideanDistance;
    return L;
}


/**
 * Predicts the output given the matrix to predict.
 * @param {Array} dataset
 * @return {Array} predictions
 */
KNN.code = {
  predict : function(L,dataset) {
    if (Array.isArray(dataset)) {
        if (typeof dataset[0] === 'number') {
            return getSinglePrediction(L, dataset);
        } else if (Array.isArray(dataset[0]) && typeof dataset[0][0] === 'number') {
            var predictions = new Array(dataset.length);
            for (var i = 0; i < dataset.length; i++) {
                predictions[i] = getSinglePrediction(L, dataset[i]);
            }
            return predictions;
        }
    }
    throw new TypeError('dataset to predict must be an array or a matrix');
  }
}

function getSinglePrediction(knn, currentCase) {
    var nearestPoints = KDTree.code.nearest(knn.kdTree, currentCase, knn.k);
    var pointsPerClass = {};
    var predictedClassMin = null;
    var predictedClassMax = null;
    var predictedClassDistance = 0;
    var maxPoints = -1;
    var minDistance = 1E30;
    
    var lastElement = nearestPoints[0][0].length - 1;
    //for (var element of knn.classes) {
    //    pointsPerClass[element] = 0;
    //}
    forof(knn.classes,function (element) {
      pointsPerClass[element] = 0;
    });
    for (var i = 0; i < nearestPoints.length; ++i) {
        var currentClass = nearestPoints[i][0][lastElement];
        var currentPoints = ++pointsPerClass[currentClass];
        // Either use majority of points matching a class or the nearest points
        if (currentPoints > maxPoints) {
            predictedClassMax = currentClass;
            predictedClassDistance = predictedClassDistance+nearestPoints[i][1];
            maxPoints = currentPoints;
        }
        if (nearestPoints[i][1] < minDistance) {
            predictedClassMin = currentClass;
            minDistance = nearestPoints[i][1];
        }
    }
    predictedClassDistance /= maxPoints;
    return maxPoints>2?predictedClassMax:predictedClassMin;
}



/** Create a simple KNN (2)
 *
 * typeof @options = {x:number [] [],y: number []}
 *
 */
var KNN2 = function (options) {
  var model={}
  // if (!(this instanceof KNN2)) return new KNN2(options);
  model.x       = options.x;
  model.y       = options.y;
  model.target  = options.y;
  model.k       = options.k || 3
  model.distance = getDistanceFunction(options.distance);
  model.weightf =  getWeightedFunction(options.weightf);
  return model
}

/** Make a prediction
 *  
 */
KNN2.code = {
  predict : function (model,data) {
    var x = data;
    var k = model.k;
    var weightf = model.weightf;
    var distance = model.distance;
    var distanceList = [];
    var i;
    for(i=0; i<model.x.length; i++)
        distanceList.push([distance(x,model.x[i]),i]);
    distanceList.sort(function(a,b) {return a[0]-b[0];});
    var avg = 0.0;
    var totalWeight = 0, weight;
    for(i=0; i<k; i++) {
        var dist = distanceList[i][0];
        var idx = distanceList[i][1];
        weight = weightf(dist);
        avg += weight * model.y[idx];
        totalWeight += weight;
    }

    avg /= totalWeight;
    return avg;
  }
}

function getWeightedFunction(options) {
    if(typeof options === 'undefined') {
        return function(x) {
            var sigma = 10.0;
            return Math.exp(-1.*x*x/(2*sigma*sigma));
        }
    } else if(typeof options === 'function') {
        return options;
    } else if(options === 'gaussian') {
        return function(x) {
            var sigma = options.sigma;
            return Math.exp(-1.*x*x/(2*sigma*sigma));
        }
    } else if(options === 'none') {
        return function(dist) {
            return 1.0;
        }
    }
}

function getDistanceFunction(options) {
    if(typeof options === 'undefined') {
        return math.euclidean;
    } else if (typeof options === 'function') {
        return options;
    } else if (options === 'euclidean') {
        return math.euclidean;
    } else if (options === 'pearson') {
        return math.pearson;
    } else 
        throw new TypeError('distance opions invalid: '+options);;      
}

module.exports={
  create    : KNN,
  predict   : KNN.code.predict,
  create2   : KNN2,
  predict2  : KNN2.code.predict,
}
};
BundleModuleCode['plugins/ml/math']=function (module,exports){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
var m = module.exports;

m.randn = function() {
    // generate random guassian distribution number. (mean : 0, standard deviation : 1)
    var v1, v2, s;

    do {
        v1 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값
        v2 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값
        s = v1 * v1 + v2 * v2;
    } while (s >= 1 || s == 0);

    s = Math.sqrt( (-2 * Math.log(s)) / s );
    return v1 * s;
}

m.shape = function(mat) {
    var row = mat.length;
    var col = mat[0].length;
    return [row,col];
};

m.addVec = function(vec1, vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i<vec1.length;i++)
            result.push(vec1[i]+vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.minusVec = function(vec1,vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i<vec1.length;i++)
            result.push(vec1[i]-vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
};

m.addMatScalar = function(mat,scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i<row ; i++) {
        var rowVec = [];
        for(j=0 ; j<col ; j++) {
            rowVec.push(mat[i][j] + scalar);
        }
        result.push(rowVec);
    }
    return result;
}

m.addMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i<mat.length;i++)
            result.push(m.addVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.minusMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i<mat.length;i++)
            result.push(m.minusVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.addMat = function (mat1, mat2) {
    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i < mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j < mat1[i].length; j++) {
                result[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
};

m.minusMat = function(mat1, mat2) {
    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i < mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j < mat1[i].length; j++) {
                result[i][j] = mat1[i][j] - mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
}

m.transpose = function (mat) {
    var result = new Array(mat[0].length);
    for (var i = 0; i < mat[0].length; i++) {
        result[i] = new Array(mat.length);
        for (var j = 0; j < mat.length; j++) {
            result[i][j] = mat[j][i];
        }
    }
    return result;
};

m.dotVec = function (vec1, vec2) {
    if (vec1.length === vec2.length) {
        var result = 0;
        for (var i = 0; i < vec1.length; i++) {
            result += vec1[i] * vec2[i];
        }
        return result;
    } else {
        throw new Error("Vector mismatch");
    }
};

m.outerVec = function (vec1,vec2) {
    var mat1 = m.transpose([vec1]);
    var mat2 = [vec2];
    return m.mulMat(mat1,mat2);
};

m.mulVecScalar = function(vec,scalar) {
    var i, result = [];
    for(i=0;i<vec.length;i++)
        result.push(vec[i]*scalar);
    return result;
};

m.mulMatScalar = function(mat,scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i<row ; i++) {
        var rowVec = [];
        for(j=0 ; j<col ; j++) {
            rowVec.push(mat[i][j] * scalar);
        }
        result.push(rowVec);
    }
    return result;
};

m.mulMatElementWise = function(mat1, mat2) {
    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = mat1[i][j] * mat2[i][j]
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.mulMat = function (mat1, mat2) {
    if (mat1[0].length === mat2.length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat2[0].length);
        }


        var mat2_T = m.transpose(mat2);
        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = m.dotVec(mat1[i],mat2_T[j]);
            }
        }
        return result;
    } else {
        throw new Error("Array mismatch");
    }
};

m.sumVec = function(vec) {
    var sum = 0;
    var i = vec.length;
    while (i--) {
        sum += vec[i];
    }
    return sum;
};

m.sumMat = function(mat) {
    var sum = 0;
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++)
          sum += mat[i][j];
    }
    return sum;
};

m.sumMatAxis = function(mat,axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i<row; i++)
            result.push(m.sumVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.sumMatAxis(mat_T,1);
    }
};

m.meanVec = function(vec) {
    return 1. * m.sumVec(vec) / vec.length;
};

m.meanMat = function(mat) {
    var row = mat.length;
    var col = mat[0].length;
    return 1. * m.sumMat(mat) / (row * col);
};

m.meanMatAxis = function(mat,axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i<row; i++)
            result.push(m.meanVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.meanMatAxis(mat_T,1);
    }
};

m.squareVec = function(vec) {
    var squareVec = [];
    var i;
    for(i=0;i<vec.length;i++) {
        squareVec.push(vec[i]*vec[i]);
    }
    return squareVec;
};

m.squareMat = function(mat) {
    var squareMat = [];
    var i;
    for(i=0;i<mat.length;i++) {
        squareMat.push(m.squareVec(mat[i]));
    }
    return squareMat;
};

m.minVec = function(vec) {
    var min = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] < min)
            min = vec[i];
    }
    return min;
};

m.maxVec = function(vec) {
    var max = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] > max)
            max = vec[i];
    }
    return max;
}

m.minMat = function(mat) {
    var min = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++) {
            if(mat[i][j] < min)
                min = mat[i][j];
        }
    }
    return min;
};

m.maxMat = function(mat) {
    var max = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++) {
            if(mat[i][j] < max)
                max = mat[i][j];
        }
    }
    return max;
};

m.zeroVec = function(n) {
    var vec = [];
    while(vec.length < n)
        vec.push(0);
    return vec;
};

m.zeroMat = function(row,col) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.zeroVec(col));
    return mat;
};

m.oneVec = function(n) {
    var vec = [];
    while(vec.length < n)
        vec.push(1);
    return vec;
};

m.oneMat = function(row,col) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.oneVec(col));
    return mat;
};

m.randVec = function(n,lower,upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var vec = [];
    while(vec.length < n)
        vec.push(lower + (upper-lower) * Math.random());
    return vec;
};

m.randMat = function(row,col,lower,upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var mat = [];
    while(mat.length < row)
        mat.push(m.randVec(col,lower,upper));
    return mat;
};

m.randnVec = function(n,mean,sigma) {
    var vec = [];
    while(vec.length < n)
        vec.push(mean+sigma* m.randn());
    return vec;
};

m.randnMat = function(row,col,mean,sigma) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.randnVec(col,mean,sigma));
    return mat;
};

m.identity = function (n) {
    var result = new Array(n);

    for (var i = 0; i < n ; i++) {
        result[i] = new Array(n);
        for (var j = 0; j < n; j++) {
            result[i][j] = (i === j) ? 1 : 0;
        }
    }

    return result;
};

m.sigmoid = function(x) {
    var sigmoid = (1. / (1 + Math.exp(-x)))
    if(sigmoid ==1) {
     //   console.warn("Something Wrong!! Sigmoid Function returns 1. Probably javascript float precision problem?\nSlightly Controlled value to 1 - 1e-14")
        sigmoid = 0.99999999999999; // Javascript Float Precision Problem.. This is a limit of javascript.
    } else if(sigmoid ==0) {
      //  console.warn("Something Wrong!! Sigmoid Function returns 0. Probably javascript float precision problem?\nSlightly Controlled value to 1e-14")
        sigmoid = 1e-14;
    }
    return sigmoid; // sigmoid cannot be 0 or 1;;
};

m.dSigmoid = function(x){
    a = m.sigmoid(x);
    return a * (1. - a);
};

m.probToBinaryMat = function(mat) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i,j;
    var result = [];

    for(i=0;i<row;i++) {
        var rowVec = [];
        for(j=0;j<col;j++) {
            if(Math.random() < mat[i][j])
                rowVec.push(1);
            else
                rowVec.push(0);
        }
        result.push(rowVec);
    }
    return result;
};

m.activateVec = function(vec,activation) {
    var i, result = [];
    for(i=0;i<vec.length;i++)
        result.push(activation(vec[i]));
    return result;
};

m.activateMat = function(mat,activation) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i, j,result = [];
    for(i=0;i<row;i++) {
        var rowVec = [];
        for(j=0;j<col;j++)
            rowVec.push(activation(mat[i][j]));
        result.push(rowVec);
    }
    return result;
};

m.activateTwoVec = function(vec1, vec2,activation) {
    if (vec1.length === vec2.length) {
        var result = new Array(vec1.length);
        for (var i = 0; i < result.length; i++) {
            result[i] = activation(vec1[i],vec2[i]);
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.activateTwoMat = function(mat1, mat2,activation) {
    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = activation(mat1[i][j],mat2[i][j]);
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.fillVec = function(n,value) {
    var vec = [];
    while(vec.length < n)
        vec.push(value);
    return vec;
};

m.fillMat = function(row,col,value) {
    var mat = [];
    while(mat.length < row) {
        var rowVec = [];
        while(rowVec.length < col)
            rowVec.push(value);
        mat.push(rowVec);
    }
    return mat;
};

m.softmaxVec = function(vec) {
    var max = m.maxVec(vec);
    var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})
    return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
};

m.softmaxMat = function(mat) {
    var result=[], i;
    for(i=0 ; i<mat.length ; i++)
        result.push(m.softmaxVec(mat[i]));
    return result;
};

m.randInt = function(min,max) {
  var rand = Math.random() * (max - min + 0.9999) + min
  return Math.floor(rand);
}

m.normalizeVec = function(vec) {
    var i;
    var newVec = [],tot = 0;
    for(i=0; i<vec.length; i++)
        tot += vec[i];
    for(i=0; i<vec.length;i++)
        newVec.push(1.*vec[i]/tot);
    return newVec;
};

m.euclidean = function(x1,x2) {
    var i;
    var distance = 0;
    for(i=0 ; i<x1.length; i++) {
        var dx = x1[i] - x2[i];
        distance += dx * dx;
    }
    return Math.sqrt(distance);
};

m.pearson = function(x, y)
{
    var xy = [];
    var x2 = [];
    var y2 = [];

    for(var i=0; i<x.length; i++)
    {
        xy.push(x[i] * y[i]);
        x2.push(x[i] * x[i]);
        y2.push(y[i] * y[i]);
    }

    var sum_x = 0;
    var sum_y = 0;
    var sum_xy = 0;
    var sum_x2 = 0;
    var sum_y2 = 0;

    for(var i=0; i<x.length; i++)
    {
        sum_x += x[i];
        sum_y += y[i];
        sum_xy += xy[i];
        sum_x2 += x2[i];
        sum_y2 += y2[i];
    }

    var step1 = (x.length * sum_xy) - (sum_x * sum_y);
    var step2 = (x.length * sum_x2) - (sum_x * sum_x);
    var step3 = (x.length * sum_y2) - (sum_y * sum_y);
    var step4 = Math.sqrt(step2 * step3);
    var answer = step1 / step4;

    return answer;
};

m.getNormVec = function(vec) {
    var i;
    var sqsum = 0;
    for(i=0; i<vec.length; i++)
        sqsum += vec[i] * vec[i];
    return Math.sqrt(sqsum);
}

m.gaussian = function(x, sigma) {
    sigma = sigma || 10.0;
    return Math.exp(-1.*x*x/(2*sigma*sigma));
}

m.meanVecs = function(vecs) {
    var sum = m.zeroVec(vecs[0].length);
    var i;
    for(i=0; i<vecs.length; i++)
        sum = m.addVec(sum,vecs[i]);
    return m.activateVec(sum,function(x) {return 1.*x/vecs.length;});
};

m.covarianceVecs = function(vecs) {
    var mat = m.zeroMat(vecs[0].length,vecs[0].length);
    var meanVec = m.meanVecs(vecs);
    var i;
    for(i=0; i<vecs.length; i++) {
        var a = m.minusVec(vecs[i],meanVec);
        mat = m.addMat(mat, m.mulMat(m.transpose([a]),[a]));
    }
    return m.activateMat(mat,function(x) { return 1.*x/(vecs.length-1);});
};

m.shuffle = function(arr){
    var o = [];
    for(var i=0;i<arr.length;i++)
        o.push(arr[i]); // deep copy
    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
};

m.range = function(start, end, step) {
    var ret = [];
    if(typeof step === "undefined")
        step = 1;
    if(typeof end === "undefined") {
        end = start;
        start = 0;
    }
    for(var i=start;i<end;i+=step)
        ret.push(i);
    return ret;
};

m.vec2Mat = function (vec) {
  return vec.map(function (v) { return [v] });
}
// For CRBM
/*
m.phi = function(mat,vec,low,high) {
    var i;
    var result = [];
    for(i=0;i<mat.length;i++) {
        result.push(m.activateTwoVec(mat[i],vec,function(x,y){return low+(high-low)* m.sigmoid(x*y);}))
    }
    return result;
}
*/
};
BundleModuleCode['plugins/ml/kmeans']=function (module,exports){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var math = Require('plugins/ml/math')
var Kmeans = module.exports;

Kmeans.cluster = function(options) {
    var data = options['data'];
    var k = options['k'];
    var distance = getDistanceFunction(options['distance']);
    var epochs = options['epochs'];
    var init_using_data = options['init_using_data'];
    if(typeof init_using_data === "undefined");
        init_using_data = true;
    var means = getRandomMeans(data,k, init_using_data);

    var epoch, i, j, l;
    var clusters = [];
    for(i=0 ; i<k ; i++)
        clusters.push([]);

    for(epoch=0 ; epoch<epochs ; epoch++) {
        clusters = [];
        for(i=0 ; i<k ; i++)
            clusters.push([]);

        // Find which centroid is the closest for each row
        for(i=0 ; i<data.length ; i++) {
            var bestmatch = 0;
            for(j=0 ; j<k ; j++) {
                if(distance(means[j],data[i]) < distance(means[bestmatch],data[i])) bestmatch = j;
            }
            clusters[bestmatch].push(i);
        }

        // Move the centroids to the average of their members
        for(i=0 ; i<k ; i++) {
            var avgs = [];
            for(j=0 ; j<data[0].length ; j++)
                avgs.push(0.0);
            if(clusters[i].length > 0) {
                for(j=0 ; j<clusters[i].length ; j++) {
                    for(l=0 ; l<data[0].length ; l++) {
                        avgs[l] += data[clusters[i][j]][l];
                    }
                }
                for(j=0 ; j<data[0].length ; j++) {
                    avgs[j] /= clusters[i].length;
                }
                means[i] = avgs;
            }
        }
    }
    return {
        clusters : clusters,
        means : means
    };
}

var getRandomMeans = function(data,k, init_using_data) {
    var clusters = [];
    if(init_using_data) {
        var cluster_index = math.range(data.length);
        cluster_index = math.shuffle(cluster_index);
        for(i=0 ; i<k ; i++) {
            clusters.push(data[cluster_index[i]]);
        }
    } else {
        var i,j;
        var ranges = [];
        for(i=0 ; i<data[0].length ; i++) {
            var min = data[0][i] , max = data[0][i];
            for(j=0 ; j<data.length ; j++) {
                if(data[j][i] < min) min = data[j][i];
                if(data[j][i] > max) max = data[j][i];
            }
            ranges.push([min,max]);
        }
        for(i=0 ; i<k ; i++) {
            var cluster = [];
            for(j=0 ; j<data[0].length;j++) {
                cluster.push(Math.random() * (ranges[j][1] - ranges[j][0]) + ranges[j][0]);
            }
            clusters.push(cluster);
        }
    }
    return clusters;
}


function getDistanceFunction(options) {
    if(typeof options === 'undefined') {
        return math.euclidean;
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'euclidean') {
        return math.euclidean;
    } else if (options['type'] === 'pearson') {
        return math.pearson;
    }
}
};
BundleModuleCode['plugins/ml/svm']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     joonkukang, Stefan Bosse
 **    $INITIAL:     (C) 2014, joonkukang
 **    $MODIFIED:    (C) 2006-2018 bLAB by sbosse
 **    $VERSION:     1.1.3
 **
 **    $INFO:
 **
 ** Support Vector Machine Algrotihm
 **
 ** 1. References : http://cs229.stanford.edu/materials/smo.pdf . simplified smo algorithm 
 ** 2. https://github.com/karpathy/svmjs
 ** 
 ** Portable model
 **
 **    $ENDOFINFO
 */

var math = Require('plugins/ml/math');
var Io = Require('com/io');

/**
 * type options = {x: number [] [], y: number []}
 */
var SVM = function (options) {
    var L = {};
    L.x = options.x;
    L.y = options.y;
    return L
};

SVM.code = {
  train : function (L,options) {
    var self = L;
    var C = options.C || 1.0;
    var tol = options.tol || 1e-4;
    var maxPasses = options.max_passes || 20;
    var alphatol = options.alpha_tol || 1e-5;

    L.options={kernel:options.kernel,iterations:maxPasses,alpha_tol:alphatol, C:C, tol:tol };
    self.kernel = getKernel(options.kernel);
    self.alphas = math.zeroVec(self.x.length);
    self.b = 0;
    var passes = 0, i;
    var count=0;
    while(passes < maxPasses) {
        var numChangedAlphas = 0;

        for(i=0; i<self.x.length; i++) {

            var E_i = SVM.code.f(self,self.x[i]) - self.y[i];

            if((self.y[i] * E_i < -tol && self.alphas[i] < C) || (self.y[i] * E_i > tol && self.alphas[i] >0)) {

                // Randomly selects j (i != j)
                var j = math.randInt(0,self.x.length-1);
                if(i==j) j = (j+1) % self.x.length;

                var E_j = SVM.code.f(self,self.x[j]) - self.y[j];
                var alpha_i_old = self.alphas[i], alpha_j_old = self.alphas[j];

                // Compute L,H
                var L,H;
                if(self.y[i] !== self.y[j]) {
                    L = Math.max(0, self.alphas[j] - self.alphas[i]);
                    H = Math.min(C, C + self.alphas[j] - self.alphas[i]);
                } else {
                    L = Math.max(0, self.alphas[j] + self.alphas[i] - C);
                    H = Math.min(C, self.alphas[j] + self.alphas[i]);
                }

                if(L === H)
                    continue;

                // Compute ETA
                var ETA = 2 * self.kernel(self.x[i],self.x[j]) - self.kernel(self.x[i],self.x[i]) - self.kernel(self.x[j],self.x[j]);
                if(ETA >= 0)
                    continue;

                // Clip new value to alpha_j
                self.alphas[j] -= 1.*self.y[j] * (E_i - E_j) / ETA;
                if(self.alphas[j] > H)
                    self.alphas[j] = H;
                else if(self.alphas[j] < L)
                    self.alphas[j] = L;

                if(Math.abs(self.alphas[j] - alpha_j_old) < alphatol)
                    continue;

                // Clip new value to alpha_i
                self.alphas[i] += self.y[i] * self.y[j] * (alpha_j_old - self.alphas[j]);

                // update b
                var b1 = self.b - E_i - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[i])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[i],self.x[j]);
                var b2 = self.b - E_j - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[j])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[j],self.x[j]);

                if(0 < self.alphas[i] && self.alphas[i] < C)
                    self.b = b1;
                else if(0 < self.alphas[j] && self.alphas[j] < C)
                    self.b = b2;
                else
                    self.b = (b1+b2)/2.0;

                numChangedAlphas ++ ;
            } // end-if
        } // end-for
        if(numChangedAlphas == 0)
            passes++;
        else
            passes = 0;
    }
  },
  
  predict : function(L,x) {
    var self = L;
    this.kernel = getKernel(L.options.kernel); // update kernel
    if(SVM.code.f(L,x) >= 0)
        return 1;
    else
        return -1;
  },

  f : function(L,x) {
    var self = L;
    var f = 0, j;
    for(j=0; j<self.x.length; j++)
        f += self.alphas[j] * self.y[j] * self.kernel(self.x[j],x);
    f += self.b;
    return f;
  }
}

function getKernel (options) {
    if(typeof options === 'undefined') {
        return function(x,y) {
            var sigma = 1.0;
            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
        }
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'gaussian') {
        return function(x,y) {
            var sigma = options['sigma'];
            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
        }
    } else if (options['type'] === 'linear') {
        return function(x,y) {
            return math.dotVec(x,y);
        }
    } else if (options['type'] === 'polynomial') {
        return function(x,y) {
            var c = options['c'];
            var d = options['d'];
            return Math.pow(math.dotVec(x,y) + c, d);
        }
    } else if (options['type'] === 'rbf') {
        return function(v1, v2) {
          var s=0;
          var sigma = options.sigma||options.rbfsigma || 0.5;
          for(var q=0;q<v1.length;q++) { s += (v1[q] - v2[q])*(v1[q] - v2[q]); } 
          return Math.exp(-s/(2.0*sigma*sigma));
        }
    }
}


var SVM2 = function (options) {
    var L = {};
    L.data = options.x;
    L.labels = options.y;
    L.threshold=Io.checkOption(options.threshold,0);
    return L
};

SVM2.code = {

  // data is NxD array of floats. labels are 1 or -1.
  train: function(L, options) {
    var data = L.data,labels=L.labels;

    // parameters
    options = options || {};
    var C = options.C || 1.0; // C value. Decrease for more regularization
    var tol = options.tol || 1e-4; // numerical tolerance. Don't touch unless you're pro
    var alphatol = options.alphatol || options.alpha_tol || 1e-7; // non-support vectors for space and time efficiency are truncated. To guarantee correct result set this to 0 to do no truncating. If you want to increase efficiency, experiment with setting this little higher, up to maybe 1e-4 or so.
    var maxiter = options.maxiter || 10000; // max number of iterations
    var numpasses = options.numpasses || options.max_passes || 10; // how many passes over data with no change before we halt? Increase for more precision.

    // instantiate kernel according to options. kernel can be given as string or as a custom function
    var kernel = linearKernel;
    L.kernelType = "linear";
    L.options={kernel:options.kernel};
    if("kernel" in options) {
      if  (typeof options.kernel == 'object') {
        kernel = getKernel(options.kernel);
        L.kernelType=options.kernel.type;
        L.rbfSigma = options.kernel.sigma || options.kernel.rbfsigma;
      } else if (typeof options.kernel == 'function') {
        // assume kernel was specified as a function. Let's just use it
        L.kernelType = "custom";
        kernel = options.kernel;
      }
    }
    L.options.C=C;
    L.options.tol=tol;
    L.options.alphatol=alphatol;
    L.options.iterations=numpasses;
    
    // initializations
    L.kernel = kernel;
    L.N = data.length; var N = L.N;
    L.D = data[0].length; var D = L.D;
    L.alpha = zeros(N);
    L.b = 0.0;
    L.usew_ = false; // internal efficiency flag

    // Cache kernel computations to avoid expensive recomputation.
    // This could use too much memory if N is large.
    if (options.memoize) {
      L.kernelResults = new Array(N);
      for (var i=0;i<N;i++) {
        L.kernelResults[i] = new Array(N);
        for (var j=0;j<N;j++) {
          L.kernelResults[i][j] = kernel(data[i],data[j]);
        }
      }
    }

    // run SMO algorithm
    var iter = 0;
    var passes = 0;
    while(passes < numpasses && iter < maxiter) {

      var alphaChanged = 0;
      for(var i=0;i<N;i++) {

        var Ei= SVM2.code.marginOne(L, data[i]) - labels[i];
        if( (labels[i]*Ei < -tol && L.alpha[i] < C)
         || (labels[i]*Ei > tol && L.alpha[i] > 0) ){

          // alpha_i needs updating! Pick a j to update it with
          var j = i;
          while(j === i) j= randi(0, L.N);
          var Ej= SVM2.code.marginOne(L, data[j]) - labels[j];

          // calculate L and H bounds for j to ensure we're in [0 C]x[0 C] box
          ai= L.alpha[i];
          aj= L.alpha[j];
          var Lb = 0; var Hb = C;
          if(labels[i] === labels[j]) {
            Lb = Math.max(0, ai+aj-C);
            Hb = Math.min(C, ai+aj);
          } else {
            Lb = Math.max(0, aj-ai);
            Hb = Math.min(C, C+aj-ai);
          }

          if(Math.abs(Lb - Hb) < 1e-4) continue;

          var eta = 2*SVM2.code.kernelResult(L, i,j) - SVM2.code.kernelResult(L, i,i) - SVM2.code.kernelResult(L, j,j);
          if(eta >= 0) continue;

          // compute new alpha_j and clip it inside [0 C]x[0 C] box
          // then compute alpha_i based on it.
          var newaj = aj - labels[j]*(Ei-Ej) / eta;
          if(newaj>Hb) newaj = Hb;
          if(newaj<Lb) newaj = Lb;
          if(Math.abs(aj - newaj) < 1e-4) continue; 
          L.alpha[j] = newaj;
          var newai = ai + labels[i]*labels[j]*(aj - newaj);
          L.alpha[i] = newai;

          // update the bias term
          var b1 = L.b - Ei - labels[i]*(newai-ai)*SVM2.code.kernelResult(L, i,i)
                   - labels[j]*(newaj-aj)*SVM2.code.kernelResult(L, i,j);
          var b2 = L.b - Ej - labels[i]*(newai-ai)*SVM2.code.kernelResult(L, i,j)
                   - labels[j]*(newaj-aj)*SVM2.code.kernelResult(L, j,j);
          L.b = 0.5*(b1+b2);
          if(newai > 0 && newai < C) L.b= b1;
          if(newaj > 0 && newaj < C) L.b= b2;

          alphaChanged++;

        } // end alpha_i needed updating
      } // end for i=1..N

      iter++;
      //console.log("iter number %d, alphaChanged = %d", iter, alphaChanged);
      if(alphaChanged == 0) passes++;
      else passes= 0;

    } // end outer loop

    // if the user was using a linear kernel, lets also compute and store the
    // weights. This will speed up evaluations during testing time
    if(L.kernelType === "linear") {

      // compute weights and store them
      L.w = new Array(L.D);
      for(var j=0;j<L.D;j++) {
        var s= 0.0;
        for(var i=0;i<L.N;i++) {
          s+= L.alpha[i] * labels[i] * data[i][j];
        }
        L.w[j] = s;
        L.usew_ = true;
      }
    } else {

      // okay, we need to retain all the support vectors in the training data,
      // we can't just get away with computing the weights and throwing it out

      // But! We only need to store the support vectors for evaluation of testing
      // instances. So filter here based on L.alpha[i]. The training data
      // for which L.alpha[i] = 0 is irrelevant for future. 
      var newdata = [];
      var newlabels = [];
      var newalpha = [];
      for(var i=0;i<L.N;i++) {
        //console.log("alpha=%f", L.alpha[i]);
        if(L.alpha[i] > alphatol) {
          newdata.push(L.data[i]);
          newlabels.push(L.labels[i]);
          newalpha.push(L.alpha[i]);
        }
      }

      // store data and labels
      L.data = newdata;
      L.labels = newlabels;
      L.alpha = newalpha;
      L.N = L.data.length;
      // console.log("filtered training data from %d to %d support vectors.", data.length, L.data.length);
    }

    var trainstats = {};
    trainstats.iters= iter;
    trainstats.passes= passes;
    return trainstats;
  }, 

  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne: function(L,inst) {

    var f = L.b;
    // if the linear kernel was used and w was computed and stored,
    // (i.e. the svm has fully finished training)
    // the internal class variable usew_ will be set to true.
    if(L.usew_) {

      // we can speed this up a lot by using the computed weights
      // we computed these during train(). This is significantly faster
      // than the version below
      for(var j=0;j<L.D;j++) {
        f += inst[j] * L.w[j];
      }

    } else {

      for(var i=0;i<L.N;i++) {
        f += L.alpha[i] * L.labels[i] * L.kernel(inst, L.data[i]);
      }
    }
    return f;
  },

  predict: function(L,inst) { 
    L.kernel=getKernel(L.options.kernel); // update kernel
    var result = SVM2.code.marginOne(L,inst);
    if (L.threshold===false) return result;
    else return  result > L.threshold ? 1 : -1; 
  },

  // data is an NxD array. Returns array of margins.
  margins: function(L,data) {

    // go over support vectors and accumulate the prediction. 
    var N = data.length;
    var margins = new Array(N);
    for(var i=0;i<N;i++) {
      margins[i] = SVM2.code.marginOne(L,data[i]);
    }
    return margins;

  },

  kernelResult: function(L, i, j) {
    if (L.kernelResults) {
      return L.kernelResults[i][j];
    }
    return L.kernel(L.data[i], L.data[j]);
  },

  // data is NxD array. Returns array of 1 or -1, predictions
  predictN: function(L,data) {
    L.kernel=getKernel(L.options.kernel); // update kernel
    var margs = SVM2.code.margins(L, data);
    for(var i=0;i<margs.length;i++) {
      if (L.threshold!=false)
        margs[i] = margs[i] > L.threshold ? 1 : -1;
    }
    return margs;
  },

  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights: function(L) {

    // DEPRECATED
    var w= new Array(L.D);
    for(var j=0;j<L.D;j++) {
      var s= 0.0;
      for(var i=0;i<L.N;i++) {
        s+= L.alpha[i] * L.labels[i] * L.data[i][j];
      }
      w[j]= s;
    }
    return {w: w, b: L.b};
  },

  toJSON: function(L) {

    if(L.kernelType === "custom") {
      console.log("Can't save this SVM because it's using custom, unsupported kernel...");
      return {};
    }

    json = {}
    json.N = L.N;
    json.D = L.D;
    json.b = L.b;

    json.kernelType = L.kernelType;
    if(L.kernelType === "linear") { 
      // just back up the weights
      json.w = L.w; 
    }
    if(L.kernelType === "rbf") { 
      // we need to store the support vectors and the sigma
      json.rbfSigma = L.rbfSigma; 
      json.data = L.data;
      json.labels = L.labels;
      json.alpha = L.alpha;
    }

    return json;
  },

  fromJSON: function(L,json) {

    this.N = json.N;
    this.D = json.D;
    this.b = json.b;

    this.kernelType = json.kernelType;
    if(this.kernelType === "linear") { 

      // load the weights! 
      this.w = json.w; 
      this.usew_ = true; 
      this.kernel = linearKernel; // this shouldn't be necessary
    }
    else if(this.kernelType == "rbf") {

      // initialize the kernel
      this.rbfSigma = json.rbfSigma; 
      this.kernel = makeRbfKernel(this.rbfSigma);

      // load the support vectors
      this.data = json.data;
      this.labels = json.labels;
      this.alpha = json.alpha;
    } else {
      console.log("ERROR! unrecognized kernel type." + this.kernelType);
    }
  }
}

// Kernels
function makeRbfKernel(sigma) {
  return function(v1, v2) {
    var s=0;
    for(var q=0;q<v1.length;q++) { s += (v1[q] - v2[q])*(v1[q] - v2[q]); } 
    return Math.exp(-s/(2.0*sigma*sigma));
  }
}

function linearKernel(v1, v2) {
  var s=0; 
  for(var q=0;q<v1.length;q++) { s += v1[q] * v2[q]; } 
  return s;
}

// Misc utility functions
// generate random floating point number between a and b
function randf(a, b) {
  return Math.random()*(b-a)+a;
}

// generate random integer between a and b (b excluded)
function randi(a, b) {
   return Math.floor(Math.random()*(b-a)+a);
}

// create vector of zeros of length n
function zeros(n) {
  var arr= new Array(n);
  for(var i=0;i<n;i++) { arr[i]= 0; }
  return arr;
}

module.exports = SVM2
};
BundleModuleCode['plugins/ml/mlp']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     joonkukang, Stefan Bosse
 **    $INITIAL:     (C) 2014, joonkukang
 **    $MODIFIED:    (C) 2006-2021 bLAB by sbosse
 **    $VERSION:     1.3.5
 **
 **    $INFO:
 **
 ** Multilayer Perceptron Artificial Neural Network
 **
 ** References : http://cs229.stanford.edu/materials/smo.pdf . simplified smo algorithm 
 **
 ** Portable model
 **
 **    $ENDOFINFO
 */
/**
 */
var math = Require('plugins/ml/math');
var HiddenLayer = Require('plugins/ml/HiddenLayer');

var MLP = function (settings) {
    var L = {}
    var self = L;
    self.x = settings.input||settings.x;
    self.y = settings.output||settings.y;
    self.sigmoidLayers = [];
    self.nLayers = settings.hidden_layer_sizes.length;
    self.settings = {
        verbose : settings.verbose || 0, // 0 : nothing, 1 : info, 2: warn
        hidden_layers : settings.hidden_layer_sizes
    };
    var i;
    for(i=0 ; i<self.nLayers+1 ; i++) {
        var inputSize, layerInput;
        if(i == 0)
            inputSize = settings.n_ins;
        else
            inputSize = settings.hidden_layer_sizes[i-1];

        if(i == 0)
            layerInput = self.x||math.oneMat(1,inputSize);
        else
            layerInput = HiddenLayer.code.sampleHgivenV(self.sigmoidLayers[self.sigmoidLayers.length-1]);

        var sigmoidLayer;
        if(i == self.nLayers) {
            sigmoidLayer = HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings.n_outs,
                'activation' : math.sigmoid,
                'W' : (typeof settings.w_array === 'undefined')? undefined : settings.w_array[i],
                'b' : (typeof settings.b_array === 'undefined')? undefined : settings.b_array[i]
            });
        } else {
            sigmoidLayer = HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings.hidden_layer_sizes[i],
                'activation' : math.sigmoid,
                'W' : (typeof settings.w_array === 'undefined')? undefined : settings.w_array[i],
                'b' : (typeof settings.b_array === 'undefined')? undefined : settings.b_array[i]
            });
        }
        self.sigmoidLayers.push(sigmoidLayer);
    }
    return L
};

MLP.code = {
  train : function(L,settings,data) {
    var self = L;
    var epochs = 1000;
    if(typeof settings.epochs !== 'undefined')
        epochs = settings.epochs;
    if (typeof data != 'undefined') {
      self.x=data.x;
      self.y=data.y;
    }
    if (typeof settings.x != 'undefined') {
      self.x=settings.x;
      self.y=settings.y;
    }
    self.settings.iterations=epochs;
    
    // calculate mean square error
    function error(output,target) {
      var e=0;
      for(var i=0;i<output.length;i++) {
        for(var j=0;j<output[i].length;j++) {
          e+=Math.pow(output[i][j]-target[i][j],2);
        }
      }
      return e/target.length;
    }
    var epoch;
    var currentProgress = 1;
    for(epoch=0 ; epoch < epochs ; epoch++) {

        // Feed Forward
        var i;
        var layerInput = [];
        layerInput.push(self.x);
        for(i=0; i<self.nLayers+1 ; i++) {
            layerInput.push(HiddenLayer.code.output(self.sigmoidLayers[i],layerInput[i]));
        }
        var output = layerInput[self.nLayers+1];
        // Back Propagation
        var delta = new Array(self.nLayers + 1);
        delta[self.nLayers] = math.mulMatElementWise(math.minusMat(self.y, output),
            math.activateMat(HiddenLayer.code.linearOutput(self.sigmoidLayers[self.nLayers],layerInput[self.nLayers]), math.dSigmoid));
        if (L.settings.verbose > 2) MLP.code.log('MLP',epoch,'delta[output]: ',math.shape(delta[self.nLayers]),'=',delta[self.nLayers],error(output,self.y));
        /*
         self.nLayers = 3 (3 hidden layers)
         delta[3] : ouput layer
         delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer
         */
        for(i = self.nLayers - 1; i>=0 ; i--) {
            delta[i] = math.mulMatElementWise(HiddenLayer.code.backPropagate(self.sigmoidLayers[i+1],delta[i+1]),
                math.activateMat(HiddenLayer.code.linearOutput(self.sigmoidLayers[i],layerInput[i]), math.dSigmoid));
        }
        // Update Weight, Bias
        for(var i=0; i<self.nLayers+1 ; i++) {
            var deltaW = math.activateMat(math.mulMat(math.transpose(layerInput[i]),delta[i]),function(x){return 1. * x / self.x.length;})
            if (L.settings.verbose > 2) 
              MLP.code.log(i,math.shape(delta[i]),math.shape(deltaW),math.shape(layerInput[i]),math.shape(math.mulMat(math.transpose(layerInput[i]),delta[i])));
            var deltaB = math.meanMatAxis(delta[i],0);
            self.sigmoidLayers[i].W = math.addMat(self.sigmoidLayers[i].W,deltaW);
            self.sigmoidLayers[i].b = math.addVec(self.sigmoidLayers[i].b,deltaB);
        }

        if(self.settings.verbose > 0) {
            var progress = (1.*epoch/epochs)*100;
            if(progress > currentProgress) {
                MLP.code.log("MLP "+progress.toFixed(0)+"% Completed ("+epoch+" epochs). Mean Squared Error="+error(output,self.y));
                currentProgress+=8;
            }
        }
    }
    var ce = MLP.code.getReconstructionCrossEntropy(L);
    if(self.settings.verbose > 0)
        MLP.code.log("MLP Final Cross Entropy : ",ce);
    L.error=error(output,self.y);
    L.crossEntropy=ce;
    return {crossEntropy:ce, Error:L.error}
  },
  getReconstructionCrossEntropy : function(L) {
    var self = L;
    var reconstructedOutput = MLP.code.predict(L, self.x);
    var a = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return x*Math.log(Math.max(1E-6,y));
    });
    var b = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return (1-x)*Math.log(1-Math.min(0.9999999999,y));
    });

    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy
  },
  predict : function(L,x) {
    var self = L;
    var output = x;
    for(i=0; i<self.nLayers+1 ; i++) {
        output = HiddenLayer.code.output(self.sigmoidLayers[i],output);
    }
    return output;
  },
  set : function(L,property,value) {
    var self = L;
    self.settings[property] = value;
  },
  log : function () {
    console.log.bind(console).apply(this,arguments)
  },
  version : '1.3.5',
}
module.exports = MLP
};
BundleModuleCode['plugins/ml/HiddenLayer']=function (module,exports){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
var math = Require('plugins/ml/math');
var HiddenLayer = module.exports = function (settings) {
    var L = {}
    var self = L;
    self.input = settings['input'];

    if(typeof settings['W'] === 'undefined') {
        var a = 1. / settings['n_in'];
        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);
    }
    if(typeof settings['b'] === 'undefined')
        settings['b'] = math.zeroVec(settings['n_out']);
    if(typeof settings['activation'] === 'undefined')
        settings['activation'] = math.sigmoid;

    self.W = settings['W'];
    self.b = settings['b'];
    self.activation = settings['activation'];
    return L;
}

HiddenLayer.code = {
  output : function(L,input) {
    var self = L;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return math.activateMat(linearOutput,self.activation);
  },
  linearOutput : function(L,input) { // returns the value before activation.
    var self = L;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return linearOutput;
  },
  backPropagate : function (L,input) { // example+num * n_out matrix
    var self = L;
    if(typeof input === 'undefined')
        throw new Error("No BackPropagation Input.")

    var linearOutput = math.mulMat(input, math.transpose(self.W));
    return linearOutput;
  },
  sampleHgivenV : function(L,input) {
    var self = L;
    if(typeof input !== 'undefined')
        self.input = input;

    var hMean = HiddenLayer.code.output(self);
    var hSample = math.probToBinaryMat(hMean);
    return hSample;
  }
}
};
BundleModuleCode['plugins/ml/id3']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2014, Ankit Kuwadekar
 **    $MODIFIED:    (C) 2006-2018 bLAB by sbosse
 **    $VERSION:     1.3.1X
 **
 **    $INFO:
 **
 ** ID3 Decision Tree Algorithm supporting categorical values only
 ** Portable model
 **
 ** New
 **   predict with nn selection
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;


/**
 * Map of valid tree node types
 * @constant
 * @static
 */
var NODE_TYPES = {
  RESULT: 'result',
  FEATURE: 'feature',
  FEATURE_VALUE: 'feature_value'
};

function isEqual(a,b) { return a==b }

/**
 * Predicts class for sample
 */
function predict(model,sample) {
  var root = model;
  while (root.type !== NODE_TYPES.RESULT) {
    var attr = root.name;
    var sampleVal = sample[attr];
    var childNode = Comp.array.min(root.vals, function(node) {
      if (typeof node.value == 'number' && typeof sampleVal == 'number')  
        return Math.pow(node.value - sampleVal,2);
      else
        return node.value == sampleVal? 0:1;
    });
    if (childNode){
      root = childNode.child;
    } else {
      root = root.vals[0].child;
    }
  }
  return root.value;
};

/**
 * Evalutes prediction accuracy on samples
 */
function evaluate(model,target,samples) {
   var total = 0;
   var correct = 0;

   Comp.array.iter(samples, function(s) {
     total++;
     var pred = predict(model,s);
     var actual = s[target];
     if (isEqual(pred,actual)) {
       correct++;
     }
   });
   return correct / total;
};

/**
 * Creates a new tree
 */
function createTree(data, target, features) {
  var targets = Comp.array.unique(Comp.array.pluck(data, target));
  
  if (targets.length == 1) {
    return {
      type:   NODE_TYPES.RESULT,
      value:  targets[0],
      name:   targets[0],
      // alias: targets[0] + randomUUID()
    };
  }

  if (features.length == 0) {
    var topTarget = mostCommon(targets);
    return {
      type:   NODE_TYPES.RESULT,
      value:  topTarget,
      name:   topTarget,
      // alias: topTarget + randomUUID()
    };
  }

  var bestFeature = maxGain(data, target, features);
  var remainingFeatures = Comp.array.without(features, bestFeature);
  var possibleValues = Comp.array.unique(Comp.array.pluck(data, bestFeature));

  var node = {
    name: bestFeature,
    // alias: bestFeature + randomUUID()
  };

  node.type = NODE_TYPES.FEATURE;
  node.vals = Comp.array.map(possibleValues, function(v) {
    var _newS = data.filter(function(x) {
      return x[bestFeature] == v
    });

    var child_node = {
      value: v,
      // alias: v + randomUUID(),
      type: NODE_TYPES.FEATURE_VALUE
    };

    child_node.child = createTree(_newS, target, remainingFeatures);
    return child_node;
  });

  return node;
}

/**
 * Computes Max gain across features to determine best split
 * @private
 */
function maxGain(data, target, features) {
  var gains=[];
  var maxgain= Comp.array.max(features, function(element) {
    var g = gain(data, target, element);
    gains.push(element+':'+g);
    return g;
  });
  return maxgain;
}

/**
 * Computes entropy of a list
 * @private
 */
function entropy(vals) {
  var uniqueVals = Comp.array.unique(vals);
  var probs = uniqueVals.map(function(x) {
    return prob(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(function(a, b) {
    return a + b
  }, 0);
}

/**
 * Computes gain
 * @private
 */
function gain(data, target, feature) {
  var attrVals = Comp.array.unique(Comp.array.pluck(data, feature));
  var setEntropy = entropy(Comp.array.pluck(data, target));
  var setSize = data.length;

  var entropies = attrVals.map(function(n) {
    var subset = data.filter(function(x) {
      return x[feature] === n
    });

    return (subset.length / setSize) * entropy(Comp.array.pluck(subset, target));
  });

  // var entropyData = entropyV(Comp.array.pluck(data, feature),eps);
  // console.log('Feat '+feature+':'+entropyData);
  var sumOfEntropies = entropies.reduce(function(a, b) {
    return a + b
  }, 0);
  return setEntropy - sumOfEntropies;
}

/**
 * Computes probability of of a given value existing in a given list
 * @private
 */
function prob(value, list) {
  var occurrences = Comp.array.filter(list, function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

/**
 * Computes Log with base-2
 * @private
 */
function log2(n) {
  return Math.log(n) / Math.log(2);
}

/**
 * Finds element with highest occurrence in a list
 * @private
 */
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;

  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}

/**
 * Generates random UUID
 * @private
 */
function randomUUID() {
  return "_r" + Math.random().toString(32).slice(2);
}

function depth(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return 1;
    case NODE_TYPES.FEATURE: 
      return 1+Comp.array.max(model.vals.map(function (val) {
        return depth(val);
      }));
    case NODE_TYPES.FEATURE_VALUE: 
      return 1+depth(model.child);   
  }
  return 0;
}


function info(model) {
  var vl = vars(model);
  return {
    depth:depth(model),
    nodes:vl.length,
    vars:vl.unique(),
  }
}


function print(model,indent) {
  var NL = '\n',
      line='',sep,
      sp = function () {return Comp.string.create(indent);};
  if (indent==undefined) indent=0;
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return ' -> '+model.name;
    case NODE_TYPES.FEATURE:
      line=NL+sp()+'($'+model.name+'?'+NL;
      sep='';
      Comp.array.iter(model.vals,function (v) {
        line += sep+print(v,indent+2)+NL;
        sep='';
      }); 
      return line+sp()+')';
    case NODE_TYPES.FEATURE_VALUE: 
      return sp()+model.value+':'+print(model.child,indent+2);   
  }
  return 0;
}

function vars(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return [];
    case NODE_TYPES.FEATURE: 
      return [model.name].concat(Comp.array.flatten(model.vals.map(vars)));
    case NODE_TYPES.FEATURE_VALUE: 
      return vars(model.child);   
  }
  return [];
}

module.exports =  {
  NODE_TYPES:NODE_TYPES,
  createTree:createTree,
  depth:depth,
  entropy:entropy,
  evaluate:evaluate,
  info:info,
  predict:predict,
  print:print,
  current:function (module) { current=module.current; Aios=module;}
};

};
BundleModuleCode['plugins/ml/C45']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     ?, Stefan Bosse
 **    $INITIAL:     (C) ?
 **    $MODIFIED:    (C) 2006-2020 bLAB by sbosse
 **    $VERSION:     1.1.8X
 **
 **    $INFO:
 **
 ** C45 Decision Tree ML Algorithm
 **
 ** Portable model
 **
 **    $ENDOFINFO
 */
'use strict';
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;

var NODE_TYPES = {
  RESULT: 'result',
  FEATURE_NUMBER: 'feature_number',     // Number value node (cut split)
  FEATURE_VALUE: 'feature_value',       // Category value
  FEATURE_CATEGORY: 'feature_category'  // Symbolic variable node (split)
};

function unique(col) {
  var u = {}, a = [];
  for(var i = 0, l = col.length; i < l; ++i){
    if(u.hasOwnProperty(col[i])) {
      continue;
    }
    a.push(col[i]);
    u[col[i]] = 1;
  }
  return a;
}

function find(col, pred) {
  var value;
  col.forEach(function(item) {
    var result = pred(item);
    if (result) {
      value = item;
    }
  });
  return value;
}

function max(array, fn) {
  var max = -Infinity;
  var index;
  for (var i = 0; i < array.length; i++) {
    var result = fn(array[i]);
    if (result >= max) {
      max = result;
      index = i;
    }
  }
  return typeof index !== 'undefined' ? array[index] : max;
}

function sortBy(col, fn) {
 col = [].slice.call(col);
 return col.sort(fn);
}

var C45 = {
  create: function () {
    return {
      features : [],
      targets: [],
      model: null
    }
  },
  /**
   * train
   *
   * @param {object} options
   * @param {array} options.data - training data
   * @param {string} options.target - class label
   * @param {array} options.features - features names
   * @param {array} options.featureTypes - features type (ie 'category', 'number')
   */
  train: function(model,options) {
    var data = options.data,
        target = options.target,
        features = options.features,
        featureTypes = options.featureTypes;
    featureTypes.forEach(function(f) {
      if (['number','category'].indexOf(f) === -1) {
        throw new Error('C4.5: Unrecognized option!');
      }
    });

    var targets = unique(data.map(function(d) {
      return d[d.length-1];
    }));
    
    model.features = features;
    model.targets = targets;
    // model is the generated tree structure
    model.model = C45._c45(model, data, target, features, featureTypes, 0);
  },

  _c45: function(model, data, target, features, featureTypes, depth) {
    var targets = unique(data.map(function(d) {
      return d[d.length-1];
    }));

    if (!targets.length) {
      // console.log(data,features,featureTypes,depth);
      return {
        type: 'result',
        value: '?',
        name: '?'
      };
    }

    if (targets.length === 1) {
      return {
        type: 'result',
        value: targets[0],
        name: targets[0]
      };
    }

    if (!features.length) {
      var topTarget = C45.mostCommon(targets);
      return {
        type: 'result',
        value: topTarget,
        name: topTarget
      };
    }

    var bestFeatureData = C45.maxGain(model, data, target, features, featureTypes);
    var bestFeature = bestFeatureData.feature;

    var remainingFeatures = features.slice(0);
    remainingFeatures.splice(features.indexOf(bestFeature), 1);

    if (featureTypes[model.features.indexOf(bestFeature)] === 'category') {
      var possibleValues = unique(data.map(function(d) {
        return d[model.features.indexOf(bestFeature)];
      }));
      var node = {
        name: bestFeature,
        type: 'feature_category',
        values: possibleValues.map(function(v) {
          var newData = data.filter(function(x) {
            return x[model.features.indexOf(bestFeature)] === v;
          });
          var childNode = {
            name: v,
            type: 'feature_value',
            child: C45._c45(model, newData, target, remainingFeatures, featureTypes, depth+1)
          };
          return childNode;
        })
      };
    } else if (featureTypes[model.features.indexOf(bestFeature)] === 'number') {
      var possibleValues = unique(data.map(function(d) {
        return d[model.features.indexOf(bestFeature)];
      }));
      var node = {
        name: bestFeature,
        type: 'feature_number',
        cut: bestFeatureData.cut,
        values: []
      };

      var newDataRight = data.filter(function(x) {
        return parseFloat(x[model.features.indexOf(bestFeature)]) > bestFeatureData.cut;
      });
      var childNodeRight = {
        name: bestFeatureData.cut.toString(),
        type: 'feature_value',
        child: C45._c45(model, newDataRight, target, remainingFeatures, featureTypes, depth+1)
      };
      node.values.push(childNodeRight);

      var newDataLeft = data.filter(function(x) {
        return parseFloat(x[model.features.indexOf(bestFeature)]) <= bestFeatureData.cut;
      });
      var childNodeLeft = {
        name: bestFeatureData.cut.toString(),
        type: 'feature_value',
        child: C45._c45(model, newDataLeft, target, remainingFeatures, featureTypes, depth+1),
      };
      node.values.push(childNodeLeft);
    }
    return node;
  },


  classify: function (model,sample) {
    // root is feature (attribute) containing all sub values
    var childNode, featureName, sampleVal;
    var root = model.model;

    if (typeof root === 'undefined') {
      callback(new Error('model is undefined'));
    }

    while (root.type != NODE_TYPES.RESULT) {

      if (root.type == NODE_TYPES.FEATURE_NUMBER) {
        // feature number attribute
        featureName = root.name;
        sampleVal = parseFloat(sample[featureName]);
        if (sampleVal <= root.cut) {
          childNode = root.values[1];
        } else {
          childNode = root.values[0];
        }
      } else if (root.type == NODE_TYPES.FEATURE_CATEGORY) {
        // feature category attribute
        featureName = root.name;
        sampleVal = sample[featureName];

        // sub value , containing n childs
        childNode = find(root.values, function(x) {
          return x.name === sampleVal;
        });
      }

      // non trained feature
      if (typeof childNode === 'undefined') {
        return 'unknown';
      }
      root = childNode.child;
    }
    return root.value;
  },

  conditionalEntropy: function(model, data, feature, cut, target) {
    var subset1 = data.filter(function(x) {
      return parseFloat(x[model.features.indexOf(feature)]) <= cut;
    });
    var subset2 = data.filter(function(x) {
      return parseFloat(x[model.features.indexOf(feature)]) > cut;
    });
    var setSize = data.length;
    return subset1.length/setSize * C45.entropy(model,
      subset1.map(function(d) {
        return d[d.length-1];
      })
    ) + subset2.length/setSize*C45.entropy(model,
      subset2.map(function(d) {
        return d[d.length-1];
      })
    );
  },

  count: function(target, targets) {
    return targets.filter(function(t) {
      return t === target;
    }).length;
  },

  depth : function (model) {
    switch (model.type) {
      case NODE_TYPES.RESULT: 
        return 1;
      case NODE_TYPES.FEATURE_NUMBER:
      case NODE_TYPES.FEATURE_CATEGORY:
        return 1+Comp.array.max(model.values.map(function (v) {
          return C45.depth(v)
        })); 
      case NODE_TYPES.FEATURE_VALUE:
        return 1+C45.depth(model.child);
    }
    return 0; 
  },
  
  entropy: function(model, vals) {
    var uniqueVals = unique(vals);
    var probs = uniqueVals.map(function(x) {
      return C45.prob(x, vals);
    });
    var logVals = probs.map(function(p) {
      return -p * C45.log2(p);
    });
    return logVals.reduce(function(a, b) {
      return a + b;
    }, 0);
  },

  gain: function(model, data, target, features, feature, featureTypes) {
    var setEntropy = C45.entropy(model, data.map(function(d) {
      return d[d.length-1];
    }));
    if (featureTypes[model.features.indexOf(feature)] === 'category') {
      var attrVals = unique(data.map(function(d) {
        return d[model.features.indexOf(feature)];
      }));
      var setSize = data.length;
      var entropies = attrVals.map(function(n) {
        var subset = data.filter(function(x) {
          return x[feature] === n;
        });
        return (subset.length/setSize) * C45.entropy(model,
          subset.map(function(d) {
            return d[d.length-1];
          })
        );
      });
      var sumOfEntropies = entropies.reduce(function(a, b) {
        return a + b;
      }, 0);
      return {
        feature: feature,
        gain: setEntropy - sumOfEntropies,
        cut: 0
      };
    } else if (featureTypes[model.features.indexOf(feature)] === 'number') {
      var attrVals = unique(data.map(function(d) {
        return d[model.features.indexOf(feature)];
      }));
      var gainVals = attrVals.map(function(cut) {
        var cutf = parseFloat(cut);
        var gain = setEntropy - C45.conditionalEntropy(model, data, feature, cutf, target);
        return {
            feature: feature,
            gain: gain,
            cut: cutf
        };
      });
      var maxgain = max(gainVals, function(e) {
        return e.gain;
      });
      return maxgain;
    }
  },
  
  info : function (model) {
    var vl = C45.vars(model);
    return {
      depth:C45.depth(model),
      nodes:vl.length,
      vars:vl.unique(),
    }
  },

  
  log2: function(n) {
    return Math.log(n) / Math.log(2);
  },
  
  maxGain: function(model, data, target, features, featureTypes) {
    var g45 = features.map(function(feature) {
      return C45.gain(model, data, target, features, feature, featureTypes);
    });
    return max(g45, function(e) {
      return e.gain;
    });
  },


  mostCommon: function(targets) {
    return sortBy(targets, function(target) {
      return C45.count(target, targets);
    }).reverse()[0];
  },

  /** Print the tree
  *
  */
  print: function (model,indent) {
    var NL = '\n',
        line='',sep;
    if (indent==undefined) indent=0;
    if (!model) return '';
    var sp = function () {return Comp.string.create(indent);};
    switch (model.type) {
      case NODE_TYPES.RESULT: 
        return sp()+'-> '+model.name+NL;
      case NODE_TYPES.FEATURE_CATEGORY:
        line=sp()+'$'+model.name+'?'+NL;
        Comp.array.iter(model.values,function (v) {
          line += C45.print(v,indent+2);
        }); 
        return line;
      case NODE_TYPES.FEATURE_NUMBER:
        line = sp()+'$'+model.name+'>'+model.cut+'?'+NL;
        if (model.values[0].type==NODE_TYPES.FEATURE_VALUE)
          line = line+C45.print(model.values[0].child,indent+2);
        else
          line = line+C45.print(model.values[0],indent+2);
        line = line+sp()+'$'+model.name+'<='+model.cut+'?'+NL;
        if (model.values[0].type==NODE_TYPES.FEATURE_VALUE)
          line = line+C45.print(model.values[1].child,indent+2);
        else
          line = line+C45.print(model.values[1],indent+2);
        return line;
      case NODE_TYPES.FEATURE_VALUE:
        line=sp()+''+model.name+NL;
        line += C45.print(model.child,indent+2);
        return line;
    }
    return 'model?';
  },

  prob: function(target, targets) {
    return C45.count(target,targets)/targets.length;
  },

  vars : function (model) {
    switch (model.type) {
      case NODE_TYPES.RESULT: return [];
      case NODE_TYPES.FEATURE_NUMBER: 
      case NODE_TYPES.FEATURE_CATEGORY: 
        return [model.name].concat(Comp.array.flatten(model.values.map(C45.vars)));
      case NODE_TYPES.FEATURE_VALUE: 
        return C45.vars(model.child);   
    }
    return [];
  },

};

module.exports = {
  classify: C45.classify,
  create:   C45.create,
  depth:    function (model) { return C45.depth(model.model) },
  entropy:  C45.entropy,
  info:     function (model) { return C45.info(model.model) },
  log2:     C45.log2,
  print:    function (model,indent) { return C45.print(model.model,indent) },
  unique:   unique,
  train:    C45.train,
  current:  function (module) { current=module.current; Aios=module;}  
}
};
BundleModuleCode['plugins/ml/text']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 BSSLAB
 **    $CREATED:     5-3-19 by sbosse.
 **    $VERSION:     1.1.1X
 **
 **    $INFO:
 **
 **  JavaScript AIOS Machine Learning API: Text analysis
 **
 ** Portable model
 **
 **    $ENDOFINFO
 */
'use strict';
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;

function similarity(s1, s2) {
  var longer = s1;
  var shorter = s2;
  if (s1.length < s2.length) {
    longer = s2;
    shorter = s1;
  }
  var longerLength = longer.length;
  if (longerLength == 0) {
    return 1.0;
  }
  return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
}
function editDistance(s1, s2) {
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();

  var costs = new Array();
  for (var i = 0; i <= s1.length; i++) {
    var lastValue = i;
    for (var j = 0; j <= s2.length; j++) {
      if (i == 0)
        costs[j] = j;
      else {
        if (j > 0) {
          var newValue = costs[j - 1];
          if (s1.charAt(i - 1) != s2.charAt(j - 1))
            newValue = Math.min(Math.min(newValue, lastValue),
              costs[j]) + 1;
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
    }
    if (i > 0)
      costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}


// Create a model
function create(strings,options) {
  return {
    data:strings
  }
}

// Classify one sample; return best matching string
function classify(model,sample) {
  var matches = model.data.map(function (h) {
    return {
      match:similarity(h,sample),
      string:h
    }
  }).sort(function (a,b) {
    if (a.match < b.match) return 1; else return -1;
  });
  return matches[0];
}

module.exports = {
  classify:classify,
  create:create,
  similarity:similarity,
  current:function (module) { current=module.current; Aios=module;}  
}
};
BundleModuleCode['plugins/ml/rf']=function (module,exports){
// MIT License
// Random Forest Trees (only binary classifier)
// Andrej Karpathy
// @blab+ 
// https://github.com/karpathy/forestjs


var RandomForest = function(options) {
  var L = {};
  return L
}

RandomForest.code = {

  /*
  data is 2D array of size N x D of examples
  labels is a 1D array of labels (only -1 or 1 for now). In future will support multiclass or maybe even regression
  options.numTrees can be used to customize number of trees to train (default = 100)
  options.maxDepth is the maximum depth of each tree in the forest (default = 4)
  options.numTries is the number of random hypotheses generated at each node during training (default = 10)
  options.trainFun is a function with signature "function myWeakTrain(data, labels, ix, options)". Here, ix is a list of 
                   indeces into data of the instances that should be payed attention to. Everything not in the list 
                   should be ignored. This is done for efficiency. The function should return a model where you store 
                   variables. (i.e. model = {}; model.myvar = 5;) This will be passed to testFun.
  options.testFun is a function with signature "funtion myWeakTest(inst, model)" where inst is 1D array specifying an example,
                   and model will be the same model that you return in options.trainFun. For example, model.myvar will be 5.
                   see decisionStumpTrain() and decisionStumpTest() downstairs for example.
  */
  train: function(L, data, labels, options) {
    options = options || {};
    L.options = options;
    
    L.numTrees = options.numTrees || 100;

    // initialize many trees and train them all independently
    L.trees= new Array(L.numTrees);
    for(var i=0;i<L.numTrees;i++) {
      L.trees[i] = DecisionTree();
      DecisionTree.code.train(L.trees[i],data, labels, options);
    }
  },

  /*
  inst is a 1D array of length D of an example. 
  returns the probability of label 1, i.e. a number in range [0, 1]
  */
  predictOne: function(L, inst) {

    // have each tree predict and average out all votes
    var dec=0;
    for(var i=0;i<L.numTrees;i++) {
      dec += DecisionTree.code.predictOne(L.trees[i],inst);
    }
    dec /= L.numTrees;
    return dec;
  },

  // convenience function. Here, data is NxD array. 
  // returns probabilities of being 1 for all data in an array.
  predict: function(L, data) {

    var probabilities= new Array(data.length);
    for(var i=0;i<data.length;i++) {
      probabilities[i]= RandomForest.code.predictOne(L,data[i]);
    }
    return probabilities;

  }

}

// represents a single decision tree
var DecisionTree = function(options) {
  var L = {};
  return L
}

DecisionTree.code = {

  train: function(L, data, labels, options) {

    options = options || {};
    var maxDepth = options.maxDepth || 4;
    var weakType = options.type || 0;

    
    var trainFun= decisionStumpTrain;
    var testFun= decisionStumpTest;

    if(options.trainFun) trainFun = options.trainFun;
    if(options.testFun) testFun = options.testFun;

    if(weakType == 0) {
      // Default
      trainFun  = decisionStumpTrain;
      testFun   = decisionStumpTest;
    }
    if(weakType) {
      trainFun  = decision2DStumpTrain;
      L.testFun = testFun = decision2DStumpTest;
    }

    // initialize various helper variables
    var numInternals= Math.pow(2, maxDepth)-1;
    var numNodes= Math.pow(2, maxDepth + 1)-1;
    var ixs= new Array(numNodes);
    for(var i=1;i<ixs.length;i++) ixs[i]=[];
    ixs[0]= new Array(labels.length);
    for(var i=0;i<labels.length;i++) ixs[0][i]= i; // root node starts out with all nodes as relevant
    var models = new Array(numInternals);

    // train
    for(var n=0; n < numInternals; n++) {

      // few base cases
      var ixhere= ixs[n];
      if(ixhere.length == 0) { continue; }
      if(ixhere.length == 1) { ixs[n*2+1] = [ixhere[0]]; continue; } // arbitrary send it down left

      // learn a weak model on relevant data for this node
      var model= trainFun(data, labels, ixhere);
      models[n]= model; // back it up model

      // split the data according to the learned model
      var ixleft=[];
      var ixright=[];
      for(var i=0; i<ixhere.length;i++) {
          var label= testFun(data[ixhere[i]], model);
          if(label === 1) ixleft.push(ixhere[i]);
          else ixright.push(ixhere[i]);
      }
      ixs[n*2+1]= ixleft;
      ixs[n*2+2]= ixright;
    }

    // compute data distributions at the leafs
    var leafPositives = new Array(numNodes);
    var leafNegatives = new Array(numNodes);
    for(var n=numInternals; n < numNodes; n++) {
      var numones= 0;
      for(var i=0;i<ixs[n].length;i++) {
          if(labels[ixs[n][i]] === 1) numones+=1;
      }
      leafPositives[n]= numones;
      leafNegatives[n]= ixs[n].length-numones;
    }

    // back up important prediction variables for predicting later
    L.models= models;
    L.leafPositives = leafPositives;
    L.leafNegatives = leafNegatives;
    L.maxDepth= maxDepth;
    // L.trainFun= trainFun;
    // L.testFun= testFun;
  }, 

  // returns probability that example inst is 1.
  predictOne: function(L, inst) { 
      var testFun = L.testFun||decisionStumpTest;
      var n=0;
      for(var i=0;i<L.maxDepth;i++) {
          var dir= testFun(inst, L.models[n]);
          if(dir === 1) n= n*2+1; // descend left
          else n= n*2+2; // descend right
      }

      return (L.leafPositives[n] + 0.5) / (L.leafNegatives[n] + 1.0); // bayesian smoothing!
  }
}

// returns model
function decisionStumpTrain(data, labels, ix, options) {

  options = options || {};
  var numtries = options.numTries || 10;

  // choose a dimension at random and pick a best split
  var ri= randi(0, data[0].length);
  var N= ix.length;

  // evaluate class entropy of incoming data
  var H= entropy(labels, ix);
  var bestGain=0; 
  var bestThr= 0;
  for(var i=0;i<numtries;i++) {

      // pick a random splitting threshold
      var ix1= ix[randi(0, N)];
      var ix2= ix[randi(0, N)];
      while(ix2==ix1) ix2= ix[randi(0, N)]; // enforce distinctness of ix2

      var a= Math.random();
      var thr= data[ix1][ri]*a + data[ix2][ri]*(1-a);

      // measure information gain we'd get from split with thr
      var l1=1, r1=1, lm1=1, rm1=1; //counts for Left and label 1, right and label 1, left and minus 1, right and minus 1
      for(var j=0;j<ix.length;j++) {
          if(data[ix[j]][ri] < thr) {
            if(labels[ix[j]]==1) l1++;
            else lm1++;
          } else {
            if(labels[ix[j]]==1) r1++;
            else rm1++;
          }
      }
      var t= l1+lm1;  // normalize the counts to obtain probability estimates
      l1=l1/t;
      lm1=lm1/t;
      t= r1+rm1;
      r1=r1/t;
      rm1= rm1/t;

      var LH= -l1*Math.log(l1) -lm1*Math.log(lm1); // left and right entropy
      var RH= -r1*Math.log(r1) -rm1*Math.log(rm1);

      var informationGain= H - LH - RH;
      //console.log("Considering split %f, entropy %f -> %f, %f. Gain %f", thr, H, LH, RH, informationGain);
      if(informationGain > bestGain || i === 0) {
          bestGain= informationGain;
          bestThr= thr;
      }
  }

  model= {};
  model.thr= bestThr;
  model.ri= ri;
  return model;
}

// returns a decision for a single data instance
function decisionStumpTest(inst, model) {
  if(!model) {
      // this is a leaf that never received any data... 
      return 1;
  }
  return inst[model.ri] < model.thr ? 1 : -1;

}

// returns model. Code duplication with decisionStumpTrain :(
function decision2DStumpTrain(data, labels, ix, options) {

  options = options || {};
  var numtries = options.numTries || 10;

  // choose a dimension at random and pick a best split
  var N= ix.length;

  var ri1= 0;
  var ri2= 1;
  if(data[0].length > 2) {
    // more than 2D data. Pick 2 random dimensions
    ri1= randi(0, data[0].length);
    ri2= randi(0, data[0].length);
    while(ri2 == ri1) ri2= randi(0, data[0].length); // must be distinct!
  }

  // evaluate class entropy of incoming data
  var H= entropy(labels, ix);
  var bestGain=0; 
  var bestw1, bestw2, bestthr;
  var dots= new Array(ix.length);
  for(var i=0;i<numtries;i++) {

      // pick random line parameters
      var alpha= randf(0, 2*Math.PI);
      var w1= Math.cos(alpha);
      var w2= Math.sin(alpha);

      // project data on this line and get the dot products
      for(var j=0;j<ix.length;j++) {
        dots[j]= w1*data[ix[j]][ri1] + w2*data[ix[j]][ri2];
      }

      // we are in a tricky situation because data dot product distribution
      // can be skewed. So we don't want to select just randomly between
      // min and max. But we also don't want to sort as that is too expensive
      // let's pick two random points and make the threshold be somewhere between them.
      // for skewed datasets, the selected points will with relatively high likelihood
      // be in the high-desnity regions, so the thresholds will make sense
      var ix1= ix[randi(0, N)];
      var ix2= ix[randi(0, N)];
      while(ix2==ix1) ix2= ix[randi(0, N)]; // enforce distinctness of ix2
      var a= Math.random();
      var dotthr= dots[ix1]*a + dots[ix2]*(1-a);

      // measure information gain we'd get from split with thr
      var l1=1, r1=1, lm1=1, rm1=1; //counts for Left and label 1, right and label 1, left and minus 1, right and minus 1
      for(var j=0;j<ix.length;j++) {
          if(dots[j] < dotthr) {
            if(labels[ix[j]]==1) l1++;
            else lm1++;
          } else {
            if(labels[ix[j]]==1) r1++;
            else rm1++;
          }
      }
      var t= l1+lm1; 
      l1=l1/t;
      lm1=lm1/t;
      t= r1+rm1;
      r1=r1/t;
      rm1= rm1/t;

      var LH= -l1*Math.log(l1) -lm1*Math.log(lm1); // left and right entropy
      var RH= -r1*Math.log(r1) -rm1*Math.log(rm1);

      var informationGain= H - LH - RH;
      //console.log("Considering split %f, entropy %f -> %f, %f. Gain %f", thr, H, LH, RH, informationGain);
      if(informationGain > bestGain || i === 0) {
          bestGain= informationGain;
          bestw1= w1;
          bestw2= w2;
          bestthr= dotthr;
      }
  }

  model= {};
  model.w1= bestw1;
  model.w2= bestw2;
  model.dotthr= bestthr;
  return model;
}

// returns label for a single data instance
function decision2DStumpTest(inst, model) {
  if(!model) {
      // this is a leaf that never received any data... 
      return 1;
  }
  return inst[0]*model.w1 + inst[1]*model.w2 < model.dotthr ? 1 : -1;

}

// Misc utility functions
function entropy(labels, ix) {
  var N= ix.length;
  var p=0.0;
  for(var i=0;i<N;i++) {
      if(labels[ix[i]]==1) p+=1;
  }
  p=(1+p)/(N+2); // let's be bayesian about this
  q=(1+N-p)/(N+2);
  return (-p*Math.log(p) -q*Math.log(q));
}

// generate random floating point number between a and b
function randf(a, b) {
  return Math.random()*(b-a)+a;
}

// generate random integer between a and b (b excluded)
function randi(a, b) {
   return Math.floor(Math.random()*(b-a)+a);
}

module.exports = RandomForest
};
BundleModuleCode['plugins/ml/rl']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2015, Andrej Karpathy
 **    $MODIFIED:    (C) 2006-2019 bLAB by sbosse
 **    $VERSION:     1.1.2
 **
 **    $INFO:
 **
 ** Reinforcement Learning module that implements several common RL algorithms.
 ** Portable models (TDAgent/DPAgent/DQNAgent)
 **
 **    $ENDOFINFO
 */
"use strict";

var options = {
  version:'1.1.2'
}
var Io = Require('com/io')
var R = module.exports; // the Recurrent library


// Utility fun
function assert(condition, message) {
  // from http://stackoverflow.com/questions/15313418/javascript-assert
  if (!condition) {
    message = message || "Assertion failed";
    if (typeof Error !== "undefined") {
      throw new Error(message);
    }
    throw message; // Fallback
  }
}

// Random numbers utils
var return_v = false;
var v_val = 0.0;
var gaussRandom = function() {
  if(return_v) { 
    return_v = false;
    return v_val; 
  }
  var u = 2*Math.random()-1;
  var v = 2*Math.random()-1;
  var r = u*u + v*v;
  if(r == 0 || r > 1) return gaussRandom();
  var c = Math.sqrt(-2*Math.log(r)/r);
  v_val = v*c; // cache this
  return_v = true;
  return u*c;
}
var randf = function(a, b) { return Math.random()*(b-a)+a; }
var randi = function(a, b) { return Math.floor(Math.random()*(b-a)+a); }
var randn = function(mu, std){ return mu+gaussRandom()*std; }

// helper function returns array of zeros of length n
// and uses typed arrays if available
var zeros = function(n) {
  if(typeof(n)==='undefined' || isNaN(n)) { return []; }
  if(typeof ArrayBuffer === 'undefined') {
    // lacking browser support
    var arr = new Array(n);
    for(var i=0;i<n;i++) { arr[i] = 0; }
    return arr;
  } else {
    return new Float64Array(n);
  }
}

// Mat holds a matrix
var Mat = function(n,d) {
  var M = {}
  // n is number of rows d is number of columns
  M.n = n;
  M.d = d;
  M.w = zeros(n * d);
  M.dw = zeros(n * d);
  return M;
}

Mat.code = {
  get: function(M,row, col) { 
    // slow but careful accessor function
    // we want row-major order
    var ix = (M.d * row) + col;
    assert(ix >= 0 && ix < M.w.length);
    return M.w[ix];
  },
  set: function(M, row, col, v) {
    // slow but careful accessor function
    var ix = (M.d * row) + col;
    assert(ix >= 0 && ix < M.w.length);
    M.w[ix] = v; 
  },
  setFrom: function(M, arr) {
    for(var i=0,n=arr.length;i<n;i++) {
      M.w[i] = arr[i]; 
    }
  },
  setColumn: function(M, m, i) {
    for(var q=0,n=m.w.length;q<n;q++) {
      M.w[(M.d * q) + i] = m.w[q];
    }
  },
  toJSON: function(M) {
    var json = {};
    json['n'] = M.n;
    json['d'] = M.d;
    json['w'] = M.w;
    return json;
  },
  fromJSON: function(M, json) {
    M.n = json.n;
    M.d = json.d;
    M.w = zeros(M.n * M.d);
    M.dw = zeros(M.n * M.d);
    for(var i=0,n=M.n * M.d;i<n;i++) {
      M.w[i] = json.w[i]; // copy over weights
    }
  }
}

var copyMat = function(b) {
  var a = Mat(b.n, b.d);
  Mat.code.setFrom(a, b.w);
  return a;
}

var copyNet = function(net) {
  // nets are (k,v) pairs with k = string key, v = Mat()
  var new_net = {};
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      new_net[p] = copyMat(net[p]);
    }
  }
  return new_net;
}

var updateMat = function(m, alpha) {
  // updates in place
  for(var i=0,n=m.n*m.d;i<n;i++) {
    if(m.dw[i] !== 0) {
      m.w[i] += - alpha * m.dw[i];
      m.dw[i] = 0;
    }
  }
}

var updateNet = function(net, alpha) {
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      updateMat(net[p], alpha);
    }
  }
}

var netToJSON = function(net) {
  var j = {};
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      j[p] = Mat.code.toJSON(net[p]);
    }
  }
  return j;
}
var netFromJSON = function(j) {
  var net = {};
  for(var p in j) {
    if(j.hasOwnProperty(p)){
      net[p] = Mat(1,1); // not proud of this
      Mat.code.fromJSON(net[p],j[p]);
    }
  }
  return net;
}
var netZeroGrads = function(net) {
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      var mat = net[p];
      gradFillConst(mat, 0);
    }
  }
}
var netFlattenGrads = function(net) {
  var n = 0;
  for(var p in net) { 
   if(net.hasOwnProperty(p)) { 
    var mat = net[p]; n += mat.dw.length; 
  }}
  var g = Mat(n, 1);
  var ix = 0;
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      var mat = net[p];
      for(var i=0,m=mat.dw.length;i<m;i++) {
        g.w[ix] = mat.dw[i];
        ix++;
      }
    }
  }
  return g;
}

// return Mat but filled with random numbers from gaussian
var RandMat = function(n,d,mu,std) {
  var m = Mat(n, d);
  fillRandn(m,mu,std);
  //fillRand(m,-std,std); // kind of :P
  return m;
}

// Mat utils
// fill matrix with random gaussian numbers
var fillRandn = function(m, mu, std) { for(var i=0,n=m.w.length;i<n;i++) { m.w[i] = randn(mu, std); } }
var fillRand = function(m, lo, hi) { for(var i=0,n=m.w.length;i<n;i++) { m.w[i] = randf(lo, hi); } }
var gradFillConst = function(m, c) { for(var i=0,n=m.dw.length;i<n;i++) { m.dw[i] = c } }



// Transformer definitions
var Graph = function(needs_backprop) {
  var G = {}
  if(typeof needs_backprop === 'undefined') { needs_backprop = true; }
  G.needs_backprop = needs_backprop;

  // this will store a list of functions that perform backprop,
  // in their forward pass order. So in backprop we will go
  // backwards and evoke each one
  G.backprop = [];
  return G
}
Graph.code = {
  backward: function(G) {
    for(var i=G.backprop.length-1;i>=0;i--) {
      G.backprop[i](); // tick!
    }
  },
  rowPluck: function(G, m, ix) {
    // pluck a row of m with index ix and return it as col vector
    assert(ix >= 0 && ix < m.n);
    var d = m.d;
    var out = Mat(d, 1);
    for(var i=0,n=d;i<n;i++){ out.w[i] = m.w[d * ix + i]; } // copy over the data

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=d;i<n;i++){ m.dw[d * ix + i] += out.dw[i]; }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  tanh: function(G, m) {
    // tanh nonlinearity
    var out = Mat(m.n, m.d);
    var n = m.w.length;
    for(var i=0;i<n;i++) { 
      out.w[i] = Math.tanh(m.w[i]);
    }

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<n;i++) {
          // grad for z = tanh(x) is (1 - z^2)
          var mwi = out.w[i];
          m.dw[i] += (1.0 - mwi * mwi) * out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  sigmoid: function(G, m) {
    // sigmoid nonlinearity
    var out = Mat(m.n, m.d);
    var n = m.w.length;
    for(var i=0;i<n;i++) { 
      out.w[i] = sig(m.w[i]);
    }

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<n;i++) {
          // grad for z = tanh(x) is (1 - z^2)
          var mwi = out.w[i];
          m.dw[i] += mwi * (1.0 - mwi) * out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  relu: function(G, m) {
    var out = Mat(m.n, m.d);
    var n = m.w.length;
    for(var i=0;i<n;i++) { 
      out.w[i] = Math.max(0, m.w[i]); // relu
    }
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<n;i++) {
          m.dw[i] += m.w[i] > 0 ? out.dw[i] : 0.0;
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  mul: function(G, m1, m2) {
    // multiply matrices m1 * m2
    assert(m1.d === m2.n, 'matmul dimensions misaligned');

    var n = m1.n;
    var d = m2.d;
    var out = Mat(n,d);
    for(var i=0;i<m1.n;i++) { // loop over rows of m1
      for(var j=0;j<m2.d;j++) { // loop over cols of m2
        var dot = 0.0;
        for(var k=0;k<m1.d;k++) { // dot product loop
          dot += m1.w[m1.d*i+k] * m2.w[m2.d*k+j];
        }
        out.w[d*i+j] = dot;
      }
    }

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<m1.n;i++) { // loop over rows of m1
          for(var j=0;j<m2.d;j++) { // loop over cols of m2
            for(var k=0;k<m1.d;k++) { // dot product loop
              var b = out.dw[d*i+j];
              m1.dw[m1.d*i+k] += m2.w[m2.d*k+j] * b;
              m2.dw[m2.d*k+j] += m1.w[m1.d*i+k] * b;
            }
          }
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  add: function(G, m1, m2) {
    assert(m1.w.length === m2.w.length);

    var out = Mat(m1.n, m1.d);
    for(var i=0,n=m1.w.length;i<n;i++) {
      out.w[i] = m1.w[i] + m2.w[i];
    }
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=m1.w.length;i<n;i++) {
          m1.dw[i] += out.dw[i];
          m2.dw[i] += out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  dot: function(G, m1, m2) {
    // m1 m2 are both column vectors
    assert(m1.w.length === m2.w.length);
    var out = Mat(1,1);
    var dot = 0.0;
    for(var i=0,n=m1.w.length;i<n;i++) {
      dot += m1.w[i] * m2.w[i];
    }
    out.w[0] = dot;
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=m1.w.length;i<n;i++) {
          m1.dw[i] += m2.w[i] * out.dw[0];
          m2.dw[i] += m1.w[i] * out.dw[0];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  eltmul: function(G, m1, m2) {
    assert(m1.w.length === m2.w.length);

    var out = Mat(m1.n, m1.d);
    for(var i=0,n=m1.w.length;i<n;i++) {
      out.w[i] = m1.w[i] * m2.w[i];
    }
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=m1.w.length;i<n;i++) {
          m1.dw[i] += m2.w[i] * out.dw[i];
          m2.dw[i] += m1.w[i] * out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
}


var softmax = function(m) {
    var out = Mat(m.n, m.d); // probability volume
    var maxval = -999999;
    for(var i=0,n=m.w.length;i<n;i++) { if(m.w[i] > maxval) maxval = m.w[i]; }

    var s = 0.0;
    for(var i=0,n=m.w.length;i<n;i++) { 
      out.w[i] = Math.exp(m.w[i] - maxval);
      s += out.w[i];
    }
    for(var i=0,n=m.w.length;i<n;i++) { out.w[i] /= s; }

    // no backward pass here needed
    // since we will use the computed probabilities outside
    // to set gradients directly on m
    return out;
  }


var Solver = function() {
  var S = {}
  S.decay_rate = 0.999;
  S.smooth_eps = 1e-8;
  S.step_cache = {};
  return S
}
Solver.code = {
  step: function(S, model, step_size, regc, clipval) {
    // perform parameter update
    var solver_stats = {};
    var num_clipped = 0;
    var num_tot = 0;
    for(var k in model) {
      if(model.hasOwnProperty(k)) {
        var m = model[k]; // mat ref
        if(!(k in S.step_cache)) { S.step_cache[k] = Mat(m.n, m.d); }
        var s = S.step_cache[k];
        for(var i=0,n=m.w.length;i<n;i++) {

          // rmsprop adaptive learning rate
          var mdwi = m.dw[i];
          s.w[i] = s.w[i] * S.decay_rate + (1.0 - S.decay_rate) * mdwi * mdwi;

          // gradient clip
          if(mdwi > clipval) {
            mdwi = clipval;
            num_clipped++;
          }
          if(mdwi < -clipval) {
            mdwi = -clipval;
            num_clipped++;
          }
          num_tot++;

          // update (and regularize)
          m.w[i] += - step_size * mdwi / Math.sqrt(s.w[i] + S.smooth_eps) - regc * m.w[i];
          m.dw[i] = 0; // reset gradients for next iteration
        }
      }
    }
    solver_stats['ratio_clipped'] = num_clipped*1.0/num_tot;
    return solver_stats;
  }
}

var initLSTM = function(input_size, hidden_sizes, output_size) {
  // hidden size should be a list

  var model = {};
  for(var d=0;d<hidden_sizes.length;d++) { // loop over depths
    var prev_size = d === 0 ? input_size : hidden_sizes[d - 1];
    var hidden_size = hidden_sizes[d];

    // gates parameters
    model['Wix'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Wih'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bi'+d]   = Mat(hidden_size, 1);
    model['Wfx'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Wfh'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bf'+d]   = Mat(hidden_size, 1);
    model['Wox'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Woh'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bo'+d]   = Mat(hidden_size, 1);
    // cell write params
    model['Wcx'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Wch'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bc'+d]   = Mat(hidden_size, 1);
  }
  // decoder params
  model['Whd']  = RandMat(output_size, hidden_size, 0, 0.08);
  model['bd']   = Mat(output_size, 1);
  return model;
}

var forwardLSTM = function(G, model, hidden_sizes, x, prev) {
  // forward prop for a single tick of LSTM
  // G is graph to append ops to
  // model contains LSTM parameters
  // x is 1D column vector with observation
  // prev is a struct containing hidden and cell
  // from previous iteration

  if(prev == null || typeof prev.h === 'undefined') {
    var hidden_prevs = [];
    var cell_prevs = [];
    for(var d=0;d<hidden_sizes.length;d++) {
      hidden_prevs.push(R.Mat(hidden_sizes[d],1)); 
      cell_prevs.push(R.Mat(hidden_sizes[d],1)); 
    }
  } else {
    var hidden_prevs = prev.h;
    var cell_prevs = prev.c;
  }

  var hidden = [];
  var cell = [];
  for(var d=0;d<hidden_sizes.length;d++) {

    var input_vector = d === 0 ? x : hidden[d-1];
    var hidden_prev = hidden_prevs[d];
    var cell_prev = cell_prevs[d];

    // input gate
    var h0 = Graph.code.mul(G,model['Wix'+d], input_vector);
    var h1 = Graph.code.mul(G,model['Wih'+d], hidden_prev);
    var input_gate = Graph.code.sigmoid(G,Graph.code.add(G,Graph.code.add(G,h0,h1),
                                        model['bi'+d]));

    // forget gate
    var h2 = Graph.code.mul(G,model['Wfx'+d], input_vector);
    var h3 = Graph.code.mul(G,model['Wfh'+d], hidden_prev);
    var forget_gate = Graph.code.sigmoid(
                        G,Graph.code.add(G,Graph.code.add(G,h2, h3),
                        model['bf'+d]));

    // output gate
    var h4 = Graph.code.mul(G,model['Wox'+d], input_vector);
    var h5 = Graph.code.mul(G,model['Woh'+d], hidden_prev);
    var output_gate = Graph.code.sigmoid(G,Graph.code.add(G,Graph.code.add(G,h4, h5),
                                                          model['bo'+d]));

    // write operation on cells
    var h6 = Graph.code.mul(G,model['Wcx'+d], input_vector);
    var h7 = Graph.code.mul(G,model['Wch'+d], hidden_prev);
    var cell_write = Graph.code.tanh(G,Graph.code.add(
                                         G,Graph.code.add(G,h6, h7),
                                         model['bc'+d]));

    // compute new cell activation
    var retain_cell = Graph.code.eltmul(G,forget_gate, cell_prev); // what do we keep from cell
    var write_cell = Graph.code.eltmul(G,input_gate, cell_write); // what do we write to cell
    var cell_d = Graph.code.add(G,retain_cell, write_cell); // new cell contents

    // compute hidden state as gated, saturated cell activations
    var hidden_d = Graph.code.eltmul(G, output_gate, Graph.code.tanh(G,cell_d));

    hidden.push(hidden_d);
    cell.push(cell_d);
  }

  // one decoder to outputs at end
  var output = Graph.code.add(G,Graph.code.mul(G,model['Whd'], hidden[hidden.length - 1]),model['bd']);

  // return cell memory, hidden representation and output
  return {'h':hidden, 'c':cell, 'o' : output};
}

var sig = function(x) {
  // helper function for computing sigmoid
  return 1.0/(1+Math.exp(-x));
}

var maxi = function(w) {
  // argmax of array w
  var maxv = w[0];
  var maxix = 0;
  for(var i=1,n=w.length;i<n;i++) {
    var v = w[i];
    if(v > maxv) {
      maxix = i;
      maxv = v;
    }
  }
  return maxix;
}

var samplei = function(w) {
  // sample argmax from w, assuming w are 
  // probabilities that sum to one
  var r = randf(0,1);
  var x = 0.0;
  var i = 0;
  while(true) {
    x += w[i];
    if(x > r) { return i; }
    i++;
  }
  return w.length - 1; // pretty sure we should never get here?
}

// various utils
module.exports.assert = assert;
module.exports.zeros = zeros;
module.exports.maxi = maxi;
module.exports.samplei = samplei;
module.exports.randi = randi;
module.exports.randn = randn;
module.exports.softmax = softmax;
// classes
module.exports.Mat = Mat;
module.exports.RandMat = RandMat;
module.exports.forwardLSTM = forwardLSTM;
module.exports.initLSTM = initLSTM;
// more utils
module.exports.updateMat = updateMat;
module.exports.updateNet = updateNet;
module.exports.copyMat = copyMat;
module.exports.copyNet = copyNet;
module.exports.netToJSON = netToJSON;
module.exports.netFromJSON = netFromJSON;
module.exports.netZeroGrads = netZeroGrads;
module.exports.netFlattenGrads = netFlattenGrads;
// optimization
module.exports.Solver = Solver;
module.exports.Graph = Graph;

// END OF RECURRENTJS

var RL = module.exports;

// syntactic sugar function for getting default parameter values
var getopt = function(opt, field_name, default_value) {
  if(typeof opt === 'undefined') { return default_value; }
  return (typeof opt[field_name] !== 'undefined') ? opt[field_name] : default_value;
}

var zeros = R.zeros; // inherit these
var assert = R.assert;
var randi = R.randi;
var randf = R.randf;

var setConst = function(arr, c) {
  for(var i=0,n=arr.length;i<n;i++) {
    arr[i] = c;
  }
}

var sampleWeighted = function(p) {
  var r = Math.random();
  var c = 0.0;
  for(var i=0,n=p.length;i<n;i++) {
    c += p[i];
    if(c >= r) { return i; }
  }
  // assert(false, 'sampleWeighted: Invalid samples '+Io.inspect(p));
  return 0
}

// ------
// AGENTS
// ------

// DPAgent performs Value Iteration
// - can also be used for Policy Iteration if you really wanted to
// - requires model of the environment :(
// - does not learn from experience :(
// - assumes finite MDP :(
var DPAgent = function(env, opt) {
  var L={};
  L.V = null; // state value function
  L.P = null; // policy distribution \pi(s,a)
  L.env = env; // store pointer to environment
  L.gamma = getopt(opt, 'gamma', 0.75); // future reward discount factor
  DPAgent.code.reset(L);
  return L;
}
DPAgent.code = {
  reset: function(L) {
    // reset the agent's policy and value function
    L.ns = L.env.getNumStates();
    L.na = L.env.getMaxNumActions();
    L.V = zeros(L.ns);
    L.P = zeros(L.ns * L.na);
    // initialize uniform random policy
    for(var s=0;s<L.ns;s++) {
      var poss = L.env.allowedActions(s);
      for(var i=0,n=poss.length;i<n;i++) {
        L.P[poss[i]*L.ns+s] = 1.0 / poss.length;
      }
    }
  },
  act: function(L,s) {
    // behave according to the learned policy
    var poss = L.env.allowedActions(s);
    var ps = [];
    for(var i=0,n=poss.length;i<n;i++) {
      var a = poss[i];
      var prob = L.P[a*L.ns+s];
      ps.push(prob);
    }
    var maxi = sampleWeighted(ps);
    return poss[maxi];
  },
  learn: function(L) {
    // perform a single round of value iteration
    DPAgent.code.evaluatePolicy(L); // writes this.V
    DPAgent.code.updatePolicy(L); // writes this.P
  },
  evaluatePolicy: function(L) {
    // perform a synchronous update of the value function
    var Vnew = zeros(L.ns);
    for(var s=0;s<L.ns;s++) {
      // integrate over actions in a stochastic policy
      // note that we assume that policy probability mass over allowed actions sums to one
      var v = 0.0;
      var poss = L.env.allowedActions(s);
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        var prob = L.P[a*L.ns+s]; // probability of taking action under policy
        if(prob === 0) { continue; } // no contribution, skip for speed
        var ns = L.env.nextState(s,a);
        var rs = L.env.reward(s,a,ns); // reward for s->a->ns transition
        v += prob * (rs + L.gamma * L.V[ns]);
      }
      Vnew[s] = v;
    }
    L.V = Vnew; // swap
  },
  updatePolicy: function(L) {
    // update policy to be greedy w.r.t. learned Value function
    for(var s=0;s<L.ns;s++) {
      var poss = L.env.allowedActions(s);
      // compute value of taking each allowed action
      var vmax, nmax;
      var vs = [];
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        var ns = L.env.nextState(s,a);
        var rs = L.env.reward(s,a,ns);
        var v = rs + L.gamma * L.V[ns];
        vs.push(v);
        if(i === 0 || v > vmax) { vmax = v; nmax = 1; }
        else if(v === vmax) { nmax += 1; }
      }
      // update policy smoothly across all argmaxy actions
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        L.P[a*L.ns+s] = (vs[i] === vmax) ? 1.0/nmax : 0.0;
      }
    }
  },
}

// QAgent uses TD (Q-Learning, SARSA)
// - does not require environment model :)
// - learns from experience :)
var TDAgent = function(env, opt) {
  var L={}
  L.update = getopt(opt, 'update', 'qlearn'); // qlearn | sarsa
  L.gamma = getopt(opt, 'gamma', 0.75); // future reward discount factor
  L.epsilon = getopt(opt, 'epsilon', 0.1); // for epsilon-greedy policy
  L.alpha = getopt(opt, 'alpha', 0.01); // value function learning rate

  // class allows non-deterministic policy, and smoothly regressing towards the optimal policy based on Q
  L.smooth_policy_update = getopt(opt, 'smooth_policy_update', false);
  L.beta = getopt(opt, 'beta', 0.01); // learning rate for policy, if smooth updates are on

  // eligibility traces
  L.lambda = getopt(opt, 'lambda', 0); // eligibility trace decay. 0 = no eligibility traces used
  L.replacing_traces = getopt(opt, 'replacing_traces', true);

  // optional optimistic initial values
  L.q_init_val = getopt(opt, 'q_init_val', 0);

  L.planN = getopt(opt, 'planN', 0); // number of planning steps per learning iteration (0 = no planning)

  L.Q = null; // state action value function
  L.P = null; // policy distribution \pi(s,a)
  L.e = null; // eligibility trace
  L.env_model_s = null;; // environment model (s,a) -> (s',r)
  L.env_model_r = null;; // environment model (s,a) -> (s',r)
  L.env = env; // store pointer to environment
  TDAgent.code.reset(L);
  return L;
}
TDAgent.code = {
  reset: function(L){
    // reset the agent's policy and value function
    L.ns = L.env.getNumStates();
    L.na = L.env.getMaxNumActions();
    L.Q = zeros(L.ns * L.na);
    if(L.q_init_val !== 0) { setConst(L.Q, L.q_init_val); }
    L.P = zeros(L.ns * L.na);
    L.e = zeros(L.ns * L.na);

    // model/planning vars
    L.env_model_s = zeros(L.ns * L.na);
    setConst(L.env_model_s, -1); // init to -1 so we can test if we saw the state before
    L.env_model_r = zeros(L.ns * L.na);
    L.sa_seen = [];
    L.pq = zeros(L.ns * L.na);

    // initialize uniform random policy
    for(var s=0;s<L.ns;s++) {
      var poss = L.env.allowedActions(s);
      for(var i=0,n=poss.length;i<n;i++) {
        L.P[poss[i]*L.ns+s] = 1.0 / poss.length;
      }
    }
    // agent memory, needed for streaming updates
    // (s0,a0,r0,s1,a1,r1,...)
    L.r0 = null;
    L.s0 = null;
    L.s1 = null;
    L.a0 = null;
    L.a1 = null;
  },
  resetEpisode: function(L) {
    // an episode finished
  },
  act: function(L,s){
    // act according to epsilon greedy policy
    var poss = L.env.allowedActions(s);
    var probs = [];
    for(var i=0,n=poss.length;i<n;i++) {
      probs.push(L.P[poss[i]*L.ns+s]);
    }
    // epsilon greedy policy
    if(Math.random() < L.epsilon) {
      var a = poss[randi(0,poss.length)]; // random available action
      L.explored = true;
    } else {
      var a = poss[sampleWeighted(probs)];
      L.explored = false;
    }
    // shift state memory
    L.s0 = L.s1;
    L.a0 = L.a1;
    L.s1 = s;
    L.a1 = a;
    return a;
  },
  learn: function(L,r1){
    // takes reward for previous action, which came from a call to act()
    if(!(L.r0 == null)) {
      TDAgent.code.learnFromTuple(L, L.s0, L.a0, L.r0, L.s1, L.a1, L.lambda);
      if(L.planN > 0) {
        TDAgent.code.updateModel(L, L.s0, L.a0, L.r0, L.s1);
        TDAgent.code.plan(L);
      }
    }
    L.r0 = r1; // store this for next update
  },
  updateModel: function(L, s0, a0, r0, s1) {
    // transition (s0,a0) -> (r0,s1) was observed. Update environment model
    var sa = a0 * L.ns + s0;
    if(L.env_model_s[sa] === -1) {
      // first time we see this state action
      L.sa_seen.push(a0 * L.ns + s0); // add as seen state
    }
    L.env_model_s[sa] = s1;
    L.env_model_r[sa] = r0;
  },
  plan: function(L) {

    // order the states based on current priority queue information
    var spq = [];
    for(var i=0,n=L.sa_seen.length;i<n;i++) {
      var sa = L.sa_seen[i];
      var sap = L.pq[sa];
      if(sap > 1e-5) { // gain a bit of efficiency
        spq.push({sa:sa, p:sap});
      }
    }
    spq.sort(function(a,b){ return a.p < b.p ? 1 : -1});

    // perform the updates
    var nsteps = Math.min(L.planN, spq.length);
    for(var k=0;k<nsteps;k++) {
      // random exploration
      //var i = randi(0, this.sa_seen.length); // pick random prev seen state action
      //var s0a0 = this.sa_seen[i];
      var s0a0 = spq[k].sa;
      L.pq[s0a0] = 0; // erase priority, since we're backing up this state
      var s0 = s0a0 % L.ns;
      var a0 = Math.floor(s0a0 / L.ns);
      var r0 = L.env_model_r[s0a0];
      var s1 = L.env_model_s[s0a0];
      var a1 = -1; // not used for Q learning
      if(L.update === 'sarsa') {
        // generate random action?...
        var poss = L.env.allowedActions(s1);
        var a1 = poss[randi(0,poss.length)];
      }
      TDAgent.code.learnFromTuple(L, s0, a0, r0, s1, a1, 0); // note lambda = 0 - shouldnt use eligibility trace here
    }
  },
  learnFromTuple: function(L, s0, a0, r0, s1, a1, lambda) {
    var sa = a0 * L.ns + s0;

    // calculate the target for Q(s,a)
    if(L.update === 'qlearn') {
      // Q learning target is Q(s0,a0) = r0 + gamma * max_a Q[s1,a]
      var poss = L.env.allowedActions(s1);
      var qmax = 0;
      for(var i=0,n=poss.length;i<n;i++) {
        var s1a = poss[i] * L.ns + s1;
        var qval = L.Q[s1a];
        if(i === 0 || qval > qmax) { qmax = qval; }
      }
      var target = r0 + L.gamma * qmax;
    } else if(L.update === 'sarsa') {
      // SARSA target is Q(s0,a0) = r0 + gamma * Q[s1,a1]
      var s1a1 = a1 * L.ns + s1;
      var target = r0 + L.gamma * L.Q[s1a1];
    }

    if(lambda > 0) {
      // perform an eligibility trace update
      if(L.replacing_traces) {
        L.e[sa] = 1;
      } else {
        L.e[sa] += 1;
      }
      var edecay = lambda * L.gamma;
      var state_update = zeros(L.ns);
      for(var s=0;s<L.ns;s++) {
        var poss = L.env.allowedActions(s);
        for(var i=0;i<poss.length;i++) {
          var a = poss[i];
          var saloop = a * L.ns + s;
          var esa = L.e[saloop];
          var update = L.alpha * esa * (target - L.Q[saloop]);
          L.Q[saloop] += update;
          L.updatePriority(s, a, update);
          L.e[saloop] *= edecay;
          var u = Math.abs(update);
          if(u > state_update[s]) { state_update[s] = u; }
        }
      }
      for(var s=0;s<L.ns;s++) {
        if(state_update[s] > 1e-5) { // save efficiency here
          TDAgent.code.updatePolicy(L,s);
        }
      }
      if(L.explored && L.update === 'qlearn') {
        // have to wipe the trace since q learning is off-policy :(
        L.e = zeros(L.ns * L.na);
      }
    } else {
      // simpler and faster update without eligibility trace
      // update Q[sa] towards it with some step size
      var update = L.alpha * (target - L.Q[sa]);
      L.Q[sa] += update;
      TDAgent.code.updatePriority(L,s0, a0, update);
      // update the policy to reflect the change (if appropriate)
      TDAgent.code.updatePolicy(L,s0);
    }
  },
  updatePriority: function(L,s,a,u) {
    // used in planning. Invoked when Q[sa] += update
    // we should find all states that lead to (s,a) and upgrade their priority
    // of being update in the next planning step
    u = Math.abs(u);
    if(u < 1e-5) { return; } // for efficiency skip small updates
    if(L.planN === 0) { return; } // there is no planning to be done, skip.
    for(var si=0;si<L.ns;si++) {
      // note we are also iterating over impossible actions at all states,
      // but this should be okay because their env_model_s should simply be -1
      // as initialized, so they will never be predicted to point to any state
      // because they will never be observed, and hence never be added to the model
      for(var ai=0;ai<L.na;ai++) {
        var siai = ai * L.ns + si;
        if(L.env_model_s[siai] === s) {
          // this state leads to s, add it to priority queue
          L.pq[siai] += u;
        }
      }
    }
  },
  updatePolicy: function(L,s) {
    var poss = L.env.allowedActions(s);
    // set policy at s to be the action that achieves max_a Q(s,a)
    // first find the maxy Q values
    var qmax, nmax;
    var qs = [];
    for(var i=0,n=poss.length;i<n;i++) {
      var a = poss[i];
      var qval = L.Q[a*L.ns+s];
      qs.push(qval);
      if(i === 0 || qval > qmax) { qmax = qval; nmax = 1; }
      else if(qval === qmax) { nmax += 1; }
    }
    // now update the policy smoothly towards the argmaxy actions
    var psum = 0.0;
    for(var i=0,n=poss.length;i<n;i++) {
      var a = poss[i];
      var target = (qs[i] === qmax) ? 1.0/nmax : 0.0;
      var ix = a*L.ns+s;
      if(L.smooth_policy_update) {
        // slightly hacky :p
        L.P[ix] += L.beta * (target - L.P[ix]);
        psum += L.P[ix];
      } else {
        // set hard target
        L.P[ix] = target;
      }
    }
    if(L.smooth_policy_update) {
      // renomalize P if we're using smooth policy updates
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        L.P[a*L.ns+s] /= psum;
      }
    }
  }
}


var DQNAgent = function(env, opt) {
  var L = {}
  L.gamma = getopt(opt, 'gamma', 0.75); // future reward discount factor
  L.epsilon = getopt(opt, 'epsilon', 0.1); // for epsilon-greedy policy
  L.alpha = getopt(opt, 'alpha', 0.01); // value function learning rate

  L.experience_add_every = getopt(opt, 'experience_add_every', 25); // number of time steps before we add another experience to replay memory
  L.experience_size = getopt(opt, 'experience_size', 5000); // size of experience replay
  L.learning_steps_per_iteration = getopt(opt, 'learning_steps_per_iteration', 10);
  L.tderror_clamp = getopt(opt, 'tderror_clamp', 1.0); 

  L.num_hidden_units =  getopt(opt, 'num_hidden_units', 100); 

  L.env = env;
  DQNAgent.code.reset(L);
  return L
}
DQNAgent.code = {
  reset: function(L) {
    L.nh = L.num_hidden_units; // number of hidden units
    L.ns = L.env.getNumStates();
    L.na = L.env.getMaxNumActions();

    // nets are hardcoded for now as key (str) -> Mat
    // not proud of this. better solution is to have a whole Net object
    // on top of Mats, but for now sticking with this
    L.net = {};
    L.net.W1 = R.RandMat(L.nh, L.ns, 0, 0.01);
    L.net.b1 = R.Mat(L.nh, 1, 0, 0.01);
    L.net.W2 = R.RandMat(L.na, L.nh, 0, 0.01);
    L.net.b2 = R.Mat(L.na, 1, 0, 0.01);

    L.exp = []; // experience
    L.expi = 0; // where to insert

    L.t = 0;

    L.r0 = null;
    L.s0 = null;
    L.s1 = null;
    L.a0 = null;
    L.a1 = null;

    L.tderror = 0; // for visualization only...
  },
  toJSON: function(L) {
    // save function
    var j = {};
    j.nh = L.nh;
    j.ns = L.ns;
    j.na = L.na;
    j.net = R.netToJSON(L.net);
    return j;
  },
  fromJSON: function(L,j) {
    // load function
    L.nh = j.nh;
    L.ns = j.ns;
    L.na = j.na;
    L.net = R.netFromJSON(j.net);
  },
  forwardQ: function(L, net, s, needs_backprop) {
    var G = R.Graph(needs_backprop);
    var a1mat = Graph.code.add(G,Graph.code.mul(G,net.W1, s), net.b1);
    var h1mat = Graph.code.tanh(G,a1mat);
    var a2mat = Graph.code.add(G,Graph.code.mul(G,net.W2, h1mat), net.b2);
    L.lastG = G; // back this up. Kind of hacky isn't it
    return a2mat;
  },
  act: function(L,slist) {
    // convert to a Mat column vector
    var s = R.Mat(L.ns, 1);
    Mat.code.setFrom(s,slist);

    // epsilon greedy policy
    if(Math.random() < L.epsilon) {
      var a = randi(0, L.na);
    } else {
      // greedy wrt Q function
      var amat = DQNAgent.code.forwardQ(L,L.net, s, false);
      var a = R.maxi(amat.w); // returns index of argmax action
    }

    // shift state memory
    L.s0 = L.s1;
    L.a0 = L.a1;
    L.s1 = s;
    L.a1 = a;

    return a;
  },
  learn: function(L,r1) {
    // perform an update on Q function
    if(!(L.r0 == null) && L.alpha > 0) {

      // learn from this tuple to get a sense of how "surprising" it is to the agent
      var tderror = DQNAgent.code.learnFromTuple(L, L.s0, L.a0, L.r0, L.s1, L.a1);
      L.tderror = tderror; // a measure of surprise
      // decide if we should keep this experience in the replay
      if(L.t % L.experience_add_every === 0) {
        L.exp[L.expi] = [L.s0, L.a0, L.r0, L.s1, L.a1];
        L.expi += 1;
        if(L.expi > L.experience_size) { L.expi = 0; } // roll over when we run out
      }
      L.t += 1;

      // sample some additional experience from replay memory and learn from it
      for(var k=0;k<L.learning_steps_per_iteration;k++) {
        var ri = randi(0, L.exp.length); // todo: priority sweeps?
        var e = L.exp[ri];
        DQNAgent.code.learnFromTuple(L, e[0], e[1], e[2], e[3], e[4])
      }
    }
    L.r0 = r1; // store for next update
  },
  learnFromTuple: function(L, s0, a0, r0, s1, a1) {
    // want: Q(s,a) = r + gamma * max_a' Q(s',a')

    // compute the target Q value
    var tmat = DQNAgent.code.forwardQ(L, L.net, s1, false);
    var qmax = r0 + L.gamma * tmat.w[R.maxi(tmat.w)];

    // now predict
    var pred = DQNAgent.code.forwardQ(L, L.net, s0, true);

    var tderror = pred.w[a0] - qmax;
    var clamp = L.tderror_clamp;
    if(Math.abs(tderror) > clamp) {  // huber loss to robustify
      if(tderror > clamp) tderror = clamp;
      if(tderror < -clamp) tderror = -clamp;
    }
    pred.dw[a0] = tderror;

    Graph.code.backward( L.lastG); // compute gradients on net params

    // update net
    R.updateNet(L.net, L.alpha);
    return tderror;
  }
}



// exports
module.exports.DPAgent = DPAgent;
module.exports.TDAgent = TDAgent;
module.exports.DQNAgent = DQNAgent;
//module.exports.SimpleReinforceAgent = SimpleReinforceAgent;
//module.exports.RecurrentReinforceAgent = RecurrentReinforceAgent;
//module.exports.DeterministPG = DeterministPG;


};
BundleModuleCode['plugins/ml/rt']=function (module,exports){
//     wink-regression-tree
//     Decision Tree to predict the value of a continuous
//     target variable
//
//     https://github.com/winkjs/wink-regression-tree
//
//     Copyright (C) 2017-18  GRAYPE Systems Private Limited
//
//     This file is part of “wink-regression-tree”.
//
//     Permission is hereby granted, free of charge, to any person obtaining a
//     copy of this software and associated documentation files (the "Software"),
//     to deal in the Software without restriction, including without limitation
//     and/or sell copies of the Software, and to permit persons to whom the
//     Software is furnished to do so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included
//     in all copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//     DEALINGS IN THE SOFTWARE.

/* eslint no-continue: 0 */

var helpers = Require( 'ml/helpers' );
var stdevEPSILON = Math.pow( 2, -48 );

// ### regressionTree
/**
 *
 * Creates an instance of a {@link RegressionTree}.
 *
 * @return {RegressionTree} object conatining set of API methods for tasks like configuration,
 * data ingestion, learning, and prediction etc.
 * @example
 * // Load wink regression tree.
 * var regressionTree = require( 'wink-regression-tree' );
 * // Create your instance of regression tree.
 * var myRT = regressionTree();
*/
var regressionTree = function () {
  // Columns configuration supplied to the `defineConfig()` function.
  var columnsConfig;
  // Columns definition created from the `columnsConfig` supplied to the `defineConfig()`
  // method.
  var columnsDefn;
  // Create configuration object.
  var config = Object.create( null );
  // The **w**ink **r**egression tree.
  var wrTree = Object.create( null );
  // Xformed Column id to input column id map.
  var xc2cMap = [];
  // Xformed data, where categorical variables are encoded by a numeric code. Useful
  // in reduction of memory load.
  var xdata = [];
  // Parameters used for evaluation.
  var evalParams = Object.create( null );
  // Remember the target column name in this.
  var target;
  // Current rules tree object version.
  var winkRulesTreeVersion = 'WRT 1.0.0';

  /**
   * @classdesc Regression tree class
   * @class RegressionTree
   * @hideconstructor
   */
  var methods = Object.create( null );

  // ### initEvalParams
  /**
   *
   * Initializes all the properties of `evalParams`.
   *
   * @return {undefined} nothing!
   * @private
  */
  var initEvalParams = function () {
    // Setup evaluation parameters.
    evalParams.size = 0;
    evalParams.mean = 0;
    evalParams.prevMean = 0;
    // Grand Sum of Squared Deviations from the Mean, prior to prediction.
    evalParams.gssdm = 0;
    // Sum of Squared Deviations from the Mean, post prediction
    evalParams.ssdm = 0;
  }; // initEvalParams()

  // ### initColsDefn
  /**
   *
   * Initializes the columns' definition by cloning the input `cols` and by adding
   * a struncture containing `map` and `nextCode` (next unique value's code)
   * for every categorical column that is not excluded fom processing.
   *
   * @param {object[]} cols — each object specifies 4 properties viz. (a) `name`;
   * (b) type in terms of `categorical` as `true or false`, where `false` indicates a
   * continuous variable; (c) `exclude`, which is set to true if the column
   * has to be excluded from training; and (d) `target`, which is set to true for
   * the column whose value is to be predicted.
   * @return {object[]} cloned `cols`, where each element gets 2 addtitional
   * properties viz. `map` and the `nextCode` that is initialized to **0**.
   * @private
  */
  var initColsDefn = function ( cols ) {
    // Clone the incoming `cols`
    var cc = JSON.parse( JSON.stringify( cols ) );
    // Intialize the included categorical columns with empty `map` object
    // and `nextCode` that will be assigned to the next unique value encountered.
    for ( var i = 0, imax = cc.length; i < imax; i += 1 ) {
      if ( cc[ i ].categorical && !cc[ i ].exclude ) {
        cc[ i ].nextCode = 0;
        cc[ i ].map = Object.create( null );
        cc[ i ].invertedMap = [];
      }
      // Remember the target column name.
      if ( cc[ i ].target ) {
        target = cc[ i ].name;
      }
    }
    // Return the cloned & initialized collumns — `cc`.
    return cc;
  }; // initColsDefn()

  // ### transformRow
  /**
   *
   * It transforms the **included categorical** column's data of `row` into coded
   * values using `colsDefn`. This encoding reduces the memory space requirements.
   * If a new unique value is encountered, the `colsDefn.map` & `colsDefn.nextCode`
   *  values are accordingly updated.
   *
   * @param {array} row — contains data i.e. column values for a single row.
   * @param {object} colsDefn — columns' definition data structure.
   * @return {array} transformed row with encoded categorical column values.
   * @private
  */
  var transformRow = function ( row, colsDefn ) {
    // Transformed row builds up in this variable.
    var xRow = [ ];
    // Map, inverted Map and target value.
    var invertedMap, map, tv;

    for ( var i = 0, imax = row.length; i < imax; i += 1 ) {
      // Categorical and Included?
      if ( colsDefn[ i ].categorical && !colsDefn[ i ].exclude ) {
        map = colsDefn[ i ].map;
        invertedMap = colsDefn[ i ].invertedMap;
        // Map defined for row's element in question?
        if ( map[ row[ i ] ] === undefined ) {
          // Not! Update the `map` & the `invertedMap`.
          map[ row[ i ] ] = colsDefn[ i ].nextCode;
          invertedMap.push( row[ i ] );
          colsDefn[ i ].nextCode += 1;
        }
      }
      // Transform value.
      if ( colsDefn[ i ].target ) {
        // Remember target's transformed value, it will be pushed as the last
        // element in the `xRow`.
        tv = ( colsDefn[ i ].categorical ) ? map[ row[ i ] ] : row[ i ];
      } else if ( !colsDefn[ i ].exclude ) {
        // Ensure exclusion.
        if (map)
          xRow.push( map[ row[ i ] ] );
        else // @blab+ non-catergorical variables
          xRow.push( row[ i ] );
      }
    }
    // Target's value is always the last element in `xRow`.
    xRow.push( tv );
    return xRow;
  }; // transformRow()

  // ### createCandidates
  /**
   *
   * It creates empty data structure for each potential candidate column.
   *
   * @param {array} cols2p — array of indexes of columns to be processed.
   * @return {object} containing further empty objects indexed by each columns
   * specified in the `cols2p` array.
   * @private
  */
  var createCandidates = function ( cols2p ) {
    // Create `candidates` object.
    var candidates = Object.create( null );
    var ci;
    // Each Column specific data structure pertaining to every unique value goes here.
    candidates.columns = Object.create( null );
    // List of indexes of columns, to avoid calls to `Object.keys()` on candidate columns.
    candidates.list = [];
    for ( var i = 0, imax = cols2p.length; i < imax; i += 1 ) {
      ci = cols2p[ i ];
      // Push this index in to the list.
      candidates.list.push( ci );
      // Create an empty structure for this column by its index.
      candidates.columns[ ci ] = Object.create( null );
    }
    return candidates;
  }; // createCandidates()

  // ### computeMeanDelta
  /**
   *
   * Computes the delta mean value from the next `data`; this delta may be used to
   * update mean by additing it to the current mean.
   *
   * @param {number} data — data used to compute the delta.
   * @param {number} currMean — current value of mean from which delta is computed
   * using the `data`.
   * @param {number} size — the number of `data` items encountered so far.
   * @return {number} the delta mean.
   * @private
  */
  var computeMeanDelta = function ( data, currMean, size ) {
    return ( data - currMean ) / ( size );
  }; // computeMeanDelta()

  // ### computeVarianceXnDelta
  /**
   *
   * Computes the delta varianceXn value from the next `data`; this delta may be
   * used to update varianceXn by additing it to the current varianceXn. Note,
   * varianceXn is nothing but *sum of squared devaitions from the mean*.
   *
   * @param {number} data — data used to compute the delta.
   * @param {number} currMean — current value of mean and
   * @param {number} prevMean — the previous value of mean; using these delta is
   * computed using the `data`.
   * @return {number} the delta varianceXn.
   * @private
  */
  var computeVarianceXnDelta = function ( data, currMean, prevMean ) {
    return ( data - prevMean ) * ( data - currMean );
  }; // computeVarianceXnDelta()

  // ### computeStdev
  /**
   *
   * Computes the standard deviation from `varianceXn` and `size` after applying
   * Bessel's correction.
   *
   * @param {number} varianceXn — the sum of squared devaitions from the mean.
   * @param {number} size — the number of items.
   * @return {number} the standard deviation.
   * @private
  */
  var computeStdev = function ( varianceXn, size ) {
    // Apply Bessel's correction for a better estimate of population standard
    // deviation.
    return ( size > 1 ) ? Math.sqrt( varianceXn / ( size - 1 ) ) : 0;
  }; // computeStdev()

  // ### computePercentageVarianceReduction
  /**
   *
   * Computes percentage reduction in variance in split children from the parent.
   *
   * @param {number} varianceXn — the sum of squared devaitions from the mean.
   * @param {number} size — the number of items.
   * @param {number} weightedSumOfVar — weighted sum of variance of every child node.
   * @return {number} the percentage reduction in variance.
   * @private
  */
  var computePercentageVarianceReduction = function ( varianceXn, size, weightedSumOfVar ) {
    return ( ( ( varianceXn / size ) - weightedSumOfVar ) * 100 / ( varianceXn / size ) );
  }; // computePercentageVarianceReduction()

  // ### updateVarianceXn
  /**
   *
   * Incrementally updates the varianceXn of `targetsValue`  for the `c2psValue` of column to
   * process — `c2p` in `candidates` for the row pointed by `rowsIndex`.
   *
   * @param {object} candidates — data structure containing varianceXn for every
   * column's applicable unique values.
   * @param {number} c2p — the column to be processed.
   * @param {string} c2psValue — the column to be processed's value.
   * @param {number} rowsIndex — index of the data row to be used.
   * @param {number} targetsValue — target's value to be used for updating varianceXn.
   * @return {boolean} always true.
   * @private
  */
  var updateVarianceXn = function ( candidates, c2p, c2psValue, rowsIndex, targetsValue ) {
    // The candidates' colums where varianceXn will be updated.
    var cc2p = candidates.columns[ c2p ];
    // Create a place holder for `c2psValue`, provided it is being encountered
    // for the first time.
    if ( cc2p[ c2psValue ] === undefined ) {
      cc2p[ c2psValue ] = Object.create( null );
      // Mean of `targetsValue` encountered so far.
      cc2p[ c2psValue ].mean = 0;
      // The variance multiplied by `n or size`.
      cc2p[ c2psValue ].varianceXn = 0;
      // The count or size of values processed so far; will match with `index`
      // array size.
      cc2p[ c2psValue ].size = 0;
      // INdex of rows containing this specific value i.e. `c2psValue`.
      cc2p[ c2psValue ].index = [];
    }
    // Update varianceXn, etc.
    var prevMean = cc2p[ c2psValue ].mean;
    cc2p[ c2psValue ].size += 1;
    cc2p[ c2psValue ].mean += computeMeanDelta( targetsValue, cc2p[ c2psValue ].mean, cc2p[ c2psValue ].size );
    // ( targetsValue - cc2p[ c2psValue ].mean ) / ( cc2p[ c2psValue ].size );
    cc2p[ c2psValue ].varianceXn += computeVarianceXnDelta( targetsValue, cc2p[ c2psValue ].mean, prevMean );
    // ( targetsValue - prevMean ) * ( targetsValue - cc2p[ c2psValue ].mean );
    cc2p[ c2psValue ].index.push( rowsIndex );
    return true;
  }; // updateVarianceXn()

  // ### processRow
  /**
   *
   * It requires a `row` of data, columns to be processed —`c2p`, the `colsDefn`,
   * and a `node` that captures the column-wise varianceXn & mean for every unique
   * of the a column.
   *
   * @param {array} row — single row of transformed data that needs to be processed.
   * @param {number} rowsIndex — index of the row being passed.
   * @param {object} candidates — for split, contains all the statistic.
   * @param {function} updateFn — updates the statistic in `candidates`.
   * @return {object[]} ???
   * @private
  */
  var processRow = function ( row, rowsIndex, candidates, updateFn ) {
    // Single column to process from the array `cols2p`.
    var c2p;
    var indexOfTarget = row.length - 1;
    for ( var i = 0, imax = candidates.list.length; i < imax; i += 1 ) {
      c2p = candidates.list[ i ];
      updateFn( candidates, c2p, row[ c2p ], rowsIndex, row[ indexOfTarget ] );
    }
  }; // processRow()

  // ### selectBestSplit
  /**
   *
   * Finds the best candidate column for split on the basis of maximum reduction
   * in variance (impurity or maximum gain).
   *
   * @param {object} candidates — columns from where the best candidate for split
   * is selected.
   * @return {object} containing the best `col` and the corresponding wieghted
   * `sum` of squared deviation from mean for each unique value.
   * @private
  */
  var selectBestSplit = function ( candidates ) {
    // Used in for-in loop: unique values (`uvs`) in a `col`.
    var col, uvs;
    // Sum of `varianceXn * size` for each `uvs` in a `col`; and its size.
    var size, sum;
    // Used to compute average children item for minAvgChildrenItems config.
    var counter, meanSize;
    // Minimum Sum and the Best Column.
    var bestCol, minSum;

    minSum = Infinity;
    bestCol = -1;
    for ( col in candidates.columns ) { // eslint-disable-line guard-for-in
      // Initialize `sum` and `size` for this `col`.
      sum = 0;
      size = 0;
      // And also counter & meanSize.
      counter = 0;
      meanSize = 0;
      for ( uvs in candidates.columns[ col ] ) { // eslint-disable-line guard-for-in
        size += candidates.columns[ col ][ uvs ].size;
        // Compute average (mean) children items.
        counter += 1;
        meanSize += computeMeanDelta( candidates.columns[ col ][ uvs ].size, meanSize, counter );
        // Compute weighted sum; will divide by sum after the loop finishes to normalize.
        // Recall, `varianceXn` is variance multiplied by items.
        sum += ( candidates.columns[ col ][ uvs ].varianceXn /* candidates.columns[ col ][ uvs ].size */ );
      }
      // Normalize - this will yield weighted sum of variances.
      sum /= size;
      // Update minumum only if `meanSize` is above the defined threshold.
      if ( ( sum < minSum ) && ( meanSize > config.minAvgChildrenItems ) ) {
        minSum = sum;
        bestCol = col;
      }
    }
    // If the best column is not found, return `undefined`.
    return ( bestCol === -1 ) ? undefined : { col: +bestCol, sum: minSum };
  }; // selectBestSplit()

  // ### reducer
  /**
   *
   * Helper function for `JS array reduce`; used to merge two arrays.
   *
   * @param {object} acc — accumulator i.e. the array containing the merged values.
   * @param {object} cv — current value i.e. one array element to be pushed.
   * @return {object} collapsed column.
   * @private
  */
  var reducer = function ( acc, cv ) {
    acc.push( cv );
    return ( acc );
  }; // reducer();

  // ### collapseNodesInCol
  /**
   *
   * Iterates through every candidate column in `cc`. For each candidate column,
   * it collapses all nodes with `size < config.minLeafNodeItems` into a single
   * node referred to as `$$other_values`.
   *
   * @param {object} col — candidate columns that are iterated through for a
   * possible collapse.
   * @return {object} collapsed column.
   * @private
  */
  var collapseNodesInCol = function ( col ) {
    // Collapsed column
    var collapsedCol = Object.create( null );
    // All `nodes < config.minLeafNodeItems` will be collapsed into this.
    var others = Object.create( null );
    // Unique Value in `col`
    var uv;
    // Helpers!
    var collapsedOccurred = false;
    // Combined mean, temp object holder.
    var meanc, obj;

    others.size = 0;
    others.mean = 0;
    others.varianceXn = 0;
    others.index = [];
    others.collapsedNodes = 0;
    // Iterate through every unique value in the `col` object.
    for ( uv in col ) { // eslint-disable-line guard-for-in
      obj = col[ uv ];
      if ( obj.size < config.minLeafNodeItems ) {
        collapsedOccurred = true;
        others.collapsedNodes += 1;
        // Combine means and remember it for a while before updating.
        meanc = ( ( others.mean * others.size ) + ( obj.mean * obj.size ) ) / ( others.size + obj.size );
        // Combine `variances * size` i.e. `varianceXn`.
        others.varianceXn = others.varianceXn +
                            obj.varianceXn +
                            ( others.size * ( others.mean - meanc ) * ( others.mean - meanc ) ) +
                            ( obj.size * ( obj.mean - meanc ) * ( obj.mean - meanc ) );
        // Now update combined means!
        others.mean = meanc;
        // Update size.
        others.size += obj.size;
        // Finally merge both indexes.
        others.index = obj.index.reduce( reducer, others.index );
      } else {
        collapsedCol[ uv ] = col[ uv ];
      }
    }
    // If collapse has occurred then include `$$other_values` in `collapsedCol`.
    if ( collapsedOccurred ) collapsedCol.$$other_values = others; // eslint-disable-line camelcase
    return collapsedCol;
  }; // collapseNodesInCol()

  // ### collapseNodesInCC
  /**
   *
   * Iterates through every candidate column in `cc`. For each candidate column,
   * it collapses all nodes with `size < config.minLeafNodeItems` into a single
   * node referred to as `$$other_values`.
   *
   * @param {object} cc — candidate columns that are iterated through for a
   * possible collapse.
   * @return {undefined} the void!
   * @private
  */
  var collapseNodesInCC = function ( cc ) {
    // Column Id in Candidate Columns (cc).
    var cid;
    for ( cid in cc ) { // eslint-disable-line guard-for-in
      cc[ cid ] = collapseNodesInCol( cc[ cid ] );
    }
  }; // collapseNodesInCC()


  // ### growTree
  /**
   *
   * Builds the tree recursively by maximaizing the variance reduction on each
   * split.
   *
   * @param {object} cc — candidate columns to consider for further growing the
   * tree.
   * @param {number} splitData — columns on which split occurred.
   * @param {number} colUsed4Split — column used for creating the `splitData`.
   * @param {object} node — node of the tree, from where tree may be grown further.
   * @param {number} depth — of the tree so far.
   * @return {object} the tree!
   * @private
  */
  var growTree = function ( cc, splitData, colUsed4Split, node, depth ) {
    // Maximum defined depth reached?
    if ( depth > config.maxDepth ) {
      // Yes, return.
      return;
    }

    var cCols;
    var colsLeft;
    var bs, uniqVal;
    var varianceReduction;
    var child;
    // Helper variables
    var actualValue, index, j, k, kmax;
    node.branches = Object.create( null );
    for ( uniqVal in splitData ) { // eslint-disable-line guard-for-in
      // Node always has enough items as collapse would have already occurred.
      // @blab+ address non-categorical values, too
      var candidate = columnsDefn[ xc2cMap[ colUsed4Split ] ];
      if (uniqVal === '$$other_values' || !candidate.invertedMap) actualValue = uniqVal;
      else actualValue =  candidate.invertedMap[ +uniqVal ];
      // actualValue = ( uniqVal === '$$other_values' ) ? uniqVal : columnsDefn[ xc2cMap[ colUsed4Split ] ].invertedMap[ +uniqVal ];
      child = node.branches[ actualValue ] = Object.create( null );
      child.size = splitData[ uniqVal ].size;
      child.mean = splitData[ uniqVal ].mean;
      child.stdev = computeStdev( splitData[ uniqVal ].varianceXn, splitData[ uniqVal ].size );
      // Add collapsed node count, if collapsed had occurred: more for reference only.
      // It has no predictionn value.
      if ( splitData[ uniqVal ].collapsedNodes !== undefined ) child.collapsedNodes = splitData[ uniqVal ].collapsedNodes;
      // Create candidate colums for this node. These will be used to obtain bestCol
      // split as per the `config`.
      cCols = createCandidates( cc );
      index = splitData[ uniqVal ].index;
      // Does it have enough items to proceed with split?
      if ( index.length <= config.minSplitCandidateItems || child.stdev < stdevEPSILON ) {
        // No! continue with the iteration with the next `uniqVal`.
        continue;
      }
      // Attempt split.
      for ( k = 0, kmax = index.length; k < kmax; k += 1 ) {
        processRow( xdata[ index[ k ] ], index[ k ], cCols, updateVarianceXn );
      }
      // Node that contain less than `config.minLeafNodeItems` are collapsed here.
      collapseNodesInCC(cCols.columns);
      bs = selectBestSplit( cCols );
      if ( bs === undefined ) {
        // No best column found, coninue with the next one!
        continue;
      }
      varianceReduction = computePercentageVarianceReduction( splitData[ uniqVal ].varianceXn, splitData[ uniqVal ].size, bs.sum );
      // Reasonable variance reduction?
      if ( varianceReduction < config.minPercentVarianceReduction ) {
        // No! continue with the iteration with the next `uniqVal`.
        continue;
      }
      // Yes, split possible! Make a list of left columns by removing the columns
      // found for splitting.
      colsLeft = [];
      for ( j = 0; j < cc.length; j += 1 ) {
        if ( cc[ j ] !== bs.col ) colsLeft.push( cc[ j ] );
      }
      // Recurse!
      child.colUsed4Split = columnsDefn[xc2cMap[bs.col]].name;
      child.varianceReduction = varianceReduction;
      growTree( colsLeft, cCols.columns[ bs.col ], bs.col, child, ( depth + 1 ) );
    }
  }; // growTree()

  // ### countRules
  /**
   *
   * Counts the number of rules generated from a rules tree and updates the final
   * number in the root node of the tree.
   *
   * @param {object} tree — the rules tree.
   * @return {undefined} or void!
   * @private
  */
  var countRules = function ( tree ) {
    var subTree = tree.branches;
    for ( var node in subTree ) {
      if ( subTree[ node ].branches !== undefined && Object.keys( subTree[ node ].branches ).length > 0 ) {
        countRules( subTree[ node ] );
      } else wrTree.rulesLearned += 1;
    }
  }; // countRules()

  // ### defineConfig
  /**
   *
   * Defines the configuration required to read the input data and to generates
   * the regression tree.
   *
   * @method RegressionTree#defineConfig
   * @param {object[]} inputDataCols each object in this array defines a column of input
   * data in the same sequence in which data will be supplied to `ingest().` It is
   * defined in terms of the following details:
   * @param {string} inputDataCols[].name of the column.
   * @param {boolean} inputDataCols[].categorical defines column's data type — `true` indicating categorical
   * **or** `false` indicating numeric; currently numeric data type is not supported.
   * @param {boolean} [inputDataCols[].exclude=false] used to exclude a column during tree building.
   * @param {boolean} [inputDataCols[].target=false] is set to `true` only for the target column, whose
   * value needs to be predicted. Note this column must be a numeric column.
   * @param {object} tree contains key value pairs of the following regression
   * tree's parameters:
   * @param {number} [tree.maxDepth=20] is the maximum depth of the tree after which
   * learning stops.
   * @param {number} [tree.minPercentVarianceReduction=10] is the minmum variance reduction
   * required for a split to occur.
   * @param {number} [tree.minSplitCandidateItems=50] the minimum items that must be present
   * at a node for it to be split further, even after the `minPercentVarianceReduction`
   * target has been achieved.
   * @param {number} [tree.minLeafNodeItems=10] is the minimum number of items that
   * must be present at a leaf node to be retained as an independent node. Nodes with
   * less than this value size are merged together.
   * @param {number} [tree.minAvgChildrenItems=2] the average number of items
   * across children must be greater than this number, for a column to become a candidate
   * for split. A higher number will discourage splits that creates many branches
   * with each child node containing fewer items.
   * @return {number} number of columns defined.
   * @example
   * // Define each column.
   * var columns = [
   *   { name: 'model', categorical: true, exclude: true },
   *   { name: 'mpg', categorical: false, target: true },
   *   { name: 'cylinders', categorical: true },
   *   { name: 'displacement', categorical: true, exclude: false },
   *   { name: 'horsepower', categorical: true, exclude: false },
   *   { name: 'weight', categorical: true, exclude: false },
   *   { name: 'acceleration', categorical: true, exclude: false },
   *   { name: 'year', categorical: true, exclude: true },
   *   { name: 'origin', categorical: true, exclude: false  }
   * ];
   * // Define parameters to grow the tree.
   * var treeParams = {
   *   minPercentVarianceReduction: 2.5,
   *   minLeafNodeItems: 10,
   *   minSplitCandidateItems: 30,
   *   minAvgChildrenItems: 3
   * };
   * // Define the configuration using above 2 variables.
   * myRT.defineConfig( columns, treeParams );
   * // -> 8
  */
  var defineConfig = function ( inputDataCols, tree ) {
    config.maxDepth = tree.maxDepth || config.maxDepth;
    config.minPercentVarianceReduction = tree.minPercentVarianceReduction || config.minPercentVarianceReduction;
    config.minSplitCandidateItems = tree.minSplitCandidateItems || config.minSplitCandidateItems;
    config.minLeafNodeItems = tree.minLeafNodeItems || config.minLeafNodeItems;
    config.minAvgChildrenItems = tree.minAvgChildrenItems || config.minAvgChildrenItems;
    columnsConfig = inputDataCols;
    columnsDefn = initColsDefn( columnsConfig );
    return inputDataCols.length;
  }; // defineConfig();

  // ### ingest
  /**
   *
   * Ingests one row of the data at a time. It is specially useful for reading
   * data in an asynchronus manner, where this may be used as a call back function
   * on every row read event.
   *
   * @method RegressionTree#ingest
   * @param {array} row one row of the data to be ingested; column values
   * should be in the same sequence in which they are defined in data configuration
   * via `defineConfig()`.
   * @return {boolean} always `true`.
   * @throws {error} if number of elements in `row` don't match with the
   * number of columns defined.
   * @example
   * // Load cars training data set.
   * var cars = require( 'wink-regression-tree/sample-data/cars.json' );
   * // Ingest the data.
   * cars.forEach( function ( row ) {
   *   myRT.ingest( row );
   * } );
  */
  var ingest = function ( row ) {
    if ( row.length === columnsConfig.length ) {
      xdata.push( transformRow( row, columnsDefn ) );
    } else {
      throw Error( 'winkRT: ingest is expecting ' + columnsConfig.length + ' elements instead found: ' + row.length );
    }

    return true;
  }; // ingest()

  // ### learn
  /**
   *
   * Learns from the ingested data and generates the rule tree that is used to
   * `predict()` the value of target variable from the input. It requires at least
   * 60 data rows to initiate meaningful learning.
   *
   * @method RegressionTree#learn
   * @return {number} number of rules learned from the input data.
   * @throws {error} if number of rows in the ingested data are <60.
   * @example
   * myRT.learn();
   * // -> Number of rules learned
  */
  var learn = function ( ) {
    if ( xdata.length < 60 ) {
      throw Error( 'winkRT: learn is expecting at least 60 rows of data, instead found: ' + xdata.length );
    }
    // Candidate columns list
    var candidateCols = [];
    // Candidate columns created using above list.
    var cndts;
    // Required for the root node.
    var rootsMean = 0;
    var rootsVarianceXn = 0;
    var prevRootsMean;
    // Index of the target variable (Y).
    var indexOfTarget;
    // Object containing best split info in terms of the column and the
    // weighted `sum` of variance.
    var bestSplit;
    // Updated candidate columns list after split.
    var updatedCandidateCols = [];
    // Helper variables
    var i, imax;
    var k = 0;

    // Create candidate columns list & `xc2cMap`.
    for ( i = 0, imax = columnsConfig.length; i < imax; i += 1 ) {
      if ( !columnsConfig[ i ].exclude ) {
        if ( !columnsConfig[ i ].target ) {
          xc2cMap.push( i );
          candidateCols.push( k );
          k += 1;
        }
      }
    }

    cndts = createCandidates( candidateCols );

    indexOfTarget = xdata[ 0 ].length - 1;
    // Process every row as this is the root level.
    for ( i = 0; i < xdata.length; i += 1 ) {
      processRow( xdata[ i ], i, cndts, updateVarianceXn );
      prevRootsMean = rootsMean;
      rootsMean += computeMeanDelta( xdata[ i ][ indexOfTarget ], rootsMean, ( i + 1 ) );
      rootsVarianceXn += computeVarianceXnDelta( xdata[ i ][ indexOfTarget ], rootsMean, prevRootsMean );
    }
    // Node that contain less than `config.minLeafNodeItems` are collapsed here.
    collapseNodesInCC(cndts.columns);
    // Define minimal root node stuff here itself.
    wrTree.version = winkRulesTreeVersion;
    wrTree.size = xdata.length;
    wrTree.mean = rootsMean;
    wrTree.stdev = computeStdev( rootsVarianceXn, wrTree.size );
    // Attempt to grow tree if standard deviation is large enough!
    if ( wrTree.stdev > stdevEPSILON ) {
      bestSplit = selectBestSplit( cndts );
      if ( bestSplit === undefined ) {
        // Opps, no worthy column available - return the root!
        wrTree.rulesLearned = 0;
        countRules( wrTree );
        return wrTree.rulesLearned;
      }
      // Find the updated list of candidate columsn after the split.
      for ( i = 0; i < candidateCols.length; i += 1 ) {
        if ( candidateCols[ i ] !== bestSplit.col ) updatedCandidateCols.push( candidateCols[ i ] );
      }
      // Define the balance stuff as a split has been found!
      wrTree.colUsed4Split = columnsDefn[xc2cMap[bestSplit.col]].name;
      wrTree.varianceReduction = computePercentageVarianceReduction( rootsVarianceXn, wrTree.size, bestSplit.sum );
      // Call recursive function, `growTree()`.
      growTree( updatedCandidateCols, cndts.columns[ bestSplit.col ], bestSplit.col, wrTree, 1 );
    }
    wrTree.rulesLearned = 0;
    countRules( wrTree );
    return wrTree.rulesLearned;
  }; // learn()

  // ### navigateRules
  /**
   *
   * Recursively navigaes the rule tree to arrive at a prediction for the
   * `input` data. If the value of a columm in the input data, required during
   * the prediction is missing, it throws an error provided the function
   * `f` is not defined. Otherwise the name of column is passed to this function;
   * and the function is expected to handle the same.
   *
   * @param {object} input — data containing column name/value pairs; the column
   * names must the same as defined via `defineConfig()`.
   * @param {object} rules — the rules tree generated during `learn()`; on every
   * recursion a branch of tree is passed.
   * @param {function} [f=undefined] — is called once
   * a leaf node is reached during prediction with the following 4 parameters: **size,**
   * **mean** and **stdev** values at the node; an **array** of column names
   * navigated to reach the leaf and **column name** for which value is missing
   * in the input (if found). The value returned from this function becomes  the prediction.
   * @param {array} colsUsed4Prediction — columns used for prediction are pushed into this array; if
   * this is empty then it means no rules matched and prediction occurred using
   * the root node.
   * @return {number} `mean` value or whatever is returned by the `fn` function, if defined.
   * @private
  */
  var navigateRules = function ( input, rules, f, colsUsed4Prediction ) {
    // Sub-tree is present if # of branches > 0.
    var hasSubTree = helpers.object.isObject( rules.branches ) &&
                        ( ( Object.keys( rules.branches ) ).length > 0 );


    var inputHasReqdValue = false;
    var stopNavigation = true;
    var column;
    var reqdValue;

    if ( !hasSubTree ) {
      // No subTree, return!
      return (
        ( typeof f === 'function' ) ?
          f( rules.size, rules.mean, rules.stdev, colsUsed4Prediction ) :
          rules.mean
      );
    }
    // Sub-tree is present, check if the input has a value for `colUsed4Split`.
    column = rules.colUsed4Split;

    inputHasReqdValue = ( ( input[ column ] !== undefined ) &&
      ( input[ column ] !== null ) );

    if ( inputHasReqdValue ) {
      // Lookup `reqdValue` from the input.
      reqdValue = input[ column ];
      // If there is no branch corresponding to the `reqdValue` then instead of stopping
      // navigation and returning the parent's node stuff, also check if there exist
      // `$$other_values`. If such a node exist, **assume** that this `reqdValue` belongs
      // to the `$$other_values` set. The intuition is that typically other values are
      // those that have very few instances (i.e. frequency of occurrance) and
      // therefore this `reqdValue` will share characterstics with `$$other_values`.
      // However, if there is no `$$other_values` set at this level then simply return
      // parent's node stuff.
      stopNavigation = !helpers.object.isObject( rules.branches[ reqdValue ] || rules.branches.$$other_values );
    } else {
      // Input does not have the value for column.
      if ( typeof f !== 'function' ) {
        // No `f` defined, throw error.
        throw Error( 'winkRT: missing column value for the column found during prediction: ' + JSON.stringify( column ) );
      }
      // The `f` is defined, let it handle.
      return f( rules.size, rules.mean, rules.stdev, colsUsed4Prediction, column );
    }

    if ( stopNavigation ) {
      return (
        ( typeof f === 'function' ) ?
          f( rules.size, rules.mean, rules.stdev, colsUsed4Prediction, column ) :
          rules.mean
      );
    }
    // Continue navigation!
    colsUsed4Prediction.push( rules.colUsed4Split );
    return navigateRules( input, rules.branches[ reqdValue ] || rules.branches.$$other_values, f, colsUsed4Prediction );
  }; // navigateRules()

  // ### predict
  /**
   *
   * Predicts the value of target variable from the `input` using the rules tree generated by
   * `learn()`. If the value of a columm in the input data, required for
   * the prediction is missing, by defualt it throws an error. If the function
   * `fn` is defined then no error is thrown, instead the name of missing column is passed
   * to this function; and the function is expected to handle the same.
   *
   * @method RegressionTree#predict
   * @param {object} input data containing column name/value pairs; the column
   * names must the same as defined via `defineConfig()`.
   * @param {function} [modifier=undefined] is called once
   * a leaf node is reached during prediction with the following 5 parameters: **size,**
   * **mean** and **stdev** values at the node; an **array** of column names
   * navigated to reach the leaf and **column name** for which value is missing
   * in the input (`default=undefined`). The value returned from this function becomes  the prediction.
   * @return {number} `mean` value or whatever is returned by the `modifier` function, if defined.
   * @throws {error} if the `input` is not a javascript object.
   * @throws {error} if a value of a column required for prediction is missing in `input`,
   * provided `modifier` has not been defined.
   * @example
   * // Populate sample input
   * var input = {
   *   model: 'Ford Gran Torino',
   *   weight: 'very high weight',
   *   displacement: 'very large displacement',
   *   horsepower: 'extremely high power',
   *   origin: 'US',
   *   acceleration: 'slow'
   * };
   * // Attempt prediction.
   * myRT.predict( input );
   * // -> 14.3
  */
  var predict = function ( input, modifier ) {
    if ( !helpers.object.isObject( input ) ) {
      throw Error( 'winkRT: input for prediction must be an object, instead found: ' + ( typeof input ) );
    }
    var colsUsed4Prediction = [];
    return navigateRules( input, wrTree, modifier, colsUsed4Prediction );
  }; // predict()

  // ### navigateRules4Stats
  /**
   *
   * Recursively navigaes the rule tree to generate the summary by extracting the
   * level wise column hierarchy, nodes that were split on this hierarchy, min &
   * max variance reduction, etc.
   *
   * @param {object} subTree — the rules tree generated during `learn()`; on every
   * recursion a branch of tree is passed.
   * @param {object} stats — summary of min/max means and their corresponding stdevs
   * along with the overall `minSD` — minimum stdev.
   * @param {stats} colImp — contains depth wise column hierarchy, number of nodesSplit
   * and the min/max varaiance reduction at that level.
   * @param {number} depth — the current depth of the tree.
   * @param {string} ch — column's hierarchy in the unix file/folder naming style.
   * @return {undefined} nothing!
   * @private
  */
  var navigateRules4Stats = function ( subTree, stats, colImp, depth, ch ) {
    var chVal = ch;
    if ( subTree.branches && ( Object.keys( subTree.branches ) ).length > 0 ) {
      // Update column's hierarchy in unix styled path names.
      chVal += '/' + subTree.colUsed4Split;
      // Initialize stats at the current `depth` and `ch` level.
      colImp[ depth ] = colImp[ depth ] || Object.create( null );
      if ( colImp[ depth ][ chVal ] === undefined ) {
        colImp[ depth ][ chVal ] = Object.create( null );
        colImp[ depth ][ chVal ].nodesSplit = 0;
        colImp[ depth ][ chVal ].minVR = Infinity;
        colImp[ depth ][ chVal ].maxVR = -Infinity;
      }
      // Update stats.
      colImp[ depth ][ chVal ].nodesSplit += 1;
      // Update min/max varaiance reductions.
      colImp[ depth ][ chVal ].minVR = Math.min( colImp[ depth ][ chVal ].minVR, +subTree.varianceReduction.toFixed( 4 ) );
      colImp[ depth ][ chVal ].maxVR = Math.max( colImp[ depth ][ chVal ].maxVR, +subTree.varianceReduction.toFixed( 4 ) );

      for ( var key in subTree.branches ) { // eslint-disable-line guard-for-in
        // Update summary!
        if ( stats.min.mean > subTree.branches[ key ].mean ) {
          stats.min.mean = subTree.branches[ key ].mean;
          stats.min.itsSD = subTree.branches[ key ].stdev;
        }
        if ( stats.max.mean < subTree.branches[ key ].mean ) {
          stats.max.mean = subTree.branches[ key ].mean;
          stats.max.itsSD = subTree.branches[ key ].stdev;
        }
        stats.minSD = Math.min( stats.minSD, subTree.branches[ key ].stdev );
        // Time to dig deeper!!
        navigateRules4Stats( subTree.branches[ key ], stats, colImp, ( depth + 1 ), chVal );
      }
    }
  }; // navigateRules4Stats()

  // ### summary
  /**
   *
   * Generates summary of the learnings in terms of the following:<ol>
   * <li>Relative importance of columns along with the corresponding min/max
   * variance reductions (VR).</li>
   * <li>The min/max mean values along with the corresponding standard
   * deviations (SD).</li>
   * <li>The minumum standard deviation (SD) discovered during the learning.</li></ol>
   *
   * @method RegressionTree#summary
   * @return {object} containing the following:<ol>
   * <li><code>table</code> — array of objects, where each object defines <code>level</code>, <code>columnHierarchy</code>,
   * <code>nodesSplit</code>, <code>minVR</code> and <code>maxVR</code>. A lower value of <code>level</code>
   * indicates higher importance; similarly more nodes at a level split on a columnHierarchy
   * is an indication of importance. Therefore, it is sorted in ascending order of <code>level</code>
   * followed by in descending order of <code>nodesSplit</code>.</li>
   * <li><code>stats</code> — object containing <code>min.mean</code>, <code>min.itsSD</code>, <code>max.mean</code>, <code>max.itsSD</code>,
   * and <code>minSD</code>.</li></ol>
   * @example
   * myRT.summary();
   * // -> returns the summary object.
  */
  var summary = function () {
    // Column imporatnce is captured first in an object to ease hashing and later
    // converted to a table.
    var columnsImportance = Object.create( null );
    var table = [];
    // Current depth of the tree.
    var depth = 1;
    // In unix style file paths.
    var columnHierarchy = '';
    // To capture min/max means and their stdevs, etc.
    var stats = Object.create( null );
    // Helper variables.
    var ch, level;

    // Initialize.
    stats.min = Object.create( null );
    stats.max = Object.create( null );
    stats.minSD = Infinity;
    stats.min.mean = Infinity;
    stats.min.itsSD = 0;
    stats.max.mean = -Infinity;
    stats.max.itsSD = 0;
    // Buld summary recursively.
    navigateRules4Stats( wrTree, stats, columnsImportance, depth, columnHierarchy );
    // Convert to `table`.
    for ( level in columnsImportance ) { // eslint-disable-line guard-for-in
      for ( ch in columnsImportance[ level ] ) { // eslint-disable-line guard-for-in
        table.push( {
          level: +level,
          columnHierarchy: ch,
          nodesSplit: columnsImportance[ level ][ ch ].nodesSplit,
          minVR: columnsImportance[ level ][ ch ].minVR,
          maxVR: columnsImportance[ level ][ ch ].maxVR,
        } );
      }
    }
    // Sort on level (asc) and then on nodesSplit(dsc).
    table.sort( function ( a, b ) {
      return (
        ( a.level > b.level ) ? 1 :
          ( a.level < b.level ) ? -1 :
            ( a.nodesSplit < b.nodesSplit ) ? 1 : -1
      );
    } );
    // Return summary!
    return { columnsImportance: table, stats: stats };
  }; // summary()

  // ### evaluate
  /**
   *
   * Incrementally evalutes variance reduction for one data row at a time.
   *
   * @method RegressionTree#evaluate
   * @param {object} rowObject contains column name/value pairs including the target column
   * name/value pair as well, which is used in evaluating the variance reduction.
   * @return {boolean} always `true`.
   * @example
   * myRT.evaluate( input );
  */
  var evaluate = function ( rowObject ) {
    var pv = predict( rowObject );
    evalParams.prevMean = evalParams.mean;
    evalParams.size += 1;
    evalParams.mean += computeMeanDelta( rowObject[ target ], evalParams.mean, evalParams.size );
    evalParams.gssdm += computeVarianceXnDelta( rowObject[ target ], evalParams.mean, evalParams.prevMean );
    evalParams.ssdm += ( ( rowObject[ target ] - pv ) * ( rowObject[ target ] - pv ) );
    return true;
  }; // evaluate()

  // ### metrics
  /**
   *
   * Computes the variance reduction observed in the validation data passed to
   * `evaluate()`.
   *
   * @method RegressionTree#metrics
   * @return {object} containing the `varianceReduction` in percentage and data `size`.
   * @example
   * myRT.metrics();
   * // -> object containing varianceReduction and data size.
  */
  var metrics = function ( ) {
    return (
      {
        size: evalParams.size,
        varianceReduction: +( ( evalParams.gssdm - evalParams.ssdm ) * 100 / evalParams.gssdm ).toFixed( 4 ),
      }
    );
  }; // metrics()

  // ### exportJSON
  /**
   *
   * Exports the JSON of the rule tree generated by `learn()`, which may be
   * saved in a file for later predictions.
   *
   * @method RegressionTree#exportJSON
   * @return {json} of the rule tree.
   * @example
   * var rules = myRT.exportJSON();
  */
  var exportJSON = function () {
    return JSON.stringify( wrTree );
  }; // exportJSON()

  // ### importJSON
  /**
   *
   * Imports the rule tree from the input `rulesTree` for subsequent use by `predict()`.
   * Note after a successful import, this can be used ONLY for prediction purpose
   * and not for further ingestion and/or learning.
   *
   * @method RegressionTree#importJSON
   * @param {json} rulesTree containg an earlier exported rule tree in JSON format.
   * @return {boolean} always `true`.
   * @throws {error} if `rulesTree` is `null`.
   * @throws {error} if `rulesTree` can not be parsed as a valid JSON.
   * @throws {error} if `rulesTree` is of incorrect version or incorrect format.
   * @example
   * var anRT = regressionTree();
   * // Assuming that json has a valid rule tree.
   * anRT.importJSON( rules );
  */
  var importJSON = function ( rulesTree ) {
    if ( !rulesTree ) {
      throw Error( 'winkRT: undefined or null JSON encountered, import failed!' );
    }
    try {
      wrTree = JSON.parse( rulesTree );
    } catch ( ex ) {
      throw Error( 'winkRT: JSON parsing error during import:\n\t' + ex.message );
    }
    if ( wrTree.version !== winkRulesTreeVersion ) {
      throw Error( 'winkRT: incorrect json format or tree version, import failed!' );
    }
    return true;
  }; // importJSON()

  // ### reset
  /**
   *
   * It completely resets the tree by re-initializing all the learning
   * related variables, except it's configuration. It is useful during
   * cross fold-validation.
   *
   * @method RegressionTree#reset
   * @return {undefined} nothing!
   * @example
   * var myRT.reset();
  */
  var reset = function () {
    // Do not reset variables pertaining to *configuration*:<br/>
    // 1. `columnsConfig`
    // 2. `columnsDefn`
    // 3. `config`
    // 4. `target`

    // All other variables are reset/re-initialized.

    // Re-initialize the **w**ink **r**egression tree.
    wrTree = Object.create( null );
    // Re-initialize Xformed Column id to input column id map.
    xc2cMap = [];
    // Re-initialize Xformed data, where categorical variables are encoded by a numeric code. Useful
    // in reduction of memory load.
    xdata = [];
    // Re-initialize parameters used for evaluation.
    evalParams = Object.create( null );
    initEvalParams();
  }; // reset();

  // Set default configuration;
  config.maxDepth = 20;
  config.minPercentVarianceReduction = 10;
  config.minSplitCandidateItems = 50;
  config.minLeafNodeItems = 10;
  // This will ensure that split will never occurr on uniq id like columns!
  config.minAvgChildrenItems = 2;
  // Initialize the number of rules learned.
  wrTree.rulesLearned = 0;

  // Initialize evaluation parameters.
  initEvalParams();

  methods.defineConfig = defineConfig;
  methods.ingest = ingest;
  methods.learn = learn;
  methods.predict = predict;
  methods.evaluate = evaluate;
  methods.metrics = metrics;
  // Setup an alias `stats()` to maintain similarity with other ML packages
  // such as naive bayes, etc.
  methods.stats = methods.summary = summary;
  methods.exportJSON = exportJSON;
  methods.importJSON = importJSON;
  methods.reset = reset;

  methods.info = function () {
    return {
      columnsConfig : columnsConfig,
      columnsDefn : columnsDefn,
    }
  }
  return methods;
}; // regressionTree()

// Export
module.exports = regressionTree;
};
BundleModuleCode['ml/helpers']=function (module,exports){
//     wink-helpers
//     Functions for cross validation, shuffle, cartesian product and more
//
//     https://github.com/winkjs/wink-helpers
//
//     Copyright (C) 2017-18  GRAYPE Systems Private Limited
//
//     This file is part of “wink-helpers”.
//
//     Permission is hereby granted, free of charge, to any person obtaining a
//     copy of this software and associated documentation files (the "Software"),
//     to deal in the Software without restriction, including without limitation
//     the rights to use, copy, modify, merge, publish, distribute, sublicense,
//     and/or sell copies of the Software, and to permit persons to whom the
//     Software is furnished to do so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included
//     in all copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//     DEALINGS IN THE SOFTWARE.

//
var helpers = Object.create( null );

// ### Private Functions

// #### Product Reducer (Callback)

// Callback function used by `reduce` inside the `product()` function.
// Follows the standard guidelines of `reduce()` callback function.
var productReducer = function ( prev, curr ) {
  var c,
      cmax = curr.length;
  var p,
      pmax = prev.length;
  var result = [];

  for ( p = 0; p < pmax; p += 1 ) {
    for ( c = 0; c < cmax; c += 1 ) {
      result.push( prev[ p ].concat( curr[ c ] ) );
    }
  }
  return ( result );
}; // productReducer()

// ### Public Function

// ### Array Helpers

helpers.array = Object.create( null);

// #### is Array

// Tests if argument `v` is a JS array; returns `true` if it is, otherwise returns `false`.
helpers.array.isArray = function ( v ) {
  return ( ( v !== undefined ) && ( v !== null ) && ( Object.prototype.toString.call( v ) === '[object Array]' ) );
}; // isArray()


// #### sorting helpers

// Set of helpers to sort either numbers or strings. For key/value pairs,
// the format for each element must be `[ key, value ]`.
// Sort helper to sort an array in ascending order.
helpers.array.ascending = function ( a, b ) {
  return ( a > b ) ? 1 :
            ( a === b ) ? 0 : -1;
}; // ascending()

// Sort helper to sort an array in descending order.
helpers.array.descending = function ( a, b ) {
  return ( b > a ) ? 1 :
            ( b === a ) ? 0 : -1;
}; // descending()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **key**.
helpers.array.ascendingOnKey = function ( a, b ) {
  return ( a[ 0 ] > b[ 0 ] ) ? 1 :
            ( a[ 0 ] === b[ 0 ] ) ? 0 : -1;
}; // ascendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in descending order by **key**.
helpers.array.descendingOnKey = function ( a, b ) {
  return ( b[ 0 ] > a[ 0 ] ) ? 1 :
            ( b[ 0 ] === a[ 0 ] ) ? 0 : -1;
}; // descendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **value**.
helpers.array.ascendingOnValue = function ( a, b ) {
  return ( a[ 1 ] > b[ 1 ] ) ? 1 :
            ( a[ 1 ] === b[ 1 ] ) ? 0 : -1;
}; // ascendingOnValue()

// Sort helper to sort an array of `[ key, value ]` in descending order by **value**.
helpers.array.descendingOnValue = function ( a, b ) {
  return ( b[ 1 ] > a[ 1 ] ) ? 1 :
            ( b[ 1 ] === a[ 1 ] ) ? 0 : -1;
}; // descendingOnValue()

// The following two functions generate a suitable function for sorting on a single
// key or on a composite keys (max 2 only). Just a remider, the generated function
// does not sort on two keys; instead it will sort on a key composed of the two
// accessors.
// Sorts in ascending order on `accessor1` & `accessor2` (optional).
helpers.array.ascendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( a[ accessor1 ][ accessor2 ] > b[ accessor1 ][ accessor2 ] ) ? 1 :
              ( a[ accessor1 ][ accessor2 ] === b[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( a[ accessor1 ] > b[ accessor1 ] ) ? 1 :
            ( a[ accessor1 ] === b[ accessor1 ] ) ? 0 : -1;
  } );
}; // ascendingOn()

// Sorts in descending order on `accessor1` & `accessor2` (optional).
helpers.array.descendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( b[ accessor1 ][ accessor2 ] > a[ accessor1 ][ accessor2 ] ) ? 1 :
              ( b[ accessor1 ][ accessor2 ] === a[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( b[ accessor1 ] > a[ accessor1 ] ) ? 1 :
            ( b[ accessor1 ] === a[ accessor1 ] ) ? 0 : -1;
  } );
}; // descendingOn()

// #### pluck

// Plucks specified element from each element of an **array of array**, and
// returns the resultant array. The element is specified by `i` (default `0`) and
// number of elements to pluck are defined by `limit` (default `a.length`).
helpers.array.pluck = function ( a, key, limit ) {
  var k, plucked;
  k = a.length;
  var i = key || 0;
  var lim = limit || k;
  if ( lim > k ) lim = k;
  plucked = new Array( lim );
  for ( k = 0; k < lim; k += 1 ) plucked[ k ] = a[ k ][ i ];
  return plucked;
}; // pluck()

// #### product

// Finds the Cartesian Product of arrays present inside the array `a`. Therefore
// the array `a` must be an array of 1-dimensional arrays. For example,
// `product( [ [ 9, 8 ], [ 1, 2 ] ] )`
// will produce `[ [ 9, 1 ], [ 9, 2 ], [ 8, 1 ], [ 8, 2 ] ]`.
helpers.array.product = function ( a ) {
  return (
    a.reduce( productReducer, [ [] ] )
  );
};

// #### shuffle

// Randomly shuffles the elements of an array and returns the same.
// Reference: Chapter on Random Numbers/Shuffling in Seminumerical algorithms.
// The Art of Computer Programming Volume II by Donald E Kunth
helpers.array.shuffle = function ( array ) {
  var a = array;
  var balance = a.length;
  var candidate;
  var temp;

  while ( balance ) {
    candidate = Math.floor( Math.random() * balance );
    balance -= 1;

    temp = a[ balance ];
    a[ balance ] = a[ candidate ];
    a[ candidate ] = temp;
  }

  return ( a );
};


// ### Object Helpers

var objectKeys = Object.keys;
var objectCreate = Object.create;

helpers.object = Object.create( null );

// #### is Object

// Tests if argument `v` is a JS object; returns `true` if it is, otherwise returns `false`.
helpers.object.isObject = function ( v ) {
  return ( v && ( Object.prototype.toString.call( v ) === '[object Object]' ) ) ? true : false; // eslint-disable-line no-unneeded-ternary

}; // isObject()

// #### keys

// Returns keys of the `obj` in an array.
helpers.object.keys = function ( obj ) {
  return ( objectKeys( obj ) );
}; // keys()

// #### size

// Returns the number of keys of the `obj`.
helpers.object.size = function ( obj ) {
  return ( ( objectKeys( obj ) ).length );
}; // size()

// #### values

// Returns all values from each key/value pair of the `obj` in an array.
helpers.object.values = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var values = new Array( length );
  for ( var i = 0; i < length; i += 1 ) {
    values[ i ] = obj[ keys[ i ] ];
  }
  return values;
}; // values()

// #### value Freq

// Returns the frequency of each unique value present in the `obj`, where the
// **key** is the *value* and **value** is the *frequency*.
helpers.object.valueFreq = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var val;
  var vf = objectCreate( null );
  for ( var i = 0; i < length; i += 1 ) {
    val = obj[ keys[ i ] ];
    vf[ val ] = 1 + ( vf[ val ] || 0 );
  }
  return vf;
}; // valueFreq()

// #### table

// Converts the `obj` in to an array of `[ key, value ]` pairs in form of a table.
// Second argument - `f` is optional and it is a function, which is called with
// each `value`.
helpers.object.table = function ( obj, f ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var pairs = new Array( length );
  var ak, av;
  for ( var i = 0; i < length; i += 1 ) {
    ak = keys[ i ];
    av = obj[ ak ];
    if ( typeof f === 'function' ) f( av );
    pairs[ i ] = [ ak, av ];
  }
  return pairs;
}; // table()

// ### Validation Helpers

helpers.validate = Object.create( null );

// Create aliases for isObject and isArray.
helpers.validate.isObject = helpers.object.isObject;
helpers.validate.isArray = helpers.array.isArray;

// #### isFiniteInteger

// Validates if `n` is a finite integer.
helpers.validate.isFiniteInteger = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n ) &&
    ( n === Math.round( n ) )
  );
}; // isFiniteInteger()

// #### isFiniteNumber

// Validates if `n` is a valid number.
helpers.validate.isFiniteNumber = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n )
  );
}; // isFiniteNumber()

// ### cross validation
/**
 *
 * Creates an instance of cross validator useful for machine learning tasks.
 *
 * @param {string[]} classLabels - array containing all the class labels.
 * @return {methods} object conatining set of API methods for tasks like evalutaion,
 * reset and metrics generation.
*/
helpers.validate.cross = function ( classLabels ) {
  // wink's const for unknown predictions!
  const unknown = 'unknown';
  // To ensure that metrics is not computed prior to evaluation.
  var evaluated = false;
  // The confusion matrix.
  var cm;
  var precision;
  var recall;
  var fmeasure;

  // The class labels is assigned to this variable.
  var labels;
  // The length of `labels` array.
  var labelCount;
  var labelsObj = Object.create( null );

  // Returned!
  var methods = Object.create( null );


  /**
   *
   * Resets the current instance for another round of evaluation; the class
   * labels defined at instance creation time are not touched.
   *
   * @return {undefined} nothing!
  */
  var reset = function ( ) {
    evaluated = false;
    cm = Object.create( null );
    precision = Object.create( null );
    recall = Object.create( null );
    fmeasure = Object.create( null );

    // Initialize confusion matrix and metrics.
    for ( var i = 0; i < labelCount; i += 1 ) {
      const row = labels[ i ];
      labelsObj[ row ] = true;
      cm[ row ] = Object.create( null );
      precision[ row ] = 0;
      recall[ row ] = 0;
      fmeasure[ row ] = 0;
      for ( var j = 0; j < labelCount; j += 1 ) {
        const col = labels[ j ];
        cm[ row ][ col ] = 0;
      }
    }
  }; // reset()

  /**
   *
   * Creates an instance of cross validator useful for machine learning tasks.
   *
   * @param {string} truth - the actual class label.
   * @param {string} guess - the predicted class label.
   * @return {boolean} returns true if the evaluation is successful. The evaluation
   * may fail if `truth` or `guess` is not in the array `classLabels` provided at
   * instance creation time; or if guess is equal to `unknown`.
  */
  var evaluate = function ( truth, guess ) {
    // If prediction failed then return false!
    if ( guess === unknown || !labelsObj[ truth ] || !labelsObj[ guess ] ) return false;
    // Update confusion matrix.
    if ( guess === truth ) {
      cm[ truth ][ guess ] += 1;
    } else {
      cm[ guess ][ truth ] += 1;
    }
    evaluated = true;
    return true;
  }; // evaluate()

  /**
   *
   * It computes a detailed metrics consisting of macro-averaged precision,
   * recall and f-measure along with their label-wise values and the confusion
   * matrix.
   *
   * @return {object} object containing macro-averaged `avgPrecision`, `avgRecall`,
   * `avgFMeasure` values along with other details such as label-wise values
   * and the confusion matrix. A value of `null` is returned if no evaluate()
   * has been called before.
  */
  var metrics = function ( ) {
    if ( !evaluated ) return null;
    // Numerators for every label; they are same for precision & recall both.
    var n = Object.create( null );
    // Only denominators differs for precision & recall
    var pd = Object.create( null );
    var rd = Object.create( null );
    // `row` and `col` of confusion matrix.
    var col, row;
    var i, j;
    // Macro average values for metrics.
    var avgPrecision = 0;
    var avgRecall = 0;
    var avgFMeasure = 0;

    // Compute label-wise numerators & denominators!
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      for ( j = 0; j < labelCount; j += 1 ) {
        col = labels[ j ];
        if ( row === col ) {
          n[ row ] = cm[ row ][ col ];
        }
        pd[ row ] = cm[ row ][ col ] + ( pd[ row ] || 0 );
        rd[ row ] = cm[ col ][ row ] + ( rd[ row ] || 0 );
      }
    }
    // Ready to compute metrics.
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      precision[ row ] = +( n[ row ] / pd[ row ] ).toFixed( 4 );
      // NaN can occur if a label has not been encountered.
      if ( isNaN( precision[ row ] ) ) precision[ row ] = 0;

      recall[ row ] = +( n[ row ] / rd[ row ] ).toFixed( 4 );
      if ( isNaN( recall[ row ] ) ) recall[ row ] = 0;

      fmeasure[ row ] = +( 2 * precision[ row ] * recall[ row ] / ( precision[ row ] + recall[ row ] ) ).toFixed( 4 );
      if ( isNaN( fmeasure[ row ] ) ) fmeasure[ row ] = 0;
    }
    // Compute thier averages, note they will be macro avegages.
    for ( i = 0; i < labelCount; i += 1 ) {
      avgPrecision += ( precision[ labels[ i ] ] / labelCount );
      avgRecall += ( recall[ labels[ i ] ] / labelCount );
      avgFMeasure += ( fmeasure[ labels[ i ] ] / labelCount );
    }
    // Return metrics.
    return (
      {
        // Macro-averaged metrics.
        avgPrecision: +avgPrecision.toFixed( 4 ),
        avgRecall: +avgRecall.toFixed( 4 ),
        avgFMeasure: +avgFMeasure.toFixed( 4 ),
        details: {
          // Confusion Matrix.
          confusionMatrix: cm,
          // Label wise metrics details, from those averages were computed.
          precision: precision,
          recall: recall,
          fmeasure: fmeasure
        }
      }
    );
  }; // metrics()

  if ( !helpers.validate.isArray( classLabels ) ) {
    throw Error( 'cross validate: class labels must be an array.' );
  }
  if ( classLabels.length < 2 ) {
    throw Error( 'cross validate: at least 2 class labels are required.' );
  }
  labels = classLabels;
  labelCount = labels.length;

  reset();

  methods.reset = reset;
  methods.evaluate = evaluate;
  methods.metrics = metrics;

  return methods;
}; // cross()

// ### Object Helpers

helpers.string = Object.create( null );

// Regex for [diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) removal.
var rgxDiacritical = /[\u0300-\u036f]/g;

/**
 *
 * Normalizes the token's value by converting it to lower case and stripping
 * the diacritical marks (if any).
 *
 * @param {string} str — that needs to be normalized.
 * @return {string} the normalized value.
 * @example
 * normalize( 'Nestlé' );
 * // -> nestle
*/
helpers.string.normalize = function ( str ) {
  return (
    str.toLowerCase().normalize( 'NFD' ).replace( rgxDiacritical, '' )
  );
}; // normalize()

helpers.getOptions = function (options,selected) {
  var options2 = {}
  selected.forEach(function (opt) { options2[opt]=options[opt] })
  return options2;
}
helpers.updateOptions = function (options,update) {
  for(var p in options) if (update[p]!=undefined) options[p]=update[p];
  return options;
}
module.exports = helpers;
};
BundleModuleCode['plugins/ml/stats']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $CREATED:     (C) 2006-2021 bLAB by sbosse
 **    $VERSION:     1.3.1X
 **
 **    $INFO:
 **
 **  ML Data Statistics and Utils 
 **
 **  New:
 **    type eps = number | number []
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var math = Require('plugins/ml/math');

///////// UTILS ////////////
var stat = {
	max: function(array) {
		return Math.max.apply(null, array);
	},
	
	min: function(array) {
		return Math.min.apply(null, array);
	},
	
	range: function(array) {
		return stat.max(array) - stat.min(array);
	},
	
	midrange: function(array) {
		return stat.range(array) / 2;
	},

	sum: function(array) {
		var num = 0;
		for (var i = 0, l = array.length; i < l; i++) num += array[i];
		return num;
	},
	
	mean: function(array) {
		return stat.sum(array) / array.length;
	},
	
	median: function(array) {
		array.sort(function(a, b) {
			return a - b;
		});
		var mid = array.length / 2;
		return mid % 1 ? array[mid - 0.5] : (array[mid - 1] + array[mid]) / 2;
	},
	
	modes: function(array) {
		if (!array.length) return [];
		var modeMap = {},
			maxCount = 0,
			modes = [];

		array.forEach(function(val) {
			if (!modeMap[val]) modeMap[val] = 1;
			else modeMap[val]++;

			if (modeMap[val] > maxCount) {
				modes = [val];
				maxCount = modeMap[val];
			}
			else if (modeMap[val] === maxCount) {
				modes.push(val);
				maxCount = modeMap[val];
			}
		});
		return modes;
	},
	
	variance: function(array) {
		var mean = stat.mean(array);
		return stat.mean(array.map(function(num) {
			return Math.pow(num - mean, 2);
		}));
	},
	
	standardDeviation: function(array) {
		return Math.sqrt(stat.variance(array));
	},
	
	meanAbsoluteDeviation: function(array) {
		var mean = stat.mean(array);
		return stat.mean(array.map(function(num) {
			return Math.abs(num - mean);
		}));
	},
  
  nans: function nans(vector) {
    var n=0; for(var i in vector) if (isNaN(vector[i])) n++;
    return n
  },

  zeros : function zeros(vector) {
    var n=0; for(var i in vector) if (vector[i]==0) n++;
    return n
  },
	
	zScores: function(array) {
		var mean = stat.mean(array);
		var standardDeviation = stat.standardDeviation(array);
		return array.map(function(num) {
			return (num - mean) / standardDeviation;
		});
	}
};

// Function aliases:
stat.average = stat.mean;

// generate gaussian noise (Standard Normal variate using Box-Muller transform)
function gaussian(min,max,skew) {
    min=min||0;
    max=max||1;
    skew=skew||1;
    var u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    var num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) num = gaussian(min, max, skew); // resample between 0 and 1 if out of range
    num = Math.pow(num, skew); // Skew
    num *= max - min; // Stretch to fill range
    num += min; // offset to min
    return num;
}

// function ({$x:number}|{value:*,prob;number}[]|number [],boolean) 
// -> {value:*,prob:number}|{index:number, prob:number}
// normalize=1: scale output max=[0,1]
// normalize=2: scale and weight output max*[0,1]

function best(o,normalize) {
  var p,max,pos=0,sum=0,res;
  if (Comp.obj.isArray(o) && typeof o[0]=='number')  {
    max=-Infinity;
    for(p in o) {
      sum += o[p];       
      if (o[p] > max) max=o[p],pos=p;
    }  
    res = {index:pos,prob:max}   
  } else if (Comp.obj.isArray(o) && typeof o[0]=='object')  {
    for(p in o) {
      sum += o[p].prob; 
      if (!max || o[p].prob>max.prob) max=o[p];
    }
    res = {value:max.value,prob:max.prob}
  } else if (Comp.obj.isObj(o)) {
    max=-Infinity;
    for(p in o) {
      sum += o[p];
      if (o[p]>max) max=o[p],pos=p;
    }
    res = {value:pos,prob:max}      
  }
  if (!res) return;
  switch (normalize) {
    case 1: res.prob=res.prob/sum; break;
    case 2: res.prob=res.prob*(res.prob/sum); break;
    default: 
  }
  return res;
}
function bestNormalize(o) { return best(o,1) }


function log2(n) {
  return Math.log(n) / Math.log(2);
}

// Select maximal value of an array by values 
// retuned by optional function applied to array values
function max(array,fun) {        
    var res,max,num;
    for(var i in array) {
        if (fun) num=fun(array[i],i); else num=array[i];
        if (max==undefined) { max=num; res=array[i] } 
        else if (num > max) { max=num; res=array[i] }
    }
    return res;
}

/**
 * Finds element with highest occurrence in a list
 * @private
 */
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;
  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}


function pluck(collection, key) {
  return collection.map(function(object) {
    return object == null ? undefined : object[key];
  });
}

function prob(value, list) {
  var occurrences = list.filter(function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}


function sort(array) {
  return array.sort(function (a,b) { return a<b?-1:1 });
}

function sum (a,b) { return a+b }

function unique(array) {
  var length = array ? array.length : 0;
  function baseUniq(array) {
    var index = -1,
        length = array.length,
        seen,
        result = [];

    seen = result;
    outer:
    while (++index < length) {
      var value = array[index];
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === value) {
          continue outer;
        }
      }
      result.push(value);
    }
    return result;
  }
  if (!length) {
    return [];
  }
  return baseUniq(array);
}

function without () {
  var array,
      values=[];
  for(var i in arguments) {
    if (i==0) array=arguments[0];
    else values.push(arguments[i]);
  }
  return array.filter(function (e) {
    return values.indexOf(e) == -1;
  });
}


////////////////////////////////////////

// Entropy of data vectors
function entropy(vals) {
  var uniqueVals = unique(vals);
  var probs = uniqueVals.map(function(x) {
    return prob(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(sum,0);
}

function entropyN(dist,N) {
  var p, probs=[];
  for(p in dist) probs.push(dist[p]/N);
  var logVals = probs.map(function(p) {
    return p==0?0:-p * log2(p)
  });
  return logVals.reduce(sum, 0);
  
}

function entropyEps(vals,eps) {
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(sum, 0);
}
// Binray Crossentropy! y0: labelled output, y1: predicted output in [0,1]
function crossEntropy (y0,y1) {
    var reconstructedOutput = y1;
    var a = math.activateTwoMat(y0,reconstructedOutput,function(x,y){
        return x*Math.log(Math.max(1E-6,y));
    });
    var b = math.activateTwoMat(y0,reconstructedOutput,function(x,y){
        return (1-x)*Math.log(1-Math.min(0.9999999999,y));
    });

    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy
}

/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probEps(value, list, eps) {
  // TODO: ranges
  var occurrences = list.filter(function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

function probEps2(value, list, eps) {
  // TODO: ranges
  var occurrences = list.filter( function(element) {
    return overlap(epsVal(value), epsVal(element));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

// Entropy of target variable partitioned feature vector
function entropyT(data,featureIndex,targetIndex,targets) {
  var en = 0;
  var col =  pluck(data,featureIndex);
  var uniqueVals = unique(col);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2==v) cn++,frac[targets.indexOf(data[row][targetIndex])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.reduce(sum)))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}

function entropyTEps(data,feature,target,targets,eps) {
  var en = 0;
  var col =  pluck(data,feature);
  var uniqueVals = uniqueEps(col,eps);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2>=v-eps && v2<=v+eps) cn++,frac[targets.indexOf(data[row][target])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.reduce(sum)))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}

function features (data,target) {
  var f;
  if (Comp.obj.isObj(data[0])) 
    f=Object.keys(data[0]);
  else if (Comp.obj.isArray(data[0]))
    f=data[0].map(function (x,i) { return String(i) });
  if (f && target != undefined) {
    if (typeof target == 'string')
      f=f.filter(function (a) { return a!=target  });
    else 
      f=f.filter(function (a,i) { return i!=target  });
  }
  return f;
}

// Commonly used formula= et-etn
function gain (data,feature,target,targets) {
  var et = entropy(pluck(data,target));
  return et-entropyT(data,feature,target,targets)
}

function gainEps(data,feature,target,targets,eps) {
  var et = entropy(pluck(data,target));
  return et/entropyTEps(data,feature,target,targets,eps)
}


function maxGainEps(data,features,target,targets,eps) {
  var maxgain=max(features, function(feature,index) {
    var g = gainEps(data,feature,target,targets,selectEps(eps,index));
    return g;
  });
  return maxgain;
}

function partition(data,feature,target,targets) {
  var parts={};
  targets.forEach(function (t) {parts[t]=[]});
  data.forEach(function (row) {
    parts[row[target]].push(row[feature]);
  })
  return parts
}

function partitionEps(data,feature,target,targets,eps) {
  var p,parts={}
  targets.forEach(function (t) {parts[t]={range:[Number.MAX_VALUE,-Number.MAX_VALUE],values:[]}});
  data.forEach(function (row) {
    parts[row[target]].values.push(row[feature]);
    parts[row[target]].range[0]=Math.min(parts[row[target]].range[0],row[feature]);
    parts[row[target]].range[1]=Math.max(parts[row[target]].range[1],row[feature]);
  })
  for(p in parts) {
    parts[p].unique=uniqueEps(parts[p].values,eps)
    parts[p].noise=2*stat.standardDeviation(parts[p].values);
  }
  return parts
}

// Return only eps-not-overlapping parititions - the most significant are selected 
// (with the lowest unique column values) 
function partitionUniqueEps(data,feature,target,targets,eps) {
  var p, q, parts={}
  // 1. Create all partitions 
  targets.forEach(function (t) {parts[t]={range:[Number.MAX_VALUE,-Number.MAX_VALUE],values:[]}});
  data.forEach(function (row) {
    parts[row[target]].values.push(row[feature]);
    parts[row[target]].range[0]=Math.min(parts[row[target]].range[0],row[feature]);
    parts[row[target]].range[1]=Math.max(parts[row[target]].range[1],row[feature]);
  })
  for(p in parts) {
    parts[p].unique=uniqueEps(parts[p].values,eps)
  }
  // 2. Remove overlapping partitions
  for(p in parts) {
    if (!parts[p]) continue;
    for (q in parts) {
      if (!parts[p]) break;
      if (p==q || !parts[q]) continue;
      if ((parts[p].range[0]-eps)<parts[q].range[1] ||
          (parts[p].range[1]+eps)>parts[q].range[0]) {
        // overlapping, select the part with best unique column values
        if ((parts[p].unique.length/parts[p].values.length)<
            (parts[q].unique.length/parts[q].values.length)) {
          //print('delete '+q)
          delete parts[q];
        } else {
          //print('delete '+p)
          delete parts[p];
        }
      }
    }
  }  
  return parts
}

function select (data,what) {
  if (Comp.obj.isArray(what) && what.length==2) {
    var c0=what[0],c1=what[1];
    return data.map(function (row) {
      return row.slice(c0,c1+1);
    })
  } 
}

function selectEps (eps,index) {
  if (typeof eps == 'number') return eps;
  else return eps[index]
}

/** Split a data set by finding the best feature (column) 
 *  based on maximal gain/entropy calculation of columns. 
 *  type eps = number | number []
 */

function splitEps (data,features,target,targets,eps) {
  var bestFeature = maxGainEps(data,features,target,targets,eps);
  var index = features.indexOf(bestFeature);
  eps = selectEps(eps,index);
  var remainingFeatures = without(features, bestFeature);
  var possibleValues = sort(uniqueEps(pluck(data, bestFeature),eps));
  var choices = possibleValues.map( function(v) {
    var dataS = data.filter(function(x) {
      return Math.abs(x[bestFeature] - v) <= eps
    });
    return {
      val:v,
      data:dataS,
    }
  });
  return {
    feature:bestFeature,
    choices:choices,
    possibleValues:possibleValues,
    remainingFeatures:remainingFeatures
  };
}

function uniqueEps(array,eps) {
  var result=[];
  array.forEach(function (x) {
    var found;
    if (!result.length) result.push(x);
    else {
      result.forEach(function (y) {
        if (found) return;
        found = Math.abs(x-y)<=eps;
      }); 
      if (!found) result.push(x);
    }
  });
  return result;
}



module.exports =  {
  analyze : function (data,features,target,eps) {
    var noise=[];
    if (!eps) eps=0;
    var targets = unique(pluck(data,target));
    var parts = {}, partsUnique = {},diversity={}
    features.forEach(function (feature) {
      partsUnique[feature]=partitionUniqueEps(data,feature,target,targets,eps);
      parts[feature]=partitionEps(data,feature,target,targets,eps);
      for(var p in parts[feature]) noise.push(parts[feature][p].noise);
    })
    features.forEach(function (feature) {
      diversity[feature]=Object.keys(partsUnique[feature]).length;
    })
   
    return {
      features:features,
      partitions:parts, // for each data column
      diversity:diversity,
      noise:stat.mean(noise)
    }
  },
  crossEntropy: crossEntropy,
  entropy:entropy,
  entropyN:entropyN,
  entropyEps:entropyEps,
  entropyTEps:entropyTEps,
  entropyT:entropyT,
  features:features,
  gain:gain,
  gainEps:gainEps,
  maxGainEps:maxGainEps,
  mostCommon:mostCommon,
  partition:partition,
  partitionEps:partitionEps,
  partitionUniqueEps:partitionUniqueEps,
  splitEps:splitEps,
  unique:unique,
  uniqueEps:uniqueEps,
  utils : {
    // return column by key of a matrix (array array|record array) 
    best:best,
    bestNormalize:bestNormalize,
    column:pluck,
    gaussian:gaussian,
    log2:log2,
    prob:prob,
    // transform [v][] -> v[]
    relax: function (mat) {
      if (Comp.obj.isMatrix(mat) && mat[0].length==1) return mat.map(function (row) { return row[0]})
      else return mat;
    },
    select:select,
    selectEps:selectEps,
    sort:sort,
    stat:stat,
    without:without,
    // transform v[] -> [v][]
    wrap: function (mat) {
      if (!Comp.obj.isMatrix(mat)) return mat.map(function (v) { return [v]})
      else return mat
    },
  },
  version:'1.2.4X',
};

};
BundleModuleCode['plugins/ml/cnn']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $CREATED:     (C) 2006-2022 bLAB by sbosse
 **    $VERSION:     1.3.2X
 **
 **    $INFO:
 **
 ** Convolutional neural network ML Algorithm Wrapper
 **
 ** Incremental learner using ml.update! Initial training data via ml.learn (or empty data set, just using ml.learner) 
 **
 ** Not portable!
 ** 
 **    $ENDOFINFO
 */
'use strict';
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;

var convnetjs = Require('plugins/ml/convnet')
var that;

function isTypedArray(o) {
  return typeof o == 'object' && o.buffer && Utils.isBufferArray(o.buffer)
}
function isLinearArray (row0) {
  if (row0.data) row0=row0.data;
  return Utils.isBufferArray(row0) || 
         isTypedArray(row0) ||
         (row0 instanceof Array && typeof row0[0]=='number')
}
that = module.exports =  {
  stats : {
    convFloat : 0,
    scale : 0,
    volRef : 0,
    volCopy : 0,
  },
  // typeof options = {x:[][],y:[],width,height,depth,normalize?:[a,b],layers:{}[]..}
  // format x = [ [row1=[col1=[z1,z2,..],col2,..],row2,..] ]
  create : function (options) {
    if (options.datatype) convnetjs.datatype=options.datatype;
    var net = new convnetjs.Net();
    if (options.network)
      // restore network from JSON model
      net.fromJSON(options.network);
    else if (options.layers)
      net.makeLayers(options.layers);
    options.trainer=options.trainer||
    {
      method: 'adadelta', 
      l2_decay: 0.001, 
      batch_size: 10
    }
    var trainer = new convnetjs.SGDTrainer(net, 
                                           options.trainer);
    trainer.options= {
      width     : options.width,
      height    : options.height,
      depth     : options.depth,
      targets   : options.targets,
      normalize : options.normalize,
      layers    : options.layers,
      trainer   : options.trainer,
    };
    return { trainer:trainer, network:net, options:trainer.options };
  },
  
  // convert data to volumes
  convert : function (x,options) {
    function toFloat32(o) {
      if (o.__constructor__=='Math.VectorTA') return Math.VectorTA(o,{datatype:'Float32'});
      if (o.__constructor__=='Math.MatrixTA') return Math.MatrixTA(o,{datatype:'Float32'});
      if (isTypedArray(o)) return new Float32Array(o);
    }
    switch (options.depth) {
      case 1: // GREY8 []/ number [][]
        var row0=x[0];
        if (isLinearArray(row0)) {
          if ((options.scale || options.normalize) && !Math.isFloat(row0)) {
            // need to convert to Float32
            x=x.map(function (row) { return toFloat32(row) })
            that.stats.convFloat += x.length;
          }
          if (options.scale) {
            x=x.map(function (row) {
              return that.ml.utils.scale(row,options.scale);
            })
            that.stats.scale += x.length;
          } else if (options.normalize) {
            var a,b,
                c=options.normalize[0],
                d=options.normalize[1];
            x.forEach(function (row) {
              var min=Math.min.apply(null,row),
                  max=Math.max.apply(null,row);
              if (a==undefined) a=min; else a=Math.min(a,min);
              if (b==undefined) b=max; else b=Math.max(b,max);        
            })
            options.scale = that.ml.utils.toScale(a,b,c,d);
            x=x.map(function (row) {
              return that.ml.utils.scale(row,options.scale);
            })
            that.stats.scale += x.length;
          }
          x=x.map(function (row) {
            var vol = new convnetjs.Vol(options.width, options.height, options.depth, row.data?row.data:row); //input volume (image)
            console.log(vol)
            return vol;
          });
          that.stats.volRef += x.length;
        } else if (row0 instanceof Array && row0[0] instanceof Array) {
            // assuming image number [][][] layout
            var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
            var i=0;
            for (var yc=0;yc<options.height;yc++) {
              for (var xc=0;xc<options.width;xx++) {
                var v = row[yc][xc];
                if (options.scale) v=that.ml.utils.scale(v,options.scale);
                vol.set(xc,yc,zc,v);
              }
            }
            that.stats.volCopy += (options.height*options.width);
            return vol;        
        };
        break;
      case 3:   // RGB []/RGBA [] /number [][][] image data
        // options.scale should be provided
        var row0=x[0];
        if (isLinearArray(row0)) {
          if ((options.scale || options.normalize) && !Math.isFloat(row0)) {
            // need to convert to Float32
            x=x.map(function (row) { return toFloat32(row) })
            that.stats.convFloat += x.length;
          }
          var channels = (row0.data||row0).length/(options.width*options.height);
          if (channels==options.depth) {
            x=x.map(function (row) {
              var vol = new convnetjs.Vol(options.width, options.height, options.depth, row.data?row.data:row); //input volume (image)
              return vol;            
            })
            that.stats.volRef += x.length;
          } else {
            x=x.map(function (row) {
              // assuming image RGB/RGBA layout
              var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
              var i=0;
              for (var yc=0;yc<options.height;yc++) {
                for (var xc=0;xc<options.width;xc++) {
                  for (var zc=0;zc<options.depth;zc++) {
                    var v = row[i * channels + zc]; // alpha channel is ignored!?
                    if (options.scale) v=that.ml.utils.scale(v,options.scale);
                    vol.set(xc,yc,zc,v);
                  }
                  i++;
                }
              }
              that.stats.volCopy += (options.height*options.width*options.depth);
              return vol;
            })
          }
        } else if (row0 instanceof Array && row0[0] instanceof Array) {
            // assuming image number [][][] layout
            var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
            var i=0;
            for (var yc=0;yc<options.height;yc++) {
              for (var xc=0;xc<options.width;cx++) {
                for (var zc=0;zc<options.depth;zc++) {
                  var v = row[yc][xc][zc];
                  if (options.scale) v=that.ml.utils.scale(v,options.scale);
                  vol.set(xc,yc,zc,v);
                }
                i++;
              }
            }
            that.stats.volCopy += (options.height*options.width*options.depth);
            return vol;        
        };      
        break;
       
    }
    return x;
  },

  // ML module back reference
  ml:{},
  
  predict: function (model,sample) {
    var trainer = model.trainer, options = trainer.options;
    if (Utils.isArray(sample[0])) {
      var vols = that.convert(sample,options);
      return vols.map(function (vol) {
        return trainer.net.forward(vol);      
      })
    } else {
      var vol = that.convert([sample],options)[0];
      return trainer.net.forward(vol);
    }
  },
  
  print: function () {
  },
  
  // !!! updates model parameters (depth, width, height) if not already set on model creation
  train : function (model, options) {
    var trainer = model.trainer, result,
        row0 = options.x && options.x[0];
    if (!options.iterations)  options.iterations=10;
    if (!options.width) {
      if (isLinearArray(row0)) {
        options.width=row0.length;
        options.height=1;
      } else if (row0[0] instanceof Array) {
        options.height=row0.length;
        options.width=row0[0].length;
      }
    }
    if (!options.depth) {
      if (isLinearArray(row0)) {
        options.depth=1;
      } else if (row0[0] instanceof Array) {
        if (row0[0][0] instanceof Array) 
          options.depth=row0[0][0].length;
        else options.depth=1;
      }
    }
    // convert matrix (2dim/3dim) to volume elements
    var x = options.x;
    var y = options.y;
    delete options.x;
    delete options.y;
    x = that.convert(x,options);

    if (!options.targets) {
      options.targets=that.ml.stats.unique(y).sort(function (a,b) { return a<b?-1:1 });;
    }
    Object.assign(trainer.options,options);
    var stop=false;
    function train (iterations,run) {
      for(var iters=0;iters<iterations;iters++) {
        var t1,t0;
        t0=Date.now();
        y.forEach(function (v,i) {
          result=trainer.train(x[i],options.targets.indexOf(v));
        })
        t1=Date.now();
        result.time=trainer.time=(t1-t0);
        result.iteration=run+iters;
        trainer.result=result;
        if (options.verbose) Code.print('Iteration #'+result.iteration+' '+inspect(result));
        if (options.callback) {
          var more=options.callback(result,run);
          if (more===false) stop=true;
        }
      }
    }
    if (!options.async) train(options.iterations,0);
    else {
      var runs = 0;
      return Code.loop(function () {
        train(1,runs);
        runs++;
        return !stop && runs < options.iterations;
      },true);
    }
    return result;  
  },
  
  update: function (data) {
  },
  
  current:function (module) { current=module.current; Aios=module;},
  
  version : '1.4.1X',
};
};
BundleModuleCode['plugins/ml/convnet']=function (module,exports){

/*** https://github.com/karpathy/convnetjs ***/
/*** @blab+ Ver. 1.2.1 ***/

var convnet={
  REVISION: 'ALPHA',
  datatype:'Float64'    // @blab+
}
module.exports=convnet;
"use strict";

/*** convnet_util ***/
// Random number utilities
var return_v = false;
var v_val = 0.0;
var gaussRandom = function() {
  if(return_v) { 
    return_v = false;
    return v_val; 
  }
  var u = 2*Math.random()-1;
  var v = 2*Math.random()-1;
  var r = u*u + v*v;
  if(r == 0 || r > 1) return gaussRandom();
  var c = Math.sqrt(-2*Math.log(r)/r);
  v_val = v*c; // cache this
  return_v = true;
  return u*c;
}
var randf = function(a, b) { return Math.random()*(b-a)+a; }
var randi = function(a, b) { return Math.floor(Math.random()*(b-a)+a); }
var randn = function(mu, std){ return mu+gaussRandom()*std; }

// Array utilities
var zeros = function(n) {
  if(typeof(n)==='undefined' || isNaN(n)) { return []; }
  if(typeof ArrayBuffer === 'undefined') {
    // lacking browser support
    var arr = new Array(n);
    for(var i=0;i<n;i++) { arr[i]= 0; }
    return arr;
  } else {
    return new (convnet.datatype=='Float32'?Float32Array:Float64Array)(n);
  }
}

var arrContains = function(arr, elt) {
  for(var i=0,n=arr.length;i<n;i++) {
    if(arr[i]===elt) return true;
  }
  return false;
}

var arrUnique = function(arr) {
  var b = [];
  for(var i=0,n=arr.length;i<n;i++) {
    if(!arrContains(b, arr[i])) {
      b.push(arr[i]);
    }
  }
  return b;
}

// return max and min of a given non-empty array.
var maxmin = function(w) {
  if(w.length === 0) { return {}; } // ... ;s
  var maxv = w[0];
  var minv = w[0];
  var maxi = 0;
  var mini = 0;
  var n = w.length;
  for(var i=1;i<n;i++) {
    if(w[i] > maxv) { maxv = w[i]; maxi = i; } 
    if(w[i] < minv) { minv = w[i]; mini = i; } 
  }
  return {maxi: maxi, maxv: maxv, mini: mini, minv: minv, dv:maxv-minv};
}

// create random permutation of numbers, in range [0...n-1]
var randperm = function(n) {
  var i = n,
      j = 0,
      temp;
  var array = [];
  for(var q=0;q<n;q++)array[q]=q;
  while (i--) {
      j = Math.floor(Math.random() * (i+1));
      temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;
}

// sample from list lst according to probabilities in list probs
// the two lists are of same size, and probs adds up to 1
var weightedSample = function(lst, probs) {
  var p = randf(0, 1.0);
  var cumprob = 0.0;
  for(var k=0,n=lst.length;k<n;k++) {
    cumprob += probs[k];
    if(p < cumprob) { return lst[k]; }
  }
}

// syntactic sugar function for getting default parameter values
var getopt = function(opt, field_name, default_value) {
  if(typeof field_name === 'string') {
    // case of single string
    return (typeof opt[field_name] !== 'undefined') ? opt[field_name] : default_value;
  } else {
    // assume we are given a list of string instead
    var ret = default_value;
    for(var i=0;i<field_name.length;i++) {
      var f = field_name[i];
      if (typeof opt[f] !== 'undefined') {
        ret = opt[f]; // overwrite return value
      }
    }
    return ret;
  }
}

function assert(condition, message) {
  if (!condition) {
    message = message || "Assertion failed";
    if (typeof Error !== "undefined") {
      throw new Error(message);
    }
    throw message; // Fallback
  }
}
// @blab+
function isArray(o) {
  return (typeof o == 'object') && (o.buffer instanceof ArrayBuffer || o instanceof Array)
}
function isTypedArray(o) {
  return o && o.buffer instanceof ArrayBuffer
}

convnet.randf = randf;
convnet.randi = randi;
convnet.randn = randn;
convnet.zeros = zeros;
convnet.maxmin = maxmin;
convnet.randperm = randperm;
convnet.weightedSample = weightedSample;
convnet.arrUnique = arrUnique;
convnet.arrContains = arrContains;
convnet.getopt = getopt;
convnet.assert = assert;

/*** convnet_vol ***/
// Vol is the basic building block of all data in a net.
// it is essentially just a 3D volume of numbers, with a
// width (sx), height (sy), and depth (depth).
// it is used to hold data for all filters, all volumes,
// all weights, and also stores all gradients w.r.t. 
// the data. c is optionally a value to initialize the volume
// with. If c is missing, fills the Vol with random numbers.
var Vol = function(sx, sy, depth, c) {
  // this is how you check if a variable is an array. Oh, Javascript :)
  // if(Object.prototype.toString.call(sx) === '[object Array]') {
  if (isArray(sx)) {
    // we were given a list in sx, assume 1D volume and fill it up
    this.sx = 1;
    this.sy = 1;
    this.depth = sx.length;
    // we have to do the following copy because we want to use
    // fast typed arrays, not an ordinary javascript array
    this.w = convnet.zeros(this.depth);
    this.dw = convnet.zeros(this.depth);
    for(var i=0;i<this.depth;i++) {
      this.w[i] = sx[i];
    }
  } else {
    // we were given dimensions of the vol
    this.sx = sx;
    this.sy = sy;
    this.depth = depth;
    var n = sx*sy*depth;
    // @blab+
    if (isArray(c)) {
      this.w  = c;
      this.dw = convnet.zeros(n);
      return;
    } else {
      this.w  = convnet.zeros(n);
      this.dw = convnet.zeros(n);
    }
    if(typeof c === 'undefined') {
      // weight normalization is done to equalize the output
      // variance of every neuron, otherwise neurons with a lot
      // of incoming connections have outputs of larger variance
      var scale = Math.sqrt(1.0/(sx*sy*depth));
      for(var i=0;i<n;i++) { 
        this.w[i] = convnet.randn(0.0, scale);
      }
    } else if (c!=0) {
      for(var i=0;i<n;i++) { 
        this.w[i] = c;
      }
    }
  }
}

Vol.prototype = {
  get: function(x, y, d) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    return this.w[ix];
  },
  set: function(x, y, d, v) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    this.w[ix] = v; 
  },
  add: function(x, y, d, v) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    this.w[ix] += v; 
  },
  get_grad: function(x, y, d) { 
    var ix = ((this.sx * y)+x)*this.depth+d;
    return this.dw[ix]; 
  },
  set_grad: function(x, y, d, v) { 
    var ix = ((this.sx * y)+x)*this.depth+d;
    this.dw[ix] = v; 
  },
  add_grad: function(x, y, d, v) { 
    var ix = ((this.sx * y)+x)*this.depth+d;
    this.dw[ix] += v; 
  },
  cloneAndZero: function() { return new Vol(this.sx, this.sy, this.depth, 0.0)},
  clone: function() {
    var V = new Vol(this.sx, this.sy, this.depth, 0.0);
    var n = this.w.length;
    for(var i=0;i<n;i++) { V.w[i] = this.w[i]; }
    return V;
  },
  addFrom: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] += V.w[k]; }},
  addFromScaled: function(V, a) { for(var k=0;k<this.w.length;k++) { this.w[k] += a*V.w[k]; }},
  setConst: function(a) { for(var k=0;k<this.w.length;k++) { this.w[k] = a; }},

  toJSON: function() {
    // todo: we may want to only save d most significant digits to save space
    var json = {}
    json.sx = this.sx; 
    json.sy = this.sy;
    json.depth = this.depth;
    json.w = this.w;
    return json;
    // we wont back up gradients to save space
  },
  fromJSON: function(json) {
    this.sx = json.sx;
    this.sy = json.sy;
    this.depth = json.depth;

    var n = this.sx*this.sy*this.depth;
    this.w = convnet.zeros(n);
    this.dw = convnet.zeros(n);
    // copy over the elements.
    for(var i=0;i<n;i++) {
      this.w[i] = json.w[i];
    }
  }
}

convnet.Vol = Vol;

/*** convnet_vol_util ***/
var Vol = convnet.Vol; // convenience

// Volume utilities
// intended for use with data augmentation
// crop is the size of output
// dx,dy are offset wrt incoming volume, of the shift
// fliplr is boolean on whether we also want to flip left<->right
var augment = function(V, crop, dx, dy, fliplr) {
  // note assumes square outputs of size crop x crop
  if(typeof(fliplr)==='undefined') var fliplr = false;
  if(typeof(dx)==='undefined') var dx = convnet.randi(0, V.sx - crop);
  if(typeof(dy)==='undefined') var dy = convnet.randi(0, V.sy - crop);
  
  // randomly sample a crop in the input volume
  var W;
  if(crop !== V.sx || dx!==0 || dy!==0) {
    W = new Vol(crop, crop, V.depth, 0.0);
    for(var x=0;x<crop;x++) {
      for(var y=0;y<crop;y++) {
        if(x+dx<0 || x+dx>=V.sx || y+dy<0 || y+dy>=V.sy) continue; // oob
        for(var d=0;d<V.depth;d++) {
         W.set(x,y,d,V.get(x+dx,y+dy,d)); // copy data over
        }
      }
    }
  } else {
    W = V;
  }

  if(fliplr) {
    // flip volume horziontally
    var W2 = W.cloneAndZero();
    for(var x=0;x<W.sx;x++) {
      for(var y=0;y<W.sy;y++) {
        for(var d=0;d<W.depth;d++) {
         W2.set(x,y,d,W.get(W.sx - x - 1,y,d)); // copy data over
        }
      }
    }
    W = W2; //swap
  }
  return W;
}

// img is a DOM element that contains a loaded image
// returns a Vol of size (W, H, 4). 4 is for RGBA
var img_to_vol = function(img, convert_grayscale) {

  if(typeof(convert_grayscale)==='undefined') var convert_grayscale = false;

  var canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  var ctx = canvas.getContext("2d");

  // due to a Firefox bug
  try {
    ctx.drawImage(img, 0, 0);
  } catch (e) {
    if (e.name === "NS_ERROR_NOT_AVAILABLE") {
      // sometimes happens, lets just abort
      return false;
    } else {
      throw e;
    }
  }

  try {
    var img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
  } catch (e) {
    if(e.name === 'IndexSizeError') {
      return false; // not sure what causes this sometimes but okay abort
    } else {
      throw e;
    }
  }

  // prepare the input: get pixels and normalize them
  var p = img_data.data;
  var W = img.width;
  var H = img.height;
  var pv = []
  for(var i=0;i<p.length;i++) {
    pv.push(p[i]/255.0-0.5); // normalize image pixels to [-0.5, 0.5]
  }
  var x = new Vol(W, H, 4, 0.0); //input volume (image)
  x.w = pv;

  if(convert_grayscale) {
    // flatten into depth=1 array
    var x1 = new Vol(W, H, 1, 0.0);
    for(var i=0;i<W;i++) {
      for(var j=0;j<H;j++) {
        x1.set(i,j,0,x.get(i,j,0));
      }
    }
    x = x1;
  }

  return x;
}

convnet.augment = augment;
convnet.img_to_vol = img_to_vol;


/*** convnet_layers_dotproducts ***/
// This file contains all layers that do dot products with input,
// but usually in a different connectivity pattern and weight sharing
// schemes: 
// - FullyConn is fully connected dot products 
// - ConvLayer does convolutions (so weight sharing spatially)
// putting them together in one file because they are very similar
var ConvLayer = function(opt) {
  var opt = opt || {};

  // required
  this.out_depth = opt.filters;
  this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;
  
  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input
  // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed
  // final application.
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'conv';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i<this.out_depth;i++) { this.filters.push(new Vol(this.sx, this.sy, this.in_depth)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}
ConvLayer.prototype = {
  forward: function(V, is_training) {
    // optimized code by @mdda that achieves 2x speedup over previous version

    this.in_act = V;
    var A = new Vol(this.out_sx |0, this.out_sy |0, this.out_depth |0, 0.0);
    
    var V_sx = V.sx |0;
    var V_sy = V.sy |0;
    var xy_stride = this.stride |0;

    for(var d=0;d<this.out_depth;d++) {
      var f = this.filters[d];
      var x = -this.pad |0;
      var y = -this.pad |0;
      for(var ay=0; ay<this.out_sy; y+=xy_stride,ay++) {  // xy_stride
        x = -this.pad |0;
        for(var ax=0; ax<this.out_sx; x+=xy_stride,ax++) {  // xy_stride

          // convolve centered at this particular location
          var a = 0.0;
          for(var fy=0;fy<f.sy;fy++) {
            var oy = y+fy; // coordinates in the original input array coordinates
            for(var fx=0;fx<f.sx;fx++) {
              var ox = x+fx;
              if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {
                for(var fd=0;fd<f.depth;fd++) {
                  // avoid function call overhead (x2) for efficiency, compromise modularity :(
                  a += f.w[((f.sx * fy)+fx)*f.depth+fd] * V.w[((V_sx * oy)+ox)*V.depth+fd];
                }
              }
            }
          }
          a += this.biases.w[d];
          A.set(ax, ay, d, a);
        }
      }
    }
    this.out_act = A;
    return this.out_act;
  },
  backward: function() {

    var V = this.in_act;
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it

    var V_sx = V.sx |0;
    var V_sy = V.sy |0;
    var xy_stride = this.stride |0;

    for(var d=0;d<this.out_depth;d++) {
      var f = this.filters[d];
      var x = -this.pad |0;
      var y = -this.pad |0;
      for(var ay=0; ay<this.out_sy; y+=xy_stride,ay++) {  // xy_stride
        x = -this.pad |0;
        for(var ax=0; ax<this.out_sx; x+=xy_stride,ax++) {  // xy_stride

          // convolve centered at this particular location
          var chain_grad = this.out_act.get_grad(ax,ay,d); // gradient from above, from chain rule
          for(var fy=0;fy<f.sy;fy++) {
            var oy = y+fy; // coordinates in the original input array coordinates
            for(var fx=0;fx<f.sx;fx++) {
              var ox = x+fx;
              if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {
                for(var fd=0;fd<f.depth;fd++) {
                  // avoid function call overhead (x2) for efficiency, compromise modularity :(
                  var ix1 = ((V_sx * oy)+ox)*V.depth+fd;
                  var ix2 = ((f.sx * fy)+fx)*f.depth+fd;
                  f.dw[ix2] += V.w[ix1]*chain_grad;
                  V.dw[ix1] += f.w[ix2]*chain_grad;
                }
              }
            }
          }
          this.biases.dw[d] += chain_grad;
        }
      }
    }
  },
  getParamsAndGrads: function() {
    var response = [];
    for(var i=0;i<this.out_depth;i++) {
      response.push({params: this.filters[i].w, grads: this.filters[i].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul});
    }
    response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
    return response;
  },
  toJSON: function() {
    var json = {};
    json.sx = this.sx; // filter size in x, y dims
    json.sy = this.sy;
    json.stride = this.stride;
    json.in_depth = this.in_depth;
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.l1_decay_mul = this.l1_decay_mul;
    json.l2_decay_mul = this.l2_decay_mul;
    json.pad = this.pad;
    json.filters = [];
    for(var i=0;i<this.filters.length;i++) {
      json.filters.push(this.filters[i].toJSON());
    }
    json.biases = this.biases.toJSON();
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.sx = json.sx; // filter size in x, y dims
    this.sy = json.sy;
    this.stride = json.stride;
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i<json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.fromJSON(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}

var FullyConnLayer = function(opt) {
  var opt = opt || {};

  // required
  // ok fine we will allow 'filters' as the word as well
  this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters;

  // optional 
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'fc';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i<this.out_depth ;i++) { this.filters.push(new Vol(1, 1, this.num_inputs)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}

FullyConnLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var A = new Vol(1, 1, this.out_depth, 0.0);
    var Vw = V.w;
    for(var i=0;i<this.out_depth;i++) {
      var a = 0.0;
      var wi = this.filters[i].w;
      for(var d=0;d<this.num_inputs;d++) {
        a += Vw[d] * wi[d]; // for efficiency use Vols directly for now
      }
      a += this.biases.w[i];
      A.w[i] = a;
    }
    this.out_act = A;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act;
    V.dw = convnet.zeros(V.w.length); // zero out the gradient in input Vol
    
    // compute gradient wrt weights and data
    for(var i=0;i<this.out_depth;i++) {
      var tfi = this.filters[i];
      var chain_grad = this.out_act.dw[i];
      for(var d=0;d<this.num_inputs;d++) {
        V.dw[d] += tfi.w[d]*chain_grad; // grad wrt input data
        tfi.dw[d] += V.w[d]*chain_grad; // grad wrt params
      }
      this.biases.dw[i] += chain_grad;
    }
  },
  getParamsAndGrads: function() {
    var response = [];
    for(var i=0;i<this.out_depth;i++) {
      response.push({params: this.filters[i].w, grads: this.filters[i].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul});
    }
    response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
    return response;
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    json.l1_decay_mul = this.l1_decay_mul;
    json.l2_decay_mul = this.l2_decay_mul;
    json.filters = [];
    for(var i=0;i<this.filters.length;i++) {
      json.filters.push(this.filters[i].toJSON());
    }
    json.biases = this.biases.toJSON();
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.filters = [];
    for(var i=0;i<json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.fromJSON(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}

convnet.ConvLayer = ConvLayer;
convnet.FullyConnLayer = FullyConnLayer;


/*** convnet_layers_pool ***/
var PoolLayer = function(opt) {

  var opt = opt || {};

  // required
  this.sx = opt.sx; // filter size
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;

  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume

  // computed
  this.out_depth = this.in_depth;
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'pool';
  // store switches for x,y coordinates for where the max comes from, for each output neuron
  this.switchx = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
  this.switchy = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
}

PoolLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;

    var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
    
    var n=0; // a counter for switches
    for(var d=0;d<this.out_depth;d++) {
      var x = -this.pad;
      var y = -this.pad;
      for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
        y = -this.pad;
        for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

          // convolve centered at this particular location
          var a = -99999; // hopefully small enough ;\
          var winx=-1,winy=-1;
          for(var fx=0;fx<this.sx;fx++) {
            for(var fy=0;fy<this.sy;fy++) {
              var oy = y+fy;
              var ox = x+fx;
              if(oy>=0 && oy<V.sy && ox>=0 && ox<V.sx) {
                var v = V.get(ox, oy, d);
                // perform max pooling and store pointers to where
                // the max came from. This will speed up backprop 
                // and can help make nice visualizations in future
                if(v > a) { a = v; winx=ox; winy=oy;}
              }
            }
          }
          this.switchx[n] = winx;
          this.switchy[n] = winy;
          n++;
          A.set(ax, ay, d, a);
        }
      }
    }
    this.out_act = A;
    return this.out_act;
  },
  backward: function() { 
    // pooling layers have no parameters, so simply compute 
    // gradient wrt data here
    var V = this.in_act;
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt data
    var A = this.out_act; // computed in forward pass 

    var n = 0;
    for(var d=0;d<this.out_depth;d++) {
      var x = -this.pad;
      var y = -this.pad;
      for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
        y = -this.pad;
        for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

          var chain_grad = this.out_act.get_grad(ax,ay,d);
          V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);
          n++;

        }
      }
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.sx = this.sx;
    json.sy = this.sy;
    json.stride = this.stride;
    json.in_depth = this.in_depth;
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.pad = this.pad;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.sx = json.sx;
    this.sy = json.sy;
    this.stride = json.stride;
    this.in_depth = json.in_depth;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0; // backwards compatibility
    this.switchx = convnet.zeros(this.out_sx*this.out_sy*this.out_depth); // need to re-init these appropriately
    this.switchy = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
  }
}

convnet.PoolLayer = PoolLayer;


/*** convnet_layers_input ***/
var getopt = convnet.getopt;

var InputLayer = function(opt) {
  var opt = opt || {};

  // required: depth
  this.out_depth = getopt(opt, ['out_depth', 'depth'], 0);

  // optional: default these dimensions to 1
  this.out_sx = getopt(opt, ['out_sx', 'sx', 'width'], 1);
  this.out_sy = getopt(opt, ['out_sy', 'sy', 'height'], 1);
  
  // computed
  this.layer_type = 'input';
}
InputLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    this.out_act = V;
    return this.out_act; // simply identity function for now
  },
  backward: function() { },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

convnet.InputLayer = InputLayer;


/*** convnet_layers_loss ***/
// Layers that implement a loss. Currently these are the layers that 
// can initiate a backward() pass. In future we probably want a more 
// flexible system that can accomodate multiple losses to do multi-task
// learning, and stuff like that. But for now, one of the layers in this
// file must be the final layer in a Net.

// This is a classifier, with N discrete classes from 0 to N-1
// it gets a stream of N incoming numbers and computes the softmax
// function (exponentiate and normalize to sum to 1 as probabilities should)
var SoftmaxLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'softmax';
}

SoftmaxLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;

    var A = new Vol(1, 1, this.out_depth, 0.0);

    // compute max activation
    var as = V.w;
    var amax = V.w[0];
    for(var i=1;i<this.out_depth;i++) {
      if(as[i] > amax) amax = as[i];
    }

    // compute exponentials (carefully to not blow up)
    var es = convnet.zeros(this.out_depth);
    var esum = 0.0;
    for(var i=0;i<this.out_depth;i++) {
      var e = Math.exp(as[i] - amax);
      esum += e;
      es[i] = e;
    }

    // normalize and output to sum to one
    for(var i=0;i<this.out_depth;i++) {
      es[i] /= esum;
      A.w[i] = es[i];
    }

    this.es = es; // save these for backprop
    this.out_act = A;
    return this.out_act;
  },
  backward: function(y) {

    // compute and accumulate gradient wrt weights and bias of this layer
    var x = this.in_act;
    x.dw = convnet.zeros(x.w.length); // zero out the gradient of input Vol

    for(var i=0;i<this.out_depth;i++) {
      var indicator = i === y ? 1.0 : 0.0;
      var mul = -(indicator - this.es[i]);
      x.dw[i] = mul;
    }

    // loss is the class negative log likelihood
    return -Math.log(this.es[y]);
  },
  getParamsAndGrads: function() { 
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
  }
}

// implements an L2 regression cost layer,
// so penalizes \sum_i(||x_i - y_i||^2), where x is its input
// and y is the user-provided array of "correct" values.
var RegressionLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'regression';
}

RegressionLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    this.out_act = V;
    return V; // identity function
  },
  // y is a list here of size num_inputs
  // or it can be a number if only one value is regressed
  // or it can be a struct {dim: i, val: x} where we only want to 
  // regress on dimension i and asking it to have value x
  backward: function(y) { 

    // compute and accumulate gradient wrt weights and bias of this layer
    var x = this.in_act;
    x.dw = convnet.zeros(x.w.length); // zero out the gradient of input Vol
    var loss = 0.0;
    if(y instanceof Array || y instanceof Float64Array || y instanceof Float32Array) {
      for(var i=0;i<this.out_depth;i++) {
        var dy = x.w[i] - y[i];
        x.dw[i] = dy;
        loss += 0.5*dy*dy;
      }
    } else if(typeof y === 'number') {
      // lets hope that only one number is being regressed
      var dy = x.w[0] - y;
      x.dw[0] = dy;
      loss += 0.5*dy*dy;
    } else {
      // assume it is a struct with entries .dim and .val
      // and we pass gradient only along dimension dim to be equal to val
      var i = y.dim;
      var yi = y.val;
      var dy = x.w[i] - yi;
      x.dw[i] = dy;
      loss += 0.5*dy*dy;
    }
    return loss;
  },
  getParamsAndGrads: function() { 
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
  }
}

var SVMLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'svm';
}

SVMLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    this.out_act = V; // nothing to do, output raw scores
    return V;
  },
  backward: function(y) {

    // compute and accumulate gradient wrt weights and bias of this layer
    var x = this.in_act;
    x.dw = convnet.zeros(x.w.length); // zero out the gradient of input Vol

    // we're using structured loss here, which means that the score
    // of the ground truth should be higher than the score of any other 
    // class, by a margin
    var yscore = x.w[y]; // score of ground truth
    var margin = 1.0;
    var loss = 0.0;
    for(var i=0;i<this.out_depth;i++) {
      if(y === i) { continue; }
      var ydiff = -yscore + x.w[i] + margin;
      if(ydiff > 0) {
        // violating dimension, apply loss
        x.dw[i] += 1;
        x.dw[y] -= 1;
        loss += ydiff;
      }
    }

    return loss;
  },
  getParamsAndGrads: function() { 
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
  }
}

convnet.RegressionLayer = RegressionLayer;
convnet.SoftmaxLayer = SoftmaxLayer;
convnet.SVMLayer = SVMLayer;


/*** convnet_layers_nonlinearities ***/
// Implements ReLU nonlinearity elementwise
// x -> max(0, x)
// the output is in [0, inf)
var ReluLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'relu';
}
ReluLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.clone();
    var N = V.w.length;
    var V2w = V2.w;
    for(var i=0;i<N;i++) { 
      if(V2w[i] < 0) V2w[i] = 0; // threshold at 0
    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      if(V2.w[i] <= 0) V.dw[i] = 0; // threshold
      else V.dw[i] = V2.dw[i];
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

// Implements Sigmoid nnonlinearity elementwise
// x -> 1/(1+e^(-x))
// so the output is between 0 and 1.
var SigmoidLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'sigmoid';
}
SigmoidLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.cloneAndZero();
    var N = V.w.length;
    var V2w = V2.w;
    var Vw = V.w;
    for(var i=0;i<N;i++) { 
      V2w[i] = 1.0/(1.0+Math.exp(-Vw[i]));
    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      var v2wi = V2.w[i];
      V.dw[i] =  v2wi * (1.0 - v2wi) * V2.dw[i];
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

// Implements Maxout nnonlinearity that computes
// x -> max(x)
// where x is a vector of size group_size. Ideally of course,
// the input size should be exactly divisible by group_size
var MaxoutLayer = function(opt) {
  var opt = opt || {};

  // required
  this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = Math.floor(opt.in_depth / this.group_size);
  this.layer_type = 'maxout';

  this.switches = convnet.zeros(this.out_sx*this.out_sy*this.out_depth); // useful for backprop
}
MaxoutLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var N = this.out_depth; 
    var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);

    // optimization branch. If we're operating on 1D arrays we dont have
    // to worry about keeping track of x,y,d coordinates inside
    // input volumes. In convnets we do :(
    if(this.out_sx === 1 && this.out_sy === 1) {
      for(var i=0;i<N;i++) {
        var ix = i * this.group_size; // base index offset
        var a = V.w[ix];
        var ai = 0;
        for(var j=1;j<this.group_size;j++) {
          var a2 = V.w[ix+j];
          if(a2 > a) {
            a = a2;
            ai = j;
          }
        }
        V2.w[i] = a;
        this.switches[i] = ix + ai;
      }
    } else {
      var n=0; // counter for switches
      for(var x=0;x<V.sx;x++) {
        for(var y=0;y<V.sy;y++) {
          for(var i=0;i<N;i++) {
            var ix = i * this.group_size;
            var a = V.get(x, y, ix);
            var ai = 0;
            for(var j=1;j<this.group_size;j++) {
              var a2 = V.get(x, y, ix+j);
              if(a2 > a) {
                a = a2;
                ai = j;
              }
            }
            V2.set(x,y,i,a);
            this.switches[n] = ix + ai;
            n++;
          }
        }
      }

    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = this.out_depth;
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt data

    // pass the gradient through the appropriate switch
    if(this.out_sx === 1 && this.out_sy === 1) {
      for(var i=0;i<N;i++) {
        var chain_grad = V2.dw[i];
        V.dw[this.switches[i]] = chain_grad;
      }
    } else {
      // bleh okay, lets do this the hard way
      var n=0; // counter for switches
      for(var x=0;x<V2.sx;x++) {
        for(var y=0;y<V2.sy;y++) {
          for(var i=0;i<N;i++) {
            var chain_grad = V2.get_grad(x,y,i);
            V.set_grad(x,y,this.switches[n],chain_grad);
            n++;
          }
        }
      }
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.group_size = this.group_size;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
    this.group_size = json.group_size;
    this.switches = convnet.zeros(this.group_size);
  }
}

// a helper function, since tanh is not yet part of ECMAScript. Will be in v6.
function tanh(x) {
  var y = Math.exp(2 * x);
  return (y - 1) / (y + 1);
}
// Implements Tanh nnonlinearity elementwise
// x -> tanh(x) 
// so the output is between -1 and 1.
var TanhLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'tanh';
}
TanhLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.cloneAndZero();
    var N = V.w.length;
    for(var i=0;i<N;i++) { 
      V2.w[i] = tanh(V.w[i]);
    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      var v2wi = V2.w[i];
      V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

convnet.TanhLayer = TanhLayer;
convnet.MaxoutLayer = MaxoutLayer;
convnet.ReluLayer = ReluLayer;
convnet.SigmoidLayer = SigmoidLayer;




/*** convnet_layers_dropout ***/
// An inefficient dropout layer
// Note this is not most efficient implementation since the layer before
// computed all these activations and now we're just going to drop them :(
// same goes for backward pass. Also, if we wanted to be efficient at test time
// we could equivalently be clever and upscale during train and copy pointers during test
// todo: make more efficient.
var DropoutLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'dropout';
  this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;
  this.dropped = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
}
DropoutLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    if(typeof(is_training)==='undefined') { is_training = false; } // default is prediction mode
    var V2 = V.clone();
    var N = V.w.length;
    if(is_training) {
      // do dropout
      for(var i=0;i<N;i++) {
        if(Math.random()<this.drop_prob) { V2.w[i]=0; this.dropped[i] = true; } // drop!
        else {this.dropped[i] = false;}
      }
    } else {
      // scale the activations during prediction
      for(var i=0;i<N;i++) { V2.w[i]*=this.drop_prob; }
    }
    this.out_act = V2;
    return this.out_act; // dummy identity function for now
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var chain_grad = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      if(!(this.dropped[i])) { 
        V.dw[i] = chain_grad.dw[i]; // copy over the gradient
      }
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.drop_prob = this.drop_prob;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
    this.drop_prob = json.drop_prob;
  }
}

convnet.DropoutLayer = DropoutLayer;

/*** convnet_layers_normailzation ***/
// a bit experimental layer for now. I think it works but I'm not 100%
// the gradient check is a bit funky. I'll look into this a bit later.
// Local Response Normalization in window, along depths of volumes
var LocalResponseNormalizationLayer = function(opt) {
  var opt = opt || {};

  // required
  this.k = opt.k;
  this.n = opt.n;
  this.alpha = opt.alpha;
  this.beta = opt.beta;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'lrn';

  // checks
  if(this.n%2 === 0) { console.log('WARNING n should be odd for LRN layer'); }
}
LocalResponseNormalizationLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;

    var A = V.cloneAndZero();
    this.S_cache_ = V.cloneAndZero();
    var n2 = Math.floor(this.n/2);
    for(var x=0;x<V.sx;x++) {
      for(var y=0;y<V.sy;y++) {
        for(var i=0;i<V.depth;i++) {

          var ai = V.get(x,y,i);

          // normalize in a window of size n
          var den = 0.0;
          for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {
            var aa = V.get(x,y,j);
            den += aa*aa;
          }
          den *= this.alpha / this.n;
          den += this.k;
          this.S_cache_.set(x,y,i,den); // will be useful for backprop
          den = Math.pow(den, this.beta);
          A.set(x,y,i,ai/den);
        }
      }
    }

    this.out_act = A;
    return this.out_act; // dummy identity function for now
  },
  backward: function() { 
    // evaluate gradient wrt data
    var V = this.in_act; // we need to set dw of this
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt data
    var A = this.out_act; // computed in forward pass 

    var n2 = Math.floor(this.n/2);
    for(var x=0;x<V.sx;x++) {
      for(var y=0;y<V.sy;y++) {
        for(var i=0;i<V.depth;i++) {

          var chain_grad = this.out_act.get_grad(x,y,i);
          var S = this.S_cache_.get(x,y,i);
          var SB = Math.pow(S, this.beta);
          var SB2 = SB*SB;

          // normalize in a window of size n
          for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {              
            var aj = V.get(x,y,j); 
            var g = -aj*this.beta*Math.pow(S,this.beta-1)*this.alpha/this.n*2*aj;
            if(j===i) g+= SB;
            g /= SB2;
            g *= chain_grad;
            V.add_grad(x,y,j,g);
          }

        }
      }
    }
  },
  getParamsAndGrads: function() { return []; },
  toJSON: function() {
    var json = {};
    json.k = this.k;
    json.n = this.n;
    json.alpha = this.alpha; // normalize by size
    json.beta = this.beta;
    json.out_sx = this.out_sx; 
    json.out_sy = this.out_sy;
    json.out_depth = this.out_depth;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.k = json.k;
    this.n = json.n;
    this.alpha = json.alpha; // normalize by size
    this.beta = json.beta;
    this.out_sx = json.out_sx; 
    this.out_sy = json.out_sy;
    this.out_depth = json.out_depth;
    this.layer_type = json.layer_type;
  }
}

convnet.LocalResponseNormalizationLayer = LocalResponseNormalizationLayer;



/*** convnet_net ***/
var assert = convnet.assert;

// Net manages a set of layers
// For now constraints: Simple linear order of layers, first layer input last layer a cost layer
var Net = function(options) {
  this.layers = [];
}

Net.prototype = {
  
  // takes a list of layer definitions and creates the network layer objects
  makeLayers: function(defs) {

    // few checks
    assert(defs.length >= 2, 'Error! At least one input layer and one loss layer are required.');
    assert(defs[0].type === 'input', 'Error! First layer must be the input layer, to declare size of inputs');

    // desugar layer_defs for adding activation, dropout layers etc
    var desugar = function() {
      var new_defs = [];
      for(var i=0;i<defs.length;i++) {
        var def = defs[i];
        
        if(def.type==='softmax' || def.type==='svm') {
          // add an fc layer here, there is no reason the user should
          // have to worry about this and we almost always want to
          new_defs.push({type:'fc', num_neurons: def.num_classes});
        }

        if(def.type==='regression') {
          // add an fc layer here, there is no reason the user should
          // have to worry about this and we almost always want to
          new_defs.push({type:'fc', num_neurons: def.num_neurons});
        }

        if((def.type==='fc' || def.type==='conv') 
            && typeof(def.bias_pref) === 'undefined'){
          def.bias_pref = 0.0;
          if(typeof def.activation !== 'undefined' && def.activation === 'relu') {
            def.bias_pref = 0.1; // relus like a bit of positive bias to get gradients early
            // otherwise it's technically possible that a relu unit will never turn on (by chance)
            // and will never get any gradient and never contribute any computation. Dead relu.
          }
        }

        new_defs.push(def);

        if(typeof def.activation !== 'undefined') {
          if(def.activation==='relu') { new_defs.push({type:'relu'}); }
          else if (def.activation==='sigmoid') { new_defs.push({type:'sigmoid'}); }
          else if (def.activation==='tanh') { new_defs.push({type:'tanh'}); }
          else if (def.activation==='maxout') {
            // create maxout activation, and pass along group size, if provided
            var gs = def.group_size !== 'undefined' ? def.group_size : 2;
            new_defs.push({type:'maxout', group_size:gs});
          }
          else { console.log('ERROR unsupported activation ' + def.activation); }
        }
        if(typeof def.drop_prob !== 'undefined' && def.type !== 'dropout') {
          new_defs.push({type:'dropout', drop_prob: def.drop_prob});
        }

      }
      return new_defs;
    }
    defs = desugar(defs);

    // create the layers
    this.layers = [];
    for(var i=0;i<defs.length;i++) {
      var def = defs[i];
      if(i>0) {
        var prev = this.layers[i-1];
        def.in_sx = prev.out_sx;
        def.in_sy = prev.out_sy;
        def.in_depth = prev.out_depth;
      }

      switch(def.type) {
        case 'fc': this.layers.push(new convnet.FullyConnLayer(def)); break;
        case 'lrn': this.layers.push(new convnet.LocalResponseNormalizationLayer(def)); break;
        case 'dropout': this.layers.push(new convnet.DropoutLayer(def)); break;
        case 'input': this.layers.push(new convnet.InputLayer(def)); break;
        case 'softmax': this.layers.push(new convnet.SoftmaxLayer(def)); break;
        case 'regression': this.layers.push(new convnet.RegressionLayer(def)); break;
        case 'conv': this.layers.push(new convnet.ConvLayer(def)); break;
        case 'pool': this.layers.push(new convnet.PoolLayer(def)); break;
        case 'relu': this.layers.push(new convnet.ReluLayer(def)); break;
        case 'sigmoid': this.layers.push(new convnet.SigmoidLayer(def)); break;
        case 'tanh': this.layers.push(new convnet.TanhLayer(def)); break;
        case 'maxout': this.layers.push(new convnet.MaxoutLayer(def)); break;
        case 'svm': this.layers.push(new convnet.SVMLayer(def)); break;
        default: console.log('ERROR: UNRECOGNIZED LAYER TYPE: ' + def.type);
      }
    }
  },

  // forward prop the network. 
  // The trainer class passes is_training = true, but when this function is
  // called from outside (not from the trainer), it defaults to prediction mode
  forward: function(V, is_training) {
    if(typeof(is_training) === 'undefined') is_training = false;
    var act = this.layers[0].forward(V, is_training);
    for(var i=1;i<this.layers.length;i++) {
      act = this.layers[i].forward(act, is_training);
    }
    return act;
  },

  getCostLoss: function(V, y) {
    this.forward(V, false);
    var N = this.layers.length;
    var loss = this.layers[N-1].backward(y);
    return loss;
  },
  
  // backprop: compute gradients wrt all parameters
  backward: function(y) {
    var N = this.layers.length;
    var loss = this.layers[N-1].backward(y); // last layer assumed to be loss layer
    for(var i=N-2;i>=0;i--) { // first layer assumed input
      this.layers[i].backward();
    }
    return loss;
  },
  getParamsAndGrads: function() {
    // accumulate parameters and gradients for the entire network
    var response = [];
    for(var i=0;i<this.layers.length;i++) {
      var layer_reponse = this.layers[i].getParamsAndGrads();
      for(var j=0;j<layer_reponse.length;j++) {
        response.push(layer_reponse[j]);
      }
    }
    return response;
  },
  getPrediction: function() {
    // this is a convenience function for returning the argmax
    // prediction, assuming the last layer of the net is a softmax
    var S = this.layers[this.layers.length-1];
    assert(S.layer_type === 'softmax', 'getPrediction function assumes softmax as last layer of the net!');

    var p = S.out_act.w;
    var maxv = p[0];
    var maxi = 0;
    for(var i=1;i<p.length;i++) {
      if(p[i] > maxv) { maxv = p[i]; maxi = i;}
    }
    return maxi; // return index of the class with highest class probability
  },
  toJSON: function() {
    var json = {};
    json.layers = [];
    for(var i=0;i<this.layers.length;i++) {
      json.layers.push(this.layers[i].toJSON());
    }
    return json;
  },
  fromJSON: function(json) {
    this.layers = [];
    for(var i=0;i<json.layers.length;i++) {
      var Lj = json.layers[i]
      var t = Lj.layer_type;
      var L;
      if(t==='input') { L = new convnet.InputLayer(); }
      if(t==='relu') { L = new convnet.ReluLayer(); }
      if(t==='sigmoid') { L = new convnet.SigmoidLayer(); }
      if(t==='tanh') { L = new convnet.TanhLayer(); }
      if(t==='dropout') { L = new convnet.DropoutLayer(); }
      if(t==='conv') { L = new convnet.ConvLayer(); }
      if(t==='pool') { L = new convnet.PoolLayer(); }
      if(t==='lrn') { L = new convnet.LocalResponseNormalizationLayer(); }
      if(t==='softmax') { L = new convnet.SoftmaxLayer(); }
      if(t==='regression') { L = new convnet.RegressionLayer(); }
      if(t==='fc') { L = new convnet.FullyConnLayer(); }
      if(t==='maxout') { L = new convnet.MaxoutLayer(); }
      if(t==='svm') { L = new convnet.SVMLayer(); }
      L.fromJSON(Lj);
      this.layers.push(L);
    }
  }
}

convnet.Net = Net;


/*** convnet_trainers ***/
var Trainer = function(net, options) {

  this.net = net;

  var options = options || {};
  this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
  this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
  this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
  this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
  this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adam/adagrad/adadelta/windowgrad/netsterov

  this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
  this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
  this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-8; // used in adam or adadelta
  this.beta1 = typeof options.beta1 !== 'undefined' ? options.beta1 : 0.9; // used in adam
  this.beta2 = typeof options.beta2 !== 'undefined' ? options.beta2 : 0.999; // used in adam

  this.k = 0; // iteration counter
  this.gsum = []; // last iteration gradients (used for momentum calculations)
  this.xsum = []; // used in adam or adadelta

  // check if regression is expected 
  if(this.net.layers[this.net.layers.length - 1].layer_type === "regression")
    this.regression = true;
  else
    this.regression = false;
}

Trainer.prototype = {
  train: function(x, y) {

    var start = new Date().getTime();
    this.net.forward(x, true); // also set the flag that lets the net know we're just training
    var end = new Date().getTime();
    var fwd_time = end - start;

    var start = new Date().getTime();
    var cost_loss = this.net.backward(y);
    var l2_decay_loss = 0.0;
    var l1_decay_loss = 0.0;
    var end = new Date().getTime();
    var bwd_time = end - start;

    if(this.regression && y.constructor !== Array)
      console.log("Warning: a regression net requires an array as training output vector.");
    
    this.k++;
    if(this.k % this.batch_size === 0) {

      var pglist = this.net.getParamsAndGrads();

      // initialize lists for accumulators. Will only be done once on first iteration
      if(this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {
        // only vanilla sgd doesnt need either lists
        // momentum needs gsum
        // adagrad needs gsum
        // adam and adadelta needs gsum and xsum
        for(var i=0;i<pglist.length;i++) {
          this.gsum.push(convnet.zeros(pglist[i].params.length));
          if(this.method === 'adam' || this.method === 'adadelta') {
            this.xsum.push(convnet.zeros(pglist[i].params.length));
          } else {
            this.xsum.push([]); // conserve memory
          }
        }
      }

      // perform an update for all sets of weights
      for(var i=0;i<pglist.length;i++) {
        var pg = pglist[i]; // param, gradient, other options in future (custom learning rate etc)
        var p = pg.params;
        var g = pg.grads;

        // learning rate for some parameters.
        var l2_decay_mul = typeof pg.l2_decay_mul !== 'undefined' ? pg.l2_decay_mul : 1.0;
        var l1_decay_mul = typeof pg.l1_decay_mul !== 'undefined' ? pg.l1_decay_mul : 1.0;
        var l2_decay = this.l2_decay * l2_decay_mul;
        var l1_decay = this.l1_decay * l1_decay_mul;

        var plen = p.length;
        for(var j=0;j<plen;j++) {
          l2_decay_loss += l2_decay*p[j]*p[j]/2; // accumulate weight decay loss
          l1_decay_loss += l1_decay*Math.abs(p[j]);
          var l1grad = l1_decay * (p[j] > 0 ? 1 : -1);
          var l2grad = l2_decay * (p[j]);

          var gij = (l2grad + l1grad + g[j]) / this.batch_size; // raw batch gradient

          var gsumi = this.gsum[i];
          var xsumi = this.xsum[i];
          if(this.method === 'adam') {
            // adam update
            gsumi[j] = gsumi[j] * this.beta1 + (1- this.beta1) * gij; // update biased first moment estimate
            xsumi[j] = xsumi[j] * this.beta2 + (1-this.beta2) * gij * gij; // update biased second moment estimate
            var biasCorr1 = gsumi[j] * (1 - Math.pow(this.beta1, this.k)); // correct bias first moment estimate
            var biasCorr2 = xsumi[j] * (1 - Math.pow(this.beta2, this.k)); // correct bias second moment estimate
            var dx =  - this.learning_rate * biasCorr1 / (Math.sqrt(biasCorr2) + this.eps);
            p[j] += dx;
          } else if(this.method === 'adagrad') {
            // adagrad update
            gsumi[j] = gsumi[j] + gij * gij;
            var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij;
            p[j] += dx;
          } else if(this.method === 'windowgrad') {
            // this is adagrad but with a moving window weighted average
            // so the gradient is not accumulated over the entire history of the run. 
            // it's also referred to as Idea #1 in Zeiler paper on Adadelta. Seems reasonable to me!
            gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
            var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij; // eps added for better conditioning
            p[j] += dx;
          } else if(this.method === 'adadelta') {
            gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
            var dx = - Math.sqrt((xsumi[j] + this.eps)/(gsumi[j] + this.eps)) * gij;
            xsumi[j] = this.ro * xsumi[j] + (1-this.ro) * dx * dx; // yes, xsum lags behind gsum by 1.
            p[j] += dx;
          } else if(this.method === 'nesterov') {
          	var dx = gsumi[j];
          	gsumi[j] = gsumi[j] * this.momentum + this.learning_rate * gij;
              dx = this.momentum * dx - (1.0 + this.momentum) * gsumi[j];
              p[j] += dx;
          } else {
            // assume SGD
            if(this.momentum > 0.0) {
              // momentum update
              var dx = this.momentum * gsumi[j] - this.learning_rate * gij; // step
              gsumi[j] = dx; // back this up for next iteration of momentum
              p[j] += dx; // apply corrected gradient
            } else {
              // vanilla sgd
              p[j] +=  - this.learning_rate * gij;
            }
          }
          g[j] = 0.0; // zero out gradient so that we can begin accumulating anew
        }
      }
    }

    // appending softmax_loss for backwards compatibility, but from now on we will always use cost_loss
    // in future, TODO: have to completely redo the way loss is done around the network as currently 
    // loss is a bit of a hack. Ideally, user should specify arbitrary number of loss functions on any layer
    // and it should all be computed correctly and automatically. 
    return {fwd_time: fwd_time, bwd_time: bwd_time, 
            l2_decay_loss: l2_decay_loss, l1_decay_loss: l1_decay_loss,
            cost_loss: cost_loss, softmax_loss: cost_loss, 
            loss: cost_loss + l1_decay_loss + l2_decay_loss}
  }
}

convnet.Trainer = Trainer;
convnet.SGDTrainer = Trainer; // backwards compatibility


/*** convnet_magicnets ***/
// used utilities, make explicit local references
var randf = convnet.randf;
var randi = convnet.randi;
var Net = convnet.Net;
var Trainer = convnet.Trainer;
var maxmin = convnet.maxmin;
var randperm = convnet.randperm;
var weightedSample = convnet.weightedSample;
var getopt = convnet.getopt;
var arrUnique = convnet.arrUnique;

/*
A MagicNet takes data: a list of convnetjs.Vol(), and labels
which for now are assumed to be class indeces 0..K. MagicNet then:
- creates data folds for cross-validation
- samples candidate networks
- evaluates candidate networks on all data folds
- produces predictions by model-averaging the best networks
*/
var MagicNet = function(data, labels, opt) {
  var opt = opt || {};
  if(typeof data === 'undefined') { data = []; }
  if(typeof labels === 'undefined') { labels = []; }

  // required inputs
  this.data = data; // store these pointers to data
  this.labels = labels;

  // optional inputs
  this.train_ratio = getopt(opt, 'train_ratio', 0.7);
  this.num_folds = getopt(opt, 'num_folds', 10);
  this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel
  // how many epochs of data to train every network? for every fold?
  // higher values mean higher accuracy in final results, but more expensive
  this.num_epochs = getopt(opt, 'num_epochs', 50); 
  // number of best models to average during prediction. Usually higher = better
  this.ensemble_size = getopt(opt, 'ensemble_size', 10);

  // candidate parameters
  this.batch_size_min = getopt(opt, 'batch_size_min', 10);
  this.batch_size_max = getopt(opt, 'batch_size_max', 300);
  this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);
  this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);
  this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);
  this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);
  this.momentum_min = getopt(opt, 'momentum_min', 0.9);
  this.momentum_max = getopt(opt, 'momentum_max', 0.9);
  this.neurons_min = getopt(opt, 'neurons_min', 5);
  this.neurons_max = getopt(opt, 'neurons_max', 30);

  // computed
  this.folds = []; // data fold indices, gets filled by sampleFolds()
  this.candidates = []; // candidate networks that are being currently evaluated
  this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds
  this.unique_labels = arrUnique(labels);
  this.iter = 0; // iteration counter, goes from 0 -> num_epochs * num_training_data
  this.foldix = 0; // index of active fold

  // callbacks
  this.finish_fold_callback = null;
  this.finish_batch_callback = null;

  // initializations
  if(this.data.length > 0) {
    this.sampleFolds();
    this.sampleCandidates();
  }
};

MagicNet.prototype = {

  // sets this.folds to a sampling of this.num_folds folds
  sampleFolds: function() {
    var N = this.data.length;
    var num_train = Math.floor(this.train_ratio * N);
    this.folds = []; // flush folds, if any
    for(var i=0;i<this.num_folds;i++) {
      var p = randperm(N);
      this.folds.push({train_ix: p.slice(0, num_train), test_ix: p.slice(num_train, N)});
    }
  },

  // returns a random candidate network
  sampleCandidate: function() {
    var input_depth = this.data[0].w.length;
    var num_classes = this.unique_labels.length;

    // sample network topology and hyperparameters
    var layer_defs = [];
    layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth: input_depth});
    var nl = weightedSample([0,1,2,3], [0.2, 0.3, 0.3, 0.2]); // prefer nets with 1,2 hidden layers
    for(var q=0;q<nl;q++) {
      var ni = randi(this.neurons_min, this.neurons_max);
      var act = ['tanh','maxout','relu'][randi(0,3)];
      if(randf(0,1)<0.5) {
        var dp = Math.random();
        layer_defs.push({type:'fc', num_neurons: ni, activation: act, drop_prob: dp});
      } else {
        layer_defs.push({type:'fc', num_neurons: ni, activation: act});
      }
    }
    layer_defs.push({type:'softmax', num_classes: num_classes});
    var net = new Net();
    net.makeLayers(layer_defs);

    // sample training hyperparameters
    var bs = randi(this.batch_size_min, this.batch_size_max); // batch size
    var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay
    var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate
    var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p
    var tp = randf(0,1); // trainer type
    var trainer_def;
    if(tp<0.33) {
      trainer_def = {method:'adadelta', batch_size:bs, l2_decay:l2};
    } else if(tp<0.66) {
      trainer_def = {method:'adagrad', learning_rate: lr, batch_size:bs, l2_decay:l2};
    } else {
      trainer_def = {method:'sgd', learning_rate: lr, momentum: mom, batch_size:bs, l2_decay:l2};
    }
    
    var trainer = new Trainer(net, trainer_def);

    var cand = {};
    cand.acc = [];
    cand.accv = 0; // this will maintained as sum(acc) for convenience
    cand.layer_defs = layer_defs;
    cand.trainer_def = trainer_def;
    cand.net = net;
    cand.trainer = trainer;
    return cand;
  },

  // sets this.candidates with this.num_candidates candidate nets
  sampleCandidates: function() {
    this.candidates = []; // flush, if any
    for(var i=0;i<this.num_candidates;i++) {
      var cand = this.sampleCandidate();
      this.candidates.push(cand);
    }
  },

  step: function() {
    
    // run an example through current candidate
    this.iter++;

    // step all candidates on a random data point
    var fold = this.folds[this.foldix]; // active fold
    var dataix = fold.train_ix[randi(0, fold.train_ix.length)];
    for(var k=0;k<this.candidates.length;k++) {
      var x = this.data[dataix];
      var l = this.labels[dataix];
      this.candidates[k].trainer.train(x, l);
    }

    // process consequences: sample new folds, or candidates
    var lastiter = this.num_epochs * fold.train_ix.length;
    if(this.iter >= lastiter) {
      // finished evaluation of this fold. Get final validation
      // accuracies, record them, and go on to next fold.
      var val_acc = this.evalValErrors();
      for(var k=0;k<this.candidates.length;k++) {
        var c = this.candidates[k];
        c.acc.push(val_acc[k]);
        c.accv += val_acc[k];
      }
      this.iter = 0; // reset step number
      this.foldix++; // increment fold

      if(this.finish_fold_callback !== null) {
        this.finish_fold_callback();
      }

      if(this.foldix >= this.folds.length) {
        // we finished all folds as well! Record these candidates
        // and sample new ones to evaluate.
        for(var k=0;k<this.candidates.length;k++) {
          this.evaluated_candidates.push(this.candidates[k]);
        }
        // sort evaluated candidates according to accuracy achieved
        this.evaluated_candidates.sort(function(a, b) { 
          return (a.accv / a.acc.length) 
               > (b.accv / b.acc.length) 
               ? -1 : 1;
        });
        // and clip only to the top few ones (lets place limit at 3*ensemble_size)
        // otherwise there are concerns with keeping these all in memory 
        // if MagicNet is being evaluated for a very long time
        if(this.evaluated_candidates.length > 3 * this.ensemble_size) {
          this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size);
        }
        if(this.finish_batch_callback !== null) {
          this.finish_batch_callback();
        }
        this.sampleCandidates(); // begin with new candidates
        this.foldix = 0; // reset this
      } else {
        // we will go on to another fold. reset all candidates nets
        for(var k=0;k<this.candidates.length;k++) {
          var c = this.candidates[k];
          var net = new Net();
          net.makeLayers(c.layer_defs);
          var trainer = new Trainer(net, c.trainer_def);
          c.net = net;
          c.trainer = trainer;
        }
      }
    }
  },

  evalValErrors: function() {
    // evaluate candidates on validation data and return performance of current networks
    // as simple list
    var vals = [];
    var fold = this.folds[this.foldix]; // active fold
    for(var k=0;k<this.candidates.length;k++) {
      var net = this.candidates[k].net;
      var v = 0.0;
      for(var q=0;q<fold.test_ix.length;q++) {
        var x = this.data[fold.test_ix[q]];
        var l = this.labels[fold.test_ix[q]];
        net.forward(x);
        var yhat = net.getPrediction();
        v += (yhat === l ? 1.0 : 0.0); // 0 1 loss
      }
      v /= fold.test_ix.length; // normalize
      vals.push(v);
    }
    return vals;
  },

  // returns prediction scores for given test data point, as Vol
  // uses an averaged prediction from the best ensemble_size models
  // x is a Vol.
  predict_soft: function(data) {
    // forward prop the best networks
    // and accumulate probabilities at last layer into a an output Vol

    var eval_candidates = [];
    var nv = 0;
    if(this.evaluated_candidates.length === 0) {
      // not sure what to do here, first batch of nets hasnt evaluated yet
      // lets just predict with current candidates.
      nv = this.candidates.length;
      eval_candidates = this.candidates;
    } else {
      // forward prop the best networks from evaluated_candidates
      nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
      eval_candidates = this.evaluated_candidates
    }

    // forward nets of all candidates and average the predictions
    var xout, n;
    for(var j=0;j<nv;j++) {
      var net = eval_candidates[j].net;
      var x = net.forward(data);
      if(j===0) { 
        xout = x; 
        n = x.w.length; 
      } else {
        // add it on
        for(var d=0;d<n;d++) {
          xout.w[d] += x.w[d];
        }
      }
    }
    // produce average
    for(var d=0;d<n;d++) {
      xout.w[d] /= nv;
    }
    return xout;
  },

  predict: function(data) {
    var xout = this.predict_soft(data);
    if(xout.w.length !== 0) {
      var stats = maxmin(xout.w);
      var predicted_label = stats.maxi; 
    } else {
      var predicted_label = -1; // error out
    }
    return predicted_label;

  },

  toJSON: function() {
    // dump the top ensemble_size networks as a list
    var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
    var json = {};
    json.nets = [];
    for(var i=0;i<nv;i++) {
      json.nets.push(this.evaluated_candidates[i].net.toJSON());
    }
    return json;
  },

  fromJSON: function(json) {
    this.ensemble_size = json.nets.length;
    this.evaluated_candidates = [];
    for(var i=0;i<this.ensemble_size;i++) {
      var net = new Net();
      net.fromJSON(json.nets[i]);
      var dummy_candidate = {};
      dummy_candidate.net = net;
      this.evaluated_candidates.push(dummy_candidate);
    }
  },

  // callback functions
  // called when a fold is finished, while evaluating a batch
  onFinishFold: function(f) { this.finish_fold_callback = f; },
  // called when a batch of candidates has finished evaluating
  onFinishBatch: function(f) { this.finish_batch_callback = f; }
  
};

convnet.MagicNet = MagicNet;


};
BundleModuleCode['plugins/ml/ann']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Thomas Wagenaar, Stefan Bosse, 
 **    $VERSION:     1.8.1X
 **
 **    $INFO:
 **
 ** https://github.com/wagenaartje/neataptic
 ** Not portable!
 **
 **    $ENDOFINFO
 **
*/

/*******************************************************************************
                                      CONFIG
*******************************************************************************/

// Config
var config = {
  groupId   : 0,
  warnings  : false,
  version   : '1.8.1X',
};

/*******************************************************************************
                                  ACTIVATION FUNCTIONS
*******************************************************************************/

// https://en.wikipedia.org/wiki/Activation_function
// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons
var activation = {
  LOGISTIC: function LOGISTIC (x, derivate) {
    var fx = 1 / (1 + Math.exp(-x));
    if (!derivate) return fx;
    return fx * (1 - fx);
  },
  TANH: function TANH (x, derivate) {
    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);
    return Math.tanh(x);
  },
  IDENTITY: function IDENTITY (x, derivate) {
    return derivate ? 1 : x;
  },
  STEP: function STEP (x, derivate) {
    return derivate ? 0 : x > 0 ? 1 : 0;
  },
  RELU: function RELU (x, derivate) {
    if (derivate) return x > 0 ? 1 : 0;
    return x > 0 ? x : 0;
  },
  SOFTSIGN: function SOFTSIGN (x, derivate) {
    var d = 1 + Math.abs(x);
    if (derivate) return x / Math.pow(d, 2);
    return x / d;
  },
  // Group activation
  SOFTMAX: function SOFTMAX (x, derivate, group) {
    var self=this;
    /* softmax function requires states of group members */
    /* group members can be already updated! */
    if (!derivate) {
      var sum = 0;
      group.nodes.forEach(function (node) {
        if (node.update>self.update) sum += Math.exp(node.state); // already computed x==state
        else sum +=  Math.exp(node.preactivate());
      });
      return Math.exp(x)/sum;
    } else {
      // https://stackoverflow.com/questions/55788902/clear-implementation-of-softmax-and-its-derivative
      var factor=0,
          denom = 0;
      group.nodes.forEach(function (node) {
            var part;
            if (node.update>self.update) {
              part = Math.exp(node.state); // already computed x==state
            } else {
              part = Math.exp(node.preactivate());
            }
            if (node != self) factor += part;
            sum += part;
          })
      var comm = -Math.pow(Math.exp(x),2);
    }
  },
  SINUSOID: function SINUSOID (x, derivate) {
    if (derivate) return Math.cos(x);
    return Math.sin(x);
  },
  GAUSSIAN: function GAUSSIAN (x, derivate) {
    var d = Math.exp(-Math.pow(x, 2));
    if (derivate) return -2 * x * d;
    return d;
  },
  BENT_IDENTITY: function BENT_IDENTITY (x, derivate) {
    var d = Math.sqrt(Math.pow(x, 2) + 1);
    if (derivate) return x / (2 * d) + 1;
    return (d - 1) / 2 + x;
  },
  BIPOLAR: function BIPOLAR (x, derivate) {
    return derivate ? 0 : x > 0 ? 1 : -1;
  },
  BIPOLAR_SIGMOID: function BIPOLAR_SIGMOID (x, derivate) {
    var d = 2 / (1 + Math.exp(-x)) - 1;
    if (derivate) return 1 / 2 * (1 + d) * (1 - d);
    return d;
  },
  HARD_TANH: function HARD_TANH (x, derivate) {
    if (derivate) return x > -1 && x < 1 ? 1 : 0;
    return Math.max(-1, Math.min(1, x));
  },
  ABSOLUTE: function ABSOLUTE (x, derivate) {
    if (derivate) return x < 0 ? -1 : 1;
    return Math.abs(x);
  },
  INVERSE: function INVERSE (x, derivate) {
    if (derivate) return -1;
    return 1 - x;
  },
  // https://arxiv.org/pdf/1706.02515.pdf
  SELU: function SELU (x, derivate) {
    var alpha = 1.6732632423543772848170429916717;
    var scale = 1.0507009873554804934193349852946;
    var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;
    if (derivate) { return x > 0 ? scale : (fx + alpha) * scale; }
    return fx * scale;
  }
};

/*******************************************************************************
                                      MUTATION
*******************************************************************************/

// https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)
var mutation = {
  ADD_NODE: {
    name: 'ADD_NODE'
  },
  SUB_NODE: {
    name: 'SUB_NODE',
    keep_gates: true
  },
  ADD_CONN: {
    name: 'ADD_CONN'
  },
  SUB_CONN: {
    name: 'REMOVE_CONN'
  },
  MOD_WEIGHT: {
    name: 'MOD_WEIGHT',
    min: -1,
    max: 1
  },
  MOD_BIAS: {
    name: 'MOD_BIAS',
    min: -1,
    max: 1
  },
  MOD_ACTIVATION: {
    name: 'MOD_ACTIVATION',
    mutateOutput: true,
    allowed: [
      activation.LOGISTIC,
      activation.TANH,
      activation.RELU,
      activation.IDENTITY,
      activation.STEP,
      activation.SOFTSIGN,
      activation.SINUSOID,
      activation.GAUSSIAN,
      activation.BENT_IDENTITY,
      activation.BIPOLAR,
      activation.BIPOLAR_SIGMOID,
      activation.HARD_TANH,
      activation.ABSOLUTE,
      activation.INVERSE,
      activation.SELU
    ]
  },
  ADD_SELF_CONN: {
    name: 'ADD_SELF_CONN'
  },
  SUB_SELF_CONN: {
    name: 'SUB_SELF_CONN'
  },
  ADD_GATE: {
    name: 'ADD_GATE'
  },
  SUB_GATE: {
    name: 'SUB_GATE'
  },
  ADD_BACK_CONN: {
    name: 'ADD_BACK_CONN'
  },
  SUB_BACK_CONN: {
    name: 'SUB_BACK_CONN'
  },
  SWAP_NODES: {
    name: 'SWAP_NODES',
    mutateOutput: true
  }
};

mutation.ALL = [
  mutation.ADD_NODE,
  mutation.SUB_NODE,
  mutation.ADD_CONN,
  mutation.SUB_CONN,
  mutation.MOD_WEIGHT,
  mutation.MOD_BIAS,
  mutation.MOD_ACTIVATION,
  mutation.ADD_GATE,
  mutation.SUB_GATE,
  mutation.ADD_SELF_CONN,
  mutation.SUB_SELF_CONN,
  mutation.ADD_BACK_CONN,
  mutation.SUB_BACK_CONN,
  mutation.SWAP_NODES
];

mutation.FFW = [
  mutation.ADD_NODE,
  mutation.SUB_NODE,
  mutation.ADD_CONN,
  mutation.SUB_CONN,
  mutation.MOD_WEIGHT,
  mutation.MOD_BIAS,
  mutation.MOD_ACTIVATION,
  mutation.SWAP_NODES
];

/*******************************************************************************
                                      SELECTION
*******************************************************************************/

// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)

var selection = {
  FITNESS_PROPORTIONATE: {
    name: 'FITNESS_PROPORTIONATE'
  },
  POWER: {
    name: 'POWER',
    power: 4
  },
  TOURNAMENT: {
    name: 'TOURNAMENT',
    size: 5,
    probability: 0.5
  }
};

/*******************************************************************************
                                      CROSSOVER
*******************************************************************************/

// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)
var crossover = {
  SINGLE_POINT: {
    name: 'SINGLE_POINT',
    config: [0.4]
  },
  TWO_POINT: {
    name: 'TWO_POINT',
    config: [0.4, 0.9]
  },
  UNIFORM: {
    name: 'UNIFORM'
  },
  AVERAGE: {
    name: 'AVERAGE'
  }
};

/*******************************************************************************
                                    COST FUNCTIONS
*******************************************************************************/

// https://en.wikipedia.org/wiki/Loss_function
var cost = {
  // Cross entropy error
  CROSS_ENTROPY: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A
      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));
    }
    return error / output.length;
  },
  // Mean Squared Error
  MSE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.pow(target[i] - output[i], 2);
    }

    return error / output.length;
  },
  // Binary error
  BINARY: function (target, output) {
    var misses = 0;
    for (var i = 0; i < output.length; i++) {
      misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);
    }

    return misses;
  },
  // Mean Absolute Error
  MAE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.abs(target[i] - output[i]);
    }

    return error / output.length;
  },
  // Mean Absolute Percentage Error
  MAPE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));
    }

    return error / output.length;
  },
  // Mean Squared Logarithmic Error
  MSLE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));
    }

    return error;
  },
  // Hinge loss, for classifiers
  HINGE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.max(0, 1 - target[i] * output[i]);
    }

    return error;
  }
};


/*******************************************************************************
                                    GATING
*******************************************************************************/

// Specifies how to gate a connection between two groups of multiple neurons
var gating = {
  OUTPUT: {
    name: 'OUTPUT'
  },
  INPUT: {
    name: 'INPUT'
  },
  SELF: {
    name: 'SELF'
  }
};


/*******************************************************************************
                                    CONNECTION
*******************************************************************************/

// Specifies in what manner two groups are connected
var connection = {
  ALL_TO_ALL: {
    name: 'OUTPUT'
  },
  ALL_TO_ELSE: {
    name: 'INPUT'
  },
  ONE_TO_ONE: {
    name: 'SELF'
  }
};


/*******************************************************************************
                                      RATE
*******************************************************************************/

// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244
var rate = {
  FIXED: function () {
    var func = function (baseRate, iteration) { return baseRate; };
    return func;
  },
  STEP: function (gamma, stepSize) {
    gamma = gamma || 0.9;
    stepSize = stepSize || 100;

    var func = function (baseRate, iteration) {
      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));
    };

    return func;
  },
  EXP: function (gamma) {
    gamma = gamma || 0.999;

    var func = function (baseRate, iteration) {
      return baseRate * Math.pow(gamma, iteration);
    };

    return func;
  },
  INV: function (gamma, power) {
    gamma = gamma || 0.001;
    power = power || 2;

    var func = function (baseRate, iteration) {
      return baseRate * Math.pow(1 + gamma * iteration, -power);
    };

    return func;
  }
};

/*******************************************************************************
                                  METHODS
*******************************************************************************/

var methods = {
  activation: activation,
  mutation: mutation,
  selection: selection,
  crossover: crossover,
  cost: cost,
  gating: gating,
  connection: connection,
  rate: rate
};

/*******************************************************************************
                                      CONNECTION
*******************************************************************************/

function Connection (from, to, weight) {
  this.from = from;
  this.to = to;
  this.gain = 1;

  this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;

  this.gater = null;
  this.elegibility = 0;

  // For tracking momentum
  this.previousDeltaWeight = 0;

  // Batch training
  this.totalDeltaWeight = 0;

  this.xtrace = {
    nodes: [],
    values: []
  };
}

Connection.prototype = {
  /**
   * Converts the connection to a json object
   */
  toJSON: function () {
    var json = {
      weight: this.weight
    };

    return json;
  }
};

/**
 * Returns an innovation ID
 * https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)
 */
Connection.innovationID = function (a, b) {
  return 1 / 2 * (a + b) * (a + b + 1) + b;
};

/*******************************************************************************
                                 NETWORK
*******************************************************************************/


/* Easier variable naming */
var mutation = methods.mutation;

function Network (input, output) {
  if (typeof input === 'undefined' || typeof output === 'undefined') {
    throw new Error('No input or output size given');
  }

  this.input = input;
  this.output = output;

  // Store all the node and connection genes
  this.nodes = []; // Stored in activation order
  this.connections = [];
  this.gates = [];
  this.selfconns = [];

  // Regularization
  this.dropout = 0;

  // Create input and output nodes
  var i;
  for (i = 0; i < this.input + this.output; i++) {
    var type = i < this.input ? 'input' : 'output';
    this.nodes.push(new Node(type,{layerid:type=='input'?0:1}));
  }

  // Connect input nodes with output nodes directly
  for (i = 0; i < this.input; i++) {
    for (var j = this.input; j < this.output + this.input; j++) {
      // https://stats.stackexchange.com/a/248040/147931
      var weight = Math.random() * this.input * Math.sqrt(2 / this.input);
      this.connect(this.nodes[i], this.nodes[j], weight);
    }
  }
}

Network.prototype = {
  /**
   * Activates the network
   */
  activate: function (input, training) {
    var output = [];

    // Activate nodes chronologically
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].type === 'input') {
        this.nodes[i].activate(input[i]);
      } else if (this.nodes[i].type === 'output') {
        var activation = this.nodes[i].activate();
        output.push(activation);
      } else {
        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;
        this.nodes[i].activate();
      }
    }

    return output;
  },

  // make a snapshot of the network (weights, biases)
  // add snapshot to this object
  backup : function () {
    if (!this.snapshots) this.snapshots=[];
    this.snapshots.push(
      { 
       nodes : this.nodes.map(function (node) {
          return {
            bias        : node.bias,
            activation  : node.activation,
            state       : node.state,
            mask        : node.mask,
            previousDeltaBias: node.previousDeltaBias,
            totalDeltaBias: node.totalDeltaBias,
            derivative: node.derivative,
          }}),
        connections : this.connections.map(function (conn) {
          return {
            gain    : conn.gain,
            weight  : conn.weight,
            elegibility : conn.elegibility,
            previousDeltaWeight : conn.previousDeltaWeight,
          }}),
    });
  },
  
  /**
   * Clear the context of the network
   */
  clear: function () {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  },

  /**
   * Connects the from node to the to node
   */
  connect: function (from, to, weight) {
    var connections = from.connect(to, weight);

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (from !== to) {
        this.connections.push(connection);
      } else {
        this.selfconns.push(connection);
      }
    }

    return connections;
  },

  /*
  *  Post configure network after construction (e.g., by assigning activation/squash functions)
  */
  configure : function (options) {
    if (options.activation && typeof options.activation == 'string') { // apply to all nodes
      this.nodes.forEach(function (node) {
        if (!methods.activation[options.activation]) throw "Network.configure: EINVALID (activation)";
        node.squash=methods.activation[options.activation];
      });
    }
    if (options.activation && typeof options.activation == 'function') { // apply to all nodes
      this.nodes.forEach(function (node) {
        node.squash=options.activation;
      });
    }
    if (options.activation && typeof options.activation == 'object') { // each for one layer
      this.groups.forEach(function (group,index) {
        group.nodes.forEach(function (node) {
          var f = typeof options.activation[index] == 'function'?
                   options.activation[index]: methods.activation[options.activation[index]];
          if (!f) throw "Network.configure: EINVALID (activation)";
          node.squash=f;
        })
      });
    }
  },
  
  /**
   * Disconnects the from node from the to node
   */
  disconnect: function (from, to) {
    // Delete the connection in the network's connection array
    var connections = from === to ? this.selfconns : this.connections;

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (connection.from === from && connection.to === to) {
        if (connection.gater !== null) this.ungate(connection);
        connections.splice(i, 1);
        break;
      }
    }

    // Delete the connection at the sending and receiving neuron
    from.disconnect(to);
  },

  /**
   * Evolves the network to reach a lower error on a dataset
   */
  evolve: function (set, options) {
    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
      throw new Error('Dataset input/output size should be same as network input/output size!');
    }

    // Read the options
    options = options || {};
    var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;
    var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;
    var cost = options.cost || methods.cost.MSE;
    var amount = options.amount || 1;


    var start = Date.now();

    if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {
      throw new Error('At least one of the following options must be specified: error, iterations');
    } else if (typeof options.error === 'undefined') {
      targetError = -1; // run until iterations
    } else if (typeof options.iterations === 'undefined') {
      options.iterations = 0; // run until target error
    }

    var fitnessFunction;
    {
      // Create the fitness function
      fitnessFunction = function (genome) {
        var score = 0;
        for (var i = 0; i < amount; i++) {
          score -= genome.test(set, cost).error;
        }

        score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;
        score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection

        return score / amount;
      };
    } 

    // Intialise the NEAT instance
    options.network = this;
    var neat = new Neat(this.input, this.output, fitnessFunction, options);

    var error = -Infinity;
    var bestFitness = -Infinity;
    var bestGenome;

    while (error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {
      var fittest = neat.evolve();
      var fitness = fittest.score;
      error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;

      if (fitness > bestFitness) {
        bestFitness = fitness;
        bestGenome = fittest;
      }

      if (options.log && neat.generation % options.log === 0) {
        console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);
      }

      if (options.schedule && neat.generation % options.schedule.iterations === 0) {
        options.schedule.function({ fitness: fitness, error: -error, iteration: neat.generation });
      }
    }


    if (typeof bestGenome !== 'undefined') {
      this.nodes = bestGenome.nodes;
      this.connections = bestGenome.connections;
      this.selfconns = bestGenome.selfconns;
      this.gates = bestGenome.gates;

      if (options.clear) this.clear();
    }

    return {
      error: -error,
      iterations: neat.generation,
      time: Date.now() - start
    };
  },

  /**
   * Gate a connection with a node
   */
  gate: function (node, connection) {
    if (this.nodes.indexOf(node) === -1) {
      throw new Error('This node is not part of the network!');
    } else if (connection.gater != null) {
      if (config.warnings) console.warn('This connection is already gated!');
      return;
    }
    node.gate(connection);
    this.gates.push(connection);
  },

  /**
   * Creates a json that can be used to create a graph with d3 and webcola
   */
  graph: function (width, height) {
    var input = 0;
    var output = 0;

    var json = {
      nodes: [],
      links: [],
      constraints: [{
        type: 'alignment',
        axis: 'x',
        offsets: []
      }, {
        type: 'alignment',
        axis: 'y',
        offsets: []
      }]
    };

    var i;
    for (i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];

      if (node.type === 'input') {
        if (this.input === 1) {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0
          });
        } else {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0.8 * width / (this.input - 1) * input++
          });
        }
        json.constraints[1].offsets.push({
          node: i,
          offset: 0
        });
      } else if (node.type === 'output') {
        if (this.output === 1) {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0
          });
        } else {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0.8 * width / (this.output - 1) * output++
          });
        }
        json.constraints[1].offsets.push({
          node: i,
          offset: -0.8 * height
        });
      }

      json.nodes.push({
        id: i,
        name: node.type === 'hidden' ? node.squash.name : node.type.toUpperCase(),
        activation: node.activation,
        bias: node.bias
      });
    }

    var connections = this.connections.concat(this.selfconns);
    for (i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (connection.gater == null) {
        json.links.push({
          source: this.nodes.indexOf(connection.from),
          target: this.nodes.indexOf(connection.to),
          weight: connection.weight
        });
      } else {
        // Add a gater 'node'
        var index = json.nodes.length;
        json.nodes.push({
          id: index,
          activation: connection.gater.activation,
          name: 'GATE'
        });
        json.links.push({
          source: this.nodes.indexOf(connection.from),
          target: index,
          weight: 1 / 2 * connection.weight
        });
        json.links.push({
          source: index,
          target: this.nodes.indexOf(connection.to),
          weight: 1 / 2 * connection.weight
        });
        json.links.push({
          source: this.nodes.indexOf(connection.gater),
          target: index,
          weight: connection.gater.activation,
          gate: true
        });
      }
    }

    return json;
  },

  // return node arrays of layer array with status information (nodes)
  // optional with activation data (number [])
  monitor : function (what,data) {
    what=what||'activation';
    function collect(node) {
      switch (what) {
        case 'node': return node;
        case 'weights':
          return node.connections.in.map(function (c) {
            return c.weight;
          })
        case 'sum':
          var result=node.connections.in.map(function (c) {
            return c.weight*c.from.activation;
          })
          if (result.length) return result.reduce(function (a,b) { return a+b });
          else return node.activation;
        default:
          return node[what]
      }    
    }
    if (data) this.activate(data);
    if (this.groups && this.groups.length)
      return this.groups.map(function (layer) {
         return layer.nodes.map(collect);
      });
    else if (this.layers && this.layers.length)     
      return this.layers.map(function (layer) {
        return layer.output.nodes.map(collect);
      });
  },
  
  /**
   * Mutates the network with the given method
   */
  mutate: function (method) {
    if (typeof method === 'undefined') {
      throw new Error('No (correct) mutate method given!');
    }

    var i, j;
    switch (method) {
      case mutation.ADD_NODE:
        // Look for an existing connection and place a node in between
        var connection = this.connections[Math.floor(Math.random() * this.connections.length)];
        var gater = connection.gater;
        this.disconnect(connection.from, connection.to);

        // Insert the new node right before the old connection.to
        var toIndex = this.nodes.indexOf(connection.to);
        var node = new Node('hidden');

        // Random squash function
        node.mutate(mutation.MOD_ACTIVATION);

        // Place it in this.nodes
        var minBound = Math.min(toIndex, this.nodes.length - this.output);
        this.nodes.splice(minBound, 0, node);

        // Now create two new connections
        var newConn1 = this.connect(connection.from, node)[0];
        var newConn2 = this.connect(node, connection.to)[0];

        // Check if the original connection was gated
        if (gater != null) {
          this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);
        }
        break;
      case mutation.SUB_NODE:
        // Check if there are nodes left to remove
        if (this.nodes.length === this.input + this.output) {
          if (config.warnings) console.warn('No more nodes left to remove!');
          break;
        }

        // Select a node which isn't an input or output node
        var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);
        this.remove(this.nodes[index]);
        break;
      case mutation.ADD_CONN:
        // Create an array of all uncreated (feedforward) connections
        var available = [];
        for (i = 0; i < this.nodes.length - this.output; i++) {
          var node1 = this.nodes[i];
          for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {
            var node2 = this.nodes[j];
            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);
          }
        }

        if (available.length === 0) {
          if (config.warnings) console.warn('No more connections to be made!');
          break;
        }

        var pair = available[Math.floor(Math.random() * available.length)];
        this.connect(pair[0], pair[1]);
        break;
      case mutation.SUB_CONN:
        // List of possible connections that can be removed
        var possible = [];

        for (i = 0; i < this.connections.length; i++) {
          var conn = this.connections[i];
          // Check if it is not disabling a node
          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.to) > this.nodes.indexOf(conn.from)) {
            possible.push(conn);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No connections to remove!');
          break;
        }

        var randomConn = possible[Math.floor(Math.random() * possible.length)];
        this.disconnect(randomConn.from, randomConn.to);
        break;
      case mutation.MOD_WEIGHT:
        var allconnections = this.connections.concat(this.selfconns);

        var connection = allconnections[Math.floor(Math.random() * allconnections.length)];
        var modification = Math.random() * (method.max - method.min) + method.min;
        connection.weight += modification;
        break;
      case mutation.MOD_BIAS:
        // Has no effect on input node, so they are excluded
        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);
        var node = this.nodes[index];
        node.mutate(method);
        break;
      case mutation.MOD_ACTIVATION:
        // Has no effect on input node, so they are excluded
        if (!method.mutateOutput && this.input + this.output === this.nodes.length) {
          if (config.warnings) console.warn('No nodes that allow mutation of activation function');
          break;
        }

        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
        var node = this.nodes[index];

        node.mutate(method);
        break;
      case mutation.ADD_SELF_CONN:
        // Check which nodes aren't selfconnected yet
        var possible = [];
        for (i = this.input; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (node.connections.self.weight === 0) {
            possible.push(node);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No more self-connections to add!');
          break;
        }

        // Select a random node
        var node = possible[Math.floor(Math.random() * possible.length)];

        // Connect it to himself
        this.connect(node, node);
        break;
      case mutation.SUB_SELF_CONN:
        if (this.selfconns.length === 0) {
          if (config.warnings) console.warn('No more self-connections to remove!');
          break;
        }
        var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];
        this.disconnect(conn.from, conn.to);
        break;
      case mutation.ADD_GATE:
        var allconnections = this.connections.concat(this.selfconns);

        // Create a list of all non-gated connections
        var possible = [];
        for (i = 0; i < allconnections.length; i++) {
          var conn = allconnections[i];
          if (conn.gater === null) {
            possible.push(conn);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No more connections to gate!');
          break;
        }

        // Select a random gater node and connection, can't be gated by input
        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);
        var node = this.nodes[index];
        var conn = possible[Math.floor(Math.random() * possible.length)];

        // Gate the connection with the node
        this.gate(node, conn);
        break;
      case mutation.SUB_GATE:
        // Select a random gated connection
        if (this.gates.length === 0) {
          if (config.warnings) console.warn('No more connections to ungate!');
          break;
        }

        var index = Math.floor(Math.random() * this.gates.length);
        var gatedconn = this.gates[index];

        this.ungate(gatedconn);
        break;
      case mutation.ADD_BACK_CONN:
        // Create an array of all uncreated (backfed) connections
        var available = [];
        for (i = this.input; i < this.nodes.length; i++) {
          var node1 = this.nodes[i];
          for (j = this.input; j < i; j++) {
            var node2 = this.nodes[j];
            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);
          }
        }

        if (available.length === 0) {
          if (config.warnings) console.warn('No more connections to be made!');
          break;
        }

        var pair = available[Math.floor(Math.random() * available.length)];
        this.connect(pair[0], pair[1]);
        break;
      case mutation.SUB_BACK_CONN:
        // List of possible connections that can be removed
        var possible = [];

        for (i = 0; i < this.connections.length; i++) {
          var conn = this.connections[i];
          // Check if it is not disabling a node
          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.from) > this.nodes.indexOf(conn.to)) {
            possible.push(conn);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No connections to remove!');
          break;
        }

        var randomConn = possible[Math.floor(Math.random() * possible.length)];
        this.disconnect(randomConn.from, randomConn.to);
        break;
      case mutation.SWAP_NODES:
        // Has no effect on input node, so they are excluded
        if ((method.mutateOutput && this.nodes.length - this.input < 2) ||
          (!method.mutateOutput && this.nodes.length - this.input - this.output < 2)) {
          if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');
          break;
        }

        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
        var node1 = this.nodes[index];
        index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
        var node2 = this.nodes[index];

        var biasTemp = node1.bias;
        var squashTemp = node1.squash;

        node1.bias = node2.bias;
        node1.squash = node2.squash;
        node2.bias = biasTemp;
        node2.squash = squashTemp;
        break;
    }
  },

  // apply uniformly distributed noise to bias of nodes and weights of connections (perc=[0,1])
  // supported layers: 'hidden'|'output'
  noise : function (perc,layers) {
    layers=layers||['hidden'];
    this.nodes.forEach(function (node) {
      if (layers.indexOf(node.type)!=-1) {
        node.bias += ((Math.random()-0.5)*perc*node.bias);
      }
    });
    this.connections.forEach(function (conn) {
      if (layers.indexOf(conn.to.type)!=-1) {
        conn.weight += ((Math.random()-0.5)*perc*conn.weight);
      }
    });
  },
  
  /**
   * Activates the network without calculating elegibility traces and such
   */
  noTraceActivate: function (input) {
    var output = [];

    // Activate nodes chronologically
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].type === 'input') {
        this.nodes[i].noTraceActivate(input[i]);
      } else if (this.nodes[i].type === 'output') {
        var activation = this.nodes[i].noTraceActivate();
        output.push(activation);
      } else {
        this.nodes[i].noTraceActivate();
      }
    }

    return output;
  },

  /**
   * Backpropagate the network
   */
  propagate: function (rate, momentum, update, target) {
    if (typeof target === 'undefined' || target.length !== this.output) {
      throw new Error('Output target length should match network output length');
    }

    var targetIndex = target.length;

    // Propagate output nodes
    var i;
    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {
      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);
    }

    // Propagate hidden and input nodes
    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {
      this.nodes[i].propagate(rate, momentum, update);
    }
  },
  
  // Experimental
  // Naive regularization of saturated nodes by adjusting the node bias to the negative 
  // weighted input summation (resulting value sum0) if the activation output of a node is
  // outside the interval [low,high] and (if there is optional activation by
  // data series data) the saturation occures more than threshold (0,1] times scaled
  // to the number of data points (or 1).
  // For a data series (|data|>1) the mean summation output is used for bias adjustment.
  regularizeBias : function (data,low,high,sum0,threshold) {
    var network = this;
    data=data||[null]
    if (low==undefined)       low=0.02; // assuming logistic/sigmoid transfer function
    if (high==undefined)      high=0.98;
    if (sum0==undefined)      sum0=0;
    if (threshold==undefined) threshold=1;
    
    var biasmap    = network.monitor('bias'),
        nodes      = network.monitor('node'),
        candimap   = [],
        sumaccumap = [];
    data.forEach(function (sample) {
      if (sample) network.activate(sample,false);
      var actmap = network.monitor('activation'),
          summap = network.monitor('sum');
      var satN=0;
      actmap.forEach(function (actlayer,layeri) {
        if (!candimap[layeri])   candimap[layeri]=Array.init(actlayer.length);
        if (!sumaccumap[layeri]) sumaccumap[layeri]=Array.init(actlayer.length);      
        actlayer.forEach(function (act,nodej) {
          sumaccumap[layeri][nodej] += summap[layeri][nodej];
          if (act<low ||
              act>high) {
            // saturated node  
            satN++;
            var node = nodes[layeri][nodej],
                sum  = summap[layeri][nodej];
            // node.bias=-sum+sum0;
            candimap[layeri][nodej]++;
          }
        });
      });
    })
    var satN=0;
    candimap.forEach(function (layer,layeri) {
      layer.forEach(function (count,nodej) {
        if (count/data.length>=threshold) {
          satN++;
          var node = nodes[layeri][nodej],
              sum  = sumaccumap[layeri][nodej]/data.length;
          node.bias=-sum+sum0;
        }
      });
    });
    return { adjusted:satN, candidates: candimap, summap : sumaccumap }
  },

  /**
   *  Removes a node from the network
   */
  remove: function (node) {
    var index = this.nodes.indexOf(node);

    if (index === -1) {
      throw new Error('This node does not exist in the network!');
    }

    // Keep track of gaters
    var gaters = [];

    // Remove selfconnections from this.selfconns
    this.disconnect(node, node);

    // Get all its inputting nodes
    var inputs = [];
    for (var i = node.connections.in.length - 1; i >= 0; i--) {
      var connection = node.connections.in[i];
      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {
        gaters.push(connection.gater);
      }
      inputs.push(connection.from);
      this.disconnect(connection.from, node);
    }

    // Get all its outputing nodes
    var outputs = [];
    for (i = node.connections.out.length - 1; i >= 0; i--) {
      var connection = node.connections.out[i];
      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {
        gaters.push(connection.gater);
      }
      outputs.push(connection.to);
      this.disconnect(node, connection.to);
    }

    // Connect the input nodes to the output nodes (if not already connected)
    var connections = [];
    for (i = 0; i < inputs.length; i++) {
      var input = inputs[i];
      for (var j = 0; j < outputs.length; j++) {
        var output = outputs[j];
        if (!input.isProjectingTo(output)) {
          var conn = this.connect(input, output);
          connections.push(conn[0]);
        }
      }
    }

    // Gate random connections with gaters
    for (i = 0; i < gaters.length; i++) {
      if (connections.length === 0) break;

      var gater = gaters[i];
      var connIndex = Math.floor(Math.random() * connections.length);

      this.gate(gater, connections[connIndex]);
      connections.splice(connIndex, 1);
    }

    // Remove gated connections gated by this node
    for (i = node.connections.gated.length - 1; i >= 0; i--) {
      var conn = node.connections.gated[i];
      this.ungate(conn);
    }

    // Remove selfconnection
    this.disconnect(node, node);

    // Remove the node from this.nodes
    this.nodes.splice(index, 1);
  },

  // restore network from a snapshot from the past
  // options parameter back specifies the n oldest snapshot in the range {1,..,#snaps}
  // otherwise the last (newest) snapshot is removed and restored (default behaviour)
  restore : function (back) {
    var self=this;
    if (!this.snapshots || this.snapshots.length==0) return;
    var snapshot = back==undefined?this.snapshots.pop():this.snapshots[this.snapshots.length-back];
    snapshot.nodes.forEach(function (nodeS,index) {
      var node = self.nodes[index];
      Object.assign(node,nodeS);
    })
    snapshot.connections.forEach(function (connS,index) {
      var conn = self.connections[index];
      Object.assign(conn,connS);
    })  
  },
  



  /**
   * Sets the value of a property for every node in this network
   */
  set: function (values) {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].bias = values.bias || this.nodes[i].bias;
      this.nodes[i].squash = values.squash || this.nodes[i].squash;
    }
  },
  /**
   * Serialize to send to workers efficiently
   */
  serialize: function () {
    var activations = [];
    var states = [];
    var conns = [];
    var squashes = [
      'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',
      'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',
      'ABSOLUTE', 'INVERSE', 'SELU'
    ];

    conns.push(this.input);
    conns.push(this.output);

    var i;
    for (i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      node.index = i;
      activations.push(node.activation);
      states.push(node.state);
    }

    for (i = this.input; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      conns.push(node.index);
      conns.push(node.bias);
      conns.push(squashes.indexOf(node.squash.name));

      conns.push(node.connections.self.weight);
      conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);

      for (var j = 0; j < node.connections.in.length; j++) {
        var conn = node.connections.in[j];

        conns.push(conn.from.index);
        conns.push(conn.weight);
        conns.push(conn.gater == null ? -1 : conn.gater.index);
      }

      conns.push(-2); // stop token -> next node
    }

    return [activations, states, conns];
  },

  /**
   * Creates a standalone function of the network which can be run without the
   * need of a library
   */
  standalone: function () {
    var present = [];
    var activations = [];
    var states = [];
    var lines = [];
    var functions = [];

    var i;
    for (i = 0; i < this.input; i++) {
      var node = this.nodes[i];
      activations.push(node.activation);
      states.push(node.state);
    }

    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');

    // So we don't have to use expensive .indexOf()
    for (i = 0; i < this.nodes.length; i++) {
      this.nodes[i].index = i;
    }

    for (i = this.input; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      activations.push(node.activation);
      states.push(node.state);

      var functionIndex = present.indexOf(node.squash.name);

      if (functionIndex === -1) {
        functionIndex = present.length;
        present.push(node.squash.name);
        functions.push(node.squash.toString());
      }

      var incoming = [];
      for (var j = 0; j < node.connections.in.length; j++) {
        var conn = node.connections.in[j];
        var computation = "A[" + conn.from.index + "] * " + conn.weight;
        
        if (conn.gater != null) {
          computation += " * A[" + conn.gater.index + "]";
        }

        incoming.push(computation);
      }

      if (node.connections.self.weight) {
        var conn = node.connections.self;
        var computation = "S[" + i + "] * " + conn.weight;

        if (conn.gater != null) {
          computation += " * A[" + conn.gater.index + "]";
        }

        incoming.push(computation);
      }

      var line1 = "S[" + i + "] = " + incoming.join(' + ') + " + " + node.bias + ";";
      var line2 = "A[" + i + "] = F[" + functionIndex + "](S[" + i + "])" + (!node.mask ? ' * ' + node.mask : '') + ";";
      lines.push(line1);
      lines.push(line2);
    }

    var output = [];
    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {
      output.push("A[" + i + "]");
    }

    output = "return [" + output.join(',') + "];";
    lines.push(output);

    var total = '';
    
    total += "var F = [" + functions.toString() + "];\r\n"; 
    total += "var A = [" + activations.toString() + "];\r\n";
    total += "var S = [" + states.toString() + "];\r\n";
    total += "function activate(input){\r\n" + lines.join('\r\n') + "\r\n}";
    return total;
  },

  /**
   * Tests a set and returns the error and elapsed time
   */
  test: function (set, cost) {
    if (cost == undefined) cost = methods.cost.MSE;
    // Check if dropout is enabled, set correct mask
    var i;
    if (this.dropout) {
      for (i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {
          this.nodes[i].mask = 1 - this.dropout;
        }
      }
    }

    var error = 0;
    var start = Date.now();

    for (i = 0; i < set.length; i++) {
      var input = set[i].input;
      var target = set[i].output;
      var output = this.noTraceActivate(input);
      error += cost(target, output);
    }

    error /= set.length;

    var results = {
      error: error,
      time: Date.now() - start
    };

    return results;
  },

  /**
   * Train the given set to this network
   */
  train: function (set, options) {
    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
      throw new Error('Dataset input/output size should be same as network input/output size!');
    }

    options = options || {};

    // Warning messages
    if (typeof options.rate === 'undefined') {
      if (config.warnings) console.warn('Using default learning rate, please define a rate!');
    }
    if (typeof options.iterations === 'undefined') {
      if (config.warnings) console.warn('No target iterations given, running until error is reached!');
    }

    // Read the options
    var targetError = options.error || 0.05;
    var cost = options.cost || methods.cost.MSE;
    var baseRate = options.rate || 0.3;
    var dropout = options.dropout || 0;
    var momentum = options.momentum || 0;
    var batchSize = options.batchSize || 1; // online learning
    var ratePolicy = options.ratePolicy || methods.rate.FIXED();

    var start = Date.now();

    if (batchSize > set.length) {
      throw new Error('Batch size must be smaller or equal to dataset length!');
    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {
      throw new Error('At least one of the following options must be specified: error, iterations');
    } else if (typeof options.error === 'undefined') {
      targetError = -1; // run until iterations
    } else if (typeof options.iterations === 'undefined') {
      options.iterations = 0; // run until target error
    }

    // Save to network
    this.dropout = dropout;

    if (options.crossValidate) {
      var numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);
      var trainSet = set.slice(0, numTrain);
      var testSet = set.slice(numTrain);
    }

    // Loops the training process
    var currentRate = baseRate;
    var iteration = 0;
    var error = 1;

    var i, j, x;
    while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {
      if (options.crossValidate && error <= options.crossValidate.testError) break;

      iteration++;

      // Update the rate
      currentRate = ratePolicy(baseRate, iteration);

      // Checks if cross validation is enabled
      if (options.crossValidate) {
        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);
        if (options.clear) this.clear();
        error = this.test(testSet, cost).error;
        if (options.clear) this.clear();
      } else {
        error = this._trainSet(set, batchSize, currentRate, momentum, cost);
        if (options.clear) this.clear();
      }

      // Checks for options such as scheduled logs and shuffling
      if (options.shuffle) {
        for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x);
      }

      if (options.log && iteration % options.log === 0) {
        console.log('iteration', iteration, 'error', error, 'rate', currentRate);
      }

      if (options.schedule && iteration % options.schedule.iterations === 0) {
        options.schedule.function({ error: error, iteration: iteration });
      }
    }

    if (options.clear) this.clear();

    if (dropout) {
      for (i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {
          this.nodes[i].mask = 1 - this.dropout;
        }
      }
    }

    return {
      error: error,
      iterations: iteration,
      time: Date.now() - start
    };
  },

  /**
   * Performs one training epoch and returns the error
   * private function used in this.train
   */
  _trainSet: function (set, batchSize, currentRate, momentum, costFunction) {
    var errorSum = 0;
    for (var i = 0; i < set.length; i++) {
      var input = set[i].input;
      var target = set[i].output;

      var update = !!((i + 1) % batchSize === 0 || (i + 1) === set.length);

      var output = this.activate(input, true);
      this.propagate(currentRate, momentum, update, target);
      errorSum += costFunction(target, output);
    }
    return errorSum / set.length;
  },



 /**
   * Convert the network to a json object
   */
  toJSON: function () {
    var json = {
      nodes: [],
      connections: [],
      input: this.input,
      output: this.output,
      dropout: this.dropout
    };

    // So we don't have to use expensive .indexOf()
    var i;
    for (i = 0; i < this.nodes.length; i++) {
      this.nodes[i].index = i;
    }

    for (i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      var tojson = node.toJSON();
      tojson.index = i;
      json.nodes.push(tojson);

      if (node.connections.self.weight !== 0) {
        var tojson = node.connections.self.toJSON();
        tojson.from = i;
        tojson.to = i;

        tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;
        json.connections.push(tojson);
      }
    }

    for (i = 0; i < this.connections.length; i++) {
      var conn = this.connections[i];
      var tojson = conn.toJSON();
      tojson.from = conn.from.index;
      tojson.to = conn.to.index;

      tojson.gater = conn.gater != null ? conn.gater.index : null;

      json.connections.push(tojson);
    }

    return json;
  },

  /**
   *  Remove the gate of a connection
   */
  ungate: function (connection) {
    var index = this.gates.indexOf(connection);
    if (index === -1) {
      throw new Error('This connection is not gated!');
    }

    this.gates.splice(index, 1);
    connection.gater.ungate(connection);
  },


};

/**
 * Convert a json object to a network
 */
Network.fromJSON = function (json) {
  var network = new Network(json.input, json.output);
  network.dropout = json.dropout;
  network.nodes = [];
  network.connections = [];
  network.groups = [];
  network.layers = [];
  var i;
  for (i = 0; i < json.nodes.length; i++) {
    var node = Node.fromJSON(json.nodes[i]);
    // reconstrct layers and groups
    network.nodes.push(node);
    if (!network.layers[node.layerid]) network.layers[node.layerid]={
      nodes       : [],
      connections : {in:[],out:[]},  // TODO
      input       : [],  // TODO
      output      : {nodes:[],connections:[]},  // TODO
    };
    network.layers[node.layerid].nodes.push(node);
    if (!network.groups[node.layerid]) network.groups[node.layerid]={
      nodes:[],
      connections:[] // TODO
    };
    network.groups[node.layerid].nodes.push(node);
  }

  for (i = 0; i < json.connections.length; i++) {
    var conn = json.connections[i];
    var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];
    connection.weight = conn.weight;
    if (conn.gater != null) {
      network.gate(network.nodes[conn.gater], connection);
    }
    network.connections.push(connection);
  }
  return network;
};

/**
 * Merge two networks into one
 */
Network.merge = function (network1, network2) {
  // Create a copy of the networks
  network1 = Network.fromJSON(network1.toJSON());
  network2 = Network.fromJSON(network2.toJSON());

  // Check if output and input size are the same
  if (network1.output !== network2.input) {
    throw new Error('Output size of network1 should be the same as the input size of network2!');
  }

  // Redirect all connections from network2 input from network1 output
  var i;
  for (i = 0; i < network2.connections.length; i++) {
    var conn = network2.connections[i];
    if (conn.from.type === 'input') {
      var index = network2.nodes.indexOf(conn.from);

      // redirect
      conn.from = network1.nodes[network1.nodes.length - 1 - index];
    }
  }

  // Delete input nodes of network2
  for (i = network2.input - 1; i >= 0; i--) {
    network2.nodes.splice(i, 1);
  }

  // Change the node type of network1's output nodes (now hidden)
  for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {
    network1.nodes[i].type = 'hidden';
  }

  // Create one network from both networks
  network1.connections = network1.connections.concat(network2.connections);
  network1.nodes = network1.nodes.concat(network2.nodes);

  return network1;
};

/**
 * Create an offspring from two parent networks
 */
Network.crossOver = function (network1, network2, equal) {
  if (network1.input !== network2.input || network1.output !== network2.output) {
    throw new Error("Networks don't have the same input/output size!");
  }

  // Initialise offspring
  var offspring = new Network(network1.input, network1.output);
  offspring.connections = [];
  offspring.nodes = [];

  // Save scores and create a copy
  var score1 = network1.score || 0;
  var score2 = network2.score || 0;

  // Determine offspring node size
  var size;
  if (equal || score1 === score2) {
    var max = Math.max(network1.nodes.length, network2.nodes.length);
    var min = Math.min(network1.nodes.length, network2.nodes.length);
    size = Math.floor(Math.random() * (max - min + 1) + min);
  } else if (score1 > score2) {
    size = network1.nodes.length;
  } else {
    size = network2.nodes.length;
  }

  // Rename some variables for easier reading
  var outputSize = network1.output;

  // Set indexes so we don't need indexOf
  var i;
  for (i = 0; i < network1.nodes.length; i++) {
    network1.nodes[i].index = i;
  }

  for (i = 0; i < network2.nodes.length; i++) {
    network2.nodes[i].index = i;
  }

  // Assign nodes from parents to offspring
  for (i = 0; i < size; i++) {
    // Determine if an output node is needed
    var node;
    if (i < size - outputSize) {
      var random = Math.random();
      node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];
      var other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];

      if (typeof node === 'undefined' || node.type === 'output') {
        node = other;
      }
    } else {
      if (Math.random() >= 0.5) {
        node = network1.nodes[network1.nodes.length + i - size];
      } else {
        node = network2.nodes[network2.nodes.length + i - size];
      }
    }

    var newNode = new Node();
    newNode.bias = node.bias;
    newNode.squash = node.squash;
    newNode.type = node.type;

    offspring.nodes.push(newNode);
  }

  // Create arrays of connection genes
  var n1conns = {};
  var n2conns = {};

  // Normal connections
  for (i = 0; i < network1.connections.length; i++) {
    var conn = network1.connections[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n1conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Selfconnections
  for (i = 0; i < network1.selfconns.length; i++) {
    var conn = network1.selfconns[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n1conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Normal connections
  for (i = 0; i < network2.connections.length; i++) {
    var conn = network2.connections[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n2conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Selfconnections
  for (i = 0; i < network2.selfconns.length; i++) {
    var conn = network2.selfconns[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n2conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Split common conn genes from disjoint or excess conn genes
  var connections = [];
  var keys1 = Object.keys(n1conns);
  var keys2 = Object.keys(n2conns);
  for (i = keys1.length - 1; i >= 0; i--) {
    // Common gene
    if (typeof n2conns[keys1[i]] !== 'undefined') {
      var conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];
      connections.push(conn);

      // Because deleting is expensive, just set it to some value
      n2conns[keys1[i]] = undefined;
    } else if (score1 >= score2 || equal) {
      connections.push(n1conns[keys1[i]]);
    }
  }

  // Excess/disjoint gene
  if (score2 >= score1 || equal) {
    for (i = 0; i < keys2.length; i++) {
      if (typeof n2conns[keys2[i]] !== 'undefined') {
        connections.push(n2conns[keys2[i]]);
      }
    }
  }

  // Add common conn genes uniformly
  for (i = 0; i < connections.length; i++) {
    var connData = connections[i];
    if (connData.to < size && connData.from < size) {
      var from = offspring.nodes[connData.from];
      var to = offspring.nodes[connData.to];
      var conn = offspring.connect(from, to)[0];

      conn.weight = connData.weight;

      if (connData.gater !== -1 && connData.gater < size) {
        offspring.gate(offspring.nodes[connData.gater], conn);
      }
    }
  }

  return offspring;
};

/*******************************************************************************
                                        architect
*******************************************************************************/


var architect = {
  /**
   * Constructs a network from a given array of connected nodes
   */
  Construct: function (list) {
    // Create a network
    var network = new Network(0, 0),
        layers=[],
        groups=[];

    // Transform all groups into nodes
    var nodes = [];

    var i;
    for (i = 0; i < list.length; i++) {
      var j;
      if (list[i] instanceof Group) {
        groups.push(list[i]);
        for (j = 0; j < list[i].nodes.length; j++) {
          nodes.push(list[i].nodes[j]);
        }
      } else if (list[i] instanceof Layer) {
        layers.push(list[i]);
        for (j = 0; j < list[i].nodes.length; j++) {
          for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {
            nodes.push(list[i].nodes[j].nodes[k]);
          }
        }
      } else if (list[i] instanceof Node) {
        nodes.push(list[i]);
      }
    }

    // Determine input and output nodes
    var inputs = [];
    var outputs = [];
    for (i = nodes.length - 1; i >= 0; i--) {
      if (nodes[i].type === 'output' || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {
        nodes[i].type = 'output';
        network.output++;
        outputs.push(nodes[i]);
        nodes.splice(i, 1);
      } else if (nodes[i].type === 'input' || !nodes[i].connections.in.length) {
        nodes[i].type = 'input';
        network.input++;
        inputs.push(nodes[i]);
        nodes.splice(i, 1);
      }
    }

    // Input nodes are always first, output nodes are always last
    nodes = inputs.concat(nodes).concat(outputs);

    if (network.input === 0 || network.output === 0) {
      throw new Error('Given nodes have no clear input/output node!');
    }

    for (i = 0; i < nodes.length; i++) {
      var j;
      for (j = 0; j < nodes[i].connections.out.length; j++) {
        network.connections.push(nodes[i].connections.out[j]);
      }
      for (j = 0; j < nodes[i].connections.gated.length; j++) {
        network.gates.push(nodes[i].connections.gated[j]);
      }
      if (nodes[i].connections.self.weight !== 0) {
        network.selfconns.push(nodes[i].connections.self);
      }
    }

    network.nodes   = nodes;
    network.layers  = layers;
    network.groups  = groups.map(function (layer) {
      // reverse node order 
      return {nodes:layer.nodes.reverse(),connections:layer.connections,layerid:layer.layerid} 
    });
    return network;
  },

  /**
   * Creates a multilayer perceptron (MLP)
   */
  Perceptron: function () {
    // Convert arguments to Array
    var layers = Array.prototype.slice.call(arguments).filter(function (e) { return e!=null });
    if (layers.length < 3) {
      throw new Error('You have to specify at least 3 layers');
    }

    // Create a list of nodes/groups
    var nodes = [];
    nodes.push(new Group(layers[0],{layerid:0}));
    for (var i = 1; i < layers.length; i++) {
      var layer = layers[i];
      layer = new Group(layer,{layerid:i});
      nodes.push(layer);
      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);
    }

    // Construct the network
    return architect.Construct(nodes);
  },

  /**
   * Creates a randomly connected network
   */
  Random: function (input, hidden, output, options) {
    options = options || {};

    var connections = options.connections || hidden * 2;
    var backconnections = options.backconnections || 0;
    var selfconnections = options.selfconnections || 0;
    var gates = options.gates || 0;

    var network = new Network(input, output);

    var i;
    for (i = 0; i < hidden; i++) {
      network.mutate(methods.mutation.ADD_NODE);
    }

    for (i = 0; i < connections - hidden; i++) {
      network.mutate(methods.mutation.ADD_CONN);
    }

    for (i = 0; i < backconnections; i++) {
      network.mutate(methods.mutation.ADD_BACK_CONN);
    }

    for (i = 0; i < selfconnections; i++) {
      network.mutate(methods.mutation.ADD_SELF_CONN);
    }

    for (i = 0; i < gates; i++) {
      network.mutate(methods.mutation.ADD_GATE);
    }

    return network;
  },

  /**
   * Creates a long short-term memory network
   */
  LSTM: function () {
    var args = Array.prototype.slice.call(arguments);
    if (args.length < 3) {
      throw new Error('You have to specify at least 3 layers');
    }

    var last = args.pop();

    var outputLayer;
    if (typeof last === 'number') {
      outputLayer = new Group(last,{layerid:args.length});
      last = {};
    } else {
      outputLayer = new Group(args.pop(),{layerid:args.length}); // last argument
    }

    outputLayer.set({
      type: 'output'
    });

    var options = {};
    options.memoryToMemory = last.memoryToMemory || false;
    options.outputToMemory = last.outputToMemory || false;
    options.outputToGates = last.outputToGates || false;
    options.inputToOutput = last.inputToOutput === undefined ? true : last.inputToOutput;
    options.inputToDeep = last.inputToDeep === undefined ? true : last.inputToDeep;
    // set all conenction weights to this default value - otherwise a random value is chosen
    options.weight = last.weight;

    var inputLayer = new Group(args.shift(),{layerid:0}); // first argument
    inputLayer.set({
      type: 'input'
    });

    var blocks = args; // all the arguments in the middle

    var nodes = [];
    nodes.push(inputLayer);

    var previous = inputLayer;
    for (var i = 0; i < blocks.length; i++) {
      var block = blocks[i];

      // Init required nodes (in activation order)
      var inputGate = new Group(block,{layerid:i+1});
      var forgetGate = new Group(block,{layerid:i+1});
      var memoryCell = new Group(block,{layerid:i+1});
      var outputGate = new Group(block,{layerid:i+1});
      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block,{layerid:i+1});

      inputGate.set({
        bias: 1
      });
      forgetGate.set({
        bias: 1
      });
      outputGate.set({
        bias: 1
      });

      // Connect the input with all the nodes
      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
      previous.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
      previous.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
      previous.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);

      // Set up internal connections
      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);
      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE,options.weight);
      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL,options.weight);

      // Set up gates
      inputGate.gate(input, methods.gating.INPUT);
      forgetGate.gate(forget, methods.gating.SELF);
      outputGate.gate(output, methods.gating.OUTPUT);

      // Input to all memory cells
      if (options.inputToDeep && i > 0) {
        var input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
        inputGate.gate(input, methods.gating.INPUT);
      }

      // Optional connections
      if (options.memoryToMemory) {
        var input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE,options.weight);
        inputGate.gate(input, methods.gating.INPUT);
      }

      if (options.outputToMemory) {
        var input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
        inputGate.gate(input, methods.gating.INPUT);
      }

      if (options.outputToGates) {
        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);
        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
      }

      // Add to array
      nodes.push(inputGate);
      nodes.push(forgetGate);
      nodes.push(memoryCell);
      nodes.push(outputGate);
      if (i !== blocks.length - 1) nodes.push(outputBlock);

      previous = outputBlock;
    }

    // input to output direct connection
    if (options.inputToOutput) {
      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL,options.weight);
    }

    nodes.push(outputLayer);
    return architect.Construct(nodes);
  },

  /**
   * Creates a gated recurrent unit network
   */
  GRU: function () {
    var args = Array.prototype.slice.call(arguments);
    if (args.length < 3) {
      throw new Error('not enough layers (minimum 3) !!');
    }

    var inputLayer = new Group(args.shift(),{layerid:0}); // first argument
    var outputLayer = new Group(args.pop(),{layerid:args.length}); // last argument
    var blocks = args; // all the arguments in the middle

    var nodes = [];
    nodes.push(inputLayer);

    var previous = inputLayer;
    for (var i = 0; i < blocks.length; i++) {
      var layer = new Layer.GRU(blocks[i],{layerid:i+1});
      previous.connect(layer);
      previous = layer;
      nodes.push(layer);
    }

    previous.connect(outputLayer);
    nodes.push(outputLayer);

    return architect.Construct(nodes);
  },

  /**
   * Creates a hopfield network of the given size
   */
  Hopfield: function (size) {
    var input = new Group(size);
    var output = new Group(size);

    input.connect(output, methods.connection.ALL_TO_ALL);

    input.set({
      type: 'input'
    });
    output.set({
      squash: methods.activation.STEP,
      type: 'output'
    });

    var network = new architect.Construct([input, output]);

    return network;
  },

  /**
   * Creates a NARX network (remember previous inputs/outputs)
   */
  NARX: function (inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {
    if (!Array.isArray(hiddenLayers)) {
      hiddenLayers = [hiddenLayers];
    }

    var nodes = [];

    var input = new Layer.Dense(inputSize);
    var inputMemory = new Layer.Memory(inputSize, previousInput);
    var hidden = [];
    var output = new Layer.Dense(outputSize);
    var outputMemory = new Layer.Memory(outputSize, previousOutput);

    nodes.push(input);
    nodes.push(outputMemory);

    for (var i = 0; i < hiddenLayers.length; i++) {
      var hiddenLayer = new Layer.Dense(hiddenLayers[i]);
      hidden.push(hiddenLayer);
      nodes.push(hiddenLayer);
      if (typeof hidden[i - 1] !== 'undefined') {
        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);
      }
    }

    nodes.push(inputMemory);
    nodes.push(output);

    input.connect(hidden[0], methods.connection.ALL_TO_ALL);
    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);
    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);
    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);
    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);
    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);

    input.set({
      type: 'input'
    });
    output.set({
      type: 'output'
    });

    return architect.Construct(nodes);
  },
  
  // Generic forward ANN
  Network : function () {
    config.groupid=0;
    var args = Array.prototype.slice.call(arguments);
    if (args.length < 2) {
      throw new Error('You have to specify at least 2 layers');
    }
    if (args.length==2) {
      // SLP
      var net = new Network(args[0],args[1]),
          groups = [{nodes:[]},{nodes:[]}];
      net.nodes.forEach(function (node) {
        if (node.type=='input') {
          node.layerid=0;
          groups[0].nodes.push(node);
        } else {
          node.layerid=1;
          groups[1].nodes.push(node);
        }
      });
      net.groups=groups;
      return net;
    } else return new architect.Perceptron(args[0],args[1],args[2],args[3],args[4],args[5],
                                           args[6],args[7],args[8],args[9]);
  },
  /*
    Construct mixed layer network:  
    typeof @options = {
       architect : string [] // Dense LSTM ...
       layers : number []  // number of nodes
       .. more options
     }
  */
  Layers : function (options) {
    var layers = [];
    var inputLayer,prevLay;
    for(var i in options.architect) {
      var layA=options.architect[i],
          layN=options.layers[i];
      if (!Layer[layA]) throw "ANN.Layer: invalid layer architect "+layA;
      var lay;
      if (layA=='LSTM') 
        lay = new Layer[layA](layN,
                              options,
                              inputLayer && inputLayer!=prevLay?inputLayer:null /* for inputToDeep*/,
                              null /* outputLayer ?*/);
      else
        lay = new Layer[layA](layN,options);
      if (layA=='Dense') inputLayer=lay;
      prevLay=lay;
      layers.push(lay);
    }
    for(var i in options.architect) {
      i=Number(i);
      var layA=options.architect[i],
          layN=options.layers[i],
          lay=layers[i];
      // handle some layer-to-layer connect options
      if (layA=='LSTM') {
        // input to output direct connection
        if (options.inputToOutput) { 
          var inputLayer=null,
              outputLayer=null;
          // search dense layers backward and forward
          if (options.architect[i-1]=='Dense') inputLayer=layers[i-1];
          if (inputLayer) for(var j=i+1;j<options.architect.length;j++) {
            if (options.architect[j]=='Dense') {
              outputLayer=layers[j];
              break;
            }
          }
          if (inputLayer && outputLayer) {
            console.log('inputToOutput')
            inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL,options.weight);
          }
        }
      }
    }
    prevLay=null;
    for(var i in options.architect) {
      var layA=options.architect[i],
          layN=options.layers[i],
          lay=layers[i];
      if (prevLay) prevLay.connect(lay); 
      prevLay=lay;
    }
    return layers;  
  }
  
};




/*******************************************************************************
                                         NODE
*******************************************************************************/

function Node (type,options) {
  this.bias = (type === 'input') ? 0 : Math.random() * 0.2 - 0.1;
  this.squash = methods.activation.LOGISTIC;
  this.type = type || 'hidden';

  this.activation = 0;
  this.state = 0;
  this.old = 0;
  this.update = 0; // activation update cpunter / time stamp
  if (options && options.layerid != undefined) this.layerid=options.layerid;
  if (options && options.group) this.group=options.group;
  // For dropout
  this.mask = 1;

  // For tracking momentum
  this.previousDeltaBias = 0;

  // Batch training
  this.totalDeltaBias = 0;

  this.connections = {
    in: [],
    out: [],
    gated: [],
    self: new Connection(this, this, 0)
  };

  // Data for backpropagation
  this.error = {
    responsibility: 0,
    projected: 0,
    gated: 0
  };
}

Node.prototype = {
  /**
   * Activates the node
   */
  preactivate : function () {
    // Precompute the activation state without changing the state of the node actually!
    // required for group activation (softmax)
    // All activation sources coming from the node itself
    var state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    var i;
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];
      state += connection.from.activation * connection.weight * connection.gain;
    }

    return state;
  },
  
  activate: function (input) {
    // Check if an input is given
    if (typeof input !== 'undefined') {
      this.activation = input;
      return this.activation;
    }

    this.old = this.state;

    var newstate = this.preactivate();
    
    // All activation sources coming from the node itself
    //this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    //var i;
    //for (i = 0; i < this.connections.in.length; i++) {
    //  var connection = this.connections.in[i];
    //  this.state += connection.from.activation * connection.weight * connection.gain;
    //}

    // Squash the values received
    // The softmax function (group function) reqires entire layer group access to computer this activation!
    this.activation = this.squash(newstate, false, this.group) * this.mask;
    this.derivative = this.squash(newstate, true,  this.group);

    this.state = newstate;
    this.update++;
    
    // Update traces
    var nodes = [];
    var influences = [];

    for (i = 0; i < this.connections.gated.length; i++) {
      var conn = this.connections.gated[i];
      var node = conn.to;

      var index = nodes.indexOf(node);
      if (index > -1) {
        influences[index] += conn.weight * conn.from.activation;
      } else {
        nodes.push(node);
        influences.push(conn.weight * conn.from.activation +
          (node.connections.self.gater === this ? node.old : 0));
      }

      // Adjust the gain to this nodes' activation
      conn.gain = this.activation;
    }

    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      // Elegibility trace
      connection.elegibility = this.connections.self.gain * this.connections.self.weight *
        connection.elegibility + connection.from.activation * connection.gain;

      // Extended trace
      for (var j = 0; j < nodes.length; j++) {
        var node = nodes[j];
        var influence = influences[j];

        var index = connection.xtrace.nodes.indexOf(node);

        if (index > -1) {
          connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *
            connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;
        } else {
          // Does not exist there yet, might be through mutation
          connection.xtrace.nodes.push(node);
          connection.xtrace.values.push(this.derivative * connection.elegibility * influence);
        }
      }
    }

    return this.activation;
  },

  /**
   * Activates the node without calculating elegibility traces and such
   */
  noTraceActivate: function (input) {
    // Check if an input is given
    if (typeof input !== 'undefined') {
      this.activation = input;
      return this.activation;
    }

    // All activation sources coming from the node itself
    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    var i;
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];
      this.state += connection.from.activation * connection.weight * connection.gain;
    }

    // Squash the values received
    this.activation = this.squash(this.state);

    for (i = 0; i < this.connections.gated.length; i++) {
      this.connections.gated[i].gain = this.activation;
    }

    return this.activation;
  },

  /**
   * Back-propagate the error, aka learn
   */
  propagate: function (rate, momentum, update, target) {
    momentum = momentum || 0;
    rate = rate || 0.3;

    // Error accumulator
    var error = 0;

    // Output nodes get their error from the enviroment
    if (this.type === 'output') {
      this.error.responsibility = this.error.projected = target - this.activation;
    } else { // the rest of the nodes compute their error responsibilities by backpropagation
      // error responsibilities from all the connections projected from this node
      var i;
      for (i = 0; i < this.connections.out.length; i++) {
        var connection = this.connections.out[i];
        var node = connection.to;
        // Eq. 21
        error += node.error.responsibility * connection.weight * connection.gain;
      }

      // Projected error responsibility
      this.error.projected = this.derivative * error;

      // Error responsibilities from all connections gated by this neuron
      error = 0;

      for (i = 0; i < this.connections.gated.length; i++) {
        var conn = this.connections.gated[i];
        var node = conn.to;
        var influence = node.connections.self.gater === this ? node.old : 0;

        influence += conn.weight * conn.from.activation;
        error += node.error.responsibility * influence;
      }

      // Gated error responsibility
      this.error.gated = this.derivative * error;

      // Error responsibility
      this.error.responsibility = this.error.projected + this.error.gated;
    }

    if (this.type === 'constant') return;

    // Adjust all the node's incoming connections
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      var gradient = this.error.projected * connection.elegibility;

      for (var j = 0; j < connection.xtrace.nodes.length; j++) {
        var node = connection.xtrace.nodes[j];
        var value = connection.xtrace.values[j];
        gradient += node.error.responsibility * value;
      }

      // Adjust weight
      var deltaWeight = rate * gradient * this.mask;
      connection.totalDeltaWeight += deltaWeight;
      if (update) {
        connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;
        connection.weight += connection.totalDeltaWeight;
        connection.previousDeltaWeight = connection.totalDeltaWeight;
        connection.totalDeltaWeight = 0;
      }
    }

    // Adjust bias
    var deltaBias = rate * this.error.responsibility;
    this.totalDeltaBias += deltaBias;
    if (update) {
      this.totalDeltaBias += momentum * this.previousDeltaBias;
      this.bias += this.totalDeltaBias;
      this.previousDeltaBias = this.totalDeltaBias;
      this.totalDeltaBias = 0;
    }
  },

  /**
   * Creates a connection from this node to the given node
   */
  connect: function (target, weight) {
    var connections = [];
    if (typeof target.bias !== 'undefined') { // must be a node!
      if (target === this) {
        // Turn on the self connection by setting the weight
        if (this.connections.self.weight !== 0) {
          if (config.warnings) console.warn('This connection already exists!');
        } else {
          this.connections.self.weight = weight || 1;
        }
        connections.push(this.connections.self);
      } else if (this.isProjectingTo(target)) {
        throw new Error('Already projecting a connection to this node!');
      } else {
        var connection = new Connection(this, target, weight);
        target.connections.in.push(connection);
        this.connections.out.push(connection);

        connections.push(connection);
      }
    } else { // should be a group
      for (var i = 0; i < target.nodes.length; i++) {
        var connection = new Connection(this, target.nodes[i], weight);
        target.nodes[i].connections.in.push(connection);
        this.connections.out.push(connection);
        target.connections.in.push(connection);

        connections.push(connection);
      }
    }
    return connections;
  },

  /**
   * Disconnects this node from the other node
   */
  disconnect: function (node, twosided) {
    if (this === node) {
      this.connections.self.weight = 0;
      return;
    }

    for (var i = 0; i < this.connections.out.length; i++) {
      var conn = this.connections.out[i];
      if (conn.to === node) {
        this.connections.out.splice(i, 1);
        var j = conn.to.connections.in.indexOf(conn);
        conn.to.connections.in.splice(j, 1);
        if (conn.gater !== null) conn.gater.ungate(conn);
        break;
      }
    }

    if (twosided) {
      node.disconnect(this);
    }
  },

  /**
   * Make this node gate a connection
   */
  gate: function (connections) {
    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];

      this.connections.gated.push(connection);
      connection.gater = this;
    }
  },

  /**
   * Removes the gates from this node from the given connection(s)
   */
  ungate: function (connections) {
    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    for (var i = connections.length - 1; i >= 0; i--) {
      var connection = connections[i];

      var index = this.connections.gated.indexOf(connection);
      this.connections.gated.splice(index, 1);
      connection.gater = null;
      connection.gain = 1;
    }
  },

  /**
   * Clear the context of the node
   */
  clear: function () {
    for (var i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      connection.elegibility = 0;
      connection.xtrace = {
        nodes: [],
        values: []
      };
    }

    for (i = 0; i < this.connections.gated.length; i++) {
      var conn = this.connections.gated[i];
      conn.gain = 0;
    }

    this.error.responsibility = this.error.projected = this.error.gated = 0;
    this.old = this.state = this.activation = 0;
  },

  /**
   * Mutates the node with the given method
   */
  mutate: function (method) {
    if (typeof method === 'undefined') {
      throw new Error('No mutate method given!');
    } else if (!(method.name in methods.mutation)) {
      throw new Error('This method does not exist!');
    }

    switch (method) {
      case methods.mutation.MOD_ACTIVATION:
        // Can't be the same squash
        var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];
        this.squash = squash;
        break;
      case methods.mutation.MOD_BIAS:
        var modification = Math.random() * (method.max - method.min) + method.min;
        this.bias += modification;
        break;
    }
  },

  /**
   * Checks if this node is projecting to the given node
   */
  isProjectingTo: function (node) {
    if (node === this && this.connections.self.weight !== 0) return true;

    for (var i = 0; i < this.connections.out.length; i++) {
      var conn = this.connections.out[i];
      if (conn.to === node) {
        return true;
      }
    }
    return false;
  },

  /**
   * Checks if the given node is projecting to this node
   */
  isProjectedBy: function (node) {
    if (node === this && this.connections.self.weight !== 0) return true;

    for (var i = 0; i < this.connections.in.length; i++) {
      var conn = this.connections.in[i];
      if (conn.from === node) {
        return true;
      }
    }

    return false;
  },

  /**
   * Converts the node to a json object
   */
  toJSON: function () {
    var json = {
      bias: this.bias,
      type: this.type,
      squash: this.squash.name,
      layerid : this.layerid,
      groupid : this.group && this.group.id,
      mask: this.mask
    };

    return json;
  }
};

/**
 * Convert a json object to a node
 */
Node.fromJSON = function (json) {
  var node = new Node();
  node.bias = json.bias;
  node.type = json.type;
  node.mask = json.mask;
  node.layerid = json.layerid;
  node.squash = methods.activation[json.squash];
  node.groupid = json.groupid; // TODO recreate node.group=Group() for all nodes with groupid
  return node;
};

/*******************************************************************************
                                         Group
*******************************************************************************/

function Layer () {
  this.output = null;

  this.nodes = [];
  this.connections = { in: [],
    out: [],
    self: []
  };
}

Layer.prototype = {
  /**
   * Activates all the nodes in the group
   */
  activate: function (value) {
    var values = [];

    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = 0; i < this.nodes.length; i++) {
      var activation;
      if (typeof value === 'undefined') {
        activation = this.nodes[i].activate();
      } else {
        activation = this.nodes[i].activate(value[i]);
      }

      values.push(activation);
    }

    return values;
  },

  /**
   * Propagates all the node in the group
   */
  propagate: function (rate, momentum, target) {
    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (typeof target === 'undefined') {
        this.nodes[i].propagate(rate, momentum, true);
      } else {
        this.nodes[i].propagate(rate, momentum, true, target[i]);
      }
    }
  },

  /**
   * Connects the nodes in this group to nodes in another group or just a node
   */
  connect: function (target, method, weight) {
    var connections;
    if (target instanceof Group || target instanceof Node) {
      connections = this.output.connect(target, method, weight);
    } else if (target instanceof Layer) {
      connections = target.input(this, method, weight);
    }

    return connections;
  },

  /**
   * Make nodes from this group gate the given connection(s)
   */
  gate: function (connections, method) {
    this.output.gate(connections, method);
  },

  /**
   * Sets the value of a property for every node
   */
  set: function (values) {
    for (var i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];

      if (node instanceof Node) {
        if (typeof values.bias !== 'undefined') {
          node.bias = values.bias;
        }

        node.squash = values.squash || node.squash;
        node.type = values.type || node.type;
      } else if (node instanceof Group) {
        node.set(values);
      }
    }
  },

  /**
   * Disconnects all nodes from this group from another given group/node
   */
  disconnect: function (target, twosided) {
    twosided = twosided || false;

    // In the future, disconnect will return a connection so indexOf can be used
    var i, j, k;
    if (target instanceof Group) {
      for (i = 0; i < this.nodes.length; i++) {
        for (j = 0; j < target.nodes.length; j++) {
          this.nodes[i].disconnect(target.nodes[j], twosided);

          for (k = this.connections.out.length - 1; k >= 0; k--) {
            var conn = this.connections.out[k];

            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
              this.connections.out.splice(k, 1);
              break;
            }
          }

          if (twosided) {
            for (k = this.connections.in.length - 1; k >= 0; k--) {
              var conn = this.connections.in[k];

              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                this.connections.in.splice(k, 1);
                break;
              }
            }
          }
        }
      }
    } else if (target instanceof Node) {
      for (i = 0; i < this.nodes.length; i++) {
        this.nodes[i].disconnect(target, twosided);

        for (j = this.connections.out.length - 1; j >= 0; j--) {
          var conn = this.connections.out[j];

          if (conn.from === this.nodes[i] && conn.to === target) {
            this.connections.out.splice(j, 1);
            break;
          }
        }

        if (twosided) {
          for (k = this.connections.in.length - 1; k >= 0; k--) {
            var conn = this.connections.in[k];

            if (conn.from === target && conn.to === this.nodes[i]) {
              this.connections.in.splice(k, 1);
              break;
            }
          }
        }
      }
    }
  },

  /**
   * Clear the context of this group
   */
  clear: function () {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }
};

Layer.Dense = function (size) {
  // Create the layer
  var layer = new Layer();

  // Init required nodes (in activation order)
  var block = new Group(size);

  layer.nodes.push(block);
  layer.output = block;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;
    return from.connect(block, method, weight);
  };

  return layer;
};

Layer.LSTM = function (size,options,inputLayer,outputLayer) {
  options=options||{}
  // Create the layer
  var layer = new Layer();

  // Init required nodes (in activation order)
  var inputGate = new Group(size);
  var forgetGate = new Group(size);
  var memoryCell = new Group(size);
  var outputGate = new Group(size);
  var outputBlock = new Group(size);

  inputGate.set({
    bias: 1
  });
  forgetGate.set({
    bias: 1
  });
  outputGate.set({
    bias: 1
  });

  // Set up internal connections
  memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);
  memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);
  memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);
  var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);
  var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);

  // Set up gates
  forgetGate.gate(forget, methods.gating.SELF);
  outputGate.gate(output, methods.gating.OUTPUT);

  // Add to nodes array
  layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];

  // Define output
  layer.output = outputBlock;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;
    var connections = [];

    var input = from.connect(memoryCell, method, weight);
    connections = connections.concat(input);

    connections = connections.concat(from.connect(inputGate, method, weight));
    connections = connections.concat(from.connect(outputGate, method, weight));
    connections = connections.concat(from.connect(forgetGate, method, weight));

    inputGate.gate(input, methods.gating.INPUT);

    return connections;
  };

  // @blab TODO TBC Optional connections
  // Input to all memory cells
  if (inputLayer && options.inputToDeep) {
    console.log('inputToDeep')
    var input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
    inputGate.gate(input, methods.gating.INPUT);
  }
  // Optional connections
  if (options.memoryToMemory) {
    console.log('memoryToMemory')
    var input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE,options.weight);
    inputGate.gate(input, methods.gating.INPUT);
  }
  if (options.outputToMemory) {
    console.log('outputToMemory')
    var input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
    inputGate.gate(input, methods.gating.INPUT);
  }
  if (outputLayer && options.outputToGates) {
    console.log('outputToGates')
    outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
    outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);
    outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
  }

  return layer;
};

Layer.GRU = function (size,options) {
  // Create the layer
  var layer = new Layer();
  var layerid = options && options.layerid;
  var updateGate = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var inverseUpdateGate = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var resetGate = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var memoryCell = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var output = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var previousOutput = new Group(size,layerid!=undefined?{layerid:layerid}:{});

  previousOutput.set({
    bias: 0,
    squash: methods.activation.IDENTITY,
    type: 'constant'
  });
  memoryCell.set({
    squash: methods.activation.TANH
  });
  inverseUpdateGate.set({
    bias: 0,
    squash: methods.activation.INVERSE,
    type: 'constant'
  });
  updateGate.set({
    bias: 1
  });
  resetGate.set({
    bias: 0
  });

  // Update gate calculation
  previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);

  // Inverse update gate calculation
  updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);

  // Reset gate calculation
  previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);

  // Memory calculation
  var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);

  resetGate.gate(reset, methods.gating.OUTPUT); // gate

  // Output calculation
  var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);
  var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);

  updateGate.gate(update1, methods.gating.OUTPUT);
  inverseUpdateGate.gate(update2, methods.gating.OUTPUT);

  // Previous output calculation
  output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);

  // Add to nodes array
  layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];

  layer.output = output;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;
    var connections = [];

    connections = connections.concat(from.connect(updateGate, method, weight));
    connections = connections.concat(from.connect(resetGate, method, weight));
    connections = connections.concat(from.connect(memoryCell, method, weight));

    return connections;
  };

  return layer;
};

Layer.Memory = function (size, memory) {
  // Create the layer
  var layer = new Layer();
  // Because the output can only be one group, we have to put the nodes all in óne group

  var previous = null;
  var i;
  for (i = 0; i < memory; i++) {
    var block = new Group(size);

    block.set({
      squash: methods.activation.IDENTITY,
      bias: 0,
      type: 'constant'
    });

    if (previous != null) {
      previous.connect(block, methods.connection.ONE_TO_ONE, 1);
    }

    layer.nodes.push(block);
    previous = block;
  }

  layer.nodes.reverse();

  for (i = 0; i < layer.nodes.length; i++) {
    layer.nodes[i].nodes.reverse();
  }

  // Because output can only be óne group, fit all memory nodes in óne group
  var outputGroup = new Group(0);
  for (var group in layer.nodes) {
    outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);
  }
  layer.output = outputGroup;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;

    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {
      throw new Error('Previous layer size must be same as memory size');
    }

    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);
  };

  return layer;
};


/*******************************************************************************
                                         Group
*******************************************************************************/

function Group (size,options) {
  this.nodes = [];
  this.connections = {
    in: [],
    out: [],
    self: []
  };
  this.id=config.groupId++;
  if (options && options.layerid!=undefined) this.layerid=options.layerid;
  for (var i = 0; i < size; i++) {
    var node = new Node(null,this.layerid!=undefined?{layerid:this.layerid,group:this}:{group:this});
    this.nodes.push(node);
  }
}

Group.prototype = {
  /**
   * Activates all the nodes in the group
   */
  activate: function (value) {
    var values = [];

    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = 0; i < this.nodes.length; i++) {
      var activation;
      if (typeof value === 'undefined') {
        activation = this.nodes[i].activate();
      } else {
        activation = this.nodes[i].activate(value[i]);
      }

      values.push(activation);
    }

    return values;
  },

  /**
   * Propagates all the node in the group
   */
  propagate: function (rate, momentum, target) {
    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (typeof target === 'undefined') {
        this.nodes[i].propagate(rate, momentum, true);
      } else {
        this.nodes[i].propagate(rate, momentum, true, target[i]);
      }
    }
  },

  /**
   * Connects the nodes in this group to nodes in another group or just a node
   */
  connect: function (target, method, weight) {
    var connections = [];
    var i, j;
    if (target instanceof Group) {
      if (typeof method === 'undefined') {
        if (this !== target) {
          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');
          method = methods.connection.ALL_TO_ALL;
        } else {
          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');
          method = methods.connection.ONE_TO_ONE;
        }
      }
      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {
        for (i = 0; i < this.nodes.length; i++) {
          for (j = 0; j < target.nodes.length; j++) {
            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;
            var connection = this.nodes[i].connect(target.nodes[j], weight);
            this.connections.out.push(connection[0]);
            target.connections.in.push(connection[0]);
            connections.push(connection[0]);
          }
        }
      } else if (method === methods.connection.ONE_TO_ONE) {
        if (this.nodes.length !== target.nodes.length) {
          throw new Error('From and To group must be the same size!');
        }

        for (i = 0; i < this.nodes.length; i++) {
          var connection = this.nodes[i].connect(target.nodes[i], weight);
          this.connections.self.push(connection[0]);
          connections.push(connection[0]);
        }
      }
    } else if (target instanceof Layer) {
      connections = target.input(this, method, weight);
    } else if (target instanceof Node) {
      for (i = 0; i < this.nodes.length; i++) {
        var connection = this.nodes[i].connect(target, weight);
        this.connections.out.push(connection[0]);
        connections.push(connection[0]);
      }
    }

    return connections;
  },

  /**
   * Make nodes from this group gate the given connection(s)
   */
  gate: function (connections, method) {
    if (typeof method === 'undefined') {
      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');
    }

    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    var nodes1 = [];
    var nodes2 = [];

    var i, j;
    for (i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);
      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);
    }

    switch (method) {
      case methods.gating.INPUT:
        for (i = 0; i < nodes2.length; i++) {
          var node = nodes2[i];
          var gater = this.nodes[i % this.nodes.length];

          for (j = 0; j < node.connections.in.length; j++) {
            var conn = node.connections.in[j];
            if (connections.includes(conn)) {
              gater.gate(conn);
            }
          }
        }
        break;
      case methods.gating.OUTPUT:
        for (i = 0; i < nodes1.length; i++) {
          var node = nodes1[i];
          var gater = this.nodes[i % this.nodes.length];

          for (j = 0; j < node.connections.out.length; j++) {
            var conn = node.connections.out[j];
            if (connections.includes(conn)) {
              gater.gate(conn);
            }
          }
        }
        break;
      case methods.gating.SELF:
        for (i = 0; i < nodes1.length; i++) {
          var node = nodes1[i];
          var gater = this.nodes[i % this.nodes.length];

          if (connections.includes(node.connections.self)) {
            gater.gate(node.connections.self);
          }
        }
    }
  },

  /**
   * Sets the value of a property for every node
   */
  set: function (values) {
    for (var i = 0; i < this.nodes.length; i++) {
      if (typeof values.bias !== 'undefined') {
        this.nodes[i].bias = values.bias;
      }

      this.nodes[i].squash = values.squash || this.nodes[i].squash;
      this.nodes[i].type = values.type || this.nodes[i].type;
    }
  },

  /**
   * Disconnects all nodes from this group from another given group/node
   */
  disconnect: function (target, twosided) {
    twosided = twosided || false;

    // In the future, disconnect will return a connection so indexOf can be used
    var i, j, k;
    if (target instanceof Group) {
      for (i = 0; i < this.nodes.length; i++) {
        for (j = 0; j < target.nodes.length; j++) {
          this.nodes[i].disconnect(target.nodes[j], twosided);

          for (k = this.connections.out.length - 1; k >= 0; k--) {
            var conn = this.connections.out[k];

            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
              this.connections.out.splice(k, 1);
              break;
            }
          }

          if (twosided) {
            for (k = this.connections.in.length - 1; k >= 0; k--) {
              var conn = this.connections.in[k];

              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                this.connections.in.splice(k, 1);
                break;
              }
            }
          }
        }
      }
    } else if (target instanceof Node) {
      for (i = 0; i < this.nodes.length; i++) {
        this.nodes[i].disconnect(target, twosided);

        for (j = this.connections.out.length - 1; j >= 0; j--) {
          var conn = this.connections.out[j];

          if (conn.from === this.nodes[i] && conn.to === target) {
            this.connections.out.splice(j, 1);
            break;
          }
        }

        if (twosided) {
          for (j = this.connections.in.length - 1; j >= 0; j--) {
            var conn = this.connections.in[j];

            if (conn.from === target && conn.to === this.nodes[i]) {
              this.connections.in.splice(j, 1);
              break;
            }
          }
        }
      }
    }
  },

  /**
   * Clear the context of this group
   */
  clear: function () {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }
};

/* Easier variable naming */
var selection = methods.selection;

/*******************************************************************************
                                         NEAT
*******************************************************************************/

function Neat (input, output, fitness, options) {
  this.input = input; // The input size of the networks
  this.output = output; // The output size of the networks
  this.fitness = fitness; // The fitness function to evaluate the networks

  // Configure options
  options = options || {};
  this.equal = options.equal || false;
  this.clear = options.clear || false;
  this.popsize = options.popsize || 50;
  this.elitism = options.elitism || 0;
  this.provenance = options.provenance || 0;
  this.mutationRate = options.mutationRate || 0.3;
  this.mutationAmount = options.mutationAmount || 1;

  this.fitnessPopulation = options.fitnessPopulation || false;

  this.selection = options.selection || methods.selection.POWER;
  this.crossover = options.crossover || [
    methods.crossover.SINGLE_POINT,
    methods.crossover.TWO_POINT,
    methods.crossover.UNIFORM,
    methods.crossover.AVERAGE
  ];
  this.mutation = options.mutation || methods.mutation.FFW;

  this.template = options.network || false;

  this.maxNodes = options.maxNodes || Infinity;
  this.maxConns = options.maxConns || Infinity;
  this.maxGates = options.maxGates || Infinity;

  // Custom mutation selection function if given
  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;

  // Generation counter
  this.generation = 0;

  // Initialise the genomes
  this.createPool(this.template);
}

Neat.prototype = {
  /**
   * Create the initial pool of genomes
   */
  createPool: function (network) {
    this.population = [];

    for (var i = 0; i < this.popsize; i++) {
      var copy;
      if (this.template) {
        copy = Network.fromJSON(network.toJSON());
      } else {
        copy = new Network(this.input, this.output);
      }
      copy.score = undefined;
      this.population.push(copy);
    }
  },

  /**
   * Evaluates, selects, breeds and mutates population
   */
  evolve: function () {
    // Check if evaluated, sort the population
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }
    this.sort();

    var fittest = Network.fromJSON(this.population[0].toJSON());
    fittest.score = this.population[0].score;

    var newPopulation = [];

    // Elitism
    var elitists = [];
    for (var i = 0; i < this.elitism; i++) {
      elitists.push(this.population[i]);
    }

    // Provenance
    for (i = 0; i < this.provenance; i++) {
      newPopulation.push(Network.fromJSON(this.template.toJSON()));
    }

    // Breed the next individuals
    for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {
      newPopulation.push(this.getOffspring());
    }

    // Replace the old population with the new population
    this.population = newPopulation;
    this.mutate();

    // this.population.push(...elitists);
    var _this$population;
    (_this$population = this.population).push.apply(_this$population, elitists); 

    // Reset the scores
    for (i = 0; i < this.population.length; i++) {
      this.population[i].score = undefined;
    }

    this.generation++;

    return fittest;
  },

  /**
   * Breeds two parents into an offspring, population MUST be surted
   */
  getOffspring: function () {
    var parent1 = this.getParent();
    var parent2 = this.getParent();

    return Network.crossOver(parent1, parent2, this.equal);
  },

  /**
   * Selects a random mutation method for a genome according to the parameters
   */
  selectMutationMethod: function (genome) {
    var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];

    if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {
      if (config.warnings) console.warn('maxNodes exceeded!');
      return;
    }

    if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {
      if (config.warnings) console.warn('maxConns exceeded!');
      return;
    }

    if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {
      if (config.warnings) console.warn('maxGates exceeded!');
      return;
    }

    return mutationMethod;
  },

  /**
   * Mutates the given (or current) population
   */
  mutate: function () {
    // Elitist genomes should not be included
    for (var i = 0; i < this.population.length; i++) {
      if (Math.random() <= this.mutationRate) {
        for (var j = 0; j < this.mutationAmount; j++) {
          var mutationMethod = this.selectMutationMethod(this.population[i]);
          this.population[i].mutate(mutationMethod);
        }
      }
    }
  },

  /**
   * Evaluates the current population
   */
  evaluate: function () {
    var i;
    if (this.fitnessPopulation) {
      if (this.clear) {
        for (i = 0; i < this.population.length; i++) {
          this.population[i].clear();
        }
      }
      this.fitness(this.population);
    } else {
      for (i = 0; i < this.population.length; i++) {
        var genome = this.population[i];
        if (this.clear) genome.clear();
        genome.score = this.fitness(genome);
      }
    }
  },

  /**
   * Sorts the population by score
   */
  sort: function () {
    this.population.sort(function (a, b) {
      return b.score - a.score;
    });
  },

  /**
   * Returns the fittest genome of the current population
   */
  getFittest: function () {
    // Check if evaluated
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }
    if (this.population[0].score < this.population[1].score) {
      this.sort();
    }

    return this.population[0];
  },

  /**
   * Returns the average fitness of the current population
   */
  getAverage: function () {
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }

    var score = 0;
    for (var i = 0; i < this.population.length; i++) {
      score += this.population[i].score;
    }

    return score / this.population.length;
  },

  /**
   * Gets a genome based on the selection function
   * @return {Network} genome
   */
  getParent: function () {
    var i;
    switch (this.selection) {
      case selection.POWER:
        if (this.population[0].score < this.population[1].score) this.sort();

        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);
        return this.population[index];
      case selection.FITNESS_PROPORTIONATE:
        // As negative fitnesses are possible
        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values
        // this is unnecessarily run for every individual, should be changed

        var totalFitness = 0;
        var minimalFitness = 0;
        for (i = 0; i < this.population.length; i++) {
          var score = this.population[i].score;
          minimalFitness = score < minimalFitness ? score : minimalFitness;
          totalFitness += score;
        }

        minimalFitness = Math.abs(minimalFitness);
        totalFitness += minimalFitness * this.population.length;

        var random = Math.random() * totalFitness;
        var value = 0;

        for (i = 0; i < this.population.length; i++) {
          var genome = this.population[i];
          value += genome.score + minimalFitness;
          if (random < value) return genome;
        }

        // if all scores equal, return random genome
        return this.population[Math.floor(Math.random() * this.population.length)];
      case selection.TOURNAMENT:
        if (this.selection.size > this.popsize) {
          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');
        }

        // Create a tournament
        var individuals = [];
        for (i = 0; i < this.selection.size; i++) {
          var random = this.population[Math.floor(Math.random() * this.population.length)];
          individuals.push(random);
        }

        // Sort the tournament individuals by score
        individuals.sort(function (a, b) {
          return b.score - a.score;
        });

        // Select an individual
        for (i = 0; i < this.selection.size; i++) {
          if (Math.random() < this.selection.probability || i === this.selection.size - 1) {
            return individuals[i];
          }
        }
    }
  },
  
  
  test: function (L,data) {
    
  },

  /**
   * Export the current population to a json object
   */
  export: function () {
    var json = [];
    for (var i = 0; i < this.population.length; i++) {
      var genome = this.population[i];
      json.push(genome.toJSON());
    }

    return json;
  },

  /**
   * Import population from a json object
   */
  import: function (json) {
    var population = [];
    for (var i = 0; i < json.length; i++) {
      var genome = json[i];
      population.push(Network.fromJSON(genome));
    }
    this.population = population;
    this.popsize = population.length;
  }
};


var Neataptic = {
  methods: methods,
  Connection: Connection,
  architect: architect,
  Network: Network,
  config: config,
  Group: Group,
  Layer: Layer,
  Node: Node,
  Neat: Neat
};

module.exports = Neataptic
};
BundleModuleCode['plugins/ml/pca']=function (module,exports){
// https://github.com/bitanath/pca
var PCA = (function () {
    var options = {};
    /**
     * The first step is to subtract the mean and center data
     * 
     * @param {Array} matrix - data in an mXn matrix format
     * @returns 
     */
    function computeDeviationMatrix(matrix) {
        var unit = unitSquareMatrix(matrix.length);
        return subtract(matrix, scale(multiply(unit, matrix), 1 / matrix.length));
    }
    /**
     * Computes variance from deviation
     * 
     * @param {Array} deviation - data minus mean as calculated from computeDeviationMatrix
     * @returns 
     */
    function computeDeviationScores(deviation) {
        var devSumOfSquares = multiply(transpose(deviation), deviation);
        return devSumOfSquares;
    }
    /**
     * Calculates the var covar square matrix using either population or sample
     * 
     * @param {Array} devSumOfSquares 
     * @param {boolean} sample - true/false whether data is from sample or not
     * @returns 
     */
    function computeVarianceCovariance(devSumOfSquares, sample) {
        var varianceCovariance;
        if (sample)
            varianceCovariance = scale(devSumOfSquares, 1 / (devSumOfSquares.length - 1));
        else
            varianceCovariance = scale(devSumOfSquares, 1 / (devSumOfSquares.length));
        return varianceCovariance;
    }
    /**
     * Matrix is the deviation sum of squares as computed earlier
     * 
     * @param {Array} matrix - output of computeDeviationScores
     * @returns 
     */
    function computeSVD(matrix) {
        var result = svd(matrix);
        if (options.verbose) console.log(result)
        var eigenvectors = result.U;
        var eigenvalues = result.S;
        var results = eigenvalues.map(function (value, i) {
            var obj = {};
            obj.eigenvalue = value;
            obj.vector = eigenvectors.map(function (vector, j) {
                return -1 * vector[i]; //HACK prevent completely negative vectors
            });
            return obj;
        });
        return results;
    }
    /**
     * Get reduced dataset after removing some dimensions
     * 
     * @param {Array} data - initial matrix started out with
     * @param {rest} vectors - eigenvectors selected as part of process
     * @returns 
     */
    function computeAdjustedData(data) {
        for (var _len = arguments.length, vectorObjs = new Array(_len > 1 ? _len - 1 : 0), 
            _key = 1; _key < _len; _key++) {
            vectorObjs[_key - 1] = arguments[_key];
        }
        //FIXME no need to transpose vectors since they're already in row normal form
        var vectors = vectorObjs.map(function(v){return v.vector});
        var matrixMinusMean = computeDeviationMatrix(data);
        var adjustedData = multiply(vectors, transpose(matrixMinusMean));
        var unit = unitSquareMatrix(data.length);
        var avgData = scale(multiply(unit, data), -1 / data.length); //NOTE get the averages to add back

        var formattedAdjustData = formatData(adjustedData, 2);
        return {
            adjustedData: adjustedData,
            formattedAdjustedData: formattedAdjustData,
            avgData: avgData,
            selectedVectors: vectors
        };
    }

    /**
     * Get original data set from reduced data set (decompress)
     * @param {*} adjustedData = formatted or unformatted adjusted data
     * @param {*} vectors = selectedVectors
     * @param {*} avgData = avgData
     */
    function computeOriginalData(adjustedData, vectors, avgData) {
        var originalWithoutMean = transpose(multiply(transpose(vectors), adjustedData));
        var originalWithMean = subtract(originalWithoutMean, avgData);
        var formattedData = formatData(originalWithMean, 2);
        return {
            originalData: originalWithMean,
            formattedOriginalData: formattedData
        }
    }

    /**
     * Get percentage explained, or loss
     * @param {*} vectors 
     * @param {*} selected 
     */
    function computePercentageExplained(vectors) {
        for (var _len = arguments.length, selected = new Array(_len > 1 ? _len - 1 : 0),
             _key = 1; _key < _len; _key++) {
            selected[_key - 1] = arguments[_key];
        }
        var total = vectors.map(function (v) {
            return v.eigenvalue
        }).reduce(function (a, b) {
            return a + b;
        });
        var explained = selected.map(function (v) {
            return v.eigenvalue
        }).reduce(function (a, b) {
            return a + b;
        });
        return (explained / total);
    }

    function getEigenVectors(data) {
        return computeSVD(computeVarianceCovariance(computeDeviationScores(computeDeviationMatrix(data)), false));
    }

    function analyseTopResult(data) {
        var eigenVectors = getEigenVectors(data);
        var sorted = eigenVectors.sort(function (a, b) {
            return b.eigenvalue - a.eigenvalue;
        });
        console.log('Sorted Vectors', sorted);
        var selected = sorted[0].vector;
        return computeAdjustedData(data, selected);
    }

    function formatData(data, precision) {
        var TEN = Math.pow(10, precision || 2);
        return data.map(function (d, i) {
            return d.map(function (n) {
                return Math.round(n * TEN) / TEN;
            })
        })
    }
    /**
     * Multiplies AxB, where A and B are matrices of nXm and mXn dimensions
     * @param {} a 
     * @param {*} b 
     */
    function multiply(a, b) {
        if (!a[0] || !b[0] || !a.length || !b.length) {
            throw new Error('Both A and B should be matrices');
        }

        if (b.length !== a[0].length) {
            throw new Error('Columns in A should be the same as the number of rows in B');
        }
        var product = [];

        for (var i = 0; i < a.length; i++) {
            product[i] = []; //initialize a new row
            for (var j = 0; j < b[0].length; j++) {
                for (var k = 0; k < a[0].length; k++) {
                    (product[i])[j] = !!(product[i])[j] ? (product[i])[j] + (a[i])[k] * (b[k])[j] : (a[i])[k] * (b[k])[j];
                }
            }
        }
        return product;
    }
    /**
     * Utility function to subtract matrix b from a
     * 
     * @param {any} a 
     * @param {any} b 
     * @returns 
     */
    function subtract(a, b) {
        if (!(a.length === b.length && a[0].length === b[0].length))
            throw new Error('Both A and B should have the same dimensions');
        var result = [];
        for (var i = 0; i < a.length; i++) {
            result[i] = [];
            for (var j = 0; j < b[0].length; j++) {
                (result[i])[j] = (a[i])[j] - (b[i])[j];
            }
        }
        return result;
    }
    /**
     * Multiplies a matrix into a factor
     * 
     * @param {any} matrix 
     * @param {any} factor 
     * @returns 
     */
    function scale(matrix, factor) {
        var result = [];
        for (var i = 0; i < matrix.length; i++) {
            result[i] = [];
            for (var j = 0; j < matrix[0].length; j++) {
                (result[i])[j] = (matrix[i])[j] * factor;
            }
        }
        return result;
    }

    /**
     * Generates a unit square matrix
     * @param {*} rows = number of rows to fill
     */
    function unitSquareMatrix(rows) {
        var result = [];
        for (var i = 0; i < rows; i++) {
            result[i] = [];
            for (var j = 0; j < rows; j++) {
                (result[i])[j] = 1;
            }
        }
        return result;
    }
    /**
     * Transposes a matrix, converts rows to columns
     * @param {*} matrix 
     */
    function transpose(matrix) {
        var operated = clone(matrix);
        return operated[0].map(function (m, c) {
            return matrix.map(function (r) {
                return r[c];
            });
        });
    }
    /**
     * Deep Clones a matrix
     * @param {*} arr 
     */
    function clone(arr) {
        var string = JSON.stringify(arr);
        var result = JSON.parse(string);
        return result;
    }

    /**
     * Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
     * From the Numeric JS Implementation Copyright (C) 2011 by Sébastien Loisel
     * The C implementation from which this has been taken may be found here: http://www.public.iastate.edu/~dicook/JSS/paper/code/svd.c
     * @param {*} A = m*n matrix
     */
    function svd(A) {
        var temp;
        var prec = Math.pow(2, -52) // assumes double prec
        var tolerance = 1.e-64 / prec;
        var itmax = 50;
        var c = 0;
        var i = 0;
        var j = 0;
        var k = 0;
        var l = 0;
        var u = clone(A);
        var m = u.length;
        var n = u[0].length;

        if (m < n) throw "Need more rows than columns"

        var e = new Array(n); //vector1
        var q = new Array(n); //vector2
        for (i = 0; i < n; i++) e[i] = q[i] = 0.0;
        var v = rep([n, n], 0);

        function pythag(a, b) {
            a = Math.abs(a)
            b = Math.abs(b)
            if (a > b)
                return a * Math.sqrt(1.0 + (b * b / a / a))
            else if (b == 0.0)
                return a
            return b * Math.sqrt(1.0 + (a * a / b / b))
        }

        //rep function
        function rep(s, v, k) {
            if (typeof k === "undefined") {
                k = 0;
            }
            var n = s[k],
                ret = Array(n),
                i;
            if (k === s.length - 1) {
                for (i = n - 2; i >= 0; i -= 2) {
                    ret[i + 1] = v;
                    ret[i] = v;
                }
                if (i === -1) {
                    ret[0] = v;
                }
                return ret;
            }
            for (i = n - 1; i >= 0; i--) {
                ret[i] = rep(s, v, k + 1);
            }
            return ret;
        }

        //Householder's reduction to bidiagonal form

        var f = 0.0;
        var g = 0.0;
        var h = 0.0;
        var x = 0.0;
        var y = 0.0;
        var z = 0.0;
        var s = 0.0;

        for (i = 0; i < n; i++) {
            e[i] = g; //vector
            s = 0.0; //sum
            l = i + 1; //stays i+1
            for (j = i; j < m; j++)
                s += (u[j][i] * u[j][i]);
            if (s <= tolerance)
                g = 0.0;
            else {
                f = u[i][i];
                g = Math.sqrt(s);
                if (f >= 0.0) g = -g;
                h = f * g - s
                u[i][i] = f - g;
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = i; k < m; k++)
                        s += u[k][i] * u[k][j]
                    f = s / h
                    for (k = i; k < m; k++)
                        u[k][j] += f * u[k][i]
                }
            }
            q[i] = g
            s = 0.0
            for (j = l; j < n; j++)
                s = s + u[i][j] * u[i][j]
            if (s <= tolerance)
                g = 0.0
            else {
                f = u[i][i + 1]
                g = Math.sqrt(s)
                if (f >= 0.0) g = -g
                h = f * g - s
                u[i][i + 1] = f - g;
                for (j = l; j < n; j++) e[j] = u[i][j] / h
                for (j = l; j < m; j++) {
                    s = 0.0
                    for (k = l; k < n; k++)
                        s += (u[j][k] * u[i][k])
                    for (k = l; k < n; k++)
                        u[j][k] += s * e[k]
                }
            }
            y = Math.abs(q[i]) + Math.abs(e[i])
            if (y > x)
                x = y
        }

        // accumulation of right hand transformations
        for (i = n - 1; i != -1; i += -1) {
            if (g != 0.0) {
                h = g * u[i][i + 1]
                for (j = l; j < n; j++)
                    v[j][i] = u[i][j] / h //u is array, v is square of columns
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = l; k < n; k++)
                        s += u[i][k] * v[k][j]
                    for (k = l; k < n; k++)
                        v[k][j] += (s * v[k][i])
                }
            }
            for (j = l; j < n; j++) {
                v[i][j] = 0;
                v[j][i] = 0;
            }
            v[i][i] = 1;
            g = e[i]
            l = i
        }

        // accumulation of left hand transformations
        for (i = n - 1; i != -1; i += -1) {
            l = i + 1
            g = q[i]
            for (j = l; j < n; j++)
                u[i][j] = 0;
            if (g != 0.0) {
                h = u[i][i] * g
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = l; k < m; k++) s += u[k][i] * u[k][j];
                    f = s / h
                    for (k = i; k < m; k++) u[k][j] += f * u[k][i];
                }
                for (j = i; j < m; j++) u[j][i] = u[j][i] / g;
            } else
                for (j = i; j < m; j++) u[j][i] = 0;
            u[i][i] += 1;
        }

        // diagonalization of the bidiagonal form
        prec = prec * x
        for (k = n - 1; k != -1; k += -1) {
            for (var iteration = 0; iteration < itmax; iteration++) { // test f splitting
                var test_convergence = false
                for (l = k; l != -1; l += -1) {
                    if (Math.abs(e[l]) <= prec) {
                        test_convergence = true
                        break
                    }
                    if (Math.abs(q[l - 1]) <= prec)
                        break
                }
                if (!test_convergence) { // cancellation of e[l] if l>0
                    c = 0.0
                    s = 1.0
                    var l1 = l - 1
                    for (i = l; i < k + 1; i++) {
                        f = s * e[i]
                        e[i] = c * e[i]
                        if (Math.abs(f) <= prec)
                            break
                        g = q[i]
                        h = pythag(f, g)
                        q[i] = h
                        c = g / h
                        s = -f / h
                        for (j = 0; j < m; j++) {
                            y = u[j][l1]
                            z = u[j][i]
                            u[j][l1] = y * c + (z * s)
                            u[j][i] = -y * s + (z * c)
                        }
                    }
                }
                // test f convergence
                z = q[k]
                if (l == k) { //convergence
                    if (z < 0.0) { //q[k] is made non-negative
                        q[k] = -z
                        for (j = 0; j < n; j++)
                            v[j][k] = -v[j][k]
                    }
                    break //break out of iteration loop and move on to next k value
                }
                if (iteration >= itmax - 1)
                    throw 'Error: no convergence.'
                // shift from bottom 2x2 minor
                x = q[l]
                y = q[k - 1]
                g = e[k - 1]
                h = e[k]
                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y)
                g = pythag(f, 1.0)
                if (f < 0.0)
                    f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x
                else
                    f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x
                // next QR transformation
                c = 1.0
                s = 1.0
                for (i = l + 1; i < k + 1; i++) {
                    g = e[i]
                    y = q[i]
                    h = s * g
                    g = c * g
                    z = pythag(f, h)
                    e[i - 1] = z
                    c = f / z
                    s = h / z
                    f = x * c + g * s
                    g = -x * s + g * c
                    h = y * s
                    y = y * c
                    for (j = 0; j < n; j++) {
                        x = v[j][i - 1]
                        z = v[j][i]
                        v[j][i - 1] = x * c + z * s
                        v[j][i] = -x * s + z * c
                    }
                    z = pythag(f, h)
                    q[i - 1] = z
                    c = f / z
                    s = h / z
                    f = c * g + s * y
                    x = -s * g + c * y
                    for (j = 0; j < m; j++) {
                        y = u[j][i - 1]
                        z = u[j][i]
                        u[j][i - 1] = y * c + z * s
                        u[j][i] = -y * s + z * c
                    }
                }
                e[l] = 0.0
                e[k] = f
                q[k] = x
            }
        }

        for (i = 0; i < q.length; i++)
            if (q[i] < prec) q[i] = 0

        //sort eigenvalues	
        for (i = 0; i < n; i++) {
            for (j = i - 1; j >= 0; j--) {
                if (q[j] < q[i]) {
                    c = q[j]
                    q[j] = q[i]
                    q[i] = c
                    for (k = 0; k < u.length; k++) {
                        temp = u[k][i];
                        u[k][i] = u[k][j];
                        u[k][j] = temp;
                    }
                    for (k = 0; k < v.length; k++) {
                        temp = v[k][i];
                        v[k][i] = v[k][j];
                        v[k][j] = temp;
                    }
                    i = j
                }
            }
        }

        return {
            U: u,
            S: q,
            V: v
        }
    }

    return {
        computeDeviationScores: computeDeviationScores,
        computeDeviationMatrix: computeDeviationMatrix,
        computeSVD: computeSVD,
        computePercentageExplained: computePercentageExplained,
        computeOriginalData: computeOriginalData,
        computeVarianceCovariance: computeVarianceCovariance,
        computeAdjustedData: computeAdjustedData,
        getEigenVectors: getEigenVectors,
        analyseTopResult: analyseTopResult,
        transpose: transpose,
        multiply: multiply,
        clone: clone,
        scale: scale,
        options:options
    }
})();

if(typeof module !== 'undefined')
module.exports = PCA;
};
BundleModuleCode['plugins/ml/dbclust']=function (module,exports){
/**
 * DBSCAN - Density based clustering
 *
 * https://github.com/uhho/density-clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * DBSCAN class construcotr
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {DBSCAN}
 */
function DBSCAN(dataset, epsilon, minPts, distanceFunction) {
  if (!(this instanceof DBSCAN)) return new DBSCAN(dataset, epsilon, minPts, distanceFunction);
  /** @type {Array} */
  this.dataset = [];
  /** @type {number} */
  this.epsilon = 1;
  /** @type {number} */
  this.minPts = 2;
  /** @type {function} */
  this.distance = this._euclideanDistance;
  /** @type {Array} */
  this.clusters = [];
  /** @type {Array} */
  this.noise = [];

  // temporary variables used during computation

  /** @type {Array} */
  this._visited = [];
  /** @type {Array} */
  this._assigned = [];
  /** @type {number} */
  this._datasetLength = 0;

  this._init(dataset, epsilon, minPts, distanceFunction);
};

/******************************************************************************/
// public functions

/**
 * Start clustering
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {undefined}
 * @access public
 */
DBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
  this._init(dataset, epsilon, minPts, distanceFunction);

  for (var pointId = 0; pointId < this._datasetLength; pointId++) {
    // if point is not visited, check if it forms a cluster
    if (this._visited[pointId] !== 1) {
      this._visited[pointId] = 1;

      // if closest neighborhood is too small to form a cluster, mark as noise
      var neighbors = this._regionQuery(pointId);

      if (neighbors.length < this.minPts) {
        this.noise.push(pointId);
      } else {
        // create new cluster and add point
        var clusterId = this.clusters.length;
        this.clusters.push([]);
        this._addToCluster(pointId, clusterId);

        this._expandCluster(clusterId, neighbors);
      }
    }
  }

  return this.clusters;
};

/******************************************************************************/
// protected functions

/**
 * Set object properties
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distance
 * @returns {undefined}
 * @access protected
 */
DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {

  if (dataset) {

    if (!(dataset instanceof Array)) {
      throw Error('Dataset must be of type array, ' +
        typeof dataset + ' given');
    }

    this.dataset = dataset;
    this.clusters = [];
    this.noise = [];

    this._datasetLength = dataset.length;
    this._visited = new Array(this._datasetLength);
    this._assigned = new Array(this._datasetLength);
  }

  if (epsilon) {
    this.epsilon = epsilon;
  }

  if (minPts) {
    this.minPts = minPts;
  }

  if (distance) {
    this.distance = distance;
  }
};

/**
 * Expand cluster to closest points of given neighborhood
 *
 * @param {number} clusterId
 * @param {Array} neighbors
 * @returns {undefined}
 * @access protected
 */
DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {

  /**
   * It's very important to calculate length of neighbors array each time,
   * as the number of elements changes over time
   */
  for (var i = 0; i < neighbors.length; i++) {
    var pointId2 = neighbors[i];

    if (this._visited[pointId2] !== 1) {
      this._visited[pointId2] = 1;
      var neighbors2 = this._regionQuery(pointId2);

      if (neighbors2.length >= this.minPts) {
        neighbors = this._mergeArrays(neighbors, neighbors2);
      }
    }

    // add to cluster
    if (this._assigned[pointId2] !== 1) {
      this._addToCluster(pointId2, clusterId);
    }
  }
};

/**
 * Add new point to cluster
 *
 * @param {number} pointId
 * @param {number} clusterId
 */
DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
  this.clusters[clusterId].push(pointId);
  this._assigned[pointId] = 1;
};

/**
 * Find all neighbors around given point
 *
 * @param {number} pointId,
 * @param {number} epsilon
 * @returns {Array}
 * @access protected
 */
DBSCAN.prototype._regionQuery = function(pointId) {
  var neighbors = [];

  for (var id = 0; id < this._datasetLength; id++) {
    var dist = this.distance(this.dataset[pointId], this.dataset[id]);
    if (dist < this.epsilon) {
      neighbors.push(id);
    }
  }

  return neighbors;
};

/******************************************************************************/
// helpers

/**
 * @param {Array} a
 * @param {Array} b
 * @returns {Array}
 * @access protected
 */
DBSCAN.prototype._mergeArrays = function(a, b) {
  var len = b.length;

  for (var i = 0; i < len; i++) {
    var P = b[i];
    if (a.indexOf(P) < 0) {
      a.push(P);
    }
  }

  return a;
};

/**
 * Calculate euclidean distance in multidimensional space
 *
 * @param {Array} p
 * @param {Array} q
 * @returns {number}
 * @access protected
 */
DBSCAN.prototype._euclideanDistance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    sum += (p[i] - q[i]) * (p[i] - q[i]);
  }

  return Math.sqrt(sum);
};


/**
 * KMEANS clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * KMEANS class constructor
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} k - number of clusters
 * @param {function} distance - distance function
 * @returns {KMEANS}
 */
 function KMEANS(dataset, k, distance) {
  this.k = 3; // number of clusters
  this.dataset = []; // set of feature vectors
  this.assignments = []; // set of associated clusters for each feature vector
  this.centroids = []; // vectors for our clusters

  this.init(dataset, k, distance);
}

/**
 * @returns {undefined}
 */
KMEANS.prototype.init = function(dataset, k, distance) {
  this.assignments = [];
  this.centroids = [];

  if (typeof dataset !== 'undefined') {
    this.dataset = dataset;
  }

  if (typeof k !== 'undefined') {
    this.k = k;
  }

  if (typeof distance !== 'undefined') {
    this.distance = distance;
  }
};

/**
 * @returns {undefined}
 */
KMEANS.prototype.run = function(dataset, k) {
  this.init(dataset, k);

  var len = this.dataset.length;

  // initialize centroids
  for (var i = 0; i < this.k; i++) {
    this.centroids[i] = this.randomCentroid();
	}

  var change = true;
  while(change) {

    // assign feature vectors to clusters
    change = this.assign();

    // adjust location of centroids
    for (var centroidId = 0; centroidId < this.k; centroidId++) {
      var mean = new Array(maxDim);
      var count = 0;

      // init mean vector
      for (var dim = 0; dim < maxDim; dim++) {
        mean[dim] = 0;
      }

      for (var j = 0; j < len; j++) {
        var maxDim = this.dataset[j].length;

        // if current cluster id is assigned to point
        if (centroidId === this.assignments[j]) {
          for (var dim = 0; dim < maxDim; dim++) {
            mean[dim] += this.dataset[j][dim];
          }
          count++;
        }
      }

      if (count > 0) {
        // if cluster contain points, adjust centroid position
        for (var dim = 0; dim < maxDim; dim++) {
          mean[dim] /= count;
        }
        this.centroids[centroidId] = mean;
      } else {
        // if cluster is empty, generate new random centroid
        this.centroids[centroidId] = this.randomCentroid();
        change = true;
      }
    }
  }

  return this.getClusters();
};

/**
 * Generate random centroid
 *
 * @returns {Array}
 */
KMEANS.prototype.randomCentroid = function() {
  var maxId = this.dataset.length -1;
  var centroid;
  var id;

  do {
    id = Math.round(Math.random() * maxId);
    centroid = this.dataset[id];
  } while (this.centroids.indexOf(centroid) >= 0);

  return centroid;
}

/**
 * Assign points to clusters
 *
 * @returns {boolean}
 */
KMEANS.prototype.assign = function() {
  var change = false;
  var len = this.dataset.length;
  var closestCentroid;

  for (var i = 0; i < len; i++) {
    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);

    if (closestCentroid != this.assignments[i]) {
      this.assignments[i] = closestCentroid;
      change = true;
    }
  }

  return change;
}

/**
 * Extract information about clusters
 *
 * @returns {undefined}
 */
KMEANS.prototype.getClusters = function() {
  var clusters = new Array(this.k);
  var centroidId;

  for (var pointId = 0; pointId < this.assignments.length; pointId++) {
    centroidId = this.assignments[pointId];

    // init empty cluster
    if (typeof clusters[centroidId] === 'undefined') {
      clusters[centroidId] = [];
    }

    clusters[centroidId].push(pointId);
  }

  return clusters;
};

// utils

/**
 * @params {Array} point
 * @params {Array.<Array>} set
 * @params {Function} f
 * @returns {number}
 */
KMEANS.prototype.argmin = function(point, set, f) {
  var min = Number.MAX_VALUE;
  var arg = 0;
  var len = set.length;
  var d;

  for (var i = 0; i < len; i++) {
    d = f(point, set[i]);
    if (d < min) {
      min = d;
      arg = i;
    }
  }

  return arg;
};

/**
 * Euclidean distance
 *
 * @params {number} p
 * @params {number} q
 * @returns {number}
 */
KMEANS.prototype.distance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    var diff = p[i] - q[i];
    sum += diff * diff;
  }

  return Math.sqrt(sum);
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = KMEANS;
}

/**
 * PriorityQueue
 * Elements in this queue are sorted according to their value
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * PriorityQueue class construcotr
 * @constructor
 *
 * @example
 * queue: [1,2,3,4]
 * priorities: [4,1,2,3]
 * > result = [1,4,2,3]
 *
 * @param {Array} elements
 * @param {Array} priorities
 * @param {string} sorting - asc / desc
 * @returns {PriorityQueue}
 */
function PriorityQueue(elements, priorities, sorting) {
  /** @type {Array} */
  this._queue = [];
  /** @type {Array} */
  this._priorities = [];
  /** @type {string} */
  this._sorting = 'desc';

  this._init(elements, priorities, sorting);
};

/**
 * Insert element
 *
 * @param {Object} ele
 * @param {Object} priority
 * @returns {undefined}
 * @access public
 */
PriorityQueue.prototype.insert = function(ele, priority) {
  var indexToInsert = this._queue.length;
  var index = indexToInsert;

  while (index--) {
    var priority2 = this._priorities[index];
    if (this._sorting === 'desc') {
      if (priority > priority2) {
        indexToInsert = index;
      }
    } else {
      if (priority < priority2) {
        indexToInsert = index;
      }
    }
  }

  this._insertAt(ele, priority, indexToInsert);
};

/**
 * Remove element
 *
 * @param {Object} ele
 * @returns {undefined}
 * @access public
 */
PriorityQueue.prototype.remove = function(ele) {
  var index = this._queue.length;

  while (index--) {
    var ele2 = this._queue[index];
    if (ele === ele2) {
      this._queue.splice(index, 1);
      this._priorities.splice(index, 1);
      break;
    }
  }
};

/**
 * For each loop wrapper
 *
 * @param {function} func
 * @returs {undefined}
 * @access public
 */
PriorityQueue.prototype.forEach = function(func) {
  this._queue.forEach(func);
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getElements = function() {
  return this._queue;
};

/**
 * @param {number} index
 * @returns {Object}
 * @access public
 */
PriorityQueue.prototype.getElementPriority = function(index) {
  return this._priorities[index];
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getPriorities = function() {
  return this._priorities;
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getElementsWithPriorities = function() {
  var result = [];

  for (var i = 0, l = this._queue.length; i < l; i++) {
    result.push([this._queue[i], this._priorities[i]]);
  }

  return result;
};

/**
 * Set object properties
 *
 * @param {Array} elements
 * @param {Array} priorities
 * @returns {undefined}
 * @access protected
 */
PriorityQueue.prototype._init = function(elements, priorities, sorting) {

  if (elements && priorities) {
    this._queue = [];
    this._priorities = [];

    if (elements.length !== priorities.length) {
      throw new Error('Arrays must have the same length');
    }

    for (var i = 0; i < elements.length; i++) {
      this.insert(elements[i], priorities[i]);
    }
  }

  if (sorting) {
    this._sorting = sorting;
  }
};

/**
 * Insert element at given position
 *
 * @param {Object} ele
 * @param {number} index
 * @returns {undefined}
 * @access protected
 */
PriorityQueue.prototype._insertAt = function(ele, priority, index) {
  if (this._queue.length === index) {
    this._queue.push(ele);
    this._priorities.push(priority);
  } else {
    this._queue.splice(index, 0, ele);
    this._priorities.splice(index, 0, priority);
  }
};



/**
 * OPTICS - Ordering points to identify the clustering structure
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * OPTICS class constructor
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {OPTICS}
 */
function OPTICS(dataset, epsilon, minPts, distanceFunction) {
  /** @type {number} */
  this.epsilon = 1;
  /** @type {number} */
  this.minPts = 1;
  /** @type {function} */
  this.distance = this._euclideanDistance;

  // temporary variables used during computation

  /** @type {Array} */
  this._reachability = [];
  /** @type {Array} */
  this._processed = [];
  /** @type {number} */
  this._coreDistance = 0;
  /** @type {Array} */
  this._orderedList = [];

  this._init(dataset, epsilon, minPts, distanceFunction);
}

/******************************************************************************/
// pulic functions

/**
 * Start clustering
 *
 * @param {Array} dataset
 * @returns {undefined}
 * @access public
 */
OPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
  this._init(dataset, epsilon, minPts, distanceFunction);

  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
    if (this._processed[pointId] !== 1) {
      this._processed[pointId] = 1;
      this.clusters.push([pointId]);
      var clusterId = this.clusters.length - 1;

      this._orderedList.push(pointId);
      var priorityQueue = new PriorityQueue(null, null, 'asc');
      var neighbors = this._regionQuery(pointId);

      // using priority queue assign elements to new cluster
      if (this._distanceToCore(pointId) !== undefined) {
        this._updateQueue(pointId, neighbors, priorityQueue);
        this._expandCluster(clusterId, priorityQueue);
      }
    }
  }

  return this.clusters;
};

/**
 * Generate reachability plot for all points
 *
 * @returns {array}
 * @access public
 */
OPTICS.prototype.getReachabilityPlot = function() {
  var reachabilityPlot = [];

  for (var i = 0, l = this._orderedList.length; i < l; i++) {
    var pointId = this._orderedList[i];
    var distance = this._reachability[pointId];

    reachabilityPlot.push([pointId, distance]);
  }

  return reachabilityPlot;
};

/******************************************************************************/
// protected functions

/**
 * Set object properties
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distance
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {

  if (dataset) {

    if (!(dataset instanceof Array)) {
      throw Error('Dataset must be of type array, ' +
        typeof dataset + ' given');
    }

    this.dataset = dataset;
    this.clusters = [];
    this._reachability = new Array(this.dataset.length);
    this._processed = new Array(this.dataset.length);
    this._coreDistance = 0;
    this._orderedList = [];
  }

  if (epsilon) {
    this.epsilon = epsilon;
  }

  if (minPts) {
    this.minPts = minPts;
  }

  if (distance) {
    this.distance = distance;
  }
};

/**
 * Update information in queue
 *
 * @param {number} pointId
 * @param {Array} neighbors
 * @param {PriorityQueue} queue
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
  var self = this;

  this._coreDistance = this._distanceToCore(pointId);
  neighbors.forEach(function(pointId2) {
    if (self._processed[pointId2] === undefined) {
      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);
      var newReachableDistance = Math.max(self._coreDistance, dist);

      if (self._reachability[pointId2] === undefined) {
        self._reachability[pointId2] = newReachableDistance;
        queue.insert(pointId2, newReachableDistance);
      } else {
        if (newReachableDistance < self._reachability[pointId2]) {
          self._reachability[pointId2] = newReachableDistance;
          queue.remove(pointId2);
          queue.insert(pointId2, newReachableDistance);
        }
      }
    }
  });
};

/**
 * Expand cluster
 *
 * @param {number} clusterId
 * @param {PriorityQueue} queue
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._expandCluster = function(clusterId, queue) {
  var queueElements = queue.getElements();

  for (var p = 0, l = queueElements.length; p < l; p++) {
    var pointId = queueElements[p];
    if (this._processed[pointId] === undefined) {
      var neighbors = this._regionQuery(pointId);
      this._processed[pointId] = 1;

      this.clusters[clusterId].push(pointId);
      this._orderedList.push(pointId);

      if (this._distanceToCore(pointId) !== undefined) {
        this._updateQueue(pointId, neighbors, queue);
        this._expandCluster(clusterId, queue);
      }
    }
  }
};

/**
 * Calculating distance to cluster core
 *
 * @param {number} pointId
 * @returns {number}
 * @access protected
 */
OPTICS.prototype._distanceToCore = function(pointId) {
  var l = this.epsilon;
  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
    var neighbors = this._regionQuery(pointId, coreDistCand);
    if (neighbors.length >= this.minPts) {
      return coreDistCand;
    }
  }

  return;
};

/**
 * Find all neighbors around given point
 *
 * @param {number} pointId
 * @param {number} epsilon
 * @returns {Array}
 * @access protected
 */
OPTICS.prototype._regionQuery = function(pointId, epsilon) {
  epsilon = epsilon || this.epsilon;
  var neighbors = [];

  for (var id = 0, l = this.dataset.length; id < l; id++) {
    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {
      neighbors.push(id);
    }
  }

  return neighbors;
};

/******************************************************************************/
// helpers

/**
 * Calculate euclidean distance in multidimensional space
 *
 * @param {Array} p
 * @param {Array} q
 * @returns {number}
 * @access protected
 */
OPTICS.prototype._euclideanDistance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    sum += (p[i] - q[i]) * (p[i] - q[i]);
  }

  return Math.sqrt(sum);
};

function Utils() {

}


KMEANS.prototype.getRandomVector = function(extremes) {
  var maxDim = extremes.length;
  var x = [];
  var r = 0;
  
  // calculate radius of n-sphere which covers all points in dataset
  var nSphereRadius = 0;
  for (var i = 0; i < maxDim; i++) {
    var extreme = extremes[i];
    var er = Math.max(extreme.center - extreme.min, extreme.center - extreme.max);
    if (er > nSphereRadius)
      nSphereRadius = er;
  }
  
  for (var i = 0; i < maxDim; i++) {
    var val = (Math.random() * 2) - 1;
    // adjust to radius of n-sphere
    x.push(val);
    r += val * val;
  }
      
  r = Math.sqrt(r);
  
  for (var i = 0; i < maxDim; i++) {
    x[i] /= r;
    // resize to fit n-sphere
    x[i] *= nSphereRadius;
    x[i] += extremes[i].center;
  }
  
  return x;
}


module.exports = {
      DBSCAN: DBSCAN,
      KMEANS: KMEANS,
      OPTICS: OPTICS,
      PriorityQueue: PriorityQueue
};
};
BundleModuleCode['plugins/ml/pre']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     8-2-16 by sbosse.
 **    $VERSION:     1.20.1X
 **
 **    $INFO:
 **
 **  JavaScript Machine Learning API: Data Preprocessing
 **
 **    $ENDOFINFO
 */

var Io = Require('com/io');
var Comp = Require('com/compat');
var _ = undefined;
var none = null;

var isArray   = Comp.obj.isArray,
    isNumber  = Comp.obj.isNumber,
    isObject  = Comp.obj.isObject,
    isMatrix  = Comp.obj.isMatrix;
/**
 * Computes Log with base-2
 * @private
 */
function log2(n) {
  return Math.log(n) / Math.log(2);
}

function obj2Array(row,features) {
  return features.map(function (attr) { return row[attr] });
}
function objSlice(row,features) {
  var o = {};
  features.forEach(function (attr) { o[attr]=row[attr] });
  return o;
}
function array2Object(row,features) {
  var result={};
  row.forEach(function (x,index) { result[features[index]]=x });
  return result;
}

// transform [v][] -> v[]
function relax(mat) {
  if (isMatrix(mat) && mat[0].length==1) return mat.map(function (row) { return row[0]})
  else return mat;
}

// transform v[] -> [v][]
function wrap(mat) {
  if (!isMatrix(mat)) return mat.map(function (v) { return [v]})
  else return mat
}

function Constructor(f, args) {
    return function() {
        f.apply(this, args);
    };
};

/* Common data transformation between different formats (X)
**
** 1a. need='xy':   data={$x:'a,$y:'b}[]    -> {x:{$x} [], y:'b[]}
** 1b. need='xy':   data=('a|'b)[][]        -> {x:'a [][], y:'b[]}
** 1b. need='xy':   data={input:[],output:[]}[]    -> {x:'a [][], y:'b[]}
** 1c. need='xry':  data=('a|'b)[][]        -> {x:{$x} [], y:'b[]}
** 1c. need='io':   data=number[][]         -> {input:number, output:number} []
** 1d. need='io':   data={$x:number,$y:number}[] -> {input:number [], output:number []} []
** 2. need='xmy':   data=number [][]    -> {x:'a [][], y:'b[]}
** 2b. need='xmy':   data={$x:'a,$y:'b}[]    -> {x:'a [][], y:'b[]}
** 3. need='d':     data={x:'a[][],y:'b[]}} -> {$x:'a,$y:'b}[]
** 4. need='dm':    data={x:'a[][],y;'b[]}  -> ('a|'b)[][]
** 5. need='m':     data={$x:'a}[]          -> 'a [][]
** 5b. need='m':     data={x:'a [],y:'a[]}[]          -> 'a [][]
** 6. need='a':     data={$x:'a}            -> 'a []
** 7. need='scale'  data='a []              -> 'a [] (features)
** 8. need='r':     data='a [][]            -> {$x:'a}[]
**
** typeof options = {
**   scale:   {k:number|number[], off:number|number[], shift:number|number[]} is transformation of input data,
**            | {}[] | [min,max] | 'auto',
**   xscale:  {k:number|number[], off:number|number[], shift:number|number[]} is transformation of input data,
**            | {}[] 
**   yscale:  {k:number|number[], off:number|number[], shift:number|number[]} is transformation of output data,
**            | {}[]
**   features : string [] | number [] is feature variable list,
**   target: string | number is output variable,
**   targets : number [] is output variables list,
**   labels: string [] // ANN: y-vector output mapping (one label == one y[0,1] vector //
**
**/

// Scale (compress) data
function scale(vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return scala.shift+(vrow-scala.off)*scala.k
    else if (scala.length)
      return scala[0].shift+(vrow-scala[0].off)*scala[0].k;
    else
      return scala.shift+(vrow-scala.off[0])*scala.k[0];
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off)*scala.k })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return scala[i].shift+(col-scala[i].off)*scala[i].k })
  else
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off[i])*scala.k[i] })
}
// Unscale (decompress) data
function unscale(vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return (vrow-scala.shift)/scala.k+scala.off
    else if (scala.length)
      return (vrow-scala[0].shift)/scala[0].k+scala[0].off
    else
      return (vrow-scala.shift)/scala.k[0]+scala.off[0]
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return (col-scala.shift)/scala.k+scala.off })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return (col-scala[i].shift)/scala[i].k+scala[i].off })  
  else
    return vrow.map(function (col,i) { 
      return (vrow-scala.shift)/scala.k[i]+scala.off[i] })  
}

// [a,b] auto scaler of data tables
function autoScale(data,features,shift) {
  var min=[],
      max=[],
      row=data[0];
  if (Comp.obj.isArray(row)) {
    for(var i=0;i<data.length;i++) {
      row=data[i];
      for(var j=0;j<row.length;j++) {
        if (min[j]==undefined) min[j]=row[j]; else min[j]=Math.min(row[j],min[j]);
        if (max[j]==undefined) max[j]=row[j]; else max[j]=Math.max(row[j],max[j]);
      }  
    }
  } else if (Comp.obj.isObj(row)) {
    if (!features) features=Object.keys(row);
    for(var i=0;i<data.length;i++) {
      row=data[i];
      for(var j=0;j<features.length;j++) {
        if (min[j]==undefined) min[j]=row[features[j]]; else min[j]=Math.min(row[features[j]],min[j]);
        if (max[j]==undefined) max[j]=row[features[j]]; else max[j]=Math.max(row[features[j]],max[j]);
      }  
    }    
  } 
  
  shift=shift||0;
  if (min.length==1)
  return {
      k:(1-shift)/(max[0]-min[0]),
      off:min[0],
      shift:shift,
      min:min[0],
      max:max[0]
  }
  else
  return {
      k:min.map(function (a,i) { var b=max[i]; return (1-shift)/(b-a)}),
      off:min,
      shift:shift,
      min:min,
      max:max
  }
}

function toScale(min,max,lower,upper) {
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  if (typeof min == 'number')
  return {
      k:(upper-lower)/(max-min),
      off:min,
      shift:lower,
      min:min,
      max:max
  }
  else if (min.length==1)
  return {
      k:(upper-lower)/(max[0]-min[0]),
      off:min[0],
      shift:lower,
      min:min[0],
      max:max[0]
  }
  else
  return {
      k:min.map(function (a,i) { var b=max[i]; return (upper-lower)/(b-a)}),
      off:min,
      shift:lower,
      min:min,
      max:max
  }
}
function preprocess(data,need,options) {
  var row,x,y,_data;
  options=options||{};
  var scala=options.scale || options.xscale, scalaY;
  // wrap array
  function array(data) {
    return isArray(data)?data:[data]
  } 
  // map categorical variable on numeric vector (one element for each label)  
  function map(data,labels,bipolar) {
    return labels.map(function (x) {
      if (data==x) return 1;
      else return bipolar?-1:0;
    })
  }
  function scalemat(mat,scala) {
    if (!scala) return mat;
    return mat.map(function (row) { return scale(row,scala) });
  }
  // TODO: options.targets
  
  if (isArray(data)) {
    row=data[0];
    switch (need) {
      case 'xy':
      case 'xry':
        if ((options.target||options.targets)!=undefined && options.features!=undefined) {
          if (isArray(row) && need=='xy') {
            if (Number(options.target)==row.length-1) {
              x=data.map(function (row) { return scale(row.slice(0,options.target),scala) });
              y=data.map(function (row) { return row[options.target] })
            }
          } else  if (isObject(row)) {
            if (typeof options.target == 'string') {
              x=data.map(function (row) { return scale(objSlice(row,options.features),scala) });
              y=data.map(function (row) { return row[options.target] });
            }
          }
        } else if (row.input && row.output) {
          x=data.map(function (row) { return row.input });
          y=data.map(function (row) { return row.output });
        }
        if (x && y) return {x:x,y:y}
        break;
      case 'a':
        if (isArray(data) && typeof data[0] != 'object') return {data:data};  
        if (isObject(data) && options.features!=undefined) {
          return { data:data.map(function (row) { 
                    return scale(objSlice(row,options.features),scala) })};
        }
        break;
      case 'm':
        if (isArray(row.x) && isArry(row.y)) {
          return { data:data.map(function (row) { 
                    return scale(row.x,scala).concat(scale(row.y,options.yscale)) })};                  
        }
        if (isMatrix(data) && !scala) return {data:data};
        else if (isMatrix(data) && !options.features) {
          // just scale data
          return { data:data.map(function (row) { 
                    return scale(row,scala) })};        
        } 
        if (isObject(row)) {
          if (!options.features) options.features=Object.keys(data[0]);
          return { data:data.map(function (row) { 
                    return scale(obj2Array(row,options.features),scala) })};
        }
       break;  
      case 'r':
       if (!isArray(row) && isObject(row)) return {data:data};
        if (isArray(row)) {
          if (!options.features) options.features=row.map(function (x,i) { return String(i) });
          return { data:data.map(function (row) { 
                    return scale(array2Object(row,options.features),scala) })};
        }
       break;  
      case 'xmy':
        if (isObject(row) && options.features!=undefined && (options.target||options.targets)!=undefined) {
          return isObject(options.target)?
                 { x:data.map(function (row) { 
                      return scale(obj2Array(row,options.features),scala) }),
                   y:data.map(function (row) { return scale(obj2Array(row,options.target),options.yscale)})}:
                 { x:data.map(function (row) { 
                      return scale(obj2Array(row,options.features),scala) }),
                   y:data.map(function (row) { return scale(row[options.target],options.yscale)})};
       }
       break;  
      case 'io':
        if (isArray(row) && (options.target||options.targets)!=undefined) {
          // number [][] 
          if (scala=='auto') scala=autoScale(data,null);
          if (Number(options.target)==row.length-1) {
            _data=data.map(function (row) { return { input :scale(row.slice(0,options.target),scala),
                                                     output:scale(array(row[options.target]),options.yscale) }});
            return _data
          } else {
            _data=data.map(function (row) { return { input :scale(obj2Array(row,options.features),scala),
                                                     output:options.targets?
                                                            scale(array(obj2Array(row,options.targets)),options.yscale) 
                                                            :
                                                            scale(array(row[options.target]),options.yscale) }});
            return _data          
          }
        } else if (isArray(row.x) && isArray(row.y)) {
          return data.map(function (row) {
                  return { input:scale(row.x,scala),
                           output:scale(row.y,options.yscale) }});       
        } else if (isObject(row) && !row.input && (options.target||options.targets)!=undefined && options.features!=undefined) {
          if (scala=='auto') scala=autoScale(data,options.features);
          _data=data.map(function (row) { return { input :scale(obj2Array(row,options.features),scala),
                                                   output:options.labels?
                                                          map(array(row[options.target]),options.labels)
                                                          :
                                                          options.targets?
                                                          scale(array(obj2Array(row,options.targets)),options.yscale) 
                                                          :
                                                          scale(array(row[options.target]),options.yscale) }});
          return _data
        } else if (row.input && row.output) {
          if (scala) {
            if (scala=='auto') scala=autoScale(data.input,null);
            _data=data.map(function (row) { return { input :scale(row.input,scala),
                                                   output:scale(row.output,options.yscale) }});
            return _data          
          } else return data;  // { input:number [], output: number [] } []
        } 
        break;
      case 'scale':
        if (isArray(row) && options.scale!=undefined) {
          if (options.features)
            return data.map(function (row) { return scale(obj2Array(row,options.features),options.scale) })
          else      
            return data.map(function (row) { return scale(row,options.scale) })
        }
    }
  } else if (data.x && data.y) {
    if (isArray(data.x) && isArray(data.y)) {
      row=data.x[0];
      if (scala=='auto') {
        scala=autoScale(data.x,null);
        scalaY=autoScale(data.y,null);
      } else scalaY=options.yscale;
      switch (need) {
        case 'io':
        if (isArray(row)) {
          // x:number [][] 
          _data=data.x.map(function (row, rowi) { return { input:scale(row,scala),
                                                           output:array(data.y[rowi]) }});
          return _data          
        } else if (isNumber(row)) {
          // x: number []
          _data=data.x.map(function (row, rowi) { return { input:scale(array(row),scala),
                                                           output:array(data.y[rowi]) }});        
          return _data          
        }
        if (isObject(row) && options.features!=undefined) {
          // x: {}

          _data=data.x.map(function (row, rowi) { return { input:scale(obj2Array(row,options.features),scala),
                                                           output:array(data.y[rowi]) }});
          return _data          
        }
        break;
        case 'xm':
          if (isArray(row)) return data.x;
          break;
        case 'xmy':
          if (isArray(row)) return { x:scalemat(data.x,scala), y:scalemat(data.y,scalaY||options.yscale||scala)};
          break;
        case 'xmya':
          if (isArray(row)) return { x:data.x, y:data.y.map(array)};
          break;
        case 'd':
          return data.x.map(function (row,rowi) {
            var newrow={};
            if (options.features && options.target) {
              options.features.forEach(function (f,coli) {
                newrow[f]=row[coli];
              });
              newrow[options.target]=data.y[rowi];
            } else {
              row.forEach(function (col,f) {
                newrow[String(f)]=col;                
              });
              newrow[String(row.length)]=data.y[rowi];
            }
            return newrow;
          })
          break;
      } 
    }   
  }
}

// randomly split data table in two paritions (e.g., training/test)
// function ([],nuµber,number) -> [partA [],partB [],?indexmapA [],?indexmapB []]
function split (data,partA,partB,withmap) {
  var A=[],B=[],mapA=[],mapB=[],index;
  if (partA==undefined) throw "ML.split: missing partA size";
  if (partB==undefined) { partB=data.length-partA };
  if (data.length < (partA+partB)) throw new Error('EINVALID');
  function shuffle(array) {
    var m = array.length, t, i;
    // While there remain elements to shuffle\u2026
    while (m) {
      // Pick a remaining element\u2026
      i = Math.floor(Math.random() * m--);
      // And swap it with the current element.
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }
    return array;
  }
  index=Array(data.length).fill().map(function (x,i) { return i });
  index=shuffle(index);
  for(var i=0;i<partA;i++) {
    A.push(data[index[i]]);
    mapA.push(index[i]);
  }
  for(var j=0;j<partB;j++) {
    B.push(data[index[i+j]]);
    mapB.push(index[i+j]);
  }
  return withmap?[A,B,mapA,mapB]:[A,B]
}

module.exports = {
  array2Object:array2Object,
  autoScale:autoScale,
  obj2Array:obj2Array,
  objSlice:objSlice,
  preprocess:preprocess,
  relax:relax,
  scale:scale,
  split:split,
  toScale:toScale,
  unscale:unscale,
  wrap:wrap,
}
};
BundleModuleCode['plugins/ml/sa']=function (module,exports){
// @justyy
// https://github.com/DoctorLai/simulated_annealling

var SimulatedAnnealing = function (options, generateNewSolution, generateNeighbor, acceptNeighbor) {
	// Set Parameters
    var coolingFactor            = options.coolingFactor || 0.05;
    var stabilizingFactor        = options.stabilizingFactor || 1.005;
    var freezingTemperature      = options.freezingTemperature || 0.001;
    var currentSystemTemperature = options.initialTemperature || 20;
    var curStabilizor            = options.initialStabilizer || 35;    

    // Init solution
    var currentSysEnergy         = generateNewSolution();

    // Probability Function
    // Higher Temperature means more likely to accept worse solutions, and vice versa
    var Prob = function (t, d) {
	    if (d < 0) {
	        return true;
	    }
	    var C = Math.exp(-d / t);
	    var R = Math.random();
	    return (R < C);
    }

    // One Iteration of Process and Return: Should we Continue?
    var _Do = function ()  {
	    if (currentSystemTemperature > freezingTemperature) {
	        for (var i = 0; i < curStabilizor; ++ i) {
	            var newEnergy = generateNeighbor(),
	                energyDelta = newEnergy - currentSysEnergy;

	            if (Prob(currentSystemTemperature, energyDelta)) {
	                // accept this neighbour 
	                acceptNeighbor();
	                // update energey
	                currentSysEnergy = newEnergy;
	            }
	        }
	        // temperature is cooling down
	        currentSystemTemperature = currentSystemTemperature - coolingFactor;
	        // so it is less likely to accept worse solutions
	        curStabilizor = curStabilizor * stabilizingFactor;
	        return true;
	    }
    	currentSystemTemperature = freezingTemperature;
    	return false;	    
	}

	// Get Current System Energy
	var _GetCurrentEnergy = function () {
		return currentSysEnergy;
	}

	// Get Current Temperature
	var _GetCurrentTemperature = () => {
		return currentSystemTemperature;
	}

	// Export Methods
	return {
		Do: function() {
			return _Do();
		},

		GetCurrentEnergy: function() {
			return _GetCurrentEnergy();
		},

		GetCurrentTemperature: function() {
			return _GetCurrentTemperature();
		}
	}
}

// module exports the Simulated Annealing Object
module.exports = { 
	SimulatedAnnealing : SimulatedAnnealing
} 
};
BundleModuleCode['plugins/ml/helpers']=function (module,exports){
//     wink-helpers
//     Functions for cross validation, shuffle, cartesian product and more
//
//     https://github.com/winkjs/wink-helpers
//
//     Copyright (C) 2017-18  GRAYPE Systems Private Limited
//
//     This file is part of “wink-helpers”.
//
//     Permission is hereby granted, free of charge, to any person obtaining a
//     copy of this software and associated documentation files (the "Software"),
//     to deal in the Software without restriction, including without limitation
//     the rights to use, copy, modify, merge, publish, distribute, sublicense,
//     and/or sell copies of the Software, and to permit persons to whom the
//     Software is furnished to do so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included
//     in all copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//     DEALINGS IN THE SOFTWARE.

//
var helpers = Object.create( null );

// ### Private Functions

// #### Product Reducer (Callback)

// Callback function used by `reduce` inside the `product()` function.
// Follows the standard guidelines of `reduce()` callback function.
var productReducer = function ( prev, curr ) {
  var c,
      cmax = curr.length;
  var p,
      pmax = prev.length;
  var result = [];

  for ( p = 0; p < pmax; p += 1 ) {
    for ( c = 0; c < cmax; c += 1 ) {
      result.push( prev[ p ].concat( curr[ c ] ) );
    }
  }
  return ( result );
}; // productReducer()

// ### Public Function

// ### Array Helpers

helpers.array = Object.create( null);

// #### is Array

// Tests if argument `v` is a JS array; returns `true` if it is, otherwise returns `false`.
helpers.array.isArray = function ( v ) {
  return ( ( v !== undefined ) && ( v !== null ) && ( Object.prototype.toString.call( v ) === '[object Array]' ) );
}; // isArray()


// #### sorting helpers

// Set of helpers to sort either numbers or strings. For key/value pairs,
// the format for each element must be `[ key, value ]`.
// Sort helper to sort an array in ascending order.
helpers.array.ascending = function ( a, b ) {
  return ( a > b ) ? 1 :
            ( a === b ) ? 0 : -1;
}; // ascending()

// Sort helper to sort an array in descending order.
helpers.array.descending = function ( a, b ) {
  return ( b > a ) ? 1 :
            ( b === a ) ? 0 : -1;
}; // descending()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **key**.
helpers.array.ascendingOnKey = function ( a, b ) {
  return ( a[ 0 ] > b[ 0 ] ) ? 1 :
            ( a[ 0 ] === b[ 0 ] ) ? 0 : -1;
}; // ascendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in descending order by **key**.
helpers.array.descendingOnKey = function ( a, b ) {
  return ( b[ 0 ] > a[ 0 ] ) ? 1 :
            ( b[ 0 ] === a[ 0 ] ) ? 0 : -1;
}; // descendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **value**.
helpers.array.ascendingOnValue = function ( a, b ) {
  return ( a[ 1 ] > b[ 1 ] ) ? 1 :
            ( a[ 1 ] === b[ 1 ] ) ? 0 : -1;
}; // ascendingOnValue()

// Sort helper to sort an array of `[ key, value ]` in descending order by **value**.
helpers.array.descendingOnValue = function ( a, b ) {
  return ( b[ 1 ] > a[ 1 ] ) ? 1 :
            ( b[ 1 ] === a[ 1 ] ) ? 0 : -1;
}; // descendingOnValue()

// The following two functions generate a suitable function for sorting on a single
// key or on a composite keys (max 2 only). Just a remider, the generated function
// does not sort on two keys; instead it will sort on a key composed of the two
// accessors.
// Sorts in ascending order on `accessor1` & `accessor2` (optional).
helpers.array.ascendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( a[ accessor1 ][ accessor2 ] > b[ accessor1 ][ accessor2 ] ) ? 1 :
              ( a[ accessor1 ][ accessor2 ] === b[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( a[ accessor1 ] > b[ accessor1 ] ) ? 1 :
            ( a[ accessor1 ] === b[ accessor1 ] ) ? 0 : -1;
  } );
}; // ascendingOn()

// Sorts in descending order on `accessor1` & `accessor2` (optional).
helpers.array.descendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( b[ accessor1 ][ accessor2 ] > a[ accessor1 ][ accessor2 ] ) ? 1 :
              ( b[ accessor1 ][ accessor2 ] === a[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( b[ accessor1 ] > a[ accessor1 ] ) ? 1 :
            ( b[ accessor1 ] === a[ accessor1 ] ) ? 0 : -1;
  } );
}; // descendingOn()

// #### pluck

// Plucks specified element from each element of an **array of array**, and
// returns the resultant array. The element is specified by `i` (default `0`) and
// number of elements to pluck are defined by `limit` (default `a.length`).
helpers.array.pluck = function ( a, key, limit ) {
  var k, plucked;
  k = a.length;
  var i = key || 0;
  var lim = limit || k;
  if ( lim > k ) lim = k;
  plucked = new Array( lim );
  for ( k = 0; k < lim; k += 1 ) plucked[ k ] = a[ k ][ i ];
  return plucked;
}; // pluck()

// #### product

// Finds the Cartesian Product of arrays present inside the array `a`. Therefore
// the array `a` must be an array of 1-dimensional arrays. For example,
// `product( [ [ 9, 8 ], [ 1, 2 ] ] )`
// will produce `[ [ 9, 1 ], [ 9, 2 ], [ 8, 1 ], [ 8, 2 ] ]`.
helpers.array.product = function ( a ) {
  return (
    a.reduce( productReducer, [ [] ] )
  );
};

// #### shuffle

// Randomly shuffles the elements of an array and returns the same.
// Reference: Chapter on Random Numbers/Shuffling in Seminumerical algorithms.
// The Art of Computer Programming Volume II by Donald E Kunth
helpers.array.shuffle = function ( array ) {
  var a = array;
  var balance = a.length;
  var candidate;
  var temp;

  while ( balance ) {
    candidate = Math.floor( Math.random() * balance );
    balance -= 1;

    temp = a[ balance ];
    a[ balance ] = a[ candidate ];
    a[ candidate ] = temp;
  }

  return ( a );
};


// ### Object Helpers

var objectKeys = Object.keys;
var objectCreate = Object.create;

helpers.object = Object.create( null );

// #### is Object

// Tests if argument `v` is a JS object; returns `true` if it is, otherwise returns `false`.
helpers.object.isObject = function ( v ) {
  return ( v && ( Object.prototype.toString.call( v ) === '[object Object]' ) ) ? true : false; // eslint-disable-line no-unneeded-ternary

}; // isObject()

// #### keys

// Returns keys of the `obj` in an array.
helpers.object.keys = function ( obj ) {
  return ( objectKeys( obj ) );
}; // keys()

// #### size

// Returns the number of keys of the `obj`.
helpers.object.size = function ( obj ) {
  return ( ( objectKeys( obj ) ).length );
}; // size()

// #### values

// Returns all values from each key/value pair of the `obj` in an array.
helpers.object.values = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var values = new Array( length );
  for ( var i = 0; i < length; i += 1 ) {
    values[ i ] = obj[ keys[ i ] ];
  }
  return values;
}; // values()

// #### value Freq

// Returns the frequency of each unique value present in the `obj`, where the
// **key** is the *value* and **value** is the *frequency*.
helpers.object.valueFreq = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var val;
  var vf = objectCreate( null );
  for ( var i = 0; i < length; i += 1 ) {
    val = obj[ keys[ i ] ];
    vf[ val ] = 1 + ( vf[ val ] || 0 );
  }
  return vf;
}; // valueFreq()

// #### table

// Converts the `obj` in to an array of `[ key, value ]` pairs in form of a table.
// Second argument - `f` is optional and it is a function, which is called with
// each `value`.
helpers.object.table = function ( obj, f ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var pairs = new Array( length );
  var ak, av;
  for ( var i = 0; i < length; i += 1 ) {
    ak = keys[ i ];
    av = obj[ ak ];
    if ( typeof f === 'function' ) f( av );
    pairs[ i ] = [ ak, av ];
  }
  return pairs;
}; // table()

// ### Validation Helpers

helpers.validate = Object.create( null );

// Create aliases for isObject and isArray.
helpers.validate.isObject = helpers.object.isObject;
helpers.validate.isArray = helpers.array.isArray;

// #### isFiniteInteger

// Validates if `n` is a finite integer.
helpers.validate.isFiniteInteger = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n ) &&
    ( n === Math.round( n ) )
  );
}; // isFiniteInteger()

// #### isFiniteNumber

// Validates if `n` is a valid number.
helpers.validate.isFiniteNumber = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n )
  );
}; // isFiniteNumber()

// ### cross validation
/**
 *
 * Creates an instance of cross validator useful for machine learning tasks.
 *
 * @param {string[]} classLabels - array containing all the class labels.
 * @return {methods} object conatining set of API methods for tasks like evalutaion,
 * reset and metrics generation.
*/
helpers.validate.cross = function ( classLabels ) {
  // wink's const for unknown predictions!
  const unknown = 'unknown';
  // To ensure that metrics is not computed prior to evaluation.
  var evaluated = false;
  // The confusion matrix.
  var cm;
  var precision;
  var recall;
  var fmeasure;

  // The class labels is assigned to this variable.
  var labels;
  // The length of `labels` array.
  var labelCount;
  var labelsObj = Object.create( null );

  // Returned!
  var methods = Object.create( null );


  /**
   *
   * Resets the current instance for another round of evaluation; the class
   * labels defined at instance creation time are not touched.
   *
   * @return {undefined} nothing!
  */
  var reset = function ( ) {
    evaluated = false;
    cm = Object.create( null );
    precision = Object.create( null );
    recall = Object.create( null );
    fmeasure = Object.create( null );

    // Initialize confusion matrix and metrics.
    for ( var i = 0; i < labelCount; i += 1 ) {
      const row = labels[ i ];
      labelsObj[ row ] = true;
      cm[ row ] = Object.create( null );
      precision[ row ] = 0;
      recall[ row ] = 0;
      fmeasure[ row ] = 0;
      for ( var j = 0; j < labelCount; j += 1 ) {
        const col = labels[ j ];
        cm[ row ][ col ] = 0;
      }
    }
  }; // reset()

  /**
   *
   * Creates an instance of cross validator useful for machine learning tasks.
   *
   * @param {string} truth - the actual class label.
   * @param {string} guess - the predicted class label.
   * @return {boolean} returns true if the evaluation is successful. The evaluation
   * may fail if `truth` or `guess` is not in the array `classLabels` provided at
   * instance creation time; or if guess is equal to `unknown`.
  */
  var evaluate = function ( truth, guess ) {
    // If prediction failed then return false!
    if ( guess === unknown || !labelsObj[ truth ] || !labelsObj[ guess ] ) return false;
    // Update confusion matrix.
    if ( guess === truth ) {
      cm[ truth ][ guess ] += 1;
    } else {
      cm[ guess ][ truth ] += 1;
    }
    evaluated = true;
    return true;
  }; // evaluate()

  /**
   *
   * It computes a detailed metrics consisting of macro-averaged precision,
   * recall and f-measure along with their label-wise values and the confusion
   * matrix.
   *
   * @return {object} object containing macro-averaged `avgPrecision`, `avgRecall`,
   * `avgFMeasure` values along with other details such as label-wise values
   * and the confusion matrix. A value of `null` is returned if no evaluate()
   * has been called before.
  */
  var metrics = function ( ) {
    if ( !evaluated ) return null;
    // Numerators for every label; they are same for precision & recall both.
    var n = Object.create( null );
    // Only denominators differs for precision & recall
    var pd = Object.create( null );
    var rd = Object.create( null );
    // `row` and `col` of confusion matrix.
    var col, row;
    var i, j;
    // Macro average values for metrics.
    var avgPrecision = 0;
    var avgRecall = 0;
    var avgFMeasure = 0;

    // Compute label-wise numerators & denominators!
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      for ( j = 0; j < labelCount; j += 1 ) {
        col = labels[ j ];
        if ( row === col ) {
          n[ row ] = cm[ row ][ col ];
        }
        pd[ row ] = cm[ row ][ col ] + ( pd[ row ] || 0 );
        rd[ row ] = cm[ col ][ row ] + ( rd[ row ] || 0 );
      }
    }
    // Ready to compute metrics.
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      precision[ row ] = +( n[ row ] / pd[ row ] ).toFixed( 4 );
      // NaN can occur if a label has not been encountered.
      if ( isNaN( precision[ row ] ) ) precision[ row ] = 0;

      recall[ row ] = +( n[ row ] / rd[ row ] ).toFixed( 4 );
      if ( isNaN( recall[ row ] ) ) recall[ row ] = 0;

      fmeasure[ row ] = +( 2 * precision[ row ] * recall[ row ] / ( precision[ row ] + recall[ row ] ) ).toFixed( 4 );
      if ( isNaN( fmeasure[ row ] ) ) fmeasure[ row ] = 0;
    }
    // Compute thier averages, note they will be macro avegages.
    for ( i = 0; i < labelCount; i += 1 ) {
      avgPrecision += ( precision[ labels[ i ] ] / labelCount );
      avgRecall += ( recall[ labels[ i ] ] / labelCount );
      avgFMeasure += ( fmeasure[ labels[ i ] ] / labelCount );
    }
    // Return metrics.
    return (
      {
        // Macro-averaged metrics.
        avgPrecision: +avgPrecision.toFixed( 4 ),
        avgRecall: +avgRecall.toFixed( 4 ),
        avgFMeasure: +avgFMeasure.toFixed( 4 ),
        details: {
          // Confusion Matrix.
          confusionMatrix: cm,
          // Label wise metrics details, from those averages were computed.
          precision: precision,
          recall: recall,
          fmeasure: fmeasure
        }
      }
    );
  }; // metrics()

  if ( !helpers.validate.isArray( classLabels ) ) {
    throw Error( 'cross validate: class labels must be an array.' );
  }
  if ( classLabels.length < 2 ) {
    throw Error( 'cross validate: at least 2 class labels are required.' );
  }
  labels = classLabels;
  labelCount = labels.length;

  reset();

  methods.reset = reset;
  methods.evaluate = evaluate;
  methods.metrics = metrics;

  return methods;
}; // cross()

// ### Object Helpers

helpers.string = Object.create( null );

// Regex for [diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) removal.
var rgxDiacritical = /[\u0300-\u036f]/g;

/**
 *
 * Normalizes the token's value by converting it to lower case and stripping
 * the diacritical marks (if any).
 *
 * @param {string} str — that needs to be normalized.
 * @return {string} the normalized value.
 * @example
 * normalize( 'Nestlé' );
 * // -> nestle
*/
helpers.string.normalize = function ( str ) {
  return (
    str.toLowerCase().normalize( 'NFD' ).replace( rgxDiacritical, '' )
  );
}; // normalize()

helpers.getOptions = function (options,selected) {
  var options2 = {}
  selected.forEach(function (opt) { options2[opt]=options[opt] })
  return options2;
}
helpers.updateOptions = function (options,update) {
  for(var p in options) if (update[p]!=undefined) options[p]=update[p];
  return options;
}
module.exports = helpers;
};
BundleModuleCode['aux/sprintf.js']=function (module,exports){
/* global window, exports, define */

function SprintfInit () {
    'use strict'

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxXC])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case 'C':
                        for (var ci=0;ci<ph.width;ci++) output += arg;
                        continue;
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8)
                        break
                    case 's':
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 't':
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                        break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16)
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%')
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (typeof exports !== 'undefined') {
        exports['sprintf'] = sprintf
        exports['vsprintf'] = vsprintf
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf
        window['vsprintf'] = vsprintf

        if (typeof define === 'function' && define['amd']) {
            define(function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                }
            })
        }
    }
    /* eslint-enable quote-props */
    return sprintf
}
SprintfInit(); 
};
BundleModuleCode['parser/esprima.js']=function (module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;};
BundleModuleCode['plugins/numpy/numpy']=function (module,exports){
/* NUMPY Binary File Reader and Writer

Format Specification: Version 1.0

The first 6 bytes are a magic string: exactly \u201cx93NUMPY\u201d.

The next 1 byte is an unsigned byte: the major version number of the file format, e.g. x01.

The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. x00. Note: the version of the file format is not tied to the version of the numpy package.

The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.

The next HEADER_LEN bytes form the header data describing the array\u2019s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (\u2018n\u2019) and padded with spaces (\u2018x20\u2019) to make the total length of the magic string + 4 + HEADER_LEN be evenly divisible by 16 for alignment purposes.

The dictionary contains three keys:

    \u201cdescr\u201d : dtype.descr
        An object that can be passed as an argument to the numpy.dtype() constructor to create the array\u2019s dtype.
    \u201cfortran_order\u201d : bool
        Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous arrays are a common form of non-C-contiguity, we allow them to be written directly to disk for efficiency.
    \u201cshape\u201d : tuple of int
        The shape of the array.

For repeatability and readability, this dictionary is formatted using pprint.pformat() so the keys are in alphabetic order.

Following the header comes the array data. If the dtype contains Python objects (i.e. dtype.hasobject is True), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on fortran_order) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that shape=() means there is 1 element) by dtype.itemsize.

*/

var fs = require('fs');

// read numpy array from file
function read(path,to) {
  var buf = fs.readFileSync(path),data;
  var array = {
    magic : buf.toString('utf8',0,6),
    major : buf.readUInt8(6),
    minor : buf.readUInt8(7),
    headerLength : buf.readInt16LE(8),
  }
  var desc = buf.toString('utf8',10,10+array.headerLength);
  desc=desc.replace(/'shape'[ ]*:/,'shape:Tuple');
  with({
    False:false,
    Tuple:function () {
      return Array.from(arguments)
    }}) { eval('array.dict = '+desc) };
  array.dataspace=array.dict.shape;
  switch (array.dict.descr) {
    case '<i2':
      array.datatype='Int16';
      data=buf.slice(10+array.headerLength);
      array.data=new Int16Array(new Uint8Array(data).buffer);
      break;
   case '<i4':
      array.datatype='Int32';
      data=buf.slice(10+array.headerLength);
      array.data=new Int32Array(new Uint8Array(data).buffer);
      break;
   case '<f4':
      array.datatype='Float32';
      data=buf.slice(10+array.headerLength);
      array.data=new Float32Array(new Uint8Array(data).buffer);
      break;
   case '<f8':
      array.datatype='Float64';
      data=buf.slice(10+array.headerLength);
      array.data=new Float64Array(new Uint8Array(data).buffer);
      break;
  }
  switch (to) {
    case 'MatrixTA':
    default:
      if (Math.MatrixTA)
        return Math.MatrixTA({data:array.data,dataspace:array.dataspace,datatype:array.datatype});
      else
        return array;
      break;
      
  }
  return array;
}

// write numpy array to file 
// typeof @options = { datatype?:string }

function write(path,data,options) {
  options=options||{};
  function info (data,levels) {
    var buf,dataspace,datatype,header;
    dataspace=[];
    if (data.levels || levels) dataspace.push(data.levels||levels);
    if (data.rows!=1) dataspace.push(data.rows);
    dataspace.push(data.columns);
    datatype=data.dtn;
    header = {
      magic : String.fromCharCode(0x93)+'NUMPY',
      major : 1,
      minor : 0,
      dict : {
        fortran_order: 'False',
        shape : '('+dataspace.join(',')+')',
      }
    }
    switch (datatype) {
        case 'Int16Array': header.dict.descr='<i2'; break;
        case 'Int32Array': header.dict.descr='<i4'; break;
        case 'Float32Array': header.dict.descr='<f4'; break;
        case 'Float64Array': header.dict.descr='<f8'; break;
    }
    var s="{'descr': '"+header.dict.descr+"', "+
          "'fortran_order': "+header.dict.fortran_order+", "+
          "'shape': "+header.dict.shape+", }";
    header.string=s;
    header.headerLength=s.length;
    return header 
  }
  
  if (Utils.isArray(data) && Math.MatrixTA && Math.MatrixTA.isMatrix(data[0])) {
    // Array of Typedarrays (MatrixTA)
    var buf;
    var header=info(data[0],data.length);
    buf=Buffer(10+header.headerLength+data[0].data.byteLength*data.length);
    buf.write(header.magic,0,'ascii');
    buf.writeUInt8(header.major,6);
    buf.writeUInt8(header.minor,7);
    buf.writeInt16LE(header.headerLength,8);
    buf.write(header.string,10,'ascii');
    var off=10+header.headerLength;
    data.forEach(function (mat,index) {
      Buffer(mat.data.buffer).copy(buf,off);
      off += mat.data.byteLength;
    });
    return fs.writeFileSync(path,buf);    
  } else if (Math.MatrixTA && Math.MatrixTA.isMatrix(data)) {
    // Typed arrays
    var buf;
    var header=info(data);
    buf=Buffer(10+header.headerLength+data.data.byteLength);
    buf.write(header.magic,0,'ascii');
    buf.writeUInt8(header.major,6);
    buf.writeUInt8(header.minor,7);
    buf.writeInt16LE(header.headerLength,8);
    buf.write(header.string,10,'ascii');
    Buffer(data.data.buffer).copy(buf,10+header.headerLength);
    return fs.writeFileSync(path,buf);
  } else if ((Math.MatrixTA && Math.Matrix && Math.Matrix.isMatrix(data)) ||
             (Math.MatrixTA && Utils.isArrayArray(data))) {
    // Generic arrays; must be converted on-the-fly to packed typed arrays
    var buf,byteLength;
    var datatype=options.datatype||'Float64';
    var _data = Math.MatrixTA(Utils.isArrayArray(data)?data:data.data,{datatype:datatype});
    var header=info(_data);
    buf=Buffer(10+header.headerLength+_data.data.byteLength);
    buf.write(header.magic,0,'ascii');
    buf.writeUInt8(header.major,6);
    buf.writeUInt8(header.minor,7);
    buf.writeInt16LE(header.headerLength,8);
    buf.write(header.string,10,'ascii');
    Buffer(_data.data.buffer).copy(buf,10+header.headerLength);
    return fs.writeFileSync(path,buf);
  } else throw "numpy.write: unspported data format";
}

module.exports = {
  read:read,
  write:write
}
};
BundleModuleCode['plugins/com/worker.js']=function (module,exports){

/** Workers for nodejs/worksh with IPC! - server side
**  Version 1: Processes
**  Each worker is processed in a separate process (so eeach worker can consume full nodejs heap memory limit)
**  New: Worker process synchronisation (blocking) now only with await statement!
**
**  Next Version 2: Threads
**  process.binding('config').experimentalWorker=true; worker_threads, SM2: SharedArrayBuffer
*/

var fork    = require('child_process').fork;

var program = process.argv[0],
    shell   = process.argv[1],
    arguments = process.argv.slice(1);

Channel = {
  channelID:0,
  channels:[],
  create : function () {
    var id = Channel.channelID++;
    var chan = {
      waiters : [],
      handlers : {},
      queue : [],
      id : id,
      cancel : function () {
        this.waiters.forEach(function (waiter) {
          waiter();
        })
        this.waiters=[];
      },
      enqueue: function (data) {
        if (this.queue.length==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else this.queue.push(data);
      },
      on : function (ev,handler) { this.handlers[ev]=handler },
      send: function (data) {
        if (this.forward) {
          this.forward(data);
        } else if (this.queue.length==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else if (this.handlers.receive) {
          this.handlers.receive(data);
        } else this.queue.push(data);
      },
      receive : function () {
        var self=this,data;
        if (this.queue.length) return this.queue.shift();
        return new Promise(function (resolve,reject) {
          self.waiters.push(function (data) {
            if (data===undefined) reject(); // interrupted
            else resolve(data);
          });
        });
      }
    }
    Channel.channels[id]=chan;
    return chan;
  }
}
/* TODO: Can't use Atomics due to custom shared memory buffer */
/* REimplement all IPC with named OS system-level semaphores available in SM module */ 
Barrier = {
  barrierID:0,
/*
  shared : function Barrier (sab,N,offset) {
    var self={}
    offset=offset||0;
    if (typeof sab == 'number') { N=sab; sab=null }
    var LOCKED=1, UNLOCKED=0;
    if (!sab) throw "Barrier.shared: No SAB provided";
    self._mu  = new Int32Array(sab,offset,4);
    if (N != undefined) self._mu[3]=N;
    else N=self._mu[3];
    self._mu[1]=0;
    self._mu[2]=LOCKED;    
    self.lock = function () {
      for(;;) {
        if (Atomics.compareExchange(self._mu, 0, UNLOCKED, LOCKED) == UNLOCKED) {
          return;
        };
        Atomics.wait(self._mu, 0, LOCKED);
      }
    };
    self.unlock = function () {
      if (Atomics.compareExchange(self._mu, 0, LOCKED, UNLOCKED) != LOCKED) {
        throw new Error("Barrier.Lock is in inconsistent state: unlock on unlocked Mutex.");
      };
      Atomics.notify(self._mu, 0,1);
    };
    self.await = function () {
      self.lock()
      if (Atomics.load(self._mu,1)<(N-1)) {
        Atomics.add(self._mu, 1, 1);
        Atomics.store(self._mu, 2, LOCKED);
        self.unlock()
        if (Atomics.load(self._mu,2)==LOCKED) 
          Atomics.wait(self._mu, 2, LOCKED);
        Atomics.sub(self._mu, 1, 1);
        return;
      } else {
        // release barrier; start down protocol
        Atomics.store(self._mu, 2, UNLOCKED);
        for(var i=N-1;i>=1;i--) {
          Atomics.notify(self._mu, 2, 1);
          while (Atomics.load(self._mu, 1)==i) {}       
        }
        self.unlock()
        return
      }
    };
    self.level = function () { return self._mu[1] },
    self.__share = function () { return {
      data : {
        barrier:Utils.serialize({
          Barrier : Barrier
        }),
        sab:sab
      },
      eval : function (data) {
        var barrier = Utils.deserialize(data.barrier)
        return barrier.Barrier(data.sab)
      }
    }};
    return self
  }
*/
}
Mutex = {
  mutexID:0,
/*
  shared : function Mutex (sab,offset) {
    var self={}
    offset=offset||0;
    var LOCKED=1, UNLOCKED=0;
    if (!sab) throw "Mutex.shared: No SAB provided";
    self._mu  = new Int32Array(sab,offset,1);
    self.lock = function () {
      for(;;) {
        if (Atomics.compareExchange(self._mu, 0, UNLOCKED, LOCKED) == UNLOCKED) {
          return;
        };
        Atomics.wait(self._mu, 0, LOCKED);
      }
    };
    self.unlock = function () {
      if (Atomics.compareExchange(self._mu, 0, LOCKED, UNLOCKED) != LOCKED) {
        throw new Error("Mutex is in inconsistent state: unlock on unlocked Mutex.");
      };
      Atomics.notify(self._mu, 0,1);
    };
    self.__share = function () { return {
      data : {
        mutex:Utils.serialize({
          Mutex : Mutex
        }),
        sab:sab
      },
      eval : function (data) {
        var mutex = Utils.deserialize(data.mutex)
        return mutex.Mutex(data.sab)
      }
    }};
    return self
  }
*/
}

Semaphore = {
  semaID:0,
  semas:[],
  semaphores : [],
  create : function (init) {
    var id = Semaphore.semaID++;
    var sema = {
      waiters : [],
      idn       : id,
      id        : 'semaphore'+id,
      counter   : init,
      cancel : function () {
        this.waiters.forEach(function (waiter) {
          waiter();
        })
        this.waiters=[];
      },
      destroy : function () {
        this.cancel();
        delete Semaphore.semaphores[id];
      },
      /*client API*/
      release: function (data) {
        if (this.forward) {
          this.forward();
        } else if (this.counter==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else this.counter++;
      },
      acquire : async function (cb) {
        var self=this;
        if (cb) {
          if (this.counter) { this.counter--; return cb()}
          else return this.waiters.push(cb);
        }
        if (this.counter) return --this.counter;
        // needs await prefix before receive in async function (Code.run)
        return new Promise(function (resolve) {         
          self.waiters.push(function (_data) {
            resolve();
          });
        })
      },
    }
    Semaphore.semaphores[id]=sema;
    return sema;
  }
/*
  shared : function Semaphore (sab,init,offset) {
    var self={}
    offset=offset||0;
    if (typeof sab == 'number') { init=sab; sab=null }
    var LOCKED=1, UNLOCKED=0;
    if (!sab) throw "Semaphore.shared: No SAB provided";
    self._mu  = new Int32Array(sab,offset,4);
    if (init!= undefined) {
      self._mu[1] = init; 
      if (init==0) self._mu[2]=LOCKED;
      else self._mu[2]=UNLOCKED;
    };
    self.lock = function () {
      for(;;) {
        if (Atomics.compareExchange(self._mu, 0, UNLOCKED, LOCKED) == UNLOCKED) {
          return;
        };
        Atomics.wait(self._mu, 0, LOCKED);
      }
    };
    self.unlock = function () {
      if (Atomics.compareExchange(self._mu, 0, LOCKED, UNLOCKED) != LOCKED) {
        throw new Error("Semaphore.Lock is in inconsistent state: unlock on unlocked Mutex.");
      };
      Atomics.notify(self._mu, 0, 1);
    };
    self.acquire = function () {
      for(;;) {
        self.lock()
        // print('acquire='+self._mu[1]);
        if (self._mu[1]==0) {
          Atomics.store(self._mu, 2, LOCKED);
          self.unlock()
          Atomics.wait(self._mu, 2, LOCKED);
          continue;
        } else {
          self._mu[1]--;
          self.unlock()
          return
        }
      }    
    };
    self.release = function () {
      self.lock()
      // print('release='+self._mu[1]);
      if (self._mu[1]==0) {
        self._mu[1]++;
        Atomics.store(self._mu, 2, UNLOCKED);
        if (Atomics.notify) Atomics.notify(self._mu, 2, 1);
        else Atomics.wake(self._mu, 2,1);  // old comp.
      } else {
        self._mu[1]++;
      }
      self.unlock()  
    };
    self.level = function () { return self._mu[1] },
    self.__share = function () { return {
      data : {
        offset : offset,
        sema:Utils.serialize({
          Semaphore : Semaphore
        }),
        sab:sab
      },
      eval : function (data) {
        var sema = Utils.deserialize(data.sema)
        return sema.Semaphore(data.sab,null,data.offset)
      }
    }};
    return self
  }
*/
}

// Local Worker Processes API
Worker = {
  workerID: 0,
  workers : [],
  handlers : [],
  connections : [],
  
  create : function (options) {
    options=options||{};

    var id = Worker.workerID++;
    var parameters=[];
    var semaJoin = Semaphore.create(0);
    var channelA = Channel.create(0),
        channelB = Channel.create(0);
    
    // Note: run may not contain empty code lines!!!
    function run(id,gui,wss) {
      var WebSocket;
      try { 
        /* create a secondary websocket service endpoint for worker-worker and master-worker IPC */
        if (wss) {
          WebSocket = require('ws');
          /* create a websocket server with random port */
          wss = new WebSocket.Server({ port: 0 });
          wss.port = wss._server.address().port;
          console.log('[Worker #'+id+'] WebSocket Service started (ws://localhost:'+wss.port+')');
          wss.on('connection', function (ws) {
            var channel;
            /* MessageChannel conection between workern/worker-main */
            console.log('[Worker #'+id+'] WebSocket ws.connection.open (ws://localhost:'+wss.port+')');
            ws.on('message', function (message) {
              message=JSONfn.parse(message);
              /*console.log('wss.on.message',message);*/
              switch (message.command) {
                case 'channel':
                  /* create a channel pair end-point handler */
                  channel = Code.channel.create();
                  channel.forward = function (data) {
                    ws.send(JSONfn.stringify({command:'send',data:data}));
                  };
                  if (message.assign) Env[message.assign]=channel;
                  break;
                case 'send':
                  if (channel) channel.enqueue(message.data);
                  break;
                default:
                  handler(message,{
                    send : function (data) { ws.send(JSONfn.stringify(data)) }
                  });
                  break;
              };
            });
            ws.on('error', function (err) {
              console.log('[Worker #'+id+'] WebSocket ws.connection',err);
            });
            ws.on('close', function () {
              console.log('[Worker #'+id+'] WebSocket ws.connection.close');
            });
          }) 
        }
      } catch (e) { wss=false; console.log(e); };
      var receiving,queue=[];
      var Console = '';
      var Env = {};
      /* Context is this.env in worksh main scope */
      Object.assign(Env,Context);
      Object.assign(Env,{
        __handler:[],
        compile : function (code,context,data) {
          if (context) {
            var pars = Object.keys(context),
                args = pars.map(function (key) { return context[key] });
            pars.unshift('__dummy');
            if (data!==undefined) { pars.push('__data'); args.push(data) };
            pars.push(code);
            var foo = new (Function.prototype.bind.apply(Function,pars));
            return foo.apply(self,args);          
          } else {
            var foo = new Function ("return "+code)();
            return foo;
          }
        },
        emit : function (ev,arg) {
          /*Send a user event to main thread*/
          process.send({command:'event',event:ev,data:arg});
        },
        error : function () { 
          process.send({ command:'error', error:Array.prototype.slice.call(arguments),console:this.Console||Console}) 
        },
        __handler:[],
        join  : function () { process.send({ release:'join' }) },
        kill  : function () {
          console.log('[Worker #'+id+'] Killed. ('+process.pid+')');
          Env.print('Terminated.');
          setTimeout(function () {
            process.exit();
          },20);
        },
        ofString:ofString,
        off : function (ev) {
          delete Env.__handler[ev]
        },
        on : function (ev,handler) {
          Env.__handler[ev]=handler;
        },
        print : function () { 
          process.send({ command:'print',data:Array.prototype.slice.call(arguments), console:this.Console||Console}) 
        },
        printi : function () { 
          var args = Array.prototype.slice.call(arguments), id=args.shift();
          if (id==undefined) return Math.random().toString(36).substr(2, 16);
          process.send({ command:'printi',id:id, data:args, console:this.Console||Console}) 
        },
        receive : function () {
          var data;
          if (queue.length) return queue.shift();
          return new Promise(function (resolve) {
            receiving=function (data) {
              resolve(data);
            };            
          });
        },
        schedule : async function () {
          return new Promise(function (resolve,reject) {
            setTimeout(function () {
              var interrupt=Code.interrupt;
              resolve(!interrupt);
            },1);
          });
        },
        send  : function (data) { process.send({ command:'send',data:toString(data) }) },
        sleep : function (time) {
          return new Promise(function (resolve) {
            setTimeout(resolve,time);
          });    
        },
        status : function () { 
          process.send({ command:'pstatus',data:Array.prototype.slice.call(arguments), console:this.Console||Console})
        },
        Table : function () {
          process.send({command:'Table',data:Array.prototype.slice.call(arguments)})
        },
        toString:toString,
        time  : Date.now,
        verbose : 1,
        write : function (key,val) { 
          process.send({write:key,data:JSONfn.serialize(val)});
        }
      });
      if (gui) {
        Object.assign(Env,{
          Plot : function (data,options) {
            if (options.update==undefined && options.id==undefined) options.id=id+'-'+(Env.Plots++);
            process.send({command:'Plot',data:toString([data,options])});
            /* id reference for plot updates */
            return options.id!=undefined?'plot'+options.id:'plot'+options.update;
          },
          Plots : 0,
          PlotTable : function (table,options) {
            options=options||{};
            if (options.id==undefined) options.id=id+'-'+(Env.Plots++);
            process.send({command:'Plot',data:toString({table:table,id:options.id})});
            return 'plot'+options.id;
          }
        });
      };
      Env.exports=Env;
      var self=this;
      function isArray(o) {
        if (o==undefined || o ==null) return false;
        else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
      };
      function isObject(o) {
        return typeof o == "object";
      };
      function isTypedArray(o) {
        return isObject(o) && o.buffer instanceof ArrayBuffer
      };
      function TypedArrayToName(ftyp) {
        if (ftyp==Int8Array   || ftyp instanceof Int8Array) return 'Int8Array';
        if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return 'Uint8Array';
        if (ftyp==Int16Array  || ftyp instanceof Int16Array) return 'Int16Array';
        if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return 'Uint16Array';
        if (ftyp==Int32Array  || ftyp instanceof Int32Array) return 'Int32Array';
        if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return 'Uint32Array';
        if (ftyp==Float32Array || ftyp instanceof Float32Array) return 'Float32Array';
        if (ftyp==Float64Array || ftyp instanceof Float64Array) return 'Float64Array';
        return ftyp.toString()
      };
      function ofString(source,mask) {
        var code;
        mask=mask||{};
        try {
          with (mask) {
            eval('"use strict"; code = '+source);
          }
        } catch (e) { console.log(e) };
        return code; 
      };
      function toString(o) {
        var usebuffer=false;
        var p,i,keys,s='',sep,tokens;
        if (o===null) return 'null';
        else if (isArray(o)) {
          s='[';sep='';
          for(p in o) {
            s=s+sep+toString(o[p]);
            sep=',';
          }
          s+=']';
        } else if (typeof Buffer != 'undefined' && o instanceof Buffer) {    
          s='Buffer([';sep='';
          for(i=0;i<o.length;i++) {
            s=s+sep+toString(o[i]);
            sep=',';
          }
          s+='])';  
        } else if (o instanceof Error) {    
          s='(new Error("'+o.toString()+'"))';
        } else if (isTypedArray(o)) {    
          s='(new '+TypedArrayToName(o)+'([';sep='';
          var b=Array.prototype.slice.call(o);
          for(i=0;i<b.length;i++) {
            s=s+sep+String(b[i]);
            sep=',';
          }
          s+=']))';  
        } else if (typeof o == 'object') {
          s='{';sep='';keys=Object.keys(o);
          for(i in keys) {
            p=keys[i];
            if (o[p]==undefined) continue;
            s=s+sep+"'"+p+"'"+':'+toString(o[p]);
            sep=',';
          }
          s+='}';
          if (o.__constructor__) s = '(function () { var o='+s+'; o.__proto__='+o.__constructor__+'.prototype; return o})()';
        } else if (typeof o == 'string')
          s="'"+
            o.toString().replace(/'/g,'\\\'')
                        .replace(/\n/g,'\\n')+
            "'"; 
        else if (typeof o == 'function') {
          s=o.toString(true);
          if (tokens=s.match(/function[ ]+([a-zA-Z0-9]+)[ ]*\(\)[ ]*{[^\[]*\[native code\][^}]*}/)) {
            return tokens[1];
          } else return s;
        } else if (o != undefined)
          s=o.toString();
        else s='undefined';
        return s;
      };
      function compile(code,context,data) {
        var pars = Object.keys(context),
            args = pars.map(function (key) { return context[key] });
        pars.unshift('__dummy');
        Code.interrupt=false;
        if (data!==undefined) { pars.push('__data'); args.push(data) };
        pars.push(code);
        try {
          var foo = new (Function.prototype.bind.apply(Function,pars));
          return foo.apply(self,args);
        } catch (e) {
          Env.error(e.toString()+','+code);
        }
      };
      function execute(code,immed,_console) {
        var exports;
        if (typeof code == 'string' && (exports=code.match(/export {([^}]+)}/))) {
          code=code.replace(/export {([^}]+)}/,'');          
          exports[1].split(',').forEach(function (exporting) {
            code += ('exports["'+exporting.trim()+'"]='+exporting.trim()+';');
          })
        }
        if (immed) {
          try {
            return compile('var __error=error,__print=print,__printi=printi,__status=status; (async function () { '+
                           'var Console="'+(_console||'')+
                           '";var print=__print.bind({Console:Console}), printi=__printi.bind({Console:Console}), status=__status.bind({Console:Console}), error=__error.bind({Console:Console}); try { '+
                           code +
                           '\n} catch (e) { error(e.toString()) }})()',Env);
          } catch (e) { Env.error(e.toString()) };    
        } else setTimeout(function () {
          try {
            compile('var __error=error,__print=print,__printi=printi,__status=status; (async function () { '+
                    'var Console="'+(_console||'')+
                    '";var print=__print.bind({Console:Console}),  printi=__printi.bind({Console:Console}), status=__status.bind({Console:Console}), error=__error.bind({Console:Console}); try { '+
                    code +
                    '\n} catch (e) { error(e.toString()) }})()',Env);
          } catch (e) { Env.error(e.toString()) };        
        },0);        
      };
      function expression(code,_console) {
        try {
         compilel('(function () { return '+code +'})()',Env);
        } catch (e) { Env.error(e.toString()) };
      };
      /* evaluate an expression (no function), always synchronous */
      function evali (code,assign,_console) {
        var result;
        result = compile ('try { var __error=error; var Console="'+_console+
                          '";\n'+
                          (assign?assign+'=':'')+
                          code+
                          '} catch (e) { console.log("caught exception",e); __error(e.toString(),e.stack) }',Env);  
        return result;
      }
      /* evaluate a function with optional data (function can be asynchronous, but rpc-op is synch.) */
      function evalf (code,data,assign,_console,_id) {
        var result,isasync=/^[ ]*async[ ]+function/.test(code);
        if (data==undefined) data=null;
        result = compile ('try { var __result=true,__error=error,__print=print,__printi=printi,__status=status; var Console="'+_console+
                         '";'+
                         (assign?
                           (isasync? '(async function () { '+
                                     'var print=__print.bind({Console:Console}), printi=__printi.bind({Console:Console}),status=__status.bind({Console:Console}),error=__error.bind({Console:Console}); '+ 
                                     assign+' = await '
                           : assign+' = ')
                         : (isasync? '(async function () { '+
                                     'var print=__print.bind({Console:Console}), printi=__printi.bind({Console:Console}),status=__status.bind({Console:Console}),error=__error.bind({Console:Console}); try { __result=await ' 
                            : '__result=')
                         )+
                         '('+
                         code+
                         ')(__data)'+
                         (isasync && !assign?'} catch (e) {__error(e.toString(),e.stack)};if (__result===undefined) __result=null;process.send({command:"evals",status:__result,id:'+_id+'});'
                          :'')+
                         (isasync? '})()'
                          : '')+
                         '} catch (e) { console.log("caught exception",e); __error(e.toString(),e.stack) }; return __result',Env,data);
        return result;      
      }
      /* handle messages from master/proxy/direct channel */
      function handler (message,connection) {
        var data;
        /*console.log('worker.on.message',message);*/
        switch (message.command) {
          case 'execute':
            Console=message.console||'';
            execute(message.code,false,message.console);
            break;
          case 'eval':
            var result = expression(message.code,message.console);
            if (result===undefined) result=null;
            if (message.code[message.code.length-1]!=';')
              connection.send({command:'print',status:result,id:message.id});
            break;
          case 'evali':
            var result = evali(message.code,message.assign,message.console);
            if (result===undefined) result=null;
            /*
            if (message.read==undefined && message.id!=undefined) process.send({command:'evals',status:result,id:message.id});
            else connection.send({command:'send',data:result});
            */
            connection.send({command:'evals',status:result,id:message.id});
            break;
          case 'evalf':
            var result = evalf(message.code,message.data,message.assign,message.console,message.id);
            if (result===undefined) result=null;
            if (!/^[ ]*async[ ]+function/.test(message.code)) {
              connection.send({command:'evals',status:result,id:message.id});
            }
            break;
          case 'event':
            if (Env.__handler[message.event]) {
              with (Env) { Env.__handler[message.event](message.data,Env); }
            }
            break;
          case 'monitor':
            /* get the signature of an object for monitoring */
            function signature (data,level) {
              var sig = typeof data;
              if (sig == 'object') {
                if (Utils.isArray(data)) {
                  sig=[];
                  if (level && data.length && data[0]!=undefined) sig = [signature(data[0],level-1)];
                } else {
                  sig={};
                  if (level) Object.keys(data).map(function (key) {
                    sig[key]=signature(data[key],level-1);
                  });
                }
              }
              return sig;
            };
            data=compile('return '+message.key,Env);
            reply = {
              command : 'monitor',
              data : {
                typ     : typeof data,
                sig     : signature(data,message.level||1),
              }
            };
            connection.send(reply);
            break;
          case 'read':
          case 'reads':
            data=compile('return '+message.key,Env);
            if (data===undefined) data=null;
            reply={
              command : message.command,
              commid  : message.commid,
              data    : data, 
            };
            connection.send(reply);            
            break;
          case '_send': /* forwarded from remote site */
            if (receiving) receiving(message.data);
            else queue.push(message.data);
            break;
          case 'send':
            if (typeof message.data=='object' && 
                message.data.channelid != undefined && 
                Code.channel.channels[message.data.channelid])
              Code.channel.channels[message.data.channelid].remote(message.data.data);
            else if (receiving) receiving(message.data);
            else queue.push(message.data);
            break;
          case 'share':
            /*console.log('share',message);*/
            if (message.eval) {
              evalf(message.eval,message.data,message.key,message.console);
            } else {
              var parts = message.key.split('.'),
                  key  = parts.pop(),
                  root = parts.join('.');
              var rootObj=compile('return '+root, Env);
              rootObj[key]=message.data;
            }
            break;
          case 'signal':
            if (message.signal=='SIGINT') Code.stop();
            else if (message.signal=='SIGKILL') Env.kill();
            Env.print('Got signal '+message.signal);
            break;
          case 'write':
            var data=JSONfn.deserialize(message.data);
            if (typeof data == 'function')
              compile(message.key+'='+data.toString()+';', Env);
            else
              compile(message.key+'='+message.data+';', Env);
            /*evali(message.key+'='+message.data);*/
            break;
        }
      }
      Code.error=Env.error;
      Code.print=Env.print;
      /* Process messages from master */
      process.on('message',function (message) { handler(message,process) });
      if (wss) process.send({command:'event',event:'port',data:wss.port});
      process.send({command:'event',event:'ready'+id});
      Env.print('Started.',process.pid,Env.time());
    }

    parameters = [
      '-e',
      run.toString().replace(/\n/g,'')+'; run('+id+','+options.gui+','+options.wss+');'
    ];
    
    var proOptions = {
      stdio: [ 'ignore', process.stdout, process.stderr, 'ipc' ]
    };
    function stderr(args,_console) {
      if (options.forward) options.forward({command:'error',error:['[WORKER #'+id+' ERR]'].concat(args),console:_console});
      else console.log.apply(null,['[WORKER #'+id+' ERR]'].concat(args));
    }
    function stdout(args,_console,line) {
      if (options.forward) options.forward({command:line==undefined?'print':(line=='status'?'pstatus':'printi'),
                                            data:['[WORKER #'+id+']'].concat(args),console:_console,id:line});
      else console.log.apply(null,['[WORKER #'+id+']'].concat(args));
    }
    // print(parameters.join(' '));
    var worker = fork(shell,parameters,proOptions);
    Worker.workers.push(worker);
    // messages from worker
    worker.on ('message', function (message) {
      switch (message.command) {
        case 'error':
          stderr(message.error,message.console);
          break;
        case 'evals':
          if (options.forward) options.forward(message);
          else channelB.enqueue(message.status);
          break;
        case 'event':
          if (options.forward) options.forward(message);
          else Worker.emit(message.event,message.data);
          break;
        case 'monitor':
          if (options.forward) options.forward(message);
          else channelB.enqueue(message.data);
          break;
        case 'Plot':
          if (options.forward) options.forward(message);
          break;
        case 'print':
          stdout(message.data,message.console);
          break;
        case 'printi':
          stdout(message.data,message.console,message.id);
          break;
        case 'pstatus':
          stdout(message.data,message.console,'status');
          break;
        case 'read':
          if (options.forward) options.forward(message);
          else channelB.send(message.data);
          // if (options.message) options.message(message);
          // else Code.worker.emit(message.commid,message.data);
          break;
        case 'reads':
          if (options.forward) options.forward(message);
          else channelB.send(message.data);
          // if (options.message) options.message(message);
          // else Code.worker.emit(message.commid,message.data);
          break;
        case 'release':
          semaJoin.release();
          break;
        case 'signal':
          if (message.signal=='SIGINT') Env.Code.stop();
          Env.print('Got signal '+message.signal);
          break;
        case 'send':
          if (options.forward) options.forward(message);
          else {
           /* explicit channel communication */
            var c=message.channelid==undefined?channelA:Channel.channels[message.channelid];
            if (c) c.enqueue(Utils.ofString(message.data));
          }
          break;
        case 'Table':
          if (options.forward) options.forward(message);
          else Table.apply(null,message.data);
          break;
        case 'write':
          if (options.forward) options.forward(message);
          // else eval(message.write+'='+message.data);  // TODO context!!!!
          break;
      }
    });
    worker.on('exit', function () {
      console.log('[WORKER #'+id+'] exit.');
      worker.state=0;
    });
    worker.channelA=channelA;
    worker.channelB=channelB;
    worker.cancel = function () {
      channelA.cancel();
      channelB.cancel();
    };
    worker.join = function () {
      semaJoin.acquire();
    };
    worker.receive = function () {
      return channelA.receive();
    };
    /* sync. request reply channel */
    worker.reply = async function (cb) {
      return channelB.receive(cb);
    };

    worker.state=1;
    // prelimenary ready event handler
    Code.worker.on('ready'+id,function () {
      worker.state=2;
    });
    return id;
  },
  
  emit : function (ev,data) {
    if (Worker.handlers[ev]) {
      Worker.handlers[ev](data);
      if (!isNaN(Number(ev))) delete Worker.handlers[ev];
    }  
  },

  // Evalue an expression on worker and wait for result
  eval : async function (id,code,assign,cb) {
    if (!Worker.workers[id]) return Code.error('eval: unknown worker'+is);
    var worker=Worker.workers[id];
    if (typeof assign == 'function') { cb=assign;assign=undefined };
    // wait for reply
    worker.send({command:'evali',code:code,id:id});
    return worker.reply(cb);
  },

  // Evalue a function 8with optional target assignment) on worker and wait for result
  evalf : async function (id,fun,data,assign,cb) {
    if (!Worker.workers[id]) return Code.error('evalf: unknown worker'+is);
    if (typeof assign == 'function') { cb=assign;assign=undefined };
    var worker=Worker.workers[id];
    // wait for reply
    worker.send({command:'evalf',code:fun.toString(),data:data,assign:assign,id:id}); 
    return worker.reply(cb);
  },

  get : function (id) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('get: No such worker #'+id);
    return Workers[id];
  },

  join : function (id) {
    if (!Worker.workers[id]) return Code.error('join: No such worker #'+id);
    var worker=Worker.workers[id];
    Worker.workers[id].join();
    
  },
  
  kill : function (id,immediate) {
    if (!Worker.workers[id]) return Code.error('kill: No such worker #'+id);
    var worker=Worker.workers[id];
    if (worker.state!=1) return;  // ignore killing
    worker.state=0;
    if (immediate)
      worker.kill();
    else 
      worker.send({command:'execute',code:'kill()'});
  },
  
  message : function (id,data) {
    if (!Worker.workers[id]) return Code.error('message: No such worker #'+id);
    var worker=Worker.workers[id];
    return worker.send(data);
  },
  
  // Create an auto data monitor for a remote objects.
  // All scalar values are returned as a copy, all objects are iterated until a given depth.
  // The level parameters defines the maximal depth of the monitor object iterator.
  // All attribute values below this depth will always be returned as a data copy!
  // reading an object is an asynchronous function returning a promise for that can be waited for:
  // (await mon.x.y).a
  // Waiting for a promise is only possible on object endpoints (depth!)
    
  monitor : async function (id,key,level,verbose) {
      var o;
      level=level||1;
      // print('Monitor',key);
      var signature = await Worker.signature(id,key,level);
      if (verbose) Code.print(signature);
      function construct(key,sig,level) {
        var o,selector = {}
        if (verbose) Code.print('construct',key,sig,level)
        switch (typeof sig) {
          case 'object':
            if (Utils.isArray(sig)) {
              if (verbose) Code.print('construct []',key)
              selector=function (name) {
                if (name==[]) {
                  // get all elements
                  if (verbose) Code.print(id,key)
                  return Worker.read(id,key)                                
                } else if (name!='length' && name != 'then') {
                  name='['+name+']';
                  if (verbose) Code.print(id,key,name)
                  return Worker.read(id,key+name)
                } else if (name != 'then') {
                  if (verbose) Code.print(id,key,name)
                  return Worker.read(id,key+'.'+name)                
                }
              }
            
            } else Object.keys(sig).forEach(function (name) {        
              // print('selector',key,name,sig[name],level)
              switch (sig[name]) {
                case 'number':
                case 'string':
                case 'boolean':
                  selector[name]=function () { return Worker.read(id,key+'.'+name)};
                  break;
                default:            
                  if (typeof sig[name]=='object') {
                    if (Utils.isArray(sig[name])) {
                      if (level && sig[name].length && typeof sig[name][0]!='string') {
                        // TODO: should arrays be indexed? only for object arrays???
                        // how get we the length of an array?
                        // TODO: select all elements selector!?!?  array[[]]!!! DONE
                        var next =  construct(key+'.'+name,[],0 /* stop here definetely */);
                        selector[name]=function () { return next };                       
                      } else {
                        if (verbose) Code.print('construct []',key,name)
                        selector[name]=function () { 
                          if (verbose) Code.print(id,key,name)
                          return Worker.read(id,key+'.'+name)
                        }
                      }
                    } else if (level) {
                      var next =  construct(key+'.'+name,sig[name],level-1);
                      selector[name]=function () { return next };
                    } else selector[name]=function () {
                      if (verbose) Code.print(id,key,name)
                      return Worker.read(id,key+'.'+name) 
                    };
                  }
              }   
            });
            // print(selector)
            o = new Proxy({},{
              get : function (target,name) {
                if (verbose) Code.print('get',key,name,typeof name,selector)
                if (typeof selector == 'function') return selector(name); 
                if (!selector[name]) return;
                return selector[name]();
              },
              set : function (target,name,val) {
                if (verbose) Code.print('set',key,name)
                return Worker.write(id,key+'.'+name,val)
              }
            });
            return o;
            break;
        }
    }
    return construct(key,signature.sig,level-1);
  },

  on : function (ev,handler) {
    Worker.handlers[ev]=handler;
  },

  // Read data from worker (sync/async)
  read : async function (id,key,cb) {
    var dst;
    if (!Worker.workers[id]) return console.error('read: No such worker #'+id);
    var worker=Worker.workers[id];
    worker.send({command:dst?'reads':'read',key:key});
    return worker.reply(cb);
  },

  receive : async function (id,cb) {
    if (!Worker.workers[id]) return Code.error('receive: No such worker #'+id);
    var worker=Worker.workers[id];
    return worker.receive(cb);
  },

  // wait for worker to be started and ready to receive messages
  ready : function (id,cb) {
    if (!Worker.workers[id]) return Code.error('ready: No such worker #'+id);
    var worker=Worker.workers[id];
    if (worker.state==2) {
      if (cb) return cb();
      else return true;
    }
    if (cb) Worker.on('ready'+id,cb);
    else {
      // needs await prefix before receive in async function (Code.run)
      return new Promise(function (resolve) { 
        Worker.on('ready'+id,function () {
          // console.log('ShellWorker ready event',id);
          worker.state=2;
          resolve();
        });
      });
    }  
  },
  
  run: function (id,code,arg) {
    if (!Worker.workers[id]) return Code.error('run: No such worker #'+id);
    var worker=Worker.workers[id];
    if (typeof code == 'function') {
      if (arg==undefined)
        worker.send({command:'execute',code:'('+code.toString()+').call(this)'});
      else
        worker.send({command:'execute',code:'('+code.toString()+').call(this,'+JSON.stringify(arg)+')'});
    } else
      worker.send({command:'execute',code:code.toString()});
  },

  // Send sharable data to worker (no string serialization) with optional code evaluation (i.e., desserialization)
  share : function (id,key,data,eval) {
    if (!Worker.workers[id]) return Code.error('share: No such worker #'+id);
    var worker=Worker.workers[id];
    if (!eval && typeof data == 'object' && typeof data.__share == 'function') {
      var share = data.__share();  // remote: key=eval(data)
      data=share.data;
      eval=share.eval;
    }
    // console.log({command:'share',key:key,data:data,eval:eval});
    worker.send({command:'share',key:key,data:data,eval:eval?eval.toString():undefined});
    return;
  },

  signal : function (id,signal) {
    if (!Worker.workers[id]) return Code.error('signal: No such worker #'+id);
    var worker=Workers[id];
    worker.send({command:'signal',signal:signal});  
  },

  // GET A REMOT OBJECT SIGNATURE UP TO DEPTH LEVEL
  signature : async function (id,key,level,cb)  {
    if (!Worker.workers[id]) return Code.error('share: No such worker #'+id);
    var worker=Worker.workers[id];
    worker.send({command:'monitor',key:key,level:level||1});
    return worker.reply(cb);
  },
  
  sleep : function (time) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve();
      },time);
    });    
  },
  
  send : function (id,data) {
    if (!Worker.workers[id]) return Code.error('send: No such worker #'+id);
    var worker=Worker.workers[id];
    return worker.send({command:'send',data:data});
  },
  
  write : function (id,key,val) {
    if (!Worker.workers[id]) return Code.error('write: No such worker #'+id);
    var worker=Worker.workers[id];
    return worker.send({comamnd:'write',key:key,data:JSONfn.serialize(val)});
  },
  
  version : '1.9.1',
  
}
Worker.Barrier=Barrier;
Worker.Channel=Channel;
Worker.Mutex=Mutex;
Worker.Semaphore=Semaphore;


Worker.Worker = function (options) {
  // create a worker object
  var workerid = Worker.create(options);
  return {
    eval : async function (code,assign,cb) { return Worker.eval(workerid,code,assign,cb) },
    evaf : async function (code,data,assign,cb) { return Worker.evalf(workerid,code,data,assign,cb) },
    kill: function (id) { Worker.kill(id==undefined?workerid:id) },
    run : async function (code,cb) { return Worker.run(workerid,code,cb) },
    signal: Worker.signal,
  }
}
module.exports=Worker;
};
BundleModuleCode['plugins/pcsp/sm.js']=function (module,exports){
/*
** Shared Memory Buffer Segments for Buffer Objects (see bobj module)
** and alloc/free block management
** Version 1: VM Processes using OS shared memory mappings
*/
var Options = {
  version : '1.2.1',
  verbose : 0
}

var ffi=require('ffi');
var ref=require('ref')

var BufferSegments = {};

if (process.platform=='linux') {
  // /usr/lib54 or /lib64?
  var libprefix = process.arch=='x64'?'/lib64/':'';
  var librt_api = {
    shm_open:['int',['char*','int','long']],
    sem_open:['void *',['char*', 'int', 'int', 'int']],
    sem_close:['int', ['void*']],
    sem_init:['int', ['void*','int','int']],
    sem_unlink:['int',['char*']],
    sem_post:['int',['void*']],
    sem_wait:['int',['void*']],
  }
  var librt =ffi.Library(libprefix+'librt',librt_api) 
  var libc = ffi.Library(libprefix+'libc',{
    ftruncate:['int',['int','int']],
    mmap:['void *',['void *','long','int','int','int','long']],
    printf:['int',['char *','char *']],
  })
  for(var p in librt_api) 
    libc[p]=librt[p];
} else {
  // sunos
  var libc = ffi.Library('libc',{
    ftruncate:['int',['int','int']],
    mmap:['void *',['void *','long','int','int','int','long']],
    printf:['int',['char *','char *']],
    shm_open:['int',['char*','int','long']],
    sem_open:['void *',['char*', 'int', 'int', 'int']],
    sem_close:['int', ['void*']],
    sem_init:['int', ['void*','int','int']],
    sem_unlink:['int',['char*']],
    sem_post:['int',['void*']],
    sem_wait:['int',['void*']],
  })
}
////////////////////////// mmap ////////////////////////////////////////////

var PROT_NONE       = 0x0             /* pages cannot be accessed */
/*
 * Protections are chosen from these bits, or-ed together.
 * Note - not all implementations literally provide all possible
 * combinations.  PROT_WRITE is often implemented as (PROT_READ |
 * PROT_WRITE) and (PROT_EXECUTE as PROT_READ | PROT_EXECUTE).
 * However, no implementation will permit a write to succeed
 * where PROT_WRITE has not been set.  Also, no implementation will
 * allow any access to succeed where prot is specified as PROT_NONE.
 */
var PROT_READ       = 0x1             /* pages can be read */
var PROT_WRITE      = 0x2             /* pages can be written */
var PROT_EXEC       = 0x4             /* pages can be executed */

/* sharing types:  must choose either SHARED or PRIVATE */
var MAP_SHARED      = 1               /* share changes */
var MAP_PRIVATE     = 2               /* changes are private */
var MAP_TYPE        = 0xf             /* mask for share type */

/* other flags to mmap (or-ed in to MAP_SHARED or MAP_PRIVATE) */
var MAP_FIXED       = 0x10            /* user assigns address */
var MAP_NORESERVE   = 0x40            /* don't reserve needed swap area */
var MAP_LOW32       = 0x80    /* force mapping in lower 4G of address space */
var MAP_ANON        = 0x100           /* map anonymous pages directly */
var MAP_ANONYMOUS   =  MAP_ANON        /* (source compatibility) */
var MAP_ALIGN       = 0x200           /* addr specifies alignment */
var MAP_TEXT        = 0x400           /* map code segment */
var MAP_INITDATA    = 0x800           /* map data segment */
var MAP_ADI         = 0x8000          /* map with ADI enabled */

/////////////////////////// shm_open ///////////////////////////////////////
// https://opensource.com/article/19/4/interprocess-communication-linux-storage

var O_RDONLY        = 0;
var O_WRONLY        = 1
var O_RDWR          = 2
if (process.platform=='linux') {
  var O_CREAT         = 0o100
  var O_EXCL          = 0o200
} else {
  // sunos
  var O_CREAT         = 0x100
  var O_EXCL          = 0x200
}
var	S_IRUSR		= 0o400
var	S_IWUSR	  = 0o200

//////////////////////////////////////////////////////////////////

var NULL      = -1
// null terminated strings
function str2buf(str) {
  var buf = Buffer(str.length+1);
  Buffer(str).copy(buf)
  buf[str.length]=0;
  return buf
}



///////////////////////////// SEMAPHORE /////////////////////////////////
// Implement a named native and sharable semaphore for SM-Syncing (blocking entire VM)
function semaphore (name,level) {
  if (!(this instanceof semaphore)) return new semaphore(name,level);
  this.name=name;
  if (Options.verbose) console.log('semaphore',name,level!=undefined?level:'shared')
  // if level == undefined then join an already existing semaphore only
  this.sem = libc.sem_open(str2buf(name),level!=undefined?O_CREAT:0,S_IRUSR | S_IWUSR, level);
  if (this.sem.hexAddress()=="ffffffff") throw ("semaphore.create("+name+")/L,"+level+" failed");
  if (level!=undefined) libc.sem_init(this.sem,1,level);
}
semaphore.prototype.acquire = function () {
  return libc.sem_wait(this.sem);
}
semaphore.prototype.release = function () {
  return libc.sem_post(this.sem);
}
semaphore.prototype.close = function () {
  libc.sem_close(this.sem);
  this.sem=null;
  return libc.sem_unlink(str2buf(this.name));
}
// IPC based on above semaphore (extends Mutex.shared, Semaphore.shared, Barrier.shared)

try { bobj=Require('pcsp/sm-ipc') } catch (e) { bobj=require('./sm-ipc') }

var bobj;
try { bobj=Require('pcsp/bobj') } catch (e) { bobj=require('./bobj') }

var AddrOf=bobj.AddrOf,
    SizeOf=bobj.SizeOf,
    TypeOf=bobj.TypeOf,
    TypeIf=bobj.TypeIf,
    Library=bobj.Library,
    BufferType=bobj.BufferType,
    StructType=bobj.StructType,
    ArrayType=bobj.ArrayType,
    BarrierType=bobj.BarrierType,
    MutexType=bobj.MutexType,
    SemaType=bobj.SemaType,
    MatrixType=bobj.MatrixType;
    

//////////////// Shared Memory Segment ///////////////////////

function sms(size,options) {
  // key=='<buffer>' -> using JS buffer instead of C memory; not sharable
  if (!(this instanceof sms)) return new sms(size,options);
  if (typeof BufferSegments=='undefined') BufferSegments={};
  global.BufferSegments=BufferSegments;
  options=options||{}
  this.options=options;
  this.verbose=options.verbose||0;
  this.key=options.key||('/shm'+Utils.uniqueID(8));
  this.base=0;
  this.allocasize=options.freelistSize||512;
  this.size=size;
  this.top=size-this.allocasize;
  BufferSegments[this.key]=this;
}


// tinyalloc
sms.prototype.alloc = function (size) {
  var bprt,bprev,
      ptr  = this.alloca.heap.free,
      prev = NULL,
      num  = size,
      top  = this.alloca.heap.top;
  num = (num + this.alloca.alignment - 1) & -this.alloca.alignment;
  while (ptr != NULL) {
      bptr=this.alloca.blocks[ptr];
      var is_top = (bptr.addr + bptr.size >= top) && (bptr.addr + num <= this.alloca.heap.limit);
      if (is_top || bptr.size >= num) {
          if (prev != NULL) {
              bprev=this.alloca.blocks[prev];
              bprev.next = bptr.next;
          } else {
              this.alloca.heap.free = bptr.next;
          }
          bptr.next  = this.alloca.heap.used;
          this.alloca.heap.used = ptr;
          if (is_top) {
              // console.log("resize top block");
              bptr.size = num;
              this.alloca.heap.top = bptr.addr + num;
          } else if (!this.alloca.disable_split && this.alloca.heap.fresh != NULL) {
              var excess = bptr.size - num;
              if (excess >= this.alloca.heap.split_thresh) {
                  blocksize    = num;
                  var split = this.alloca.heap.fresh,
                      bsplit = this.alloca.blocks[split];
                  this.alloca.heap.fresh  = bsplit.next;
                  bsplit.addr  = bptr.addr + num;
                  // console.log("split");
                  // console.log(bsplit.addr);
                  bsplit.size = excess;
                  this.insert_block(split,bsplit);
                  if (!this.alloca.disable_compact) this.compact();
              }
          }
          return bptr.addr;
      }
      prev = ptr;
      ptr  = bptr.next;
  }
  // no matching free blocks
  // see if any other blocks available
  var new_top = top + num;
  if (this.alloca.heap.fresh != NULL && new_top <= this.alloca.limit) {
      ptr         = this.alloca.heap.fresh;
      bptr        = this.alloca.blocks[ptr];
      this.alloca.heap.fresh  = bptr.next;
      bptr.addr   = top;
      bptr.next   = this.alloca.heap.used;
      bptr.size   = num;
      this.alloca.heap.used  = ptr;
      this.alloca.heap.top   = new_top;
      return bptr.addr;
  }
  return NULL;
}

sms.prototype.calloc = function (size) {
  var addr=this.alloc(size);
  if (addr) this.buffer.fill(0,addr,addr+size);
  return addr
}

// compact heap block list (tinyalloc)
sms.prototype.compact = function () {
  var bptr,bprev,bscan,
      ptr = this.alloca.heap.free,
      prev, scan;

  while (ptr != NULL) {
      bptr = this.alloca.blocks[ptr];
      prev = ptr;
      bprev = bptr;
      scan = bptr.next;
      bscan = this.alloca.blocks[scan];
      while (scan != NULL &&
             bprev.addr + bprev.size == bscan.addr) {
          // print_s("merge");
          // print_i((size_t)scan);
          prev = scan;
          scan = bscan.next;
      }
      if (prev != ptr) {
          var new_size =
              bprev.addr - bptr.addr + bprev.size;
          // print_s("new size");
          // print_i(new_size);
          bptr.size   = new_size;
          var next = bprev.next;
          // make merged blocks available
          this.release_blocks(bptr.next, bprev.next);
          // relink
          bptr.next = next;
      }
      ptr = bptr.next;
  }
}
// Create and open shared memory segment (or create a non-shareable buffer insteda, key=='<buffer>')
sms.prototype.create = function () {
  if (this.key != '<buffer>') {
    this.fd = libc.shm_open(str2buf(this.key),O_RDWR|O_CREAT, S_IRUSR | S_IWUSR);
    if (this.fd < 0) throw ("sms.create: (shm_open) failed: "+this.fd);
    libc.ftruncate(this.fd,this.size)
    // map shm in process space
    var pa = libc.mmap(ref.NULL_POINTER, this.size ,PROT_READ | PROT_WRITE, MAP_SHARED, this.fd, 0);
    this.memory = pa;
    this.buffer = ref.reinterpret(pa, this.size, 0);
  } else this.buffer = Buffer(this.size); // generic JS buffer; not shareable
  
  this.buffer._key=this.key;
  
  /////////////// tinyalloc block management //////////////
  var blocks = ArrayType({
    addr:'int',
    next:'int',
    size:'int',
  });
  var heapControl = StructType({
    free:'int',
    used:'int',
    fresh:'int',
    top:'int'
  })
  var heap_blocks = Math.floor((this.allocasize-heapControl.size())/(SizeOf('int')*3));
  //// block lists at beginning of segment!!! ////
  this.alloca = {
    blocks : blocks(this.buffer,heapControl.size(),heap_blocks),
    heap   : heapControl(this.buffer,0),
    base   : 0,
    limit  : this.top+this.allocasize,
    max_blocks : heap_blocks-1,
    split_thresh : 16,
    alignment : 4,
    disable_compact : false,
    disable_split   : false, 
  }
  if (Options.verbose)
    console.log('[SM '+this.key+'] Created shared segment ('+this.allocasize+'/'+this.size+') with blocks',heap_blocks,'heap_max_blocks',this.alloca.max_blocks);
  this.alloca.heap.free=NULL;
  this.alloca.heap.used=NULL;  
  this.alloca.heap.fresh=1;
  this.alloca.heap.top=this.allocasize;
  
  var i = this.alloca.heap.fresh; 
  while (i<heap_blocks-1) {
    var block = this.alloca.blocks[i];
    block.next = i + 1;
    i++;
  }
  this.alloca.blocks[i].next=NULL;
  
  ///////////////////////////////////////////////////////
  
}

sms.prototype.destroy = function () {
  delete BufferSegments[this.key];
}

// Returns (free) a memory block. Free is either the block address or a buffer object
// with an __address attribute.
sms.prototype.free = function (free) {
  if (typeof free == 'object' && free.__address) free=free.__address;
  else if (typeof free != 'number') throw "free: argument must be an address number";
  var bblock,block = this.alloca.heap.used;
  var bprev,prev  = NULL;
  while (block != NULL) {
      bblock=this.alloca.blocks[block];
      if (free == bblock.addr) {
          if (prev != NULL) {
              bprev=this.alloca.blocks[prev];
              bprev.next = bblock.next;
          } else {
              this.alloca.heap.used = bblock.next;
          }
          this.insert_block(block);
          if (!this.alloca.disable_compact) this.compact();
          return true;
      }
      prev  = block;
      block = bblock.next;
  }
  return false;
}

sms.prototype.info = function () {
  return { fd : this.fd, size : this.size, top: this.top }
}

// insert a block (tinyalloc)
sms.prototype.insert_block = function (block,bblock) {
  if (!bblock) bblock = this.alloca.blocks[block];
  if (!this.alloca.disable_compact) {
    var bptr, ptr  = this.alloca.heap.free;
    var bprev, prev = NULL;
    while (ptr != NULL) {
        bptr = this.alloca.blocks[ptr];
        if (bblock.addr <= bptr.addr) {
            // print_s("insert");
            // print_i((size_t)ptr);
            break;
        }
        prev = ptr;
        ptr  = bptr.next;
    }
    if (prev != NULL) {
        bprev = this.alloca.blocks[prev];
        if (ptr == NULL) {
            // print_s("new tail");
        }
        bprev.next = block;
    } else {
        // print_s("new head");
        this.alloca.heap.free = block;
    }
    bblock.next = ptr;
  } else {
    bblock.next = this.alloca.heap.free;
    this.alloca.heap.free  = block;
  }
}

// compile and attach type constructor library
sms.prototype.library = function (types) {
  this.typesDef=types;
  this.types=Library(types);
  return this.types;
}

// create a lock object for an address (block) by using a shared semaphore
sms.prototype.lock = function (addr,create) {
  var level=create?1:undefined;
  var sema = semaphore('/'+addr.toString(16),level);
  return sema;
}

// Map already created shared memory segment
sms.prototype.map = function () {
  this.fd = libc.shm_open(str2buf(this.key),O_RDWR, S_IRUSR | S_IWUSR);
  if (this.fd < 0) throw "sms.open: (shm_open) failed"
  // map shm in process space
  var pa = libc.mmap(ref.NULL_POINTER, this.size ,PROT_READ | PROT_WRITE, MAP_SHARED, this.fd, 0);
  this.memory = pa;
  this.buffer = ref.reinterpret(pa, this.size, 0);
  this.buffer._key=this.key;

  /////////////// tinyalloc block management //////////////
  var blocks = ArrayType({
    addr:'int',
    next:'int',
    size:'int',
  });
  var heapControl = StructType({
    free:'int',
    used:'int',
    fresh:'int',
    top:'int'
  })
  var heap_blocks = Math.floor((this.allocasize-heapControl.size())/(SizeOf('int')*3));
  //// block lists at beginning of segment!!! ////
  this.alloca = {
    blocks : blocks(this.buffer,heapControl.size(),heap_blocks),
    heap   : heapControl(this.buffer,0),
    base   : 0,
    limit  : this.top+this.allocasize,
    max_blocks : heap_blocks-1,
    split_thresh : 16,
    alignment : 4,
    disable_compact : false,
    disable_split   : false, 
  }
  if (Options.verbose)
    console.log('[SM '+this.key+'] Mapped shared segment ('+this.allocasize+'/'+this.size+') with blocks',heap_blocks,'heap_max_blocks',this.alloca.max_blocks);
}

// allocate or share an object (scalar, struct, array)
sms.prototype.object = function (typcon,elements,address,parameter) {
  var _typcon=typcon,_elements=elements;
  if (typeof typcon == 'string') {
    if (/Array$/.test(typcon)) {
      // typed arary
      parameter=typcon.replace('Array','');
      typcon=BufferType();
    } else if (/^MatrixTA\-/.test(typcon)) {
      typcon=MatrixType(typcon.replace('MatrixTA-',''),typcon)
      elements=elements.prod();
    } else if (typcon=='Semaphore') {
      typcon=SemaType('semaphore','semaphore',elements);
      elements=1;
    } else if (typcon=='Barrier') {
      typcon=BarrierType('barrier','barrier',elements);
      elements=1;
    } else if (typcon=='Mutex') {
      typcon=MutexType('mutex','mutex');
      elements=1;
    } else if (this.types) {
      if (!this.types[typcon]) throw Error('sms.object: unknown type '+typcon);
      typcon=this.types[typcon];
    }
  }
  
  if (typeof elements == 'object' && !Utils.isArray(elements)) { parameter=elements; elements=1; }
  if (typeof elements == 'boolean') { address=elements; elements=1; }
  if (typeof elements == 'undefined') elements=1; 
  if (typeof typcon != 'function') throw Error('BufferSegment.sms.object: First argument must be a valid type constructor function');
  var size1 = typcon.size(parameter);
  if (size1==0) throw Error('BufferSegment.sms.object('+_typcon+'): Zero object/element size!');
  if (isNaN(elements)) throw Error('BufferSegment.sms.object('+_typcon+'): Invalid elements parameter!');
  if (typeof address=='undefined') address = this.calloc(size1*elements);

  if (Options.verbose) console.log('sm.object:',address,size1,elements,parameter)
  
  var obj;
  switch (typcon.class) {
    case 'Array':
    case 'MatrixTA':
      return typcon(this.buffer,address,_elements,null,this.key);
    case 'Buffer':
      var block=typcon(this.buffer,address,elements,parameter,this.key); // returns a block {addr,size,data}
      block.segment=this.key;
      return block;
    case 'Mutex':
    case 'Semaphore':
    case 'Barrier':
      return typcon(this.buffer,address,null,this.key)
    default:
      return typcon(this.buffer,address,null,this.key)
  }
}


sms.prototype.release_blocks = function (scan, to) {
  var bscan = this.alloca.blocks[scan], 
      bto = this.alloca.blocks[to],
      bscan_next, scan_next;
  while (scan != to) {
      // print_s("release");
      // print_i((size_t)scan);
      scan_next   = bscan.next;
      bscan_next  = this.alloca.blocks[scan_next];
      bscan.next  = this.alloca.heap.fresh;
      this.alloca.heap.fresh = scan;
      bscan.addr  = 0;
      bscan.size  = 0;
      scan        = scan_next;
  }
}

sms.prototype.__share = function () {
  // return an expression that can be evaluated in a remote process to create a share of this segment
  // by the shared buffer key passed to the evaluation function 'argument'
  return {data:{key:this.key,size:this.size,options:this.options,types:this.typesDef},
          eval:'function (data) { data.options.key=data.key; var sms=BufferSegment(data.size,data.options); sms.library(data.types); sms.map(); return sms; }'};
}

sms.prototype.stats = function () {
  var self=this;
  function count_blocks(ptr) {
    var bptr, num = 0;
    while (ptr != NULL) {
        num++;
        bptr = self.alloca.blocks[ptr];
        ptr = bptr.next;
    }
    return num;
  }
  return {
    free  : this.alloca.heap.free,
    used  : this.alloca.heap.used,
    fresh : this.alloca.heap.fresh,
    nfree : count_blocks(this.alloca.heap.free),
    nused : count_blocks(this.alloca.heap.used),
    nfresh : count_blocks(this.alloca.heap.fresh),
    ntotal : this.alloca.max_blocks,
  }
}
sms.version = Options.version;

BufferSegment = sms;
BufferSegment.AddrOf = AddrOf;
BufferSegment.SizeOf = SizeOf;
BufferSegment.TypeOf = TypeOf;
BufferSegment.TypeIf = TypeIf;
BufferSegment.StructType = StructType;
BufferSegment.ArrayType = ArrayType;
BufferSegment.SemaType = SemaType;
BufferSegment.BarrierType = BarrierType;
BufferSegment.MutexType = MutexType;
BufferSegment.MatrixType = MatrixType;
BufferSegment.BufferType = BufferType;
BufferSegment.options = Options;

BufferSegment.semaphore = semaphore;
BufferSegment.object = function (segment,typcon,elements,address,parameter) {
  var sm = BufferSegments[segment];
  if (!sm) return Code.error('BufferSegment.object: unknown segment '+segment);
  return sm.object(typcon,elements,address,parameter);
}
//////////////////////////////////////////////////////////////////
module.exports = BufferSegment;

};
BundleModuleCode['pcsp/sm-ipc']=function (module,exports){

/* IPC using SM1 module and named semaphores */
/*
n = the number of threads
count = 0
mutex = Semaphore(1)
barrier = Semaphore(0)


mutex.wait()
count = count + 1
if count == n: barrier.signal() # unblock ONE thread
mutex.signal()

barrier.wait()
mutex.wait()
count = count - 1
barrier.signal() # wake-up next thread
mutex.signal()

*/
Barrier.shared = function Barrier (sab,N,offset,id) {
  var self={}
  offset=offset||0;
  if (typeof sab == 'number') { N=sab; sab=null }
  var LOCKED=1, UNLOCKED=0;
  if (!sab) sab=new SharedArrayBuffer(16);
  if (id==undefined) id = Utils.uniqueID(8);
  self.__id=id;
  self._mu  = new Int32Array(sab,offset,4);
  if (N!= undefined) {
    self._mu[3] = N;
    self._mu[1] = 0;
    self._lock=BufferSegment.semaphore('/barrierlock_A_'+id,1);
    self._wait=BufferSegment.semaphore('/barrierlock_B_'+id,0);
    self._ack=BufferSegment.semaphore('/barrierlock_C_'+id,0);
  } else {
    // only map in
    self._lock=BufferSegment.semaphore('/barrierlock_A_'+id); 
    self._wait=BufferSegment.semaphore('/barrierlock_B_'+id);
    self._ack=BufferSegment.semaphore('/barrierlock_C_'+id);
    N=self._mu[3];
  }
  self.lock = function () {
    return self._lock.acquire()
  };
  self.unlock = function () {
    return self._lock.release()
  };
  self.wait = function () {
    return self._wait.acquire()    
  };
  self.signal = function () {
    return self._wait.release()    
  };
  self.waitAck = function () {
    return self._ack.acquire()    
  };
  self.signalAck = function () {
    return self._ack.release()    
  };
  self.join = function () {
    self.lock()
    if (self._mu[1]<(N-1)) {
      self._mu[1]++;
      self.unlock()
      self.wait();
      self._mu[1]--;
      self.signalAck()
      return;
    } else {
      // release barrier; start down protocol; hold the lock to prevent rejoin the barrier
      for(var i=N-1;i>=1;i--) {
        self.signal()
        self.waitAck()
      }
      self.unlock()
      return
    }
  }
  self.level = function () { return self._mu[1] },
  self.__share = function () { return {
    data : {
      offset : offset,
      id : id,
      barrier:Utils.serialize({
        Barrier : Barrier
      }),
      sab:sab.key
    },
    eval : function (data) {
      var barrier = Utils.deserialize(data.barrier)
      var sab = BufferSegments[data.key].buffer.buffer;
      return barrier.Barrier(sab,data.offset,data.id)
    }
  }}
  return self
}

Mutex.shared = function Mutex (sab,offset,id) {
  var self={}
  offset=offset||0;
  var LOCKED=1, UNLOCKED=0;
  if (!sab) sab=new SharedArrayBuffer(4);
  if (id==undefined) {
    id = Utils.uniqueID(16);
    self._lock=BufferSegment.semaphore('/mulock_A_'+id,1);
  } else {
    self._lock=BufferSegment.semaphore('/mulock_A_'+id);
  }
  self.__id=id;
  self._mu  = new Int32Array(sab,offset,1); /* not used here */
  self.lock = function () {
    return self._lock.acquire()
  };
  self.unlock = function () {
    return self._lock.release()
  };
  self.__share = function () { return {
      data : {
        offset : offset,
        id : id,
        mutex:Utils.serialize({
          Mutex : Mutex
        }),
        key:sab._key
      },
      eval : function (data) {
        var mutex = Utils.deserialize(data.sema)
        var sab = BufferSegments[data.key].buffer.buffer;
        return mutex.Mutex(sab,null,data.offset,data.id)
      }
  }}
  return self
}
  
Semaphore.shared = function Semaphore (sab,init,offset,id) {
  var self={}
  offset=offset||0;
  if (typeof sab == 'number') { init=sab; sab=null }
  var LOCKED=1, UNLOCKED=0;
  if (!sab) throw "Semaphore.shared: No SAB provided";
  if (id==undefined) id = Utils.uniqueID(16);
  self.__id=id;
  print(id)
  self._mu  = new Int32Array(sab,offset,4);
  if (init!= undefined) {
    self._mu[1] = init; 
    self._lock=BufferSegment.semaphore('/semalock_A_'+id,1);
    self._wait=BufferSegment.semaphore('/semalock_B_'+id,0);
  } else {
    // only map in
    self._lock=BufferSegment.semaphore('/semalock_A_'+id); 
    self._wait=BufferSegment.semaphore('/semalock_B_'+id); 
  }
  self.lock = function () {
    return self._lock.acquire()
  };
  self.unlock = function () {
    return self._lock.release()
  };
  self.wait = function () {
    return self._wait.acquire()    
  };
  self.signal = function () {
    return self._wait.release()    
  };
  self.acquire = function () {
    for(;;) {
      self.lock()
      if (self._mu[1]==0) {
        self.unlock()
        self.wait()
        continue;
      } else {
        self._mu[1]--;
        self.unlock()
        return
      }
    }    
  };
  self.release = function () {
    self.lock()
    if (self._mu[1]==0) {
      self._mu[1]++;
      self.signal()
    } else {
      self._mu[1]++;
    }
    self.unlock()  
  };
  self.level = function () { return self._mu[1] },
  self.__share = function () { return {
      data : {
        offset : offset,
        id : id,
        sema:Utils.serialize({
          Semaphore : Semaphore
        }),
        key:sab._key
      },
      eval : function (data) {
        var sema = Utils.deserialize(data.sema)
        var sab = BufferSegments[data.key].buffer.buffer;
        return sema.Semaphore(sab,null,data.offset,data.id)
      }
  }};
  return self
}
  
};
BundleModuleCode['pcsp/bobj']=function (module,exports){
/*
** Buffer Objects 
*/
var BufferObjects={}
BufferObjects.init = function(module) {
  var version='1.3.3'
  if (typeof BufferObjects=='undefined') BufferObjects={};
  var NULL = -1
  //////////////////// BUFFER SEGMENT OBJECT MEMORY ////////////////////
  function SizeOf(typOrObj,types,parameter) {
    if (typeof typOrObj == 'object' && typOrObj.__size) return typOrObj.__size;
    var typ = typOrObj;
    var eltyp  = typ.match(/([^\[\*]+)/)[1],
        length  = typ.match(/\[([^\]]*)\]/),  // array length if any
        pointer = typ.indexOf('*')!=-1;
    if (length) {
      length=length[1];
      if (parameter) for(var p in parameter) length=length.replace(p,parameter[p]);
      length=Number(length);
    } else length=1;
    if (pointer) return 4*length;
    eltyp=eltyp.trim();
    if (parameter && parameter[eltyp]) eltyp=parameter[eltyp];
    switch (eltyp) {
      case 'char' : return length;
      case 'int'  : return 4*length;
      case 'int32' : return 4*length;
      case 'void' : return 4*length;
      case 'float': return 4*length;
      case 'float32' : return 4*length;
      case 'double': return 8*length;
      case 'float64' : return 8*length;
      default     : if (types && types[eltyp]) return length*types[eltyp].size();
    }
  }
  function TypeOf(typ,parameter) {
    var eltyp = typ.match(/([^\[\*]+)/)[1],
        length  = typ.match(/\[([^\]]*)\]/),  // array length if any
        pointer = typ.indexOf('*')!=-1,
        array = false,
        size0,
        size; // total size of this type
    if (length) {
      length=length[1];
      if (parameter) for(var p in parameter) length=length.replace(p,parameter[p]);
      length=Number(length);
      array=true;
    } else length=1;
    eltyp=eltyp.trim();
    if (parameter && parameter[eltyp]) eltyp=parameter[eltyp];
    switch (eltyp) {
      case 'char' :  size0=1; size = 1*length ; break;
      case 'int'  :  size0=4; size = 4*length ; break;
      case 'void' :  size0=4; size = 4*length ; break;
      case 'float':  size0=4; size = 4*length ; break;
      case 'float32':  size0=4; size = 4*length ; break;
      case 'double':  size0=8; size = 8*length ; break;
      case 'float64':  size0=8; size = 8*length ; break;
    }
    if (pointer) { size0=4; size=4 };
    return { typ : eltyp, length:length, size : size, size0:size0, pointer:pointer, array:array }
  }
  function TypeIf(o) {
    if (Utils.isArray(o)) {
      return 
    }
    if (Utils.isString(o)) return 'char[]';
    if (Utils.isNumber(o)) return 'float';
    if (Utils.isObject(o)) {
      var ti={}
      for(var k in o) {
        ti[k]=TypeIf(o[k]);
      }
      return ti
    }
  }
  // Structure Type Object constructor
  function StructType(desc,name,types) {
    var typConstr = function (buf,addr,parameter,segment) {
      var bo = {}, offset=0;
      for(var key in desc) {
        var dt = TypeOf(desc[key],parameter);
        // console.log(key,dt)
        switch (dt.typ) {
          case 'int':
            if (!dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readInt32LE(addr+offset);
                },
                set(value) {
                  buf.writeInt32LE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'float':
            if (!dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readFloatLE(addr+offset);
                },
                set(value) {
                  buf.writeFloatLE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'void':      
            if (dt-pointer && !dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readInt32LE(addr+offset);
                },
                set(value) {
                  buf.writeInt32LE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'char':
            if (dt.array) {
              (function (offset,size) { Object.defineProperty(bo, key, {
                get() {
                  var end = buf.indexOf(0,addr+offset);
                  return buf.slice(addr+offset,end).toString('utf8');
                },
                set(value) {
                  Buffer(value).copy(buf,addr+offset);
                }
              })})(offset,dt.size);
              offset += dt.size;
            } else if (!dt.pointer) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return String.fromCharCode(buf[addr+offset]);
                },
                set(value) {
                  buf[addr+offset]=value.charCodeAt(0);
                }
              })})(offset);
              offset += dt.size;          
            }
            break;
          default:
            // console.log(dt);
            if (dt.pointer && !dt.array) {
               (function (offset,size,dt) { 
                  var typcon;
                  if (dt.typ==name) typcon=typConstr;
                  else if (types) typcon=types[dt.type];
                  if (!typcon) throw "typConstr: Unknown type "+dt.typ;
                  bo['_'+key]=NULL; // shadow pointer
                  var b2o,addr;
                  Object.defineProperty(bo, key, {
                  get() {
                    if (bo['_'+key]!=NULL){
                      if (!b2o || bo['_'+key]!=addr) {
                        addr=bo['_'+key];
                        b2o=typConstr(buf,addr);  // cache wrapper
                      }
                      return b2o;
                    } else throw "typConstr: NULL pointer ("+name+"."+key+")"
                  },
                  set(ref) {
                    if (typeof ref=='number') bo['_'+key]=ref;
                    if (typeof ref=='object' && ref.__address) bo['_'+key]=ref.__address;                  
                  }
                })})(offset,dt.size,dt);
                offset += dt.size;
            } else if (!dt.pointer && dt.array) {
              if (types[dt.typ]) {
              console.log(types[dt.typ])
                bo[key]=ArrayType(types[dt.typ].desc)(buf,addr+offset,dt.length);
                offset += dt.size; 
              } else throw "StructType: unknown struct type "+dt.typ;         
            }
            break;    
        }
      }
      bo.__address=addr; bo.__size=offset; bo.__desc=desc; bo.__parameter=parameter; bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.StructType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.StructType.deserialize(objdesc)}};
      }
      bo.__class='Struct';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      var dataSize=0;
      for(var key in desc) dataSize += SizeOf(desc[key],types,parameter);
      return dataSize;
    }
    typConstr.name;
    typConstr.class='Struct';
    typConstr.desc=desc;
    return typConstr;
  }
  StructType.cache=[];
  // create a share of an object //
  
  // 1. Serialize a buffer object
  StructType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  StructType.deserialize = function (buffer,share) {
    // TODO types mapping
    // TODO struct caching
    if (!share) { 
     share=buffer; 
     var sms=BufferSegments[share.segment]; 
     if (sms) buffer=sms.buffer;
   };
    if (!buffer) throw "StructType.deserialize: no buffer segment specified";
    
    var st = StructType(share.struct,share.type,share.types);
    return st(buffer,share.address,share.parameter,share.segment);
  }


  // Array Type Object constructor
  function ArrayType(desc,name,types) {
    var size1=0,computeSize;
    var typConstr = function (buf,addr,length,parameter,segment) {
      var bo = {}, size=0, internal={};
      switch (desc) {
        case 'char':
          size=1;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return String.fromCharCode(buf[addr+index*size]);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf[addr+index*size]=val.charCodeAt(0);
            },
          });
          break;
        case 'int':
        case 'int32':
        case 'void':
          size=4;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.readInt32LE(addr+index*size);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.writeInt32LE(val,addr+index*size);
            }
          });
          break;
        case 'float':
        case 'float32':
          size=4;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.readFloatLE(addr+index*size);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.writeFloatLE(val,addr+index*size);
            }
          });
          break;
        default:
          // structure type?
          if (typeof desc == 'string') {
            // find structure descriptor
            desc = types && types[desc];
          }
          if (!desc) throw ("BufferObjects.ArrayType: Cannot resolve type "+desc);
          size=0;
          if (typeof desc == 'function') size = desc.size(parameter);
          else for(var key in desc) size += SizeOf(desc[key],parameter);
          // console.log(length,parameter,size,desc)
          if (isNaN(size)) throw ("BufferObjects.ArrayType: computed size of struct is invalid ("+name+")");
          if (!(typeof desc == 'function')) {
            // we have to create a structure object each time an array element is dereferenced!
            // but caching and remembering the last access struct object wrapper
            var st = StructType(desc);
            var cache=[];
            bo = new Proxy([],{
              get : function (target,name) {
                if (typeof name == 'symbol' || isNaN(Number(name))) {
                  switch (name) {
                    case 'length':
                      return internal.__length;
                    default: return internal[name];
                  }
                };
                var index=Number(name),offset=0,ro={};
                if (length && index>length-1) throw "BufferObjects.ArrayType.get: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              },
              set : function (target,name,val) {
                if (typeof name == 'symbol' || isNaN(Number(name))) return;
                // val must be entire updated struct (for copy)
                var index=Number(name),ro={};  // requires getters and setters
                if (length && index>length-1) throw "BufferObjects.ArrayType.set: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              }
            });                  
          } else {
            var cache=[];
            var st = desc;
               
            bo = new Proxy([],{
              get : function (target,name) {
                if (typeof name == 'symbol' || isNaN(Number(name))) {
                  switch (name) {
                    case 'length':
                      return internal.__length;
                    default: return internal[name];
                  }
                };
                var index=Number(name),offset=0,ro={};
                if (length && index>length-1) throw "BufferObjects.ArrayType.get: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              },
              set : function (target,name,val) {
                if (typeof name == 'symbol' || isNaN(Number(name))) return;
                // val must be entire updated struct (for copy)
                var index=Number(name),ro={};  // requires getters and setters
                if (length && index>length-1) throw "BufferObjects.ArrayType.set: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              }
            });                  
          }
          break;
      }
      // We can't attach the attributes to bo due to the Proxy wrapper
      internal.__address=addr; 
      internal.__size=size*length; 
      internal.__desc=typeof desc == 'function'?desc.desc:desc; 
      internal.__parameter=parameter; internal.__type=name;
      internal.__segment=segment; bo.__class='Array';
      internal.__length = length;
      internal.__share  = function () {
        /* TODO */
        return {data:BufferObjects.ArrayType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.ArrayType.deserialize(objdesc)}};
      }
      size1=size;
      return bo;
    }
    computeSize=false;
    typConstr.size=function (parameter) {
      if (!computeSize) {
        computeSize=true;
        typConstr({},0,0);
      }
      return size1;
    };
    typConstr.class='Array';
    typConstr.name=name;
    typConstr.desc=desc;  
    return typConstr;  
  }
  // 1. Serialize a buffer object
  ArrayType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment, length:bo.__length } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  ArrayType.deserialize = function (buffer,share) {
    // TODO types mapping
    // TODO struct caching
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "ArrayType.deserialize: no buffer segment specified";
    
    var st = ArrayType(share.struct,share.type,share.types);
    return st(buffer,share.address,share.parameter,share.segment);
  }

  // Matrix Type Object constructor
  // desc=='Float32'|...
  function MatrixType(desc,name) {
    var size1=0;
    var datatype = 'Float32';
    var typConstr = function (buf,addr,length,parameter,segment) {
      var bytesize;
      var bo=Math.MatrixTA({data:function (size) {
        bytesize=size;
        return buf.buffer
      },rows:length[0],columns:length[1],datatype:datatype,offset:addr})
      // length must be a dataspace array
      bo.__address=addr; 
      bo.__size=bytesize; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__length = length;
      bo.__share=function () {
        return {data:BufferObjects.MatrixType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.MatrixType.deserialize(objdesc)}};
      }
      bo.__class='Struct';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 4
    }
    typConstr.name=name;
    typConstr.class='MatrixTA';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  MatrixType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment, length:bo.__length } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  MatrixType.deserialize = function (buffer,share) {
    if (!share) { 
     share=buffer; 
     var sms=BufferSegments[share.segment]; 
     if (sms) buffer=sms.buffer;
   };
    if (!buffer) throw "MatrixType.deserialize: no buffer segment specified";
    
    var st = MatrixType(share.struct,share.type);
    return st(buffer,share.address,share.length,share.segment);
  }


  function BarrierType(desc,name,N,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.barrier?Code.barrier.shared:Barrier)(buf.buffer,N,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.BarrierType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.BarrierType.deserialize(objdesc)}};
      }
      bo.__class='Barrier';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Barrier';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  BarrierType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type,  id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  BarrierType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "BarrierType.deserialize: no buffer segment specified";
    
    var st = BarrierType(share.struct,share.type,null,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }


  function MutexType(desc,name,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.mutex?Code.mutex.shared:Mutex)(buf.buffer,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.MutexType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.MutexType.deserialize(objdesc)}};
      }
      bo.__class='Mutex';
      return bo;
    }
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Mutex';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  MutexType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  MutexType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "SemaType.deserialize: no buffer segment specified";
    
    var st = MutexType(share.struct,share.type,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }
 
 
  function SemaType(desc,name,init,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.semaphore?Code.semaphore.shared:Semaphore)(buf.buffer,init,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.SemaType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.SemaType.deserialize(objdesc)}};
      }
      bo.__class='Semaphore';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Semaphore';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  SemaType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  SemaType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "SemaType.deserialize: no buffer segment specified";
    
    var st = SemaType(share.struct,share.type,null,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }
  
  // Generic buffer type support (can by typed arrays, too)
  // In contrast to arrays always shared buffer (array), i.e., a slice of segment buffer
  // Returns a block descriptor
  function BufferType () {
    function typConstr(buf,addr,length,datatype,segment) {
      // we can only slice (sharing) the main segment buffer with typearrays!
      console.log('BufferType',addr,length,datatype);
      return {
        data  : new Utils.TypedArrayOfName[datatype+'Array'](buf.buffer,addr /* bytes! */ ,length /* # elements */ ),
        addr  : addr,
        size  : length,
        datatype : datatype,
        segment : segment,
      }
    };
    typConstr.size = function (elements,datatype) {
      datatype=datatype||'Uint8';
      return elements*Utils.DataSize[datatype];
    }
    typConstr.class = 'Buffer';
    typConstr.name = 'buffer';
    return typConstr;
  }
  
  function AddrOf (bo) {
    return bo.__address
  }
  
  function Library (types) {
    var compiled={}
    for(var t in types) {
      // Type descriptor to be compiled
      if (!Utils.isArray(types[t])) compiled[t]=StructType(types[t],t,compiled);
      else compiled[t]=ArrayType(types[t][0],t,compiled);
    }
    return compiled;
  }
  Object.assign(BufferObjects ,{
    AddrOf  : AddrOf,
    SizeOf  : SizeOf,
    TypeOf  : TypeOf,
    TypeIf  : TypeIf,
    StructType  : StructType,
    ArrayType   : ArrayType,
    MatrixType  : MatrixType,
    BufferType  : BufferType,
    BarrierType : BarrierType,
    MutexType   : MutexType,
    SemaType    : SemaType,
    Library : Library,
    version : version
  }) 
  if (module!=undefined)
    module.exports = {
      AddrOf:AddrOf,
      SizeOf:SizeOf,
      TypeOf:TypeOf,
      TypeIf:TypeIf,
      StructType  : StructType,
      ArrayType   : ArrayType,
      MatrixType  : MatrixType,
      BufferType  : BufferType,
      BarrierType : BarrierType,
      MutexType   : MutexType,
      SemaType    : SemaType,
      Library : Library,
      version : version
    }   
}
BufferObjects.init(module)


};
BundleModuleCode['Worker.js']=function (module,exports){
// Worker Class (Code.worker and Code.shellworker wrapper)
var __shells={};

function Worker(url,id,options) {
  var self=this;
  if (!(this instanceof Worker)) return new Worker(url,id,options);
  
  options=options||{}
  if (/http\:|https\:|ws\:/.test(url)) this.url=url;
  else if (typeof url != 'object') this.id=this.url;
  if (typeof options=='object') this.options=options;
  else if (typeof id=='object') this.options=id;
  else if (typeof url=='object') this.options=url;
  return new Promise(async function (resolve,reject) {
    try { await self.init(); } catch (e) { reject(e) }
    resolve(self);
  });
}
Worker.prototype.init = async function () {
  if (this.url==undefined) {
    this.worker = Code.worker.create(this.id,this.options);
  } else if (/http\:|https\:|ws\:/.test(this.url)) {
    // Remote Code.shellworker
    // 1. Connect to shell
    await Code.shellworker.connect(this.url);
    // 2. Create worker
    this.shellworker = await Code.shellworker.create(this.url,this.id,this.options);
  }
}
Worker.prototype.cancel = function () {
  if (this.worker!=undefined) return Code.worker.cancel(this.worker);
  else return Code.shellworker.cancel(this.shellworker);
}
Worker.prototype.emit = function (ev,data) {
  if (this.worker!=undefined) return Code.worker.emit(this.worker,ev,data);
  else return Code.shellworker.emit(this.shellworker,ev,data);
}
Worker.prototype.eval = function (fun,data,shared,assign) {
  if (this.worker!=undefined) return Code.worker.evalf(this.worker,fun,data,shared,assign);
  else return Code.shellworker.evalf(this.shellworker,fun,data,shared,assign);
}
Worker.prototype.kill = function () {
  if (this.worker!=undefined) return Code.worker.kill(this.worker);
  else return Code.shellworker.kill(this.shellworker);
}
Worker.prototype.monitor = function (key,level,verbose) {
  if (this.worker!=undefined) return Code.worker.monitor(this.worker,key,level,verbosen);
  else return Code.shellworker.monitor(this.shellworker,key,level,verbose);

}
Worker.prototype.ready = async function () {
  if (this.worker!=undefined) return Code.worker.ready(this.worker);
  else return Code.shellworker.ready(this.shellworker);
}
Worker.prototype.read = function (key) {
  if (this.worker!=undefined) return Code.worker.read(this.worker,key);
  else return Code.shellworker.read(this.shellworker,key);
}
Worker.prototype.receive = function () {
  if (this.worker!=undefined) return Code.worker.receive(this.worker);
  else return Code.shellworker.receive(this.shellworker);
}
Worker.prototype.run = function (code,console) {
  if (this.worker!=undefined) return Code.worker.run(this.worker,code,console);
  else return Code.shellworker.run(this.shellworker,code,console);
}
Worker.prototype.send = function (data) {
  if (this.worker!=undefined) return Code.worker.send(this.worker,data);
  else return Code.shellworker.send(this.shellworker,data);
}
Worker.prototype.share = function (key,data,eval) {
  if (this.worker!=undefined) return Code.worker.share(this.worker,key,data,eval);
}
Worker.prototype.signal = function (signal,data) {
  if (this.worker!=undefined) return Code.worker.signal(this.worker,signal,data);
  else return Code.shellworker.signal(this.shellworker,signal,data);
}
Worker.prototype.status = function () {
  if (this.worker!=undefined) return Code.worker.status(this.worker);
  else return Code.shellworker.status(this.shellworker);
}
Worker.prototype.write = function (key,val) {
  if (this.worker!=undefined) return Code.worker.write(this.worker,key,val);
  else return Code.shellworker.write(this.shellworker,key,val);
}

if (typeof module == 'object') module.exports = Worker;

};
BundleModuleCode['plugins/pcsp/bobj.js']=function (module,exports){
/*
** Buffer Objects 
*/
var BufferObjects={}
BufferObjects.init = function(module) {
  var version='1.3.3'
  if (typeof BufferObjects=='undefined') BufferObjects={};
  var NULL = -1
  //////////////////// BUFFER SEGMENT OBJECT MEMORY ////////////////////
  function SizeOf(typOrObj,types,parameter) {
    if (typeof typOrObj == 'object' && typOrObj.__size) return typOrObj.__size;
    var typ = typOrObj;
    var eltyp  = typ.match(/([^\[\*]+)/)[1],
        length  = typ.match(/\[([^\]]*)\]/),  // array length if any
        pointer = typ.indexOf('*')!=-1;
    if (length) {
      length=length[1];
      if (parameter) for(var p in parameter) length=length.replace(p,parameter[p]);
      length=Number(length);
    } else length=1;
    if (pointer) return 4*length;
    eltyp=eltyp.trim();
    if (parameter && parameter[eltyp]) eltyp=parameter[eltyp];
    switch (eltyp) {
      case 'char' : return length;
      case 'int'  : return 4*length;
      case 'int32' : return 4*length;
      case 'void' : return 4*length;
      case 'float': return 4*length;
      case 'float32' : return 4*length;
      case 'double': return 8*length;
      case 'float64' : return 8*length;
      default     : if (types && types[eltyp]) return length*types[eltyp].size();
    }
  }
  function TypeOf(typ,parameter) {
    var eltyp = typ.match(/([^\[\*]+)/)[1],
        length  = typ.match(/\[([^\]]*)\]/),  // array length if any
        pointer = typ.indexOf('*')!=-1,
        array = false,
        size0,
        size; // total size of this type
    if (length) {
      length=length[1];
      if (parameter) for(var p in parameter) length=length.replace(p,parameter[p]);
      length=Number(length);
      array=true;
    } else length=1;
    eltyp=eltyp.trim();
    if (parameter && parameter[eltyp]) eltyp=parameter[eltyp];
    switch (eltyp) {
      case 'char' :  size0=1; size = 1*length ; break;
      case 'int'  :  size0=4; size = 4*length ; break;
      case 'void' :  size0=4; size = 4*length ; break;
      case 'float':  size0=4; size = 4*length ; break;
      case 'float32':  size0=4; size = 4*length ; break;
      case 'double':  size0=8; size = 8*length ; break;
      case 'float64':  size0=8; size = 8*length ; break;
    }
    if (pointer) { size0=4; size=4 };
    return { typ : eltyp, length:length, size : size, size0:size0, pointer:pointer, array:array }
  }
  function TypeIf(o) {
    if (Utils.isArray(o)) {
      return 
    }
    if (Utils.isString(o)) return 'char[]';
    if (Utils.isNumber(o)) return 'float';
    if (Utils.isObject(o)) {
      var ti={}
      for(var k in o) {
        ti[k]=TypeIf(o[k]);
      }
      return ti
    }
  }
  // Structure Type Object constructor
  function StructType(desc,name,types) {
    var typConstr = function (buf,addr,parameter,segment) {
      var bo = {}, offset=0;
      for(var key in desc) {
        var dt = TypeOf(desc[key],parameter);
        // console.log(key,dt)
        switch (dt.typ) {
          case 'int':
            if (!dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readInt32LE(addr+offset);
                },
                set(value) {
                  buf.writeInt32LE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'float':
            if (!dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readFloatLE(addr+offset);
                },
                set(value) {
                  buf.writeFloatLE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'void':      
            if (dt-pointer && !dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readInt32LE(addr+offset);
                },
                set(value) {
                  buf.writeInt32LE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'char':
            if (dt.array) {
              (function (offset,size) { Object.defineProperty(bo, key, {
                get() {
                  var end = buf.indexOf(0,addr+offset);
                  return buf.slice(addr+offset,end).toString('utf8');
                },
                set(value) {
                  Buffer(value).copy(buf,addr+offset);
                }
              })})(offset,dt.size);
              offset += dt.size;
            } else if (!dt.pointer) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return String.fromCharCode(buf[addr+offset]);
                },
                set(value) {
                  buf[addr+offset]=value.charCodeAt(0);
                }
              })})(offset);
              offset += dt.size;          
            }
            break;
          default:
            // console.log(dt);
            if (dt.pointer && !dt.array) {
               (function (offset,size,dt) { 
                  var typcon;
                  if (dt.typ==name) typcon=typConstr;
                  else if (types) typcon=types[dt.type];
                  if (!typcon) throw "typConstr: Unknown type "+dt.typ;
                  bo['_'+key]=NULL; // shadow pointer
                  var b2o,addr;
                  Object.defineProperty(bo, key, {
                  get() {
                    if (bo['_'+key]!=NULL){
                      if (!b2o || bo['_'+key]!=addr) {
                        addr=bo['_'+key];
                        b2o=typConstr(buf,addr);  // cache wrapper
                      }
                      return b2o;
                    } else throw "typConstr: NULL pointer ("+name+"."+key+")"
                  },
                  set(ref) {
                    if (typeof ref=='number') bo['_'+key]=ref;
                    if (typeof ref=='object' && ref.__address) bo['_'+key]=ref.__address;                  
                  }
                })})(offset,dt.size,dt);
                offset += dt.size;
            } else if (!dt.pointer && dt.array) {
              if (types[dt.typ]) {
              console.log(types[dt.typ])
                bo[key]=ArrayType(types[dt.typ].desc)(buf,addr+offset,dt.length);
                offset += dt.size; 
              } else throw "StructType: unknown struct type "+dt.typ;         
            }
            break;    
        }
      }
      bo.__address=addr; bo.__size=offset; bo.__desc=desc; bo.__parameter=parameter; bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.StructType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.StructType.deserialize(objdesc)}};
      }
      bo.__class='Struct';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      var dataSize=0;
      for(var key in desc) dataSize += SizeOf(desc[key],types,parameter);
      return dataSize;
    }
    typConstr.name;
    typConstr.class='Struct';
    typConstr.desc=desc;
    return typConstr;
  }
  StructType.cache=[];
  // create a share of an object //
  
  // 1. Serialize a buffer object
  StructType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  StructType.deserialize = function (buffer,share) {
    // TODO types mapping
    // TODO struct caching
    if (!share) { 
     share=buffer; 
     var sms=BufferSegments[share.segment]; 
     if (sms) buffer=sms.buffer;
   };
    if (!buffer) throw "StructType.deserialize: no buffer segment specified";
    
    var st = StructType(share.struct,share.type,share.types);
    return st(buffer,share.address,share.parameter,share.segment);
  }


  // Array Type Object constructor
  function ArrayType(desc,name,types) {
    var size1=0,computeSize;
    var typConstr = function (buf,addr,length,parameter,segment) {
      var bo = {}, size=0, internal={};
      switch (desc) {
        case 'char':
          size=1;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return String.fromCharCode(buf[addr+index*size]);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf[addr+index*size]=val.charCodeAt(0);
            },
          });
          break;
        case 'int':
        case 'int32':
        case 'void':
          size=4;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.readInt32LE(addr+index*size);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.writeInt32LE(val,addr+index*size);
            }
          });
          break;
        case 'float':
        case 'float32':
          size=4;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.readFloatLE(addr+index*size);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.writeFloatLE(val,addr+index*size);
            }
          });
          break;
        default:
          // structure type?
          if (typeof desc == 'string') {
            // find structure descriptor
            desc = types && types[desc];
          }
          if (!desc) throw ("BufferObjects.ArrayType: Cannot resolve type "+desc);
          size=0;
          if (typeof desc == 'function') size = desc.size(parameter);
          else for(var key in desc) size += SizeOf(desc[key],parameter);
          // console.log(length,parameter,size,desc)
          if (isNaN(size)) throw ("BufferObjects.ArrayType: computed size of struct is invalid ("+name+")");
          if (!(typeof desc == 'function')) {
            // we have to create a structure object each time an array element is dereferenced!
            // but caching and remembering the last access struct object wrapper
            var st = StructType(desc);
            var cache=[];
            bo = new Proxy([],{
              get : function (target,name) {
                if (typeof name == 'symbol' || isNaN(Number(name))) {
                  switch (name) {
                    case 'length':
                      return internal.__length;
                    default: return internal[name];
                  }
                };
                var index=Number(name),offset=0,ro={};
                if (length && index>length-1) throw "BufferObjects.ArrayType.get: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              },
              set : function (target,name,val) {
                if (typeof name == 'symbol' || isNaN(Number(name))) return;
                // val must be entire updated struct (for copy)
                var index=Number(name),ro={};  // requires getters and setters
                if (length && index>length-1) throw "BufferObjects.ArrayType.set: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              }
            });                  
          } else {
            var cache=[];
            var st = desc;
               
            bo = new Proxy([],{
              get : function (target,name) {
                if (typeof name == 'symbol' || isNaN(Number(name))) {
                  switch (name) {
                    case 'length':
                      return internal.__length;
                    default: return internal[name];
                  }
                };
                var index=Number(name),offset=0,ro={};
                if (length && index>length-1) throw "BufferObjects.ArrayType.get: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              },
              set : function (target,name,val) {
                if (typeof name == 'symbol' || isNaN(Number(name))) return;
                // val must be entire updated struct (for copy)
                var index=Number(name),ro={};  // requires getters and setters
                if (length && index>length-1) throw "BufferObjects.ArrayType.set: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              }
            });                  
          }
          break;
      }
      // We can't attach the attributes to bo due to the Proxy wrapper
      internal.__address=addr; 
      internal.__size=size*length; 
      internal.__desc=typeof desc == 'function'?desc.desc:desc; 
      internal.__parameter=parameter; internal.__type=name;
      internal.__segment=segment; bo.__class='Array';
      internal.__length = length;
      internal.__share  = function () {
        /* TODO */
        return {data:BufferObjects.ArrayType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.ArrayType.deserialize(objdesc)}};
      }
      size1=size;
      return bo;
    }
    computeSize=false;
    typConstr.size=function (parameter) {
      if (!computeSize) {
        computeSize=true;
        typConstr({},0,0);
      }
      return size1;
    };
    typConstr.class='Array';
    typConstr.name=name;
    typConstr.desc=desc;  
    return typConstr;  
  }
  // 1. Serialize a buffer object
  ArrayType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment, length:bo.__length } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  ArrayType.deserialize = function (buffer,share) {
    // TODO types mapping
    // TODO struct caching
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "ArrayType.deserialize: no buffer segment specified";
    
    var st = ArrayType(share.struct,share.type,share.types);
    return st(buffer,share.address,share.parameter,share.segment);
  }

  // Matrix Type Object constructor
  // desc=='Float32'|...
  function MatrixType(desc,name) {
    var size1=0;
    var datatype = 'Float32';
    var typConstr = function (buf,addr,length,parameter,segment) {
      var bytesize;
      var bo=Math.MatrixTA({data:function (size) {
        bytesize=size;
        return buf.buffer
      },rows:length[0],columns:length[1],datatype:datatype,offset:addr})
      // length must be a dataspace array
      bo.__address=addr; 
      bo.__size=bytesize; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__length = length;
      bo.__share=function () {
        return {data:BufferObjects.MatrixType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.MatrixType.deserialize(objdesc)}};
      }
      bo.__class='Struct';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 4
    }
    typConstr.name=name;
    typConstr.class='MatrixTA';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  MatrixType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment, length:bo.__length } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  MatrixType.deserialize = function (buffer,share) {
    if (!share) { 
     share=buffer; 
     var sms=BufferSegments[share.segment]; 
     if (sms) buffer=sms.buffer;
   };
    if (!buffer) throw "MatrixType.deserialize: no buffer segment specified";
    
    var st = MatrixType(share.struct,share.type);
    return st(buffer,share.address,share.length,share.segment);
  }


  function BarrierType(desc,name,N,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.barrier?Code.barrier.shared:Barrier)(buf.buffer,N,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.BarrierType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.BarrierType.deserialize(objdesc)}};
      }
      bo.__class='Barrier';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Barrier';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  BarrierType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type,  id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  BarrierType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "BarrierType.deserialize: no buffer segment specified";
    
    var st = BarrierType(share.struct,share.type,null,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }


  function MutexType(desc,name,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.mutex?Code.mutex.shared:Mutex)(buf.buffer,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.MutexType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.MutexType.deserialize(objdesc)}};
      }
      bo.__class='Mutex';
      return bo;
    }
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Mutex';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  MutexType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  MutexType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "SemaType.deserialize: no buffer segment specified";
    
    var st = MutexType(share.struct,share.type,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }
 
 
  function SemaType(desc,name,init,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.semaphore?Code.semaphore.shared:Semaphore)(buf.buffer,init,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.SemaType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.SemaType.deserialize(objdesc)}};
      }
      bo.__class='Semaphore';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Semaphore';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  SemaType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  SemaType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "SemaType.deserialize: no buffer segment specified";
    
    var st = SemaType(share.struct,share.type,null,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }
  
  // Generic buffer type support (can by typed arrays, too)
  // In contrast to arrays always shared buffer (array), i.e., a slice of segment buffer
  // Returns a block descriptor
  function BufferType () {
    function typConstr(buf,addr,length,datatype,segment) {
      // we can only slice (sharing) the main segment buffer with typearrays!
      console.log('BufferType',addr,length,datatype);
      return {
        data  : new Utils.TypedArrayOfName[datatype+'Array'](buf.buffer,addr /* bytes! */ ,length /* # elements */ ),
        addr  : addr,
        size  : length,
        datatype : datatype,
        segment : segment,
      }
    };
    typConstr.size = function (elements,datatype) {
      datatype=datatype||'Uint8';
      return elements*Utils.DataSize[datatype];
    }
    typConstr.class = 'Buffer';
    typConstr.name = 'buffer';
    return typConstr;
  }
  
  function AddrOf (bo) {
    return bo.__address
  }
  
  function Library (types) {
    var compiled={}
    for(var t in types) {
      // Type descriptor to be compiled
      if (!Utils.isArray(types[t])) compiled[t]=StructType(types[t],t,compiled);
      else compiled[t]=ArrayType(types[t][0],t,compiled);
    }
    return compiled;
  }
  Object.assign(BufferObjects ,{
    AddrOf  : AddrOf,
    SizeOf  : SizeOf,
    TypeOf  : TypeOf,
    TypeIf  : TypeIf,
    StructType  : StructType,
    ArrayType   : ArrayType,
    MatrixType  : MatrixType,
    BufferType  : BufferType,
    BarrierType : BarrierType,
    MutexType   : MutexType,
    SemaType    : SemaType,
    Library : Library,
    version : version
  }) 
  if (module!=undefined)
    module.exports = {
      AddrOf:AddrOf,
      SizeOf:SizeOf,
      TypeOf:TypeOf,
      TypeIf:TypeIf,
      StructType  : StructType,
      ArrayType   : ArrayType,
      MatrixType  : MatrixType,
      BufferType  : BufferType,
      BarrierType : BarrierType,
      MutexType   : MutexType,
      SemaType    : SemaType,
      Library : Library,
      version : version
    }   
}
BufferObjects.init(module)


};
BundleModuleCode['cache']=function (module,exports){
// https://github.com/naugtur/safe-memory-cache
// Universal size- and volume constrained cache module
/*
typeof @options = {
  limit   : 40,
  volume  : 1E5,
  maxTTL  : 60000,
  buckets : 4,
  cleanupListener : function (dropped) {
    print(Array.from( dropped.keys() ))
  },
*/
function createMem(number, limit, volume) {
    var mem = Object.create(bucketsProto)
    mem.N = number
    mem.max = limit
    mem.maxVolume = volume
    mem.clear()
    return mem
}

function sizeOf(o) {
  if (typeof o == 'string') return 8;
  if (o instanceof Array) return 8;
  if (o instanceof Uint8Array) return 1;
  if (o instanceof Uint16Array) return 2;
  if (o instanceof Uint32Array) return 4;
  if (o instanceof Int8Array) return 1;
  if (o instanceof Int16Array) return 2;
  if (o instanceof Int32Array) return 4;
  if (o instanceof Float32Array) return 4;
  if (o instanceof Float64Array) return 8;
}

var bucketsProto = {
    clear: function clear() {
        this.size = 0;
        this.volume = 0;  // TODO: volumen / bucket
        this.buckets = [];
        for (var i = 0; i < this.N; i++) {
            this.spawnBucket()
        }
    },
    spawnBucket: function spawnBucket() {
        this.buckets.unshift(new Map())
    },
    rotateBuckets: function rotateBuckets() {
        var dropped = this.buckets.pop()
        this.spawnBucket()
        this.size = 0;
        this.volume = 0;
        if (this.rotationHook) {
            this.rotationHook(dropped)
        }
    },
    set: function set(key, value) {
        if (!(this.buckets[0].has(key))) {
            this.size++;
            if (value.length) this.volume += (value.length*8);
            else if (value.data && value.data.length) {
              this.volume += (value.data.length*4) // TODO
            }
            if ((this.max && this.size >= Math.ceil(this.max / this.buckets.length)) ||
                (this.maxVolume && this.volume >= Math.ceil(this.maxVolume / this.buckets.length))) {
                this.rotateBuckets()
            }
        }
        this.buckets[0].set(key, value)
        return value
    },
    get: function get(key) {
        for (var i = 0; i < this.buckets.length; i++) {
            if (this.buckets[i].has(key)) {
                //todo: this should be configurable
                if (i) {
                    //put a reference in the newest bucket
                    return this.set(key, this.buckets[i].get(key))
                }
                return this.buckets[i].get(key)
            }
        }
    }
}



module.exports = 
    function safeMemoryCache(opts) {
        opts=opts||{};
        var buckets = ~~(opts.buckets) || 4;
        var mem = createMem(buckets, opts.limit || 100, opts.volume|| 1E6)
        mem.rotationHook = opts.cleanupListener || null

        if (opts.maxTTL) {
            var intervalHandle = setInterval(mem.rotateBuckets.bind(mem), ~~(opts.maxTTL / buckets))
        }

        return {
            set: mem.set.bind(mem),
            get: mem.get.bind(mem),
            clear: mem.clear.bind(mem),
            destroy: function () {
                clearInterval(intervalHandle)
            },
            _get_buckets: function () {
                return mem.buckets
            },
            _rotate_buckets: function () {
                return mem.rotateBuckets()
            }
        }

    }

};
BundleModuleCode['yaml']=function (module,exports){
/*
YAML parser (and simple printer) for Javascript
Author: Diogo Costa

This program is released under the MIT License as follows:

Copyright (c) 2011 Diogo Costa (costa.h4evr@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

/**
 * @name YAML
 * @namespace
*/

var YAML = 
(function() {
    function isDate(value) {
        var dateFormat1 = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/,
            dateFormat2 = /^([0-9]{2,4})-([0-1][0-9])-([0-3][0-9])(?:( [0-2][0-9]):([0-5][0-9]):([0-5][0-9]))?$/,
            dateFormat3 = /[A-Z][a-z]+[ ][A-Z][a-z]+[ ][0-9]+[ ][0-9]+[ ]\d+:\d+:\d+[ ]/;
        return dateFormat1.test(value) || 
               dateFormat2.test(value) ||
               dateFormat3.test(value);
    }
    var errors = [],
        reference_blocks = [],
        processing_time = 0,
        regex =
        {
            "regLevel" : new RegExp("^([\\s\\-]+)"),
            "invalidLine" : new RegExp("^\\-\\-\\-|^\\.\\.\\.|^\\s*#.*|^\\s*$"),
            "dashesString" : new RegExp("^\\s*\\\"([^\\\"]*)\\\"\\s*$"),
            "quotesString" : new RegExp("^\\s*\\\'([^\\\']*)\\\'\\s*$"),
            "float" : new RegExp("^[+-]?[0-9]+\\.[0-9]+(e[+-]?[0-9]+(\\.[0-9]+)?)?$"),
            "integer" : new RegExp("^[+-]?[0-9]+$"),
            // @blab+: prevent array matching within text            
            "array" : new RegExp("^\\[\\s*(.*)\\s*\\]"),
            "map" : new RegExp("\\{\\s*(.*)\\s*\\}"),
            "key_value" : new RegExp("([a-z0-9_-][ a-z0-9_-]*):( .+)", "i"),
            "single_key_value" : new RegExp("^([a-z0-9_-][ a-z0-9_-]*):( .+?)$", "i"),
            // @balb+: prevent key matching in quoted strings in list items: ^[^\"a-z0-9_-]*
            "key" : new RegExp("^[^\"a-z0-9_-]*([a-z0-9_-][ a-z0-9_-]+):( .+)?", "i"),
            "item" : new RegExp("^-\\s+"),
            "trim" : new RegExp("^\\s+|\\s+$"),
            "comment" : new RegExp("([^\\\'\\\"#]+([\\\'\\\"][^\\\'\\\"]*[\\\'\\\"])*)*(#.*)?")
        };
 
     /**
      * @class A block of lines of a given level.
      * @param {int} lvl The block's level.
      * @private
      */
    function Block(lvl) {
        return {
            /* The block's parent */
            parent: null,
            /* Number of children */
            length: 0,
            /* Block's level */
            level: lvl,
            /* Lines of code to process */
            lines: [],
            /* Blocks with greater level */
            children : [],
            /* Add a block to the children collection */
            addChild : function(obj) {
                this.children.push(obj);
                obj.parent = this;
                ++this.length;
            }
        };
    }

    // function to create an XMLHttpClient in a cross-browser manner
    function createXMLHTTPRequest() {
        var xmlhttp;
        
        try {
            // Mozilla / Safari / IE7
            xmlhttp = new XMLHttpRequest();
        } catch (e) {
            // IE
            var XMLHTTP_IDS = new Array('MSXML2.XMLHTTP.5.0',
            'MSXML2.XMLHTTP.4.0',
            'MSXML2.XMLHTTP.3.0',
            'MSXML2.XMLHTTP',
            'Microsoft.XMLHTTP' );
            var success = false;
            for (var i=0;i < XMLHTTP_IDS.length && !success; i++) {
                try {
                xmlhttp = new ActiveXObject(XMLHTTP_IDS[i]);
                success = true;
                } catch (e) {}
            }
            if (!success) {
                throw new Error('Unable to create XMLHttpRequest.');
            }
        }
        
        return xmlhttp;
    }

    function fromURL(src, ondone) {
        var client = createXMLHTTPRequest();
        client.onreadystatechange = function() {
            if (this.readyState == 4 || this.status == 200) {
                var txt = this.responseText;
                ondone(YAML.eval(txt));
            }
        };
        client.open('GET', src);
        client.send();
    }

    function parser(str) {
        var regLevel = regex["regLevel"];
        var invalidLine = regex["invalidLine"];
        var lines = str.split("\n");
        var m;
        var level = 0, curLevel = 0;
        
        var blocks = [];
        
        var result = new Block(-1);
        var currentBlock = new Block(0);
        result.addChild(currentBlock);
        var levels = [];
        var line = "";
        
        blocks.push(currentBlock);
        levels.push(level);
        
        for(var i = 0, len = lines.length; i < len; ++i) {
            line = lines[i];
           
            if(line.match(invalidLine)) {
                continue;
            }
        
            if(m = regLevel.exec(line)) {
                level = m[1].length;
            } else
                level = 0;
            
            if(level > curLevel) {
                var oldBlock = currentBlock;
                currentBlock = new Block(level);
                oldBlock.addChild(currentBlock);
                blocks.push(currentBlock);
                levels.push(level);
            } else if(level < curLevel) {                
                var added = false;

                var k = levels.length - 1;
                for(; k >= 0; --k) {
                    if(levels[k] == level) {
                        currentBlock = new Block(level);
                        blocks.push(currentBlock);
                        levels.push(level);
                        if(blocks[k].parent!= null)
                            blocks[k].parent.addChild(currentBlock);
                        added = true;
                        break;
                    }
                }
                
                if(!added) {
                    errors.push("Error: Invalid indentation at line " + i + ": " + line);
                    return;
                }
            }
            
            currentBlock.lines.push(line.replace(regex["trim"], ""));
            curLevel = level;
        }
        
        return result;
    }
    
    function processValue(val) {
        val = val.replace(regex["trim"], "");
        var m = null;

        if(val == 'true') {
            return true;
        } else if(val == 'false') {
            return false;
        } else if(val == '.NaN') {
            return Number.NaN;
        } else if(val == 'null') {
            return null;
        } else if(val == '.inf') {
            return Number.POSITIVE_INFINITY;
        } else if(val == '-.inf') {
            return Number.NEGATIVE_INFINITY;
        } else if(m = val.match(regex["dashesString"])) {
            return m[1];
        } else if(m = val.match(regex["quotesString"])) {
            return m[1];
        } else if(m = val.match(regex["float"])) {
            return parseFloat(m[0]);
        } else if(m = val.match(regex["integer"])) {
            return parseInt(m[0]);
        } else if( isDate(val) ) {
            return new Date(m);
        } else if(m = val.match(regex["single_key_value"])) {
            var res = {};
            res[m[1]] = processValue(m[2]);
            return res;
        } else if(m = val.match(regex["array"])){
            var count = 0, c = ' ';
            var res = [];
            var content = "";
            var str = false;
            for(var j = 0, lenJ = m[1].length; j < lenJ; ++j) {
                c = m[1][j];
                if(c == '\'' || c == '"') {
                    if(str === false) {
                        str = c;
                        content += c;
                        continue;
                    } else if((c == '\'' && str == '\'') || (c == '"' && str == '"')) {
                        str = false;
                        content += c;
                        continue;
                    }
                } else if(str === false && (c == '[' || c == '{')) {
                    ++count;
                } else if(str === false && (c == ']' || c == '}')) {
                    --count;
                } else if(str === false && count == 0 && c == ',') {
                    res.push(processValue(content));
                    content = "";
                    continue;
                }
                
                content += c;
            }
            
            if(content.length > 0)
                res.push(processValue(content));
            return res;
        } else if(m = val.match(regex["map"])){
            var count = 0, c = ' ';
            var res = [];
            var content = "";
            var str = false;
            for(var j = 0, lenJ = m[1].length; j < lenJ; ++j) {
                c = m[1][j];
                if(c == '\'' || c == '"') {
                    if(str === false) {
                        str = c;
                        content += c;
                        continue;
                    } else if((c == '\'' && str == '\'') || (c == '"' && str == '"')) {
                        str = false;
                        content += c;
                        continue;
                    }
                } else if(str === false && (c == '[' || c == '{')) {
                    ++count;
                } else if(str === false && (c == ']' || c == '}')) {
                    --count;
                } else if(str === false && count == 0 && c == ',') {
                    res.push(content);
                    content = "";
                    continue;
                }
                
                content += c;
            }
            
            if(content.length > 0)
                res.push(content);
                
            var newRes = {};
            for(var j = 0, lenJ = res.length; j < lenJ; ++j) {
                if(m = res[j].match(regex["key_value"])) {
                    newRes[m[1]] = processValue(m[2]);
                }
            }
            
            return newRes;
        } else 
            return val;
    }
    
    function processFoldedBlock(block) {
        var lines = block.lines;
        var children = block.children;
        var str = lines.join(" ");
        var chunks = [str];
        for(var i = 0, len = children.length; i < len; ++i) {
            chunks.push(processFoldedBlock(children[i]));
        }
        return chunks.join("\n");
    }
    
    function processLiteralBlock(block) {
        var lines = block.lines;
        var children = block.children;
        var str = lines.join("\n");
        for(var i = 0, len = children.length; i < len; ++i) {
            str += processLiteralBlock(children[i]);
        }
        return str;
    }
    
    function processBlock(blocks) {
        var m = null;
        var res = {};
        var lines = null;
        var children = null;
        var currentObj = null;
        
        var level = -1;
        
        var processedBlocks = [];
        
        var isMap = true;
        
        for(var j = 0, lenJ = blocks.length; j < lenJ; ++j) {
            
            if(level != -1 && level != blocks[j].level)
                continue;
        
            processedBlocks.push(j);
        
            level = blocks[j].level;
            lines = blocks[j].lines;
            children = blocks[j].children;
            currentObj = null;
        
            for(var i = 0, len = lines.length; i < len; ++i) {
                var line = lines[i];

                if(m = line.match(regex["key"])) {
                    var key = m[1].trim();

                    if(key[0] == '-') {
                        key = key.replace(regex["item"], "");
                        if (isMap) { 
                            isMap = false;
                            if (typeof(res.length) === "undefined") {
                                res = [];
                            } 
                        }
                        if(currentObj != null) res.push(currentObj);
                        currentObj = {};
                        isMap = true;
                    }
                    
                    if(typeof m[2] != "undefined") {
                        var value = m[2].replace(regex["trim"], "");
                        if(value[0] == '&') {
                            var nb = processBlock(children);
                            if(currentObj != null) currentObj[key] = nb;
                            else res[key] = nb;
                            reference_blocks[value.substr(1)] = nb;
                        } else if(value[0] == '|') {
                            if(currentObj != null) currentObj[key] = processLiteralBlock(children.shift());
                            else res[key] = processLiteralBlock(children.shift());
                        } else if(value[0] == '*') {
                            var v = value.substr(1);
                            var no = {};
                            
                            if(typeof reference_blocks[v] == "undefined") {
                                errors.push("Reference '" + v + "' not found!");
                            } else {
                                for(var k in reference_blocks[v]) {
                                    no[k] = reference_blocks[v][k];
                                }
                                
                                if(currentObj != null) currentObj[key] = no;
                                else res[key] = no;
                            }
                        } else if(value[0] == '>') {
                            if(currentObj != null) currentObj[key] = processFoldedBlock(children.shift());
                            else res[key] = processFoldedBlock(children.shift());
                        } else {
                            if(currentObj != null) currentObj[key] = processValue(value);
                            else res[key] = processValue(value);
                        }
                    } else {
                        if(currentObj != null) currentObj[key] = processBlock(children);
                        else res[key] = processBlock(children);                        
                    }
                } else if(line.match(/^-\s*$/)) {
                    if (isMap) { 
                        isMap = false;
                        if (typeof(res.length) === "undefined") {
                            res = [];
                        } 
                    }
                    if(currentObj != null) res.push(currentObj);
                    currentObj = {};
                    isMap = true;
                    continue;
                } else if(m = line.match(/^-\s*(.*)/)) {
                    if(currentObj != null) 
                        currentObj.push(processValue(m[1]));
                    else {
                        if (isMap) { 
                            isMap = false;
                            if (typeof(res.length) === "undefined") {
                                res = [];
                            } 
                        }
                        res.push(processValue(m[1]));
                    }
                    continue;
                }
            }
            
            if(currentObj != null) {
                if (isMap) { 
                    isMap = false;
                    if (typeof(res.length) === "undefined") {
                        res = [];
                    } 
                }
                res.push(currentObj);
            }
        }
        
        for(var j = processedBlocks.length - 1; j >= 0; --j) {
            blocks.splice.call(blocks, processedBlocks[j], 1);
        }

        return res;
    }
        
    function semanticAnalysis(blocks) {
        var res = processBlock(blocks.children);
        return res;
    }
    
    function preProcess(src) {
        var m;
        var lines = src.split("\n");
        
        var r = regex["comment"];
        
        for(var i in lines) {
            if(m = lines[i].match(r)) {
/*                var cmt = "";
                if(typeof m[3] != "undefined")
                    lines[i] = m[1];
                else if(typeof m[3] != "undefined")
                    lines[i] = m[3]; 
                else
                    lines[i] = "";
                    */
                if(typeof m[3] !== "undefined") {
                    lines[i] = m[0].substr(0, m[0].length - m[3].length);
                }
            }
        }
        
        return lines.join("\n");
    }
    
    function eval(str) {
        errors = [];
        reference_blocks = [];
        processing_time = (new Date()).getTime();
        var pre = preProcess(str)
        var doc = parser(pre);
        var res = semanticAnalysis(doc);
        processing_time = (new Date()).getTime() - processing_time;
        
        return res;
    }
     
    function stringify (obj) {
      var indent=0;
      // TODO
      return '';
    }   
    return {        
        /**
         * Load and parse a YAML file from a URL.
         * @param {String} src URL from where to load the YAML file
         * @param {Function} ondone Function that will be called when the file is parsed. The result is passed as an argument.
         * @function
         */
        fromURL : fromURL,
        
        /**
         * Parse a YAML file from a string.
         * @param {String} str String with the YAML file contents.
         * @function
         */
        eval : eval,
        
        /**
         * Get errors found when parsing the last file.
         * @function
         * @returns Errors found when parsing the last file.
         */
        getErrors : function() { return errors; },
        
        /**
         * Get the time it took to parse the last file.
         * @function
         * @returns Time in milliseconds.
         */
        getProcessingTime : function() { return processing_time; },
        
        stringify : stringify
    }
})();
if (typeof module == 'object') module.exports=YAML;
};
BundleModuleCode['aux/line/line']=function (module,exports){
var MOVE_LEFT = new Buffer('1b5b3130303044', 'hex').toString();
var MOVE_UP = new Buffer('1b5b3141', 'hex').toString();
var CLEAR_LINE = new Buffer('1b5b304b', 'hex').toString();
var stringWidth = Require('aux/line/string-width');

module.exports = function(stream) {
	var write = stream.write;
	var str;

	stream.write = function(data) {
		if (str && data !== str) str = null;
		return write.apply(this, arguments);
	};

	if (stream === process.stderr || stream === process.stdout) {
		process.on('exit', function() {
			if (str !== null) stream.write('');
		});
	}

	var prevLineCount = 0;
	var log = function() {
		str = '';
		var nextStr = Array.prototype.join.call(arguments, ' ');

		// Clear screen
		for (var i=0; i<prevLineCount; i++) {
			str += MOVE_LEFT + CLEAR_LINE + (i < prevLineCount-1 ? MOVE_UP : '');
		}

		// Actual log output
		str += nextStr;
		stream.write(str);

		// How many lines to remove on next clear screen
		var prevLines = nextStr.split('\n');
		prevLineCount = 0;
		for (var i=0; i < prevLines.length; i++) {
			prevLineCount += Math.ceil(stringWidth(prevLines[i]) / stream.columns) || 1;
		}
	};

	log.clear = function() {
		stream.write('');
	};

	return log;
};

module.exports.stdout = module.exports(process.stdout);
module.exports.stderr = module.exports(process.stderr);
};
BundleModuleCode['aux/line/string-width']=function (module,exports){
'use strict';
var stripAnsi = Require('aux/line/strip-ansi');
var isFullwidthCodePoint = Require('aux/line/is-fullwidth-code-point');

var stringWidth = string => {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	string = stripAnsi(string);

	if (string.length === 0) {
		return 0;
	}

	// string = string.replace(emojiRegex(), '  ');

	let width = 0;

	for (let i = 0; i < string.length; i++) {
		var code = string.codePointAt(i);

		// Ignore control characters
		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (code >= 0x300 && code <= 0x36F) {
			continue;
		}

		// Surrogates
		if (code > 0xFFFF) {
			i++;
		}

		width += isFullwidthCodePoint(code) ? 2 : 1;
	}

	return width;
};

module.exports = stringWidth;
// TODO: remove this in the next major version
module.exports.default = stringWidth;
};
BundleModuleCode['aux/line/strip-ansi']=function (module,exports){
'use strict';
const ansiRegex = Require('aux/line/ansi-regex');

module.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};
BundleModuleCode['aux/line/ansi-regex']=function (module,exports){
'use strict';

module.exports = function (onlyFirst)  {
  if (onlyFirst==undefined) onlyFirst=false;
	var pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};
};
BundleModuleCode['aux/line/is-fullwidth-code-point']=function (module,exports){
/* eslint-disable yoda */
'use strict';

const isFullwidthCodePoint = codePoint => {
	if (!Number.isInteger(codePoint)) {
		return false;
	}

	// Code points are derived from:
	// https://unicode.org/Public/UNIDATA/EastAsianWidth.txt
	return codePoint >= 0x1100 && (
		codePoint <= 0x115F || // Hangul Jamo
		codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
		codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
		// CJK Radicals Supplement .. Enclosed CJK Letters and Months
		(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
		// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
		(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
		// CJK Unified Ideographs .. Yi Radicals
		(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
		// Hangul Jamo Extended-A
		(0xA960 <= codePoint && codePoint <= 0xA97C) ||
		// Hangul Syllables
		(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
		// CJK Compatibility Ideographs
		(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
		// Vertical Forms
		(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
		// CJK Compatibility Forms .. Small Form Variants
		(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
		// Halfwidth and Fullwidth Forms
		(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
		(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
		// Kana Supplement
		(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
		// Enclosed Ideographic Supplement
		(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
		// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
		(0x20000 <= codePoint && codePoint <= 0x3FFFD)
	);
};

module.exports = isFullwidthCodePoint;
module.exports.default = isFullwidthCodePoint;
};
BundleModuleCode['plugins/com/Http.js']=function (module,exports){
/* Simplified generic client/server HTTP API for node.js */
var Http = {}
var https,
    http = require('http');

function parseUrl(url) {
  if (!isNaN(Number(url)) || url=='*') return {
    proto:  undefined,
    host:   undefined,
    port:   url,
    path:   '',
    params:  undefined,
  }
  function toParams (avl) {
    var params = {};
    avl.forEach(function (av) {
      var parts=av.split('=');
      params[parts[0]]=parts[1];
    })
    return params;
  }
  var tokens = url.match(/((http|https|udp|tcp):\/\/)?([a-zA-Z0-9_\.\-]+):(\[?[0-9]+\]?|\*)(\/[^\?]+)?(\?.+$)?/)
  if (!tokens) {
    tokens   = url.match(/((http|https|udp|tcp):\/\/)?([a-zA-Z0-9_\.\-]+)(\/[^\?]+)?(\?.+$)?/);
    return  {
      proto:  tokens[2],
      host:   tokens[3],
      port:   undefined,
      path:   tokens[4]||'',
      params:  tokens[5] && toParams(tokens[5].replace(/^\?/,'').split('&')),
    }
  } else return  {
    proto:  tokens[2],
    host:   tokens[3],
    port:   tokens[4] && Number(tokens[4]),
    path:   tokens[5]||'',
    params:  tokens[6] && toParams(tokens[6].replace(/^\?/,'').split('&')),
  }
}

function parseQueryString( url ) {
    var queryString = url.substring( url.indexOf('?') + 1 );
    if (queryString == url) return [];
    var params = {}, queries, temp, i, l;
    // Split into key/value pairs
    queries = queryString.split("&");
    // Convert the array of strings into an object
    for ( i = 0, l = queries.length; i < l; i++ ) {
        temp = queries[i].split('=');
        if (temp[1]==undefined) temp[1]='true';
        params[temp[0]] = temp[1].replace('%20',' ');
    }
    return params;
}
function reply(response,body,mimetype,proto) {
  header={'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Credentials': 'true',
          'Content-Type': mimetype?mimetype:'text/plain'};

  if (proto=='http') response.writeHead(200,header);
  response.write(body);
  response.end();
}

Http.get = async function (url,callback,mimetype) {
  var ishttps= url.match(/https:/)!=null;
  url=url.replace(/^http[s]*:\/\//,'');
  if (typeof callback=='string') { mimetype=callback;callback=null};
  function exec(url,callback) {
    var parts = parseUrl(url),
        path  = parts.path,
        host  = parts.host,
        port  = parts.port||(ishttps?'443':'80'),
        options = {
          host: host,
          port: port,
          path: path,
          method: 'GET',
          keepAlive: true,
          headers: {
              // 'Content-Type': 'application/x-www-form-urlencoded',
          }          
        }
    var req = (ishttps?https:http).request(options, function(res) {
        res.setEncoding('utf8');
        var data='';
        res.on('data', function (chunk) {
          data += chunk;
          // console.log('Response: ' + chunk);
        });
        res.on('end', function () {
          try {
            var result=mimetype=='json'?JSONfn.parse(data):data;
            // console.log('GET: ',result);
          } catch (e) { result=e; }
          callback(result);
        });
    });
    req.on('error',function (err) {
      // console.log(err)
      callback(null,err);
    });
    req.setNoDelay();
    // get_req.write();
    req.end();
  }
  if (callback) {
    exec(url,callback);
  } else return new Promise(function (resolve,reject) {
    exec(url,resolve)
  })
}
Http.put = async function (url,data,callback,mimetype) {
  var ishttps= url.match(/https:/)!=null;
  url=url.replace(/^http[s]*:\/\//,'');
  if (typeof callback=='string') { mimetype=callback;callback=null};
  function exec(url,callback) {
    var parts = parseUrl(url),
        path  = parts.path,
        host  = parts.host,
        port  = parts.port||(ishttps?'443':'80'),
        options = {
          host: host,
          port: port,
          path: path,
          method: 'GET',
          keepAlive: true,
          headers: {
              // 'Content-Type': 'application/x-www-form-urlencoded',
          }          
        }
    var req = (ishttps?https:http).request(options, function(res) {
        res.setEncoding('utf8');
        var data='';
        res.on('data', function (chunk) {
          data += chunk;
          // console.log('Response: ' + chunk);
        });
        res.on('end', function () {
          try {
            var result=mimetype=='json'?JSONfn.parse(data):data;
            // console.log('GET: ',result);
          } catch (e) { result=e; }
          callback(result);
        });
    });
    req.on('error',function (err) {
      // console.log(err)
      callback(null,err);
    });
    req.setNoDelay();
    req.write(mimetype=='json'?JSONfn.stringify(data):data);
    req.end();
  }
  if (callback) {
    exec(url,callback);
  } else return new Promise(function (resolve,reject) {
    exec(url,resolve)
  })

}
// callback(method,url,peer,params,body,error?)
Http.service =  function (host,port,callback,proto) {
  var webSrv = http.createServer(function (request,response) {
    var body,header,sep,query,res,now;
    if (request.url.length) 
      query=parseQueryString(request.url);
    else 
      query={}
    switch (request.method) {
      case 'GET':
        var result = callback(request.method,request.url,'',query,null);
        if (typeof result=='string') reply(response,result,null,proto);
        else reply(response,result.data,result.mimetype,proto);
        break;      
      case 'POST':
        body = '';
        request.on('data', function (chunk) {
          body = body + chunk;
        });
        request.on('end', function () {
          var result = callback(request.method,request.url,body,query,null);
          if (typeof result=='string') reply(response,result,null,proto);
          else reply(response,result.data,result.mimetype,proto);
        });
        break;
    }
  })
  
  webSrv.on("connection", function (socket) {
      // socket.setNoDelay(true);
  });

  webSrv.on("error", function (err) {
    console.log(err)
    callback('ERROR',null,null,null,null,err)
  });

  webSrv.listen(port,function (err) {
    console.log('HTTP Service started (http://'+host+':'+port+')');
  });
  return webSrv
}

module.exports = Http;
};
BundleModuleCode['plugins/html/html.js']=function (module,exports){
// HTML document formatter

function html (header,body) {
  return [
    '<html>',
    '<header>'
  ].concat(header).concat([
    '</header>',
    '<body>'
  ]).concat(body).concat([
    '</body>',
    '</html>'
  ])
}
var tags = ['a','p','div','h1','h2','h3','ol','ul','li','dd','dt','dl','table','tbody','tr','td','th'];
html.tagger = function(tag) {
  return function (content,style) {
    return [
      style?'<'+tag+' style="'+style+'">':'<'+tag+'>'
    ].concat(typeof content == 'string'?[content]:content).concat([
      '</'+tag+'>'
    ])
  }
}
for (var i in tags) {
  html[tags[i]]=html.tagger(tags[i]);
}
html.button = function (url,label,style) {
  style=style||'';
  label=label||url;
  return '<button onclick="window.location.href=\''+url+'\'" style="'+style+'">'+label+'</button>'
}

html.link = function (url,label,style) {
  style=style||'';
  label=label||url;
  return '<a href="'+url+'" style="'+style+'">'+label+'</a>'
}

html.list = function (items,ordered) {
  var tag = ordered?'ol':'ul'
  return html[tag](items.map(function (item) {
    return html.li(item);
  }))
}
html.toString = function(header,body) {
  var H = html(header,body);
  function flat(H) {
    if (typeof H == 'string') return H;
    else return H.map(flat).join('\n')
  }
  return flat(H)
}
if (typeof 'module' != 'undefined') module.exports=html;
};
BundleModuleCode['fpe']=function (module,exports){
function FPEgeneric() {
  // TODO: Browser compatible module
  const crypto = require('crypto')
  const numbers = '1234567890'.split('')

  return function ({ password, algorithm = 'aes-256-cbc', domain = numbers }) {
    if (!password) {
      throw new Error('`password` is required')
    }

    function enc (text) {
      const cipher = crypto.createCipher(algorithm, password)
      let crypted = cipher.update(text, 'utf8', 'hex')
      crypted += cipher.final('hex')
      return crypted
    }

    // create a permutation of domain
    const sorted = domain.map(c => c).sort((c1, c2) => enc(c1).localeCompare(enc(c2)))
    const encTable = {}
    const decTable = {}

    for (let i in domain) {
      encTable[domain[i]] = sorted[i]
      decTable[sorted[i]] = domain[i]
    }

    function validate (text, result) {
      if (text.length !== result.length) {
        throw new Error('some of the input characters are not in the cipher´s domain (#text!=#result): ['+domain.length+']')
      }
    }

    function encrypt (text) {
      if (typeof text !== 'string') { throw new Error('input is not a string') }
      const encrypted = text.split('').map((c) => encTable[c]).join('')
      validate(text, encrypted)
      return encrypted
    }

    function decrypt (text) {
      if (typeof text !== 'string') { throw new Error('input is not a string') }
      const decrypted = text.split('').map((c) => decTable[c]).join('')
      validate(text, decrypted)
      return decrypted
    }

    return { encrypt, decrypt }
  }
}
var fpe = FPEgeneric();

function Encryptor(options) {
  if (!options || !options.password) throw Error('Encryptor: no options.password set');
  if (options.binary) options.domain=256;  
  this.options=options;
  this._encryptor = fpe({
    password: options.password,
    domain: this._getAllASCIICharacters(options.domain)
  });
}
Encryptor.prototype._getAllASCIICharacters = function (n) {
  var a=32,b=127;
  if (n) a=0,b=n;
  const chars = [];
  for (let i = a; i < b; ++i) {
    chars.push(String.fromCharCode(i));
  }
  return chars;
}
Encryptor.prototype.encrypt = function(data) {
  if (this.options.binary) data=data.toString('binary')
  var encrypted=this._encryptor.encrypt(data);
  if (this.options.binary) encrypted=new Buffer(encrypted,'binary');
  return encrypted;
}

Encryptor.prototype.decrypt = function(data) {
  if (this.options.binary) data=data.toString('binary')
  var decrypted=this._encryptor.decrypt(data);
  if (this.options.binary) decrypted=new Buffer(decrypted,'binary');
  return decrypted;
}

function test() {
  const encryptor = new Encryptor({ password: 'veronica' });

  // Note: The ciphertext has the same length as the plaintext.
  var encrypted = encryptor.encrypt('The quick brown fox number 3, jumps over the lazy dog')
  // '/(26:*Gu`6OpRDx6>R,6x* O2p6oF6w* \b6Rt2p6C(26l7E56gR!'
  console.log(encrypted.length,encrypted)
  var decrypted = encryptor.decrypt(encrypted)
  console.log(decrypted.length,decrypted)
}

module.exports = Encryptor


};
BundleModuleCode['cap.js']=function (module,exports){
// TODO String/Array extensions from compat

Capability = {
  /**
   *
   * typeof @port_valse = number [] 
   * typeof return = string
   */
  Port : function (port_vals) {
      if (port_vals==undefined) port_vals=[0,0,0,0,0,0];
      var port='';
      for(var i = 0; i< Capability.PORT_SIZE;i++) {
          port=port+String.fromCharCode(port_vals[i]);
      }
      return port;

  },
  /**
   *
   * typeof @obj = number | undefined
   * typeof @rights = number | undefined
   * typeof @rand = port | undefined
   * typeof function = constructor
   */
  Private : function (obj,rights,rand) {
      if (obj==undefined) {
          // Create empty private field
        return {
            prv_obj : 0,
            prv_rights : 0,
            prv_rand : Capability.Port()
        }
      } else {
        return {
          prv_obj : obj,               // Integer
          prv_rights : rights,         // Integer
          prv_rand : rand              // Port=string
        }
      }
  },

  /**
   *
   * typeof @cap_port = port
   * typeof @cap_priv = privat
   * typeof function = @constructor
   */
  Capability : function(cap_port, cap_priv) {
      if (cap_port==undefined) {
          // Create empty capability
          return {
            cap_port : Capability.Port(),
            cap_priv : Capability.Private()
          }
      } else {
          return {
            cap_port : cap_port,      // Port=string
            cap_priv : cap_priv?cap_priv:Capability.Private()
          }
      }
  },
  cap_parse : function (str,offset) {
      var cap=Capability.Capability(),
          pos=0;
      if (offset!=undefined) pos=offset;
      var pp=Capability.port_parse(str,pos);
      if (pp==undefined) return undefined;
      cap.cap_port=pp.port;
      pos=pp.pos;
      pp=Capability.prv_parse(str,pos);
      if (pp==undefined) return undefined;
      cap.cap_priv=pp.priv;
      pos=pp.pos;
      return {cap:cap,pos:pos};
  },

  cap_of_string : function (str) { var pp = Capability.cap_parse(str,0); return pp?pp.cap:undefined },

  cap_to_string : function (cap) {
      var str='';
      if (cap==undefined) return 'undefined';
      if (cap.cap_port!=undefined) str='['+Capability.port_to_string(cap.cap_port)+']'; else str = '[]';
      if (cap.cap_priv!=undefined) str=str+'('+Capability.prv_to_string(cap.cap_priv)+')'; else str=str+'()';
      return str;
  },

  /*
   ** Utils to get and set single bytes of a port
   */
  get_portbyte : function (port,i) {
      return port.charCodeAt(i); // String.fromCharCode(String.get(port,i))
  },
  set_portbyte : function (port,i,byte) {
      return String.set(port, i, (String.fromCharCode(byte)));
  },

  /*
   ** Encryption function
   */
  one_way : function (port) {
      var key = Array.create(64,0);
      var block = Array.create(48,0);
      var pubport = String.create (Capability.PORT_SIZE,'\0');
      var i, j, k;

      /*
      ** We actually need 64 bit key.
      ** Throw some zeroes in at bits 6 and 7 mod 8
      ** The bits at 7 mod 8 etc are not used by the algorithm
      */
      j=0;
      for (i = 0; i< 64; i++) {
          if ((i & 7) > 5)
              key[i] = 0;
          else {
              if ((Capability.get_portbyte(port, (j >> 3)) & (1 << (j & 7))) != 0)
                  key[i] = 1;
              else
                  key[i] = 0;
              j++;
          }
      }

      Des48.des_OWsetkey(key);
      /*
      ** Now go encrypt constant 0
      */
      block=Des48.des_OWcrypt48(block);


      /*
      ** and put the bits in the destination port
      */
      var pb = 0;

      for (i = 0; i < Capability.PORT_SIZE;i++) {
          var pbyte = 0;
          for (j = 0; j < 8; j++) {
              pbyte = pbyte | (block[pb] << j);
              pb++;
          }
          pubport=Capability.set_portbyte(pubport, i, pbyte);
      }
      return pubport;
  },

  pad : function (str,size) {
      while (str.length < (size || 2)) {str = "0" + str;}
      return str;
  },

  port_cmp : function (port1,port2) {
    return port1==port2;
  },

  port_copy : function (port) {
      return String.copy(port);
  },

  // Expected format: XX:XX:XX:XX:XX
  port_of_string : function (str,compact) {
      var tokens=str.split(':'),i,port='';
      for (i=0;i<Capability.PORT_SIZE;i++) {
          var num='0x'+tokens[i];
          port=port+String.fromCharCode(parseInt(num,16));
      }
      return port;
  },

  port_of_name : function (str) {
    var portvals = [0,0,0,0,0,0];
    for (var i=0;i<str.length;i++) {
      var d = str.charCodeAt(i);
      portvals[i % Capability.PORT_SIZE] = (portvals[i % Capability.PORT_SIZE]+d) & 0xff;
    }
    var port=""
    for (i=0;i<Capability.PORT_SIZE;i++) {
      port += String.fromCharCode(portvals[i]);
    }
    return port;
  },
  
  port_parse : function (str,pos) {
      var port='';
      var len=str.length;
      if (pos==undefined) pos=0;
      if (len<(pos+17)) return undefined;
      if (str[pos]=='[') pos++;
      for(var i=0;i<6;i++) {
          var sv='0x'+str[pos]+str[pos+1];
          port=port+String.fromCharCode(parseInt(sv));
          pos=pos+2;
          if (str[pos]==':') pos++;
      }
      if (str[pos]==']') pos++;
      return {port:port,pos:pos};
  },

  port_to_string : function (port,compact) {
      var i,str='';
      if (port) {
          for (i = 0; i < Capability.PORT_SIZE; i++) {
              var num = port.charCodeAt(i); // String.fromCharCode(String.get(port, i));
              if (!compact && i > 0) str = str + ':';
              str = str + Capability.pad(num.toString(16).toUpperCase(), 2);
          }
      } else str='undefined';
      return str;
  },

  priv2pub_cache : [],
  
  prv2pub : function  (port) {
      var putport;
      if (Capability.priv2pub_cache[port] == undefined) {
          putport=Capability.one_way(port);
          Capability.priv2pub_cache[port] = putport;
      } else putport = Capability.priv2pub_cache[port];
      return putport;
  },

  prv_cmp : function (prv1,prv2) {
   return  (prv1==undefined&&prv2==undefined) ||
           (prv1.prv_obj==prv2.prv_obj &&
            prv1.prv_rights==prv2.prv_rights &&
            Capability.port_cmp(prv1.prv_rand,prv2.prv_rand))
  },

  /**
   ** Decode a private structure (check for a valid private field)
   *
   * typeof @prv =  privat
   * typeof @rand = port
   * returns boolean
   */
  prv_decode : function  (prv,rand) {
      if (prv.prv_rights == Capability.PRV_ALL_RIGHTS)
          return Capability.port_cmp(prv.prv_rand,rand);
      else {
          var tmp_port = Capability.port_copy(rand),
              pt0 = Capability.get_portbyte(tmp_port, 0),
              pr0 = prv.prv_rights;
          tmp_port = Capability.set_portbyte(tmp_port, 0, (pt0 ^ pr0));
          tmp_port = Capability.one_way(tmp_port);
          return Capability.port_cmp(prv.prv_rand, tmp_port)
      }
  },

  /*
   ** Encode a private part from the object number, the rights field
   ** and the random port.
   ** Returns the created private structure.
   */
  prv_encode : function (obj,rights,rand) {
      var tmp_port = Capability.port_copy(rand),
          r1 = rights,
          rmask = Capability.PRV_ALL_RIGHTS;

      if (rights == Capability.PRV_ALL_RIGHTS)
          return Capability.Private(obj,r1 & rmask,tmp_port);
      else {
          var pt0 = Capability.get_portbyte(tmp_port,0);
          tmp_port = Capability.set_portbyte(tmp_port,0,pt0 ^ r1);
          tmp_port = Capability.one_way(tmp_port);
          return Capability.Private(obj,r1 & rmask,tmp_port)
      }
  },

  prv_of_string : function (str) { var pp=Capability.prv_parse(str,0); return pp?pp.priv:undefined },

  /*
   ** Return the private object number form a private structure
   */
  prv_number : function (prv) {
      return prv.prv_obj;
  },

  // Expected format: obj(right)[port]
  prv_parse : function (str,offset) {
      var priv=Capability.Private();
      var sv;
      var len=str.length,pos=offset;
      if (str[pos]=='(') pos++;
      sv='';
      while(str[pos]!='(') {
          sv=sv+str[pos];
          pos++;
      }
      priv.prv_obj=parseInt(sv);
      sv='';
      if (str[pos]=='(') pos++;
      while(str[pos]!=')') {
          sv=sv+str[pos];
          pos++;
      }
      priv.prv_rights=parseInt('0x'+sv);
      if (str[pos]==')') pos++;
      var pp=Capability.port_parse(str,pos);
      if (pp==undefined) return undefined;
      priv.prv_rand=pp.port;
      pos=pp.pos;
      return {priv:priv,pos:pos};
  },


  prv_to_string : function (priv) {
      var str='';
      if (priv==undefined) return 'undefined';
      str=priv.prv_obj;
      str=str+'('+String.hex(priv.prv_rights,2).toUpperCase()+')[';
      str=str+Capability.port_to_string(priv.prv_rand)+']';
      return str;
  },

  /** Restrict a private field (rights&mask) of a capability.
   *
   * @param {privat} priv
   * @param {number} mask rights restriction mask
   * @param {port} random secret server random port
   */
  prv_restrict: function (priv,mask,random) {
      var pr = Capability.prv_encode(priv.prv_obj,
                          priv.prv_rights & mask,
                          random);
      return pr;
  },
  /*
   ** Return the private rights field.
   */
  prv_rights: function (prv) {
      return prv.prv_rights & Capability.PRV_ALL_RIGHTS;
  },
  /*
   ** Check the private rights field: 1. Validation, 2: Required rights.
   */
  prv_rights_check : function (prv,rand,required) {
    if (!Capability.prv_decode(prv,rand)) return false;
    return (prv.prv_rights & required)==required;
  },

  /*
   * Return a new random unique port.
   *
   * Warning: the quality of the random ports are strongly
   * related to JSVMs underlying random generator.
   *
   * typeof return = port
   */
  uniqport: function () {
      var port = String.create (Capability.PORT_SIZE,0);
      var i,values;

      do {
        values = Rnd.generate({number:true,length:Capability.PORT_SIZE});
        for (i = 0; i <= (Capability.PORT_SIZE - 1); i++) 
          port = String.set(port, i, (String.fromCharCode(values[i])));
        if (Capability.uniquePorts[port]) Capability.uniquePorts[port]++;
        else Capability.uniquePorts[port]=1;
      } while (Capability.uniquePorts[port]>1);
      return port;
  },

  PORT_SIZE : 6,
  PRIVSIZE : 24,
  CAP_SIZE : 16,
  PRV_ALL_RIGHTS : 0xff,

  priv2pub_cache : [],
  uniquePorts : {},

}


Capability.Port.equal = Capability.port_cmp
Capability.Port.toString = Capability.port_to_string
Capability.Port.ofString = Capability.port_of_string
Capability.Port.ofName = Capability.port_of_name
Capability.Port.prv2pub = Capability.prv2pub
Capability.Port.random = Capability.uniqport
Capability.Port.unique = Capability.uniqport
Capability.Private.decode = Capability.prv_decode
Capability.Private.encode = Capability.prv_encode
Capability.Private.equal = Capability.prv_cmp
Capability.Private.number = Capability.prv_number
Capability.Private.ofString = Capability.prv_of_string
Capability.Private.restrict = Capability.prv_restrict
Capability.Private.rights = Capability.prv_rights
Capability.Private.rights_check = Capability.prv_rights_check
Capability.Private.toString = Capability.prv_to_string
Capability.Capability.toString = Capability.cap_to_string
Capability.Capability.ofString = Capability.cap_of_string

Crypto = (function () {
  var globalScope;
  if ("undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope) globalScope=self;
  else if ("object" == typeof window) globalScope=window;
  else if ("object" == typeof global) globalScope=global;
  
  var crypto = globalScope.crypto || globalScope.msCrypto;

  if (!crypto && typeof require != 'undefined') try { crypto=globalScope.crypto=require('require') } catch (e) {};

  var twister;

  var MersenneTwister = function(seed) {
	  if (seed == undefined) {
          /**
          ** It is not sure that Math.random is seeded randomly
          ** Thus, a combination of current system time and Math.random 
          ** is used to seed and initialize this random generator
          */
		  seed = new Date().getTime();
          seed *= Math.random()*91713;
          seed |= 0;
	  }

	  /* Period parameters */
	  this.N = 624;
	  this.M = 397;
	  this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	  this.mt = new Array(this.N); /* the array for the state vector */
	  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	  if (seed.constructor == Array) {
		  this.init_by_array(seed, seed.length);
	  }
	  else {
		  this.init_seed(seed);
	  }
  }

  /* initializes mt[N] with a seed */
  /* origin name init_genrand */
  MersenneTwister.prototype.init_seed = function(s) {
	  this.mt[0] = s >>> 0;
	  for (this.mti=1; this.mti<this.N; this.mti++) {
		  var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		  this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		  + this.mti;
		  /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		  /* In the previous versions, MSBs of the seed affect   */
		  /* only MSBs of the array mt[].                        */
		  /* 2002/01/09 modified by Makoto Matsumoto             */
		  this.mt[this.mti] >>>= 0;
		  /* for >32 bit machines */
	  }
  }

  /* initialize by an array with array-length */
  /* init_key is the array for initializing keys */
  /* key_length is its length */
  /* slight change for C++, 2004/2/26 */
  MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	  var i, j, k;
	  this.init_seed(19650218);
	  i=1; j=0;
	  k = (this.N>key_length ? this.N : key_length);
	  for (; k; k--) {
		  var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
		  this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		  + init_key[j] + j; /* non linear */
		  this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		  i++; j++;
		  if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		  if (j>=key_length) j=0;
	  }
	  for (k=this.N-1; k; k--) {
		  var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		  this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		  - i; /* non linear */
		  this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		  i++;
		  if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	  }

	  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
  }

  /* generates a random number on [0,0xffffffff]-interval */
  /* origin name genrand_int32 */
  MersenneTwister.prototype.random_int = function() {
	  var y;
	  var mag01 = new Array(0x0, this.MATRIX_A);
	  /* mag01[x] = x * MATRIX_A  for x=0,1 */

	  if (this.mti >= this.N) { /* generate N words at one time */
		  var kk;

		  if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			  this.init_seed(5489);  /* a default initial seed is used */

		  for (kk=0;kk<this.N-this.M;kk++) {
			  y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			  this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		  }
		  for (;kk<this.N-1;kk++) {
			  y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			  this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		  }
		  y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		  this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		  this.mti = 0;
	  }

	  y = this.mt[this.mti++];

	  /* Tempering */
	  y ^= (y >>> 11);
	  y ^= (y << 7) & 0x9d2c5680;
	  y ^= (y << 15) & 0xefc60000;
	  y ^= (y >>> 18);

	  return y >>> 0;
  }

  /* generates a random number on [0,0x7fffffff]-interval */
  /* origin name genrand_int31 */
  MersenneTwister.prototype.random_int31 = function() {
	  return (this.random_int()>>>1);
  }

  /* generates a random number on [0,1]-real-interval */
  /* origin name genrand_real1 */
  MersenneTwister.prototype.random_incl = function() {
	  return this.random_int()*(1.0/4294967295.0);
	  /* divided by 2^32-1 */
  }

  /* generates a random number on [0,1)-real-interval */
  MersenneTwister.prototype.random = function() {
	  return this.random_int()*(1.0/4294967296.0);
	  /* divided by 2^32 */
  }

  /* generates a random number on (0,1)-real-interval */
  /* origin name genrand_real3 */
  MersenneTwister.prototype.random_excl = function() {
	  return (this.random_int() + 0.5)*(1.0/4294967296.0);
	  /* divided by 2^32 */
  }

  /* generates a random number on [0,1) with 53-bit resolution*/
  /* origin name genrand_res53 */
  MersenneTwister.prototype.random_long = function() {
	  var a=this.random_int()>>>5, b=this.random_int()>>>6;
	  return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  function polyfill () {
    twister = new MersenneTwister(); // (Math.random()*Number.MAX_SAFE_INTEGER)|0)
    if (!crypto) crypto=globalScope.crypto={};
    crypto.getRandomValues = function getRandomValues (abv) {
      var l = abv.length
      while (l--) {
        abv[l] = Math.floor(twister.random() * 256)
      }
      return abv
    }
    if (!globalScope.Uint8Array && !Uint8Array) throw new Error('crypto.rand: No Uint8Array found!');
    if (!globalScope.Uint8Array) globalScope.Uint8Array=Uint8Array;
  }


  function randomByte (min,max) {
    if (!twister) twister = new MersenneTwister();
    return Math.floor(twister.random() * (max-min))+min;
  }

  function randomBytes (size, cb) {
    // phantomjs needs to throw
    if (size > 65536) throw new Error('requested too many random bytes')
    if (!crypto || !crypto.getRandomValues) polyfill();

    // in case browserify  isn't using the Uint8Array version
    var rawBytes = new globalScope.Uint8Array(size);
    // This will not work in older browsers.
    // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
    if (size > 0) {  // getRandomValues fails on IE if size == 0
      crypto.getRandomValues(rawBytes);
    }
    // phantomjs doesn't like a buffer being passed here
    var bytes = new Buffer(rawBytes);
    if (typeof cb === 'function') {
      cb(null, bytes)
    }

    return bytes
  } 

  return {
    randomByte:randomByte,
    randomBytes:randomBytes
  }
})();

Des48 = (function () {
  
  const des_HBS = 24;
  const des_BS = des_HBS * 2;


  /*
  ** Initial permutation,
  */

  var des_IP = [
      23, 27, 34, 44, 37, 17, 12, 42,
      3, 32, 41, 29, 20,  2,  1, 10,
      0, 28, 40,  6,  7, 11, 16,  8,
      25, 30, 14, 26, 47, 38, 19, 43,
      18,  5, 35, 39, 36, 21,  4, 45,
      24, 22, 13, 33, 31,  9, 15, 46 ];

  /*
  ** Final permutation, FP = IP^(-1)
  */

  var des_FP = [
      16, 14, 13,  8, 38, 33, 19, 20,
      23, 45, 15, 21,  6, 42, 26, 46,
      22,  5, 32, 30, 12, 37, 41,  0,
      40, 24, 27,  1, 17, 11, 25, 44,
      9, 43,  2, 34, 36,  4, 29, 35,
      18, 10,  7, 31,  3, 39, 47, 28 ];

  /*
  ** Permuted-choice 1 from the key bits
  ** to yield C and D.
  ** Note that bits 8,16... are left out:
      ** They are intended for a parity check.
  */

  var des_PC1_C = [
      57,49,41,33,25,17, 9,
      1,58,50,42,34,26,18,
      10, 2,59,51,43,35,27,
      19,11, 3,60,52,44,36 ];

  var des_PC1_D = [
      63,55,47,39,31,23,15,
      7,62,54,46,38,30,22,
      14, 6,61,53,45,37,29,
      21,13, 5,28,20,12, 4 ];


  /*
  ** Sequence of shifts used for the key schedule.
  */

  var des_shifts = [
      1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 ];



  /*
  ** Permuted-choice 2, to pick out the bits from
  ** the CD array that generate the key schedule.
  */

  var des_PC2_C = [
      14,17,11,24, 1, 5,
      3,28,15, 6,21,10,
      23,19,12, 4,26, 8,
      16, 7,27,20,13, 2 ];

  var des_PC2_D = [
      41,52,31,37,47,55,
      30,40,51,45,33,48,
      44,49,39,56,34,53,
      46,42,50,36,29,32 ];

  /*
  ** The C and D arrays used to calculate the key schedule.
  */


  var des_C = Array.create(56,0);
  // des_D = des_C[28]
  var des_D_get = function (i) {return des_C[i+28]};
  var des_D_set  =  function (i,sval) { des_C[i+28] = sval };

  /*
  ** The key schedule.
  ** Generated from the key.
  */

  var des_KS= Array.matrix(16,48,0);

  var des_OWsetkey = function(key) {
      var ks = [];
      var t = 0;
      var i,j,k;
      /*
      ** First, generate C and D by permuting
      ** the key.  The low order bit of each
      ** 8-bit char is not used, so C and D are only 28
      ** bits apiece.
      */

      for(i = 0;i < 28;i++) {

          var index1 = des_PC1_C[i] - 1;
          var index2 = des_PC1_D[i] - 1;

          des_C[i] = key[index1];
          des_D_set(i,key[index2]);
      }

      /*
      ** To generate Ki, rotate C and D according
      ** to schedule and pick up a permutation
      ** using PC2.
      */


      for (i = 0 ;i< 16;i++) {

          ks = des_KS[i];

          // rotate
          for (k = 0; k < des_shifts[i]; k++) {
              t = des_C[0];

              for (j = 0; j < 27; j++) {
                  des_C[j] = -des_C[j + 1];
              }

              des_C[27] = t;
              t = des_D_get(0);

              for (j = 0; j < 27; j++) {
                  des_D_set(j, des_D_get(j + 1));
              }
              des_D_set(27, t);
          }

          /*
           ** get Ki. Note C and D are concatenated.
           */

          for (j = 0; j < 24; j++) {
              ks[j] = des_C[des_PC2_C[j] - 1];
              ks[j + 24] = des_D_get(des_PC2_D[j] - 28 - 1);
          }

      }
  };


  /*
  ** The E bit-selection table.
  */

  var des_E = [
      22, 15, 12,  3,  8,  2, 23, 16,
      14, 13,  9, 10,  0,  1, 21, 19,
      18,  6, 11,  7, 17,  4, 20,  5,
      5, 17, 11, 13, 12, 14,  8,  7,
      19, 22, 18,  9,  3,  4,  1,  6,
      16,  2, 20, 15, 10, 23,  0, 21 ];


  /*
  ** The 8 selection functions.
  ** For some reason, they give a 0-origin
  ** index, unlike everything else.
  */

  var des_S = [
      [ 14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
      0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
      4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
      15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13 ],

      [ 15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10,
      3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5,
      0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15,
      13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9 ],

      [ 10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8,
      13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1,
      13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7,
      1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12 ],

      [ 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15,
      13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9,
      10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4,
      3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14 ],

      [ 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9,
      14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6,
      4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14,
      11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3 ],

      [ 12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11,
      10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8,
      9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6,
      4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13 ],

      [ 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1,
      13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6,
      1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2,
      6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12 ],

      [ 13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7,
      1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2,
      7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8,
      2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11 ]
      ];


  /*
  ** P is a permutation on the selected combination
  ** of the current L and key.
  */

  var des_P = [
      3, 13,  9, 12,  8, 20, 21,  7,
      5, 23, 16,  1, 14, 18,  4, 15,
      22, 10,  2,  0, 11, 19, 17,  6 ];

  var des_L = Array.create(des_BS,0);
  var des_R_get = function (i) { return des_L[(i+des_HBS)]};
  var des_R_set = function (i,sval) { des_L[i+des_HBS]= sval};
  var des_tempL = Array.create(des_HBS,0);
  var des_f = Array.create (32,0);

  /*
  ** Warning!!
  **
  ** f[] used to be HBS for some years.
  ** 21/6/1990 cbo and sater discovered that inside the loop where f is computed
  ** indices are used from 0 to 31. These overlapped the preS array which is
  ** declared hereafter on all compilers upto that point, but only those
  ** values that were not used anymore. But the values of f are only used
  ** upto HBS. Makes you wonder about the one-way property.
  ** Then came ACK, and reversed the order of the arrays in the image.
  **
  ** As a short term solution f[] was increased to 32, but in the long run
  ** someone should have a good look at our "oneway" function
  */

  /*
  ** The combination of the key and the input, before selection.
  */
  var des_preS = Array.create (48,0);

  /*
  ** The payoff: encrypt a block. (Now 48 bytes, 1 bit/byte)
  */

  var des_OWcrypt48 = function(block) {
      var ks = [];
      var t1 = 0;
      var t2 = 0;
      var i, j, k;
      /*
       ** First, permute the bits in the input
       */

      for (j = 0; j <= (des_BS - 1); j++) {
          des_L[j] = block[des_IP[j]];
      }
      /*
       ** Perform an encryption operation 16 times.
       */

      for (i = 0; i <= 15; i++) {
          ks = des_KS[i];

          /*
           ** Save the R array,
           ** which will be the new L.
           */

          for (j = 0; j < (des_HBS - 1); j++) {
              des_tempL[j] = des_R_get(j);
          }
          /*
           ** Expand R to 48 bits using the E selector;
           ** exclusive-or with the current key bits.
           */

          for (j = 0; j <= 47; j++) {
              des_preS[j] = (des_R_get(des_E[j])) ^ ks[j];
          }

          /*
           ** The pre-select bits are now considered
           ** in 8 groups of 6 bits each.
           ** The 8 selection functions map these
           ** 6-bit quantities into 4-bit quantities
           ** and the results permuted
           ** to make an f(R, K).
           ** The indexing into the selection functions
           ** is peculiar; it could be simplified by
           ** rewriting the tables.
           */

          t1 = 0;
          t2 = 0;

          for (j = 0; j <= 7; j++) {
              var sind2 =
                  ((des_preS[t1 + 0] << 5) & 0xff) +
                  ((des_preS[t1 + 1] << 3) & 0xff) +
                  ((des_preS[t1 + 2] << 2) & 0xff) +
                  ((des_preS[t1 + 3] << 1) & 0xff) +
                  ((des_preS[t1 + 4] << 0) & 0xff) +
                  ((des_preS[t1 + 5] << 4) & 0xff);

              k = des_S[j][sind2];

              des_f[t2 + 0] = (k >> 3) & 0x1;
              des_f[t2 + 1] = (k >> 2) & 0x1;
              des_f[t2 + 2] = (k >> 1) & 0x1;
              des_f[t2 + 3] = (k >> 0) & 0x1;    // 3 .. 31 !!!

              t1 = t1 + 6;
              t2 = t2 + 4;
          }

          /*
           ** The new R is L ^ f(R, K).
           ** The f here has to be permuted first, though.
           */

          for (j = 0; j < des_HBS; j++) {
              des_R_set(j, (des_L[j] ^ des_f[des_P[j]]));
          }

          /*
           ** Finally, the new L (the original R)
           ** is copied back.
           */

          for (j = 0; j < des_HBS; j++) {
              des_L[j] = des_tempL[j];
          }

      }


      /*
       ** The output L and R are reversed.
       */

      for (j = 0; j < des_HBS; j++) {
          t1 = des_L[j];
          des_L[j] = des_R_get(j);
          des_R_set(j, t1);
      }

      /*
       ** The final output
       ** gets the inverse permutation of the very original.
       */

      for (j = 0; j < des_BS; j++) {
          block[j] = des_L[des_FP[j]];
      }
      return block;
  };

  return {
      des_OWsetkey:des_OWsetkey,
      des_OWcrypt48:des_OWcrypt48
  };
})();


Rnd = {
  generate : function (options) {
  
  function numgen (options) {
    // assuming byte number range 0-255
    var arr = new Uint8Array(options.length||8);
    getRandomValues(arr);
    return arr;
  }
  
  function pwgen (options) {
    var localName, consonant, letter, vowel, pattern = options.pattern,
        char = "", n, i, validChars = [], prefix=options.prefix;
    letter = /[a-zA-Z]$/;
    vowel = /[aeiouAEIOU]$/;
    consonant = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/;
    if (options.length == null) {
      options.length = 10;
    }
    if (pattern == null) {
      pattern = /\w/;
    }
    if (prefix == null) {
      prefix = '';
    }

    // Non memorable passwords will pick characters from a pre-generated
    // list of characters
    if (!options.memorable) {
      for (i = 33; 126 > i; i += 1) {
        char = String.fromCharCode(i);
        if (char.match(pattern)) {
          validChars.push(char);
        }
      }

      if (!validChars.length) {
        throw new Error("Could not find characters that match the " +
          "password pattern " + pattern + ". Patterns must match individual " +
          "characters, not the password as a whole.");
      }
    }


    while (prefix.length < options.length) {
      if (options.memorable) {
        if (prefix.match(consonant)) {
          pattern = vowel;
        } else {
          pattern = consonant;
        }
        n = Crypto.randomByte(33,126); // rand(33, 126);
        char = String.fromCharCode(n);
      } else {
        char = validChars[rand(0, validChars.length)];
      }

      if (options.lowercase) char = char.toLowerCase();
      else if (options.uppercase) char = char.toUpperCase();
      
      if (char.match(pattern)) {
        prefix = "" + prefix + char;
      }
    }
    return prefix;
  };


  function rand(min, max) {
    var key, value, arr = new Uint8Array(max);
    getRandomValues(arr);
    for (key in arr) {
      if (arr.hasOwnProperty(key)) {
        value = arr[key];
        if (value > min && value < max) {
          return value;
        }
      }
    }
    return rand(min, max);
  }


  function getRandomValues(buf) {
    var bytes = Crypto.randomBytes(buf.length);
    buf.set(bytes);
  }
  if (options.number) 
    return numgen(options)
  else
    return pwgen(options);
}};
};
BundleModuleCode['parser/papaparse']=function (module,exports){
/*!
	Papa Parse
	v4.1.2
	https://github.com/mholt/PapaParse
*/
var Papa={};
Papa.init=function(global)
{
	'use strict';
	var IS_WORKER = !global.document && !!global.postMessage,
		IS_PAPA_WORKER = IS_WORKER && /(\?|&)papaworker(=|&|$)/.test(global.location.search),
		LOADED_SYNC = false, AUTO_SCRIPT_PATH;
	var workers = {}, workerIdCounter = 0;

	if (typeof Papa == 'undefined') global.Papa = {};

	Papa.parse = CsvToJson;
	Papa.unparse = JsonToCsv;

	Papa.RECORD_SEP = String.fromCharCode(30);
	Papa.UNIT_SEP = String.fromCharCode(31);
	Papa.BYTE_ORDER_MARK = '\ufeff';
	Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
	Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
	Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously

	// Configurable chunk sizes for local and remote files, respectively
	Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
	Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
	Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails

	// Exposed for testing and development only
	Papa.Parser = Parser;
	Papa.ParserHandle = ParserHandle;
	Papa.NetworkStreamer = NetworkStreamer;
	Papa.FileStreamer = FileStreamer;
	Papa.StringStreamer = StringStreamer;

        function detectCSV (chunk, opts) {
          opts = opts || {}
          if (Buffer.isBuffer(chunk)) chunk = chunk + ''
          var delimiters = opts.delimiters || [',', ';', '\t', '|']
          var newlines = opts.newlines || ['\n', '\r']

          var lines = chunk.split(/[\n\r]+/g)

          var delimiter = determineMost(lines[0], delimiters)
          var newline = determineMost(chunk, newlines)

          if (!delimiter) {
            if (isQuoted(lines[0])) return { newline: newline }
            return null
          }

          return {
            delimiter: delimiter,
            newline: newline
          }
        }

        function determineMost (chunk, items) {
          var ignoreString = false
          var itemCount = {}
          var maxValue = 0
          var maxChar
          var currValue
          items.forEach(function (item) {
            itemCount[item] = 0
          })
          for (var i = 0; i < chunk.length; i++) {
            if (chunk[i] === '"') ignoreString = !ignoreString
            else if (!ignoreString && chunk[i] in itemCount) {
              currValue = ++itemCount[chunk[i]]
              if (currValue > maxValue) {
                maxValue = currValue
                maxChar = chunk[i]
              }
            }
          }
          return maxChar
        }

        function isQuoted (chunk) {
          // is correctly quoted
          var nextQuote = false
          if (chunk[0] !== '"') return false
          if (chunk[chunk.length - 1] !== '"') return false
          for (var i = 1; i < chunk.length - 1; i++) {
            if (chunk[i] === '"') nextQuote = !nextQuote
            else if (nextQuote) return false
          }
          return !nextQuote
        }

        Papa.detect = detectCSV;
        
	if (typeof module !== 'undefined' && module.exports)
	{
		// Export to Node...
		module.exports = Papa;
	}
	else if (isFunction(global.define) && global.define.amd)
	{
		// Wireup with RequireJS
		define(function() { return Papa; });
	}
	else
	{
		// ...or as browser global
		global.Papa = Papa;
	}

	if (global.jQuery)
	{
		var $ = global.jQuery;
		$.fn.parse = function(options)
		{
			var config = options.config || {};
			var queue = [];

			this.each(function(idx)
			{
				var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
								&& $(this).attr('type').toLowerCase() === 'file'
								&& global.FileReader;

				if (!supported || !this.files || this.files.length === 0)
					return true;	// continue to next input element

				for (var i = 0; i < this.files.length; i++)
				{
					queue.push({
						file: this.files[i],
						inputElem: this,
						instanceConfig: $.extend({}, config)
					});
				}
			});

			parseNextFile();	// begin parsing
			return this;		// maintains chainability


			function parseNextFile()
			{
				if (queue.length === 0)
				{
					if (isFunction(options.complete))
						options.complete();
					return;
				}

				var f = queue[0];

				if (isFunction(options.before))
				{
					var returned = options.before(f.file, f.inputElem);

					if (typeof returned === 'object')
					{
						if (returned.action === 'abort')
						{
							error('AbortError', f.file, f.inputElem, returned.reason);
							return;	// Aborts all queued files immediately
						}
						else if (returned.action === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
						else if (typeof returned.config === 'object')
							f.instanceConfig = $.extend(f.instanceConfig, returned.config);
					}
					else if (returned === 'skip')
					{
						fileComplete();	// parse the next file in the queue, if any
						return;
					}
				}

				// Wrap up the user's complete callback, if any, so that ours also gets executed
				var userCompleteFunc = f.instanceConfig.complete;
				f.instanceConfig.complete = function(results)
				{
					if (isFunction(userCompleteFunc))
						userCompleteFunc(results, f.file, f.inputElem);
					fileComplete();
				};

				Papa.parse(f.file, f.instanceConfig);
			}

			function error(name, file, elem, reason)
			{
				if (isFunction(options.error))
					options.error({name: name}, file, elem, reason);
			}

			function fileComplete()
			{
				queue.splice(0, 1);
				parseNextFile();
			}
		}
	}


	if (IS_PAPA_WORKER)
	{
		global.onmessage = workerThreadReceivedMessage;
	}
	else if (Papa.WORKERS_SUPPORTED)
	{
		AUTO_SCRIPT_PATH = getScriptPath();

		// Check if the script was loaded synchronously
		if (!document.body)
		{
			// Body doesn't exist yet, must be synchronous
			LOADED_SYNC = true;
		}
		else
		{
			document.addEventListener('DOMContentLoaded', function () {
				LOADED_SYNC = true;
			}, true);
		}
	}




	function CsvToJson(_input, _config)
	{
		_config = _config || {};

		if (_config.worker && Papa.WORKERS_SUPPORTED)
		{
			var w = newWorker();

			w.userStep = _config.step;
			w.userChunk = _config.chunk;
			w.userComplete = _config.complete;
			w.userError = _config.error;

			_config.step = isFunction(_config.step);
			_config.chunk = isFunction(_config.chunk);
			_config.complete = isFunction(_config.complete);
			_config.error = isFunction(_config.error);
			delete _config.worker;	// prevent infinite loop

			w.postMessage({
				input: _input,
				config: _config,
				workerId: w.id
			});

			return;
		}

		var streamer = null;
		if (typeof _input === 'string')
		{
			if (_config.download)
				streamer = new NetworkStreamer(_config);
			else
				streamer = new StringStreamer(_config);
		}
		else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
			streamer = new FileStreamer(_config);

		return streamer.stream(_input);
	}






	function JsonToCsv(_input, _config)
	{
		var _output = '';
		var _fields = [];

		// Default configuration

		/** whether to surround every datum with quotes */
		var _quotes = false;

		/** delimiting character */
		var _delimiter = ',';

		/** newline character(s) */
		var _newline = '\r\n';

		unpackConfig();

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields =  _input.meta && _input.meta.fields;

				if (!_input.fields)
					_input.fields =  _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw 'exception: Unable to serialize unrecognized input';


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length === 1
				&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;
		}


		/** Turns an object's keys into an array */
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		/** The double for loop that iterates the data and writes out a CSV string including header row */
		function serialize(fields, data)
		{
			var csv = '';

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
		function safe(str, col)
		{
			if (typeof str === 'undefined' || str === null)
				return '';

			str = str.toString().replace(/"/g, '""');

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Papa.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) === ' '
							|| str.charAt(str.length - 1) === ' ';

			return needsQuotes ? '"' + str + '"' : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}

	/** ChunkStreamer is the base prototype for various streamer implementations. */
	function ChunkStreamer(config)
	{
		this._handle = null;
		this._paused = false;
		this._finished = false;
		this._input = null;
		this._baseIndex = 0;
		this._partialLine = '';
		this._rowCount = 0;
		this._start = 0;
		this._nextChunk = null;
		this.isFirstChunk = true;
		this._completeResults = {
			data: [],
			errors: [],
			meta: {}
		};
		replaceConfig.call(this, config);

		this.parseChunk = function(chunk)
		{
			// First chunk pre-processing
			if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
			{
				var modifiedChunk = this._config.beforeFirstChunk(chunk);
				if (modifiedChunk !== undefined)
					chunk = modifiedChunk;
			}
			this.isFirstChunk = false;

			// Rejoin the line we likely just split in two by chunking the file
			var aggregate = this._partialLine + chunk;
			this._partialLine = '';

			var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

			if (this._handle.paused() || this._handle.aborted())
				return;

			var lastIndex = results.meta.cursor;

			if (!this._finished)
			{
				this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
				this._baseIndex = lastIndex;
			}

			if (results && results.data)
				this._rowCount += results.data.length;

			var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

			if (IS_PAPA_WORKER)
			{
				global.postMessage({
					results: results,
					workerId: Papa.WORKER_ID,
					finished: finishedIncludingPreview
				});
			}
			else if (isFunction(this._config.chunk))
			{
				this._config.chunk(results, this._handle);
				if (this._paused)
					return;
				results = undefined;
				this._completeResults = undefined;
			}

			if (!this._config.step && !this._config.chunk) {
				this._completeResults.data = this._completeResults.data.concat(results.data);
				this._completeResults.errors = this._completeResults.errors.concat(results.errors);
				this._completeResults.meta = results.meta;
			}

			if (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))
				this._config.complete(this._completeResults, this._input);

			if (!finishedIncludingPreview && (!results || !results.meta.paused))
				this._nextChunk();

			return results;
		};

		this._sendError = function(error)
		{
			if (isFunction(this._config.error))
				this._config.error(error);
			else if (IS_PAPA_WORKER && this._config.error)
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					error: error,
					finished: false
				});
			}
		};

		function replaceConfig(config)
		{
			// Deep-copy the config so we can edit it
			var configCopy = copy(config);
			configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
			if (!config.step && !config.chunk)
				configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
			this._handle = new ParserHandle(configCopy);
			this._handle.streamer = this;
			this._config = configCopy;	// persist the copy to the caller
		}
	}


	function NetworkStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.RemoteChunkSize;
		ChunkStreamer.call(this, config);

		var xhr;

		if (IS_WORKER)
		{
			this._nextChunk = function()
			{
				this._readChunk();
				this._chunkLoaded();
			};
		}
		else
		{
			this._nextChunk = function()
			{
				this._readChunk();
			};
		}

		this.stream = function(url)
		{
			this._input = url;
			this._nextChunk();	// Starts streaming
		};

		this._readChunk = function()
		{
			if (this._finished)
			{
				this._chunkLoaded();
				return;
			}

			xhr = new XMLHttpRequest();

			if (this._config.withCredentials)
			{
				xhr.withCredentials = this._config.withCredentials;
			}

			if (!IS_WORKER)
			{
				xhr.onload = bindFunction(this._chunkLoaded, this);
				xhr.onerror = bindFunction(this._chunkError, this);
			}

			xhr.open('GET', this._input, !IS_WORKER);

			if (this._config.chunkSize)
			{
				var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
				xhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);
				xhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672
			}

			try {
				xhr.send();
			}
			catch (err) {
				this._chunkError(err.message);
			}

			if (IS_WORKER && xhr.status === 0)
				this._chunkError();
			else
				this._start += this._config.chunkSize;
		}

		this._chunkLoaded = function()
		{
			if (xhr.readyState != 4)
				return;

			if (xhr.status < 200 || xhr.status >= 400)
			{
				this._chunkError();
				return;
			}

			this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
			this.parseChunk(xhr.responseText);
		}

		this._chunkError = function(errorMessage)
		{
			var errorText = xhr.statusText || errorMessage;
			this._sendError(errorText);
		}

		function getFileSize(xhr)
		{
			var contentRange = xhr.getResponseHeader('Content-Range');
			return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
		}
	}
	NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
	NetworkStreamer.prototype.constructor = NetworkStreamer;


	function FileStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.LocalChunkSize;
		ChunkStreamer.call(this, config);

		var reader, slice;

		// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
		// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
		var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

		this.stream = function(file)
		{
			this._input = file;
			slice = file.slice || file.webkitSlice || file.mozSlice;

			if (usingAsyncReader)
			{
				reader = new FileReader();		// Preferred method of reading files, even in workers
				reader.onload = bindFunction(this._chunkLoaded, this);
				reader.onerror = bindFunction(this._chunkError, this);
			}
			else
				reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

			this._nextChunk();	// Starts streaming
		};

		this._nextChunk = function()
		{
			if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
				this._readChunk();
		}

		this._readChunk = function()
		{
			var input = this._input;
			if (this._config.chunkSize)
			{
				var end = Math.min(this._start + this._config.chunkSize, this._input.size);
				input = slice.call(input, this._start, end);
			}
			var txt = reader.readAsText(input, this._config.encoding);
			if (!usingAsyncReader)
				this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
		}

		this._chunkLoaded = function(event)
		{
			// Very important to increment start each time before handling results
			this._start += this._config.chunkSize;
			this._finished = !this._config.chunkSize || this._start >= this._input.size;
			this.parseChunk(event.target.result);
		}

		this._chunkError = function()
		{
			this._sendError(reader.error);
		}

	}
	FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
	FileStreamer.prototype.constructor = FileStreamer;


	function StringStreamer(config)
	{
		config = config || {};
		ChunkStreamer.call(this, config);

		var string;
		var remaining;
		this.stream = function(s)
		{
			string = s;
			remaining = s;
			return this._nextChunk();
		}
		this._nextChunk = function()
		{
			if (this._finished) return;
			var size = this._config.chunkSize;
			var chunk = size ? remaining.substr(0, size) : remaining;
			remaining = size ? remaining.substr(size) : '';
			this._finished = !remaining;
			return this.parseChunk(chunk);
		}
	}
	StringStreamer.prototype = Object.create(StringStreamer.prototype);
	StringStreamer.prototype.constructor = StringStreamer;



	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var self = this;
		var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
		var _input;				// The input being parsed
		var _parser;			// The core parser being used
		var _paused = false;	// Whether we are paused or not
		var _aborted = false;   // Whether the parser has aborted or not
		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};

		if (isFunction(_config.step))
		{
			var userStep = _config.step;
			_config.step = function(results)
			{
				_results = results;

				if (needsHeaderRow())
					processResults();
				else	// only call user's step function after header row
				{
					processResults();

					// It's possbile that this line was empty and there's no row here after all
					if (_results.data.length === 0)
						return;

					_stepCounter += results.data.length;
					if (_config.preview && _stepCounter > _config.preview)
						_parser.abort();
					else
						userStep(_results, self);
				}
			};
		}

		/**
		 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
		 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
		 * when an input comes in multiple chunks, like from a file.
		 */
		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			if (!_config.newline)
				_config.newline = guessLineEndings(input);

			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input, _config.newline);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = Papa.DefaultDelimiter;
				}
				_results.meta.delimiter = _config.delimiter;
			}

			var parserConfig = copy(_config);
			if (_config.preview && _config.header)
				parserConfig.preview++;	// to compensate for header row

			_input = input;
			_parser = new Parser(parserConfig);
			_results = _parser.parse(_input, baseIndex, ignoreLastRow);
			processResults();
			return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
		};

		this.paused = function()
		{
			return _paused;
		};

		this.pause = function()
		{
			_paused = true;
			_parser.abort();
			_input = _input.substr(_parser.getCharIndex());
		};

		this.resume = function()
		{
			_paused = false;
			self.streamer.parseChunk(_input);
		};

		this.aborted = function () 
		{
			return _aborted;
		};

		this.abort = function()
		{
			_aborted = true;
			_parser.abort();
			_results.meta.aborted = true;
			if (isFunction(_config.complete))
				_config.complete(_results);
			_input = '';
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \''+Papa.DefaultDelimiter+'\'');
				_delimiterError = false;
			}

			if (_config.skipEmptyLines)
			{
				for (var i = 0; i < _results.data.length; i++)
					if (_results.data[i].length === 1 && _results.data[i][0] === '')
						_results.data.splice(i--, 1);
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length === 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = {};

				for (var j = 0; j < _results.data[i].length; j++)
				{
					if (_config.dynamicTyping)
					{
						var value = _results.data[i][j];
						if (value === 'true' || value === 'TRUE')
							_results.data[i][j] = true;
						else if (value === 'false' || value === 'FALSE')
							_results.data[i][j] = false;
						else
							_results.data[i][j] = tryParseFloat(value);
					}

					if (_config.header)
					{
						if (j >= _fields.length)
						{
							if (!row['__parsed_extra'])
								row['__parsed_extra'] = [];
							row['__parsed_extra'].push(_results.data[i][j]);
						}
						else
							row[_fields[j]] = _results.data[i][j];
					}
				}

				if (_config.header)
				{
					_results.data[i] = row;
					if (j > _fields.length)
						addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
					else if (j < _fields.length)
						addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
				}
			}

			if (_config.header && _results.meta)
				_results.meta.fields = _fields;
			return _results;
		}

		function guessDelimiter(input, newline)
		{
			var delimChoices = [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					newline: newline,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				if (preview.data.length > 0)
					avgFieldCount /= preview.data.length;

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}

		function guessLineEndings(input)
		{
			input = input.substr(0, 1024*1024);	// max length 1 MB

			var r = input.split('\r');

			var n = input.split('\n');

			var nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);

			if (r.length === 1 || nAppearsFirst)
				return '\n';

			var numWithN = 0;
			for (var i = 0; i < r.length; i++)
			{
				if (r[i][0] === '\n')
					numWithN++;
			}

			return numWithN >= r.length / 2 ? '\r\n' : '\r';
		}

		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}





	/** The core parser implements speedy and correct CSV parsing */
	function Parser(config)
	{
		// Unpack the config object
		config = config || {};
		var delim = config.delimiter;
		var newline = config.newline;
		var comments = config.comments;
		var step = config.step;
		var preview = config.preview;
		var fastMode = config.fastMode;

		// Delimiter must be valid
		if (typeof delim !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
			delim = ',';

		// Comment character must be valid
		if (comments === delim)
			throw 'Comment character same as delimiter';
		else if (comments === true)
			comments = '#';
		else if (typeof comments !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
			comments = false;

		// Newline must be valid: \r, \n, or \r\n
		if (newline != '\n' && newline != '\r' && newline != '\r\n')
			newline = '\n';

		// We're gonna need these at the Parser scope
		var cursor = 0;
		var aborted = false;

		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			// For some reason, in Chrome, this speeds things up (!?)
			if (typeof input !== 'string')
				throw 'Input must be a string';

			// We don't need to compute some of these every time parse() is called,
			// but having them in a more local scope seems to perform better
			var inputLen = input.length,
				delimLen = delim.length,
				newlineLen = newline.length,
				commentsLen = comments.length;
			var stepIsFunction = typeof step === 'function';

			// Establish starting state
			cursor = 0;
			var data = [], errors = [], row = [], lastCursor = 0;

			if (!input)
				return returnable();

			if (fastMode || (fastMode !== false && input.indexOf('"') === -1))
			{
				var rows = input.split(newline);
				for (var i = 0; i < rows.length; i++)
				{
					var row = rows[i];
					cursor += row.length;
					if (i !== rows.length - 1)
						cursor += newline.length;
					else if (ignoreLastRow)
						return returnable();
					if (comments && row.substr(0, commentsLen) === comments)
						continue;
					if (stepIsFunction)
					{
						data = [];
						pushRow(row.split(delim));
						doStep();
						if (aborted)
							return returnable();
					}
					else
						pushRow(row.split(delim));
					if (preview && i >= preview)
					{
						data = data.slice(0, preview);
						return returnable(true);
					}
				}
				return returnable();
			}

			var nextDelim = input.indexOf(delim, cursor);
			var nextNewline = input.indexOf(newline, cursor);

			// Parser loop
			for (;;)
			{
				// Field has opening quote
				if (input[cursor] === '"')
				{
					// Start our search for the closing quote where the cursor is
					var quoteSearch = cursor;

					// Skip the opening quote
					cursor++;

					for (;;)
					{
						// Find closing quote
						var quoteSearch = input.indexOf('"', quoteSearch+1);

						if (quoteSearch === -1)
						{
							if (!ignoreLastRow) {
								// No closing quote... what a pity
								errors.push({
									type: 'Quotes',
									code: 'MissingQuotes',
									message: 'Quoted field unterminated',
									row: data.length,	// row has yet to be inserted
									index: cursor
								});
							}
							return finish();
						}

						if (quoteSearch === inputLen-1)
						{
							// Closing quote at EOF
							var value = input.substring(cursor, quoteSearch).replace(/""/g, '"');
							return finish(value);
						}

						// If this quote is escaped, it's part of the data; skip it
						if (input[quoteSearch+1] === '"')
						{
							quoteSearch++;
							continue;
						}

						if (input[quoteSearch+1] === delim)
						{
							// Closing quote followed by delimiter
							row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
							cursor = quoteSearch + 1 + delimLen;
							nextDelim = input.indexOf(delim, cursor);
							nextNewline = input.indexOf(newline, cursor);
							break;
						}

						if (input.substr(quoteSearch+1, newlineLen) === newline)
						{
							// Closing quote followed by newline
							row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
							saveRow(quoteSearch + 1 + newlineLen);
							nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field

							if (stepIsFunction)
							{
								doStep();
								if (aborted)
									return returnable();
							}

							if (preview && data.length >= preview)
								return returnable(true);

							break;
						}
					}

					continue;
				}

				// Comment found at start of new line
				if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
				{
					if (nextNewline === -1)	// Comment ends at EOF
						return returnable();
					cursor = nextNewline + newlineLen;
					nextNewline = input.indexOf(newline, cursor);
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// Next delimiter comes before next newline, so we've reached end of field
				if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
				{
					row.push(input.substring(cursor, nextDelim));
					cursor = nextDelim + delimLen;
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// End of row
				if (nextNewline !== -1)
				{
					row.push(input.substring(cursor, nextNewline));
					saveRow(nextNewline + newlineLen);

					if (stepIsFunction)
					{
						doStep();
						if (aborted)
							return returnable();
					}

					if (preview && data.length >= preview)
						return returnable(true);

					continue;
				}

				break;
			}


			return finish();


			function pushRow(row)
			{
				data.push(row);
				lastCursor = cursor;
			}

			/**
			 * Appends the remaining input from cursor to the end into
			 * row, saves the row, calls step, and returns the results.
			 */
			function finish(value)
			{
				if (ignoreLastRow)
					return returnable();
				if (typeof value === 'undefined')
					value = input.substr(cursor);
				row.push(value);
				cursor = inputLen;	// important in case parsing is paused
				pushRow(row);
				if (stepIsFunction)
					doStep();
				return returnable();
			}

			/**
			 * Appends the current row to the results. It sets the cursor
			 * to newCursor and finds the nextNewline. The caller should
			 * take care to execute user's step function and check for
			 * preview and end parsing if necessary.
			 */
			function saveRow(newCursor)
			{
				cursor = newCursor;
				pushRow(row);
				row = [];
				nextNewline = input.indexOf(newline, cursor);
			}

			/** Returns an object with the results, errors, and meta. */
			function returnable(stopped)
			{
				return {
					data: data,
					errors: errors,
					meta: {
						delimiter: delim,
						linebreak: newline,
						aborted: aborted,
						truncated: !!stopped,
						cursor: lastCursor + (baseIndex || 0)
					}
				};
			}

			/** Executes the user's step function and resets data & errors. */
			function doStep()
			{
				step(returnable());
				data = [], errors = [];
			}
		};

		/** Sets the abort flag */
		this.abort = function()
		{
			aborted = true;
		};

		/** Gets the cursor position */
		this.getCharIndex = function()
		{
			return cursor;
		};
	}


	// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
	// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358
	function getScriptPath()
	{
		var scripts = document.getElementsByTagName('script');
		return scripts.length ? scripts[scripts.length - 1].src : '';
	}

	function newWorker()
	{
		if (!Papa.WORKERS_SUPPORTED)
			return false;
		if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
			throw new Error(
				'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
				'You need to set Papa.SCRIPT_PATH manually.'
			);
		var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
		// Append 'papaworker' to the search string to tell papaparse that this is our worker.
		workerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';
		var w = new global.Worker(workerUrl);
		w.onmessage = mainThreadReceivedMessage;
		w.id = workerIdCounter++;
		workers[w.id] = w;
		return w;
	}

	/** Callback when main thread receives a message */
	function mainThreadReceivedMessage(e)
	{
		var msg = e.data;
		var worker = workers[msg.workerId];
		var aborted = false;

		if (msg.error)
			worker.userError(msg.error, msg.file);
		else if (msg.results && msg.results.data)
		{
			var abort = function() {
				aborted = true;
				completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
			};

			var handle = {
				abort: abort,
				pause: notImplemented,
				resume: notImplemented
			};

			if (isFunction(worker.userStep))
			{
				for (var i = 0; i < msg.results.data.length; i++)
				{
					worker.userStep({
						data: [msg.results.data[i]],
						errors: msg.results.errors,
						meta: msg.results.meta
					}, handle);
					if (aborted)
						break;
				}
				delete msg.results;	// free memory ASAP
			}
			else if (isFunction(worker.userChunk))
			{
				worker.userChunk(msg.results, handle, msg.file);
				delete msg.results;
			}
		}

		if (msg.finished && !aborted)
			completeWorker(msg.workerId, msg.results);
	}

	function completeWorker(workerId, results) {
		var worker = workers[workerId];
		if (isFunction(worker.userComplete))
			worker.userComplete(results);
		worker.terminate();
		delete workers[workerId];
	}

	function notImplemented() {
		throw 'Not implemented.';
	}

	/** Callback when worker thread receives a message */
	function workerThreadReceivedMessage(e)
	{
		var msg = e.data;

		if (typeof Papa.WORKER_ID === 'undefined' && msg)
			Papa.WORKER_ID = msg.workerId;

		if (typeof msg.input === 'string')
		{
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: Papa.parse(msg.input, msg.config),
				finished: true
			});
		}
		else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
		{
			var results = Papa.parse(msg.input, msg.config);
			if (results)
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: results,
					finished: true
				});
		}
	}

	/** Makes a deep copy of an array or object (mostly) */
	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function bindFunction(f, self)
	{
		return function() { f.apply(self, arguments); };
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}
}
Papa.init(typeof window != 'undefined'?window:this);

};
BundleModuleCode['doc/doc']=function (module,exports){
/** Markdown renderer for highlighted and formatted terminal output
 *  by embedding (escaped) terminal control sequences
 *
 */

var Marked = Require('marked');
var Colors = Require('doc/colors');
var List   = Require('doc/list');
var Table  = Require('doc/cli-table');
var NL = '\n';

function id (x) {return x}

// default css
var css = {
  bold:Colors.black.bold,
  italic:Colors.underline,
  h1:Colors.bold,
  h2:Colors.blue.bold,
  h3:Colors.red.bold,
  
  ol:{
    label:['1','a','i'],
  },
  ul:{
    label:['*','-','+'],
  },
  
}

// Increment numeric/alphanumeric list label
function incr(label,start) {
  switch (label) {
    case '1': return start.toString();
  }
  return label;
}

function B (text) { return css.bold(text) }
function I (text) { return css.italic(text) }
function P (text) { return text+'\n' }

function H (text, level) {
  var color,
      escapedText = text.toLowerCase().replace(/[^\w]+/g, '-');
  
  switch (level) {
    case 1: color=css.h1; break;
    case 2: color=css.h2; break;
    case 3: color=css.h3; break;
    default: color=id;
  }

  return color(text+'\n');
};

function CD(text) {
  return text+'\n';
}


function DL(body) {
  var item;
  list=new List({type:'dl',tab:2});
  while (this._data.stack.length && this._data.stack[0].dt != undefined) {
    item=this._data.stack.shift();
    //print(item)
    list.unshift({dt:css.bold(item.dt),dd:item.dd});
  }
  return list.toString()+NL;
    
}
function DT(body) {
  this._data.stack.unshift({dt:body});
}
function DD(body) {
  if (this._data.stack.length && this._data.stack[0].dt!=undefined)
     this._data.stack[0].dd=body;
}

function L(body, ordered, start) {
  var list,label;
  if (ordered) label=incr(css.ol.label[this._data.olist],start);
  else label=css.ul.label[this._data.ulist];
  list=new List({type:label});

  if (ordered) this._data.olist++; else this._data.ulist++; 
  
  while (this._data.stack.length && this._data.stack[0].item != undefined) {
    list.unshift(this._data.stack.shift().item);
  }
    
  if (ordered) this._data.olist--; else this._data.ulist--; 
  return list.toString()+NL;
}

function LI(text) {
  this._data.stack.unshift({item:text});
}

function text(text) {
  return text.replace(/&quot;/g,'"').
              replace(/&gt;/g,'>').
              replace(/&lt;/g,'<');
}

// Terminal MarkDown Renderer
function Renderer (options) {
  var marked = Marked(),
      renderer = new marked.Renderer();

  renderer.heading = H.bind(renderer);
  renderer.list = L.bind(renderer);
  renderer.listitem = LI.bind(renderer);
  renderer.paragraph = P.bind(renderer);
  renderer.strong = B.bind(renderer);
  renderer.em = I.bind(renderer);
  renderer._data={stack:[],ulist:0,olist:0};
  renderer.dt = DT.bind(renderer);
  renderer.dd = DD.bind(renderer);
  renderer.dl = DL.bind(renderer);
  renderer.code = CD.bind(renderer);
  renderer.text = text;
  
  marked.setOptions({
    renderer: renderer,
    highlight: function(code) {
      return require('highlight.js').highlightAuto(code).value;
    },
    pedantic: false,
    gfm: true,
    tables: true,
    breaks: false,
    sanitize: false,
    smartLists: true,
    smartypants: false,
    xhtml: false
  });  
  if (options.lazy) return function (text) { try { return marked(text) } catch (e) { return text }};
  else return marked;
}

module.exports = {
  Colors:Colors,
  List:List,
  Marked:Marked,
  Renderer:Renderer,
  Table:Table
}
};
BundleModuleCode['marked']=function (module,exports){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * 2016-2019 (c) Dr. Stefan Bosse
 * https://github.com/markedjs/marked
 *
 * Version 1.4.1
 */

function Marked() {
'use strict';

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
  nptable: noop,
  blockquote: /^( {0,3}>[^ ]? ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  dl:  /^ *(dt)\n: *(dd)/, 
  table: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)+)/,
  math: /^\$\$[ ]*(\{[^\}]+\})?[ ]*\n([^\$]+)\n\$\$/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();
  

// blab+
block.bullet = /(?:[*+-]|\d+\.|[a-zA-Z]\.|[ixv]+\.|[IXV]+\.)/;
// block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block.comment =/^%% ([^\n]*)/;
block._comment = /<!--(?!-?>)[\s\S]*?-->/;
block.html = edit(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit(block.paragraph)
  .replace('hr', block.hr)
  .replace('heading', block.heading)
  .replace('lheading', block.lheading)
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

block.dl = edit(block.dl)
  .replace('dt', block.text)
  .replace('dd', block.text)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
  fencesOpt: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *({[^}]+})?\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = edit(block.paragraph)
  .replace('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  .getRegex();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/,
});

/**
 * Pedantic grammar
 */

block.pedantic = merge({}, block.normal, {
  html: edit(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.pedantic) {
    this.rules = block.pedantic;
  } else if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    // .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      space,
      i,
      tag,
      l,
      isordered;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }
    // math
    if (cap = this.rules.math.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'math',
        parameter: cap[1] && cap[1].replace(/\{|\}/g,''),
        text: cap[2]
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // +@blab fencesOpt (gfm)
    if (cap = this.rules.fencesOpt.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        options : cap[3],
        text: cap[4] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = splitCells(item.cells[i]);
      }

      this.tokens.push(item);

      continue;
    }

    // @blab+
    // comment %%
    if (cap = this.rules.comment.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'comment',
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);
      var flag = cap[0][cap[0].indexOf('>')+1];
      if (flag==' ') flag=null;
      this.tokens.push({
        type: 'blockquote_start',
        flag: flag
      });
      cap = cap[0].replace(/^ *>[^ ]? ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);

      bull = cap[2];
      // @blab+ start, bullet
      this.tokens.push({
        type    : 'list_start',
        ordered : !(/[*+-]|->/.test(bull)),
        bullet  : bull,
        start   : bull.length > 1?bull.replace(/\./,''):null,
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        // blab+ 
        item = item.replace(/^ *([*+-]|\d+\.|[a-zA-Z]\.|[ixv]+\.|[IXV]+\.) +/, '');
        // item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // @blab+
        // Ignore immediately leading \d|[a-zA-Z]\. prefix that is text! 
        // FIX: Escape dot characters matching the bulet pattern
        if (/^[a-zA-Z]\./.test(item)) item = item.replace(/^([a-zA-Z])\./,'$1\\.');


        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }


    // dl
    if (cap = this.rules.dl.exec(src)) {
      // TODO
      this.tokens.push({
        type: 'dl_start',
      });
      this.tokens.push({
        type: 'dt_start',
      });
      this.tokens.push({
        type: 'text',
        text: cap[1]
      });
      this.tokens.push({
        type: 'dt_end',
      });
      
      this.tokens.push({
        type: 'dd_start',
      });
      this.tokens.push({
        type: 'text',
        text: cap[2]
      });
      this.tokens.push({
        type: 'dd_end',
      });
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'dl_end'
      });
      continue;
    }
    
    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = splitCells(
          item.cells[i].replace(/^ *\| *| *\| *$/g, ''));
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
// +@blab
  reflink2: /^\[(label)\]:\s*([^"]+)"([^"]+)"/,
  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
  // fix *x* **x** one character em/strong formatters
  // strong: /^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^__([^\s])__(?!_)|^\*\*([^\s])\*\*(?!\*)/,
  // em: /^_([^\s][\s\S]*?[^\s_])_(?!_)|^_([^\s_][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*][\s\S]*?[^\s])\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)/,
  strong: /^__([a-zA-Z])__|^\*\*([a-zA-Z])\*\*|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^__([^\s])__(?!_)|^\*\*([^\s])\*\*(?!\*)/,
  em: /^_([a-zA-Z])_|^\*([a-zA-Z])\*|^_([^\s][\s\S]*?[^\s_])_(?!_)|^_([^\s_][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*][\s\S]*?[^\s])\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
};

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit(inline.tag)
  .replace('comment', block._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|[^\[\]\\])*?/;
inline._href = /\s*(<(?:\\[<>]?|[^\s<>\\])*>|(?:\\[()]?|\([^\s\x00-\x1f()\\]*\)|[^\s\x00-\x1f()\\])*?)/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .getRegex();
// +@blab
inline.reflink2 = edit(inline.reflink2)
  .replace('label', inline._label)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)
    .replace('email', inline._email)
    .getRegex(),
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: edit(inline.text)
    .replace(']|', '~]|')
    .replace('|', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|')
    .getRegex()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.pedantic) {
    this.rules = inline.pedantic;
  } else if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      title,
      cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      cap[0] = this.rules._backpedal.exec(cap[0])[0];
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      href = cap[2];
      if (this.options.pedantic) {
        link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) {
          href = link[1];
          title = link[3];
        } else {
          title = '';
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
      out += this.outputLink(cap, {
        href: InlineLexer.escapes(href),
        title: InlineLexer.escapes(title)
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if (cap = this.rules.reflink.exec(src)) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }
    // +@blab
    // [label]: Text Text "[labelprint]"
    if (cap = this.rules.reflink2.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputRefLink(cap,{ref:cap[1], title:cap[2], label:cap[3]});
      this.inLink = false;
      continue;
    }
    if (cap = this.rules.nolink.exec(src)) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        // @bab:  Maybe a citation [xyz]?
        // out += cap[0].charAt(0);
        // src = cap[0].substring(1) + src;
        out += this.outputCitation(cap[1]);
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

InlineLexer.escapes = function(text) {
  return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
}

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = link.href,
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

// +@blab [label]: Text Text "[labelprint]"
InlineLexer.prototype.outputRefLink = function(cap, link) {
  var ref = link.ref,
      label = link.label, 
      title = link.title ? escape(link.title) : null;

  return this.renderer.reflink ? this.renderer.reflink(ref, title, label) : escape(label+' '+title);
};
//  [xyz]
InlineLexer.prototype.outputCitation = function(label) {
  return this.renderer.citation ? this.renderer.citation(label) : '['+label+']';

}
/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || marked.defaults;
}

Renderer.prototype.code = function(code, lang, escaped, options) {
  var html,extra='';
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }
  if (options) try { eval('options='+options.replace(/;/g,',')) } catch (e) {};

  if (lang=='pseudo') {
    code = code.replace(/@([a-zA-Z0-9_-]+)/g,'<strong>$1</strong>')
               .replace(/`([^`]+)`/g,'<em>$1</em>')
               .replace(/_([a-zA-Z0-9]+)/g,'<sub>$1</sub>')
               .replace(/~([^~]+)~/g,'<sub>$1</sub>')
               .replace(/\^([^\^]+)\^/g,'<sup>$1</sup>');
    escaped = true;
    lang='plaintext';
  } else if (lang=='ascii') {
    code = asciiDraw(code);
    extra='ascii';
    lang='plaintext';
  } else if (lang=='tree') {
    code = asciiTree(code);
    extra='ascii';
    lang='plaintext';
  } else if (lang=='tree0') {
    code = asciiTree(code,true);
    lang='plaintext';
    extra='tree';
  }

  
  if (!lang) {
    html = '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  } else {

    html = '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + ' '+extra
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
  }
  if (options && options.spoiler) {
    // collapsable spoiler element (for large code blocks)
    var i = Math.random(), label = options.label? options.label+'.':'Code.';
    html = '<input type="checkbox" '+
           'id="spoiler'+i+'"/><label id="spoiler-label'+i+'" for="spoiler'+i+'"'+
           '>'+
           label+'</label>'+
           '<div class="spoiler">'+html+'</div>'+NL+'</input><br>'+NL;  }
  return html;
};

Renderer.prototype.blockquote = function(quote,special) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  if (this.options.headerIds) {
    return '<h'
      + level
      + ' id="'
      + this.options.headerPrefix
      + raw.toLowerCase().replace(/[^\w]+/g, '-')
      + '">'
      + text
      + '</h'
      + level
      + '>\n';
  }
  // ignore IDs
  return '<h' + level + '>' + text + '</h' + level + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.math = function(code) {
  return '<pre>\n' + code + '\n</pre>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.dl = function(body) {
  return '<dl>\n' + body + '</dl>\n';
};
Renderer.prototype.dt = function(body) {
  return '<dt>' + body + '</dt>\n';
};
Renderer.prototype.dd = function(body) {
  return '<dd>' + body + '</dd>\n';
};

Renderer.prototype.paragraph = function(text) {
  if (/^[ ]*<input/.test(text)) return text;  // special HTML 
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

Renderer.prototype.unwrap = function (typ, html) {
  var tag='<'+typ+'>',
      antitag='</'+typ+'>',
      p0=html.indexOf(tag),p1;
  if (p0!=-1) html=html.substring(p0+tag.length);
  p1=html.lastIndexOf(antitag);
  if (p1!=-1) html=html.substring(0,p1);
  return html;
}

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return text;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return text;
    }
  }
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return text;
  }
  var out = '<a href="' + escape(href) + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += ' target="_blank">' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

// @blab+
Renderer.prototype.comment = function(text) {
console.log(text)
  return '';
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function (text) {
  return text;
}

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
}

TextRenderer.prototype.br = function() {
  return '';
}

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, {renderer: new TextRenderer()})
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    // @blab+
    // comment %%
    case 'comment': {
      return this.renderer.comment(this.token.text);
    }
    
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)));
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped,
        this.token.options);
    }
    case 'math': {
      return this.renderer.math(this.token.text,this.token.parameter);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;
      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body, this.token.align);
    }
    case 'blockquote_start': {
      body = '';
      var flag=this.token.flag;
      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }
      return this.renderer.blockquote(body,flag);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start,
          bullet = this.token.bullet;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start, bullet);
    }
    case 'list_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'dl_start': {
      body = '';
      while (this.next().type !== 'dl_end') {
        body += this.tok();
      }
      return this.renderer.dl(body);    
    }
    case 'dt_start': {
      body = '';
      while (this.next().type !== 'dt_end') {
        body += this.parseText();
      }
      return this.renderer.dt(body);    
    }
    case 'dd_start': {
      body = '';
      while (this.next().type !== 'dd_end') {
        body += this.parseText();
      }
      return this.renderer.dd(body);    
    }
    case 'html': {
      // TODO parse inline content if parameter markdown=1
      return this.renderer.html(this.token.text);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = base.replace(/[^/]*$/, '');
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

function splitCells(tableRow) {
  var cells = tableRow.replace(/([^\\])\|/g, '$1 |').split(/ +\| */),
      i = 0;

  for (; i < cells.length; i++) {
    cells[i] = cells[i].replace(/\\\|/g, '|');
  }
  return cells;
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.getDefaults = function () {
  return {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'lang-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tables: true,
    xhtml: false
  };
}

marked.defaults = marked.getDefaults();

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;
return marked;

}

if (typeof global != 'undefined') global.Marked=Marked;
if (typeof module != 'undefined') module.exports=Marked;
};
BundleModuleCode['doc/colors']=function (module,exports){
/*

The MIT License (MIT)

Original Library 
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var ansiStyles = colors.styles = Require('doc/styles');
var defineProps = Object.defineProperties;

colors.supportsColor = Require('doc/system/supports-colors').supportsColor;

if (typeof colors.enabled === "undefined") {
  colors.enabled = colors.supportsColor() !== false;
}

colors.stripColors = colors.strip = function(str){
  return ("" + str).replace(/\x1B\[\d+m/g, '');
};


var stylize = colors.stylize = function stylize (str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  return ansiStyles[style].open + str + ansiStyles[style].close;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe,  '\\$&');
}

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function () {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function (key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function () {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = arguments;
  var argsLen = args.length;
  var str = argsLen !== 0 && String(arguments[0]);
  if (argsLen > 1) {
    for (var a = 1; a < argsLen; a++) {
      str += ' ' + args[a];
    }
  }

  if (!colors.enabled || !str) {
    return str;
  }

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
  }

  return str;
}

colors.setTheme = function (theme) {
  if (typeof theme === 'string') {
    console.log('colors.setTheme now only accepts an object, not a string.  ' +
      'If you are trying to set a theme from a file, it is now your (the caller\'s) responsibility to require the file.  ' +
      'The old syntax looked like colors.setTheme(__dirname + \'/../themes/generic-logging.js\'); ' +
      'The new syntax looks like colors.setTheme(require(__dirname + \'/../themes/generic-logging.js\'));');
    return;
  }
  for (var style in theme) {
    (function(style){
      colors[style] = function(str){
        if (typeof theme[style] === 'object'){
          var out = str;
          for (var i in theme[style]){
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style)
  }
}

function init() {
  var ret = {};
  Object.keys(styles).forEach(function (name) {
    ret[name] = {
      get: function () {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function sequencer (map, str) {
  var exploded = str.split(""), i = 0;
  exploded = exploded.map(map);
  return exploded.join("");
};

// custom formatter methods
colors.trap =   Require('doc/custom/trap');
colors.zalgo =  Require('doc/custom/zalgo');

// maps
colors.maps = {};
colors.maps.america = (function() {
  return function (letter, i, exploded) {
    if(letter === " ") return letter;
    switch(i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter)
      case 2: return colors.blue(letter)
    }
  }
})();

colors.maps.zebra =   function (letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
}
colors.maps.rainbow = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();
colors.maps.random =  (function () {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
  };
})();

for (var map in colors.maps) {
  (function(map){
    colors[map] = function (str) {
      return sequencer(colors.maps[map], str);
    }
  })(map)
}

defineProps(colors, init());
};
BundleModuleCode['doc/styles']=function (module,exports){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]

};

Object.keys(codes).forEach(function (key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});};
BundleModuleCode['doc/system/supports-colors']=function (module,exports){
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

'use strict';

var os = Require('os');
var hasFlag = Require('doc/system/has-flag.js');

var env = process.env;

var forceColor = void 0;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level: level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	var min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		var osRelease = os.release().split('.');
		if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {
			return sign in env;
		}) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
		);
	}

	if ('TERM_PROGRAM' in env) {
		var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Hyper':
				return 3;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	var level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};
};
BundleModuleCode['doc/system/has-flag.js']=function (module,exports){
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

'use strict';

module.exports = function (flag, argv) {
	argv = argv || process.argv;

	var terminatorPos = argv.indexOf('--');
	var prefix = /^-{1,2}/.test(flag) ? '' : '--';
	var pos = argv.indexOf(prefix + flag);

	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};
};
BundleModuleCode['doc/custom/trap']=function (module,exports){
module['exports'] = function runTheTrap (text, options) {
  var result = "";
  text = text || "Run the trap, drop the bass";
  text = text.split('');
  var trap = {
    a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
    b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
    c: ["\u00a9", "\u023b", "\u03fe"],
    d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
    e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
    f: ["\u04fa"],
    g: ["\u0262"],
    h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
    i: ["\u0f0f"],
    j: ["\u0134"],
    k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
    l: ["\u0139"],
    m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
    n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
    o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
    p: ["\u01f7", "\u048e"],
    q: ["\u09cd"],
    r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
    s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
    t: ["\u0141", "\u0166", "\u0373"],
    u: ["\u01b1", "\u054d"],
    v: ["\u05d8"],
    w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
    x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
    y: ["\u00a5", "\u04b0", "\u04cb"],
    z: ["\u01b5", "\u0240"]
  }
  text.forEach(function(c){
    c = c.toLowerCase();
    var chars = trap[c] || [" "];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== "undefined") {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;

}
};
BundleModuleCode['doc/custom/zalgo']=function (module,exports){
// please no
module['exports'] = function zalgo(text, options) {
  text = text || "   he is here   ";
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }
  

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
    options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
    options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
    options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
}
};
BundleModuleCode['doc/list']=function (module,exports){
var NL='\n',SP=' ';
function spaces(n) {var s=''; while(n) s+=SP,n--; return s;}

/** List Constructor
 *  typeof @options = {
 *    type:string=' '|'*'|'-'|'+'|'1'|'2'|..|'a'|'b'|..|'dl',
 *  }
 */
function List (options) {
  this.type = options.type|| '*';
  this.margin = options.margin || {left:0,right:0,top:0,bottom:0};
  this.width = options.width || 80;
  this.tab = options.tab || 2;
  this.tab2 = options.tab || 4;
}
/**
 * Inherit from Array. Each item of the list is one array element.
 */

List.prototype.__proto__ = Array.prototype;

/** List formatter
 *
 */
List.prototype.render
List.prototype.toString = function (){
  var i,self=this,ret='',line='',lines=[],label,
      tokens,
      textwidth=this.width-this.margin.left-this.margin.right-this.tab;
  for(i=0;i<this.margin.top;i++) lines.push([]);
  this.forEach(function (item,index) {
    label=self.type;
    line = spaces (self.margin.left);
    switch (label) {
      case '*':
      case '+':
      case '-':
        line += label+SP; break;
      case ' ': break;
      case '1': line += (index+1).toString()+'.'+SP; break;
      case '2': line += (index+2).toString()+'.'+SP; break;
      case '3': line += (index+3).toString()+'.'+SP; break;
      case '4': line += (index+4).toString()+'.'+SP; break;
      case '5': line += (index+5).toString()+'.'+SP; break;
      case '6': line += (index+6).toString()+'.'+SP; break;
      case '7': line += (index+7).toString()+'.'+SP; break;
      case '8': line += (index+8).toString()+'.'+SP; break;
      case '9': line += (index+9).toString()+'.'+SP; break;
      case 'dl':
        line += item.dt+NL; label=undefined; item=item.dd; break;
      default:
        break;
    }
    line += label?spaces(self.tab-label.length-1):spaces(self.tab);
    if (item.length < textwidth) {
      line += item;
      lines.push(line);
    } else {
      tokens=item.split(SP); // TODO: preserve nbsp?
      tokens.forEach(function (token) {
        if ((line.length+token.length+1)<textwidth)
          line += (token+SP);
        else {
          lines.push(line);
          line = spaces(self.margin.left+self.tab)+token+SP;
        }
      });
      lines.push(line);
    }
  });
  for(i=0;i<this.margin.bottom;i++) lines.push([]);
  return lines.join(NL);
}


module.exports = List;
};
BundleModuleCode['doc/cli-table']=function (module,exports){
/* https://github.com/Automattic/cli-table */

/**
 * Module dependencies.
 */

var colors =  Require('doc/colors')
  , utils =   Require('doc/cli-utils')
  , repeat = utils.repeat
  , truncate = utils.truncate
  , pad = utils.pad;

/**
 * Table constructor
 *
 * @param {Object} options
 * @api public
 */

function Table (options){
  this.options = utils.options({
      chars: {
          'top': '─'
        , 'top-mid': '┬'
        , 'top-left': '┌'
        , 'top-right': '┐'
        , 'bottom': '─'
        , 'bottom-mid': '┴'
        , 'bottom-left': '└'
        , 'bottom-right': '┘'
        , 'left': '│'
        , 'left-mid': '├'
        , 'mid': '─'
        , 'mid-mid': '┼'
        , 'right': '│'
        , 'right-mid': '┤'
        , 'middle': '│'
      }
    , truncate: '…'
    , colWidths: []
    , colAligns: []
    , style: {
          'padding-left': 1
        , 'padding-right': 1
        , head: ['red']
        , border: ['grey']
        , compact : false
      }
    , head: []
  }, options);
};

/**
 * Inherit from Array.
 */

Table.prototype.__proto__ = Array.prototype;

/**
 * Width getter
 *
 * @return {Number} width
 * @api public
 */
/* Depricated

Table.prototype.__defineGetter__('width', function (){
  var str = this.toString().split("\n");
  if (str.length) return str[0].length;
  return 0;
});
*/
Object.defineProperty(Table.prototype,'width',{
  get: function() {
    var str = this.toString().split("\n");
    if (str.length) return str[0].length;
    return 0;
  }
});
/**
 * Render to a string.
 *
 * @return {String} table representation
 * @api public
 */

Table.prototype.render
Table.prototype.toString = function (){
  var ret = ''
    , options = this.options
    , style = options.style
    , head = options.head
    , chars = options.chars
    , truncater = options.truncate
      , colWidths = options.colWidths || new Array(this.head.length)
      , totalWidth = 0;

    if (!head.length && !this.length) return '';

    if (!colWidths.length){
      var all_rows = this.slice(0);
      if (head.length) { all_rows = all_rows.concat([head]) };

      all_rows.forEach(function(cells){
        // horizontal (arrays)
        if (typeof cells === 'object' && cells.length) {
          extractColumnWidths(cells);

        // vertical (objects)
        } else {
          var header_cell = Object.keys(cells)[0]
            , value_cell = cells[header_cell];

          colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);

          // cross (objects w/ array values)
          if (typeof value_cell === 'object' && value_cell.length) {
            extractColumnWidths(value_cell, 1);
          } else {
            colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
          }
        }
    });
  };

  totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
    function (a, b){
      return a + b
    })) + colWidths.length + 1;

  function extractColumnWidths(arr, offset) {
    var offset = offset || 0;
    arr.forEach(function(cell, i){
      colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
    });
  };

  function get_width(obj) {
    return typeof obj == 'object' && obj && obj.width != undefined
         ? obj.width
         : ((typeof obj == 'object' && obj !== null ? utils.strlen(obj.text) : utils.strlen(obj)) + (style['padding-left'] || 0) + (style['padding-right'] || 0))
  }

  // draws a line
  function line (line, left, right, intersection){
    var width = 0
      , line =
          left
        + repeat(line, totalWidth - 2)
        + right;

    colWidths.forEach(function (w, i){
      if (i == colWidths.length - 1) return;
      width += w + 1;
      line = line.substr(0, width) + intersection + line.substr(width + 1);
    });

    return applyStyles(options.style.border, line);
  };

  // draws the top line
  function lineTop (){
    var l = line(chars.top
               , chars['top-left'] || chars.top
               , chars['top-right'] ||  chars.top
               , chars['top-mid']);
    if (l)
      ret += l + "\n";
  };

  function generateRow (items, style) {
    var cells = []
      , max_height = 0;

    // prepare vertical and cross table data
    if (!Array.isArray(items) && typeof items === "object") {
      var key = Object.keys(items)[0]
        , value = items[key]
        , first_cell_head = true;

      if (Array.isArray(value)) {
        items = value;
        items.unshift(key);
      } else {
        items = [key, value];
      }
    }

    // transform array of item strings into structure of cells
    items.forEach(function (item, i) {
      var contents = (item == null ? '' : item).toString().split("\n").reduce(function (memo, l) {
        memo.push(string(l, i));
        return memo;
      }, [])

      var height = contents.length;
      if (height > max_height) { max_height = height };

      cells.push({ contents: contents , height: height });
    });

    // transform vertical cells into horizontal lines
    var lines = new Array(max_height);
    cells.forEach(function (cell, i) {
      cell.contents.forEach(function (line, j) {
        if (!lines[j]) { lines[j] = [] };
        if (style || (first_cell_head && i === 0 && options.style.head)) {
          line = applyStyles(options.style.head, line)
        }

        lines[j].push(line);
      });

      // populate empty lines in cell
      for (var j = cell.height, l = max_height; j < l; j++) {
        if (!lines[j]) { lines[j] = [] };
        lines[j].push(string('', i));
      }
    });
    var ret = "";
    lines.forEach(function (line, index) {
      if (ret.length > 0) {
        ret += "\n" + applyStyles(options.style.border, chars.left);
      }

      ret += line.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
    });

    return applyStyles(options.style.border, chars.left) + ret;
  };

  function applyStyles(styles, subject) {
    if (!subject)
      return '';
    styles.forEach(function(style) {
      subject = colors[style](subject);
    });
    return subject;
  };

  // renders a string, by padding it or truncating it
  function string (str, index){
    var str = String(typeof str == 'object' && str.text ? str.text : str)
      , length = utils.strlen(str)
      , width = colWidths[index]
          - (style['padding-left'] || 0)
          - (style['padding-right'] || 0)
      , align = options.colAligns[index] || 'left';

    return repeat(' ', style['padding-left'] || 0)
         + (length == width ? str :
             (length < width
              ? pad(str, ( width + (str.length - length) ), ' ', align == 'left' ? 'right' :
                  (align == 'middle' ? 'both' : 'left'))
              : (truncater ? truncate(str, width, truncater) : str))
           )
         + repeat(' ', style['padding-right'] || 0);
  };

  if (head.length){
    lineTop();

    ret += generateRow(head, style.head) + "\n"
  }

  if (this.length)
    this.forEach(function (cells, i){
      if (!head.length && i == 0)
        lineTop();
      else {
        if (!style.compact || i<(!!head.length) ?1:0 || cells.length == 0){
          var l = line(chars.mid
                     , chars['left-mid']
                     , chars['right-mid']
                     , chars['mid-mid']);
          if (l)
            ret += l + "\n"
        }
      }

      if (cells.hasOwnProperty("length") && !cells.length) {
        return
      } else {
        ret += generateRow(cells) + "\n";
      };
    });

  var l = line(chars.bottom
             , chars['bottom-left'] || chars.bottom
             , chars['bottom-right'] || chars.bottom
             , chars['bottom-mid']);
  if (l)
    ret += l;
  else
    // trim the last '\n' if we didn't add the bottom decoration
    ret = ret.slice(0, -1);

  return ret;
};

/**
 * Module exports.
 */

module.exports = Table;

module.exports.version = '0.0.1';
};
BundleModuleCode['doc/cli-utils']=function (module,exports){

/**
 * Repeats a string.
 *
 * @param {String} char(s)
 * @param {Number} number of times
 * @return {String} repeated string
 */

exports.repeat = function (str, times){
  return Array(times + 1).join(str);
};

/**
 * Pads a string
 *
 * @api public
 */

exports.pad = function (str, len, pad, dir) {
  if (len + 1 >= str.length)
    switch (dir){
      case 'left':
        str = Array(len + 1 - str.length).join(pad) + str;
        break;

      case 'both':
        var right = Math.ceil((padlen = len - str.length) / 2);
        var left = padlen - right;
        str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
        break;

      default:
        str = str + Array(len + 1 - str.length).join(pad);
    };

  return str;
};

/**
 * Truncates a string
 *
 * @api public
 */

exports.truncate = function (str, length, chr){
  chr = chr || '…';
  return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
};

/**
 * Copies and merges options with defaults.
 *
 * @param {Object} defaults
 * @param {Object} supplied options
 * @return {Object} new (merged) object
 */

function options(defaults, opts) {
  for (var p in opts) {
    if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
      defaults[p] = defaults[p] || {};
      options(defaults[p], opts[p]);
    } else {
      defaults[p] = opts[p];
    }
  }
  return defaults;
};
exports.options = options;

//
// For consideration of terminal "color" programs like colors.js,
// which can add ANSI escape color codes to strings,
// we destyle the ANSI color escape codes for padding calculations.
//
// see: http://en.wikipedia.org/wiki/ANSI_escape_code
//
exports.strlen = function(str){
  var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
  var stripped = ("" + (str != null ? str : '')).replace(code,'');
  var split = stripped.split("\n");
  return split.reduce(function (memo, s) { return (s.length > memo) ? s.length : memo }, 0);
}
};
BundleModuleCode['com/readline']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Joyent, Inc. and other Node contributors, Stefan Bosse
 **    $INITIAL:     (C) 2006-2018 bLAB
 **    $VERSION:     1.2.5
 **
 **    $INFO:
 **

// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.
// https://github.com/antirez/linenoise
// Reference:
// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html

*/

var kHistorySize = 30;

var util = Require('util');
var Buffer = Require('buffer').Buffer;
var inherits = Require('util').inherits;
var EventEmitter = Require('events').EventEmitter;
var StringDecoder = Require('string_decoder').StringDecoder;

// listenerCount isn't in node 0.10, so here's a basic polyfill
EventEmitter._listenerCount = EventEmitter._listenerCount || function (ee, event) {
  var listeners = ee && ee._events && ee._events[event]
  if (Array.isArray(listeners)) {
    return listeners.length
  } else if (typeof listeners === 'function') {
    return 1
  } else {
    return 0
  }
}

exports.createInterface = function(input, output, completer, terminal) {
  var rl;
  if (arguments.length === 1) {
    rl = new Interface(input);
  } else {
    rl = new Interface(input, output, completer, terminal);
  }
  return rl;
};


function Interface(input, output, completer, terminal) {
  if (!(this instanceof Interface)) {
    return new Interface(input, output, completer, terminal);
  }

  this._sawReturn = false;

  EventEmitter.call(this);

  if (arguments.length === 1) {
    // an options object was given
    output = input.output;
    completer = input.completer;
    terminal = input.terminal;
    input = input.input;
  }

  completer = completer || function() { return []; };

  if (!util.isFunction(completer)) {
    throw new TypeError('Argument \'completer\' must be a function');
  }

  // backwards compat; check the isTTY prop of the output stream
  //  when `terminal` was not specified
  if (util.isUndefined(terminal) && !util.isNullOrUndefined(output)) {
    terminal = !!output.isTTY;
  }

  var self = this;

  this.output = output;
  this.input = input;

  // Check arity, 2 - for async, 1 for sync
  this.completer = completer.length === 2 ? completer : function(v, callback) {
    callback(null, completer(v));
  };

  this.setPrompt('> ');

  this.terminal = !!terminal;

  function ondata(data) {
    self._normalWrite(data);
  }

  function onend() {
    if (util.isString(self._line_buffer) && self._line_buffer.length > 0) {
      self.emit('line', self._line_buffer);
    }
    self.close();
  }

  function ontermend() {
    if (util.isString(self.line) && self.line.length > 0) {
      self.emit('line', self.line);
    }
    self.close();
  }

  function onkeypress(s, key) {
    self._ttyWrite(s, key);
  }

  function onresize() {
    self._refreshLine();
  }

  if (!this.terminal) {
    input.on('data', ondata);
    input.on('end', onend);
    self.once('close', function() {
      input.removeListener('data', ondata);
      input.removeListener('end', onend);
    });
    this._decoder = new StringDecoder('utf8');

  } else {

    exports.emitKeypressEvents(input);

    // input usually refers to stdin
    input.on('keypress', onkeypress);
    input.on('end', ontermend);

    // Current line
    this.line = '';

    this._setRawMode(true);
    this.terminal = true;

    // Cursor position on the line.
    this.cursor = 0;

    this.history = [];
    this.historyIndex = -1;

    if (!util.isNullOrUndefined(output))
      output.on('resize', onresize);

    self.once('close', function() {
      input.removeListener('keypress', onkeypress);
      input.removeListener('end', ontermend);
      if (!util.isNullOrUndefined(output)) {
        output.removeListener('resize', onresize);
      }
    });
  }

  input.resume();
}

inherits(Interface, EventEmitter);

Object.defineProperty(Interface.prototype,'columns',{
  get: function() {
    var columns = Infinity;
    if (this.output && this.output.columns)
      columns = this.output.columns;
    return columns;
  }
});
/* Depricated
Interface.prototype.__defineGetter__('columns', function() {
  var columns = Infinity;
  if (this.output && this.output.columns)
    columns = this.output.columns;
  return columns;
});
*/

Interface.prototype.setPrompt = function(prompt) {
  this._prompt = prompt;
};


Interface.prototype._setRawMode = function(mode) {
  if (util.isFunction(this.input.setRawMode)) {
    return this.input.setRawMode(mode);
  }
};


Interface.prototype.prompt = function(preserveCursor) {
  if (this.paused) this.resume();
  if (this.terminal) {
    if (!preserveCursor) this.cursor = 0;
    this._refreshLine();
  } else {
    this._writeToOutput(this._prompt);
  }
};


Interface.prototype.question = function(query, cb) {
  if (util.isFunction(cb)) {
    if (this._questionCallback) {
      this.prompt();
    } else {
      this._oldPrompt = this._prompt;
      this.setPrompt(query);
      this._questionCallback = cb;
      this.prompt();
    }
  }
};


Interface.prototype._onLine = function(line) {
  if (this._questionCallback) {
    var cb = this._questionCallback;
    this._questionCallback = null;
    this.setPrompt(this._oldPrompt);
    cb(line);
  } else {
    this.emit('line', line);
  }
};

Interface.prototype._writeToOutput = function _writeToOutput(stringToWrite) {
  if (!util.isString(stringToWrite))
    throw new TypeError('stringToWrite must be a string');

  if (!util.isNullOrUndefined(this.output))
    this.output.write(stringToWrite);
};

Interface.prototype._addHistory = function() {
  if (this.line.length === 0) return '';

  if (this.history.length === 0 || this.history[0] !== this.line) {
    this.history.unshift(this.line);

    // Only store so many
    if (this.history.length > kHistorySize) this.history.pop();
  }

  this.historyIndex = -1;
  return this.history[0];
};


Interface.prototype._refreshLine = function() {
  // line length
  var line = this._prompt + this.line;
  var dispPos = this._getDisplayPos(line);
  var lineCols = dispPos.cols;
  var lineRows = dispPos.rows;

  // cursor position
  var cursorPos = this._getCursorPos();

  // first move to the bottom of the current line, based on cursor pos
  var prevRows = this.prevRows || 0;
  if (prevRows > 0) {
    exports.moveCursor(this.output, 0, -prevRows);
  }

  // Cursor to left edge.
  exports.cursorTo(this.output, 0);
  // erase data
  exports.clearScreenDown(this.output);

  // Write the prompt and the current buffer content.
  this._writeToOutput(line);

  // Force terminal to allocate a new line
  if (lineCols === 0) {
    this._writeToOutput(' ');
  }

  // Move cursor to original position.
  exports.cursorTo(this.output, cursorPos.cols);

  var diff = lineRows - cursorPos.rows;
  if (diff > 0) {
    exports.moveCursor(this.output, 0, -diff);
  }

  this.prevRows = cursorPos.rows;
};


Interface.prototype.close = function() {
  if (this.closed) return;
  this.pause();
  if (this.terminal) {
    this._setRawMode(false);
  }
  this.closed = true;
  this.emit('close');
};


Interface.prototype.pause = function() {
  if (this.paused) return;
  this.input.pause();
  this.paused = true;
  this.emit('pause');
  return this;
};


Interface.prototype.resume = function() {
  if (!this.paused) return;
  this.input.resume();
  this.paused = false;
  this.emit('resume');
  return this;
};


Interface.prototype.write = function(d, key) {
  if (this.paused) this.resume();
  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);
};

// \r\n, \n, or \r followed by something other than \n
var lineEnding = /\r?\n|\r(?!\n)/;
Interface.prototype._normalWrite = function(b) {
  if (util.isUndefined(b)) {
    return;
  }
  var string = this._decoder.write(b);
  if (this._sawReturn) {
    string = string.replace(/^\n/, '');
    this._sawReturn = false;
  }

  // Run test() on the new string chunk, not on the entire line buffer.
  var newPartContainsEnding = lineEnding.test(string);

  if (this._line_buffer) {
    string = this._line_buffer + string;
    this._line_buffer = null;
  }
  if (newPartContainsEnding) {
    this._sawReturn = /\r$/.test(string);

    // got one or more newlines; process into "line" events
    var lines = string.split(lineEnding);
    // either '' or (concievably) the unfinished portion of the next line
    string = lines.pop();
    this._line_buffer = string;
    lines.forEach(function(line) {
      this._onLine(line);
    }, this);
  } else if (string) {
    // no newlines this time, save what we have for next time
    this._line_buffer = string;
  }
};

Interface.prototype._insertString = function(c) {
  //BUG: Problem when adding tabs with following content.
  //     Perhaps the bug is in _refreshLine(). Not sure.
  //     A hack would be to insert spaces instead of literal '\t'.
  if (this.cursor < this.line.length) {
    var beg = this.line.slice(0, this.cursor);
    var end = this.line.slice(this.cursor, this.line.length);
    this.line = beg + c + end;
    this.cursor += c.length;
    this._refreshLine();
  } else {
    this.line += c;
    this.cursor += c.length;

    if (this._getCursorPos().cols === 0) {
      this._refreshLine();
    } else {
      this._writeToOutput(c);
    }

    // a hack to get the line refreshed if it's needed
    this._moveCursor(0);
  }
};

Interface.prototype._tabComplete = function() {
  var self = this;

  self.pause();
  self.completer(self.line.slice(0, self.cursor), function(err, rv) {
    self.resume();

    if (err) {
      // XXX Log it somewhere?
      return;
    }

    var completions = rv[0],
        completeOn = rv[1];  // the text that was completed
    if (completions && completions.length) {
      // Apply/show completions.
      if (completions.length === 1) {
        self._insertString(completions[0].slice(completeOn.length));
      } else {
        self._writeToOutput('\r\n');
        var width = completions.reduce(function(a, b) {
          return a.length > b.length ? a : b;
        }).length + 2;  // 2 space padding
        var maxColumns = Math.floor(self.columns / width) || 1;
        var group = [], c;
        for (var i = 0, compLen = completions.length; i < compLen; i++) {
          c = completions[i];
          if (c === '') {
            handleGroup(self, group, width, maxColumns);
            group = [];
          } else {
            group.push(c);
          }
        }
        handleGroup(self, group, width, maxColumns);

        // If there is a common prefix to all matches, then apply that
        // portion.
        var f = completions.filter(function(e) { if (e) return e; });
        var prefix = commonPrefix(f);
        if (prefix.length > completeOn.length) {
          self._insertString(prefix.slice(completeOn.length));
        }

      }
      self._refreshLine();
    }
  });
};

// this = Interface instance
function handleGroup(self, group, width, maxColumns) {
  if (group.length == 0) {
    return;
  }
  var minRows = Math.ceil(group.length / maxColumns);
  for (var row = 0; row < minRows; row++) {
    for (var col = 0; col < maxColumns; col++) {
      var idx = row * maxColumns + col;
      if (idx >= group.length) {
        break;
      }
      var item = group[idx];
      self._writeToOutput(item);
      if (col < maxColumns - 1) {
        for (var s = 0, itemLen = item.length; s < width - itemLen;
             s++) {
          self._writeToOutput(' ');
        }
      }
    }
    self._writeToOutput('\r\n');
  }
  self._writeToOutput('\r\n');
}

function commonPrefix(strings) {
  if (!strings || strings.length == 0) {
    return '';
  }
  var sorted = strings.slice().sort();
  var min = sorted[0];
  var max = sorted[sorted.length - 1];
  for (var i = 0, len = min.length; i < len; i++) {
    if (min[i] != max[i]) {
      return min.slice(0, i);
    }
  }
  return min;
}


Interface.prototype._wordLeft = function() {
  if (this.cursor > 0) {
    var leading = this.line.slice(0, this.cursor);
    var match = leading.match(/([^\w\s]+|\w+|)\s*$/);
    this._moveCursor(-match[0].length);
  }
};


Interface.prototype._wordRight = function() {
  if (this.cursor < this.line.length) {
    var trailing = this.line.slice(this.cursor);
    var match = trailing.match(/^(\s+|\W+|\w+)\s*/);
    this._moveCursor(match[0].length);
  }
};


Interface.prototype._deleteLeft = function() {
  if (this.cursor > 0 && this.line.length > 0) {
    this.line = this.line.slice(0, this.cursor - 1) +
                this.line.slice(this.cursor, this.line.length);

    this.cursor--;
    this._refreshLine();
  }
};


Interface.prototype._deleteRight = function() {
  this.line = this.line.slice(0, this.cursor) +
              this.line.slice(this.cursor + 1, this.line.length);
  this._refreshLine();
};


Interface.prototype._deleteWordLeft = function() {
  if (this.cursor > 0) {
    var leading = this.line.slice(0, this.cursor);
    var match = leading.match(/([^\w\s]+|\w+|)\s*$/);
    leading = leading.slice(0, leading.length - match[0].length);
    this.line = leading + this.line.slice(this.cursor, this.line.length);
    this.cursor = leading.length;
    this._refreshLine();
  }
};


Interface.prototype._deleteWordRight = function() {
  if (this.cursor < this.line.length) {
    var trailing = this.line.slice(this.cursor);
    var match = trailing.match(/^(\s+|\W+|\w+)\s*/);
    this.line = this.line.slice(0, this.cursor) +
                trailing.slice(match[0].length);
    this._refreshLine();
  }
};


Interface.prototype._deleteLineLeft = function() {
  this.line = this.line.slice(this.cursor);
  this.cursor = 0;
  this._refreshLine();
};


Interface.prototype._deleteLineRight = function() {
  this.line = this.line.slice(0, this.cursor);
  this._refreshLine();
};


Interface.prototype.clearLine = function() {
  this._moveCursor(+Infinity);
  this._writeToOutput('\r\n');
  this.line = '';
  this.cursor = 0;
  this.prevRows = 0;
};

// Get current input line content
Interface.prototype.getLine = function() {
  return this.line;  
};


// Insert a message before actual prompt input line
Interface.prototype.insertOutput = function(msg) {
  this._moveCursor(+Infinity);
  this._writeToOutput('\r');
  this._writeToOutput(msg+'\n');
  this._writeToOutput(this._prompt+this.line);
  
};

Interface.prototype._line = function() {
  var line = this._addHistory();
  this.clearLine();
  this._onLine(line);
};


Interface.prototype._historyNext = function() {
  if (this.historyIndex > 0) {
    this.historyIndex--;
    this.line = this.history[this.historyIndex];
    this.cursor = this.line.length; // set cursor to end of line.
    this._refreshLine();

  } else if (this.historyIndex === 0) {
    this.historyIndex = -1;
    this.cursor = 0;
    this.line = '';
    this._refreshLine();
  }
};


Interface.prototype._historyPrev = function() {
  if (this.historyIndex + 1 < this.history.length) {
    this.historyIndex++;
    this.line = this.history[this.historyIndex];
    this.cursor = this.line.length; // set cursor to end of line.

    this._refreshLine();
  }
};


// Returns the last character's display position of the given string
Interface.prototype._getDisplayPos = function(str) {
  var offset = 0;
  var col = this.columns;
  var row = 0;
  var code;
  str = stripVTControlCharacters(str);
  for (var i = 0, len = str.length; i < len; i++) {
    code = codePointAt(str, i);
    if (code >= 0x10000) { // surrogates
      i++;
    }
    if (code === 0x0a) { // new line \n
      offset = 0;
      row += 1;
      continue;
    }
    if (isFullWidthCodePoint(code)) {
      if ((offset + 1) % col === 0) {
        offset++;
      }
      offset += 2;
    } else {
      offset++;
    }
  }
  var cols = offset % col;
  var rows = row + (offset - cols) / col;
  return {cols: cols, rows: rows};
};


// Returns current cursor's position and line
Interface.prototype._getCursorPos = function() {
  var columns = this.columns;
  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);
  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));
  var cols = dispPos.cols;
  var rows = dispPos.rows;
  // If the cursor is on a full-width character which steps over the line,
  // move the cursor to the beginning of the next line.
  if (cols + 1 === columns &&
      this.cursor < this.line.length &&
      isFullWidthCodePoint(codePointAt(this.line, this.cursor))) {
    rows++;
    cols = 0;
  }
  return {cols: cols, rows: rows};
};


// This function moves cursor dx places to the right
// (-dx for left) and refreshes the line if it is needed
Interface.prototype._moveCursor = function(dx) {
  var oldcursor = this.cursor;
  var oldPos = this._getCursorPos();
  this.cursor += dx;

  // bounds check
  if (this.cursor < 0) this.cursor = 0;
  else if (this.cursor > this.line.length) this.cursor = this.line.length;

  var newPos = this._getCursorPos();

  // check if cursors are in the same line
  if (oldPos.rows === newPos.rows) {
    var diffCursor = this.cursor - oldcursor;
    var diffWidth;
    if (diffCursor < 0) {
      diffWidth = -getStringWidth(
          this.line.substring(this.cursor, oldcursor)
          );
    } else if (diffCursor > 0) {
      diffWidth = getStringWidth(
          this.line.substring(this.cursor, oldcursor)
          );
    }
    exports.moveCursor(this.output, diffWidth, 0);
    this.prevRows = newPos.rows;
  } else {
    this._refreshLine();
  }
};


// handle a write from the tty
Interface.prototype._ttyWrite = function(s, key) {
  key = key || {};

  // Ignore escape key - Fixes #2876
  if (key.name == 'escape') return;

  if (key.ctrl && key.shift) {
    /* Control and shift pressed */
    switch (key.name) {
      case 'backspace':
        this._deleteLineLeft();
        break;

      case 'delete':
        this._deleteLineRight();
        break;
    }

  } else if (key.ctrl) {
    /* Control key pressed */

    switch (key.name) {
      case 'c':
        if (EventEmitter.listenerCount(this, 'SIGINT') > 0) {
          this.emit('SIGINT');
        } else {
          // This readline instance is finished
          this.close();
        }
        break;

      case 'h': // delete left
        this._deleteLeft();
        break;

      case 'd': // delete right or EOF
        if (this.cursor === 0 && this.line.length === 0) {
          // This readline instance is finished
          this.close();
        } else if (this.cursor < this.line.length) {
          this._deleteRight();
        }
        break;

      case 'u': // delete the whole line
        this.cursor = 0;
        this.line = '';
        this._refreshLine();
        break;

      case 'k': // delete from current to end of line
        this._deleteLineRight();
        break;

      case 'a': // go to the start of the line
        this._moveCursor(-Infinity);
        break;

      case 'e': // go to the end of the line
        this._moveCursor(+Infinity);
        break;

      case 'b': // back one character
        this._moveCursor(-1);
        break;

      case 'f': // forward one character
        this._moveCursor(+1);
        break;

      case 'l': // clear the whole screen
        exports.cursorTo(this.output, 0, 0);
        exports.clearScreenDown(this.output);
        this._refreshLine();
        break;

      case 'n': // next history item
        this._historyNext();
        break;

      case 'p': // previous history item
        this._historyPrev();
        break;

      case 'z':
        if (process.platform == 'win32') break;
        if (EventEmitter.listenerCount(this, 'SIGTSTP') > 0) {
          this.emit('SIGTSTP');
        } else {
          process.once('SIGCONT', (function(self) {
            return function() {
              // Don't raise events if stream has already been abandoned.
              if (!self.paused) {
                // Stream must be paused and resumed after SIGCONT to catch
                // SIGINT, SIGTSTP, and EOF.
                self.pause();
                self.emit('SIGCONT');
              }
              // explicitly re-enable "raw mode" and move the cursor to
              // the correct position.
              // See https://github.com/joyent/node/issues/3295.
              self._setRawMode(true);
              self._refreshLine();
            };
          })(this));
          this._setRawMode(false);
          process.kill(process.pid, 'SIGTSTP');
        }
        break;

      case 'w': // delete backwards to a word boundary
      case 'backspace':
        this._deleteWordLeft();
        break;

      case 'delete': // delete forward to a word boundary
        this._deleteWordRight();
        break;

      case 'left':
        this._wordLeft();
        break;

      case 'right':
        this._wordRight();
        break;
    }

  } else if (key.meta) {
    /* Meta key pressed */

    switch (key.name) {
      case 'b': // backward word
        this._wordLeft();
        break;

      case 'f': // forward word
        this._wordRight();
        break;

      case 'd': // delete forward word
      case 'delete':
        this._deleteWordRight();
        break;

      case 'backspace': // delete backwards to a word boundary
        this._deleteWordLeft();
        break;
    }

  } else {
    /* No modifier keys used */

    // \r bookkeeping is only relevant if a \n comes right after.
    if (this._sawReturn && key.name !== 'enter')
      this._sawReturn = false;

    switch (key.name) {
      case 'return':  // carriage return, i.e. \r
        this._sawReturn = true;
        this._line();
        break;

      case 'enter':
        if (this._sawReturn)
          this._sawReturn = false;
        else
          this._line();
        break;

      case 'backspace':
        this._deleteLeft();
        break;

      case 'delete':
        this._deleteRight();
        break;

      case 'tab': // tab completion
        this._tabComplete();
        break;

      case 'left':
        this._moveCursor(-1);
        break;

      case 'right':
        this._moveCursor(+1);
        break;

      case 'home':
        this._moveCursor(-Infinity);
        break;

      case 'end':
        this._moveCursor(+Infinity);
        break;

      case 'up':
        this._historyPrev();
        break;

      case 'down':
        this._historyNext();
        break;

      default:
        if (util.isBuffer(s))
          s = s.toString('utf-8');

        if (s) {
          var lines = s.split(/\r\n|\n|\r/);
          for (var i = 0, len = lines.length; i < len; i++) {
            if (i > 0) {
              this._line();
            }
            this._insertString(lines[i]);
          }
        }
    }
  }
};


exports.Interface = Interface;



/**
 * accepts a readable Stream instance and makes it emit "keypress" events
 */

function emitKeypressEvents(stream) {
  if (stream._keypressDecoder) return;
  var StringDecoder = Require('string_decoder').StringDecoder; // lazy load
  stream._keypressDecoder = new StringDecoder('utf8');

  function onData(b) {
    if (EventEmitter.listenerCount(stream, 'keypress') > 0) {
      var r = stream._keypressDecoder.write(b);
      if (r) emitKeys(stream, r);
    } else {
      // Nobody's watching anyway
      stream.removeListener('data', onData);
      stream.on('newListener', onNewListener);
    }
  }

  function onNewListener(event) {
    if (event == 'keypress') {
      stream.on('data', onData);
      stream.removeListener('newListener', onNewListener);
    }
  }

  if (EventEmitter.listenerCount(stream, 'keypress') > 0) {
    stream.on('data', onData);
  } else {
    stream.on('newListener', onNewListener);
  }
}
exports.emitKeypressEvents = emitKeypressEvents;

/*
  Some patterns seen in terminal key escape codes, derived from combos seen
  at http://www.midnight-commander.org/browser/lib/tty/key.c

  ESC letter
  ESC [ letter
  ESC [ modifier letter
  ESC [ 1 ; modifier letter
  ESC [ num char
  ESC [ num ; modifier char
  ESC O letter
  ESC O modifier letter
  ESC O 1 ; modifier letter
  ESC N letter
  ESC [ [ num ; modifier char
  ESC [ [ 1 ; modifier letter
  ESC ESC [ num char
  ESC ESC O letter

  - char is usually ~ but $ and ^ also happen with rxvt
  - modifier is 1 +
                (shift     * 1) +
                (left_alt  * 2) +
                (ctrl      * 4) +
                (right_alt * 8)
  - two leading ESCs apparently mean the same as one leading ESC
*/

// Regexes used for ansi escape code splitting
var metaKeyCodeReAnywhere = /(?:\x1b)([a-zA-Z0-9])/;
var metaKeyCodeRe = new RegExp('^' + metaKeyCodeReAnywhere.source + '$');
var functionKeyCodeReAnywhere = new RegExp('(?:\x1b+)(O|N|\\[|\\[\\[)(?:' + [
  '(\\d+)(?:;(\\d+))?([~^$])',
  '(?:M([@ #!a`])(.)(.))', // mouse
  '(?:1;)?(\\d+)?([a-zA-Z])'
].join('|') + ')');
var functionKeyCodeRe = new RegExp('^' + functionKeyCodeReAnywhere.source);
var escapeCodeReAnywhere = new RegExp([
  functionKeyCodeReAnywhere.source, metaKeyCodeReAnywhere.source, /\x1b./.source
].join('|'));

function emitKeys(stream, s) {
  if (util.isBuffer(s)) {
    if (s[0] > 127 && util.isUndefined(s[1])) {
      s[0] -= 128;
      s = '\x1b' + s.toString(stream.encoding || 'utf-8');
    } else {
      s = s.toString(stream.encoding || 'utf-8');
    }
  }

  var buffer = [];
  var match;
  while (match = escapeCodeReAnywhere.exec(s)) {
    buffer = buffer.concat(s.slice(0, match.index).split(''));
    buffer.push(match[0]);
    s = s.slice(match.index + match[0].length);
  }
  buffer = buffer.concat(s.split(''));

  buffer.forEach(function(s) {
    var ch,
        key = {
          sequence: s,
          name: undefined,
          ctrl: false,
          meta: false,
          shift: false
        },
        parts;

    if (s === '\r') {
      // carriage return
      key.name = 'return';

    } else if (s === '\n') {
      // enter, should have been called linefeed
      key.name = 'enter';

    } else if (s === '\t') {
      // tab
      key.name = 'tab';

    } else if (s === '\b' || s === '\x7f' ||
               s === '\x1b\x7f' || s === '\x1b\b') {
      // backspace or ctrl+h
      key.name = 'backspace';
      key.meta = (s.charAt(0) === '\x1b');

    } else if (s === '\x1b' || s === '\x1b\x1b') {
      // escape key
      key.name = 'escape';
      key.meta = (s.length === 2);

    } else if (s === ' ' || s === '\x1b ') {
      key.name = 'space';
      key.meta = (s.length === 2);

    } else if (s.length === 1 && s <= '\x1a') {
      // ctrl+letter
      key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
      key.ctrl = true;

    } else if (s.length === 1 && s >= 'a' && s <= 'z') {
      // lowercase letter
      key.name = s;

    } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
      // shift+letter
      key.name = s.toLowerCase();
      key.shift = true;

    } else if (parts = metaKeyCodeRe.exec(s)) {
      // meta+character key
      key.name = parts[1].toLowerCase();
      key.meta = true;
      key.shift = /^[A-Z]$/.test(parts[1]);

    } else if (parts = functionKeyCodeRe.exec(s)) {
      // ansi escape sequence

      // reassemble the key code leaving out leading \x1b's,
      // the modifier key bitflag and any meaningless "1;" sequence
      var code = (parts[1] || '') + (parts[2] || '') +
                 (parts[4] || '') + (parts[9] || ''),
          modifier = (parts[3] || parts[8] || 1) - 1;

      // Parse the key modifier
      key.ctrl = !!(modifier & 4);
      key.meta = !!(modifier & 10);
      key.shift = !!(modifier & 1);
      key.code = code;

      // Parse the key itself
      switch (code) {
        /* xterm/gnome ESC O letter */
        case 'OP': key.name = 'f1'; break;
        case 'OQ': key.name = 'f2'; break;
        case 'OR': key.name = 'f3'; break;
        case 'OS': key.name = 'f4'; break;

        /* xterm/rxvt ESC [ number ~ */
        case '[11~': key.name = 'f1'; break;
        case '[12~': key.name = 'f2'; break;
        case '[13~': key.name = 'f3'; break;
        case '[14~': key.name = 'f4'; break;

        /* from Cygwin and used in libuv */
        case '[[A': key.name = 'f1'; break;
        case '[[B': key.name = 'f2'; break;
        case '[[C': key.name = 'f3'; break;
        case '[[D': key.name = 'f4'; break;
        case '[[E': key.name = 'f5'; break;

        /* common */
        case '[15~': key.name = 'f5'; break;
        case '[17~': key.name = 'f6'; break;
        case '[18~': key.name = 'f7'; break;
        case '[19~': key.name = 'f8'; break;
        case '[20~': key.name = 'f9'; break;
        case '[21~': key.name = 'f10'; break;
        case '[23~': key.name = 'f11'; break;
        case '[24~': key.name = 'f12'; break;

        /* xterm ESC [ letter */
        case '[A': key.name = 'up'; break;
        case '[B': key.name = 'down'; break;
        case '[C': key.name = 'right'; break;
        case '[D': key.name = 'left'; break;
        case '[E': key.name = 'clear'; break;
        case '[F': key.name = 'end'; break;
        case '[H': key.name = 'home'; break;

        /* xterm/gnome ESC O letter */
        case 'OA': key.name = 'up'; break;
        case 'OB': key.name = 'down'; break;
        case 'OC': key.name = 'right'; break;
        case 'OD': key.name = 'left'; break;
        case 'OE': key.name = 'clear'; break;
        case 'OF': key.name = 'end'; break;
        case 'OH': key.name = 'home'; break;

        /* xterm/rxvt ESC [ number ~ */
        case '[1~': key.name = 'home'; break;
        case '[2~': key.name = 'insert'; break;
        case '[3~': key.name = 'delete'; break;
        case '[4~': key.name = 'end'; break;
        case '[5~': key.name = 'pageup'; break;
        case '[6~': key.name = 'pagedown'; break;

        /* putty */
        case '[[5~': key.name = 'pageup'; break;
        case '[[6~': key.name = 'pagedown'; break;

        /* rxvt */
        case '[7~': key.name = 'home'; break;
        case '[8~': key.name = 'end'; break;

        /* rxvt keys with modifiers */
        case '[a': key.name = 'up'; key.shift = true; break;
        case '[b': key.name = 'down'; key.shift = true; break;
        case '[c': key.name = 'right'; key.shift = true; break;
        case '[d': key.name = 'left'; key.shift = true; break;
        case '[e': key.name = 'clear'; key.shift = true; break;

        case '[2$': key.name = 'insert'; key.shift = true; break;
        case '[3$': key.name = 'delete'; key.shift = true; break;
        case '[5$': key.name = 'pageup'; key.shift = true; break;
        case '[6$': key.name = 'pagedown'; key.shift = true; break;
        case '[7$': key.name = 'home'; key.shift = true; break;
        case '[8$': key.name = 'end'; key.shift = true; break;

        case 'Oa': key.name = 'up'; key.ctrl = true; break;
        case 'Ob': key.name = 'down'; key.ctrl = true; break;
        case 'Oc': key.name = 'right'; key.ctrl = true; break;
        case 'Od': key.name = 'left'; key.ctrl = true; break;
        case 'Oe': key.name = 'clear'; key.ctrl = true; break;

        case '[2^': key.name = 'insert'; key.ctrl = true; break;
        case '[3^': key.name = 'delete'; key.ctrl = true; break;
        case '[5^': key.name = 'pageup'; key.ctrl = true; break;
        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;
        case '[7^': key.name = 'home'; key.ctrl = true; break;
        case '[8^': key.name = 'end'; key.ctrl = true; break;

        /* misc. */
        case '[Z': key.name = 'tab'; key.shift = true; break;
        default: key.name = 'undefined'; break;

      }
    }

    // Don't emit a key if no name was found
    if (util.isUndefined(key.name)) {
      key = undefined;
    }

    if (s.length === 1) {
      ch = s;
    }

    if (key || ch) {
      stream.emit('keypress', ch, key);
    }
  });
}


/**
 * moves the cursor to the x and y coordinate on the given stream
 */

function cursorTo(stream, x, y) {
  if (util.isNullOrUndefined(stream))
    return;

  if (!util.isNumber(x) && !util.isNumber(y))
    return;

  if (!util.isNumber(x))
    throw new Error("Can't set cursor row without also setting it's column");

  if (!util.isNumber(y)) {
    stream.write('\x1b[' + (x + 1) + 'G');
  } else {
    stream.write('\x1b[' + (y + 1) + ';' + (x + 1) + 'H');
  }
}
exports.cursorTo = cursorTo;


/**
 * moves the cursor relative to its current location
 */

function moveCursor(stream, dx, dy) {
  if (util.isNullOrUndefined(stream))
    return;

  if (dx < 0) {
    stream.write('\x1b[' + (-dx) + 'D');
  } else if (dx > 0) {
    stream.write('\x1b[' + dx + 'C');
  }

  if (dy < 0) {
    stream.write('\x1b[' + (-dy) + 'A');
  } else if (dy > 0) {
    stream.write('\x1b[' + dy + 'B');
  }
}
exports.moveCursor = moveCursor;


/**
 * clears the current line the cursor is on:
 *   -1 for left of the cursor
 *   +1 for right of the cursor
 *    0 for the entire line
 */

function clearLine(stream, dir) {
  if (util.isNullOrUndefined(stream))
    return;

  if (dir < 0) {
    // to the beginning
    stream.write('\x1b[1K');
  } else if (dir > 0) {
    // to the end
    stream.write('\x1b[0K');
  } else {
    // entire line
    stream.write('\x1b[2K');
  }
}
exports.clearLine = clearLine;


/**
 * clears the screen from the current position of the cursor down
 */

function clearScreenDown(stream) {
  if (util.isNullOrUndefined(stream))
    return;

  stream.write('\x1b[0J');
}
exports.clearScreenDown = clearScreenDown;


/**
 * Returns the number of columns required to display the given string.
 */

function getStringWidth(str) {
  var width = 0;
  str = stripVTControlCharacters(str);
  for (var i = 0, len = str.length; i < len; i++) {
    var code = codePointAt(str, i);
    if (code >= 0x10000) { // surrogates
      i++;
    }
    if (isFullWidthCodePoint(code)) {
      width += 2;
    } else {
      width++;
    }
  }
  return width;
}
exports.getStringWidth = getStringWidth;


/**
 * Returns true if the character represented by a given
 * Unicode code point is full-width. Otherwise returns false.
 */

function isFullWidthCodePoint(code) {
  if (isNaN(code)) {
    return false;
  }

  // Code points are derived from:
  // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt
  if (code >= 0x1100 && (
      code <= 0x115f ||  // Hangul Jamo
      0x2329 === code || // LEFT-POINTING ANGLE BRACKET
      0x232a === code || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||
      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      0x3250 <= code && code <= 0x4dbf ||
      // CJK Unified Ideographs .. Yi Radicals
      0x4e00 <= code && code <= 0xa4c6 ||
      // Hangul Jamo Extended-A
      0xa960 <= code && code <= 0xa97c ||
      // Hangul Syllables
      0xac00 <= code && code <= 0xd7a3 ||
      // CJK Compatibility Ideographs
      0xf900 <= code && code <= 0xfaff ||
      // Vertical Forms
      0xfe10 <= code && code <= 0xfe19 ||
      // CJK Compatibility Forms .. Small Form Variants
      0xfe30 <= code && code <= 0xfe6b ||
      // Halfwidth and Fullwidth Forms
      0xff01 <= code && code <= 0xff60 ||
      0xffe0 <= code && code <= 0xffe6 ||
      // Kana Supplement
      0x1b000 <= code && code <= 0x1b001 ||
      // Enclosed Ideographic Supplement
      0x1f200 <= code && code <= 0x1f251 ||
      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      0x20000 <= code && code <= 0x3fffd)) {
    return true;
  }
  return false;
}
exports.isFullWidthCodePoint = isFullWidthCodePoint;


/**
 * Returns the Unicode code point for the character at the
 * given index in the given string. Similar to String.charCodeAt(),
 * but this function handles surrogates (code point >= 0x10000).
 */

function codePointAt(str, index) {
  var code = str.charCodeAt(index);
  var low;
  if (0xd800 <= code && code <= 0xdbff) { // High surrogate
    low = str.charCodeAt(index + 1);
    if (!isNaN(low)) {
      code = 0x10000 + (code - 0xd800) * 0x400 + (low - 0xdc00);
    }
  }
  return code;
}
exports.codePointAt = codePointAt;


/**
 * Tries to remove all VT control characters. Use to estimate displayed
 * string width. May be buggy due to not running a real state machine
 */
function stripVTControlCharacters(str) {
  str = str.replace(new RegExp(functionKeyCodeReAnywhere.source, 'g'), '');
  return str.replace(new RegExp(metaKeyCodeReAnywhere.source, 'g'), '');
}
exports.stripVTControlCharacters = stripVTControlCharacters;

};
BundleModuleCode['term/readlineSync']=function (module,exports){
/*
 * readlineSync
 * https://github.com/anseki/readline-sync
 *
 * Copyright (c) 2018 anseki
 * Licensed under the MIT license.
 */

'use strict';

var
  IS_WIN = process.platform === 'win32',

  ALGORITHM_CIPHER = 'aes-256-cbc',
  ALGORITHM_HASH = 'sha256',
  DEFAULT_ERR_MSG = 'The current environment doesn\'t support interactive reading from TTY.',

  fs = require('fs'),
  TTY = process.binding('tty_wrap').TTY,
  childProc = require('child_process'),
  pathUtil = require('path'),

  defaultOptions = {
    /* eslint-disable key-spacing */
    prompt:             '> ',
    hideEchoBack:       false,
    mask:               '*',
    limit:              [],
    limitMessage:       'Input another, please.$<( [)limit(])>',
    defaultInput:       '',
    trueValue:          [],
    falseValue:         [],
    caseSensitive:      false,
    keepWhitespace:     false,
    encoding:           'utf8',
    bufferSize:         1024,
    print:              void 0,
    history:            true,
    cd:                 false,
    phContent:          void 0,
    preCheck:           void 0
    /* eslint-enable key-spacing */
  },

  fdR = 'none', fdW, ttyR, isRawMode = false,
  extHostPath, extHostArgs, tempdir, salt = 0,
  lastInput = '', inputHistory = [], rawInput,
  _DBG_useExt = false, _DBG_checkOptions = false, _DBG_checkMethod = false;

function getHostArgs(options) {
  // Send any text to crazy Windows shell safely.
  function encodeArg(arg) {
    return arg.replace(/[^\w\u0080-\uFFFF]/g, function(chr) {
      return '#' + chr.charCodeAt(0) + ';';
    });
  }

  return extHostArgs.concat((function(conf) {
    var args = [];
    Object.keys(conf).forEach(function(optionName) {
      if (conf[optionName] === 'boolean') {
        if (options[optionName]) { args.push('--' + optionName); }
      } else if (conf[optionName] === 'string') {
        if (options[optionName]) {
          args.push('--' + optionName, encodeArg(options[optionName]));
        }
      }
    });
    return args;
  })({
    /* eslint-disable key-spacing */
    display:        'string',
    displayOnly:    'boolean',
    keyIn:          'boolean',
    hideEchoBack:   'boolean',
    mask:           'string',
    limit:          'string',
    caseSensitive:  'boolean'
    /* eslint-enable key-spacing */
  }));
}

// piping via files (for Node.js v0.10-)
function _execFileSync(options, execOptions) {

  function getTempfile(name) {
    var filepath, suffix = '', fd;
    tempdir = tempdir || require('os').tmpdir();

    while (true) {
      filepath = pathUtil.join(tempdir, name + suffix);
      try {
        fd = fs.openSync(filepath, 'wx');
      } catch (e) {
        if (e.code === 'EEXIST') {
          suffix++;
          continue;
        } else {
          throw e;
        }
      }
      fs.closeSync(fd);
      break;
    }
    return filepath;
  }

  var hostArgs, shellPath, shellArgs, res = {}, exitCode, extMessage,
    pathStdout = getTempfile('readline-sync.stdout'),
    pathStderr = getTempfile('readline-sync.stderr'),
    pathExit = getTempfile('readline-sync.exit'),
    pathDone = getTempfile('readline-sync.done'),
    crypto = require('crypto'), shasum, decipher, password;

  shasum = crypto.createHash(ALGORITHM_HASH);
  shasum.update('' + process.pid + (salt++) + Math.random());
  password = shasum.digest('hex');
  decipher = crypto.createDecipher(ALGORITHM_CIPHER, password);

  hostArgs = getHostArgs(options);
  if (IS_WIN) {
    shellPath = process.env.ComSpec || 'cmd.exe';
    process.env.Q = '"'; // The quote (") that isn't escaped.
    // `()` for ignore space by echo
    shellArgs = ['/V:ON', '/S', '/C',
      '(%Q%' + shellPath + '%Q% /V:ON /S /C %Q%' + /* ESLint bug? */ // eslint-disable-line no-path-concat
        '%Q%' + extHostPath + '%Q%' +
          hostArgs.map(function(arg) { return ' %Q%' + arg + '%Q%'; }).join('') +
        ' & (echo !ERRORLEVEL!)>%Q%' + pathExit + '%Q%%Q%) 2>%Q%' + pathStderr + '%Q%' +
      ' |%Q%' + process.execPath + '%Q% %Q%' + __dirname + '\\encrypt.js%Q%' +
        ' %Q%' + ALGORITHM_CIPHER + '%Q% %Q%' + password + '%Q%' +
        ' >%Q%' + pathStdout + '%Q%' +
      ' & (echo 1)>%Q%' + pathDone + '%Q%'];
  } else {
    shellPath = '/bin/sh';
    shellArgs = ['-c',
      // Use `()`, not `{}` for `-c` (text param)
      '("' + extHostPath + '"' + /* ESLint bug? */ // eslint-disable-line no-path-concat
          hostArgs.map(function(arg) { return " '" + arg.replace(/'/g, "'\\''") + "'"; }).join('') +
        '; echo $?>"' + pathExit + '") 2>"' + pathStderr + '"' +
      ' |"' + process.execPath + '" "' + __dirname + '/encrypt.js"' +
        ' "' + ALGORITHM_CIPHER + '" "' + password + '"' +
        ' >"' + pathStdout + '"' +
      '; echo 1 >"' + pathDone + '"'];
  }
  if (_DBG_checkMethod) { _DBG_checkMethod('_execFileSync', hostArgs); }
  try {
    childProc.spawn(shellPath, shellArgs, execOptions);
  } catch (e) {
    res.error = new Error(e.message);
    res.error.method = '_execFileSync - spawn';
    res.error.program = shellPath;
    res.error.args = shellArgs;
  }

  while (fs.readFileSync(pathDone, {encoding: options.encoding}).trim() !== '1') {} // eslint-disable-line no-empty
  if ((exitCode =
      fs.readFileSync(pathExit, {encoding: options.encoding}).trim()) === '0') {
    res.input =
      decipher.update(fs.readFileSync(pathStdout, {encoding: 'binary'}),
        'hex', options.encoding) +
      decipher.final(options.encoding);
  } else {
    extMessage = fs.readFileSync(pathStderr, {encoding: options.encoding}).trim();
    res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
    res.error.method = '_execFileSync';
    res.error.program = shellPath;
    res.error.args = shellArgs;
    res.error.extMessage = extMessage;
    res.error.exitCode = +exitCode;
  }

  fs.unlinkSync(pathStdout);
  fs.unlinkSync(pathStderr);
  fs.unlinkSync(pathExit);
  fs.unlinkSync(pathDone);

  return res;
}

function readlineExt(options) {
  var hostArgs, res = {}, extMessage,
    execOptions = {env: process.env, encoding: options.encoding};

  if (!extHostPath) {
    if (IS_WIN) {
      if (process.env.PSModulePath) { // Windows PowerShell
        extHostPath = 'powershell.exe';
        extHostArgs = ['-ExecutionPolicy', 'Bypass', '-File', __dirname + '\\read.ps1']; // eslint-disable-line no-path-concat
      } else {                        // Windows Script Host
        extHostPath = 'cscript.exe';
        extHostArgs = ['//nologo', __dirname + '\\read.cs.js']; // eslint-disable-line no-path-concat
      }
    } else {
      extHostPath = '/bin/sh';
      extHostArgs = [__dirname + '/read.sh']; // eslint-disable-line no-path-concat
    }
  }
  if (IS_WIN && !process.env.PSModulePath) { // Windows Script Host
    // ScriptPW (Win XP and Server2003) needs TTY stream as STDIN.
    // In this case, If STDIN isn't TTY, an error is thrown.
    execOptions.stdio = [process.stdin];
  }

  if (childProc.execFileSync) {
    hostArgs = getHostArgs(options);
    if (_DBG_checkMethod) { _DBG_checkMethod('execFileSync', hostArgs); }
    try {
      res.input = childProc.execFileSync(extHostPath, hostArgs, execOptions);
    } catch (e) { // non-zero exit code
      extMessage = e.stderr ? (e.stderr + '').trim() : '';
      res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
      res.error.method = 'execFileSync';
      res.error.program = extHostPath;
      res.error.args = hostArgs;
      res.error.extMessage = extMessage;
      res.error.exitCode = e.status;
      res.error.code = e.code;
      res.error.signal = e.signal;
    }
  } else {
    res = _execFileSync(options, execOptions);
  }
  if (!res.error) {
    res.input = res.input.replace(/^\s*'|'\s*$/g, '');
    options.display = '';
  }

  return res;
}

/*
  display:            string
  displayOnly:        boolean
  keyIn:              boolean
  hideEchoBack:       boolean
  mask:               string
  limit:              string (pattern)
  caseSensitive:      boolean
  keepWhitespace:     boolean
  encoding, bufferSize, print
*/
function _readlineSync(options) {
  var input = '', displaySave = options.display,
    silent = !options.display &&
      options.keyIn && options.hideEchoBack && !options.mask;

  function tryExt() {
    var res = readlineExt(options);
    if (res.error) { throw res.error; }
    return res.input;
  }

  if (_DBG_checkOptions) { _DBG_checkOptions(options); }

  (function() { // open TTY
    var fsB, constants, verNum;

    function getFsB() {
      if (!fsB) {
        fsB = process.binding('fs'); // For raw device path
        constants = process.binding('constants');
      }
      return fsB;
    }

    if (typeof fdR !== 'string') { return; }
    fdR = null;

    if (IS_WIN) {
      // iojs-v2.3.2+ input stream can't read first line. (#18)
      // ** Don't get process.stdin before check! **
      // Fixed v5.1.0
      // Fixed v4.2.4
      // It regressed again in v5.6.0, it is fixed in v6.2.0.
      verNum = (function(ver) { // getVerNum
        var nums = ver.replace(/^\D+/, '').split('.');
        var verNum = 0;
        if ((nums[0] = +nums[0])) { verNum += nums[0] * 10000; }
        if ((nums[1] = +nums[1])) { verNum += nums[1] * 100; }
        if ((nums[2] = +nums[2])) { verNum += nums[2]; }
        return verNum;
      })(process.version);
      if (!(verNum >= 20302 && verNum < 40204 || verNum >= 50000 && verNum < 50100 || verNum >= 50600 && verNum < 60200) &&
          process.stdin.isTTY) {
        process.stdin.pause();
        fdR = process.stdin.fd;
        ttyR = process.stdin._handle;
      } else {
        try {
          // The stream by fs.openSync('\\\\.\\CON', 'r') can't switch to raw mode.
          // 'CONIN$' might fail on XP, 2000, 7 (x86).
          fdR = getFsB().open('CONIN$', constants.O_RDWR, parseInt('0666', 8));
          ttyR = new TTY(fdR, true);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('\\\\.\\CON', 'w');
        } catch (e) { /* ignore */ }
        if (typeof fdW !== 'number') { // Retry
          try {
            fdW = getFsB().open('CONOUT$', constants.O_RDWR, parseInt('0666', 8));
          } catch (e) { /* ignore */ }
        }
      }

    } else {
      if (process.stdin.isTTY) {
        process.stdin.pause();
        try {
          fdR = fs.openSync('/dev/tty', 'r'); // device file, not process.stdin
          ttyR = process.stdin._handle;
        } catch (e) { /* ignore */ }
      } else {
        // Node.js v0.12 read() fails.
        try {
          fdR = fs.openSync('/dev/tty', 'r');
          ttyR = new TTY(fdR, false);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('/dev/tty', 'w');
        } catch (e) { /* ignore */ }
      }
    }
  })();

  (function() { // try read
    var atEol, limit,
      isCooked = !options.hideEchoBack && !options.keyIn,
      buffer, reqSize, readSize, chunk, line;
    rawInput = '';

    // Node.js v0.10- returns an error if same mode is set.
    function setRawMode(mode) {
      if (mode === isRawMode) { return true; }
      if (ttyR.setRawMode(mode) !== 0) { return false; }
      isRawMode = mode;
      return true;
    }

    if (_DBG_useExt || !ttyR ||
        typeof fdW !== 'number' && (options.display || !isCooked)) {
      input = tryExt();
      return;
    }

    if (options.display) {
      fs.writeSync(fdW, options.display);
      options.display = '';
    }
    if (options.displayOnly) { return; }

    if (!setRawMode(!isCooked)) {
      input = tryExt();
      return;
    }

    reqSize = options.keyIn ? 1 : options.bufferSize;
    // Check `allocUnsafe` to make sure of the new API.
    buffer = Buffer.allocUnsafe && Buffer.alloc ? Buffer.alloc(reqSize) : new Buffer(reqSize);

    if (options.keyIn && options.limit) {
      limit = new RegExp('[^' + options.limit + ']',
        'g' + (options.caseSensitive ? '' : 'i'));
    }

    while (true) {
      readSize = 0;
      try {
        readSize = fs.readSync(fdR, buffer, 0, reqSize);
      } catch (e) {
        if (e.code !== 'EOF') {
          setRawMode(false);
          input += tryExt();
          return;
        }
      }
      if (readSize > 0) {
        chunk = buffer.toString(options.encoding, 0, readSize);
        rawInput += chunk;
      } else {
        chunk = '\n';
        rawInput += String.fromCharCode(0);
      }

      if (chunk && typeof (line = (chunk.match(/^(.*?)[\r\n]/) || [])[1]) === 'string') {
        chunk = line;
        atEol = true;
      }

      // other ctrl-chars
      // eslint-disable-next-line no-control-regex
      if (chunk) { chunk = chunk.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]/g, ''); }
      if (chunk && limit) { chunk = chunk.replace(limit, ''); }

      if (chunk) {
        if (!isCooked) {
          if (!options.hideEchoBack) {
            fs.writeSync(fdW, chunk);
          } else if (options.mask) {
            fs.writeSync(fdW, (new Array(chunk.length + 1)).join(options.mask));
          }
        }
        input += chunk;
      }

      if (!options.keyIn && atEol ||
        options.keyIn && input.length >= reqSize) { break; }
    }

    if (!isCooked && !silent) { fs.writeSync(fdW, '\n'); }
    setRawMode(false);
  })();

  if (options.print && !silent) {
    options.print(displaySave + (options.displayOnly ? '' :
        (options.hideEchoBack ? (new Array(input.length + 1)).join(options.mask)
          : input) + '\n'), // must at least write '\n'
      options.encoding);
  }

  return options.displayOnly ? '' :
    (lastInput = options.keepWhitespace || options.keyIn ? input : input.trim());
}

function flattenArray(array, validator) {
  var flatArray = [];
  function _flattenArray(array) {
    if (array == null) {
      return;
    } else if (Array.isArray(array)) {
      array.forEach(_flattenArray);
    } else if (!validator || validator(array)) {
      flatArray.push(array);
    }
  }
  _flattenArray(array);
  return flatArray;
}

function escapePattern(pattern) {
  return pattern.replace(/[\x00-\x7f]/g, // eslint-disable-line no-control-regex
    function(s) { return '\\x' + ('00' + s.charCodeAt().toString(16)).substr(-2); });
}

// margeOptions(options1, options2 ... )
// margeOptions(true, options1, options2 ... )
//    arg1=true : Start from defaultOptions and pick elements of that.
function margeOptions() {
  var optionsList = Array.prototype.slice.call(arguments),
    optionNames, fromDefault;

  if (optionsList.length && typeof optionsList[0] === 'boolean') {
    fromDefault = optionsList.shift();
    if (fromDefault) {
      optionNames = Object.keys(defaultOptions);
      optionsList.unshift(defaultOptions);
    }
  }

  return optionsList.reduce(function(options, optionsPart) {
    if (optionsPart == null) { return options; }

    // ======== DEPRECATED ========
    if (optionsPart.hasOwnProperty('noEchoBack') &&
        !optionsPart.hasOwnProperty('hideEchoBack')) {
      optionsPart.hideEchoBack = optionsPart.noEchoBack;
      delete optionsPart.noEchoBack;
    }
    if (optionsPart.hasOwnProperty('noTrim') &&
        !optionsPart.hasOwnProperty('keepWhitespace')) {
      optionsPart.keepWhitespace = optionsPart.noTrim;
      delete optionsPart.noTrim;
    }
    // ======== /DEPRECATED ========

    if (!fromDefault) { optionNames = Object.keys(optionsPart); }
    optionNames.forEach(function(optionName) {
      var value;
      if (!optionsPart.hasOwnProperty(optionName)) { return; }
      value = optionsPart[optionName];
      switch (optionName) {
                           // _readlineSync <- *    * -> defaultOptions
        // ================ string
        case 'mask':                        // *    *
        case 'limitMessage':                //      *
        case 'defaultInput':                //      *
        case 'encoding':                    // *    *
          value = value != null ? value + '' : '';
          if (value && optionName !== 'limitMessage') { value = value.replace(/[\r\n]/g, ''); }
          options[optionName] = value;
          break;
        // ================ number(int)
        case 'bufferSize':                  // *    *
          if (!isNaN(value = parseInt(value, 10)) && typeof value === 'number') {
            options[optionName] = value; // limited updating (number is needed)
          }
          break;
        // ================ boolean
        case 'displayOnly':                 // *
        case 'keyIn':                       // *
        case 'hideEchoBack':                // *    *
        case 'caseSensitive':               // *    *
        case 'keepWhitespace':              // *    *
        case 'history':                     //      *
        case 'cd':                          //      *
          options[optionName] = !!value;
          break;
        // ================ array
        case 'limit':                       // *    *     to string for readlineExt
        case 'trueValue':                   //      *
        case 'falseValue':                  //      *
          options[optionName] = flattenArray(value, function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number' ||
              type === 'function' || value instanceof RegExp;
          }).map(function(value) {
            return typeof value === 'string' ? value.replace(/[\r\n]/g, '') : value;
          });
          break;
        // ================ function
        case 'print':                       // *    *
        case 'phContent':                   //      *
        case 'preCheck':                    //      *
          options[optionName] = typeof value === 'function' ? value : void 0;
          break;
        // ================ other
        case 'prompt':                      //      *
        case 'display':                     // *
          options[optionName] = value != null ? value : '';
          break;
        // no default
      }
    });
    return options;
  }, {});
}

function isMatched(res, comps, caseSensitive) {
  return comps.some(function(comp) {
    var type = typeof comp;
    return type === 'string' ?
        (caseSensitive ? res === comp : res.toLowerCase() === comp.toLowerCase()) :
      type === 'number' ? parseFloat(res) === comp :
      type === 'function' ? comp(res) :
      comp instanceof RegExp ? comp.test(res) : false;
  });
}

function replaceHomePath(path, expand) {
  var homePath = pathUtil.normalize(
    IS_WIN ? (process.env.HOMEDRIVE || '') + (process.env.HOMEPATH || '') :
    process.env.HOME || '').replace(/[\/\\]+$/, '');
  path = pathUtil.normalize(path);
  return expand ? path.replace(/^~(?=\/|\\|$)/, homePath) :
    path.replace(new RegExp('^' + escapePattern(homePath) +
      '(?=\\/|\\\\|$)', IS_WIN ? 'i' : ''), '~');
}

function replacePlaceholder(text, generator) {
  var PTN_INNER = '(?:\\(([\\s\\S]*?)\\))?(\\w+|.-.)(?:\\(([\\s\\S]*?)\\))?',
    rePlaceholder = new RegExp('(\\$)?(\\$<' + PTN_INNER + '>)', 'g'),
    rePlaceholderCompat = new RegExp('(\\$)?(\\$\\{' + PTN_INNER + '\\})', 'g');

  function getPlaceholderText(s, escape, placeholder, pre, param, post) {
    var text;
    return escape || typeof (text = generator(param)) !== 'string' ? placeholder :
      text ? (pre || '') + text + (post || '') : '';
  }

  return text.replace(rePlaceholder, getPlaceholderText)
    .replace(rePlaceholderCompat, getPlaceholderText);
}

function array2charlist(array, caseSensitive, collectSymbols) {
  var values, group = [], groupClass = -1, charCode = 0, symbols = '', suppressed;
  function addGroup(groups, group) {
    if (group.length > 3) { // ellipsis
      groups.push(group[0] + '...' + group[group.length - 1]);
      suppressed = true;
    } else if (group.length) {
      groups = groups.concat(group);
    }
    return groups;
  }

  values = array.reduce(
      function(chars, value) { return chars.concat((value + '').split('')); }, [])
    .reduce(function(groups, curChar) {
      var curGroupClass, curCharCode;
      if (!caseSensitive) { curChar = curChar.toLowerCase(); }
      curGroupClass = /^\d$/.test(curChar) ? 1 :
        /^[A-Z]$/.test(curChar) ? 2 : /^[a-z]$/.test(curChar) ? 3 : 0;
      if (collectSymbols && curGroupClass === 0) {
        symbols += curChar;
      } else {
        curCharCode = curChar.charCodeAt(0);
        if (curGroupClass && curGroupClass === groupClass &&
            curCharCode === charCode + 1) {
          group.push(curChar);
        } else {
          groups = addGroup(groups, group);
          group = [curChar];
          groupClass = curGroupClass;
        }
        charCode = curCharCode;
      }
      return groups;
    }, []);
  values = addGroup(values, group); // last group
  if (symbols) { values.push(symbols); suppressed = true; }
  return {values: values, suppressed: suppressed};
}

function joinChunks(chunks, suppressed) {
  return chunks.join(chunks.length > 2 ? ', ' : suppressed ? ' / ' : '/');
}

function getPhContent(param, options) {
  var text, values, resCharlist = {}, arg;
  if (options.phContent) {
    text = options.phContent(param, options);
  }
  if (typeof text !== 'string') {
    switch (param) {
      case 'hideEchoBack':
      case 'mask':
      case 'defaultInput':
      case 'caseSensitive':
      case 'keepWhitespace':
      case 'encoding':
      case 'bufferSize':
      case 'history':
      case 'cd':
        text = !options.hasOwnProperty(param) ? '' :
          typeof options[param] === 'boolean' ? (options[param] ? 'on' : 'off') :
          options[param] + '';
        break;
      // case 'prompt':
      // case 'query':
      // case 'display':
      //   text = options.hasOwnProperty('displaySrc') ? options.displaySrc + '' : '';
      //   break;
      case 'limit':
      case 'trueValue':
      case 'falseValue':
        values = options[options.hasOwnProperty(param + 'Src') ? param + 'Src' : param];
        if (options.keyIn) { // suppress
          resCharlist = array2charlist(values, options.caseSensitive);
          values = resCharlist.values;
        } else {
          values = values.filter(function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number';
          });
        }
        text = joinChunks(values, resCharlist.suppressed);
        break;
      case 'limitCount':
      case 'limitCountNotZero':
        text = options[options.hasOwnProperty('limitSrc') ?
          'limitSrc' : 'limit'].length;
        text = text || param !== 'limitCountNotZero' ? text + '' : '';
        break;
      case 'lastInput':
        text = lastInput;
        break;
      case 'cwd':
      case 'CWD':
      case 'cwdHome':
        text = process.cwd();
        if (param === 'CWD') {
          text = pathUtil.basename(text);
        } else if (param === 'cwdHome') {
          text = replaceHomePath(text);
        }
        break;
      case 'date':
      case 'time':
      case 'localeDate':
      case 'localeTime':
        text = (new Date())['to' +
          param.replace(/^./, function(str) { return str.toUpperCase(); }) +
          'String']();
        break;
      default: // with arg
        if (typeof (arg = (param.match(/^history_m(\d+)$/) || [])[1]) === 'string') {
          text = inputHistory[inputHistory.length - arg] || '';
        }
    }
  }
  return text;
}

function getPhCharlist(param) {
  var matches = /^(.)-(.)$/.exec(param), text = '', from, to, code, step;
  if (!matches) { return null; }
  from = matches[1].charCodeAt(0);
  to = matches[2].charCodeAt(0);
  step = from < to ? 1 : -1;
  for (code = from; code !== to + step; code += step) { text += String.fromCharCode(code); }
  return text;
}

// cmd "arg" " a r g " "" 'a"r"g' "a""rg" "arg
function parseCl(cl) {
  var reToken = new RegExp(/(\s*)(?:("|')(.*?)(?:\2|$)|(\S+))/g), matches,
    taken = '', args = [], part;
  cl = cl.trim();
  while ((matches = reToken.exec(cl))) {
    part = matches[3] || matches[4] || '';
    if (matches[1]) {
      args.push(taken);
      taken = '';
    }
    taken += part;
  }
  if (taken) { args.push(taken); }
  return args;
}

function toBool(res, options) {
  return (
    (options.trueValue.length &&
      isMatched(res, options.trueValue, options.caseSensitive)) ? true :
    (options.falseValue.length &&
      isMatched(res, options.falseValue, options.caseSensitive)) ? false : res);
}

function getValidLine(options) {
  var res, forceNext, limitMessage,
    matches, histInput, args, resCheck;

  function _getPhContent(param) { return getPhContent(param, options); }
  function addDisplay(text) { options.display += (/[^\r\n]$/.test(options.display) ? '\n' : '') + text; }

  options.limitSrc = options.limit;
  options.displaySrc = options.display;
  options.limit = ''; // for readlineExt
  options.display = replacePlaceholder(options.display + '', _getPhContent);

  while (true) {
    res = _readlineSync(options);
    forceNext = false;
    limitMessage = '';

    if (options.defaultInput && !res) { res = options.defaultInput; }

    if (options.history) {
      if ((matches = /^\s*\!(?:\!|-1)(:p)?\s*$/.exec(res))) { // `!!` `!-1` +`:p`
        histInput = inputHistory[0] || '';
        if (matches[1]) { // only display
          forceNext = true;
        } else { // replace input
          res = histInput;
        }
        // Show it even if it is empty (NL only).
        addDisplay(histInput + '\n');
        if (!forceNext) { // Loop may break
          options.displayOnly = true;
          _readlineSync(options);
          options.displayOnly = false;
        }
      } else if (res && res !== inputHistory[inputHistory.length - 1]) {
        inputHistory = [res];
      }
    }

    if (!forceNext && options.cd && res) {
      args = parseCl(res);
      switch (args[0].toLowerCase()) {
        case 'cd':
          if (args[1]) {
            try {
              process.chdir(replaceHomePath(args[1], true));
            } catch (e) {
              addDisplay(e + '');
            }
          }
          forceNext = true;
          break;
        case 'pwd':
          addDisplay(process.cwd());
          forceNext = true;
          break;
        // no default
      }
    }

    if (!forceNext && options.preCheck) {
      resCheck = options.preCheck(res, options);
      res = resCheck.res;
      if (resCheck.forceNext) { forceNext = true; } // Don't switch to false.
    }

    if (!forceNext) {
      if (!options.limitSrc.length ||
        isMatched(res, options.limitSrc, options.caseSensitive)) { break; }
      if (options.limitMessage) {
        limitMessage = replacePlaceholder(options.limitMessage, _getPhContent);
      }
    }

    addDisplay((limitMessage ? limitMessage + '\n' : '') +
      replacePlaceholder(options.displaySrc + '', _getPhContent));
  }
  return toBool(res, options);
}

// for dev
exports._DBG_set_useExt = function(val) { _DBG_useExt = val; };
exports._DBG_set_checkOptions = function(val) { _DBG_checkOptions = val; };
exports._DBG_set_checkMethod = function(val) { _DBG_checkMethod = val; };
exports._DBG_clearHistory = function() { lastInput = ''; inputHistory = []; };

// ------------------------------------

exports.setDefaultOptions = function(options) {
  defaultOptions = margeOptions(true, options);
  return margeOptions(true); // copy
};

exports.question = function(query, options) {
  /* eslint-disable key-spacing */
  return getValidLine(margeOptions(margeOptions(true, options), {
    display:            query
  }));
  /* eslint-enable key-spacing */
};

exports.prompt = function(options) {
  var readOptions = margeOptions(true, options);
  readOptions.display = readOptions.prompt;
  return getValidLine(readOptions);
};

exports.keyIn = function(query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions(margeOptions(true, options), {
    display:            query,
    keyIn:              true,
    keepWhitespace:     true
  });
  /* eslint-enable key-spacing */

  // char list
  readOptions.limitSrc = readOptions.limit.filter(function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number';
  })
  .map(function(text) { return replacePlaceholder(text + '', getPhCharlist); });
  // pattern
  readOptions.limit = escapePattern(readOptions.limitSrc.join(''));

  ['trueValue', 'falseValue'].forEach(function(optionName) {
    readOptions[optionName] = readOptions[optionName].reduce(function(comps, comp) {
      var type = typeof comp;
      if (type === 'string' || type === 'number') {
        comps = comps.concat((comp + '').split(''));
      } else { comps.push(comp); }
      return comps;
    }, []);
  });

  readOptions.display = replacePlaceholder(readOptions.display + '',
    function(param) { return getPhContent(param, readOptions); });

  return toBool(_readlineSync(readOptions), readOptions);
};

// ------------------------------------

exports.questionEMail = function(query, options) {
  if (query == null) { query = 'Input e-mail address: '; }
  /* eslint-disable key-spacing */
  return exports.question(query, margeOptions({
    // -------- default
    hideEchoBack:       false,
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    limit:              /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    limitMessage:       'Input valid e-mail address, please.',
    trueValue:          null,
    falseValue:         null
  }, options, {
    // -------- forced
    keepWhitespace:     false,
    cd:                 false
  }));
  /* eslint-enable key-spacing */
};

exports.questionNewPassword = function(query, options) {
  /* eslint-disable key-spacing */
  var resCharlist, min, max,
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       true,
      mask:               '*',
      limitMessage:       'It can include: $<charlist>\n' +
                            'And the length must be: $<length>',
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      true
    }, options, {
      // -------- forced
      history:            false,
      cd:                 false,
      // limit (by charlist etc.),
      phContent: function(param) {
        return param === 'charlist' ? resCharlist.text :
          param === 'length' ? min + '...' + max : null;
      }
    }),
    // added:     charlist, min, max, confirmMessage, unmatchMessage
    charlist, confirmMessage, unmatchMessage,
    limit, limitMessage, res1, res2;
  /* eslint-enable key-spacing */
  options = options || {};

  charlist = replacePlaceholder(
    options.charlist ? options.charlist + '' : '$<!-~>', getPhCharlist);
  if (isNaN(min = parseInt(options.min, 10)) || typeof min !== 'number') { min = 12; }
  if (isNaN(max = parseInt(options.max, 10)) || typeof max !== 'number') { max = 24; }
  limit = new RegExp('^[' + escapePattern(charlist) +
    ']{' + min + ',' + max + '}$');
  resCharlist = array2charlist([charlist], readOptions.caseSensitive, true);
  resCharlist.text = joinChunks(resCharlist.values, resCharlist.suppressed);

  confirmMessage = options.confirmMessage != null ? options.confirmMessage :
    'Reinput a same one to confirm it: ';
  unmatchMessage = options.unmatchMessage != null ? options.unmatchMessage :
    'It differs from first one.' +
      ' Hit only the Enter key if you want to retry from first one.';

  if (query == null) { query = 'Input new password: '; }

  limitMessage = readOptions.limitMessage;
  while (!res2) {
    readOptions.limit = limit;
    readOptions.limitMessage = limitMessage;
    res1 = exports.question(query, readOptions);

    readOptions.limit = [res1, ''];
    readOptions.limitMessage = unmatchMessage;
    res2 = exports.question(confirmMessage, readOptions);
  }

  return res1;
};

function _questionNum(query, options, parser) {
  var validValue;
  function getValidValue(value) {
    validValue = parser(value);
    return !isNaN(validValue) && typeof validValue === 'number';
  }
  /* eslint-disable key-spacing */
  exports.question(query, margeOptions({
    // -------- default
    limitMessage:       'Input valid number, please.'
  }, options, {
    // -------- forced
    limit:              getValidValue,
    cd:                 false
    // trueValue, falseValue, caseSensitive, keepWhitespace don't work.
  }));
  /* eslint-enable key-spacing */
  return validValue;
}
exports.questionInt = function(query, options) {
  return _questionNum(query, options, function(value) { return parseInt(value, 10); });
};
exports.questionFloat = function(query, options) {
  return _questionNum(query, options, parseFloat);
};

exports.questionPath = function(query, options) {
  /* eslint-disable key-spacing */
  var validPath, error = '',
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       '$<error(\n)>Input valid path, please.' +
                            '$<( Min:)min>$<( Max:)max>',
      history:            true,
      cd:                 true
    }, options, {
      // -------- forced
      keepWhitespace:     false,
      limit: function(value) {
        var exists, stat, res;
        value = replaceHomePath(value, true);
        error = ''; // for validate
        // mkdir -p
        function mkdirParents(dirPath) {
          dirPath.split(/\/|\\/).reduce(function(parents, dir) {
            var path = pathUtil.resolve((parents += dir + pathUtil.sep));
            if (!fs.existsSync(path)) {
              fs.mkdirSync(path);
            } else if (!fs.statSync(path).isDirectory()) {
              throw new Error('Non directory already exists: ' + path);
            }
            return parents;
          }, '');
        }

        try {
          exists = fs.existsSync(value);
          validPath = exists ? fs.realpathSync(value) : pathUtil.resolve(value);
          // options.exists default: true, not-bool: no-check
          if (!options.hasOwnProperty('exists') && !exists ||
              typeof options.exists === 'boolean' && options.exists !== exists) {
            error = (exists ? 'Already exists' : 'No such file or directory') +
              ': ' + validPath;
            return false;
          }
          if (!exists && options.create) {
            if (options.isDirectory) {
              mkdirParents(validPath);
            } else {
              mkdirParents(pathUtil.dirname(validPath));
              fs.closeSync(fs.openSync(validPath, 'w')); // touch
            }
            validPath = fs.realpathSync(validPath);
          }
          if (exists && (options.min || options.max ||
              options.isFile || options.isDirectory)) {
            stat = fs.statSync(validPath);
            // type check first (directory has zero size)
            if (options.isFile && !stat.isFile()) {
              error = 'Not file: ' + validPath;
              return false;
            } else if (options.isDirectory && !stat.isDirectory()) {
              error = 'Not directory: ' + validPath;
              return false;
            } else if (options.min && stat.size < +options.min ||
                options.max && stat.size > +options.max) {
              error = 'Size ' + stat.size + ' is out of range: ' + validPath;
              return false;
            }
          }
          if (typeof options.validate === 'function' &&
              (res = options.validate(validPath)) !== true) {
            if (typeof res === 'string') { error = res; }
            return false;
          }
        } catch (e) {
          error = e + '';
          return false;
        }
        return true;
      },
      // trueValue, falseValue, caseSensitive don't work.
      phContent: function(param) {
        return param === 'error' ? error :
          param !== 'min' && param !== 'max' ? null :
          options.hasOwnProperty(param) ? options[param] + '' : '';
      }
    });
    // added:     exists, create, min, max, isFile, isDirectory, validate
  /* eslint-enable key-spacing */
  options = options || {};

  if (query == null) { query = 'Input path (you can "cd" and "pwd"): '; }

  exports.question(query, readOptions);
  return validPath;
};

// props: preCheck, args, hRes, limit
function getClHandler(commandHandler, options) {
  var clHandler = {}, hIndex = {};
  if (typeof commandHandler === 'object') {
    Object.keys(commandHandler).forEach(function(cmd) {
      if (typeof commandHandler[cmd] === 'function') {
        hIndex[options.caseSensitive ? cmd : cmd.toLowerCase()] = commandHandler[cmd];
      }
    });
    clHandler.preCheck = function(res) {
      var cmdKey;
      clHandler.args = parseCl(res);
      cmdKey = clHandler.args[0] || '';
      if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
      clHandler.hRes =
        cmdKey !== '_' && hIndex.hasOwnProperty(cmdKey) ?
          hIndex[cmdKey].apply(res, clHandler.args.slice(1)) :
        hIndex.hasOwnProperty('_') ? hIndex._.apply(res, clHandler.args) : null;
      return {res: res, forceNext: false};
    };
    if (!hIndex.hasOwnProperty('_')) {
      clHandler.limit = function() { // It's called after preCheck.
        var cmdKey = clHandler.args[0] || '';
        if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
        return hIndex.hasOwnProperty(cmdKey);
      };
    }
  } else {
    clHandler.preCheck = function(res) {
      clHandler.args = parseCl(res);
      clHandler.hRes = typeof commandHandler === 'function' ?
        commandHandler.apply(res, clHandler.args) : true; // true for break loop
      return {res: res, forceNext: false};
    };
  }
  return clHandler;
}

exports.promptCL = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  exports.prompt(readOptions);
  return clHandler.args;
};

exports.promptLoop = function(inputHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
    // -------- default
    hideEchoBack:       false,
    trueValue:          null,
    falseValue:         null,
    caseSensitive:      false,
    history:            true
  }, options);
  /* eslint-enable key-spacing */
  while (true) { if (inputHandler(exports.prompt(readOptions))) { break; } }
  return;
};

exports.promptCLLoop = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  while (true) {
    exports.prompt(readOptions);
    if (clHandler.hRes) { break; }
  }
  return;
};

exports.promptSimShell = function(options) {
  /* eslint-disable key-spacing */
  return exports.prompt(margeOptions({
    // -------- default
    hideEchoBack:       false,
    history:            true
  }, options, {
    // -------- forced
    prompt:             (function() {
      return IS_WIN ?
        '$<cwd>>' :
        // 'user@host:cwd$ '
        (process.env.USER || '') +
        (process.env.HOSTNAME ?
          '@' + process.env.HOSTNAME.replace(/\..*$/, '') : '') +
        ':$<cwdHome>$ ';
    })()
  }));
  /* eslint-enable key-spacing */
};

function _keyInYN(query, options, limit) {
  var res;
  if (query == null) { query = 'Are you sure? '; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s*:?\s*$/, '') + ' [y/n]: ';
  }
  /* eslint-disable key-spacing */
  res = exports.keyIn(query, margeOptions(options, {
    // -------- forced
    hideEchoBack:       false,
    limit:              limit,
    trueValue:          'y',
    falseValue:         'n',
    caseSensitive:      false
    // mask doesn't work.
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return typeof res === 'boolean' ? res : '';
}
exports.keyInYN = function(query, options) { return _keyInYN(query, options); };
exports.keyInYNStrict = function(query, options) { return _keyInYN(query, options, 'yn'); };

exports.keyInPause = function(query, options) {
  if (query == null) { query = 'Continue...'; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s+$/, '') + ' (Hit any key)';
  }
  /* eslint-disable key-spacing */
  exports.keyIn(query, margeOptions({
    // -------- default
    limit:              null
  }, options, {
    // -------- forced
    hideEchoBack:       true,
    mask:               ''
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return;
};

exports.keyInSelect = function(items, query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false
    }, options, {
      // -------- forced
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      false,
      // limit (by items),
      phContent: function(param) {
        return param === 'itemsCount' ? items.length + '' :
          param === 'firstItem' ? (items[0] + '').trim() :
          param === 'lastItem' ? (items[items.length - 1] + '').trim() : null;
      }
    }),
    // added:     guide, cancel
    keylist = '', key2i = {}, charCode = 49 /* '1' */, display = '\n';
  /* eslint-enable key-spacing */
  if (!Array.isArray(items) || !items.length || items.length > 35) {
    throw '`items` must be Array (max length: 35).';
  }

  items.forEach(function(item, i) {
    var key = String.fromCharCode(charCode);
    keylist += key;
    key2i[key] = i;
    display += '[' + key + '] ' + (item + '').trim() + '\n';
    charCode = charCode === 57 /* '9' */ ? 97 /* 'a' */ : charCode + 1;
  });
  if (!options || options.cancel !== false) {
    keylist += '0';
    key2i['0'] = -1;
    display += '[0] ' +
      (options && options.cancel != null && typeof options.cancel !== 'boolean' ?
        (options.cancel + '').trim() : 'CANCEL') + '\n';
  }
  readOptions.limit = keylist;
  display += '\n';

  if (query == null) { query = 'Choose one from list: '; }
  if ((query += '')) {
    if (!options || options.guide !== false) {
      query = query.replace(/\s*:?\s*$/, '') + ' [$<limit>]: ';
    }
    display += query;
  }

  return key2i[exports.keyIn(display, readOptions).toLowerCase()];
};

exports.getRawInput = function() { return rawInput; };

// ======== DEPRECATED ========
function _setOption(optionName, args) {
  var options;
  if (args.length) { options = {}; options[optionName] = args[0]; }
  return exports.setDefaultOptions(options)[optionName];
}
exports.setPrint = function() { return _setOption('print', arguments); };
exports.setPrompt = function() { return _setOption('prompt', arguments); };
exports.setEncoding = function() { return _setOption('encoding', arguments); };
exports.setMask = function() { return _setOption('mask', arguments); };
exports.setBufferSize = function() { return _setOption('bufferSize', arguments); };
};
BundleModuleCode['doc/table']=function (module,exports){
var doc = Require('doc/doc');

Table = function (data,options) {
  var totalWidth=(process.stdout.columns)-2;
  if (Utils.isArray(options)) options={head:options};
  options=options||{};
  var head=options.head,table;
  if (Utils.isMatrix(data)) {
  } else if (Utils.isArray(data) && Utils.isObject(data[0])) {
    options.head=true;
    head=Object.keys(data[0]);
    data=data.map(function (row) {
      return head.map(function (key) { return row[key] })
    });
  } else return new Error('Table: Inavlid data');
  if (!options.colWidths) {
    totalWidth-= ((head||data[0]).length-1);
    options.colWidths=(head||data[0]).map(function (x,i) {
      return Math.max(4,Math.floor(totalWidth/(head||data[0]).length));
    });
  }
  if (head) 
    table = new doc.Table({
      head : head,
      colWidths :options.colWidths,
    });
  else 
    table = new doc.Table({
      colWidths : options.colWidths,
    });
  data.forEach(function (row,rowi) {
    table.push(row);
  });
  Code.print(table.toString());
 
}
};
BundleModuleCode['signature']=function (module,exports){
/*
** Smart exploring type interface and signature generator of arbitrary objects and functions
**
** Version 1.2.1
*/
function Signature(exports) {
  var _ =undefined;

  var Test = {
    isArray: function isArray(o) {
      if (o==_ || o ==null) return false;
      else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
    },
    isArrayArray: function isArrayArray(o) {
      if (o==_ || o ==null) return false;
      else return Utils.isArray(o) &&
                  Utils.isArray(o[0]);
    },
    isArrayArrayArray: function isArrayArrayArray(o) {
      if (o==_ || o ==null) return false;
      else return Utils.isArray(o) &&
                  Utils.isArray(o[0]) &&
                  Utils.isArray(o[0][0]);
    },
    isBuffer: function isBuffer(o) {
      if (o==_ || o ==null) return false;
      else return o instanceof Buffer;
    },
    isEmpty: function isEmpty(o) {
      for(var prop in o) {
         if (o[prop]!=undefined) return false;
      }
      return true;  
    },
    isError : function (o) {
      return o instanceof Error
    },
    isFunction: function isFunction(o) {
        return typeof o == "function";
    },
    isMatrix: function isMatrix(o,noarray) {
      if (o==_ || o ==null) return false;
      else return (!noarray && Utils.isArray(o) &&
                   Utils.isArray(o[0])) ||
                  (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                  (Math.Matrix && Math.Matrix.isMatrix(o))
                  ;
    },
    isObj: function isObj(o) {
        return typeof o == "object";
    },
    isObject: function isObject(o) {
        return typeof o == "object";
    },
    isRegex: function isRegex(o) {
        return o instanceof RegExp;
    },
    isString: function isString(o) {
        return typeof o == "string" || (typeof o == "object" && o.constructor === String);
    },
    isNumber: function isNumber(o) {
        return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
    },
    isBoolean: function isBoolean (o) {
        return typeof o == "boolean"
    },
    isString: function isString(o) {
        return typeof o == "string"
    },
    isStruct: function isStruct(o) {
        return o && !Utils.isArray(o) && Utils.isObject(o)
    },
    isTypedArray: function isTypedArray(o) {
        return o && Utils.isObject(o) && o.buffer instanceof ArrayBuffer
    },
    isVector: function isVector(o,noarray) {
      if (o==_ || o ==null) return false;
      else return (!noarray && Utils.isArray(o)) ||
                  (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                  (Math.Vector && Math.Vector.isVector(o))
                  ;
    },
  }
  var NL = '\n';

  // Detect circular references by an object/function cache
  var Cache = [],CacheMap=[];
  function CacheLookup (obj) {
    for(var i in Cache) if (Cache[i]===obj) return true;
    return false;
  }
  function RefName(obj) {
    for(var i in CacheMap) if (CacheMap[i].f===obj) return CacheMap[i].key;
    return '';
  }
  function sigArray (a,indent,left,structure) {
    var rowTypes,
        rowType0 = signature(a[0],indent+2,0),
        rowType1 = signature(a[a.length-1],indent+2,0);  // best hope assumption: if first and last element are equal=>mono
    // Try to get type set for polysorted arrays!!!!
    if (structure || a.length<1000) {
      rowTypes=[];
      var _C=Cache,_CM=CacheMap;
      for(var i in a) {
        Cache = [],CacheMap=[];
        var sig = signature(a[i],indent+2,0,structure);
        if (rowTypes.indexOf(sig)==-1) rowTypes.push(sig);
      }
      Cache = _C,CacheMap=_CM;
    }
    if (structure) {
      return '['+NL+rowTypes.join(','+NL)+']'
    }
    if (rowTypes) {
      if (rowTypes.length==1)
        return rowTypes[0]+(rowTypes[0][rowTypes[0].length-1]==']'?'':' ')+'['+(a.length?a.length:'')+']';
      else if (rowTypes.length>1)
        return '('+rowTypes.join('|')+')['+(a.length?a.length:'')+']';
      else
        return '['+(a.length?a.length:'')+']';
    }
    else {
      return (rowType0==rowType1 && a.length?rowType0+(rowType0[rowType0.length-1]==']'?'':' '):
              "'a ")+ '['+(a.length?a.length:'')+']'; 
    }           
  }

  function sigTypedArray (ta,indent,left) {
    var con=ta.constructor.name;
    return con+' ['+ta.length+']';
  }

  function sigFunction (f,indent) {
    var space=Array(indent).join(' '),
        spaces=function (s) { return space+' '+s };
    // try to extract function parameter list
    var code=f.toString(),
        attributes=Object.keys(f),
        native = /\[native code\]/.test(f),
        tokens=code.match(/[ ]*function[ ]*([^\( ]+)?[ ]*\(([^\)]*)\)/),
        name=tokens && tokens[1] && tokens[1].trim(),
        parameter=tokens && tokens[2]&&tokens[2].replace(/\/\*[^\*]*\*\//,'');
    if (name) CacheMap.push({key:name,f:f});
    if (attributes.length) {
      attributes = attributes.map(function (key) {
        return (name?name+'.':'')+key+' : '+signature(f[key],(indent||0)+2,0);
      });
    }
    if (native) {
      // extended native?
      return 'native function'+(name?' '+name:'')+(attributes.length?NL+attributes.map(spaces).join(NL):'');
    }
    var retType='',
        retIdOrExpr = code.match(/return[ ]*[a-zA-Z0-9$!_\-\.\(\{\[]+/);  // return <identifier>|<expr>
    //if (retIdOrExpr && ['if','for','function','while','do','switch','case'].indexOf(retIdOrExpr[1])==-1)
    //  retType="'a";
    return 'function'+
           (name?' '+name:'')+
           (parameter || (!parameter && retType)?' ('+parameter.split(',').map(function (s) { return s.length?'@'+s.trim():''}).join(',')+')':'')+
           (retType?' -> '+retType:'')+(attributes.length?NL+attributes.map(spaces).join(NL):'');
  }

  function sigMatrix (m,indent,left) {
    var con=Math.MatrixTA && Math.MatrixTA.isMatrix(m)?'MatrixTA':'Matrix';
    return m.datatype+' '+con+' '+m.dataspace.slice().reverse().map(function (s) { return '['+s+']'}).join('');
  }

  function sigObject (o,indent,left,structure) {
    if (o==null) return 'null';
    var space0=Array(left==0?0:indent).join(' '),
        space=Array(indent).join(' '),
        spaces=function (s) { return space+' '+s },
        keys = Object.keys(o),
        lines=[];
    for(var i in keys) {
      var key=keys[i];
      lines.push(key+' : '+signature(o[key],indent+2,0));
    }
    return space0+'{'+NL+lines.map(spaces).join(','+NL)+NL+space+'}';
  }

  function signature (obj,indent,left,structure) {
    var ref,
        space=Array(left==0?0:indent).join(' '),
        typ=typeof obj;
    switch (typ) {
      case 'string':
      case 'number':
      case 'boolean':
      case 'undefined':
        return space+typ;
      case 'function':
        if (CacheLookup(obj)!=false) return '[circular reference]'+(RefName(obj)? ' = '+RefName(obj):'');
        Cache.push(obj);
        return space+sigFunction(obj,indent,left);
      case 'object':
        if (CacheLookup(obj)!=false) return '[circular reference]'+(RefName(obj)? ' = '+RefName(obj):'');
        Cache.push(obj);
        if (Test.isTypedArray(obj)) return space+sigTypedArray(obj);
        if (Test.isBuffer(obj)) return space+'Buffer('+obj.length+')'; 
        if (Test.isMatrix(obj,true)) return space+sigMatrix(obj,indent,left);
        if (Test.isArray(obj)) return space+sigArray(obj,indent,left,structure);
        if (signature.instances) {
          for(var i in signature.instances) {
            if (obj instanceof signature.instances[i]) return signature.instances[i].name+ ' object';
          }
        }
        return sigObject(obj,indent||0,left,structure);
    }
  }

  signature.register=function(instance) {
    if (!signature.instances) signature.instances=[instance];
    else signature.instances.push(instance);
  }

  // Global API; Main entry point!

  var typeOf = function typeOf (o) {
    Cache=[];CacheMap=[];
    var sig=signature(o);
    Cache=[];CacheMap=[];
    return sig;
  }

  // Print interface of object constructor function and prototypes
  function interface(constructor,indent) {
    function constrRetFix(s,ret) {
      var lines = s.split(NL);
      lines[0]  = lines[0].replace(/[ ]*\->[^$]+/,'')+' -> '+ret;
      return lines.join(NL);
    }
    var space=Array(indent).join(' '),
        spaces=function (s) { return space+' '+s },
        name = constructor.name,
        sig  = constrRetFix(signature(constructor,0,indent+2),name+' object'),
        prototypes = [];
    if (!name) {
      name = constructor.toString().match(/^[ ]*function[ ]*([a-zA-Z_0-9]+)/);
      if (name) name=name[1];
    }
    Cache=[];CacheMap=[];
    if (name) CacheMap.push({key:name,f:constructor});
    if (constructor.prototype) {
      var keys=Object.keys(constructor.prototype);
      if (keys.length==0 && ([] instanceof constructor)) keys=Object.getOwnPropertyNames([].__proto__); // native constructor
      for(var i in keys) {
        var key=keys[i];
        if (!constructor.prototype.__lookupGetter__(key)) {
          
          if (!key || typeof constructor.prototype[key] == 'undefined') continue;
          if (constructor.prototype[key]  === constructor) {
            continue;
          }
          CacheMap.push({key:name+'.'+key,f:constructor.prototype[key]});
          prototypes.push('method '+signature(constructor.prototype[key],0,indent)
                                    .replace(/function[ ]*([^ \(]*)/,'function '+(name?name+'.':'')+key+' ')
                                    .replace(/\[circular reference\][ ]*(=[^$]+)?/,'function reference '+(name?name+'.':'')+key+' = '+RefName(constructor.prototype[key]))
                        );
        } else {
          // a getter that fails to evaluate
          prototypes.push('method getter '+(name?name+'.':'')+key);
        }
      }
    }    
    Cache=[];CacheMap=[];
    return 'constructor '+sig+
            (prototypes.length?NL+prototypes.map(spaces).join(NL):'')
  }



  // Print a structure interface; expand object arrays; summarize numeric arrays and buffers and TA
  function structure(obj,indent) {
    Cache=[];CacheMap=[];
    var strut=signature(o,0,0,true);
    Cache=[];CacheMap=[];
    return strut;
  }

  typeOf.signature=signature;
  typeOf.interface=interface;
  typeOf.structure=structure;

  Object.assign(exports, {
    interface:interface,
    signature:signature,
    structure:structure,
    test:Test,
    typeOf:typeOf,
  });
}
if (typeof module != 'undefined') { module.exports={}; Signature(module.exports) }
else if (typeof WorkerGlobalScope != 'undefined' && self instanceof WorkerGlobalScope) Signature(self);
else if (typeof window != 'undefined') Signature(window);
else if (typeof global != 'undefined') Signature(global);

};
BundleModuleCode['sizeof']=function (module,exports){
// Copyright 2014 Andrei Karpushonak
// https://github.com/miktam/sizeof
// TODO: ArrayBuffer, Typedarrays, ..

function SizeOf(exports) {
  'use strict'

  var ECMA_SIZES =   {
    STRING: 2,
    BOOLEAN: 4,
    NUMBER: 8
  }

  function isBuffer(o) {
    return o instanceof Buffer
  }
  function isArrayBuffer(o) {
    return typeof ArrayBuffer != 'undedined' && o instanceof ArrayBuffer
  }
  function isTypedArray(o) {
      return o && typeof o == 'object' && o.buffer && o.buffer instanceof ArrayBuffer
  }

  function baseProperties(obj) {
    const stringProperties = []
    for (var prop in obj) { 
        stringProperties.push(prop)
    }
    return stringProperties
  }

  function allProperties(obj) {
    const stringProperties = []
    for (var prop in obj) { 
        stringProperties.push(prop)
    }
    if (Object.getOwnPropertySymbols) {
        var symbolProperties = Object.getOwnPropertySymbols(obj)
        Array.prototype.push.apply(stringProperties, symbolProperties)
    }
    return stringProperties
  }

  function sizeOfObject (seen, object, dataOnly) {
    if (object == null) {
      return 0
    }

    var bytes = 0
    var properties = dataOnly?baseProperties(object):allProperties(object)
    for (var i = 0; i < properties.length; i++) {
      var key = properties[i]
      // Do not recalculate circular references
      if (typeof object[key] === 'object' && object[key] !== null) {
        if (seen.has(object[key])) {
          continue
        }
        seen.add(object[key])
      }

      if (!dataOnly) bytes += getCalculator(seen)(key)
      try {
        bytes += getCalculator(seen,dataOnly)(object[key])
      } catch (ex) {
        if (ex instanceof RangeError) {
          // circular reference detected, final result might be incorrect
          // let's be nice and not throw an exception
          bytes = 0
        }
      }
    }

    return bytes
  }

  function getCalculator (seen,dataOnly) {
    return function calculator(object) {
      if (isArrayBuffer(object)) {
        return object.byteLength
      }
      if (isTypedArray(object)) {
        return object.buffer.byteLength
      }
      if (isBuffer(object)) {
        return object.length
      }

      var objectType = typeof (object)
      switch (objectType) {
        case 'string':
          return object.length * ECMA_SIZES.STRING
        case 'boolean':
          return ECMA_SIZES.BOOLEAN
        case 'number':
          return ECMA_SIZES.NUMBER
        case 'symbol':
          const isGlobalSymbol = Symbol.keyFor && Symbol.keyFor(object)
          return isGlobalSymbol ? Symbol.keyFor(object).length * ECMA_SIZES.STRING : (object.toString().length - 8) * ECMA_SIZES.STRING 
        case 'object':
          if (Array.isArray(object)) {
            // TODO: (big) numeric arrays
            return object.map(getCalculator(seen,dataOnly)).reduce(function (acc, curr) {
              return acc + curr
            }, 0)
          } else {
            return sizeOfObject(seen, object,dataOnly)
          }
        default:
          return 0
      }
    }
  }

  /**
   * Main module's entry point
   * Calculates Bytes for the provided parameter
   * @param object - handles object/string/boolean/buffer
   * @returns {*}
   */
  function sizeof (object,dataOnly) {
    return getCalculator(new WeakSet(),dataOnly)(object)
  }
  Object.assign(exports, {
    sizeOf:sizeof,
  });

}

if (typeof module != 'undefined') { module.exports={}; SizeOf(module.exports) }
else if (typeof WorkerGlobalScope != 'undefined' && self instanceof WorkerGlobalScope) SizeOf(self);
else if (typeof window != 'undefined') SizeOf(window);
else if (typeof global != 'undefined') SizeOf(global);


};
FilesEmbedded['plugins/math/help.md']=function (format){return Base64.decode('JTIzJTIwTWF0aCUwQSUwQSUyMyUyMyUyMEdlb21ldHJ5JTBBJTBBTWF0aC5kZWx0YSUyMCUzQSUyMGZ1bmN0aW9uJTIwJTIzJTIwRGVsdGElMjB2ZWN0b3IlMEElMjAlMjBwb2ludDElMjAlM0ElMjAlNUJ4JTJDeSUyQy4uJTVEJTBBJTIwJTIwcG9pbnQxJTIwJTNBJTIwJTdCeCUyQ3klMkMuLiU3RCUwQSUyMCUyMHBvaW50MiUyMCUzQSUyMCU1QnglMkN5JTJDLi4lNUQlMEElMjAlMjBwb2ludDIlMjAlM0ElMjAlN0J4JTJDeSUyQy4uJTdEJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwJTVCJTVEJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwJTdCJTdEJTBBJTBBTWF0aC5kaXN0YW5jZSUyMCUzQSUyMGZ1bmN0aW9uJTIwJTIzJTIwRXVjbGlkaWFuJTIwZGlzdGFuY2UlMEElMjAlMjBwb2ludDElMjAlM0ElMjAlNUJ4JTJDeSUyQy4uJTVEJTBBJTIwJTIwcG9pbnQxJTIwJTNBJTIwJTdCeCUyQ3klMkMuLiU3RCUwQSUyMCUyMHBvaW50MiUzRiUyMCUzQSUyMCU1QnglMkN5JTJDLi4lNUQlMEElMjAlMjBwb2ludDIlM0YlMjAlM0ElMjAlN0J4JTJDeSUyQy4uJTdEJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwbnVtYmVyJTBBJTBBTWF0aC5uZWFyZXN0JTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBGaW5kJTIwbmVhcmVzdCUyMHBvaW50JTIwaW4lMjBudW1iZXIlMjBzZXJpZXMlMEElMjAlMjBwb2ludHMlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEElMjAlMjB2YWx1JTIwJTIwJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwZXBzaWxvbiUzRiUyMCUzQSUyMG51bWJlciUwQSUyMCUyMHJldHVybiUyMCUzQSUyMCU3QiUyMHglM0FpbmRleCUyMG51bWJlciUyQyUyMHklM0FudW1iZXIlMjAlN0QlMEElMEElMjMlMjMlMjBSYW5kb20lMEElMEFNYXRoLnJhbmRvbSUyMCUzQSUyMGZ1bmN0aW9uJTIwJTIzJTIwUmFuZG9tJTIwbnVtYmVyJTIwJTVCMCUyQzElMjklMEElMjAlMjByZXR1cm4lMjAlM0ElMjBudW1iZXIlMEElMEFNYXRoLnJhbmRvbS5zZWxlY3QlMjAlM0ElMjBmdW5jdGlvbiUyMCUyMyUyMFJhbmRvbSUyMHNlbGVjdGlvbiUwQSUyMCUyMGNob2ljZXMlMjAlM0ElMjAlMjdhJTIwJTVCJTVEJTIwJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwJTI3YSUwQSUwQSUyMCUyMCUwQSUyMCUyMCUwQQ==')};
FilesEmbedded['plugins/ml/help.md']=function (format){return Base64.decode('JTIzJTIwTUwlMEElMEElMjMlMjMlMjBVdGlscyUwQSUwQVNjYWxpbmclMjAlM0ElMjAlN0IlN0QlMEElMjAlMjBrJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwb2ZmJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwc2hpZnQlMjAlM0IlMjBudW1iZXIlMEElMjAlMjBtaW4lMjAlM0ElMjBudW1iZXIlMEElMjAlMjBtYXglMjAlM0ElMjBudW1iZXIlMEElMjAlMjAlMEFNTC5zY2FsZSUyMCUzQSUyMGZ1bmN0aW9uJTIwJTI4ZGF0YSUyQ3NjYWxlcyUyOSUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMjAlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTIwJTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUzQSUyMCU3QiUyNGF0dHIlM0FudW1iZXIlN0QlMjAlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTNBJTIwJTdCJTI0YXR0ciUzQW51bWJlciU3RCUyMCU1QiU1RCUwQSUyMCUyMHNjYWxlcyUyMCUzQSUyMFNjYWxpbmclMEElMjAlMjBzY2FsZXMlMjAlM0ElMjBTY2FsaW5nJTIwJTVCJTVEJTBBJTIwJTIwc2NhbGVzJTIwJTNBJTIwJTdCJTIwJTI0YXR0ciUyMCUzQSUyMFNjYWxpbmclMjAlN0QlMEElMEFNTC5zY2FsZTAlMjAlM0ElMjBmdW5jdGlvbiUyMCUyOGRhdGElMkNsb3dlciU2MCUyQ3VwcGVyJTNGJTI5JTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTNBJTIwJTdCJTIwJTI0YXR0ciUzQW51bWJlciUyMCU3RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjAlN0IlMjAlMjRhdHRyJTNBbnVtYmVyJTIwJTdEJTIwJTVCJTVEJTBBJTIwJTIwJTBBJTIzJTIzJTIwQU5OJTBBJTBBV1dXJTIwJTNBJTIwaHR0cHMlM0EvL3dhZ2VuYWFydGplLmdpdGh1Yi5pby9uZWF0YXB0aWMvJTBBJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTIwJTVCJTVEJTIwJTIzJTIwcmVjb3JkJTIwYXJyYXklMEElMjAlMjBpbnB1dCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUyMCUyMG91dHB1dCUyMCUzQSUyMG51bWJlciUyMCUyMCU1QiU1RCUwQVRyYWluJTIwRGF0YSUyMCUzQSUyMCU3QiU3RCUwQSUyMCUyMHglMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTBBRGF0YSUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQURhdGElMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMjAlMEElMEFNb2RlbCUyMFBhcmFtdGVyJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIwYWxnb3JpdGhtJTIwJTNBJTIwTUwuTUwuQU5OJTBBJTIwJTIwYWN0aXZhdGlvbiUzRiUzQSUyMHN0cmluZyUyMCU1QiU1RCUyMCUyMyUyMFJFTFUlMkMlMjBJREVOVElUWSUyQyUyMExPR0lTVElDJTJDJTIwU1RFUCUwQSUyMCUyMGxheWVycyUyMCUzQSUyMG51bWViciUyMCU1QiU1RCUwQSUwQVRyYWluaW5nJTIwUGFyYW1ldGVyJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIwcmF0ZSUzRiUyMCUzQSUyMG51bWJlciUwQSUyMCUyMGl0ZXJhdGlvbnMlM0YlMjAlM0ElMjBudW1iZXIlMEElMjAlMjBlcnJvciUzRiUyMCUzQSUyMG51bWJlciUwQSUyMCUyMGRyb3B1dCUzRiUyMCUzQSUyMG51bWJlciUyQyUwQSUyMCUyMG1vbWVudHVtJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwYmF0Y2hTaXplJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwY3Jvc3NWYWxpZGF0ZSUzRiUyMCUzQSUyMCUwQSUyMCUyMCUyMCUyMHRlc3RTaXplJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwJTIwJTIwdGVzdEVycm9yJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwY2xlYXIlM0YlMjAlM0ElMjBib29sZWFuJTBBJTIwJTIwbG9nJTNGJTIwJTNBJTIwYm9vbGVhbiUwQSUyMCUyMHJhdGVQb2xpY3klM0YlMjAlM0ElMjBzdHJpbmclMEElMEFNTC5sZWFybmVyJTIwJTNBJTIwZnVuY3Rpb24lMEElMjAlMjBtb2RlbCUyMCUzQSUyME1vZGVsJTIwUGFyYW10ZXIlMjAlMEElMjAlMjByZXR1cm4lMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMCUwQU1MLnRyYWluJTIwJTNBJTIwZnVuY3Rpb24lMEElMjAlMjBtb2RlbCUyMCUyMCUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUyMCUzQSUyMFRyYWluJTIwRGF0YSUwQSUyMCUyMG9wdGlvbnMlMjAlM0ElMjBUcmFpbmluZyUyMFBhcmFtZXRlciUwQSUwQU1MLnByZWRpY3QlMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMG1vZGVsJTIwJTIwJTIwJTNBJTIwbW9kZWwlMjAlN0IlN0QlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTIwJTNBJTIwRGF0YSUwQSUyMCUyMCUwQSUyMyUyMyUyMENOTiUwQSUwQVdXVyUyMCUzQSUyMGh0dHBzJTNBLy9naXRodWIuY29tL2thcnBhdGh5L2NvbnZuZXRqcyUwQSUwQVRyYWluJTIwRGF0YSUyMCUzQSUyMCU3QiU3RCUwQSUyMCUyMHglMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMjAlMjMlMjBkZXB0aCUzRDElMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCU1QiU1RCU1QiU1RCUyMCUyMyUyMGRlcHRoJTNFMSUwQSUyMCUyMHklMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlN0IlN0QlMEElMjAlMjB4JTIwJTNBJTIwYnVmZmVyJTIwJTVCJTVEJTIwJTIzJTIwUkdCL1JHQkElMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMHVpbnQ4YXJyYXklMjAlNUIlNUQlMjAlMjMlMjBSR0IvUkdCQSUwQSUyMCUyMHklMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlN0IlN0QlMEElMjAlMjB4JTIwJTNBJTIwbWF0cml4VGElMjAlNUIlNUQlMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTBBJTBBRGF0YSUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCU1QiU1RCUwQURhdGElMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlNUIlNUQlMEFEYXRhJTIwJTNBJTIwYnVmZmVyJTIwJTVCJTVEJTBBRGF0YSUyMCUzQSUyMG1hdHJpeFRBJTIwJTVCJTVEJTBBJTBBTW9kZWwlMjBQYXJhbWV0ZXIlMjAlM0ElMjAlN0IlN0QlMEElMjAlMjBhbGdvcml0aG0lMjAlM0ElMjBNTC5NTC5DTk4lMEElMjAlMjBsYXllcnMlMjAlM0ElMjAlNUIlNUQlMEElMjAlMjAlMjAlMjAlN0J0eXBlJTIwJTNEJTIwJTI3aW5wdXQlMjclMkMlMjBvdXRfc3glM0FudW1iZXIlMkMlMjBvdXRfc3klM0FudW1iZXIlMkMlMjBvdXRfZGVwdGglM0FudW1iZXIlN0QlMEElMjAlMjAlMjAlMjAlN0J0eXBlJTIwJTNEJTIwJTI3Y29udiUyNyUyQyUyMHN4JTNBbnVtYmVyJTJDJTIwZmlsdGVycyUzQW51bWJlciUyQyUyMHN0cmlkZSUzQW51bWJlciUyQyUyMHBhZCUzQW51bWJlciUyQyUyMGFjdGl2YXRpb24lM0ElMjBzdHJpbmclMjAlM0QlMjElMjAlMjdyZWx1JTI3JTdEJTBBJTIwJTIwJTIwJTIwJTdCdHlwZSUyMCUzRCUyMCUyN3Bvb2wlMjclMkMlMjBzeCUzQW51bWJlciUyQyUyMHN0cmlkZSUzQW51bWJlciU3RCUwQSUyMCUyMCUyMCUyMCU3QnR5cGUlMjAlM0QlMjAlMjdzb2Z0bWF4JTI3JTJDJTIwbnVtX2NsYXNzZXMlM0FudW1iZXIlN0QlMEElMjAlMjB0cmFpbmVyJTIwJTNBJTIwJTBBJTIwJTIwJTIwJTIwbWV0aG9kJTIwJTNBJTIwc3RyaW5nJTIwJTNEJTIwJTI3YWRhZGVsdGElMjclMjAlMEElMjAlMjAlMjAlMjBsMl9kZWNheSUyMCUzQSUyMG51bWJlciUyMCUzRCUyMSUyMDAuMDAxJTIwJTBBJTIwJTIwJTIwJTIwYmF0Y2hfc2l6ZSUyMCUzQSUyMG51bWJlciUyMCUzRCUyMSUyMDEwJTBBJTIwJTIwZGF0YXR5cGUlM0YlMjAlM0ElMjBzdHJpbmclMjAlM0QlMjAlMjdGbG9hdDMyJTI3JTdDJTI3RmxvYXQ2NCUyNyUwQSUwQVRyYWluJTIwUGFyYW1ldGVyJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMGRhdGElMEElMjAlMjB5JTIwJTNBJTIwZGF0YSUwQSUyMCUyMHdpZHRoJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwaGVpZ2h0JTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwZGVwdGglMjAlM0ElMjBudW1iZXIlMEElMjAlMjBub3JtYWxpemUlMjAlM0ElMjBudW1iZXIlMjAlNUIyJTVEJTBBJTIwJTIwaXRlcmF0aW9ucyUyMCUzQSUyMG51bWJlciUwQSUyMCUyMGNhbGxiYWNrJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjhyZXN1bHQlM0ElN0IlN0QlMkNpdGVyYXRpb24lMjklMjAtJTNFJTIwbW9yZSUzRiUzQWJvb2xlYW4lMEElMjAlMjB2ZXJib3NlJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTBBTUwubGVhcm5lciUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlM0ElMjBNb2RlbCUyMFBhcmFtdGVyJTIwJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwbW9kZWwlMjAlN0IlN0QlMEElMjAlMjAlMEFNTC50cmFpbiUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlMjAlMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlMjAlM0ElMjBUcmFpbiUyMERhdGElMEElMjAlMjBvcHRpb25zJTIwJTNBJTIwVHJhaW5pbmclMjBQYXJhbWV0ZXIlMEElMEFNTC5wcmVkaWN0JTIwJTNBJTIwZnVuY3Rpb24lMEElMjAlMjBtb2RlbCUyMCUyMCUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUyMCUzQSUyMERhdGElMEElMEElMjMlMjMlMjBNTFAlMEElMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlMEElMjAlMjB4JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTIwJTIweSUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUwQURhdGElMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMEElMEFNb2RlbCUyMFBhcmFtZXRlciUyMCUzQSUwQSUyMCUyMGFsZ29yaXRobSUyMCUzQSUyME1MLk1MLk1MUCUwQSUyMCUyMGxheWVycyUyMCUzQSUyMCU1QiU1RCUwQSUwQVRyYWluJTIwUGFyYW1ldGVyJTBBJTIwJTIweCUyMCUzQSUyMGRhdGElMEElMjAlMjB5JTIwJTNBJTIwZGF0YSUwQSUyMCUyMGVwb2NocyUyMCUzQSUyMG51bWJlciUwQSUwQU1MLmxlYXJuZXIlMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMG1vZGVsJTIwJTNBJTIwTW9kZWwlMjBQYXJhbXRlciUyMCUwQSUyMCUyMHJldHVybiUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTIwJTIwJTBBTUwudHJhaW4lMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMG1vZGVsJTIwJTIwJTIwJTNBJTIwbW9kZWwlMjAlN0IlN0QlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTIwJTNBJTIwVHJhaW4lMjBEYXRhJTBBJTIwJTIwb3B0aW9ucyUyMCUzQSUyMFRyYWluaW5nJTIwUGFyYW1ldGVyJTBBJTBBTUwucHJlZGljdCUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlMjAlMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlMjAlM0ElMjBEYXRhJTBBJTBBJTIzJTIzJTIwUlQlMEElMEFXV1clMjAlM0ElMjBodHRwcyUzQS8vZ2l0aHViLmNvbS93aW5ranMvd2luay1yZWdyZXNzaW9uLXRyZWUlMEElMEFUcmFpbmluZyUyMERhdGElMjAlM0ElMjAlN0IlN0QlMjAlNUIlNUQlMjAlMjMlMjByZWNvcmQlMjBhcnJheSUwQSUyMCUyMCUyNG5hbWUlMjAlM0ElMjBudW1iZXIlMjAlN0MlMjBzdHJpbmclMEElMEFEYXRhJTIwJTNBJTIwJTdCJTdEJTIwJTIzJTIwcmVjb3JkJTIwJTBBJTIwJTIwJTI0bmFtZSUyMCUzQSUyMG51bWJlciUyMCU3QyUyMHN0cmluZyUwQURhdGElMjAlM0ElMjAlN0IlN0QlMjAlNUIlNUQlMjAlMjMlMjByZWNvcmQlMjBhcnJheSUwQSUyMCUyMCUyNG5hbWUlMjAlM0ElMjBudW1iZXIlMjAlN0MlMjBzdHJpbmclMEElMEFNb2RlbCUyMFBhcmFtZXRlciUyMCUzQSUwQSUyMCUyMGFsZ29yaXRobSUyMCUzQSUyME1MLk1MLlJUJTBBJTIwJTIwZmVhdHVyZXMlMjAlM0ElMjAlNUIlNUQlMEElMjAlMjAlMjAlMjBuYW1lJTIwJTNBJTIwc3RyaW5nJTBBJTIwJTIwJTIwJTIwY2F0ZWdvcmljYWwlMjAlM0ElMjBib29sZWFuJTBBJTIwJTIwJTIwJTIwZXhjbHVkZSUyMCUzQSUyMGJvb2xlYW4lMEElMjAlMjB0YXJnZXQlMjAlMjAlMjAlM0ElMEElMjAlMjAlMjAlMjBuYW1lJTIwJTNBJTIwc3RyaW5nJTBBJTIwJTIwJTIwJTIwY2F0ZWdvcmljYWwlMjAlM0ElMjBib29sZWFuJTIwJTNEJTIwZmFsc2UlMEElMjAlMjBtaW5QZXJjZW50VmFyaWFuY2VSZWR1Y3Rpb24lMjAlM0ElMjBudW1iZXIlMjAlM0QlM0YlMjAwLjUlMEElMjAlMjBtaW5MZWFmTm9kZUl0ZW1zJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMTAlMEElMjAlMjBtaW5TcGxpdENhbmRpZGF0ZUl0ZW1zJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMzAlMEElMjAlMjBtaW5BdmdDaGlsZHJlbkl0ZW1zJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMiUwQSUwQSUyMCUyMCUyMCUyMCUwQSUyMyUyMyUyMFNWTSUwQSUwQVdXVyUyMCUzQSUyMGh0dHBzJTNBLy9naXRodWIuY29tL2thcnBhdGh5L3N2bWpzJTBBJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCU1QiU1RCUwQSUyMCUyMHklMjAlM0ElMjBudW1iZXIlMjAlN0ItMSUyQzElN0QlNUIlNUQlMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlN0IlN0QlMEElMjAlMjB4JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTIwJTIweSUyMCUzQSUyMG51bWJlciUyMHN0cmluZyUyMCU1QiU1RCUyMCUyMyUyME11bHRpLVNWTSUwQSUwQURhdGElMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEFEYXRhJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTBBTW9kZWwlMjBQYXJhbWV0ZXIlMjAlM0ElMjAlN0IlN0QlMEElMjAlMjBhbGdvcml0aG0lMjAlMjAlMjAlM0ElMjBNTC5NTC5TVk0lMEElMjAlMjBDJTNGJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMS4wJTBBJTIwJTIwdG9sJTNGJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMWUtNCUwQSUyMCUyMG1heF9wYXNzZXMlM0YlMjAlM0ElMjBudW1iZXIlMjAlM0QlM0YlMjAyMCUwQSUyMCUyMGFscGhhX3RvbCUzRiUyMCUyMCUzQSUyMG51bWJlciUyMCUzRCUzRiUyMDFlLTUlMEElMjAlMjBrZXJuZWwlM0YlMjAlMjAlM0ElMjAlMjAlMjMlMjByYmYlMjBrZXJuZWwlMEElMjAlMjAlMjAlMjAlMjB0eXBlJTIwJTIwJTNBJTIwJTIycmJmJTIyJTBBJTIwJTIwJTIwJTIwJTIwc2lnbWElMjAlM0ElMjBudW1iZXIlMjAlM0QlM0YlMjAwLjUlMEElMjAlMjBrZXJuZWwlM0YlMjAlM0ElMjAlMjAlMjMlMjBwb2x5bm9taWFsJTIwa2VybmVsJTBBJTIwJTIwJTIwJTIwJTIwdHlwZSUyMCUzQSUyMCUyMnBvbHlub21pYWwlMjIlMEElMjAlMjAlMjAlMjAlMjBjJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTIxJTIwMSUyMCUwQSUyMCUyMCUyMCUyMCUyMGQlMjAlMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlM0QlMjElMjA1JTBBJTIwJTIwbGFiZWxzJTNGJTIwJTNBJTIwc3RyaW5nJTVCJTVEJTIwJTIwJTIwJTIzJTIwTXVsdGktU1ZNJTBBJTBBUHJlZGljdCUyME91dHB1dCUyMCUzQSUyMG51bWJlciUyMCUwQVByZWRpY3QlMjBPdXRwdXQlMjAlM0ElMjAlMjAlNUIlNUQlMjAlMjMlMjBNdWx0aS1TVk0lMEElMjAlMjAlMjB2YWx1ZSUyMCUzQSUyMHN0cmluZyUwQSUyMCUyMCUyMHByb2IlMjAlMjAlM0ElMjBudW1iZXIlMEElMjAlMjAlMEFNTC5sZWFybiUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlMjAlM0ElMjBNb2RlbCUyMFBhcmFtdGVyJTIwd2l0aCUyMFRyYWluJTIwRGF0YSUwQSUyMCUyMHJldHVybiUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTBBTUwubGVhcm4lMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjBEYXRhJTBBJTIwJTIwbW9kZWwlMjAlMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMHJldHVybiUyMCUzQSUyMFByZWRpY3QlMjBPdXRwdXQlMEElMEElMEE=')};

var Base64=Require('os/base64');
module.exports=Require('top/worksh.js');
