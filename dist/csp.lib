var CoreModule = {};
CoreModule['com/io']='com/io';
CoreModule['com/pwgen']='com/pwgen.lw';
CoreModule['assert']='os/assert';
CoreModule['crypto']='os/crypto.rand';
CoreModule['events']='os/events';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['util']='util';
CoreModule['http']='http';
CoreModule['deasync']='deasync';
CoreModule['os']='os';
CoreModule['net']='net';
CoreModule['fs']='fs';
CoreModule['stream']='';
CoreModule['url']='';
CoreModule['zlib']='';
CoreModule['child_process']='';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
var Fs = require("fs");
if (typeof __dirname == 'undefined') __dirname = '';
if (typeof __filename == 'undefined') __filename = 'plugins/csp/csp.js';
//From compat.js
var any = undefined;
var empty = null;
var none = null;
var _ = undefined;
var int = function (v) {return v|0};
var div = function (a,b) {return a/b|0};
var print = function (msg) {console.log(msg)};
if (typeof global == 'undefined') global={};
PATH=[process.cwd(),".","/home/sbosse/proj/workbook/src",""];
function _isdir(path) {
  var stats=Fs.statSync(path);
  return stats && stats.isDirectory()};
function _search(index,file) {
  if (PATH.length==index) return file;
  var path=PATH[index];
  if (Fs.existsSync(path+"/"+file+".js")) return path+"/"+file+".js";
  else if (Fs.existsSync(path+"/"+file) && !_isdir(path+"/"+file)) return path+"/"+file;
  else return _search(index+1,file);
 }
var __library=arguments&&arguments[3];
function Require(modupath) { 
  var file,filepath;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}; var module={exports:exports};
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,global,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,global,process);
  else { try { file=_search(0,modupath); module = require(file)}
  catch (e) { var more="";
   if ((e.name==="SyntaxError"||e.name==="TypeError") && file) {
      var src=Fs.readFileSync(file,"utf8");
      var Esprima = Require("parser/esprima");
      try {
        var ast = Esprima.parse(src, { tolerant: true, loc:true });
        if (ast.errors && ast.errors.length>0) more = ", "+ast.errors[0];
      } catch (e) {
        if (e.lineNumber) more = ", in line "+e.lineNumber;
      }
   }
   console.log("Require import of "+modupath+" ("+file+") failed: "+e+more);
   // if (e.stack) console.log(e.stack);
   throw e; // process.exit(-1);
  }}
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
FilesEmbedded=global.FilesEmbedded = {};
FileEmbedd=global.FileEmbedd = function (path,format) {};
FileEmbedded=global.FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='node';

BundleModuleCode['com/io']=function (module,exports,global,process){
/**
 **      ==================================
 **      OOOO   OOOO OOOO  O      O   OOOO
 **      O   O  O    O     O     O O  O   O
 **      O   O  O    O     O     O O  O   O
 **      OOOO   OOOO OOOO  O     OOO  OOOO
 **      O   O     O    O  O    O   O O   O
 **      O   O     O    O  O    O   O O   O
 **      OOOO   OOOO OOOO  OOOO O   O OOOO
 **      ==================================
 **      BSSLAB, Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR.
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2020 BSSLAB
 **    $CREATED:     sbosse on 3/28/15.
 **    $VERSION:     1.7.1X
 **
 **    $INFO:
 *
 * This module encapsulates all IO operations (except networking) supporting
 * node.js applications.
 *
 **    $ENDOFINFO
 */

if (global.TARGET=='node')  { 

 /*
  ************
  ** Node.js
  ************
  */
 var util = require('util');
 var GetEnv = Require('os/getenv');
 var Base64 = Require('os/base64');
 var Fs = require('fs');
 var os = require('os');
 var child = require('child_process');

 var stderr_fun = function (str) { process.stderr.write(str); };
 var stdout_fun = function (str) { process.stdout.write(str); };

 /*
  ** node.js specific
  */

 var tracefile = undefined;
 var tracing = true;

 /**
 * Open a module and append all exported properties to the current global object.
 * (top-level scope)
 */
 global.open = function(name,as) {
   var module = Require(name);
   for (var p in module) {
     global[p] = module[p];
   };
   if (as) global[as]=module;
 }

/*
 ** node.js
 */
var io = {
    checkOptions : function(options,defaultOptions) {
      return Object.assign({}, defaultOptions||{}, options) },
      
    checkOption : function (option,defaultOption) { 
      return option==undefined? defaultOption:option },

    config: {
        columns:undefined,
        rows:undefined
    },
    /**************
     ** FILE IO
     ***************/
    /**
     *
     * @param fd
     */
    close: function (fd) {
        Fs.closeSync(fd);
    },
    /**
     *
     * @param path
     */
    exists: function (path) {
        return Fs.existsSync(path);
    },
    /**
     *
     * @param path
     */
    file_exists: function (path) {
        return Fs.existsSync(path);
    },
    /** Search a file by iterating global PATH variable.
     *
     * @param name  File name or partial (relative) path
     */
    file_search: function (name) {
        // Expecting global PATH variable !?
        if (this.file_exists(name)) return name; 
        else if (typeof PATH !== 'undefined') {
          for (var p in PATH) {
            if (this.file_exists(PATH[p]+'/'+name)) return (PATH[p]+'/'+name);
          }
          return undefined;
        } else return undefined;
    },
    /**
     *
     * @param path
     * @returns {number}
     */
    file_size: function (path) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            return stat.size;
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param timekind a c m
     * @returns {number}
     */
    file_time: function (path,timekind) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            switch (timekind) {
                case 'a': return stat.atime.getTime()/1000;
                case 'c': return stat.ctime.getTime()/1000;
                case 'm': return stat.mtime.getTime()/1000;
                default: return stat.mtime.getTime()/1000;
            }
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param mode
     * @returns {*}
     */
    open: function (path, mode) {
        return Fs.openSync(path, mode);
    },
    /**
     *
     * @param fd
     * @param len
     * @param foff
     */
    read: function (fd, len, foff) {
        // TODO
    },
    /**
     *
     * @param path
     * @returns {string|undefined}
     */
    read_file: function (path) {
        try {
            return Fs.readFileSync(path,'utf8');
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    read_file_bin: function (path) {
        try {
            return Fs.readFileSync(path);
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param fd
     */
    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {number}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return Fs.readSync(fd, buf, boff, len, foff);
    },
    /**
     *
     * @param fd
     */
    sync: function (fd) {
        Fs.fsyncSync(fd);
    },
    
    time: function () {
      return Date.now()
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {number}
     */
    write: function (fd, data, foff) {
        return Fs.writeSync(fd, data, foff);
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {number}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return Fs.writeSync(fd, buf, bpos, blen, foff);
    },
    /**
     *
     * @param path
     * @param {string} buf
     */
    write_file: function (path,str) {
        try {
            Fs.writeFileSync(path, str, 'utf8');
            return str.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param path
     * @param buf
     * @returns {*}
     */
    write_file_bin: function (path,buf) {
        try {
            Fs.writeFileSync(path, buf, 'binary');
            return buf.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param fd
     * @param {string} str
     * @returns {number}
     */
    write_line: function (fd, str) {
        return Fs.writeSync(fd, str+NL);
    },

    /****************
     ** CONSOLE IO
     ****************/
    /**
     *
     * @param msg
     */
    debug: function (msg) {
        console.error('Debug: ' + msg);
    },
    /**
     *
     * @param msg
     */
    err: function (msg) {
        console.error('Error: ' + msg);
        throw Error(msg);
    },
    /**
     *
     * @param msg
     */
    fail: function (msg) {
        console.error('Fatal Error: ' + msg);
        process.exit(0);
    },
    /**
     *
     * @param obj
     */
    inspect: function (obj,depth) {return util.inspect(obj,{showHidden: false, 
                                                            depth: depth?depth:2})},

    /**
     * 
     */
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (!e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        if (where==undefined) this.out(e);
        else this.out(where+': '+e);
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
     /**
     *
     * @param e
     * @param where
     */
    sprintstack: function (e) {
        var str='';
        if (e==_ || !e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .replace(/^Object.eval\s*\(/gm, '')
            .split('\n');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                if (str!='') str += '\n';
                str += '  at '+line;
            }
        }
        return str;
    },
   /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    /**
     *
     * @param msg
     */
    out: function (msg) {
        console.warn(msg)
    },
    /**
     *
     * @param msg
     */
    warn: function (msg) {
        console.warn('Warning: ' + msg);
    },
    /**
     *
     * @param fun
     */
    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    /**
     *
     * @param fun
     */
    set_stdout: function(fun) {
        stdout_fun=fun;
    },
    /**
     *
     * @param msg
     */
    stderr: function (msg) {
        stderr_fun(msg);
    },
    /**
     *
     * @param msg
     */
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            Fs.writeSync(tracefile, '[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        tracefile = Fs.openSync(path, 'w+');
        if (tracefile != undefined) this.tracing = false;
    },

    /**************
     ** Process control
     ***************/
    exit: function (n) {
        process.exit(n);
    },
    /**
     *
     * @returns {*} RSS HEAP in kBytes {data,heap}
     */
    mem: function () {
        var mem = process.memoryUsage();
        return {data:(mem.rss/1024)|0,heap:(mem.heapUsed/1024)|0};
    },
    /****************************
     ** Environment and Arguments
     ****************************/
    getenv: function (name, def) {
        return GetEnv(name, def);
    },
    workdir: function () {
        return this.getenv('PWD','');
    },

    /**
     *  @return {string []}
     */
    getargs: function () {
        return process.argv;
    },

    sleep: function(delay) {
      var start = new Date().getTime();
      while (new Date().getTime() < start + delay);
    },
    
    /**
     *  Process management
     */
    fork: child.fork,
    exec: child.exec,
    spawn: child.spawn,

    /**
     * OS
     */
    hostname: os.hostname

  };
} else {
 /*
  ************
  ** Browser
  ************
  */
  var tracing = true;
  var stderr_fun = function (str) { console.log(str); };
  var stdout_fun = function (str) { console.log(str); };
  var args=[];

  /**
  * Open a module and append all exported properties to the current global object.
  * (top-level scope)
  */
  global.open = function(name,as) {
    var module = Require(name);
    for (var p in module) {
      global[p] = module[p];
    };
    if (as) global[as]=module;
  }
  
  var io = {
    /*
    ************
    ** Browser
    ************
    */
    /*
     ** FILE IO
     * TODO WebStorage
     */
    close: function (fd) {
        return;
    },
    exists: function (path) {
        return false;
    },
    open: function (path, mode) {
        var fd = Fs.openSync(path, mode);
        return fd;
    },

    read: function (fd, len, foff) {
        // TODO
    },
    read_file: function (path) {
        return '';
    },

    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {*}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return -1;
    },
    sync: function (fd) {
        return;
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {*}
     */
    write: function (fd, data, foff) {
        return -1;
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {*}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return -1;
    },

    /*
     ** CONSOLE IO
     */
    debug: function (msg) {
        stderr_fun('Debug: ' + msg);
    },
    err: function (msg) {
        stderr_fun('Error: ' + msg);
        throw Error(msg);
    },
    fail: function (msg) {
        stderr_fun('Fatal Error: ' + msg);
    },
    inspect: function (obj) {
        return;
    },
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        stderr_fun('Stack Trace');
        stderr_fun('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                stderr_fun(line);
            }
        }
        stderr_fun('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (where==undefined) stderr_fun(e);
        else stderr_fun(where+': '+e);
    },
    /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    out: function (msg) {
        stdout_fun(msg)
    },
    warn: function (msg) {
        stderr_fun('Warning: ' + msg);
    },


    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    set_stdout: function(fun) {
        stdout_fun=fun;
    },

    stderr: function (msg) {
        stderr_fun(msg);
    },
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            this.log('[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        return undefined;
    },

    exit: function (n) {
        return;
    },
    getenv: function (name, def) {
        return def;
    },
    workdir: function () {
        return '';
    },
    /**
     *  @return {string []}
     */
    getargs: function () {
        return args;
    },
    set_args: function (argv) {
        args=argv;
    },
    inspect: function (o) {return '?'}
  };
}  
module.exports = io;
};
BundleModuleCode['os/getenv']=function (module,exports,global,process){
var util = require("util");
var url = require("url");

var fallbacksDisabled = false;

function _value(varName, fallback) {
  var value = process.env[varName];
  if (value === undefined) {
    if (fallback === undefined) {
      throw new Error('GetEnv.Nonexistent: ' + varName + ' does not exist ' +
                      'and no fallback value provided.');
    }
    if (fallbacksDisabled) {
      throw new Error('GetEnv.DisabledFallbacks: ' + varName + ' relying on fallback ' + 
                      'when fallbacks have been disabled');
    }
    return '' + fallback;
  }
  return value;
}

var convert = {
  string: function(value) {
    return '' + value;
  },
  int: function(value) {
    var isInt = value.match(/^-?\d+$/);
    if (!isInt) {
      throw new Error('GetEnv.NoInteger: ' + value + ' is not an integer.');
    }

    return +value;
  },
  float: function(value) {
    var isInfinity = (+value === Infinity || +value === -Infinity);
    if (isInfinity) {
      throw new Error('GetEnv.Infinity: ' + value + ' is set to +/-Infinity.');
    }

    var isFloat = !(isNaN(value) || value === '');
    if (!isFloat) {
      throw new Error('GetEnv.NoFloat: ' + value + ' is not a number.');
    }

    return +value;
  },
  bool: function(value) {
    var isBool = (value === 'true' || value === 'false');
    if (!isBool) {
      throw new Error('GetEnv.NoBoolean: ' + value + ' is not a boolean.');
    }

    return (value === 'true');
  },
  url: url.parse
};

function converter(type) {
  return function(varName, fallback) {
    if(typeof varName == 'string') { // default
      var value = _value(varName, fallback);
      return convert[type](value);
    } else { // multibert!
      return getenv.multi(varName);
    }
  };
};

var getenv = converter('string');

Object.keys(convert).forEach(function(type) {
  getenv[type] = converter(type);
});

getenv.array = function array(varName, type, fallback) {
  type = type || 'string';
  if (Object.keys(convert).indexOf(type) === -1) {
    throw new Error('GetEnv.ArrayUndefinedType: Unknown array type ' + type);
  }
  var value = _value(varName, fallback);
  return value.split(/\s*,\s*/).map(convert[type]);
};

getenv.multi = function multi(spec) {
  var key, value;
  var result = {};
  for(var key in spec) {
    var value = spec[key];
    if(util.isArray(value)) { // default value & typecast
      switch(value.length) {
        case 1: // no default value
        case 2: // no type casting
          result[key] = getenv(value[0], value[1]); // dirty, when case 1: value[1] is undefined
        break;
        case 3: // with typecast
          result[key] = getenv[value[2]](value[0], value[1]);
          break;
        default: // wtf?
          throw('getenv.multi(): invalid spec');
          break;
      }
    } else { // value or throw
      result[key] = getenv(value);
    }
  }
  return result;
};

getenv.disableFallbacks = function() {
  fallbacksDisabled = true;
};

getenv.enableFallbacks = function() {
  fallbacksDisabled = false;
};

module.exports = getenv;
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['plugins/csp/csp.js']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     29-5-19 by sbosse.
 **    $VERSION:     1.3.1
 **
 **    $INFO:
 **
 **  Universal Constraint Solver Programming Module
 **
 **    $ENDOFINFO
 */
 
var Io = Require('com/io');
var Comp = Require('com/compat');
var simple = Require('plugins/csp/cspS');
var casso  = Require('plugins/csp/cassowary');
var constr = Require('plugins/csp/constrained');
var fmin   = Require('plugins/csp/fmin');
var checkOptions = Io.checkOptions,
    checkOption = Io.checkOption;

CSP = {
  /* Add constraint */
  C : function (model,v1,v2,f) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        model.constraints.push([v1,v2,f]);
        break;
      case CSP.CSP.CASSOWARY:
        model.solver.addConstraint(v1);
        model.constraints.push(v1);
        break;
      case CSP.CSP.CONSTRAINED:
        model.solver.addConstraint(v1);
        model.constraints.push(v1);
        break;
      case CSP.CSP.FMIN:
        model.constraints.push(v1);
        break;
    }    
  },
  
  // Create Equation
  EQ: function (model,x1,x2) {
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        var eq = new casso.Equation(x1,x2);
        model.equations.push(eq);
        return eq;
        break;
    }   
  },
  // Add constant
  N : function (model,name,val) {
    switch (model.algorithm) {
      case CSP.CSP.CONSTRAINED:
        model.constants[name]=val;
        return model.solver.addConstant(name, model.constants, name);
        break;
      case CSP.CSP.FMIN:
        model.constants[name]=val;
        break;
    }    
    return model.variables[name];
  },

  NEQ: function (model,x1,op,x2) {
    var expr;
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        switch (op) {
          case '<=':
          case '<':
            expr = new casso.Inequality(x1,casso.LEQ,x2);
            break;
          case '>=':
          case '>':
            expr = new casso.Inequality(x1,casso.GEQ,x2);
            break;
        }
        return expr;
        break;
    }   
  },


  // Create Expression
  EXPR: function (model,x1,op,x2) {
    var expr;
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        switch (op) {
          case '+':
            expr = casso.plus(x1,x2);
            break;
          case '-':
            expr = casso.minus(x1,x2);
            break;
          case '<':
            expr = new casso.Inequality(x1,casso.LEQ,x2);
            break;
          case undefined:
            expr = new casso.Expression(x1);
            break;
        }
        return expr;
        break;
    }   
  },
  
  // Add variable
  V : function (model,name,val) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        model.variables[name]=val;
        break;
      case CSP.CSP.CASSOWARY:
        model.variables[name]=new casso.Variable({value:val});
        break;
      case CSP.CSP.CONSTRAINED:
        model.variables[name]=val;
        return model.solver.addVariable(name, model.variables, name);
        break;
      case CSP.CSP.FMIN:
        model.variables[name]=val;
        break;
    }    
    return model.variables[name];
  },


  model2loss : function (model) {
    var objvar,expr,
        vars  = Object.keys(model.variables),
        constraints = model.constraints;
    // only equality constraints are supported!
    if (typeof constraints[0]=='function') 
     return constraints[0];
    if (constraints.length==1 && constraints[0].indexOf('=')>0) {
      var eq = constraints[0].split('=');
      if (objvar=eq[1].match(/[ ]([a-zA-Z0-9]+)/)) {
        objvar=objvar[1];
        expr=eq[0].trim();
      }
    }
    if (objvar && expr && model.constants[objvar]!=undefined) {
      var fcode = 'function loss(_x){';
      fcode += 'var ';
      fcode += vars.map(function (v,index) {  return (v+'=_x['+index+']') }).join(',');
      fcode += '; var err = ';
      fcode += expr;
      fcode += ('-'+model.constants[objvar]);
      fcode += '; return err*err}';
      eval(fcode);
      return loss;
    }
  },
  
  range : function (a,b,step) {
    var res=[];
    if (step==undefined) step=1;
    for(var i=a;i<=b;i=i+step) res.push(i);
    return res;
  },
  
  /* Create a new solver */
  solver : function (options) {
    var model={}
    options=checkOptions(options,{});
    options.algorithm=checkOption(options.algorithm,CSP.CSP.SIMPLE);
    model.algorithm=options.algorithm;
    switch (options.algorithm) {
      case CSP.CSP.SIMPLE:
        model.variables= {}
        model.constraints = []
        break;
      case CSP.CSP.CASSOWARY:
        model.variables= {}
        model.constraints = []
        model.equations = []
        model.solver = new casso.SimplexSolver();
        break;
      case CSP.CSP.CONSTRAINED:
        model.constants= {}
        model.variables= {}
        model.constraints = []
        model.solver = new constr.System();
        break;
      case CSP.CSP.FMIN:
        model.variables= {}
        model.constants= {}
        model.constraints = []
        model.algorithm2=options.solver||'nelderMead';
        model.solver = fmin[model.algorithm2];
        break;
    }
    return model
  },
  /* Solve the problem, return solutions */
  solve : function (model,options) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        return simple.solve(model)
      case CSP.CSP.CASSOWARY:
        model.solver.resolve();
        return model.solver.getInternalInfo()
      case CSP.CSP.CONSTRAINED:
        if (options && options.minimize) return model.solver.minimize(options.minimize);
        if (options && options.maximize) return model.solver.maximize(options.maximize);
        model.solver.resolve();
        return model.variables
      case CSP.CSP.FMIN:
        // here is the main work: construct a loss function from variables, constants, and constraint(s)
        var loss = CSP.model2loss(model);
        var solution = model.solver(loss,
                                    Object.keys(model.variables).map(function (v) {
                                      return model.variables[v]
                                    }));
        return solution
        break;
    }  
  },
  CSP:{
    SIMPLE    : 'SIMPLE',
    DISCRETE  : 'SIMPLE',
    CASSOWARY : 'CASSOWARY',
    LINEAR    : 'CASSOWARY',
    CONSTRAINED : 'CONSTRAINED',
    FMIN : 'FMIN',
  },
  CASSOWARY:casso,
  version: '1.3.1'
}

module.exports = CSP;


};
BundleModuleCode['com/compat']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     30-3-15 by sbosse.
 **    $VERSION:     1.23.6X
 **
 **    $INFO:
 **
 **  JavaScript-OCaML Compatibility Module
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Path = Require('com/path');
var Sprintf = Require('com/sprintf');

/*******************************
** Some global special "values"
********************************/

/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var any = undefined;
/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var _ = undefined;

/**
 *
 * @type {null}
 */
var none = null;
/**
 *
 * @type {null}
 */
var empty = null;

var NL = '\n';

global.int = function (v) {return v|0};
global.div = function (a,b) {return a/b|0};

if (!Object.prototype.forEach) {
	Object.defineProperties(Object.prototype, {
		'forEach': {
			value: function (callback) {
				if (this == null) {
					throw new TypeError('Not an object');
				}
				var obj = this;
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						callback.call(obj, obj[key], key, obj);
					}
				}
			},
			writable: true
		}
	});
}
/** Just transfer parent prototypes to child
 *
 */
function inherit(child,parent) {
  for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}

/** Portable class inheritance and instanceOf polyfill
 *
 */
// SomeObject.prototype.__proto__=SomeObject2.prototype;
// Child class inherits prototype from parent using __proto__
function inheritPrototype(child,parent) {
  var __proto__=child.__proto__;
  child.prototype.__proto__=parent.prototype;
  if (!__proto__) for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}
// Polyfill fir o instanceof c with inheritance check (checking __proto__)
function instanceOf(obj,cla) {
  var p=obj.__proto__;
  if (obj instanceof cla) return true;
  while (p) {
    if (p === cla.prototype) return true;
    p=p.__proto__
  }
  return false;
}
// Polyfill for __defineGetter__ / __defineSetter__
function defineGetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    get:fun
  });
}
function defineSetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    set:fun
  });

}

var inherit = inherit;
var inheritPrototype = inheritPrototype;
var instanceOf = instanceOf;
var defineGetter = defineGetter;
var defineSetter = defineSetter;

/**
 *
 */
var assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
};
global.assert=assert;

function forof(obj,f) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = obj[Symbol.iterator](), _step; 
         !(_iteratorNormalCompletion = (_step = _iterator.next()).done); 
         _iteratorNormalCompletion = true) {
      element = _step.value;

      f(element);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}


global.forof=forof;

/** OBJ
 *
 */
var obj = {
    /** Compact an object:
     * [{a:b},[c:d},..] -> {a:b,c:d,..}
     * {a:[b]} -> {a:b}
     *
     */
    compact: function (o) {
      var a;
      if (obj.isArray(o)) {
        if (o.length==1 && obj.isObject(o[0])) return obj.compact(o[0]);
        else return o;
      } else if (obj.isObject(o)) for (a in o) {
          var elem=o[a];
          o[a]=obj.compact(elem);
      }
      return o;
    },
    copy: function (o) {
      if (o === null || typeof o !== 'object') {
        return o;
      }
 
      var temp = (o instanceof Array) ? [] : {};
      for (var key in o) {
        temp[key] = obj.copy(o[key]);
      }
 
      return temp;    
    },
    equal: function (o1,o2) {
      if (!o1 || !o2) return false;
      for(var i in o1) if (o1[i]!=o2[i]) return false;
      for(var i in o2) if (o1[i]!=o2[i]) return false;
      return true;
    },
    extend: function (o1,o2) {
      for(var i in o2) o1[i]=o2[i];
      return o1;
    },
    find: function(obj,fun) {
      var p;
      for(p in obj) {
          if (fun(obj[p],p)) return obj[p];
      }
    },

    hasProperty: function (o,p) {
      return o[p]!=undefined || (p in o);
    },
    head:function(o) {
      for (var p in o) return p;
      return undefined;
    },
    // transfer src attributes to dst recusively (no object overwrite)
    inherit: function (dst,src) {
      for(var i in src) {
        if (typeof dst[i] == 'object' && typeof src[i] == 'object')
          inherit(dst[i],src[i]);
        else if (typeof dst[i] == 'undefined')
          dst[i]=src[i];
      }
      return dst;
    },
    isArray:function (o) {
      if (o==_ || o ==null) return false;
      else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
    },
    isMatrix:function (o) {
      if (o==_ || o ==null) return false;
      else return obj.isArray(o) &&
                  obj.isArray(o[0]);
    },
    isEmpty: function (o) {
      for(var prop in o) {
         if (o[prop]!=undefined) return false;
      }
      return true;  
    },
    isFunction: function (o) {
        return typeof o == "function";
    },
    isObj:function (o) {
        return typeof o == "object";
    },
    isObject:function (o) {
        return typeof o == "object";
    },
    isRegex: function (o) {
        return o instanceof RegExp;
    },
    isString: function (o) {
        return typeof o == "string" || (typeof o == "object" && o.constructor === String);
    },
    isNumber: function (o) {
        return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
    },


    iter: function(obj,fun) {
      var p;
      for(p in obj) {
        fun(obj[p],p)
      }
    }
};

/** ARRAY
 *
 */
var array = {
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean conjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    and: function(array,fun) {
        var res=true;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res&&fun(element,i)
        }
        return res;
    },
    /** Append one element at the end of the array.
     *
     * @param {* []} array
     * @param {*} element
     * @returns {* []}
     */
    append : function(array,element) {
        array.push(element);
        return array;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    call: function(array,args) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            element()
        }
    },
    /** Check for an elenment in the array by using a check function.
     *
     * @param array
     * @param fun
     * @returns {boolean}
     */
    check: function(array,fun) {
        var i,exist;
        exist=false;
        loop: for(i in array) {
            var element=array[i];
            if (fun(element,i)) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Append array2 at the end of array inplace. The extended array is returned.
     *  Source array (1) will be modified.
     *
     * @param {*[]} array
     * @param {*[]} array2
     * @returns {*[]}
     */
    concat : function(array,array2) {
        for(var i in array2) {
            array.push(array2[i]);
        }
        return array;
    },
    /** Create the conjunction set of two arrays
     *
     */
    conjunction :function (set1,set2,fun) {
      return array.union(set1,set2,fun);
    },
    /**
     *
     * @param {*[]} array
     * @param {number|string|*|*[]} elements
     * @param {function} [fun] Optional equality test function
     * @returns {boolean}
     */
    contains : function(array,elements,fun) {
        var i = array.length;
        if (!fun) fun=function(o1,o2) {return o1===o2};
        if (obj.isArray(elements)) {
          while (i--) {
            var j = elements.length;
            while (j--) {
              if (fun(array[i],elements[j])) {
                  return true;
              }          
            }
          }
        }
        else while (i--) {
            if (fun(array[i],elements)) {
                return true;
            }
        }
        return false;
    },
    /** Return a fresh copy of the source array or copy src array to dst.
     *
     * @param array
     * @returns {Array.<T>|string|Blob|ArrayBuffer}
     */
    copy: function(src,dst) {
        var i;
        if (dst) {
          for(i in src) dst[i]=src[i];  
        } else return src.slice();
    },
    /** Create a new array with initial element values.
     *
     * @param length
     * @param init
     * @returns {Array}
     */
    create : function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    },
    /** Create a matrix (array of array) with initial element values.
     *
     */
    create_matrix : function(rows,cols,init) {
        var m = [];
        var r = [];
        var i,j;
        for (i = 0; i < rows; i++) {
            r=[];
            for(j=0;j<cols;j++) r.push(init);
            m.push(r);
        }
        return m;
    },
    /** Create the (inclusive) disjunction set of two arrays.
     *  Source arrays will not be modified.
     *
     */
    disjunction :function (set1,set2,fun) {
      return array.merge(set1,set2);
    },
    /**
     *
     * @param array
     * @returns {boolean}
     */
    empty : function (array) {
      return (array==undefined ||
              array.length==0)
    },
    
    /** Test for equality
    */
    equal: function (a1,a2) {
      if (a1.length != a2.length) return false;
      for(var i in a1) if (a1[i]!=a2[i]) return false;
      return true;
    },
    
    /** Create the (exclusive) disjunction set of two arrays. 
     *  Source arrays will not be modified.
     *
     */
    exclusive :function (set1,set2,fun) {
        var i,j,found,res = [];
        for (i in set1) {
          found=false;
          loop1: for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) {found=true; break loop1;}
            else if (fun == undefined && set1[i]==set2[j]) {found=true; break loop1;};
          }
          if (!found) res.push(set1[i]);
        }
        for (i in set2) {
          found=false;
          loop2: for (j in set1) {
            if (fun != undefined && fun(set2[i],set1[j])) {found=true; break loop2;}
            else if (fun == undefined && set2[i]==set1[j]) {found=true; break loop2;};
          }
          if (!found) res.push(set2[i]);
        }
        return res;
    },
    /** Find an element in an array and return it (or none);
     *
     * @param array
     * @param fun
     * @returns {undefined|*}
     */
    find: function(array,fun) {
        var i;
        for(i in array) {
          if (fun(array[i],i)) return array[i];
        }
        return none;
    },
    /** Search and map an element of an array using a test&map function.
     *
     * @param array
     * @param {function(*,number):*} fun
     * @returns {undefined|*}
     */
    findmap: function(array,fun) {
        var i,found;
        for(i in array) {
          found=fun(array[i],i);
          if (found) return found;
        }
        return none;
    },
    /** Filter out elements using a test function.
     *
     * @param {* []} array
     * @param {function(*,number):boolean} fun
     * @returns {* []}
     */
    filter: function(array,fun) {
      if (array.filter) return array.filter(fun);
      else {
        var res=[],
            len=array.length,
            element,i;
        for(i=0;i<len;i++) {
            element=array[i];
            if (fun(element,i)) res.push(element);
        }
        return res;
      }
    },
    /** Filter out and map elements using a test&map function.
     *
     * @param {* []} array
     * @param {function(*,number):*|undefined} fun
     * @returns {* []}
     */
    filtermap: function(array,fun) {
        var res=[],
            len=array.length,
            element,mapped,i;
        for(i=0;i<len;i++) {
            element=array[i];
            mapped=fun(element,i);
            if (mapped!=undefined) res.push(mapped);
        }
        return res;
    },
    /** Flattens an array consting of arrays (and elements)
     *
     * @param array
     * @returns {Array}
     */
    flatten: function (array) {
        var res=[];
        var len=array.length;
        var i;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (!obj.isArray(element)) res.push(element);
            else {
                var j;
                var len2=element.length;
                for(j=0;j<len2;j++) {
                    var element2=element[j];
                    res.push(element2);
                }
            }
        }
        return res;

    },
    /**
     *
     * @param array
     * @returns {*}
     */
    head : function(array) {
        return array[0];
    },
    /**
     *
     * @param length
     * @param fun
     * @returns {Array}
     */
    init : function(length,fun) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = fun(i);
        }
        return arr;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter: function(array,fun) {
      /*
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            fun(array[i],i)
        }
      */
      array.forEach(fun);
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     */
    iter2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.iter2: arrays of different lengths'));
        /*
        var len=array1.length;
        for(i=0;i<len;i++) {
            fun(array1[i],array2[i],i)
        }
        */
        array1.forEach(function (e1,i) { fun(e1,array2[i],i) });
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun Returning a true value leaves iteration loop
     */
    iter_break: function(array,fun) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (fun(element,i)) return;
        }
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter_rev: function(array,fun) {
        var i;
        var len=array.length;
        for(i=len-1;i>=0;i--) {
            fun(array[i],i)
        }
    },
    /** Return last element of array.
     *
     */
    last : function(array) {
      var len=array.length;
      if (len==0) return none;
      else return array[len-1];
    },
    
    length : function(array) {
        return array.length;
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     * @returns {* []}
     */
    map2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.map2: arrays of different lengths'));
        var len=array1.length;
        var res=[];
        for(i=0;i<len;i++) {
            res.push(fun(array1[i],array2[i],i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     * @returns {* []}
     */
    map: function(array,fun) {
        var i=0;
        var len=array.length;
        var res=[];
        for(i=0;i<len;i++) {
            var element=array[i];
            res.push(fun(element,i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hdtl  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match: function(array,fun_hdtl,fun_empty) {
        if (array.length == 0) {
            if (fun_empty) fun_empty();
        } else if (array.length>1) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else fun_hdtl(this.head(array),[]);
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hd1hd2  - function(hd1,hd2)
     * @param {Function} [fun_hdtl]  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match2: function(array,fun_hd1hd2,fun_hdtl,fun_empty) {
        if (array.length == 0 && fun_empty)
            fun_empty();
        else if (array.length == 2) {
            var hd1 = this.head(array);
            var hd2 = this.second(array);
            fun_hd1hd2(hd1,hd2);
        }
        else if (array.length>1 && fun_hdtl) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else if (fun_hdtl) fun_hdtl(this.head(array),[]);
    },
    /** Return the maximum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    max : function (array,fun) {        
        var res,max,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (max==undefined) { max=num; res=array[i] } 
            else if (num > max) { max=num; res=array[i] }
        }
        return res;
    },
    /** Return the minimum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    min : function (array,fun) {        
        var res,min,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (min==undefined) { min=num; res=array[i] }
            else if (num < min) { min=num; res=array[i] }
        }
        return res;
    },
    /** Check for an element in the array.
     *
     * @param {(number|string|boolean) []} array
     * @param {number|string|boolean} element
     * @returns {boolean}
     */
    member: function(array,element) {
        var i,exist;
        var len=array.length;
        exist=false;
        loop: for(i=0;i<len;i++) {
            var _element=array[i];
            if (_element==element) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Merge all arrays and return a new array.
     *
     * @param {Array} array1
     * @param {Array} array2
     * @param {Array} [array3]
     * @param {Array} [array4]
     * @returns {Array}
     */
    merge: function(array1,array2,array3,array4) {
        var arraynew=array1.slice();
        arraynew=arraynew.concat(array2);
        if (array3!=undefined) arraynew=arraynew.concat(array3);
        if (array4!=undefined) arraynew=arraynew.concat(array4);
        return arraynew;
    },
    /** Return the next element from array after val (next element after last is first!)
     * @param {Array} array
     * @param {number|string} val
     * @returns {number|string}
     */
    next: function(array,val) {
        var i;
        var len=array.length;
        if (obj.isString(val))
          for(i=0;i<len;i++) {
            if (string.equal(array[i],val)) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
        else
          for(i=0;i<len;i++) {
            if (array[i]==val) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
          
        return none;
    },
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean disjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    or: function(array,fun) {
        var res=false;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res||fun(element,i)
        }
        return res;
    },
    
   /**
     * Gets the property value of `key` from all elements in `collection`.
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * pluck(users, 'user');
     * // => ['barney', 'fred']
     */
    pluck: function(collection, key) {
      return collection.map(function(object) {
          return object == null ? undefined : object[key];
        });
    },
    /*
     ** Push/pop head elements (Stack behaviour)
     */
    /** Remove and return top element of array.
     *
     * @param array
     * @returns {*}
     */
    pop : function(array) {
        var element=array[0];
        array.shift();
        return element;
    },
    print: function(array) {
        var i;
        var len=array.length;
        var str='[';
        for(i=0;i<len;i++) {
            var cell=array[i];
            str=str+cell;
        }
        return str+']';
    },
    /** Add new element at top of array.
     *
     * @param array
     * @param element
     */
    push : function(array,element) {
        array.unshift(element);
    },
    /** Create an ordered array of numbers {a,a+1,..b}
     *
     * @param a
     * @param b
     * @returns {Array}
     */
    range : function(a,b) {
        var i;
        var array=[];
        for(i=a;i<=b;i++) array.push(i);
        return array;
    },
    /** Remove elements from an array.
     *  [1,2,3,4,5,6] (begin=2,end=4) => [1,2,6]
     * @param {* []} array
     * @returns {* []}
     */
    remove: function(array,begin,end) {
      var i,a;
      if (end==undefined) end=begin+1;
      if (begin<0 || end >= array.length) return [];
      a=array.slice(0,begin);
      for(i=end;i<array.length;i++) a.push(array[i]);
      return a;
    },
    
    second : function(array) {
        return array[1];
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,*):number} fun   (1:a gt. b by the ordering criterion,-1: a lt. b, 0: a eq. b)
     * @returns {* []}
     */
    sort: function(array,fun) {
        var array2=array.slice();
        array2.sort(fun);
        return array2;
    },
    /** Split an array at position 'pos', i.e., remove 'len' (1) elements starting at 
     *  position 'pos'.
     *  ==> use remove!!! split should return two arrays!!
     *
     * @param array
     * @param pos
     * @param [len]
     * @param element
     */    
    split: function(array,pos,len) {
      if (pos==0) return array.slice((len||1));
      else {
        var a1=array.slice(0,pos);
        var a2=array.slice(pos+(len||1));
        return a1.concat(a2);
      }
    },
    /** Return the sum number of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    sum : function (array,fun) {        
        var res=0;
        for(var i in array) {
            var num=0;
            if (fun) num=fun(array[i]); else num=array[i];
            if (!obj.isNumber(num)) return undefined;
            res += num;
        }
        return res;
    },
    /** Return a new array w/o the head element (or optional 
     *  w/o the first top elements).
     *
     */
    tail : function(array,top) {
        var array2=array.slice();
        array2.shift();
        if (top) for(;top>1;top--) array2.shift();
        return array2;
    },
    /** Return union of two sets (== conjunction set)
     *
     * @param {* []} set1 
     * @param {* []} set2
     * @param {function} [fun]  Equality test
     * @returns {* []}
     */
    union : function(set1,set2,fun) {
        var i,j,res = [];
        for (i in set1) {
          for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) res.push(set1[i]);
            else if (fun == undefined && set1[i]==set2[j]) res.push(set1[i]);
          }
        }
        return res;
    },
    
    /**
     * Creates a duplicate-free version of an array
     */
    unique: function(array) {
      var length = array ? array.length : 0;
      function baseUniq(array) {
        var index = -1,
            length = array.length,
            seen,
            result = [];

        seen = result;
        outer:
        while (++index < length) {
          var value = array[index];
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        return result;
      }
      if (!length) {
        return [];
      }
      return baseUniq(array);
    },
    
    /**
     * Creates an array excluding all provided values
     * without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    without: function () {
      var array,
          values=[];
      for(var i in arguments) {
        if (i==0) array=arguments[0];
        else values.push(arguments[i]);
      }
      return array.filter(function (e) {
        return values.indexOf(e) == -1;
      });
    },
    /** Test for zero elements {0, '', false, undefined, ..}
    */
    zero: function (array) {
      for(var i in array) if (!!array[i]) return false;
      return true;
    },
};

/** STRING
 *
 */
var string = {
    /** Is pattern conatined in template?
     *
     */
    contains: function (template,pattern) {
      return template.indexOf(pattern)>-1;
    },
    copy: function(src) {
        var i;
        var dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
    },
    /**
     *
     * @param {number} size
     * @returns {string} filled with spaces
     */
    create: function(size)
    {
        var i;
        var s='';
        var init=' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    endsWith : function (str,tail) {
        return str.indexOf(tail)==(str.length-tail.length);
    },
    empty: function (str) {
      return this.equal(str,'');
    },
    equal:  function(str1,str2) {
        var i;
        var eq=true;
        if (str1.length != str2.length) return false;
        for(i=0;i<str1.length;i++) { if (string.get(str1,i)!=string.get(str2,i)) eq=false;}
        return eq;
    },
    find: function (search,str) {
        return str.indexOf(search);
    },
    format_hex: function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
    },
    /**
     *
     * @param {string} str
     * @param {number} index
     * @returns {string}
     */
    get: function (str,index) {
        assert((str != undefined && index < str.length && index >= 0)||('string.get ('+str.length+')'));
        return str.charAt(index);
    },
    isBoolean: function (str) {
        return (str=='true' || str=='false')
    },
    isNumeric: function (str) {
        return !isNaN(parseFloat(str)) && isFinite(str);
    },
    isText: function (s) {
      var is_text=true;
      string.iter(s,function (ch,i) {
        string.match(ch,[
          ['a','z',function () {}],
          ['A','Z',function () {}],
          ['0','9',function () {if (i==0) is_text=false;}],
          function () {is_text=false;}
        ]);
      });
      return is_text;
    },
    /**
     *
     * @param {string} str
     * @param {function(string,number)} fun
     */
    iter: function(str,fun) {
        var i;
        var len=str.length;
        for (i = 0; i < len; i++)  {
            var c = str.charAt(i);
            fun(c,i);
        }
    },
    /**
     *
     * @param str
     * @returns {*}
     */
    length: function(str) {
        if (str!=undefined) return str.length;
        else return 0;
    },
    /**
     *
     * @param str
     * @returns {string}
     */
    lowercase : function (str) {
        return str.toLowerCase();
    },
    /**
     *
     * @param {number} size
     * @param {string} init
     * @returns {string}
     */
    make: function(size,init)
    {
        var i;
        var s='';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    /** Map a string with a set of (test,reuslt) transformation rules.
     * 
     * @param {string} str
     * @param {* [] []} case - ([string,string] | fun) []
     */
    map: function(str,mapping) {
        var i;
        var map;
        for(i in mapping) {
            map=mapping[i];
            if (obj.isFunction(map)) return map(str);
            else if (this.equal(str,map[0])) return map[1];
        }          
    },
    /** Match a string with different patterns and apply a matching function.
     *
     * @param {string} str
     * @param {* [] []} cases - ([string,fun] | [string [<case1>,<case2>,..],fun] | [<range1>:string,<range2>:string,fun] | fun) []
     */
    match: function(str,cases) {
        var i,j;
        var cas,cex,cv;
        for(i in cases) {
            cas=cases[i];
            if (obj.isArray(cas)) {
              switch (cas.length) {
                case 2:
                  // Multi-value-case
                  cex=cas[0];
                  if (!obj.isArray(cex)) {
                      if (this.equal(str,cex)) {
                          cas[1]();
                          return;
                      }
                  } else {
                      for(j in cex) {
                          cv=cex[j];
                          if (this.equal(str,cv)) {
                              cas[1]();
                              return;
                          }
                      }
                  }
                  break;
                case 3:
                  // Character range check
                  try {
                    j=pervasives.int_of_char(str);
                    if (j>= pervasives.int_of_char(cas[0]) && j<=pervasives.int_of_char(cas[1])) {
                      cas[2](str);
                      return;
                    }
                  } catch(e) {
                    return
                  };
                  break;
                case 1:
                  cas[0](str); // Default case - obsolete
                  return;
                default: 
                  throw 'String.match #args';
              }
            } else if (obj.isFunction(cas)) {
                // Default case
                cas(str);
                return;
            }
        }
    },
    /** Pad a string on the left (pre-str.length) if pre>0,
     *  right (post-str.length) if post>0, or centered (pre>0&post>0).
     *
     */
     
    pad: function (str,pre,post,char) {
      var len = str.length;
      if (pre>0 && post==0) return string.make(len-pre,char||' ')+str;
      else if (post>0 && pre==0) return str+string.make(post-len,char||' ');
      else return string.make(len-pre/2,char||' ')+str+string.make(len-post/2,char||' ');
    },
    /**
     *
     * @param str
     * @param pos
     * @param len
     * @returns {Number}
     */
    parse_hex: function (str,pos,len) {
        // parse a hexadecimal number in string 'str' starting at position 'pos' with 'len' figures.
        return parseInt(this.sub(str,pos,len),16);
    },
    /** Return the sub-string after a point in the source string ('.' or optional point string).
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    postfix: function (str,point) {
      var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(n+1);
    },
    /** Return the sub-string before a point in the source string ('.' or optional point string)
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    prefix: function (str,point) {
        var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(0,n);
    },
    replace_first: function (pat,repl,str) {
        return str.replace(pat,repl);
    },
    replace_all: function (pat,repl,str) {
        return str.replace('/'+pat+'/g',repl);
    },
    /**
     *
     * @param str
     * @param index
     * @param char
     * @returns {string}
     */
    set: function (str,index,char) {
        assert((str != undefined && index < str.length && index >= 0)||'string.get');
        return str.substr(0, index) + char + str.substr(index+1)
    },
    /**
     *
     * @param delim
     * @param str
     * @returns {*|Array}
     */
    split: function (delim,str) {
        return str.split(delim);
    },
    startsWith : function (str,head) {
        return !str.indexOf(head);
    },
    /** Return a sub-string.
     * 
     * @param str
     * @param off
     * @param [len] If not give, return a sub-string from off to end
     * @returns {string}
     */
    sub: function (str,off,len) {
        if (len)
            return str.substr(off,len);
        else
            return str.substr(off);
    },
    /** Remove leading and trailing characters from string
     *
     * @param str
     * @param {number} pref number of head characters to remove
     * @param {number} post number of tail characters to remove
     * @returns {*}
     */
    trim: function (str,pref,post) {
        if (str.length==0 ||
            pref>str.length ||
            post>str.length ||
            pref < 0 || post < 0 ||
            (pref==0 && post==0)
        ) return str;
        return str.substr(pref,str.length-pref-post);
    },
    /** Return a string with all characters converted to uppercase letters.
     *
     * @param str
     * @returns {string}
     */
    uppercase : function (str) {
        return str.toUpperCase();
    },
    /** Return a string with first character converted to uppercase letter.
     *
     * @param str
     * @returns {string}
     */
    Uppercase : function (str) {
        var len = str.length;
        if (len > 1) {
            var head = str.substr(0,1);
            var tail = str.substr(1,len-1);
            return head.toUpperCase()+tail.toLowerCase()
        } if (len==1) return str.toUpperCase();
        else return '';
    }
};

/** RANDOM
 *
 */
var rnd = Math.random;
/* Antti Sykri's algorithm adapted from Wikipedia MWC
** Returns a random generator function [0.0,1.0| with seed initialization
*/
var seeder = function(s) {
    var m_w  = s;
    var m_z  = 987654321;
    var mask = 0xffffffff;

    return function() {
      m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
      m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;

      var result = ((m_z << 16) + m_w) & mask;
      result /= 4294967296;

      return result + 0.5;
    }
}
 
var random = {
    float: function(max) {
        return rnd()*max
    }, 
    int: function(max) {
        return Math.floor(rnd()*max+0)
    },
    // integer
    interval: function(min,max) {
        return Math.round(min+rnd()*(max-min))
    },
    // float
    range: function(min,max) {
        return min+rnd()*(max-min)
    },
    seed: function (s) {
      // Create a new initialized random generator
      rnd=seeder(s);
    }
};

/** PRINTF
 *
 */
var printf = {
    /** Trim string(s).
     *
     * @param str
     * @param indent
     * @param [width]
     * @param {string} [tab]
     * @returns {string}
     */
    align: function (str,indent,width,tab) {
        var lines = string.split('\n',str);
        var form = '';
        var sp = printf.spaces(indent);
        var spbreak = sp;

        array.iter(lines,function(line){
            var rest;
            function breakit(spbreak,str) {
                if (width < (str.length + spbreak.length)) {
                    return spbreak+string.sub(str,0,width-spbreak.length)+'\n'+
                           breakit(spbreak,string.sub(str,width-spbreak.length,str.length-width+spbreak.length));
                } else return spbreak+str+'\n';
            }
            if (width && width < (line.length + indent)) {
                if (tab) {
                    var pos = string.find(tab,line);
                    if (pos > 0 && pos < width) spbreak=printf.spaces(pos+indent+1);
                    else spbreak=sp;
                }
                form=form+sp+string.sub(line,0,width-indent)+'\n';
                rest=string.sub(line,width-indent,line.length-width+indent);
                form=form+breakit(spbreak,rest);
            }
            else
                form=form+sp+line+'\n';
        });
        return form;
    },
    /** Format a list of array elements using the (optional) mapping
     *  function <fun> and the separator <sep> (optional, too, default is ',').
     * 
     */
    list: function (array,fun,sep) {
      var i, str='';
      if (sep==undefined) sep=',';
      if (fun==undefined) fun=function (s) {return s;};
      if (!obj.isArray(array)) array=[array];
      for (i in array) {
        if (str==='') str=fun(array[i]);
        else str=str+sep+fun(array[i]);
      }
      return str;
    },
    /**
     *
     * @param n
     * @returns {string}
     */
    spaces: function (n){
        return string.make(n,' ');
    },
    /** Formatted printer (simplified)
     *
     * @param {* []} args (['%format',arg]|string) []  format=%s,%d,%f,%c,%x,%#d,%#s,..
     * @returns {string}
     */
    sprintf2: function(args) {
        var str='';
        array.iter(args,function(fmtarg) {
            var len, n,fs;
            if (obj.isArray(fmtarg)) {
                if (fmtarg.length==2) {
                    var fmt=fmtarg[0];
                    var arg=fmtarg[1];
                    var fc='';
                    var fn=0;
                    string.iter(fmt,function(c) {
                        if (c=='s' || c=='d' || c=='f' || c=='x') {
                            fc=c;
                        } else if (c!='%') {
                            fn=fn*10;
                            n=parseInt(c);
                            if (!isNaN(n)) fn=fn+n;
                        }
                    });
                    if (fc=='s' && obj.isString(arg)) {
                        str=str+arg;
                        if (fn!=0) {
                            len=arg.length;
                            if (len<fn) str=str+string.create(fn-len);
                        }
                    } else if (fc=='d' && obj.isNumber(arg)) {
                        fs = pervasives.string_of_int(arg);
                        if (fn!=0) {
                            len = fs.length;
                            if (len < fn) {
                                str=str+string.create(fn-len);
                            }
                        }
                        str=str+fs;
                    } else if (fc=='x' && obj.isNumber(arg)) {
                        fs = string.format_hex(arg,fn||8);
                        str=str+fs;
                    }
                }
            } else if (obj.isString(fmtarg)) {
                str = str + fmtarg;
            }
        });
        return str;
    },
    sprintf:Sprintf.sprintf
};

/** FILENAME
 *
 */
var filename = {
    /**
     *
     * @param path
     * @returns {string}
     */
    basename : function (path) {
        return Path.basename(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    dirname : function (path) {
        return Path.dirname(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    extname : function (path) {
        return Path.extname(path)
    },
    /**
     *
     * @param path
     * @returns {boolean}
     */
    is_relative: function(path) {
        return !(path.length > 0 && path[0] == '/');
    },
    /**
     *
     * @param pathl
     * @param absolute
     * @returns {string}
     */
    join: function (pathl,absolute) {
        var path=(absolute?'/':'');
        array.iter(pathl,function (name,index) {
            if (index>0) {
                path=path+'/'+name;
            }
            else {
                path=path+name;
            }
        });
        return path;
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    normalize : function (path) {
        return Path.normalize(path)
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    path_absolute: function (path) {
        if (this.is_relative(path)) {
            var workdir = Io.workdir();
            return this.path_normalize(workdir + '/' + path);
        } else return this.path_normalize(path);
    },
    /** Duplicate of Path.normalize!?
     *
     * @param path
     * @returns {string}
     */
    path_normalize: function (path) {
        var i;
        if (string.equal(path, '')) path = '/';
        var relpath = !(string.get(path, 0) == '/');
        var pathlist = path.split('/');
        var pathlist2 = pathlist.filter(function (s) {
            return (!string.equal(s, '') && !string.equal(s, '.'))
        });
        var pathlist3 = [];
        array.iter(pathlist2, function (pe) {
            if (!string.equal(pe, '..')) {
                array.push(pathlist3, pe)
            } else {
                if (pathlist3.length == 0) return '';
                else
                    pathlist3 = array.tail(pathlist3);
            }
        });
        var path2 = '';
        i = 0;
        array.iter(pathlist3, function (pe) {
            var sep;
            if (i == 0) sep = ''; else sep = '/';
            path2 = pe + sep + path2;
            i++;
        });
        if (relpath) return path2; else return '/' + path2;
    },
    removeext: function (path) {
      return path.substr(0, path.lastIndexOf('.'));
    }
};

/** PERVASIVES
 *
 *
 */
var pervasives = {
    assert:assert,
    char_of_int: function (i) {return String.fromCharCode(i)},
    div: function(a,b) {return a/b|0;},
    failwith: function(msg) {Io.err(msg);},
    float_of_string: function(s) {var num=parseFloat(s); if (isNaN(num)) throw 'NaN'; else return num;},
    int_of_char: function(c) {return c.charCodeAt()},
    int_of_float: function(f) {return f|0;},
    int_of_string: function(s) {      
      var num=parseInt(s); if (isNaN(num)) throw 'NaN'; else return num;
    },

    /** Try to find a value in a search list and return a mapping value.
     *
     * @param {*} value
     * @param {* []} mapping [testval,mapval] []
     * @returns {*}
     */
    map: function(value,mapping) {
        function eq(v1,v2) {
            if (v1==v2) return true;
            if (obj.isString(v1) && obj.isString(v2)) return string.equal(v1,v2);
            return false;
        }
        if (!array.empty(mapping)) {
          var hd=array.head(mapping);
          var tl=array.tail(mapping);
          if (eq(hd[0],value)) return hd[1];
          else return pervasives.map(value,tl);
        }  else return undefined;
    },
    /** Apply a matcher function to a list of cases with case handler functions.
     * A case is matched if the matcher function returns a value/object.
     *
     * The result of the matcher function is passed as an argument ot the case handler function.
     * The return value of the case handler fucntion is finally returned by this match function
     * or undefined if there was no matching case.
     *
     * @param {function(*,*):*} matcher function(expr,pat)
     * @param {*} expr
     * @param {*[]} cases (pattern,handler function | handler function) []
     * @returns {*|undefined}
     */
    match: function (matcher,expr,cases) {
        var ret = undefined;
        array.iter_break(cases, function (match) {
            var quit, succ, pat, fun;

            if (match.length == 2) {
                /*
                 ** Pattern, Function
                 */
                pat = match[0];
                fun = match[1];
                succ = matcher(expr, pat);
                if (succ) ret = fun(succ);
                quit = succ!=undefined;
            } else if (match.length == 1) {
                /*
                 ** Default case, Function
                 */
                fun = match[0];
                ret = fun();
                quit= true;
            }
            return quit;
        });
        return ret;
    },
    mtime: function () {var time = new Date(); return time.getTime();},
    min: function(a,b) { return (a<b)?a:b},
    max: function(a,b) { return (a>b)?a:b},
    string_of_float: function(f) {return f.toString()},
    string_of_int: function(i) {return i.toString()},
    string_of_int64: function(i) {return i.toString()},
    time: function () {var time = new Date(); return (time.getTime()/1000)|0;}
};

/** BIT
 *
 */
var bit = {
    get: function (v,b) {return (v >> b) && 1;},
    isSet: function (v,b) {return ((v >> b) && 1)==1;},
    set: function (v,b) {return v & (1 << b);}
};

/** ARGS
 *
 */
var args = {
    /** Parse process or command line arguments (array argv). The first offset [1] arguments are
     ** ignored. The numarg pattern '*' consumes all remaining arguments.
     *
     * @param {string []} argv
     * @param {*[]} map  [<argname>,<numargs:0..3|'*'>,<handler(up to 3 arguments|[])>]|[<defhandler(val)>] []
     * @param {number} [offset]
     */
    parse: function(argv,map,offset) {
        var shift=undefined,
            in_shift=0,
            shift_args=[],
            names,
            mapfun,
            numarg,
            len=argv.length;

        if (offset==undefined) offset=1;

        argv.forEach(function (val, index) {
            var last=index==(len-1);
            if(index>=offset) {
                if (in_shift==0) {
                    array.check(map,function (onemap) {
                        assert(onemap!=undefined||'map');
                        if (onemap.length==3) {
                            names  = onemap[0];
                            numarg = onemap[1];
                            mapfun = onemap[2];
                            if (!obj.isArray(names)) names=[names];
                            var found = array.find(names,function (name) {
                                if (string.equal(val, name)) return name; else _;
                            });
                            if (found) {
                                if (numarg==0) mapfun(found);
                                else {
                                    in_shift=numarg;
                                    shift_args=[];
                                    shift=mapfun;
                                }
                                return true;
                            }
                        } else if (obj.isFunction(onemap)) {
                          onemap(val);
                          return true;                        
                        } else if (onemap.length==1) {
                            mapfun = onemap[0];
                            mapfun(val);
                            return true;
                        }
                        return false;
                    });
                } else {
                    shift_args.push(val);
                    if (in_shift!='*') in_shift--;
                    if (in_shift==0 && shift!=undefined) {
                        numarg=shift_args.length;
                        switch (numarg) {
                            case 0: shift(val);break;
                            case 1: shift(shift_args[0],val); break;
                            case 2: shift(shift_args[0],shift_args[1],val); break;
                            case 3: shift(shift_args[0],shift_args[1],shift_args[2],val); break;
                            default: break;
                        }
                        shift=undefined;
                    } else if (in_shift=='*' && last) shift(shift_args);
                }
            }
        });
    }

};

/** HASHTBL
 *
 */
var hashtbl = {
    add: function(hash,key,data) {
        hash[key]=data;
    },
    create: function(initial) {
        return [];
    },
    empty: function(hash) {
        for (var key in hash) return false;
        return true;
    },
    find: function(hash,key) {
        return hash[key];
    },
    invalidate: function(hash,key) {
        hash[key]=undefined;
    },
    iter: function(hash,fun) {
        for (var key in hash) {
            if (hash[key]!=undefined) fun(key,hash[key]);
        }
    },
    mem: function(hash,key) {
        return hash[key] != undefined;
    },
    remove: function(hash,key) {
        // TODO: check, its wrong!
        if (!hash.hasOwnProperty(key))
            return;
        if (isNaN(parseInt(key)) || !(hash instanceof Array))
            delete hash[key];
        else
            hash.splice(key, 1)
    }
};

var types = [];
/**
 * 
 * @param name
 * @returns {number}
 */
function register_type(name) {
    var typoff = 1000+types.length*1000;
    if (array.member(types,name)) throw('[COMP] register_type: type '+name+' exists already.');
    types.push(name);
    return typoff;
}

/**
 *
 * @typedef {{v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tuple
 */
/**
 *
 * @typedef {{t:number, v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tagged_tuple
 */

module.exports = {
    args:args,
    assert: assert,
    array:array,
    bit:bit,
    defineGetter : defineGetter,
    defineSetter : defineSetter,
    div:pervasives.div,
    filename:filename,
    hashtbl:hashtbl,
    inherit : inherit,
    inheritPrototype : inheritPrototype,
    instanceOf : instanceOf,
    isNodeJS: function () {
        return (typeof global !== "undefined" &&
                {}.toString.call(global) == '[object global]');
    },
    obj:obj,
    pervasives:pervasives,
    printf:printf,
    random:random,
    string:string,
    isArray: obj.isArray,
    isString: obj.isString,
    isNumber: obj.isNumber,

    register_type:register_type,
    /**
     *
     * @param tag
     * @param [val1]
     * @param [val2]
     * @param [val3]
     * @returns {(tagged_tuple)}
     */
    Tuple: function (tag,val1,val2,val3) {
        if(val3) return {t:tag,v1:val1,v2:val2,v3:val3};
        else if (val2) return {t:tag,v1:val1,v2:val2};
        else if (val1) return {t:tag,v1:val1};
        else return {t:tag};
    }
};
};
BundleModuleCode['plugins/csp/cspS']=function (module,exports,global,process){
var CSP = {},
    FAILURE = 'FAILURE',
    stepCounter = 0;

CSP.solve = function solve(csp) {
  // Solves a constraint satisfaction problem.
  // `csp` is an object that should have the properties:
  //    `variables`  : object that holds variable names and their domain.
  //    `constraints`: list of constraints where each element is an 
  //                   array of [head node, tail node, constraint function]
  //    `cb`: optional callback function.

  var result = backtrack({}, csp.variables, csp);
  if (result == FAILURE) { return result; }
  // Unwrap values from array containers.
  for (var key in result) {
    result[key] = result[key][0];
  }
  if (csp.cb) csp.cb(result);
  return result;
}

function backtrack(_assigned, unassigned, csp) {
  // Backtracking search.
  
  // Copying assigned in necessary because we modify it. Without copying
  // the object over, modifying assigned would also change values for old
  // assigned objects (which are used in callbacks).
  var assigned = {};
  for (var key in _assigned) { assigned[key] = _assigned[key]; }

  if (finished(unassigned)) { return assigned; } // Base case.
  var nextKey = selectUnassignedVariable(unassigned),
      values = orderValues(nextKey, assigned, unassigned, csp);
  delete unassigned[nextKey];

  for (var i = 0; i < values.length; i++) {
    stepCounter++;
    assigned[nextKey] = [values[i]]; // Assign a value to a variable.
    var consistent = enforceConsistency(assigned, unassigned, csp);
    var newUnassigned = {}, newAssigned = {};
    for (var key in consistent) {
      if (assigned[key]) { newAssigned[key] = assigned[key].slice(); }
      else { newUnassigned[key] = consistent[key].slice(); }
    }
    if (anyEmpty(consistent)) { continue; } // Empty domains means failure.
    var result = backtrack(newAssigned, newUnassigned, csp);
    if (result != FAILURE) { return result; }
  }

  return FAILURE;
}

function finished(unassigned) {
  // Checks if there are no more variables to assign.
  return Object.keys(unassigned).length == 0;
}

function anyEmpty(consistent) {
  // Checks if any variable's domain is empty.
  for (var key in consistent) {
    if (consistent[key].length == 0) { return true; }
  }
  return false;
}

function partialAssignment(assigned, unassigned) {
  // Combine unassigned and assigned for use in enforceConsistency.
  var partial = {};
  for (var key in unassigned) { partial[key] = unassigned[key].slice(); }
  for (var key in assigned) { partial[key] = assigned[key].slice(); }
  return partial;
}

function enforceConsistency(assigned, unassigned, csp) {
  // Enforces arc consistency by removing inconsistent values from
  // every constraint's tail node.

  function removeInconsistentValues(head, tail, constraint, variables) {
    var hv,tv,validHeadValues,validTailValues,removed;
    if (tail) {
      // Removes inconsistent values from the tail node. A value is
      // inconsistent when if the `tail` is assigned that value, there are
      // no values in `head`'s domain that satisfies the constraint.
      // - binray constraint
      hv = variables[head], tv = variables[tail];
      validTailValues = tv.filter(function (t) {
        return hv.some(function (h) {
          return constraint(h, t);
        });
      });
      removed = tv.length != validTailValues.length;
      variables[tail] = validTailValues;
    } else {
      // unary constraint - modify head
      hv = variables[head];
      validHeadValues = hv.filter(function (h) {
          return constraint(h);
      });
      removed = hv.length != validHeadValues.length;
      variables[head] = validHeadValues;
    }
    return removed;
  }

  function incomingConstraints(node) {
    // Returns all the constraints where `node` is the head node.
    return csp.constraints.filter(function (c) {
      return c[0] == node;
    });
  }
  
  var queue = csp.constraints.slice(), 
      variables = partialAssignment(assigned, unassigned);
  while (queue.length) { // While there are more constraints to test.
    var c = queue.shift(), head = c[0], tail = c[1], constraint = c[2];
    if (removeInconsistentValues(head, tail, constraint, variables)) {
      // If values from the tail have been removed, incoming constraints
      // to the tail must be rechecked.
      queue = queue.concat(incomingConstraints(tail));
    }
  }
  return variables;
}

function selectUnassignedVariable(unassigned) {
  // Picks the next variable to assign according to the Minimum
  // Remaining Values heuristic. Pick the variable with the fewest
  // values remaining in its domain. This helps identify domain
  // failures earlier.
  var minKey = null, minLen = Number.POSITIVE_INFINITY;
  for (var key in unassigned) {
    var len = unassigned[key].length;
    if (len < minLen) { minKey = key, minLen = len; }
  }
  return minKey;
}

function orderValues(nextKey, assigned, unassigned, csp) {
  // Orders the values of an unassigned variable according to the
  // Least Constraining Values heuristic. Perform arc consistency
  // on each possible value, and order variables according to the
  // how many values were eliminated from all the domains (fewest
  // eliminated in the front). This helps makes success more likely
  // by keeping future options open.
  
  function countValues(vars) {
    var sum = 0;
    for (var key in vars) { sum += vars[key].length; }
    return sum;
  }

  function valuesEliminated(val) {
    assigned[nextKey] = [val];
    var newLength = countValues(enforceConsistency(assigned, unassigned, csp));
    delete assigned[nextKey];
    return newLength;
  }

  // Cache valuesEliminated to be used in sort.
  var cache = {}, values = unassigned[nextKey];
  values.forEach(function(val) {
    cache[val] = valuesEliminated(val);
  });
  // Descending order based on the number of domain values remaining.
  values.sort(function (a, b) { return cache[b] - cache[a]; });
  return values;
}

module.exports = CSP;
};
BundleModuleCode['plugins/csp/cassowary']=function (module,exports,global,process){
/**
 * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
 * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
 *
 * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
 *
 * This is a compiled version of Cassowary/JS. For source versions or to
 * contribute, see the github project:
 *
 *  https://github.com/slightlyoff/cassowary.js/
 *  https://github.com/slightlyoff/cassowary-js-refactor
 *
 */

(function() {
!function(a){"use strict";var b="undefined"!=typeof a.HTMLElement,c=function(a){for(var b=null;a&&a!=Object.prototype;){if(a.tagName){b=a.tagName;break}a=a.prototype}return b||"div"},d=1e-8,e={},f=function(a,b){if(a&&b){if("function"==typeof a[b])return a[b];var c=a.prototype;if(c&&"function"==typeof c[b])return c[b];if(c!==Object.prototype&&c!==Function.prototype)return"function"==typeof a.__super__?f(a.__super__,b):void 0}},g=!1;try{var h=new Map;h.set("foo","bar");var i=h.values();i.next(),h.forEach(function(){});var k=new Map(h);if(k.get("foo")!=h.get("foo"))throw"ctor fail";g=!0}catch(l){}var m=a.c=function(){return m._api?m._api.apply(this,arguments):void 0};m._functionalMap=g,m.GEQ=1,m.LEQ=2;var n=b?function(b,d,e){if(d&&d.prototype instanceof a.HTMLElement){var g=b,h=c(e),i=function(a){return a.__proto__=e,g.apply(a,arguments),e.created&&a.created(),e.decorate&&a.decorate(),a};m.extend(e,{upgrade:i}),b=function(){return i(a.document.createElement(h))},b.prototype=e,m.extend(b,{ctor:g})}return b}:function(a){return a};m.inherit=function(a){var b=null,c=null;a["extends"]&&(c=a["extends"],delete a["extends"]),a.initialize&&(b=a.initialize,delete a.initialize);var d=b||function(){};Object.defineProperty(d,"__super__",{value:c?c:Object,enumerable:!1,configurable:!0,writable:!1}),a._t&&(e[a._t]=d);var f=d.prototype=Object.create(c?c.prototype:Object.prototype);return m.extend(f,a),n(d,c,f,a)},m.own=function(b,c,d){return Object.getOwnPropertyNames(b).forEach(c,d||a),b},m.extend=function(a,b){return m.own(b,function(c){var d=Object.getOwnPropertyDescriptor(b,c);if("function"==typeof d.get||"function"==typeof d.set)Object.defineProperty(a,c,d);else if("function"==typeof d.value||"_"===c.charAt(0))d.writable=!0,d.configurable=!0,d.enumerable=!1,Object.defineProperty(a,c,d);else try{a[c]=b[c]}catch(e){}}),a},m.assert=function(a,b){if(!a)throw new m.InternalError("Assertion failed: "+b)};var o=function(a){return"number"==typeof a?m.Expression.fromConstant(a):a instanceof m.Variable?m.Expression.fromVariable(a):a};m.plus=function(a,b){return a=o(a),b=o(b),a.plus(b)},m.minus=function(a,b){return a=o(a),b=o(b),a.minus(b)},m.times=function(a,b){return a=o(a),b=o(b),a.times(b)},m.divide=function(a,b){return a=o(a),b=o(b),a.divide(b)},m.approx=function(a,b){return a=+a,b=+b,a===b?!0:0==a?Math.abs(b)<d:0==b?Math.abs(a)<d:Math.abs(a-b)<Math.abs(a)*d};var p=1;m._inc=function(){return p++},m.parseJSON=function(a){return JSON.parse(a,function(a,b){if("object"!=typeof b||"string"!=typeof b._t)return b;var c=b._t,d=e[c];if(c&&d){var g=f(d,"fromJSON");if(g)return g(b,d)}return b})},"function"==typeof define&&define.amd?define(m):"object"==typeof module&&module.exports?module.exports=m:a.c=m}(this),function(a){"use strict";if(a._functionalMap)a.HashTable=a.inherit({initialize:function(b){this.hashCode=a._inc(),this._store=b instanceof a.HashTable?new Map(b._store):new Map},clone:function(){return new a.HashTable(this)},get:function(a){var b=this._store.get(a.hashCode);return void 0===b?null:b[1]},clear:function(){this._store.clear()},get size(){return this._store.size},set:function(a,b){return this._store.set(a.hashCode,[a,b])},has:function(a){return this._store.has(a.hashCode)},"delete":function(a){return this._store.delete(a.hashCode)},each:function(a,b){this._store.forEach(function(c){return a.call(b||null,c[0],c[1])},b)},escapingEach:function(a,b){if(this._store.size)for(var c,e,f=this._store.values(),e=f.next();!e.done;){if(c=a.call(b||null,e.value[0],e.value[1])){if(void 0!==c.retval)return c;if(c.brk)break}e=f.next()}},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c in this._store.keys())if(void 0==b._store.get(c))return!1;return!0}});else{var b={},c=function(a,b){Object.keys(a).forEach(function(c){b[c]=a[c]})};a.HashTable=a.inherit({initialize:function(){this.size=0,this._store={},this._deleted=0},set:function(a,b){var c=a.hashCode;"undefined"==typeof this._store[c]&&this.size++,this._store[c]=[a,b]},get:function(a){if(!this.size)return null;a=a.hashCode;var b=this._store[a];return"undefined"!=typeof b?b[1]:null},clear:function(){this.size=0,this._store={}},_compact:function(){var a={};c(this._store,a),this._store=a},_compactThreshold:100,_perhapsCompact:function(){this._size>30||this._deleted>this._compactThreshold&&(this._compact(),this._deleted=0)},"delete":function(a){a=a.hashCode,this._store.hasOwnProperty(a)&&(this._deleted++,delete this._store[a],this.size>0&&this.size--)},each:function(a,b){if(this.size){this._perhapsCompact();var c=this._store;for(var d in this._store)this._store.hasOwnProperty(d)&&a.call(b||null,c[d][0],c[d][1])}},escapingEach:function(a,c){if(this.size){this._perhapsCompact();for(var d=this,e=this._store,f=b,g=Object.keys(e),h=0;h<g.length;h++)if(function(b){d._store.hasOwnProperty(b)&&(f=a.call(c||null,e[b][0],e[b][1]))}(g[h]),f){if(void 0!==f.retval)return f;if(f.brk)break}}},clone:function(){var b=new a.HashTable;return this.size&&(b.size=this.size,c(this._store,b._store)),b},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c=Object.keys(this._store),d=0;d<c.length;d++){var e=c[d];if(this._store[e][0]!==b._store[e][0])return!1}return!0},toString:function(){var b="";return this.each(function(a,c){b+=a+" => "+c+"\n"}),b},toJSON:function(){return{_t:"c.HashTable"}},fromJSON:function(){var c=new a.HashTable;return c}})}}(this.c||module.parent.exports||{}),function(a){"use strict";a.HashSet=a._functionalMap?a.inherit({_t:"c.HashSet",initialize:function(b){this.hashCode=a._inc(),this._store=b instanceof a.HashSet?new Map(b._store):new Map},add:function(a){return this._store.set(a.hashCode,a)},has:function(a){return this._store.has(a.hashCode)},get size(){return this._store.size},clear:function(){this._store.clear()},values:function(){for(var a=[],b=this._store.values(),c=b.next();!c.done;)a.push(c.value),c=b.next();return a},first:function(){var a=this._store.values(),b=a.next();return b.done?null:b.value},"delete":function(a){this._store.delete(a.hashCode)},each:function(a,b){var c=this;this._store.forEach(function(d){return a.call(b||null,d,d,c)},b)},escapingEach:function(a,b){this.size&&this._store.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a[a.length]=b.toJSON()}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c._store=b.data),c}}):a.inherit({_t:"c.HashSet",initialize:function(){this._store=[],this.size=0,this.hashCode=a._inc()},add:function(a){var b=this._store;b.indexOf(a),-1==b.indexOf(a)&&(b[b.length]=a),this.size=b.length},values:function(){return this._store},first:function(){return this._store[0]},has:function(a){return-1!=this._store.indexOf(a)},"delete":function(a){var b=this._store.indexOf(a);return-1==b?null:(this._store.splice(b,1)[0],this.size=this._store.length,void 0)},clear:function(){this._store.length=0},each:function(a,b){this.size&&this._store.forEach(a,b)},escapingEach:function(a,b){this.size&&this._store.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a[a.length]=b.toJSON()}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c._store=b.data),c}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Error=a.inherit({initialize:function(a){a&&(this._description=a)},_name:"c.Error",_description:"An error has occured in Cassowary",set description(a){this._description=a},get description(){return"("+this._name+") "+this._description},get message(){return this.description},toString:function(){return this.description}});var b=function(b,c){return a.inherit({"extends":a.Error,initialize:function(){a.Error.apply(this,arguments)},_name:b||"",_description:c||""})};a.ConstraintNotFound=b("c.ConstraintNotFound","Tried to remove a constraint never added to the tableu"),a.InternalError=b("c.InternalError"),a.NonExpression=b("c.NonExpression","The resulting expression would be non"),a.NotEnoughStays=b("c.NotEnoughStays","There are not enough stays to give specific values to every variable"),a.RequiredFailure=b("c.RequiredFailure","A required constraint cannot be satisfied"),a.TooDifficult=b("c.TooDifficult","The constraints are too difficult to solve")}(this.c||module.parent.exports||{}),function(a){"use strict";var b=1e3;a.SymbolicWeight=a.inherit({_t:"c.SymbolicWeight",initialize:function(){this.value=0;for(var a=1,c=arguments.length-1;c>=0;--c)this.value+=arguments[c]*a,a*=b},toJSON:function(){return{_t:this._t,value:this.value}}})}(this.c||module.parent.exports||{}),function(a){a.Strength=a.inherit({initialize:function(b,c,d,e){this.name=b,this.symbolicWeight=c instanceof a.SymbolicWeight?c:new a.SymbolicWeight(c,d,e)},get required(){return this===a.Strength.required},toString:function(){return this.name+(this.required?"":":"+this.symbolicWeight)}}),a.Strength.required=new a.Strength("<Required>",1e3,1e3,1e3),a.Strength.strong=new a.Strength("strong",1,0,0),a.Strength.medium=new a.Strength("medium",0,1,0),a.Strength.weak=new a.Strength("weak",0,0,1)}(this.c||("undefined"!=typeof module?module.parent.exports.c:{})),function(a){"use strict";a.AbstractVariable=a.inherit({isDummy:!1,isExternal:!1,isPivotable:!1,isRestricted:!1,_init:function(b,c){this.hashCode=a._inc(),this.name=(c||"")+this.hashCode,b&&("undefined"!=typeof b.name&&(this.name=b.name),"undefined"!=typeof b.value&&(this.value=b.value),"undefined"!=typeof b.prefix&&(this._prefix=b.prefix))},_prefix:"",name:"",value:0,valueOf:function(){return this.value},toJSON:function(){var a={};return this._t&&(a._t=this._t),this.name&&(a.name=this.name),"undefined"!=typeof this.value&&(a.value=this.value),this._prefix&&(a._prefix=this._prefix),this._t&&(a._t=this._t),a},fromJSON:function(b,c){var d=new c;return a.extend(d,b),d},toString:function(){return this._prefix+"["+this.name+":"+this.value+"]"}}),a.Variable=a.inherit({_t:"c.Variable","extends":a.AbstractVariable,initialize:function(b){this._init(b,"v");var c=a.Variable._map;c&&(c[this.name]=this)},isExternal:!0}),a.DummyVariable=a.inherit({_t:"c.DummyVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"d")},isDummy:!0,isRestricted:!0,value:"dummy"}),a.ObjectiveVariable=a.inherit({_t:"c.ObjectiveVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"o")},value:"obj"}),a.SlackVariable=a.inherit({_t:"c.SlackVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"s")},isPivotable:!0,isRestricted:!0,value:"slack"})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Point=a.inherit({initialize:function(b,c,d){if(b instanceof a.Variable)this._x=b;else{var e={value:b};d&&(e.name="x"+d),this._x=new a.Variable(e)}if(c instanceof a.Variable)this._y=c;else{var f={value:c};d&&(f.name="y"+d),this._y=new a.Variable(f)}},get x(){return this._x},set x(b){b instanceof a.Variable?this._x=b:this._x.value=b},get y(){return this._y},set y(b){b instanceof a.Variable?this._y=b:this._y.value=b},toString:function(){return"("+this.x+", "+this.y+")"}})}(this.c||module.parent.exports||{}),function(a){"use strict";var b=function(a,b){return"number"==typeof a?a:b};a.Expression=a.inherit({initialize:function(c,d,e){this.constant=b(e,0),this.terms=new a.HashTable,this.externalVariables=new a.HashSet,Object.defineProperty(this,"solver",{enumerable:!1,configurable:!0,writable:!0,value:null}),c instanceof a.AbstractVariable?(d=b(d,1),this.setVariable(c,d)):"number"==typeof c&&(isNaN(c)?console.trace():this.constant=c)},initializeFromHash:function(a,b){return this.constant=a,this.terms=b.clone(),this},multiplyMe:function(a){this.constant*=a;var b=this.terms;return b.each(function(c,d){b.set(c,d*a)}),this},clone:function(){var b=a.Expression.empty();return b.initializeFromHash(this.constant,this.terms),b.solver=this.solver,b},times:function(b){if("number"==typeof b)return this.clone().multiplyMe(b);if(this.isConstant)return b.times(this.constant);if(b.isConstant)return this.times(b.constant);throw new a.NonExpression},plus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,1):b instanceof a.Variable?this.clone().addVariable(b,1):void 0},minus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,-1):b instanceof a.Variable?this.clone().addVariable(b,-1):void 0},divide:function(b){if("number"==typeof b){if(a.approx(b,0))throw new a.NonExpression;return this.times(1/b)}if(b instanceof a.Expression){if(!b.isConstant)throw new a.NonExpression;return this.times(1/b.constant)}},addExpression:function(c,d,e){return c instanceof a.AbstractVariable&&(c=a.Expression.fromVariable(c)),d=b(d,1),this.constant+=d*c.constant,c.terms.each(function(a,b){this.addVariable(a,b*d,e),this._updateIfExternal(a)},this),this},addVariable:function(b,c,d){null==c&&(c=1);var e=this.terms.get(b);if(e){var f=e+c;0==f||a.approx(f,0)?(this.solver&&this.solver.noteRemovedVariable(b,d),this.terms.delete(b)):this.setVariable(b,f)}else a.approx(c,0)||(this.setVariable(b,c),this.solver&&this.solver.noteAddedVariable(b,d));return this},_updateIfExternal:function(a){a.isExternal&&(this.externalVariables.add(a),this.solver&&this.solver._noteUpdatedExternal(a))},setVariable:function(a,b){return this.terms.set(a,b),this._updateIfExternal(a),this},anyPivotableVariable:function(){if(this.isConstant)throw new a.InternalError("anyPivotableVariable called on a constant");var b=this.terms.escapingEach(function(a){return a.isPivotable?{retval:a}:void 0});return b&&void 0!==b.retval?b.retval:null},substituteOut:function(b,c,d){var e=this.solver;if(!e)throw new a.InternalError("Expressions::substituteOut called without a solver");var f=this.setVariable.bind(this),g=this.terms,h=g.get(b);g.delete(b),this.constant+=h*c.constant,c.terms.each(function(b,c){var i=g.get(b);if(i){var j=i+h*c;a.approx(j,0)?(e.noteRemovedVariable(b,d),g.delete(b)):f(b,j)}else f(b,h*c),e&&e.noteAddedVariable(b,d)})},changeSubject:function(a,b){this.setVariable(a,this.newSubject(b))},newSubject:function(a){var b=1/this.terms.get(a);return this.terms.delete(a),this.multiplyMe(-b),b},coefficientFor:function(a){return this.terms.get(a)||0},get isConstant(){return 0==this.terms.size},toString:function(){var b="",c=!1;if(!a.approx(this.constant,0)||this.isConstant){if(b+=this.constant,this.isConstant)return b;c=!0}return this.terms.each(function(a,d){c&&(b+=" + "),b+=d+"*"+a,c=!0}),b},equals:function(b){return b===this?!0:b instanceof a.Expression&&b.constant===this.constant&&b.terms.equals(this.terms)},Plus:function(a,b){return a.plus(b)},Minus:function(a,b){return a.minus(b)},Times:function(a,b){return a.times(b)},Divide:function(a,b){return a.divide(b)}}),a.Expression.empty=function(b){var c=new a.Expression(void 0,1,0);return c.solver=b,c},a.Expression.fromConstant=function(b,c){var d=new a.Expression(b);return d.solver=c,d},a.Expression.fromValue=function(b,c){b=+b;var d=new a.Expression(void 0,b,0);return d.solver=c,d},a.Expression.fromVariable=function(b,c){var d=new a.Expression(b,1,0);return d.solver=c,d}}(this.c||module.parent.exports||{}),function(a){"use strict";a.AbstractConstraint=a.inherit({initialize:function(b,c){this.hashCode=a._inc(),this.strength=b||a.Strength.required,this.weight=c||1},isEdit:!1,isInequality:!1,isStay:!1,get required(){return this.strength===a.Strength.required},toString:function(){return this.strength+" {"+this.weight+"} ("+this.expression+")"}});var b=a.AbstractConstraint.prototype.toString,c=function(b,c,d){a.AbstractConstraint.call(this,c||a.Strength.strong,d),this.variable=b,this.expression=new a.Expression(b,-1,b.value)};a.EditConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isEdit:!0,toString:function(){return"edit:"+b.call(this)}}),a.StayConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isStay:!0,toString:function(){return"stay:"+b.call(this)}});var d=a.Constraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(b,c,d){a.AbstractConstraint.call(this,c,d),this.expression=b}});a.Inequality=a.inherit({"extends":a.Constraint,_cloneOrNewCle:function(b){return b.clone?b.clone():new a.Expression(b)},initialize:function(b,c,e,f,g){var h=b instanceof a.Expression,i=e instanceof a.Expression,j=b instanceof a.AbstractVariable,k=e instanceof a.AbstractVariable,l="number"==typeof b,m="number"==typeof e;if((h||l)&&k){var n=b,o=c,p=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else if(j&&(i||m)){var n=e,o=c,p=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else{if(h&&m){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(l&&i){var s=e,o=c,t=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(h&&i){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(t),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(s));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(s),-1)}}else{if(h)return d.call(this,b,c,e);if(c==a.GEQ)d.call(this,new a.Expression(e),f,g),this.expression.multiplyMe(-1),this.expression.addVariable(b);else{if(c!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");d.call(this,new a.Expression(e),f,g),this.expression.addVariable(b,-1)}}}},isInequality:!0,toString:function(){return d.prototype.toString.call(this)+" >= 0) id: "+this.hashCode}}),a.Equation=a.inherit({"extends":a.Constraint,initialize:function(b,c,e,f){if(b instanceof a.Expression&&!c||c instanceof a.Strength)d.call(this,b,c,e);else if(b instanceof a.AbstractVariable&&c instanceof a.Expression){var g=b,h=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.AbstractVariable&&"number"==typeof c){var g=b,k=c,i=e,j=f;d.call(this,new a.Expression(k),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.Expression&&c instanceof a.AbstractVariable){var h=b,g=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else{if(!(b instanceof a.Expression||b instanceof a.AbstractVariable||"number"==typeof b)||!(c instanceof a.Expression||c instanceof a.AbstractVariable||"number"==typeof c))throw"Bad initializer to c.Equation";b=b instanceof a.Expression?b.clone():new a.Expression(b),c=c instanceof a.Expression?c.clone():new a.Expression(c),d.call(this,b,e,f),this.expression.addExpression(c,-1)}a.assert(this.strength instanceof a.Strength,"_strength not set")},toString:function(){return d.prototype.toString.call(this)+" = 0)"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.EditInfo=a.inherit({initialize:function(a,b,c,d,e){this.constraint=a,this.editPlus=b,this.editMinus=c,this.prevEditConstant=d,this.index=e},toString:function(){return"<cn="+this.constraint+", ep="+this.editPlus+", em="+this.editMinus+", pec="+this.prevEditConstant+", index="+this.index+">"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Tableau=a.inherit({initialize:function(){this.columns=new a.HashTable,this.rows=new a.HashTable,this._infeasibleRows=new a.HashSet,this._externalRows=new a.HashTable},noteRemovedVariable:function(a,b){var c=this.columns.get(a);b&&c&&c.delete(b)},noteAddedVariable:function(a,b){b&&this.insertColVar(a,b)},getInternalInfo:function(){return"Tableau Information:\nRows: "+this.rows.size+" (= "+(this.rows.size-1)+" constraints)"+"\nColumns: "+this.columns.size+"\nInfeasible Rows: "+this._infeasibleRows.size+"\nExternal basic variables: "+this._externalRows.size},toString:function(){var a="Tableau:\n";return this.rows.each(function(b,c){a+=b+" <==> "+c+"\n"}),a+="\nColumns:\n",a+=this.columns,a+="\nInfeasible rows: ",a+=this._infeasibleRows,a+="External basic variables: ",a+=this._externalRows},insertColVar:function(b,c){var d=this.columns.get(b);d||(d=new a.HashSet,this.columns.set(b,d)),d.add(c)},addRow:function(a,b){this.rows.set(a,b),b.terms.each(function(b){this.insertColVar(b,a)},this),a.isExternal&&this._externalRows.set(a,b)},removeColumn:function(a){var b=this.columns.get(a);b&&(this.columns.delete(a),b.each(function(b){var c=this.rows.get(b);c.terms.delete(a)},this)),a.isExternal&&this._externalRows.delete(a)},removeRow:function(b){var c=this.rows.get(b);return a.assert(null!=c),c.terms.each(function(a){var d=this.columns.get(a);null!=d&&d.delete(b)},this),this._infeasibleRows.delete(b),b.isExternal&&this._externalRows.delete(b),this.rows.delete(b),c},substituteOut:function(a,b){var c=this.columns.get(a);c.each(function(c){var d=this.rows.get(c);d.substituteOut(a,b,c,this),c.isExternal&&this._updatedExternals.add(c),c.isRestricted&&d.constant<0&&this._infeasibleRows.add(c)},this),a.isExternal&&this._externalRows.set(a,b),this.columns.delete(a)},columnsHasKey:function(a){return!!this.columns.get(a)}})}(this.c||module.parent.exports||{}),function(a){var b=a.Tableau,c=b.prototype,d=1e-8,e=a.Strength.weak,f={eplus:null,eminus:null,prevEConstant:null};a.SimplexSolver=a.inherit({"extends":a.Tableau,initialize:function(){a.Tableau.call(this),this._stayMinusErrorVars=[],this._stayPlusErrorVars=[],this._errorVars=new a.HashTable,this._markerVars=new a.HashTable,this._objective=new a.ObjectiveVariable({name:"Z"}),this._editVarMap=new a.HashTable,this._editVarList=[],this._slackCounter=0,this._artificialCounter=0,this._dummyCounter=0,this.autoSolve=!0,this._needsSolving=!1,this._optimizeCount=0,this.rows.set(this._objective,a.Expression.empty(this)),this._editVariableStack=[0],this._updatedExternals=new a.HashSet},_noteUpdatedExternal:function(a){this._updatedExternals.add(a)},add:function(){for(var a=0;a<arguments.length;a++)this.addConstraint(arguments[a]);return this},addEditVar:function(b,c,d){var e=new a.EditConstraint(b,c||a.Strength.strong,d);return this.addEditConstraint(e),this},addEditConstraint:function(a){var b=f;return this.addConstraint(a),this._addEditConstraint(a,b.eplus,b.eminus,b.prevEConstant),this},_addEditConstraint:function(b,c,d,e){var f=this._editVarMap.size,g=new a.EditInfo(b,c,d,e,f);this._editVarMap.set(b.variable,g),this._editVarList[f]={v:b.variable,info:g}},addConstraint:function(b){if(b instanceof a.Constraint){var c=this;b.expression.externalVariables.each(function(a){c._noteUpdatedExternal(a)})}var d=this.newExpression(b);return d.solver=this,this.tryAddingDirectly(d)||this.addWithArtificialVariable(d),this._needsSolving=!0,this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},addConstraintNoException:function(a){try{return this.addConstraint(a),!0}catch(b){return console.error(b),!1}},beginEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this._infeasibleRows.clear(),this._resetStayConstants(),this._editVariableStack[this._editVariableStack.length]=this._editVarMap.size,this},endEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this.resolve(),this._editVariableStack.pop(),this.removeEditVarsTo(this._editVariableStack[this._editVariableStack.length-1]),this},removeAllEditVars:function(){return this.removeEditVarsTo(0)},removeEditVarsTo:function(b){try{for(var c=this._editVarList.length,d=b;c>d;d++)this._editVarList[d]&&this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);return this._editVarList.length=b,a.assert(this._editVarMap.size==b,"_editVarMap.size == n"),this}catch(e){throw new a.InternalError("Constraint not found in removeEditVarsTo")}},addPointStays:function(a){return a.forEach(function(a,b){this.addStay(a.x,e,Math.pow(2,b)),this.addStay(a.y,e,Math.pow(2,b))},this),this},addStay:function(b,c,d){var f=new a.StayConstraint(b,c||e,d||1);return this.addConstraint(f)},setConstant:function(a,b){this._setConstant(a,b),this.resolve()},removeConstraint:function(b){this._needsSolving=!0,this._resetStayConstants();var c=this.rows.get(this._objective),d=this._errorVars.get(b);null!=d&&d.each(function(a){var d=this.rows.get(a);null==d?c.addVariable(a,-b.weight*b.strength.symbolicWeight.value,this._objective,this):c.addExpression(d,-b.weight*b.strength.symbolicWeight.value,this._objective,this)},this);var e=this._markerVars.get(b);if(this._markerVars.delete(b),null==e)throw new a.InternalError("Constraint not found in removeConstraintInternal");if(null==this.rows.get(e)){var f=this.columns.get(e),g=null,h=0;f.each(function(b){if(b.isRestricted){var c=this.rows.get(b),d=c.coefficientFor(e);if(0>d){var f=-c.constant/d;(null==g||h>f||a.approx(f,h)&&b.hashCode<g.hashCode)&&(h=f,g=b)}}},this),null==g&&f.each(function(a){if(a.isRestricted){var b=this.rows.get(a),c=b.coefficientFor(e),d=b.constant/c;(null==g||h>d)&&(h=d,g=a)}},this),null==g&&(0==f.size?this.removeColumn(e):f.escapingEach(function(a){return a!=this._objective?(g=a,{brk:!0}):void 0},this)),null!=g&&this.pivot(e,g)}if(null!=this.rows.get(e)&&this.removeRow(e),null!=d&&d.each(function(a){a!=e&&this.removeColumn(a)},this),b.isStay){if(null!=d)for(var j=0;j<this._stayPlusErrorVars.length;j++)d.delete(this._stayPlusErrorVars[j]),d.delete(this._stayMinusErrorVars[j])}else if(b.isEdit){var k=this._editVarMap.get(b.variable);this.removeColumn(k.editMinus),this._editVarMap.delete(b.variable)}return null!=d&&this._errorVars.delete(d),this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},reset:function(){throw new a.InternalError("reset not implemented")},resolveArray:function(a){var b=a.length;this._editVarMap.each(function(c,d){var e=d.index;b>e&&this.suggestValue(c,a[e])},this),this.resolve()},resolvePair:function(a,b){this.suggestValue(this._editVarList[0].v,a),this.suggestValue(this._editVarList[1].v,b),this.resolve()},resolve:function(){this.dualOptimize(),this._setExternalVariables(),this._infeasibleRows.clear(),this._resetStayConstants()},suggestValue:function(b,c){var d=this._editVarMap.get(b);if(!d)throw new a.Error("suggestValue for variable "+b+", but var is not an edit variable");var e=c-d.prevEditConstant;return d.prevEditConstant=c,this.deltaEditConstant(e,d.editPlus,d.editMinus),this},solve:function(){return this._needsSolving&&(this.optimize(this._objective),this._setExternalVariables()),this},setEditedValue:function(b,c){if(!this.columnsHasKey(b)&&null==this.rows.get(b))return b.value=c,this;if(!a.approx(c,b.value)){this.addEditVar(b),this.beginEdit();try{this.suggestValue(b,c)}catch(d){throw new a.InternalError("Error in setEditedValue")}this.endEdit()}return this},addVar:function(b){if(!this.columnsHasKey(b)&&null==this.rows.get(b))try{this.addStay(b)}catch(c){throw new a.InternalError("Error in addVar -- required failure is impossible")}return this},getInternalInfo:function(){var a=c.getInternalInfo.call(this);return a+="\nSolver info:\n",a+="Stay Error Variables: ",a+=this._stayPlusErrorVars.length+this._stayMinusErrorVars.length,a+=" ("+this._stayPlusErrorVars.length+" +, ",a+=this._stayMinusErrorVars.length+" -)\n",a+="Edit Variables: "+this._editVarMap.size,a+="\n"},getDebugInfo:function(){return this.toString()+this.getInternalInfo()+"\n"},toString:function(){var a=c.getInternalInfo.call(this);return a+="\n_stayPlusErrorVars: ",a+="["+this._stayPlusErrorVars+"]",a+="\n_stayMinusErrorVars: ",a+="["+this._stayMinusErrorVars+"]",a+="\n",a+="_editVarMap:\n"+this._editVarMap,a+="\n"},addWithArtificialVariable:function(b){var c=new a.SlackVariable({value:++this._artificialCounter,prefix:"a"}),d=new a.ObjectiveVariable({name:"az"}),e=b.clone();this.addRow(d,e),this.addRow(c,b),this.optimize(d);var f=this.rows.get(d);if(!a.approx(f.constant,0))throw this.removeRow(d),this.removeColumn(c),new a.RequiredFailure;var g=this.rows.get(c);if(null!=g){if(g.isConstant)return this.removeRow(c),this.removeRow(d),void 0;var h=g.anyPivotableVariable();this.pivot(h,c)}a.assert(null==this.rows.get(c),"rowExpression(av) == null"),this.removeColumn(c),this.removeRow(d)},tryAddingDirectly:function(a){var b=this.chooseSubject(a);return null==b?!1:(a.newSubject(b),this.columnsHasKey(b)&&this.substituteOut(b,a),this.addRow(b,a),!0)},chooseSubject:function(b){var c=null,d=!1,e=!1,f=b.terms,g=f.escapingEach(function(a,b){if(d){if(!a.isRestricted&&!this.columnsHasKey(a))return{retval:a}}else if(a.isRestricted){if(!e&&!a.isDummy&&0>b){var f=this.columns.get(a);(null==f||1==f.size&&this.columnsHasKey(this._objective))&&(c=a,e=!0)}}else c=a,d=!0},this);if(g&&void 0!==g.retval)return g.retval;if(null!=c)return c;var h=0,g=f.escapingEach(function(a,b){return a.isDummy?(this.columnsHasKey(a)||(c=a,h=b),void 0):{retval:null}},this);if(g&&void 0!==g.retval)return g.retval;if(!a.approx(b.constant,0))throw new a.RequiredFailure;return h>0&&b.multiplyMe(-1),c},deltaEditConstant:function(a,b,c){var d=this.rows.get(b);if(null!=d)return d.constant+=a,d.constant<0&&this._infeasibleRows.add(b),void 0;var e=this.rows.get(c);if(null!=e)return e.constant+=-a,e.constant<0&&this._infeasibleRows.add(c),void 0;var f=this.columns.get(c);f||console.log("columnVars is null -- tableau is:\n"+this),f.each(function(b){var d=this.rows.get(b),e=d.coefficientFor(c);d.constant+=e*a,b.isExternal&&this._noteUpdatedExternal(b),b.isRestricted&&d.constant<0&&this._infeasibleRows.add(b)},this)},dualOptimize:function(){for(var b=this.rows.get(this._objective);this._infeasibleRows.size;){var c=this._infeasibleRows.first();this._infeasibleRows.delete(c);var d=null,e=this.rows.get(c);if(e&&e.constant<0){var g,f=Number.MAX_VALUE,h=e.terms;if(h.each(function(c,e){if(e>0&&c.isPivotable){var h=b.coefficientFor(c);g=h/e,(f>g||a.approx(g,f)&&c.hashCode<d.hashCode)&&(d=c,f=g)}}),f==Number.MAX_VALUE)throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");this.pivot(d,c)}}},newExpression:function(b){var c=f;c.eplus=null,c.eminus=null,c.prevEConstant=null;var d=b.expression,e=a.Expression.fromConstant(d.constant,this),g=new a.SlackVariable,h=new a.DummyVariable,i=new a.SlackVariable,j=new a.SlackVariable,k=d.terms;if(k.each(function(a,b){var c=this.rows.get(a);c?e.addExpression(c,b):e.addVariable(a,b)},this),b.isInequality){if(++this._slackCounter,g=new a.SlackVariable({value:this._slackCounter,prefix:"s"}),e.setVariable(g,-1),this._markerVars.set(b,g),!b.required){++this._slackCounter,i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),e.setVariable(i,1);var l=this.rows.get(this._objective);l.setVariable(i,b.strength.symbolicWeight.value*b.weight),this.insertErrorVar(b,i),this.noteAddedVariable(i,this._objective)}}else if(b.required)++this._dummyCounter,h=new a.DummyVariable({value:this._dummyCounter,prefix:"d"}),c.eplus=h,c.eminus=h,c.prevEConstant=d.constant,e.setVariable(h,1),this._markerVars.set(b,h);else{++this._slackCounter,j=new a.SlackVariable({value:this._slackCounter,prefix:"ep"}),i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),e.setVariable(j,-1),e.setVariable(i,1),this._markerVars.set(b,j);
var l=this.rows.get(this._objective),m=b.strength.symbolicWeight.value*b.weight;l.setVariable(j,m),this.noteAddedVariable(j,this._objective),l.setVariable(i,m),this.noteAddedVariable(i,this._objective),this.insertErrorVar(b,i),this.insertErrorVar(b,j),b.isStay?(this._stayPlusErrorVars[this._stayPlusErrorVars.length]=j,this._stayMinusErrorVars[this._stayMinusErrorVars.length]=i):b.isEdit&&(c.eplus=j,c.eminus=i,c.prevEConstant=d.constant)}return e.constant<0&&e.multiplyMe(-1),e},optimize:function(b){this._optimizeCount++;var c=this.rows.get(b);a.assert(null!=c,"zRow != null");for(var g,h,e=null,f=null;;){if(g=0,h=c.terms,h.escapingEach(function(a,b){return a.isPivotable&&g>b?(g=b,e=a,{brk:1}):void 0},this),g>=-d)return;var i=Number.MAX_VALUE,j=this.columns.get(e),k=0;if(j.each(function(b){if(b.isPivotable){var c=this.rows.get(b),d=c.coefficientFor(e);0>d&&(k=-c.constant/d,(i>k||a.approx(k,i)&&b.hashCode<f.hashCode)&&(i=k,f=b))}},this),i==Number.MAX_VALUE)throw new a.InternalError("Objective function is unbounded in optimize");this.pivot(e,f)}},pivot:function(a,b){var c=!1;c&&console.time(" SimplexSolver::pivot"),null==a&&console.warn("pivot: entryVar == null"),null==b&&console.warn("pivot: exitVar == null"),c&&console.time("  removeRow");var d=this.removeRow(b);c&&console.timeEnd("  removeRow"),c&&console.time("  changeSubject"),d.changeSubject(b,a),c&&console.timeEnd("  changeSubject"),c&&console.time("  substituteOut"),this.substituteOut(a,d),c&&console.timeEnd("  substituteOut"),c&&console.time("  addRow"),this.addRow(a,d),c&&console.timeEnd("  addRow"),c&&console.timeEnd(" SimplexSolver::pivot")},_resetStayConstants:function(){for(var a=this._stayPlusErrorVars,b=a.length,c=0;b>c;c++){var d=this.rows.get(a[c]);null===d&&(d=this.rows.get(this._stayMinusErrorVars[c])),null!=d&&(d.constant=0)}},_setExternalVariables:function(){var a=[];this._updatedExternals.each(function(b){var c=b.value,d=this._externalRows.get(b);return d?(b.value=d.constant,c!==b.value&&a.push({type:"update",name:b.name,variable:b,oldValue:c}),void 0):(b.value=0,void 0)},this),this._updatedExternals.clear(),this._needsSolving=!1,this._informCallbacks(a),a.length&&this.onsolved(a)},onsolved:function(){},_informCallbacks:function(a){this._callbacks&&this._callbacks.forEach(function(b){b(a)})},_addCallback:function(a){var b=this._callbacks||(this._callbacks=[]);b[b.length]=a},insertErrorVar:function(b,c){var d=this._errorVars.get(b);d||(d=new a.HashSet,this._errorVars.set(b,d)),d.add(c)}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Timer=a.inherit({initialize:function(){this.isRunning=!1,this._elapsedMs=0},start:function(){return this.isRunning=!0,this._startReading=new Date,this},stop:function(){return this.isRunning=!1,this._elapsedMs+=new Date-this._startReading,this},reset:function(){return this.isRunning=!1,this._elapsedMs=0,this},elapsedTime:function(){return this.isRunning?(this._elapsedMs+(new Date-this._startReading))/1e3:this._elapsedMs/1e3}})}(this.c||module.parent.exports||{}),this.c.parser=function(){function a(a){return'"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,escape)+'"'}var b={parse:function(b,c){function k(a){g>e||(e>g&&(g=e,h=[]),h.push(a))}function l(){var a,b,c,d,f;if(d=e,f=e,a=A(),null!==a){for(b=[],c=m();null!==c;)b.push(c),c=m();null!==b?(c=A(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)}else a=null,e=f;return null!==a&&(a=function(a,b){return b}(d,a[1])),null===a&&(e=d),a}function m(){var a,b,c,d;return c=e,d=e,a=Q(),null!==a?(b=t(),null!==b?a=[a,b]:(a=null,e=d)):(a=null,e=d),null!==a&&(a=function(a,b){return b}(c,a[0])),null===a&&(e=c),a}function n(){var a;return b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),a}function o(){var a;return/^[a-zA-Z]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[a-zA-Z]")),null===a&&(36===b.charCodeAt(e)?(a="$",e++):(a=null,0===f&&k('"$"')),null===a&&(95===b.charCodeAt(e)?(a="_",e++):(a=null,0===f&&k('"_"')))),a}function p(){var a;return a=o(),null===a&&(/^[0-9]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[0-9]"))),a}function q(){var a;return f++,/^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\t\\x0B\\f \\xA0\\uFEFF]")),f--,0===f&&null===a&&k("whitespace"),a}function r(){var a;return/^[\n\r\u2028\u2029]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\n\\r\\u2028\\u2029]")),a}function s(){var a;return f++,10===b.charCodeAt(e)?(a="\n",e++):(a=null,0===f&&k('"\\n"')),null===a&&("\r\n"===b.substr(e,2)?(a="\r\n",e+=2):(a=null,0===f&&k('"\\r\\n"')),null===a&&(13===b.charCodeAt(e)?(a="\r",e++):(a=null,0===f&&k('"\\r"')),null===a&&(8232===b.charCodeAt(e)?(a="\u2028",e++):(a=null,0===f&&k('"\\u2028"')),null===a&&(8233===b.charCodeAt(e)?(a="\u2029",e++):(a=null,0===f&&k('"\\u2029"')))))),f--,0===f&&null===a&&k("end of line"),a}function t(){var a,c,d;return d=e,a=A(),null!==a?(59===b.charCodeAt(e)?(c=";",e++):(c=null,0===f&&k('";"')),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=z(),null!==a?(c=s(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=A(),null!==a?(c=u(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d))),a}function u(){var a,c;return c=e,f++,b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),f--,null===a?a="":(a=null,e=c),a}function v(){var a;return f++,a=w(),null===a&&(a=y()),f--,0===f&&null===a&&k("comment"),a}function w(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function x(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=r()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=r()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function y(){var a,c,d,g,h,i,j;if(h=e,"//"===b.substr(e,2)?(a="//",e+=2):(a=null,0===f&&k('"//"')),null!==a){for(c=[],i=e,j=e,f++,d=r(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,d=r(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?(d=r(),null===d&&(d=u()),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function z(){var a,b;for(a=[],b=q(),null===b&&(b=x(),null===b&&(b=y()));null!==b;)a.push(b),b=q(),null===b&&(b=x(),null===b&&(b=y()));return a}function A(){var a,b;for(a=[],b=q(),null===b&&(b=s(),null===b&&(b=v()));null!==b;)a.push(b),b=q(),null===b&&(b=s(),null===b&&(b=v()));return a}function B(){var a,b;return b=e,a=D(),null===a&&(a=C()),null!==a&&(a=function(a,b){return{type:"NumericLiteral",value:b}}(b,a)),null===a&&(e=b),a}function C(){var a,c,d;if(d=e,/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]")),null!==c)for(a=[];null!==c;)a.push(c),/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]"));else a=null;return null!==a&&(a=function(a,b){return parseInt(b.join(""))}(d,a)),null===a&&(e=d),a}function D(){var a,c,d,g,h;return g=e,h=e,a=C(),null!==a?(46===b.charCodeAt(e)?(c=".",e++):(c=null,0===f&&k('"."')),null!==c?(d=C(),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)):(a=null,e=h),null!==a&&(a=function(a,b){return parseFloat(b.join(""))}(g,a)),null===a&&(e=g),a}function E(){var a,c,d,g;if(g=e,/^[\-+]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\-+]")),a=null!==a?a:"",null!==a){if(/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]")),null!==d)for(c=[];null!==d;)c.push(d),/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]"));else c=null;null!==c?a=[a,c]:(a=null,e=g)}else a=null,e=g;return a}function F(){var a,b;return f++,b=e,a=G(),null!==a&&(a=function(a,b){return b}(b,a)),null===a&&(e=b),f--,0===f&&null===a&&k("identifier"),a}function G(){var a,b,c,d,g;if(f++,d=e,g=e,a=o(),null!==a){for(b=[],c=p();null!==c;)b.push(c),c=p();null!==b?a=[a,b]:(a=null,e=g)}else a=null,e=g;return null!==a&&(a=function(a,b,c){return b+c.join("")}(d,a[0],a[1])),null===a&&(e=d),f--,0===f&&null===a&&k("identifier"),a}function H(){var a,c,d,g,h,i,j;return i=e,a=F(),null!==a&&(a=function(a,b){return{type:"Variable",name:b}}(i,a)),null===a&&(e=i),null===a&&(a=B(),null===a&&(i=e,j=e,40===b.charCodeAt(e)?(a="(",e++):(a=null,0===f&&k('"("')),null!==a?(c=A(),null!==c?(d=Q(),null!==d?(g=A(),null!==g?(41===b.charCodeAt(e)?(h=")",e++):(h=null,0===f&&k('")"')),null!==h?a=[a,c,d,g,h]:(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j),null!==a&&(a=function(a,b){return b}(i,a[2])),null===a&&(e=i))),a}function I(){var a,b,c,d,f;return a=H(),null===a&&(d=e,f=e,a=J(),null!==a?(b=A(),null!==b?(c=I(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)):(a=null,e=f),null!==a&&(a=function(a,b,c){return{type:"UnaryExpression",operator:b,expression:c}}(d,a[0],a[2])),null===a&&(e=d)),a}function J(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"')),null===a&&(33===b.charCodeAt(e)?(a="!",e++):(a=null,0===f&&k('"!"')))),a}function K(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=I(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=L(),null!==d?(f=A(),null!==f?(g=I(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=L(),null!==d?(f=A(),null!==f?(g=I(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"MultiplicativeExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function L(){var a;return 42===b.charCodeAt(e)?(a="*",e++):(a=null,0===f&&k('"*"')),null===a&&(47===b.charCodeAt(e)?(a="/",e++):(a=null,0===f&&k('"/"'))),a}function M(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=K(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=N(),null!==d?(f=A(),null!==f?(g=K(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=N(),null!==d?(f=A(),null!==f?(g=K(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"AdditiveExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function N(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"'))),a}function O(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=M(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=P(),null!==d?(f=A(),null!==f?(g=M(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=P(),null!==d?(f=A(),null!==f?(g=M(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"Inequality",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function P(){var a;return"<="===b.substr(e,2)?(a="<=",e+=2):(a=null,0===f&&k('"<="')),null===a&&(">="===b.substr(e,2)?(a=">=",e+=2):(a=null,0===f&&k('">="')),null===a&&(60===b.charCodeAt(e)?(a="<",e++):(a=null,0===f&&k('"<"')),null===a&&(62===b.charCodeAt(e)?(a=">",e++):(a=null,0===f&&k('">"'))))),a}function Q(){var a,c,d,g,h,i,j,l,m;if(j=e,l=e,a=O(),null!==a){for(c=[],m=e,d=A(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=A(),null!==h?(i=O(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==d;)c.push(d),m=e,d=A(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=A(),null!==h?(i=O(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==c?a=[a,c]:(a=null,e=l)}else a=null,e=l;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"Equality",operator:c[e][1],left:d,right:c[e][3]};return d}(j,a[0],a[1])),null===a&&(e=j),a}function R(a){a.sort();for(var b=null,c=[],d=0;d<a.length;d++)a[d]!==b&&(c.push(a[d]),b=a[d]);return c}function S(){for(var a=1,c=1,d=!1,f=0;f<Math.max(e,g);f++){var h=b.charAt(f);"\n"===h?(d||a++,c=1,d=!1):"\r"===h||"\u2028"===h||"\u2029"===h?(a++,c=1,d=!0):(c++,d=!1)}return{line:a,column:c}}var d={start:l,Statement:m,SourceCharacter:n,IdentifierStart:o,IdentifierPart:p,WhiteSpace:q,LineTerminator:r,LineTerminatorSequence:s,EOS:t,EOF:u,Comment:v,MultiLineComment:w,MultiLineCommentNoLineTerminator:x,SingleLineComment:y,_:z,__:A,Literal:B,Integer:C,Real:D,SignedInteger:E,Identifier:F,IdentifierName:G,PrimaryExpression:H,UnaryExpression:I,UnaryOperator:J,MultiplicativeExpression:K,MultiplicativeOperator:L,AdditiveExpression:M,AdditiveOperator:N,InequalityExpression:O,InequalityOperator:P,LinearExpression:Q};if(void 0!==c){if(void 0===d[c])throw new Error("Invalid rule name: "+a(c)+".")}else c="start";var e=0,f=0,g=0,h=[],T=d[c]();if(null===T||e!==b.length){var U=Math.max(e,g),V=U<b.length?b.charAt(U):null,W=S();throw new this.SyntaxError(R(h),V,U,W.line,W.column)}return T},toSource:function(){return this._source}};return b.SyntaxError=function(b,c,d,e,f){function g(b,c){var d,e;switch(b.length){case 0:d="end of input";break;case 1:d=b[0];break;default:d=b.slice(0,b.length-1).join(", ")+" or "+b[b.length-1]}return e=c?a(c):"end of input","Expected "+d+" but "+e+" found."}this.name="SyntaxError",this.expected=b,this.found=c,this.message=g(b,c),this.offset=d,this.line=e,this.column=f},b.SyntaxError.prototype=Error.prototype,b}(),function(a){"use strict";var b=new a.SimplexSolver,c={},d={},e=a.Strength.weak;a.Strength.medium,a.Strength.strong,a.Strength.required;var i=function(f){if(d[f])return d[f];switch(f.type){case"Inequality":var g="<="==f.operator?a.LEQ:a.GEQ,h=new a.Inequality(i(f.left),g,i(f.right),e);return b.addConstraint(h),h;case"Equality":var h=new a.Equation(i(f.left),i(f.right),e);return b.addConstraint(h),h;case"MultiplicativeExpression":var h=a.times(i(f.left),i(f.right));return b.addConstraint(h),h;case"AdditiveExpression":return"+"==f.operator?a.plus(i(f.left),i(f.right)):a.minus(i(f.left),i(f.right));case"NumericLiteral":return new a.Expression(f.value);case"Variable":return c[f.name]||(c[f.name]=new a.Variable({name:f.name})),c[f.name];case"UnaryExpression":console.log("UnaryExpression...WTF?")}},j=function(a){return a.map(i)};a._api=function(){var c=Array.prototype.slice.call(arguments);if(1==c.length){if("string"==typeof c[0]){var d=a.parser.parse(c[0]);return j(d)}"function"==typeof c[0]&&b._addCallback(c[0])}}}(this.c||module.parent.exports||{});
}).call(
  (typeof module != "undefined") ?
      (module.compiled = true && module) : this
);
};
BundleModuleCode['plugins/csp/constrained']=function (module,exports,global,process){
/* https://github.com/Wizcorp/constrained */
var _modules={};
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
})({
    1: [function(require, module, exports) {
        /**
         * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
         * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
         *
         * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
         *
         * This is a compiled version of Cassowary/JS. For source versions or to
         * contribute, see the github project:
         *
         *  https://github.com/slightlyoff/cassowary-js-refactor
         *
         */

        (function() {
            ! function(a) {
                "use strict";
                var b = "undefined" != typeof a.HTMLElement,
                    c = function(a) {
                        for (var b = null; a && a != Object.prototype;) {
                            if (a.tagName) {
                                b = a.tagName;
                                break
                            }
                            a = a.prototype
                        }
                        return b || "div"
                    },
                    d = 1e-8,
                    e = {},
                    f = function(a, b) {
                        if (a && b) {
                            if ("function" == typeof a[b]) return a[b];
                            var c = a.prototype;
                            if (c && "function" == typeof c[b]) return c[b];
                            if (c !== Object.prototype && c !== Function.prototype) return "function" == typeof a.__super__ ? f(a.__super__, b) : void 0
                        }
                    },
                    g = !1;
                try {
                    var h = new Map;
                    h.set("foo", "bar");
                    var i = h.values();
                    i.next(), h.forEach(function() {});
                    var k = new Map(h);
                    if (k.get("foo") != h.get("foo")) throw "ctor fail";
                    g = !0
                } catch (l) {}
                var m = a.c = function() {
                    return m._api ? m._api.apply(this, arguments) : void 0
                };
                m._functionalMap = g, m.GEQ = 1, m.LEQ = 2;
                var n = b ? function(b, d, e) {
                    if (d && d.prototype instanceof a.HTMLElement) {
                        var g = b,
                            h = c(e),
                            i = function(a) {
                                return a.__proto__ = e, g.apply(a, arguments), e.created && a.created(), e.decorate && a.decorate(), a
                            };
                        m.extend(e, {
                            upgrade: i
                        }), b = function() {
                            return i(a.document.createElement(h))
                        }, b.prototype = e, m.extend(b, {
                            ctor: g
                        })
                    }
                    return b
                } : function(a) {
                    return a
                };
                m.inherit = function(a) {
                    var b = null,
                        c = null;
                    a["extends"] && (c = a["extends"], delete a["extends"]), a.initialize && (b = a.initialize, delete a.initialize);
                    var d = b || function() {};
                    Object.defineProperty(d, "__super__", {
                        value: c ? c : Object,
                        enumerable: !1,
                        configurable: !0,
                        writable: !1
                    }), a._t && (e[a._t] = d);
                    var f = d.prototype = Object.create(c ? c.prototype : Object.prototype);
                    return m.extend(f, a), n(d, c, f, a)
                }, m.own = function(b, c, d) {
                    return Object.getOwnPropertyNames(b).forEach(c, d || a), b
                }, m.extend = function(a, b) {
                    return m.own(b, function(c) {
                        var d = Object.getOwnPropertyDescriptor(b, c);
                        if ("function" == typeof d.get || "function" == typeof d.set) Object.defineProperty(a, c, d);
                        else if ("function" == typeof d.value || "_" === c.charAt(0)) d.writable = !0, d.configurable = !0, d.enumerable = !1, Object.defineProperty(a, c, d);
                        else try {
                            a[c] = b[c]
                        } catch (e) {}
                    }), a
                }, m.assert = function(a, b) {
                    if (!a) throw new m.InternalError("Assertion failed: " + b)
                };
                var o = function(a) {
                    return "number" == typeof a ? m.Expression.fromConstant(a) : a instanceof m.Variable ? m.Expression.fromVariable(a) : a
                };
                m.plus = function(a, b) {
                    return a = o(a), b = o(b), a.plus(b)
                }, m.minus = function(a, b) {
                    return a = o(a), b = o(b), a.minus(b)
                }, m.times = function(a, b) {
                    return a = o(a), b = o(b), a.times(b)
                }, m.divide = function(a, b) {
                    return a = o(a), b = o(b), a.divide(b)
                }, m.approx = function(a, b) {
                    return a = +a, b = +b, a === b ? !0 : 0 == a ? Math.abs(b) < d : 0 == b ? Math.abs(a) < d : Math.abs(a - b) < Math.abs(a) * d
                };
                var p = 1;
                m._inc = function() {
                    return p++
                }, m.parseJSON = function(a) {
                    return JSON.parse(a, function(a, b) {
                        if ("object" != typeof b || "string" != typeof b._t) return b;
                        var c = b._t,
                            d = e[c];
                        if (c && d) {
                            var g = f(d, "fromJSON");
                            if (g) return g(b, d)
                        }
                        return b
                    })
                }, "function" == typeof define && define.amd ? define(m) : "object" == typeof module && module.exports ? module.exports = m : a.c = m
            }(this),
            function(a) {
                "use strict";
                if (a._functionalMap) a.HashTable = a.inherit({
                    initialize: function(b) {
                        this.hashCode = a._inc(), this._store = b instanceof a.HashTable ? new Map(b._store) : new Map
                    },
                    clone: function() {
                        return new a.HashTable(this)
                    },
                    get: function(a) {
                        var b = this._store.get(a.hashCode);
                        return void 0 === b ? null : b[1]
                    },
                    clear: function() {
                        this._store.clear()
                    },
                    get size() {
                        return this._store.size
                    },
                    set: function(a, b) {
                        return this._store.set(a.hashCode, [a, b])
                    },
                    has: function(a) {
                        return this._store.has(a.hashCode)
                    },
                    "delete": function(a) {
                        return this._store.delete(a.hashCode)
                    },
                    each: function(a, b) {
                        this._store.forEach(function(c) {
                            return a.call(b || null, c[0], c[1])
                        }, b)
                    },
                    escapingEach: function(a, b) {
                        if (this._store.size)
                            for (var c, e, f = this._store.values(), e = f.next(); !e.done;) {
                                if (c = a.call(b || null, e.value[0], e.value[1])) {
                                    if (void 0 !== c.retval) return c;
                                    if (c.brk) break
                                }
                                e = f.next()
                            }
                    },
                    equals: function(b) {
                        if (b === this) return !0;
                        if (!(b instanceof a.HashTable) || b._size !== this._size) return !1;
                        for (var c in this._store.keys())
                            if (void 0 == b._store.get(c)) return !1;
                        return !0
                    }
                });
                else {
                    var b = {},
                        c = function(a, b) {
                            Object.keys(a).forEach(function(c) {
                                b[c] = a[c]
                            })
                        };
                    a.HashTable = a.inherit({
                        initialize: function() {
                            this.size = 0, this._store = {}, this._deleted = 0
                        },
                        set: function(a, b) {
                            var c = a.hashCode;
                            "undefined" == typeof this._store[c] && this.size++, this._store[c] = [a, b]
                        },
                        get: function(a) {
                            if (!this.size) return null;
                            a = a.hashCode;
                            var b = this._store[a];
                            return "undefined" != typeof b ? b[1] : null
                        },
                        clear: function() {
                            this.size = 0, this._store = {}
                        },
                        _compact: function() {
                            var a = {};
                            c(this._store, a), this._store = a
                        },
                        _compactThreshold: 100,
                        _perhapsCompact: function() {
                            this._size > 30 || this._deleted > this._compactThreshold && (this._compact(), this._deleted = 0)
                        },
                        "delete": function(a) {
                            a = a.hashCode, this._store.hasOwnProperty(a) && (this._deleted++, delete this._store[a], this.size > 0 && this.size--)
                        },
                        each: function(a, b) {
                            if (this.size) {
                                this._perhapsCompact();
                                var c = this._store;
                                for (var d in this._store) this._store.hasOwnProperty(d) && a.call(b || null, c[d][0], c[d][1])
                            }
                        },
                        escapingEach: function(a, c) {
                            if (this.size) {
                                this._perhapsCompact();
                                for (var d = this, e = this._store, f = b, g = Object.keys(e), h = 0; h < g.length; h++)
                                    if (function(b) {
                                            d._store.hasOwnProperty(b) && (f = a.call(c || null, e[b][0], e[b][1]))
                                        }(g[h]), f) {
                                        if (void 0 !== f.retval) return f;
                                        if (f.brk) break
                                    }
                            }
                        },
                        clone: function() {
                            var b = new a.HashTable;
                            return this.size && (b.size = this.size, c(this._store, b._store)), b
                        },
                        equals: function(b) {
                            if (b === this) return !0;
                            if (!(b instanceof a.HashTable) || b._size !== this._size) return !1;
                            for (var c = Object.keys(this._store), d = 0; d < c.length; d++) {
                                var e = c[d];
                                if (this._store[e][0] !== b._store[e][0]) return !1
                            }
                            return !0
                        },
                        toString: function() {
                            var b = "";
                            return this.each(function(a, c) {
                                b += a + " => " + c + "\n"
                            }), b
                        },
                        toJSON: function() {
                            return {
                                _t: "c.HashTable"
                            }
                        },
                        fromJSON: function() {
                            var c = new a.HashTable;
                            return c
                        }
                    })
                }
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.HashSet = a._functionalMap ? a.inherit({
                    _t: "c.HashSet",
                    initialize: function(b) {
                        this.hashCode = a._inc(), this._store = b instanceof a.HashSet ? new Map(b._store) : new Map
                    },
                    add: function(a) {
                        return this._store.set(a.hashCode, a)
                    },
                    has: function(a) {
                        return this._store.has(a.hashCode)
                    },
                    get size() {
                        return this._store.size
                    },
                    clear: function() {
                        this._store.clear()
                    },
                    values: function() {
                        for (var a = [], b = this._store.values(), c = b.next(); !c.done;) a.push(c.value), c = b.next();
                        return a
                    },
                    first: function() {
                        var a = this._store.values(),
                            b = a.next();
                        return b.done ? null : b.value
                    },
                    "delete": function(a) {
                        this._store.delete(a.hashCode)
                    },
                    each: function(a, b) {
                        var c = this;
                        this._store.forEach(function(d) {
                            return a.call(b || null, d, d, c)
                        }, b)
                    },
                    escapingEach: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    toString: function() {
                        var a = this.size + " {",
                            b = !0;
                        return this.each(function(c) {
                            b ? b = !1 : a += ", ", a += c
                        }), a += "}\n"
                    },
                    toJSON: function() {
                        var a = [];
                        return this.each(function(b) {
                            a[a.length] = b.toJSON()
                        }), {
                            _t: "c.HashSet",
                            data: a
                        }
                    },
                    fromJSON: function(b) {
                        var c = new a.HashSet;
                        return b.data && (c.size = b.data.length, c._store = b.data), c
                    }
                }) : a.inherit({
                    _t: "c.HashSet",
                    initialize: function() {
                        this._store = [], this.size = 0, this.hashCode = a._inc()
                    },
                    add: function(a) {
                        var b = this._store;
                        b.indexOf(a), -1 == b.indexOf(a) && (b[b.length] = a), this.size = b.length
                    },
                    values: function() {
                        return this._store
                    },
                    first: function() {
                        return this._store[0]
                    },
                    has: function(a) {
                        return -1 != this._store.indexOf(a)
                    },
                    "delete": function(a) {
                        var b = this._store.indexOf(a);
                        return -1 == b ? null : (this._store.splice(b, 1)[0], this.size = this._store.length, void 0)
                    },
                    clear: function() {
                        this._store.length = 0
                    },
                    each: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    escapingEach: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    toString: function() {
                        var a = this.size + " {",
                            b = !0;
                        return this.each(function(c) {
                            b ? b = !1 : a += ", ", a += c
                        }), a += "}\n"
                    },
                    toJSON: function() {
                        var a = [];
                        return this.each(function(b) {
                            a[a.length] = b.toJSON()
                        }), {
                            _t: "c.HashSet",
                            data: a
                        }
                    },
                    fromJSON: function(b) {
                        var c = new a.HashSet;
                        return b.data && (c.size = b.data.length, c._store = b.data), c
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Error = a.inherit({
                    initialize: function(a) {
                        a && (this._description = a)
                    },
                    _name: "c.Error",
                    _description: "An error has occured in Cassowary",
                    set description(a) {
                        this._description = a
                    },
                    get description() {
                        return "(" + this._name + ") " + this._description
                    },
                    get message() {
                        return this.description
                    },
                    toString: function() {
                        return this.description
                    }
                });
                var b = function(b, c) {
                    return a.inherit({
                        "extends": a.Error,
                        initialize: function() {
                            a.Error.apply(this, arguments)
                        },
                        _name: b || "",
                        _description: c || ""
                    })
                };
                a.ConstraintNotFound = b("c.ConstraintNotFound", "Tried to remove a constraint never added to the tableu"), a.InternalError = b("c.InternalError"), a.NonExpression = b("c.NonExpression", "The resulting expression would be non"), a.NotEnoughStays = b("c.NotEnoughStays", "There are not enough stays to give specific values to every variable"), a.RequiredFailure = b("c.RequiredFailure", "A required constraint cannot be satisfied"), a.TooDifficult = b("c.TooDifficult", "The constraints are too difficult to solve")
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                var b = 1e3;
                a.SymbolicWeight = a.inherit({
                    _t: "c.SymbolicWeight",
                    initialize: function() {
                        this.value = 0;
                        for (var a = 1, c = arguments.length - 1; c >= 0; --c) this.value += arguments[c] * a, a *= b
                    },
                    toJSON: function() {
                        return {
                            _t: this._t,
                            value: this.value
                        }
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                a.Strength = a.inherit({
                    initialize: function(b, c, d, e) {
                        this.name = b, this.symbolicWeight = c instanceof a.SymbolicWeight ? c : new a.SymbolicWeight(c, d, e)
                    },
                    get required() {
                        return this === a.Strength.required
                    },
                    toString: function() {
                        return this.name + (this.required ? "" : ":" + this.symbolicWeight)
                    }
                }), a.Strength.required = new a.Strength("<Required>", 1e3, 1e3, 1e3), a.Strength.strong = new a.Strength("strong", 1, 0, 0), a.Strength.medium = new a.Strength("medium", 0, 1, 0), a.Strength.weak = new a.Strength("weak", 0, 0, 1)
            }(this.c || ("undefined" != typeof module ? module.parent.exports.c : {})),
            function(a) {
                "use strict";
                a.AbstractVariable = a.inherit({
                    isDummy: !1,
                    isExternal: !1,
                    isPivotable: !1,
                    isRestricted: !1,
                    _init: function(b, c) {
                        this.hashCode = a._inc(), this.name = (c || "") + this.hashCode, b && ("undefined" != typeof b.name && (this.name = b.name), "undefined" != typeof b.value && (this.value = b.value), "undefined" != typeof b.prefix && (this._prefix = b.prefix))
                    },
                    _prefix: "",
                    name: "",
                    value: 0,
                    valueOf: function() {
                        return this.value
                    },
                    toJSON: function() {
                        var a = {};
                        return this._t && (a._t = this._t), this.name && (a.name = this.name), "undefined" != typeof this.value && (a.value = this.value), this._prefix && (a._prefix = this._prefix), this._t && (a._t = this._t), a
                    },
                    fromJSON: function(b, c) {
                        var d = new c;
                        return a.extend(d, b), d
                    },
                    toString: function() {
                        return this._prefix + "[" + this.name + ":" + this.value + "]"
                    }
                }), a.Variable = a.inherit({
                    _t: "c.Variable",
                    "extends": a.AbstractVariable,
                    initialize: function(b) {
                        this._init(b, "v");
                        var c = a.Variable._map;
                        c && (c[this.name] = this)
                    },
                    isExternal: !0
                }), a.DummyVariable = a.inherit({
                    _t: "c.DummyVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "d")
                    },
                    isDummy: !0,
                    isRestricted: !0,
                    value: "dummy"
                }), a.ObjectiveVariable = a.inherit({
                    _t: "c.ObjectiveVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "o")
                    },
                    value: "obj"
                }), a.SlackVariable = a.inherit({
                    _t: "c.SlackVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "s")
                    },
                    isPivotable: !0,
                    isRestricted: !0,
                    value: "slack"
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Point = a.inherit({
                    initialize: function(b, c, d) {
                        if (b instanceof a.Variable) this._x = b;
                        else {
                            var e = {
                                value: b
                            };
                            d && (e.name = "x" + d), this._x = new a.Variable(e)
                        }
                        if (c instanceof a.Variable) this._y = c;
                        else {
                            var f = {
                                value: c
                            };
                            d && (f.name = "y" + d), this._y = new a.Variable(f)
                        }
                    },
                    get x() {
                        return this._x
                    },
                    set x(b) {
                        b instanceof a.Variable ? this._x = b : this._x.value = b
                    },
                    get y() {
                        return this._y
                    },
                    set y(b) {
                        b instanceof a.Variable ? this._y = b : this._y.value = b
                    },
                    toString: function() {
                        return "(" + this.x + ", " + this.y + ")"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                var b = function(a, b) {
                    return "number" == typeof a ? a : b
                };
                a.Expression = a.inherit({
                    initialize: function(c, d, e) {
                        this.constant = b(e, 0), this.terms = new a.HashTable, this.externalVariables = new a.HashSet, Object.defineProperty(this, "solver", {
                            enumerable: !1,
                            configurable: !0,
                            writable: !0,
                            value: null
                        }), c instanceof a.AbstractVariable ? (d = b(d, 1), this.setVariable(c, d)) : "number" == typeof c && (isNaN(c) ? console.trace() : this.constant = c)
                    },
                    initializeFromHash: function(a, b) {
                        return this.constant = a, this.terms = b.clone(), this
                    },
                    multiplyMe: function(a) {
                        this.constant *= a;
                        var b = this.terms;
                        return b.each(function(c, d) {
                            b.set(c, d * a)
                        }), this
                    },
                    clone: function() {
                        var b = a.Expression.empty();
                        return b.initializeFromHash(this.constant, this.terms), b.solver = this.solver, b
                    },
                    times: function(b) {
                        if ("number" == typeof b) return this.clone().multiplyMe(b);
                        if (this.isConstant) return b.times(this.constant);
                        if (b.isConstant) return this.times(b.constant);
                        throw new a.NonExpression
                    },
                    plus: function(b) {
                        return b instanceof a.Expression ? this.clone().addExpression(b, 1) : b instanceof a.Variable ? this.clone().addVariable(b, 1) : void 0
                    },
                    minus: function(b) {
                        return b instanceof a.Expression ? this.clone().addExpression(b, -1) : b instanceof a.Variable ? this.clone().addVariable(b, -1) : void 0
                    },
                    divide: function(b) {
                        if ("number" == typeof b) {
                            if (a.approx(b, 0)) throw new a.NonExpression;
                            return this.times(1 / b)
                        }
                        if (b instanceof a.Expression) {
                            if (!b.isConstant) throw new a.NonExpression;
                            return this.times(1 / b.constant)
                        }
                    },
                    addExpression: function(c, d, e) {
                        return c instanceof a.AbstractVariable && (c = a.Expression.fromVariable(c)), d = b(d, 1), this.constant += d * c.constant, c.terms.each(function(a, b) {
                            this.addVariable(a, b * d, e), this._updateIfExternal(a)
                        }, this), this
                    },
                    addVariable: function(b, c, d) {
                        null == c && (c = 1);
                        var e = this.terms.get(b);
                        if (e) {
                            var f = e + c;
                            0 == f || a.approx(f, 0) ? (this.solver && this.solver.noteRemovedVariable(b, d), this.terms.delete(b)) : this.setVariable(b, f)
                        } else a.approx(c, 0) || (this.setVariable(b, c), this.solver && this.solver.noteAddedVariable(b, d));
                        return this
                    },
                    _updateIfExternal: function(a) {
                        a.isExternal && (this.externalVariables.add(a), this.solver && this.solver._noteUpdatedExternal(a))
                    },
                    setVariable: function(a, b) {
                        return this.terms.set(a, b), this._updateIfExternal(a), this
                    },
                    anyPivotableVariable: function() {
                        if (this.isConstant) throw new a.InternalError("anyPivotableVariable called on a constant");
                        var b = this.terms.escapingEach(function(a) {
                            return a.isPivotable ? {
                                retval: a
                            } : void 0
                        });
                        return b && void 0 !== b.retval ? b.retval : null
                    },
                    substituteOut: function(b, c, d) {
                        var e = this.solver;
                        if (!e) throw new a.InternalError("Expressions::substituteOut called without a solver");
                        var f = this.setVariable.bind(this),
                            g = this.terms,
                            h = g.get(b);
                        g.delete(b), this.constant += h * c.constant, c.terms.each(function(b, c) {
                            var i = g.get(b);
                            if (i) {
                                var j = i + h * c;
                                a.approx(j, 0) ? (e.noteRemovedVariable(b, d), g.delete(b)) : f(b, j)
                            } else f(b, h * c), e && e.noteAddedVariable(b, d)
                        })
                    },
                    changeSubject: function(a, b) {
                        this.setVariable(a, this.newSubject(b))
                    },
                    newSubject: function(a) {
                        var b = 1 / this.terms.get(a);
                        return this.terms.delete(a), this.multiplyMe(-b), b
                    },
                    coefficientFor: function(a) {
                        return this.terms.get(a) || 0
                    },
                    get isConstant() {
                        return 0 == this.terms.size
                    },
                    toString: function() {
                        var b = "",
                            c = !1;
                        if (!a.approx(this.constant, 0) || this.isConstant) {
                            if (b += this.constant, this.isConstant) return b;
                            c = !0
                        }
                        return this.terms.each(function(a, d) {
                            c && (b += " + "), b += d + "*" + a, c = !0
                        }), b
                    },
                    equals: function(b) {
                        return b === this ? !0 : b instanceof a.Expression && b.constant === this.constant && b.terms.equals(this.terms)
                    },
                    Plus: function(a, b) {
                        return a.plus(b)
                    },
                    Minus: function(a, b) {
                        return a.minus(b)
                    },
                    Times: function(a, b) {
                        return a.times(b)
                    },
                    Divide: function(a, b) {
                        return a.divide(b)
                    }
                }), a.Expression.empty = function(b) {
                    var c = new a.Expression(void 0, 1, 0);
                    return c.solver = b, c
                }, a.Expression.fromConstant = function(b, c) {
                    var d = new a.Expression(b);
                    return d.solver = c, d
                }, a.Expression.fromValue = function(b, c) {
                    b = +b;
                    var d = new a.Expression(void 0, b, 0);
                    return d.solver = c, d
                }, a.Expression.fromVariable = function(b, c) {
                    var d = new a.Expression(b, 1, 0);
                    return d.solver = c, d
                }
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.AbstractConstraint = a.inherit({
                    initialize: function(b, c) {
                        this.hashCode = a._inc(), this.strength = b || a.Strength.required, this.weight = c || 1
                    },
                    isEdit: !1,
                    isInequality: !1,
                    isStay: !1,
                    get required() {
                        return this.strength === a.Strength.required
                    },
                    toString: function() {
                        return this.strength + " {" + this.weight + "} (" + this.expression + ")"
                    }
                });
                var b = a.AbstractConstraint.prototype.toString,
                    c = function(b, c, d) {
                        a.AbstractConstraint.call(this, c || a.Strength.strong, d), this.variable = b, this.expression = new a.Expression(b, -1, b.value)
                    };
                a.EditConstraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function() {
                        c.apply(this, arguments)
                    },
                    isEdit: !0,
                    toString: function() {
                        return "edit:" + b.call(this)
                    }
                }), a.StayConstraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function() {
                        c.apply(this, arguments)
                    },
                    isStay: !0,
                    toString: function() {
                        return "stay:" + b.call(this)
                    }
                });
                var d = a.Constraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function(b, c, d) {
                        a.AbstractConstraint.call(this, c, d), this.expression = b
                    }
                });
                a.Inequality = a.inherit({
                    "extends": a.Constraint,
                    _cloneOrNewCle: function(b) {
                        return b.clone ? b.clone() : new a.Expression(b)
                    },
                    initialize: function(b, c, e, f, g) {
                        var h = b instanceof a.Expression,
                            i = e instanceof a.Expression,
                            j = b instanceof a.AbstractVariable,
                            k = e instanceof a.AbstractVariable,
                            l = "number" == typeof b,
                            m = "number" == typeof e;
                        if ((h || l) && k) {
                            var n = b,
                                o = c,
                                p = e,
                                q = f,
                                r = g;
                            if (d.call(this, this._cloneOrNewCle(n), q, r), o == a.LEQ) this.expression.multiplyMe(-1), this.expression.addVariable(p);
                            else {
                                if (o != a.GEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                this.expression.addVariable(p, -1)
                            }
                        } else if (j && (i || m)) {
                            var n = e,
                                o = c,
                                p = b,
                                q = f,
                                r = g;
                            if (d.call(this, this._cloneOrNewCle(n), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addVariable(p);
                            else {
                                if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                this.expression.addVariable(p, -1)
                            }
                        } else {
                            if (h && m) {
                                var s = b,
                                    o = c,
                                    t = e,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(s), q, r), o == a.LEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(t));
                                else {
                                    if (o != a.GEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(t), -1)
                                }
                                return this
                            }
                            if (l && i) {
                                var s = e,
                                    o = c,
                                    t = b,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(s), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(t));
                                else {
                                    if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(t), -1)
                                }
                                return this
                            }
                            if (h && i) {
                                var s = b,
                                    o = c,
                                    t = e,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(t), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(s));
                                else {
                                    if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(s), -1)
                                }
                            } else {
                                if (h) return d.call(this, b, c, e);
                                if (c == a.GEQ) d.call(this, new a.Expression(e), f, g), this.expression.multiplyMe(-1), this.expression.addVariable(b);
                                else {
                                    if (c != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    d.call(this, new a.Expression(e), f, g), this.expression.addVariable(b, -1)
                                }
                            }
                        }
                    },
                    isInequality: !0,
                    toString: function() {
                        return d.prototype.toString.call(this) + " >= 0) id: " + this.hashCode
                    }
                }), a.Equation = a.inherit({
                    "extends": a.Constraint,
                    initialize: function(b, c, e, f) {
                        if (b instanceof a.Expression && !c || c instanceof a.Strength) d.call(this, b, c, e);
                        else if (b instanceof a.AbstractVariable && c instanceof a.Expression) {
                            var g = b,
                                h = c,
                                i = e,
                                j = f;
                            d.call(this, h.clone(), i, j), this.expression.addVariable(g, -1)
                        } else if (b instanceof a.AbstractVariable && "number" == typeof c) {
                            var g = b,
                                k = c,
                                i = e,
                                j = f;
                            d.call(this, new a.Expression(k), i, j), this.expression.addVariable(g, -1)
                        } else if (b instanceof a.Expression && c instanceof a.AbstractVariable) {
                            var h = b,
                                g = c,
                                i = e,
                                j = f;
                            d.call(this, h.clone(), i, j), this.expression.addVariable(g, -1)
                        } else {
                            if (!(b instanceof a.Expression || b instanceof a.AbstractVariable || "number" == typeof b) || !(c instanceof a.Expression || c instanceof a.AbstractVariable || "number" == typeof c)) throw "Bad initializer to c.Equation";
                            b = b instanceof a.Expression ? b.clone() : new a.Expression(b), c = c instanceof a.Expression ? c.clone() : new a.Expression(c), d.call(this, b, e, f), this.expression.addExpression(c, -1)
                        }
                        a.assert(this.strength instanceof a.Strength, "_strength not set")
                    },
                    toString: function() {
                        return d.prototype.toString.call(this) + " = 0)"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.EditInfo = a.inherit({
                    initialize: function(a, b, c, d, e) {
                        this.constraint = a, this.editPlus = b, this.editMinus = c, this.prevEditConstant = d, this.index = e
                    },
                    toString: function() {
                        return "<cn=" + this.constraint + ", ep=" + this.editPlus + ", em=" + this.editMinus + ", pec=" + this.prevEditConstant + ", index=" + this.index + ">"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Tableau = a.inherit({
                    initialize: function() {
                        this.columns = new a.HashTable, this.rows = new a.HashTable, this._infeasibleRows = new a.HashSet, this._externalRows = new a.HashTable
                    },
                    noteRemovedVariable: function(a, b) {
                        var c = this.columns.get(a);
                        b && c && c.delete(b)
                    },
                    noteAddedVariable: function(a, b) {
                        b && this.insertColVar(a, b)
                    },
                    getInternalInfo: function() {
                        return "Tableau Information:\nRows: " + this.rows.size + " (= " + (this.rows.size - 1) + " constraints)" + "\nColumns: " + this.columns.size + "\nInfeasible Rows: " + this._infeasibleRows.size + "\nExternal basic variables: " + this._externalRows.size
                    },
                    toString: function() {
                        var a = "Tableau:\n";
                        return this.rows.each(function(b, c) {
                            a += b + " <==> " + c + "\n"
                        }), a += "\nColumns:\n", this.columns.each(function(b, c) {
                            a += b + " <==> " + c
                        }), a += "\nInfeasible rows: ", a += this._infeasibleRows, a += "External basic variables: ", a += this._externalRows
                    },
                    insertColVar: function(b, c) {
                        var d = this.columns.get(b);
                        d || (d = new a.HashSet, this.columns.set(b, d)), d.add(c)
                    },
                    addRow: function(a, b) {
                        this.rows.set(a, b), b.terms.each(function(b) {
                            this.insertColVar(b, a)
                        }, this), a.isExternal && this._externalRows.set(a, b)
                    },
                    removeColumn: function(a) {
                        var b = this.columns.get(a);
                        b && (this.columns.delete(a), b.each(function(b) {
                            var c = this.rows.get(b);
                            c.terms.delete(a)
                        }, this)), a.isExternal && this._externalRows.delete(a)
                    },
                    removeRow: function(b) {
                        var c = this.rows.get(b);
                        return a.assert(null != c), c.terms.each(function(a) {
                            var d = this.columns.get(a);
                            null != d && d.delete(b)
                        }, this), this._infeasibleRows.delete(b), b.isExternal && this._externalRows.delete(b), this.rows.delete(b), c
                    },
                    substituteOut: function(a, b) {
                        var c = this.columns.get(a);
                        c.each(function(c) {
                            var d = this.rows.get(c);
                            d.substituteOut(a, b, c, this), c.isExternal && this._updatedExternals.add(c), c.isRestricted && d.constant < 0 && this._infeasibleRows.add(c)
                        }, this), a.isExternal && this._externalRows.set(a, b), this.columns.delete(a)
                    },
                    columnsHasKey: function(a) {
                        return !!this.columns.get(a)
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                var b = a.Tableau,
                    c = b.prototype,
                    d = 1e-8,
                    e = a.Strength.weak,
                    f = {
                        eplus: null,
                        eminus: null,
                        prevEConstant: null
                    };
                a.SimplexSolver = a.inherit({
                    "extends": a.Tableau,
                    initialize: function() {
                        a.Tableau.call(this), this._stayMinusErrorVars = [], this._stayPlusErrorVars = [], this._errorVars = new a.HashTable, this._markerVars = new a.HashTable, this._objective = new a.ObjectiveVariable({
                            name: "Z"
                        }), this._editVarMap = new a.HashTable, this._editVarList = [], this._slackCounter = 0, this._artificialCounter = 0, this._dummyCounter = 0, this.autoSolve = !0, this._needsSolving = !1, this._optimizeCount = 0, this.rows.set(this._objective, a.Expression.empty(this)), this._editVariableStack = [0], this._updatedExternals = new a.HashSet
                    },
                    _noteUpdatedExternal: function(a) {
                        this._updatedExternals.add(a)
                    },
                    add: function() {
                        for (var a = 0; a < arguments.length; a++) this.addConstraint(arguments[a]);
                        return this
                    },
                    addEditVar: function(b, c, d) {
                        var e = new a.EditConstraint(b, c || a.Strength.strong, d);
                        return this.addEditConstraint(e), this
                    },
                    addEditConstraint: function(a) {
                        var b = f;
                        return this.addConstraint(a), this._addEditConstraint(a, b.eplus, b.eminus, b.prevEConstant), this
                    },
                    _addEditConstraint: function(b, c, d, e) {
                        var f = this._editVarMap.size,
                            g = new a.EditInfo(b, c, d, e, f);
                        this._editVarMap.set(b.variable, g), this._editVarList[f] = {
                            v: b.variable,
                            info: g
                        }
                    },
                    addConstraint: function(b) {
                        if (b instanceof a.Constraint) {
                            var c = this;
                            b.expression.externalVariables.each(function(a) {
                                c._noteUpdatedExternal(a)
                            })
                        }
                        var d = this.newExpression(b);
                        return d.solver = this, this.tryAddingDirectly(d) || this.addWithArtificialVariable(d), this._needsSolving = !0, this.autoSolve && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    addConstraintNoException: function(a) {
                        try {
                            return this.addConstraint(a), !0
                        } catch (b) {
                            return console.error(b), !1
                        }
                    },
                    beginEdit: function() {
                        return a.assert(this._editVarMap.size > 0, "_editVarMap.size > 0"), this._infeasibleRows.clear(), this._resetStayConstants(), this._editVariableStack[this._editVariableStack.length] = this._editVarMap.size, this
                    },
                    endEdit: function() {
                        return a.assert(this._editVarMap.size > 0, "_editVarMap.size > 0"), this.resolve(), this._editVariableStack.pop(), this.removeEditVarsTo(this._editVariableStack[this._editVariableStack.length - 1]), this
                    },
                    removeAllEditVars: function() {
                        return this.removeEditVarsTo(0)
                    },
                    removeEditVarsTo: function(b) {
                        try {
                            for (var c = this._editVarList.length, d = b; c > d; d++) this._editVarList[d] && this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);
                            return this._editVarList.length = b, a.assert(this._editVarMap.size == b, "_editVarMap.size == n"), this
                        } catch (e) {
                            throw new a.InternalError("Constraint not found in removeEditVarsTo")
                        }
                    },
                    addPointStays: function(a) {
                        return a.forEach(function(a, b) {
                            this.addStay(a.x, e, Math.pow(2, b)), this.addStay(a.y, e, Math.pow(2, b))
                        }, this), this
                    },
                    addStay: function(b, c, d) {
                        var f = new a.StayConstraint(b, c || e, d || 1);
                        return this.addConstraint(f)
                    },
                    setConstant: function(a, b) {
                        this._setConstant(a, b), this.resolve()
                    },
                    removeConstraint: function(b) {
                        this._needsSolving = !0, this._resetStayConstants();
                        var c = this.rows.get(this._objective),
                            d = this._errorVars.get(b);
                        null != d && d.each(function(a) {
                            var d = this.rows.get(a);
                            null == d ? c.addVariable(a, -b.weight * b.strength.symbolicWeight.value, this._objective, this) : c.addExpression(d, -b.weight * b.strength.symbolicWeight.value, this._objective, this)
                        }, this);
                        var e = this._markerVars.get(b);
                        if (this._markerVars.delete(b), null == e) throw new a.InternalError("Constraint not found in removeConstraintInternal");
                        if (null == this.rows.get(e)) {
                            var f = this.columns.get(e),
                                g = null,
                                h = 0;
                            f.each(function(b) {
                                if (b.isRestricted) {
                                    var c = this.rows.get(b),
                                        d = c.coefficientFor(e);
                                    if (0 > d) {
                                        var f = -c.constant / d;
                                        (null == g || h > f || a.approx(f, h) && b.hashCode < g.hashCode) && (h = f, g = b)
                                    }
                                }
                            }, this), null == g && f.each(function(a) {
                                if (a.isRestricted) {
                                    var b = this.rows.get(a),
                                        c = b.coefficientFor(e),
                                        d = b.constant / c;
                                    (null == g || h > d) && (h = d, g = a)
                                }
                            }, this), null == g && (0 == f.size ? this.removeColumn(e) : f.escapingEach(function(a) {
                                return a != this._objective ? (g = a, {
                                    brk: !0
                                }) : void 0
                            }, this)), null != g && this.pivot(e, g)
                        }
                        if (null != this.rows.get(e) && this.removeRow(e), null != d && d.each(function(a) {
                                a != e && this.removeColumn(a)
                            }, this), b.isStay) {
                            if (null != d)
                                for (var j = 0; j < this._stayPlusErrorVars.length; j++) d.delete(this._stayPlusErrorVars[j]), d.delete(this._stayMinusErrorVars[j])
                        } else if (b.isEdit) {
                            var k = this._editVarMap.get(b.variable);
                            this.removeColumn(k.editMinus), this._editVarMap.delete(b.variable)
                        }
                        return null != d && this._errorVars.delete(d), this.autoSolve && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    reset: function() {
                        throw new a.InternalError("reset not implemented")
                    },
                    resolveArray: function(a) {
                        var b = a.length;
                        this._editVarMap.each(function(c, d) {
                            var e = d.index;
                            b > e && this.suggestValue(c, a[e])
                        }, this), this.resolve()
                    },
                    resolvePair: function(a, b) {
                        this.suggestValue(this._editVarList[0].v, a), this.suggestValue(this._editVarList[1].v, b), this.resolve()
                    },
                    resolve: function() {
                        this.dualOptimize(), this._setExternalVariables(), this._infeasibleRows.clear(), this._resetStayConstants()
                    },
                    suggestValue: function(b, c) {
                        var d = this._editVarMap.get(b);
                        if (!d) throw new a.Error("suggestValue for variable " + b + ", but var is not an edit variable");
                        var e = c - d.prevEditConstant;
                        return d.prevEditConstant = c, this.deltaEditConstant(e, d.editPlus, d.editMinus), this
                    },
                    solve: function() {
                        return this._needsSolving && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    setEditedValue: function(b, c) {
                        if (!this.columnsHasKey(b) && null == this.rows.get(b)) return b.value = c, this;
                        if (!a.approx(c, b.value)) {
                            this.addEditVar(b), this.beginEdit();
                            try {
                                this.suggestValue(b, c)
                            } catch (d) {
                                throw new a.InternalError("Error in setEditedValue")
                            }
                            this.endEdit()
                        }
                        return this
                    },
                    addVar: function(b) {
                        if (!this.columnsHasKey(b) && null == this.rows.get(b)) try {
                            this.addStay(b)
                        } catch (c) {
                            throw new a.InternalError("Error in addVar -- required failure is impossible")
                        }
                        return this
                    },
                    getInternalInfo: function() {
                        var a = c.getInternalInfo.call(this);
                        return a += "\nSolver info:\n", a += "Stay Error Variables: ", a += this._stayPlusErrorVars.length + this._stayMinusErrorVars.length, a += " (" + this._stayPlusErrorVars.length + " +, ", a += this._stayMinusErrorVars.length + " -)\n", a += "Edit Variables: " + this._editVarMap.size, a += "\n"
                    },
                    getDebugInfo: function() {
                        return this.toString() + this.getInternalInfo() + "\n"
                    },
                    toString: function() {
                        var a = c.getInternalInfo.call(this);
                        return a += "\n_stayPlusErrorVars: ", a += "[" + this._stayPlusErrorVars + "]", a += "\n_stayMinusErrorVars: ", a += "[" + this._stayMinusErrorVars + "]", a += "\n", a += "_editVarMap:\n" + this._editVarMap, a += "\n"
                    },
                    addWithArtificialVariable: function(b) {
                        var c = new a.SlackVariable({
                                value: ++this._artificialCounter,
                                prefix: "a"
                            }),
                            d = new a.ObjectiveVariable({
                                name: "az"
                            }),
                            e = b.clone();
                        this.addRow(d, e), this.addRow(c, b), this.optimize(d);
                        var f = this.rows.get(d);
                        if (!a.approx(f.constant, 0)) throw this.removeRow(d), this.removeColumn(c), new a.RequiredFailure;
                        var g = this.rows.get(c);
                        if (null != g) {
                            if (g.isConstant) return this.removeRow(c), this.removeRow(d), void 0;
                            var h = g.anyPivotableVariable();
                            this.pivot(h, c)
                        }
                        a.assert(null == this.rows.get(c), "rowExpression(av) == null"), this.removeColumn(c), this.removeRow(d)
                    },
                    tryAddingDirectly: function(a) {
                        var b = this.chooseSubject(a);
                        return null == b ? !1 : (a.newSubject(b), this.columnsHasKey(b) && this.substituteOut(b, a), this.addRow(b, a), !0)
                    },
                    chooseSubject: function(b) {
                        var c = null,
                            d = !1,
                            e = !1,
                            f = b.terms,
                            g = f.escapingEach(function(a, b) {
                                if (d) {
                                    if (!a.isRestricted && !this.columnsHasKey(a)) return {
                                        retval: a
                                    }
                                } else if (a.isRestricted) {
                                    if (!e && !a.isDummy && 0 > b) {
                                        var f = this.columns.get(a);
                                        (null == f || 1 == f.size && this.columnsHasKey(this._objective)) && (c = a, e = !0)
                                    }
                                } else c = a, d = !0
                            }, this);
                        if (g && void 0 !== g.retval) return g.retval;
                        if (null != c) return c;
                        var h = 0,
                            g = f.escapingEach(function(a, b) {
                                return a.isDummy ? (this.columnsHasKey(a) || (c = a, h = b), void 0) : {
                                    retval: null
                                }
                            }, this);
                        if (g && void 0 !== g.retval) return g.retval;
                        if (!a.approx(b.constant, 0)) throw new a.RequiredFailure;
                        return h > 0 && b.multiplyMe(-1), c
                    },
                    deltaEditConstant: function(a, b, c) {
                        var d = this.rows.get(b);
                        if (null != d) return d.constant += a, d.constant < 0 && this._infeasibleRows.add(b), void 0;
                        var e = this.rows.get(c);
                        if (null != e) return e.constant += -a, e.constant < 0 && this._infeasibleRows.add(c), void 0;
                        var f = this.columns.get(c);
                        f || console.log("columnVars is null -- tableau is:\n" + this), f.each(function(b) {
                            var d = this.rows.get(b),
                                e = d.coefficientFor(c);
                            d.constant += e * a, b.isExternal && this._noteUpdatedExternal(b), b.isRestricted && d.constant < 0 && this._infeasibleRows.add(b)
                        }, this)
                    },
                    dualOptimize: function() {
                        for (var b = this.rows.get(this._objective); this._infeasibleRows.size;) {
                            var c = this._infeasibleRows.first();
                            this._infeasibleRows.delete(c);
                            var d = null,
                                e = this.rows.get(c);
                            if (e && e.constant < 0) {
                                var g, f = Number.MAX_VALUE,
                                    h = e.terms;
                                if (h.each(function(c, e) {
                                        if (e > 0 && c.isPivotable) {
                                            var h = b.coefficientFor(c);
                                            g = h / e, (f > g || a.approx(g, f) && c.hashCode < d.hashCode) && (d = c, f = g)
                                        }
                                    }), f == Number.MAX_VALUE) throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");
                                this.pivot(d, c)
                            }
                        }
                    },
                    newExpression: function(b) {
                        var c = f;
                        c.eplus = null, c.eminus = null, c.prevEConstant = null;
                        var d = b.expression,
                            e = a.Expression.fromConstant(d.constant, this),
                            g = new a.SlackVariable,
                            h = new a.DummyVariable,
                            i = new a.SlackVariable,
                            j = new a.SlackVariable,
                            k = d.terms;
                        if (k.each(function(a, b) {
                                var c = this.rows.get(a);
                                c ? e.addExpression(c, b) : e.addVariable(a, b)
                            }, this), b.isInequality) {
                            if (++this._slackCounter, g = new a.SlackVariable({
                                    value: this._slackCounter,
                                    prefix: "s"
                                }), e.setVariable(g, -1), this._markerVars.set(b, g), !b.required) {
                                ++this._slackCounter, i = new a.SlackVariable({
                                    value: this._slackCounter,
                                    prefix: "em"
                                }), e.setVariable(i, 1);
                                var l = this.rows.get(this._objective);
                                l.setVariable(i, b.strength.symbolicWeight.value * b.weight), this.insertErrorVar(b, i), this.noteAddedVariable(i, this._objective)
                            }
                        } else if (b.required) ++this._dummyCounter, h = new a.DummyVariable({
                            value: this._dummyCounter,
                            prefix: "d"
                        }), c.eplus = h, c.eminus = h, c.prevEConstant = d.constant, e.setVariable(h, 1), this._markerVars.set(b, h);
                        else {
                            ++this._slackCounter, j = new a.SlackVariable({
                                value: this._slackCounter,
                                prefix: "ep"
                            }), i = new a.SlackVariable({
                                value: this._slackCounter,
                                prefix: "em"
                            }), e.setVariable(j, -1), e.setVariable(i, 1), this._markerVars.set(b, j);
                            var l = this.rows.get(this._objective),
                                m = b.strength.symbolicWeight.value * b.weight;
                            l.setVariable(j, m), this.noteAddedVariable(j, this._objective), l.setVariable(i, m), this.noteAddedVariable(i, this._objective), this.insertErrorVar(b, i), this.insertErrorVar(b, j), b.isStay ? (this._stayPlusErrorVars[this._stayPlusErrorVars.length] = j, this._stayMinusErrorVars[this._stayMinusErrorVars.length] = i) : b.isEdit && (c.eplus = j, c.eminus = i, c.prevEConstant = d.constant)
                        }
                        return e.constant < 0 && e.multiplyMe(-1), e
                    },
                    optimize: function(b) {
                        this._optimizeCount++;
                        var c = this.rows.get(b);
                        a.assert(null != c, "zRow != null");
                        for (var g, h, e = null, f = null;;) {
                            if (g = 0, h = c.terms, h.escapingEach(function(a, b) {
                                    return a.isPivotable && g > b ? (g = b, e = a, {
                                        brk: 1
                                    }) : void 0
                                }, this), g >= -d) return;
                            var i = Number.MAX_VALUE,
                                j = this.columns.get(e),
                                k = 0;
                            if (j.each(function(b) {
                                    if (b.isPivotable) {
                                        var c = this.rows.get(b),
                                            d = c.coefficientFor(e);
                                        0 > d && (k = -c.constant / d, (i > k || a.approx(k, i) && b.hashCode < f.hashCode) && (i = k, f = b))
                                    }
                                }, this), i == Number.MAX_VALUE) throw new a.InternalError("Objective function is unbounded in optimize");
                            this.pivot(e, f)
                        }
                    },
                    pivot: function(a, b) {
                        var c = !1;
                        c && console.time(" SimplexSolver::pivot"), null == a && console.warn("pivot: entryVar == null"), null == b && console.warn("pivot: exitVar == null"), c && console.time("  removeRow");
                        var d = this.removeRow(b);
                        c && console.timeEnd("  removeRow"), c && console.time("  changeSubject"), d.changeSubject(b, a), c && console.timeEnd("  changeSubject"), c && console.time("  substituteOut"), this.substituteOut(a, d), c && console.timeEnd("  substituteOut"), c && console.time("  addRow"), this.addRow(a, d), c && console.timeEnd("  addRow"), c && console.timeEnd(" SimplexSolver::pivot")
                    },
                    _resetStayConstants: function() {
                        for (var a = this._stayPlusErrorVars, b = a.length, c = 0; b > c; c++) {
                            var d = this.rows.get(a[c]);
                            null === d && (d = this.rows.get(this._stayMinusErrorVars[c])), null != d && (d.constant = 0)
                        }
                    },
                    _setExternalVariables: function() {
                        var a = [];
                        this._updatedExternals.each(function(b) {
                            var c = b.value,
                                d = this._externalRows.get(b);
                            return d ? (b.value = d.constant, c !== b.value && a.push({
                                type: "update",
                                name: b.name,
                                variable: b,
                                oldValue: c
                            }), void 0) : (b.value = 0, void 0)
                        }, this), this._updatedExternals.clear(), this._needsSolving = !1, this._informCallbacks(a), a.length && this.onsolved(a)
                    },
                    onsolved: function() {},
                    _informCallbacks: function(a) {
                        this._callbacks && this._callbacks.forEach(function(b) {
                            b(a)
                        })
                    },
                    _addCallback: function(a) {
                        var b = this._callbacks || (this._callbacks = []);
                        b[b.length] = a
                    },
                    insertErrorVar: function(b, c) {
                        var d = this._errorVars.get(b);
                        d || (d = new a.HashSet, this._errorVars.set(b, d)), d.add(c)
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Timer = a.inherit({
                    initialize: function() {
                        this.isRunning = !1, this._elapsedMs = 0
                    },
                    start: function() {
                        return this.isRunning = !0, this._startReading = new Date, this
                    },
                    stop: function() {
                        return this.isRunning = !1, this._elapsedMs += new Date - this._startReading, this
                    },
                    reset: function() {
                        return this.isRunning = !1, this._elapsedMs = 0, this
                    },
                    elapsedTime: function() {
                        return this.isRunning ? (this._elapsedMs + (new Date - this._startReading)) / 1e3 : this._elapsedMs / 1e3
                    }
                })
            }(this.c || module.parent.exports || {}), this.c.parser = function() {
                    function a(a) {
                        return '"' + a.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"'
                    }
                    var b = {
                        parse: function(b, c) {
                            function k(a) {
                                g > e || (e > g && (g = e, h = []), h.push(a))
                            }

                            function l() {
                                var a, b, c, d, f;
                                if (d = e, f = e, a = A(), null !== a) {
                                    for (b = [], c = m(); null !== c;) b.push(c), c = m();
                                    null !== b ? (c = A(), null !== c ? a = [a, b, c] : (a = null, e = f)) : (a = null, e = f)
                                } else a = null, e = f;
                                return null !== a && (a = function(a, b) {
                                    return b
                                }(d, a[1])), null === a && (e = d), a
                            }

                            function m() {
                                var a, b, c, d;
                                return c = e, d = e, a = Q(), null !== a ? (b = t(), null !== b ? a = [a, b] : (a = null, e = d)) : (a = null, e = d), null !== a && (a = function(a, b) {
                                    return b
                                }(c, a[0])), null === a && (e = c), a
                            }

                            function n() {
                                var a;
                                return b.length > e ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("any character")), a
                            }

                            function o() {
                                var a;
                                return /^[a-zA-Z]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[a-zA-Z]")), null === a && (36 === b.charCodeAt(e) ? (a = "$", e++) : (a = null, 0 === f && k('"$"')), null === a && (95 === b.charCodeAt(e) ? (a = "_", e++) : (a = null, 0 === f && k('"_"')))), a
                            }

                            function p() {
                                var a;
                                return a = o(), null === a && (/^[0-9]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[0-9]"))), a
                            }

                            function q() {
                                var a;
                                return f++, /^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\t\\x0B\\f \\xA0\\uFEFF]")), f--, 0 === f && null === a && k("whitespace"), a
                            }

                            function r() {
                                var a;
                                return /^[\n\r\u2028\u2029]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\n\\r\\u2028\\u2029]")), a
                            }

                            function s() {
                                var a;
                                return f++, 10 === b.charCodeAt(e) ? (a = "\n", e++) : (a = null, 0 === f && k('"\\n"')), null === a && ("\r\n" === b.substr(e, 2) ? (a = "\r\n", e += 2) : (a = null, 0 === f && k('"\\r\\n"')), null === a && (13 === b.charCodeAt(e) ? (a = "\r", e++) : (a = null, 0 === f && k('"\\r"')), null === a && (8232 === b.charCodeAt(e) ? (a = "\u2028", e++) : (a = null, 0 === f && k('"\\u2028"')), null === a && (8233 === b.charCodeAt(e) ? (a = "\u2029", e++) : (a = null, 0 === f && k('"\\u2029"')))))), f--, 0 === f && null === a && k("end of line"), a
                            }

                            function t() {
                                var a, c, d;
                                return d = e, a = A(), null !== a ? (59 === b.charCodeAt(e) ? (c = ";", e++) : (c = null, 0 === f && k('";"')), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d), null === a && (d = e, a = z(), null !== a ? (c = s(), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d), null === a && (d = e, a = A(), null !== a ? (c = u(), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d))), a
                            }

                            function u() {
                                var a, c;
                                return c = e, f++, b.length > e ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("any character")), f--, null === a ? a = "" : (a = null, e = c), a
                            }

                            function v() {
                                var a;
                                return f++, a = w(), null === a && (a = y()), f--, 0 === f && null === a && k("comment"), a
                            }

                            function w() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "/*" === b.substr(e, 2) ? (a = "/*", e += 2) : (a = null, 0 === f && k('"/*"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? ("*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function x() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "/*" === b.substr(e, 2) ? (a = "/*", e += 2) : (a = null, 0 === f && k('"/*"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null === d && (d = r()), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null === d && (d = r()), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? ("*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function y() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "//" === b.substr(e, 2) ? (a = "//", e += 2) : (a = null, 0 === f && k('"//"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, d = r(), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, d = r(), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? (d = r(), null === d && (d = u()), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function z() {
                                var a, b;
                                for (a = [], b = q(), null === b && (b = x(), null === b && (b = y())); null !== b;) a.push(b), b = q(), null === b && (b = x(), null === b && (b = y()));
                                return a
                            }

                            function A() {
                                var a, b;
                                for (a = [], b = q(), null === b && (b = s(), null === b && (b = v())); null !== b;) a.push(b), b = q(), null === b && (b = s(), null === b && (b = v()));
                                return a
                            }

                            function B() {
                                var a, b;
                                return b = e, a = D(), null === a && (a = C()), null !== a && (a = function(a, b) {
                                    return {
                                        type: "NumericLiteral",
                                        value: b
                                    }
                                }(b, a)), null === a && (e = b), a
                            }

                            function C() {
                                var a, c, d;
                                if (d = e, /^[0-9]/.test(b.charAt(e)) ? (c = b.charAt(e), e++) : (c = null, 0 === f && k("[0-9]")), null !== c)
                                    for (a = []; null !== c;) a.push(c), /^[0-9]/.test(b.charAt(e)) ? (c = b.charAt(e), e++) : (c = null, 0 === f && k("[0-9]"));
                                else a = null;
                                return null !== a && (a = function(a, b) {
                                    return parseInt(b.join(""))
                                }(d, a)), null === a && (e = d), a
                            }

                            function D() {
                                var a, c, d, g, h;
                                return g = e, h = e, a = C(), null !== a ? (46 === b.charCodeAt(e) ? (c = ".", e++) : (c = null, 0 === f && k('"."')), null !== c ? (d = C(), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)) : (a = null, e = h), null !== a && (a = function(a, b) {
                                    return parseFloat(b.join(""))
                                }(g, a)), null === a && (e = g), a
                            }

                            function E() {
                                var a, c, d, g;
                                if (g = e, /^[\-+]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\-+]")), a = null !== a ? a : "", null !== a) {
                                    if (/^[0-9]/.test(b.charAt(e)) ? (d = b.charAt(e), e++) : (d = null, 0 === f && k("[0-9]")), null !== d)
                                        for (c = []; null !== d;) c.push(d), /^[0-9]/.test(b.charAt(e)) ? (d = b.charAt(e), e++) : (d = null, 0 === f && k("[0-9]"));
                                    else c = null;
                                    null !== c ? a = [a, c] : (a = null, e = g)
                                } else a = null, e = g;
                                return a
                            }

                            function F() {
                                var a, b;
                                return f++, b = e, a = G(), null !== a && (a = function(a, b) {
                                    return b
                                }(b, a)), null === a && (e = b), f--, 0 === f && null === a && k("identifier"), a
                            }

                            function G() {
                                var a, b, c, d, g;
                                if (f++, d = e, g = e, a = o(), null !== a) {
                                    for (b = [], c = p(); null !== c;) b.push(c), c = p();
                                    null !== b ? a = [a, b] : (a = null, e = g)
                                } else a = null, e = g;
                                return null !== a && (a = function(a, b, c) {
                                    return b + c.join("")
                                }(d, a[0], a[1])), null === a && (e = d), f--, 0 === f && null === a && k("identifier"), a
                            }

                            function H() {
                                var a, c, d, g, h, i, j;
                                return i = e, a = F(), null !== a && (a = function(a, b) {
                                    return {
                                        type: "Variable",
                                        name: b
                                    }
                                }(i, a)), null === a && (e = i), null === a && (a = B(), null === a && (i = e, j = e, 40 === b.charCodeAt(e) ? (a = "(", e++) : (a = null, 0 === f && k('"("')), null !== a ? (c = A(), null !== c ? (d = Q(), null !== d ? (g = A(), null !== g ? (41 === b.charCodeAt(e) ? (h = ")", e++) : (h = null, 0 === f && k('")"')), null !== h ? a = [a, c, d, g, h] : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j), null !== a && (a = function(a, b) {
                                    return b
                                }(i, a[2])), null === a && (e = i))), a
                            }

                            function I() {
                                var a, b, c, d, f;
                                return a = H(), null === a && (d = e, f = e, a = J(), null !== a ? (b = A(), null !== b ? (c = I(), null !== c ? a = [a, b, c] : (a = null, e = f)) : (a = null, e = f)) : (a = null, e = f), null !== a && (a = function(a, b, c) {
                                    return {
                                        type: "UnaryExpression",
                                        operator: b,
                                        expression: c
                                    }
                                }(d, a[0], a[2])), null === a && (e = d)), a
                            }

                            function J() {
                                var a;
                                return 43 === b.charCodeAt(e) ? (a = "+", e++) : (a = null, 0 === f && k('"+"')), null === a && (45 === b.charCodeAt(e) ? (a = "-", e++) : (a = null, 0 === f && k('"-"')), null === a && (33 === b.charCodeAt(e) ? (a = "!", e++) : (a = null, 0 === f && k('"!"')))), a
                            }

                            function K() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = I(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = L(), null !== d ? (f = A(), null !== f ? (g = I(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = L(), null !== d ? (f = A(), null !== f ? (g = I(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "MultiplicativeExpression",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function L() {
                                var a;
                                return 42 === b.charCodeAt(e) ? (a = "*", e++) : (a = null, 0 === f && k('"*"')), null === a && (47 === b.charCodeAt(e) ? (a = "/", e++) : (a = null, 0 === f && k('"/"'))), a
                            }

                            function M() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = K(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = N(), null !== d ? (f = A(), null !== f ? (g = K(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = N(), null !== d ? (f = A(), null !== f ? (g = K(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "AdditiveExpression",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function N() {
                                var a;
                                return 43 === b.charCodeAt(e) ? (a = "+", e++) : (a = null, 0 === f && k('"+"')), null === a && (45 === b.charCodeAt(e) ? (a = "-", e++) : (a = null, 0 === f && k('"-"'))), a
                            }

                            function O() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = M(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = P(), null !== d ? (f = A(), null !== f ? (g = M(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = P(), null !== d ? (f = A(), null !== f ? (g = M(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "Inequality",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function P() {
                                var a;
                                return "<=" === b.substr(e, 2) ? (a = "<=", e += 2) : (a = null, 0 === f && k('"<="')), null === a && (">=" === b.substr(e, 2) ? (a = ">=", e += 2) : (a = null, 0 === f && k('">="')), null === a && (60 === b.charCodeAt(e) ? (a = "<", e++) : (a = null, 0 === f && k('"<"')), null === a && (62 === b.charCodeAt(e) ? (a = ">", e++) : (a = null, 0 === f && k('">"'))))), a
                            }

                            function Q() {
                                var a, c, d, g, h, i, j, l, m;
                                if (j = e, l = e, a = O(), null !== a) {
                                    for (c = [], m = e, d = A(), null !== d ? ("==" === b.substr(e, 2) ? (g = "==", e += 2) : (g = null, 0 === f && k('"=="')), null !== g ? (h = A(), null !== h ? (i = O(), null !== i ? d = [d, g, h, i] : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m); null !== d;) c.push(d), m = e, d = A(), null !== d ? ("==" === b.substr(e, 2) ? (g = "==", e += 2) : (g = null, 0 === f && k('"=="')), null !== g ? (h = A(), null !== h ? (i = O(), null !== i ? d = [d, g, h, i] : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m);
                                    null !== c ? a = [a, c] : (a = null, e = l)
                                } else a = null, e = l;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "Equality",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(j, a[0], a[1])), null === a && (e = j), a
                            }

                            function R(a) {
                                a.sort();
                                for (var b = null, c = [], d = 0; d < a.length; d++) a[d] !== b && (c.push(a[d]), b = a[d]);
                                return c
                            }

                            function S() {
                                for (var a = 1, c = 1, d = !1, f = 0; f < Math.max(e, g); f++) {
                                    var h = b.charAt(f);
                                    "\n" === h ? (d || a++, c = 1, d = !1) : "\r" === h || "\u2028" === h || "\u2029" === h ? (a++, c = 1, d = !0) : (c++, d = !1)
                                }
                                return {
                                    line: a,
                                    column: c
                                }
                            }
                            var d = {
                                start: l,
                                Statement: m,
                                SourceCharacter: n,
                                IdentifierStart: o,
                                IdentifierPart: p,
                                WhiteSpace: q,
                                LineTerminator: r,
                                LineTerminatorSequence: s,
                                EOS: t,
                                EOF: u,
                                Comment: v,
                                MultiLineComment: w,
                                MultiLineCommentNoLineTerminator: x,
                                SingleLineComment: y,
                                _: z,
                                __: A,
                                Literal: B,
                                Integer: C,
                                Real: D,
                                SignedInteger: E,
                                Identifier: F,
                                IdentifierName: G,
                                PrimaryExpression: H,
                                UnaryExpression: I,
                                UnaryOperator: J,
                                MultiplicativeExpression: K,
                                MultiplicativeOperator: L,
                                AdditiveExpression: M,
                                AdditiveOperator: N,
                                InequalityExpression: O,
                                InequalityOperator: P,
                                LinearExpression: Q
                            };
                            if (void 0 !== c) {
                                if (void 0 === d[c]) throw new Error("Invalid rule name: " + a(c) + ".")
                            } else c = "start";
                            var e = 0,
                                f = 0,
                                g = 0,
                                h = [],
                                T = d[c]();
                            if (null === T || e !== b.length) {
                                var U = Math.max(e, g),
                                    V = U < b.length ? b.charAt(U) : null,
                                    W = S();
                                throw new this.SyntaxError(R(h), V, U, W.line, W.column)
                            }
                            return T
                        },
                        toSource: function() {
                            return this._source
                        }
                    };
                    return b.SyntaxError = function(b, c, d, e, f) {
                        function g(b, c) {
                            var d, e;
                            switch (b.length) {
                                case 0:
                                    d = "end of input";
                                    break;
                                case 1:
                                    d = b[0];
                                    break;
                                default:
                                    d = b.slice(0, b.length - 1).join(", ") + " or " + b[b.length - 1]
                            }
                            return e = c ? a(c) : "end of input", "Expected " + d + " but " + e + " found."
                        }
                        this.name = "SyntaxError", this.expected = b, this.found = c, this.message = g(b, c), this.offset = d, this.line = e, this.column = f
                    }, b.SyntaxError.prototype = Error.prototype, b
                }(),
                function(a) {
                    "use strict";
                    var b = new a.SimplexSolver,
                        c = {},
                        d = {},
                        e = a.Strength.weak;
                    a.Strength.medium, a.Strength.strong, a.Strength.required;
                    var i = function(f) {
                            if (d[f]) return d[f];
                            switch (f.type) {
                                case "Inequality":
                                    var g = "<=" == f.operator ? a.LEQ : a.GEQ,
                                        h = new a.Inequality(i(f.left), g, i(f.right), e);
                                    return b.addConstraint(h), h;
                                case "Equality":
                                    var h = new a.Equation(i(f.left), i(f.right), e);
                                    return b.addConstraint(h), h;
                                case "MultiplicativeExpression":
                                    var h = a.times(i(f.left), i(f.right));
                                    return b.addConstraint(h), h;
                                case "AdditiveExpression":
                                    return "+" == f.operator ? a.plus(i(f.left), i(f.right)) : a.minus(i(f.left), i(f.right));
                                case "NumericLiteral":
                                    return new a.Expression(f.value);
                                case "Variable":
                                    return c[f.name] || (c[f.name] = new a.Variable({
                                        name: f.name
                                    })), c[f.name];
                                case "UnaryExpression":
                                    console.log("UnaryExpression...WTF?")
                            }
                        },
                        j = function(a) {
                            return a.map(i)
                        };
                    a._api = function() {
                        var c = Array.prototype.slice.call(arguments);
                        if (1 == c.length) {
                            if ("string" == typeof c[0]) {
                                var d = a.parser.parse(c[0]);
                                return j(d)
                            }
                            "function" == typeof c[0] && b._addCallback(c[0])
                        }
                    }
                }(this.c || module.parent.exports || {});
        }).call(
            (typeof module != "undefined") ?
            (module.compiled = true && module) : this
        );

    }, {}],
    2: [function(require, module, exports) {
        function Expression() {
            this._left = null;
            this._right = null;
        }
        module.exports = Expression;

        Expression.prototype.addExpressions = function(left, right) {
            this._left = left;
            this._right = right;
        };

        // Overridable method
        Expression.prototype.construct = function() {};
    }, {}],
    3: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var primitives = require('./primitives.js');
        var operators = require('./operators.js');
        var parseExpression = require('./parser.js');

        var Numeral = primitives.Numeral;
        var Constant = primitives.Constant;
        var Variable = primitives.Variable;

        var Equality = operators.Equality;
        var Multiplication = operators.Multiplication;

        function System() {
            if ((this instanceof System) === false) {
                return new System();
            }

            this._solver = new cassowary.SimplexSolver();
            this._solver.autoSolve = false;

            this._variables = [];
            this._constants = [];
            this._constraints = {};
            this._parameters = {};

            // Callback and its parameters
            // Yes it is possible to pass the parameters of the callback
            // to allow the user to avoid keeping closures around (closures keep objects in memory!)
            this._onNewSolution = null;
            this._onNewSolutionParams = null;

            this._forceResolving = true;

            // Optimization parameters
            this.z = 0;
            this._objectiveVariable = null;
            this._optimization = false;
            this._minimization = true;

            // Callback function when a parameter is missing
            // when parsing an expression
            var self = this;
            this._onParameterMissing = function(name) {
                return self.addVariable(name, {
                    x: 0
                }, 'x').getVariable(name);
            };
        }
        module.exports = System;

        System.prototype.onNewSolution = function(onNewSolution, onNewSolutionParams) {
            this._onNewSolution = onNewSolution;
            this._onNewSolutionParams = onNewSolutionParams;
            return this;
        };

        System.prototype._optimize = function(expression) {
            if (expression instanceof Variable === true) {
                this._objectiveVariable = expression;
                this._solver.optimize(expression._variable);
            } else {
                this._objectiveVariable = new Variable('z', {
                    z: 0
                }, 'z');
                this.addConstraint(new Equality(this._objectiveVariable, expression));
                this._solver.optimize(this._objectiveVariable._variable);
            }

            this._forceResolving = true;
            this._optimization = true;
        };

        System.prototype.minimize = function(expression) {
            if (typeof(expression) === 'string') {
                expression = parseExpression(expression, this._parameters, this._onParameterMissing);
            }

            this._optimize(expression);
            this._minimization = true;
            return this;
        };

        System.prototype.maximize = function(expression) {
            if (typeof(expression) === 'string') {
                expression = parseExpression(expression, this._parameters, this._onParameterMissing);
            }

            this._optimize(new Multiplication(expression, new Numeral(-1)));
            this._minimization = false;
            return this;
        };

        System.prototype.addVariable = function(name, object, property) {
            var variable = new Variable(name, object, property);
            this._variables.push(variable);
            this._parameters[name] = variable;
            return this;
        };

        System.prototype.addConstant = function(name, object, property) {
            var constant = new Constant(name, object, property);
            this._constants.push(constant);
            this._parameters[name] = constant;
            return this;
        };

        System.prototype.getVariable = function(name) {
            for (var v = 0; v < this._variables.length; v += 1) {
                if (this._variables[v]._name === name) {
                    return this._variables[v];
                }
            }
        };

        System.prototype.addConstraint = function(constraint) {
            if (typeof(constraint) === 'string') {
                constraint = parseExpression(constraint, this._parameters, this._onParameterMissing);
            }

            if (this._constraints[constraint._id] !== undefined) {
                console.warn('[System.addConstraint] Constraint already present in the system:', constraint);
                return;
            }

            this._solver.addConstraint(constraint.construct());
            this._constraints[constraint._id] = constraint;

            this._forceResolving = true;
            return this;
        };

        System.prototype.removeConstraint = function(constraint) {
            if (this._constraints[constraint._id] === undefined) {
                console.warn('[System.removeConstraint] Constraint not present in the system:', constraint);
                return;
            }

            constraint._unregisterFromPrimitives();
            this._solver.removeConstraint(constraint._constraint);
            delete this._constraints[constraint._id];

            this._forceResolving = true;
            return this;
        };

        System.prototype.resolve = function(slacking) {
            var c0, c1, constraint;

            var systemIsSameSameButDifferent = this._forceResolving;
            this._forceResolving = false;

            // Checking whether a constant has changed
            // var constraintsToUpdate = null;
            for (c0 = 0; c0 < this._constants.length; c0 += 1) {
                var constant = this._constants[c0];
                if (constant.refresh()) {
                    // The value of the constant has changed

                    // // At least one constraint will be updated
                    // if (constraintsToUpdate === null) {
                    // 	constraintsToUpdate = {};
                    // }

                    // // Updating all the constraints containing the constant
                    // var constraints = constant._constraints;
                    // for (c1 = 0; c1 < constraints.length; c1 += 1) {
                    // 	constraint = constraints[c1];
                    // 	constraintsToUpdate[constraint.id] = constraint;
                    // }

                    // Therefore it will need resolving
                    systemIsSameSameButDifferent = true;
                }
            }

            // // Updating constraints for which a constant has changed
            // if (constraintsToUpdate !== null) {
            // 	var constraintIds = Object.keys(constraintsToUpdate);
            // 	for (c1 = 0; c1 < constraintIds.length; c1 += 1) {
            // 		constraint = constraintsToUpdate[constraintIds[c1]];
            // 		// (Inefficient) Process to update a constraint:
            // 		// 1 - Remove the constraint
            // 		this._solver.removeConstraint(constraint._constraint);
            // 		// 2 - Reconstructing to consider the new constant value
            // 		constraint.construct();
            // 		// 3 - Add back the constraint
            // 		this._solver.addConstraint(constraint._constraint);

            // 		// Should be:
            // 		// constraint.updateConstant(constant);
            // 	}
            // }

            // Reconstructing the whole problem even if only one constant has changed
            if (systemIsSameSameButDifferent === true) {
                this._solver = new cassowary.SimplexSolver();
                this._solver.autoSolve = false;

                var constraintIds = Object.keys(this._constraints);
                for (c1 = 0; c1 < constraintIds.length; c1 += 1) {
                    constraint = this._constraints[constraintIds[c1]];
                    this._solver.addConstraint(constraint.construct());
                }
            }

            // Skip the resolution if no constant has changed and solver is required to slack
            if (systemIsSameSameButDifferent === false && slacking === true) {
                return;
            }

            // Resolving the problem
            this._solver.resolve();

            // Refreshing variables so that their corresponding objects get updated
            // with the newly computed feasible solution
            var solutionIsSameSameButDifferent = false;
            for (var v = 0; v < this._variables.length; v += 1) {
                if (this._variables[v].refresh() === true) {
                    solutionIsSameSameButDifferent = true;
                }
            }

            // Refreshing objective variable, if any
            if (this._optimization === true) {
                this._objectiveVariable.refresh();
                this.z = (this._minimization === true) ? this._objectiveVariable._value : -this._objectiveVariable._value;
            }

            // Triggering callback if the solution has changed
            if (solutionIsSameSameButDifferent === true) {
                if (this._onNewSolution !== null) {
                    this._onNewSolution(this._onNewSolutionParams);
                }
            }

            return this;
        };

        System.prototype.log = function() {
            for (var v = 0; v < this._variables.length; v += 1) {
                var variable = this._variables[v];
                console.log(variable._name, '=', variable._value);
            }

            console.log('objective value =', this.z);
        };

        System.prototype.getValue = function(name) {
            return this._parameters[name]._value;
        };

        System.prototype.getObjectiveValue = function() {
            return this.z;
        };
    }, {
        "../deps/cassowary.js": 1,
        "./operators.js": 5,
        "./parser.js": 6,
        "./primitives.js": 7
    }],
    4: [function(require, module, exports) {
        (function(global) {
            var primitives = require('./primitives.js');
            var operators = require('./operators.js');

            var System = require('./System.js');
            var Numeral = primitives.Numeral;

            var Addition = operators.Addition;
            var Subtraction = operators.Subtraction;
            var Multiplication = operators.Multiplication;
            var Division = operators.Division;
            var GreaterOrEqual = operators.GreaterOrEqual;
            var LowerOrEqual = operators.LowerOrEqual;
            var Equality = operators.Equality;

            var Constrained = {
                // System of constraints
                System: System,

                // Expression operators
                plus: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Addition(expression1, expression2);
                },

                minus: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Subtraction(expression1, expression2);
                },

                times: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Multiplication(expression1, expression2);
                },

                dividedBy: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Division(expression1, expression2);
                },

                // Constraint generators
                greaterThan: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new GreaterOrEqual(expression1, expression2, strength, weight);
                },

                lowerThan: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new LowerOrEqual(expression1, expression2, strength, weight);
                },

                equals: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Equality(expression1, expression2, strength, weight);
                }
            };

            // window within a browser, global within node
            var root;
            if (typeof(window) !== 'undefined') {
                root = window;
            } else if (typeof(global) !== 'undefined') {
                root = global;
            } else {
                console.warn('[TINA] Your environment might not support TINA.');
                root = this;
            }

            module.exports = root.Constrained = Constrained;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "./System.js": 3,
        "./operators.js": 5,
        "./primitives.js": 7
    }],
    5: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var Expression = require('./Expression.js');

        function Addition(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Addition.prototype = Object.create(Expression.prototype);
        Addition.prototype.constructor = Addition;
        Addition.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.plus(right);
        };

        function Subtraction(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Subtraction.prototype = Object.create(Expression.prototype);
        Subtraction.prototype.constructor = Subtraction;
        Subtraction.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.minus(right);
        };

        function Multiplication(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Multiplication.prototype = Object.create(Expression.prototype);
        Multiplication.prototype.constructor = Multiplication;
        Multiplication.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.times(right);
        };

        function Division(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Division.prototype = Object.create(Expression.prototype);
        Division.prototype.constructor = Division;
        Division.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.divide(right);
        };

        var constraintCount = 0;

        function Constraint(expression1, expression2, strength, weight) {
            this._expression1 = expression1;
            this._expression2 = expression2;
            this._strength = strength;
            this._weight = weight;

            this._constraint = null;
            this._id = (constraintCount++).toString();

            this._registerToPrimitives();
        }

        Constraint.prototype._registerToPrimitives = function() {
            var stack = [this._expression1, this._expression2];
            while (stack.length !== 0) {
                var expression = stack.pop();
                if (expression._left === null) {
                    expression._register(this);
                } else {
                    stack.push(expression._left);
                    stack.push(expression._right);
                }
            }
        };

        Constraint.prototype._unregisterFromPrimitives = function() {
            var stack = [this._expression1, this._expression2];
            while (stack.length !== 0) {
                var expression = stack.pop();
                if (expression._left === null) {
                    expression._unregister(this);
                } else {
                    stack.push(expression._left);
                    stack.push(expression._right);
                }
            }
        };

        function LowerOrEqual(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        LowerOrEqual.prototype = Object.create(Constraint.prototype);
        LowerOrEqual.prototype.constructor = LowerOrEqual;
        LowerOrEqual.prototype.construct = function() {
            this._constraint = new cassowary.Inequality(
                this._expression1.construct(),
                cassowary.LEQ,
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        function GreaterOrEqual(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        GreaterOrEqual.prototype = Object.create(Constraint.prototype);
        GreaterOrEqual.prototype.constructor = GreaterOrEqual;
        GreaterOrEqual.prototype.construct = function() {
            this._constraint = new cassowary.Inequality(
                this._expression1.construct(),
                cassowary.GEQ,
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        function Equality(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        Equality.prototype = Object.create(Constraint.prototype);
        Equality.prototype.constructor = Equality;
        Equality.prototype.construct = function() {
            this._constraint = new cassowary.Equation(
                this._expression1.construct(),
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        module.exports = {
            Addition: Addition,
            Subtraction: Subtraction,
            Multiplication: Multiplication,
            Division: Division,
            LowerOrEqual: LowerOrEqual,
            GreaterOrEqual: GreaterOrEqual,
            Equality: Equality
        };
    }, {
        "../deps/cassowary.js": 1,
        "./Expression.js": 2
    }],
    6: [function(require, module, exports) {
        var systemOperators = require('./operators.js');
        var systemPrimitives = require('./primitives.js');

        var Addition = systemOperators.Addition;
        var Subtraction = systemOperators.Subtraction;
        var Multiplication = systemOperators.Multiplication;
        var Division = systemOperators.Division;
        var GreaterOrEqual = systemOperators.GreaterOrEqual;
        var LowerOrEqual = systemOperators.LowerOrEqual;
        var Equality = systemOperators.Equality;

        var Numeral = systemPrimitives.Numeral;

        //
        /**
         * @class  Expression Parser
         * @author Cedric Stoquer
         *
         * @param {String} str - string buffer
         *
         *
         * Simple expression parser with the following features:
         * - parse variables, integer and float numbers, string constants, unary and binary operators,
         *   parenthesis, predefined functions with any number of parameters.
         * - correctly resolve operator precedence.
         *
         * Originaly designed to parse BASIC programs
         */
        function Parser(str) {
            this.str = str;
            this.parameterMap = null;
            this.onParameterMissing = null;
        }

        function parseExpression(str, parameterMap, onParameterMissing) {
            var parser = new Parser(str);
            parser.parameterMap = parameterMap;
            parser.onParameterMissing = onParameterMissing;
            return parser.parseExpression();
        }

        module.exports = parseExpression;

        //

        var operators = [
            // { id: ';',   precedence: 0 },
            // { id: 'AND', precedence: 1 },
            // { id: 'OR',  precedence: 1 },
            // { id: 'XOR', precedence: 1 },
            // { id: '<>',  precedence: 2 },
            {
                id: '>=',
                precedence: 2,
                class: GreaterOrEqual
            }, {
                id: '<=',
                precedence: 2,
                class: LowerOrEqual
            }, {
                id: '=',
                precedence: 2,
                class: Equality
            },
            // { id: '>',   precedence: 2 },
            // { id: '<',   precedence: 2 },
            {
                id: '+',
                precedence: 3,
                class: Addition
            }, {
                id: '-',
                precedence: 3,
                class: Subtraction
            },
            // { id: '\\',  precedence: 4 },
            // { id: 'MOD', precedence: 4 },
            {
                id: '*',
                precedence: 4,
                class: Multiplication
            }, {
                id: '/',
                precedence: 4,
                class: Division
            }
        ];

        var unaryOperators = [
            // { id: '!' }
        ];

        var functions = [
            // { id: 'ABS',      parameters: 1 },
            // { id: 'ATN',      parameters: 1 },
            // { id: 'CIN',      parameters: 1 },
            // { id: 'COS',      parameters: 1 },
            // { id: 'EXP',      parameters: 1 },
            // { id: 'INT',      parameters: 1 },
            // { id: 'LOG10',    parameters: 1 },
            // { id: 'LOG',      parameters: 1 },
            // { id: 'MAX',      parameters: '*' },
            // { id: 'MIN',      parameters: '*' },
            // { id: 'PI',       parameters: 0 },
            // { id: 'ROUND',    parameters: [1, 2] },
            // { id: 'SGN',      parameters: 1 },
            // { id: 'SIN',      parameters: 1 },
            // { id: 'SQR',      parameters: 1 },
            // { id: 'TAN',      parameters: 1 }
        ];

        //

        Parser.prototype.removeWhiteSpace = function() {
            var t = this;
            // while (t.str[0] === ' ' || t.str[0] === '\n') t.str = t.str.substring(1);
            t.str = t.str.replace(' ', '');
            t.str = t.str.replace('\n', '');
        };

        //
        //
        //
        //
        //
        //

        /** @method parseParenthesis
         */
        Parser.prototype.parseParenthesis = function() {
            var t = this;
            if (t.str[0] !== '(') throw new Error('An opening parenthesis is missing.');
            //consume first parenthesis
            t.str = t.str.substring(1);
            var res = '';
            var stackParenthesis = 0;
            while (!(t.str[0] === ')' && stackParenthesis === 0)) {
                if (t.str[0] === '(') stackParenthesis++;
                if (t.str[0] === ')') stackParenthesis--;
                if (stackParenthesis < 0) throw new Error('Too much closing parenthesis.');
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Parenthesis expression doesn\'t resolve');
            }
            // consume last parenthesis
            t.str = t.str.substring(1);

            // parse expression inside parenthesis
            res = parseExpression(res, t.parameterMap, t.onParameterMissing);
            // res = {
            // 	type: 'parenthesis',
            // 	arg: res
            // };
            return res;
        };

        //
        //
        //
        //
        //
        //

        /** @method getParenthesisList
         * Parse a list of comma separated arguments
         */
        Parser.prototype.getParenthesisList = function() {
            var t = this;
            // parse parenthesis content: (expr, expr, ...)
            if (t.str[0] !== '(') throw new Error('An opening parenthesis is missing.');
            // consume first "("
            t.str = t.str.substring(1);
            var args = [];
            var arg = '';
            var stackParenthesis = 0;
            while (!(t.str[0] === ')' && stackParenthesis === 0)) {
                if (t.str[0] === '(') stackParenthesis++;
                if (t.str[0] === ')') stackParenthesis--;
                if (stackParenthesis < 0) throw new Error('Too much closing parenthesis.');
                if (t.str[0] === ',' && stackParenthesis === 0) {
                    arg = parseExpression(arg);
                    args.push(arg);
                    arg = '';
                } else {
                    arg += t.str[0];
                }
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Parenthesis expression doesn\'t resolve');
            }
            // push last parameter
            arg = parseExpression(arg);
            args.push(arg);
            // consume last ")"
            t.str = t.str.substring(1);
            return args;
        };

        //
        //
        //
        //
        //
        //

        /** @method parseString
         */
        Parser.prototype.parseString = function() {
            var t = this;
            var res = '';
            if (t.str[0] !== '"') throw new Error('An opening quote is missing.');
            // consume first double quote
            t.str = t.str.substring(1);
            while (t.str[0] !== '"') {
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Closing quote not found.');
            }
            // consume last double quote
            t.str = t.str.substring(1);
            return {
                type: 'string',
                value: res
            };
        };

        //
        //
        //
        //
        //
        //

        /** @method parseNumber
         */
        Parser.prototype.parseNumber = function() {
            var t = this;
            var type = 'int';
            var res = '';

            // check for a negative number
            if (t.str[0] === '-') {
                res = '-';
                t.str = t.str.substring(1);
                t.removeWhiteSpace();
            }

            if (t.str === '') throw new Error('End of line before number.');

            if (t.str[0].search(/[0-9]/) === -1) throw new Error('Not a digit character');
            while (t.str[0].search(/[0-9]/) === 0) {
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') break;
            }

            // check for a decimal point
            if (t.str[0] === '.') {
                type = 'float';
                res += '.';
                t.str = t.str.substring(1);
                // continue to consume decimal digits
                while (t.str[0].search(/[0-9]/) === 0) {
                    res += t.str[0];
                    t.str = t.str.substring(1);
                    if (t.str === '') break;
                }
            }

            // var value = Number(res);
            return new Numeral(parseFloat(res));
        };

        //
        //
        //
        //
        //
        //

        /** @method parseFunction
         * @desc   get function parameters content
         * @param {Object} func - function definition object
         *
         * A function have the following syntax:
         * - without parameters                : FUNC
         * - parameters defined in parenthesis : FUNC(X)
         * - and comma separated               : FUNC(X1, X2, X3, ...)
         */
        Parser.prototype.parseFunction = function(func) {
            var t = this;
            // function name has already been consumed.
            var res = {
                type: 'function',
                id: func.id
            };
            var parameters = func.parameters;
            // parameters can be:
            // 0 -> no parameters, thus no parenthesis
            if (parameters === 0) return res;

            // int   -> a fixed number of parameter
            // array -> various number of parameters is possible
            // '*'   -> number of parameters is free (but at least 1)

            // special case: if function can have 0 or more parameters,
            // then if we have 0 parameters, there are no parenthesis
            if (Array.isArray(parameters) && parameters.indexOf(0) !== -1 && t.str[0] !== '(') {
                return res;
            }

            var args = t.getParenthesisList();

            // check parameters count
            var count = args.length;
            // there are no parameter (but there are brackets)
            if (count === 0) throw new Error('There is no arguments inside function brackets.');
            // number of parameters is incorrect
            if (!isNaN(parameters) && count !== parameters) throw new Error('Incorrect number of arguments.');
            // check when various number of parameters are possible
            if (Array.isArray(parameters)) {
                var ok = false;
                for (var i = 0, len = parameters.length; i < len; i++) {
                    if (count === parameters[i]) {
                        ok = true;
                        break;
                    }
                }
                if (!ok) throw new Error('Incorrect number of arguments.');
            }

            // add parameters in result
            res.args = args;
            return res;
        };


        //
        //
        //
        //
        //
        //

        /** @method parseVariable
         */
        Parser.prototype.parseVariable = function() {
            var t = this;
            var res = '';
            // default type for locomotive basic are float
            var varType = 'float';

            // first character must be a letter
            if (t.str[0].search(/[A-Za-z]/) === -1) throw new Error('Invalid variable name');
            res += t.str[0];
            t.str = t.str.substring(1);

            // following character could be letters or numbers
            while (t.str !== '' && t.str[0].search(/[A-Za-z0-9]/) !== -1) {
                res += t.str[0];
                t.str = t.str.substring(1);
            }

            // variable name can ends with one of these special characters : $ % !
            if (t.str[0] === '$' || t.str[0] === '%' || t.str[0] === '!') {
                res += t.str[0];
                switch (t.str[0]) {
                    case '$':
                        varType = 'string';
                        break;
                    case '%':
                        varType = 'int';
                        break;
                    case '!':
                        varType = 'float';
                        break;
                }
                t.str = t.str.substring(1);
            }

            /*res = {
            	type: 'variable',
            	varType: varType,
            	id: res,
            };

            // if variable is an array, following character is a opening bracket
            if (t.str[0] === '(') {
            	// extract parenthesis content
            	res.indexes = t.getParenthesisList();
            	// set variable as an array
            	res.isArray = true;
            }

            return res;*/

            var parameter = t.parameterMap[res];
            return (parameter === undefined) ? t.onParameterMissing(res) : parameter;
        };

        //
        //
        //
        //
        //
        //

        /** @method getNextObject
         *
         * next object should be one of these:
         *  ~  (e)     an expression in parenthesis
         *  ~  -1      a number (possibly negative). NOTA: no whitespace allowed between "-" operator and the number
         *  ~  -e      unary operator applied to an expression
         *  ~  NOT e   unary boolean operator NOT
         *  ~  F(e,e)  a function (function names are known, see table)
         *  ~  X       a variable name
         */
        Parser.prototype.getNextObject = function() {
            var t = this;
            t.removeWhiteSpace();

            if (t.str === '') return null;

            // check if next object is an expression in parenthesis
            if (t.str[0] === '(') return t.parseParenthesis();

            // check if next object is a string
            if (t.str[0] === '"') return t.parseString();

            // TODO: hexadecimal number

            // check for unary '-' operator (not with number)
            if (t.str[0] === '-' && t.str[1].search(/[0-9]/) === -1) {
                // consume '-'
                t.str = t.str.substring(1);
                return new Multiplication(new Numeral(-1), t.getNextObject());
                // return { type: 'unaryOp', id: '-', arg: t.getNextObject() };
            }

            // check for unary operators
            var i;
            for (i = 0; i < unaryOperators.length; i++) {
                var operatorId = unaryOperators[i].id;
                var strLen = operatorId.length;
                if (t.str.substring(0, strLen) === operatorId) {
                    // consume operator
                    t.str = t.str.substring(strLen);
                    return new unaryOperators[i].class(t.getNextObject());
                    // return { type: 'unaryOp', id: operatorId, arg: t.getNextObject() };
                }
            }

            // check if next object is a number
            if (t.str[0].search(/[\-0-9]/) !== -1) return t.parseNumber();

            // check if next object is a function
            for (i = 0; i < functions.length; i++) {
                var fLen = functions[i].id.length;
                if (t.str.substring(0, fLen) === functions[i].id) {
                    // consume funtion name
                    t.str = t.str.substring(fLen);
                    // get parameters and return function object
                    return t.parseFunction(functions[i]);
                }
            }

            // check if next object is a variable name
            if (t.str[0].search(/[A-Za-z]/) !== -1) return t.parseVariable();

            // not recognized object
            return null;
        };

        //
        //
        //
        //
        //
        //

        /** @method getNextOperator
         *
         * next token is an operator in the list
         */
        Parser.prototype.getNextOperator = function() {
            var t = this;
            t.removeWhiteSpace();

            // check end of stream
            if (t.str === '') return null;

            // check each of operators
            for (var i = 0; i < operators.length; i++) {
                var oLen = operators[i].id.length;
                if (t.str.substring(0, oLen) === operators[i].id) {
                    // consume token
                    t.str = t.str.substring(oLen);
                    // return operator
                    return operators[i];
                }
            }

            // next element is not a token
            return null;
        };

        //
        //
        //
        //
        //
        //

        /** @method parseExpression
         *
         * next token is an operator in the list
         */
        Parser.prototype.parseExpression = function() {
            // get all tokens
            var operator;
            var objects = [];
            var operators = [];
            while (true) {
                objects.push(this.getNextObject());
                operator = this.getNextOperator();
                if (operator === null) break;
                operators.push(operator);
            }

            // parse expression
            var i = 0;
            while (operators.length > 0) {
                operator = operators[i];
                var lookahead = operators[i + 1];
                if (!lookahead || operator.precedence >= lookahead.precedence) {
                    // reducing object[i] operator[i] object[i+1]
                    // var object = {
                    // 	type: 'operator',
                    // 	id:   operator.id,
                    // 	arg1: objects[i],
                    // 	arg2: objects[i+1]
                    // };

                    var object = new operator.class(objects[i], objects[i + 1]);

                    objects.splice(i, 2, object);
                    operators.splice(i, 1);
                    i = 0;
                    continue;
                }
                i += 1;
            }
            return objects[0];
        };



    }, {
        "./operators.js": 5,
        "./primitives.js": 7
    }],
    7: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var Expression = require('./Expression.js');

        function Numeral(value) {
            this._value = value;
            Expression.call(this);
        }
        Numeral.prototype = Object.create(Expression.prototype);
        Numeral.prototype.constructor = Numeral;

        Numeral.prototype.construct = function() {
            return new cassowary.Expression(this._value);
        };

        Numeral.prototype._register = function() {};
        Numeral.prototype._unregister = function() {};


        function ObjectBinder(name, object, property) {
            this._name = name;
            this._object = object;
            this._property = property;
            this._value = object[property];

            this._constraints = [];
        }

        ObjectBinder.prototype._register = function(constraint) {
            this._constraints.push(constraint);
        };

        ObjectBinder.prototype._unregister = function(constraint) {
            var idx = this._constraints.indexOf(constraint);
            if (idx === -1) {
                this._constraints.splice(idx, 1);
            }
        };


        function Constant(name, object, property) {
            if ((this instanceof Constant) === false) {
                return new Constant(object, property);
            }

            ObjectBinder.call(this, name, object, property);
            Expression.call(this);
        }
        Constant.prototype = Object.create(Expression.prototype);
        Constant.prototype.constructor = Constant;
        Constant.prototype._register = ObjectBinder.prototype._register;
        Constant.prototype._unregister = ObjectBinder.prototype._unregister;

        Constant.prototype.construct = function() {
            return new cassowary.Expression(this._object[this._property]);
        };

        Constant.prototype.refresh = function() {
            if (this._value !== this._object[this._property]) {
                this._value = this._object[this._property];
                return true;
            }

            return false;
        };


        function Variable(name, object, property) {
            if ((this instanceof Variable) === false) {
                return new Variable(object, property);
            }

            // Callback and its parameters
            // Yes it is possible to pass the parameters of the callback
            // to allow the user to avoid keeping closures around (closures keep objects in memory!)
            this._onChange = null;
            this._onChangeParams = null;

            ObjectBinder.call(this, name, object, property);
            Expression.call(this);

            this._variable = new cassowary.Variable({
                name: this._name,
                value: this._value
            });
        }
        Variable.prototype = Object.create(cassowary.Variable.prototype);
        Variable.prototype.constructor = Variable;
        Variable.prototype._register = ObjectBinder.prototype._register;

        Variable.prototype.construct = function() {
            return new cassowary.Expression(this._variable, 1);
        };

        Variable.prototype.refresh = function() {
            if (this._value !== this._variable.value) {
                this._object[this._property] = this._variable.value;
                if (this._onChange !== null) {
                    this._onChange(this._onChangeParams, this._variable.value, this._value);
                }
                this._value = this._variable.value;
                return true;
            }

            return false;
        };

        Variable.prototype.onChange = function(onChange, onChangeParams) {
            this._onChange = onChange;
            this._onChangeParams = onChangeParams;
            return this;
        };

        module.exports = {
            Numeral: Numeral,
            Constant: Constant,
            Variable: Variable
        };
    }, {
        "../deps/cassowary.js": 1,
        "./Expression.js": 2
    }]
}, _modules , [4]);

module.exports = _modules[4].exports;
};
BundleModuleCode['plugins/csp/fmin']=function (module,exports,global,process){
/* https://github.com/benfred/fmin */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.fmin = global.fmin || {})));
}(this, function (exports) { 'use strict';

    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    function bisect(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
        }

        if (fA === 0) return a;
        if (fB === 0) return b;

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    }

    // need some basic operations on vectors, rather than adding a dependency,
    // just define here
    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

    function dot(a, b) {
        var ret = 0;
        for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
        }
        return ret;
    }

    function norm2(a)  {
        return Math.sqrt(dot(a, a));
    }

    function scale(ret, value, c) {
        for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
        }
    }

    function weightedSum(ret, w1, v1, w2, v2) {
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
        }
    }

    /** minimizes a function using the downhill simplex method */
    function nelderMead(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.05,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-6,
            minTolerance = parameters.minErrorDelta || 1e-5,
            rho = (parameters.rho !== undefined) ? parameters.rho : 1,
            chi = (parameters.chi !== undefined) ? parameters.chi : 2,
            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
            maxDiff;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        simplex[0].id = 0;
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
            simplex[i+1].id = i+1;
        }

        function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
                simplex[N][i] = value[i];
            }
            simplex[N].fx = value.fx;
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        var centroid = x0.slice(),
            reflected = x0.slice(),
            contracted = x0.slice(),
            expanded = x0.slice();

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
                // copy the simplex (since later iterations will mutate) and
                // sort it to have a consistent order between iterations
                var sortedSimplex = simplex.map(function (x) {
                    var state = x.slice();
                    state.fx = x.fx;
                    state.id = x.id;
                    return state;
                });
                sortedSimplex.sort(function(a,b) { return a.id - b.id; });

                parameters.history.push({x: simplex[0].slice(),
                                         fx: simplex[0].fx,
                                         simplex: sortedSimplex});
            }

            maxDiff = 0;
            for (i = 0; i < N; ++i) {
                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
                (maxDiff < minTolerance)) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            weightedSum(reflected, 1+rho, centroid, -rho, worst);
            reflected.fx = f(reflected);

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx < simplex[0].fx) {
                weightedSum(expanded, 1+chi, centroid, -chi, worst);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    updateSimplex(expanded);
                }  else {
                    updateSimplex(reflected);
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                    // do an inside contraction
                    weightedSum(contracted, 1+psi, centroid, -psi, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < reflected.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // if we don't contract here, we're done
                    if (sigma >= 1) break;

                    // do a reduction
                    for (i = 1; i < simplex.length; ++i) {
                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            } else {
                updateSimplex(reflected);
            }
        }

        simplex.sort(sortOrder);
        return {fx : simplex[0].fx,
                x : simplex[0]};
    }

    /// searches along line 'pk' for a point that satifies the wolfe conditions
    /// See 'Numerical Optimization' by Nocedal and Wright p59-60
    /// f : objective function
    /// pk : search direction
    /// current: object containing current gradient/loss
    /// next: output: contains next gradient/loss
    /// returns a: step size taken
    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),
            phi = phi0, phi_old = phi0,
            phiPrime = phiPrime0,
            a0 = 0;

        a = a || 1;
        c1 = c1 || 1e-6;
        c2 = c2 || 0.1;

        function zoom(a_lo, a_high, phi_lo) {
            for (var iteration = 0; iteration < 16; ++iteration) {
                a = (a_lo + a_high)/2;
                weightedSum(next.x, 1.0, current.x, a, pk);
                phi = next.fx = f(next.x, next.fxprime);
                phiPrime = dot(next.fxprime, pk);

                if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                    (phi >= phi_lo)) {
                    a_high = a;

                } else  {
                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                        return a;
                    }

                    if (phiPrime * (a_high - a_lo) >=0) {
                        a_high = a_lo;
                    }

                    a_lo = a;
                    phi_lo = phi;
                }
            }

            return 0;
        }

        for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);
            if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                (iteration && (phi >= phi_old))) {
                return zoom(a0, a, phi_old);
            }

            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                return a;
            }

            if (phiPrime >= 0 ) {
                return zoom(a, a0, phi);
            }

            phi_old = phi;
            a0 = a;
            a *= 2;
        }

        return a;
    }

    function conjugateGradient(f, initial, params) {
        // allocate all memory up front here, keep out of the loop for perfomance
        // reasons
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            yk = initial.slice(),
            pk, temp,
            a = 1,
            maxIterations;

        params = params || {};
        maxIterations = params.maxIterations || initial.length * 20;

        current.fx = f(current.x, current.fxprime);
        pk = current.fxprime.slice();
        scale(pk, current.fxprime,-1);

        for (var i = 0; i < maxIterations; ++i) {
            a = wolfeLineSearch(f, pk, current, next, a);

            // todo: history in wrong spot?
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     alpha: a});
            }

            if (!a) {
                // faiiled to find point that satifies wolfe conditions.
                // reset direction for next iteration
                scale(pk, current.fxprime, -1);

            } else {
                // update direction using PolakRibiere CG method
                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);

                var delta_k = dot(current.fxprime, current.fxprime),
                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);

                weightedSum(pk, beta_k, pk, -1, next.fxprime);

                temp = current;
                current = next;
                next = temp;
            }

            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        if (params.history) {
            params.history.push({x: current.x.slice(),
                                 fx: current.fx,
                                 fxprime: current.fxprime.slice(),
                                 alpha: a});
        }

        return current;
    }

    function gradientDescent(f, initial, params) {
        params = params || {};
        var maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 0.001,
            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};

        for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice()});
            }

            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        return current;
    }

    function gradientDescentLineSearch(f, initial, params) {
        params = params || {};
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 1,
            pk = initial.slice(),
            c1 = params.c1 || 1e-3,
            c2 = params.c2 || 0.1,
            temp,
            functionCalls = [];

        if (params.history) {
            // wrap the function call to track linesearch samples
            var inner = f;
            f = function(x, fxprime) {
                functionCalls.push(x.slice());
                return inner(x, fxprime);
            };
        }

        current.fx = f(current.x, current.fxprime);
        for (var i = 0; i < maxIterations; ++i) {
            scale(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);

            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     functionCalls: functionCalls,
                                     learnRate: learnRate,
                                     alpha: learnRate});
                functionCalls = [];
            }


            temp = current;
            current = next;
            next = temp;

            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;
        }

        return current;
    }

    exports.bisect = bisect;
    exports.nelderMead = nelderMead;
    exports.conjugateGradient = conjugateGradient;
    exports.gradientDescent = gradientDescent;
    exports.gradientDescentLineSearch = gradientDescentLineSearch;
    exports.zeros = zeros;
    exports.zerosM = zerosM;
    exports.norm2 = norm2;
    exports.weightedSum = weightedSum;
    exports.scale = scale;

}));
};

var Base64=Require('os/base64');
module.exports = Require('plugins/csp/csp.js');
if (typeof window != 'undefined') for(var p in module.exports) window[p]=module.exports[p];
return module.exports;
