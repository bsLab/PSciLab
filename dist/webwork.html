<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html onclick="keepFocusInTextbox(event)">

<head>
    
    <title>Web WorkShell</title>
    <style>/*
 * DOM element rendering detection
 * https://davidwalsh.name/detect-node-insertion
 */
@keyframes chartjs-render-animation {
	from { opacity: 0.99; }
	to { opacity: 1; }
}

.chartjs-render-monitor {
	animation: chartjs-render-animation 0.001s;
}

/*
 * DOM element resizing detection
 * https://github.com/marcj/css-element-queries
 */
.chartjs-size-monitor,
.chartjs-size-monitor-expand,
.chartjs-size-monitor-shrink {
	position: absolute;
	direction: ltr;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	overflow: hidden;
	pointer-events: none;
	visibility: hidden;
	z-index: -1;
}

.chartjs-size-monitor-expand > div {
	position: absolute;
	width: 1000000px;
	height: 1000000px;
	left: 0;
	top: 0;
}

.chartjs-size-monitor-shrink > div {
	position: absolute;
	width: 200%;
	height: 200%;
	left: 0;
	top: 0;
}
</style>
    <style>/*
 *  Font Awesome 4.7 base64 by @keithorbit - http://www.mactale.com/
 */
/*
 *  Serve the Font Awesome 4.7 as Data URI. No need to host the files anywhere, just copy and paste this into your CSS instead.
 *  Plus, this reduces http requests, and thus speeds up page load time.
 *  Works in IE9 and better.
*/

@font-face{
 font-family:FontAwesome;
 src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAARfkAA0AAAAB3gQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAEXyAAAABwAAAAccdzsJkdERUYAAReoAAAAHgAAAB4AJwIzT1MvMgAAAawAAAA+AAAAYIgyegFjbWFwAAAEfAAAAVIAAALCyQOgrGdhc3AAARegAAAACAAAAAj//wADZ2x5ZgAAChwAAP5RAAGx7AUuRy9oZWFkAAABMAAAADYAAAA2BFEO2mhoZWEAAAFoAAAAIQAAACQO+QooaG10eAAAAewAAAKOAAAIqjpiEzxsb2NhAAAF0AAABEoAAARcGM6ExG1heHAAAAGMAAAAHwAAACAClgIcbmFtZQABCHAAAAI9AAAEsPutKsFwb3N0AAEKsAAADPAAABWe3VxBOwABAAAABADFm5uP7l8PPPUACwcAAAAAAMtR3zAAAAAA0Obl7f/t/ukJCQYSAAAACAACAAAAAAAAeNpjYGRgYGP4z8DAwMnw/+3//5ycDEARZMCkAQB5dwU3AAAAeNpjYGRgYNJlkmRQZwABJiBmBEIGBgcwnwEADVYAtwB42mNgZtNinMDAysDA0sNizMDA0AahmYoZGBi7GPCAgsqiYgYHBoWvDGwM/4F8NgZGkDAjkhIFBkYAuegILwAAeNqNVLFuFDEQnb1d23uCgwgUKZAmDQqgXAMKggZtkRKKSKSJBAiJNkALlcVn8DX8EKLI6SBcgnlee9Zj30ZhpafxjmfsNzOeqS19InyTI6Lqe4ChcdSArpKcQFYWoADy/o8hj4L0e9K/WvTytfb+Ys+vPZTX2XwP+Az9B7bR7EPBHro7Ov7D9xHbjMH7NeHsztvV8X+4O50DnVso5ilsGnG/uQqRS0NJynhNrvuiJHexryduBS7fgOPLYhtBF8/Z9zBJP1N2yN2JzI3K8u5+KOtcVqcgj3tYEUfIZedt2iLfnAdxP9VW5CHVZIhbSuaq0v4ecvJWi9oom92HuN1vyflSWNoMcbtFXnvaiPIQeVjG3DR6PbabGW9L24bznvQ7Jr4bj4mlbhLzxrqm4Ir1/azvrDs3tP5mjIhf1K6TOVGprzqT4hs44qw5MEMNXnqA2xwY/vmOJvaLzt9vp8s3XbwX0Zu818X+m+F/HnzdGWpwwTmJ8o3PE/AO/srDIA86ckFMM+5P+K4gt8bqHfNynXufdZXN8v2E9Q25FfDnqv4StbtXf4Ws3bniPiJ6Kup/1wP6Hpoh5hmw3ccg3rCy63HEew/6HgJPj5hP7me2qwY/or0ohzkE+11NwxzE+3ROzlTYbo70ytCr3qYt5jH3/jTYn+CMj1i/kvXXYj6YJT0o+yny5NncxzWVPklutEm/w/WY/v9s9NhlzqLXZuKOg8jnGda3gp37C1wIzs+xv6XHZl6OBniP/cPI+2HUv/D6aeReAnY3PJQdP78tJOdX1KFfg+O1toi/LdZtubZ8tnP4v63FmeGN+7noTsNcDjOyn5XoZfj8DHtuifUvVfDm96gF/7bgxHvp+wdK+6tOAAB42s2Ru0oDYRCFZ2O8Y2a8JyrrJmgnKj5ACNiHFDYWxhSpg08gPoH4BLKlNkHEQkTEyjKkFCEXsLAyzlmNd/O7Gggo2AiCA3OGA4f5YIaI2qjZE2T5Stax76xPH7Rcf2YpQe00RQ65tEt5OqAzOnd6nDlnNRqL2bHM9KuG1Na4JjWtOV3XTd3WvO5rQcta0wZCsDGLOJJII4d1bGIbeZyggDJqaHghz/bidTLGp31QdloU+kIhFY1qQlOa0TXd0C11dU9PtahVVRAEDuaRQAoZrGEDW3Cxh1MUUYV65IkX/aCYS5M1K2bZLJlFs1DtrVxVDsv3pZfS0cWkTMi4RCQsozIiwzIkgzIg/RKUNgmIJcSGG/zGr/zCz/zEj/zA91znO75lj8HKN3zdN9O85N+X1UEtlBXwJfA90Hztf6jOjnBX+1h3T+THRPBXe98BJuagpAAAeNqdwm1MkgkAAGA0JTRM8gwJURFNkeFHiKTOOCKPFM2QeahknJIior5SmnmI5AxJkcw48wrJ88yQI+IUyXOcKRE5jjzzDJU559zN3ZxzzDnmmnPudttt9//2PCAQCP6/hIMYICXI6UX1EnoZvEHeGceij7X5ZPnM+xz4ZvhqfA/BBWDbcd7xQ0gBRAnZ8Mvy0/od+TP9e/xXT+BPqKCZ0CaoI4AUUBIwfDLzpDYQHpgbqIEVweSwP0/hTg0FYYNavyAEewdzgs2ng08DcARcDj8MSQoRh1hC3AgkgotYPVN0xorEIdnIQeQCcicUHUoOBUJNoZsoOIqCEqAmUNthmWGysN3wrHB7REJEW4Qt4hBNRANoLXonMiNSEWmNXMeQMG2YnShOlDbqKFoWvXwWf/avmLYYa2xMLCNWFLuFpWDLsTrsRhw8jhaniVvDUXBaPAQviQ+ON8Q7E/AJ8oTVRExia+J6Eu0c4pyYACaICHrCTjIv2ZTsIrKIPcTFFFKKKmWXxCDNnmed96RK09BpQJo5HZxecIF7wUiGkdPJUvL+l2IKjEKmNF1kXZyioqgy6jB16xLz0lGm8qt0GpzWRNu6zLpszWJnubPp2fxsWfZwtjXbQ8fSafRy+lSOTw4rZy9XmLt4hXdlMA+W15vnviq8amEEMXiMnXx2fl/+BhPBbGTuFSi+trOYLHMhtDC1UFq4UIQq4heZikHFuOKCYkmxtniXTWaL2Tb2/jXmNUNJeElGSWvJ0XXKdd0/OAiOjLP5Da0UW6opo5fJy/a4Bdwh7twN9I3uck75RPnnCnxFX8URL4E3WQmpFFUa+XC+lO+s8q6iVrVV2QQ+AqKALXBWQ6uBamO1p4Zb86TGXYuu5deqah0ABOAAQ4CnjlTXWucQBgvVQs/Nxpvzt5JuSeox9QP1jgZiw+ht3G1dI65Reyfmjr4p6VuKKFUkEbmasc1As1kMF9PF4hZ0i73lSEKTCCUqiU3ivku7C9z1tFnvce9tShlSlXS3ndje0L4tS5dJZFv3DR2tHeZORqesc01OkEvkU13wLkWXW8FQOB7kPpjsbuo2dH9+yHrY04PocT/qfbSrTFUKlBPfIXv5j7GPV/vWv199CjzVqzAqukreD+6v6V9TZ6onn7GemQdwA6IBzw/hg5xBy4/KoaAh5dDhc+bzxWHe8OILwYtpDVqjHvEeoYw4tc6fpLpoHUc395L7ckcfo+frl19BX00bQAbAoDcc/KwdhY6Bx0rHnhgJRt44bLxh3G3Svsa8Nk1Qf1mbNJvlvx5MLb9JfzMxnTqtmUmdaZ2xWdQWs2X7bfRbrZVk7bBa3jHfzdoo77HvTbP+s/LZaTvCTrOr7Qe/iR1mx+GHhg+7c8Cc9ffRedb8wcfGj+sLSQuKBc8f3EXwoupTxieXM9dpXMIslfxLuXSw3Lg8t5KxYl7Zd+FcfJfZtf+fvwHfCeXDAAB42rx9CXxU1dX4u/e+ZfaZN2+2TCaTmcyaBJIwawhZhrCTgGwCAmJEUQQXVBDEhVEpCuIGilSrRq1Uun12sf9WxW+66ddFaltqN//9x7a2/aq2fq0/WyHz8j/3vpnJJCSi/f7fHzLv3X09995zzj3nPA5zWzmO2ER4cBLHZYNykMhBeQgV1NxWPLhVCJzaKnKnOPoPcVX/plH/+SOc+KSQ5+rA45CQHEy4HGIo2BBNZZJBGUXTqW6UDCb8SHyyuXgHynmjUe9wnj5RrnhHczjuFvLueFiYG4LoIhdNReGPcHhnc8hdq9PVsjqhDg7qaAaP7LDghhac6sbJhFsWxnpTmSzKJBMukZu96dI1l26aDa+pl60qjvVG/SRnssXbhcDpwcTiZqezefHF8IrhmneKM6oDyMv1SQPi+HYOszbkoQ0SF4Su27gA/SHoakMMwSMcxTZ7JhzgXXYnDIOLz6sfqHerHyAJXUOk/lQmrB77yuv3qKePX3XVcSQgPxKOX3UjWhXBkABJWmI1n+qPopU3jqa46rh6+p7Xv6Iei9DZ4UbyEidwnJfr4hZxXEQWJV6y4GYYARSLRqIx2eGCsc7InbiFwByITofb5fbzM3Cim2Qz2W6UlbXJSct0emCg8oGI+t6jydwVbQi1XZFLPqq+FwkoZqFgVpAgmnSncmbl0DdfFTsasi0OhBwt2YYO8dVvZs7Pr+89letdv75XKPSuDxAu7D+xp7lt2rS25j0n/OEiZ1YUPo7tellnEBTz09uOPCVM80bs9oh3mvDUkeb7Bk4XaG6elqHNMe1bnvNxHA9D2sKnoYUJP3Z3E5hQOqbkoZS9eK8h1N/Zqg5133LVknB4yVW3dA+pbxbvy9vxGl34govvnvX6P5sX5MLh3ILmf77+v98sPq2V/QWYuyGuQYNRBYqj8xYR4AkAmlUomGYjSibhVgQYE6/6wErkdChOtUftgQl14pXq/TXt6P03lE7lDfR+O7ne5VUfVU2S2VlnevttU51TtKD30IZaZ0S/AL3c2KhOX6CnSwRX6tZT6NWjiBGmlkSEcjsmbwZ/NUqoa44fV9egxAK0C12PXmbtapy8WdiBGrvRzeqt3erP1bUvv0wM5WYmPqSVtI0A2TD29VwMoKoEIalugY5/gq4sv8DZxEDUlgkI+YPXDx++/qDkDGTmbuzS9y7/xN5PLO/Vd22cmwk4JbXwhvqtN95A3bftvPPOnemN2y++YFa8Od0Mf/FZF1y8fSP5oxb/BscZ6ZqSaL1WqLmV6+HO4S7gruJ2c/dwj3H/xnFCOhVtRg1iHXK4ZiAA67P4kZyKMqgvLQM0Pv5jpj9bfeMXE8pHvWxnm+TBc1FvkaMeAs9hbjRGqMqp5qtTna1MWIYfsIUkwkLKVaLQQxM5i17MClbpkx8NPz3qJNVJ1IfOUuBzp1jdAlvEPAV4sXo+6W49ZoRq0LgRO0s84fpTKpfq709h9hx1k/xkMZij22h/CtEn/mGVZ/iHk8VwbLGy/edMWOSQU2tVF9JaJY/zo/9h//j6MNceVwvx9vY4ytHnqBvnq33F/ORxHz1ltRsFmJM+0C8qzuKok0wYetYEVYUBCE04F//PZ+Gjj6oAMcMsjEDYaW7yuGr3vzhWY4YCzq7rOYt4O/9lzgU+ODMksaEVoWiqB8EpoYdHPRJv9xWn3OFb4rtDPezzUQeK4nupn/xtCYvy3YE2U7/Pp/4S3wdeKPfKkb8Idv4gF+K4sMOKxIaYHtGyo6msfmz5LoekR4Kdlaz+Sv2VVhKKgqtUG4qWSv8VhH5orK9SiobPaPtFCM7G2doMN2sPOi0hbW5mwLYMj4SrDsFBhEqYFzcZ5sVzinlIMQPaMgQoyKhzDD7Wl54MH8NDZ+Skzj9UIWnPbu6bBEmr7pOVc3NtZ0DtR2t/sUBrxbmP12rW3o/c0tK5L9Ll1silKWaERT4ArUmn7NmMy+0SJQu0nmEAcPDFWhDgj26Xne7Z2g5N8exdJ9Tfq/+h/v7ErscPNl9WH7A2bdiydP/xV4/vX7plQ5M1UL+56eDjxXz/pn74w/lP0ZS7TiDfp76Geq8IWJqbLgssfO36TZAccm26/rWFgcuami2BK9QX8cIi26Ax26Dhn1DBEUf3BS5SARcNSCKy5qftm8iPzubn7JaCxc4eKP/x3ANlh/0alTlRDp5/KzI3pm50zTB9WQgNQn87xTwC9YzOB6MxrgR/KtogOlwJCkGwPiWYEQfMSAjWqCjBf9pqWK4xiQJSNEZRR8DvIagF0cGABZwthyZhFWcA/2c9hAXtzgJqDZQBRastSIIgP8Dd4ZOHD5/Eh22mbyiO0HyDvvZel8myf0qrzSzV/cbiRL5pjXcZrBbjzTFJZ51vr7X8L7PNZnzOUhOfZdB773OZzWMT3623mk23hFlirxUSYxet4TC64jcmF/ZlIonVJq8hcrf+crf1joRPNn/d5tyiN16TMZhNRufamsS0Wuw0s7QtLdOXmkwGc/gew5bqxIYdSZ1FS9zmw052dpRwWQ1GZnCzuEs1PKR6loWz+BWgfx1+Srd2IxSE0Q2KksAgrYKwhMprOsvoWxhDdobYLWxO4YEmceeH8xYrITlitRQHUKFNMqjfNkjkKrtlYH3vMOBTAwx00nOti+kJs9g6F6UtdhKoAiPLJO6in3x1uB9gXo7wC7frMdY/AMHD/cuv376cfJ3V/plIKhX5jF1b/zUwYJcKhFPY+mddg46X8K+0HrmyAGghdjLEKKxR6hpAqbQfO2U3bCqAn6r5EcC5AFfFPbgH/Z9unZmYdcX+Yr/JZNZ167AB/yiwOvAeWxq/NmAcUAMUsaWILhpCPEK/UqN45kI9lvDM4r/rENYvNNTq8Cqv94ffpn1TN32N8gG0vZVOsQIUMJxbALXOcQikW5KD0RicOVovgrLwgi/eHj/FzlSSjw/49qCdBpP6sgldpA4A4sPxe3wD8dN5Gi/C2R33zVbvqDOh6aZTdh7OdjTIGB+ksjYdsHdPGcVstX2nBDacrQUFLMjmR4EMZ8Owm8LWDjs7gU1C2xGGNHAYPHhK/cWpgwdPofgpdM0J9TF1vfrYiRPoQvQEupAMqRW4obBQVCHVwVIOfEF10hMn2DwmAF9aDNujDNDOoTRpQZRMkYhT1OgcRwiomxgEU2pHIiJQOw2wMSAKuQ10c2HJ6M4RomOIXPwqD3KYnzM7kAfZTe+Z7Pj9lmLObEcOCFbfhXAHspuLuRYvelwXdqDlEGKFkKOQxApJ0HJHWIce92Ifj9jJpBZ4k80G9KZiRpQ1YB6B54JMN+9QfIpZ2zfN4Dz9dneZjhApEmjlIlwXYCilvbD8VsZMu9uV6KGrD7kkisegaJaynjSAcMrBhKBxlVCUvY4CODAkDf349o5PddyBXo23q8/L9WrOnrGruXpZbkJAmiFKfHFNR1NaLvqHAqN43x3t8Iflxjo1pyioUNcYQwVGN+WqYMXDhRkO4Ki0qwIqTjkJ20UJWLqRLcpXwQs/YFC/afQY1YJVp3MV2MKBvx9WYObgwTOgBg+YTOo39XqUsykOBjcWddCOE1WQdvwM0Jmgrdoep22GGluCYoJo8raur2qhAfVAs1HO+pMPber9DnWQbXIDdovJhHr0erVgQx98SFMxgwmKApjZyg+2oBgJEji8gu5gZBQasoq2G7sVFxlBnYigk8XOk/BCnRegHB6Iek/BRlXzF0PaS3LetOEvNThHDAS9q9qwCReeUP2MM/nb7i4cr2loqCn+oqtqjKxcLeWQUDycHbq0wgyMzSTLnh8MFIesss0WCATrceBDFz1+aqFdLeh1SgTnI4pdUQs/+LBVjyptSlb2oli0B0VDDRYMOFsyQc/7BD3YJZGvIJnJBA9nP6B2HIXUJlmu33//98rI146TCySbxbhPj3RXqN///CiqdggpW24FCBc4NeeNxmP+/ftKKN6mCwxYv19XY9hzH02J2pHvxK6rNt4Ci6ganwlz89gqwFywIQwIy+h+DZQHHLOJCnJSXtgp1pUKntOF7FyQtR3O6j+inLpJ/ctB9a9bblFSdLpg5Sn75n31wr1/mmtsAnA0KzW0fxAK3SsFvmxWZqKHkHIQObbcCtnQkIDV99SvXHnJLYpWRDSl7Oudf+s18sVuhSg0O4Ts36cFmCVkQouga0qUgqJuUn4Bh8ZhpOmz+MfTpemz+JVxXCvlDC6URghM9uAhfph5CCMzJnZDolPMQznBY3i9aKBS3N8ncBX//uHRScLcw7Q+flE1E5itcV7jsdfTNZ6mu72zmkdEaUE4fykl6ILlTFFWkisT3QGkQ1uRLhBvJ1xh8+HDm9WhItuvMUQXvo506j+/XmincJkr0REyl2VwWdnwYLvLaNggxapbcKhB483SdU5xZkCZk4whCrXnWIdyfZv7hEJN7c8f6rpp3Z0LCuq7ss0brXd2vP2NLc/dHE1kdp+/3OyNCtz86GkL7Tj/t+j8dF/f9qJQU2vZNiU15aA+6sV/CLgtdTs7ZihNqaZo+Z6F0ZF9tIVWDIi/cyyOWgc/WBDpFIatBjsd9fQ4r6BmZRgDGgFDr0oEppjvdHzDtW/1KDY677qG2XXPqD9Xv6z+/Jm62Q3XzRuNW73P9Q1H594hlEL9KDW0F+8/ev+04PItgVHkMzCv03TBhvuR+KlPqafu33CBqXNeYBQpDWxZHpx2/9EHkeeVXbteUf+k9StAOH4IcDi2b8GxWIFdOGhcBM5qRf2KeortwyJaBEuVHzxNVzhaBCEUzVykrUEKLwE+z8qaOnFpnDaRlJlNUi2EXSm4J6wD5c+da7B6o56GBg/9Rb1Ww9wJKlbtR27zCZFaZ52zpmV2Sw28ayNCLQNd2O++AXM2j7VnAbfl47QJjtRSKLunAXqbEW/j44DCA0C023CMEuSVFB+5R+jczx4wm2qjsXbHwuXLFzraY1Gv2XwAfVb9qRnANCbVSy3hG/bvvyHcAk4W+dOPPgpZ9YRanCFEvTFHnTXz5NefzFjrHDGA/hlfU1Pq7rUQE3bzZr7GuxbZUALZ1nprwOsOQ5K1nIkR+RTm6T2kEXZWhXPDiVsPJ34rnHN0rTpDaQV+QfghRqvIQfoGdF9GpXCg3dIhOSQHnck00pLIKA//SB5IL0p20B/h6HOEK+b5fJ5Gq3n2LsJ/AX40iHA02zBCu1EpH43FeZWFUz4zBGKWkAbTH8fuBstnw5n9iHHNpb7MoPzxZEhOKv+NXw/8CwTW19c/An/d3TfX1/ewv0d6euDvZva3vqfn+Pr1NFlPj5A/dYuw+1/60XnRzvQHhLfYHl1XxaMoYURAQVQoMeRCBdgc+zbz10VUZyyVjhTT0XR/Cg2m81H8gwhvpJF9ai4dUR2RCP5hJJ9Gg6n+dLSYiZVx0wekLaW60merTdBCgfqDPZHGhZIfoRUoz4LDLX70WoTG5dNDH6F9KRboq4dMUBn+fjStNZuMvAc4zz3Q5hXcxdw2gFigSSyU7oLlnE3B2o1muzFbxlH6HO+AKNEtsS6V8kmimx3zgIbHXILI3D0oEx0l5ar84qVxl/qOcu3M4Y2L7vF5XCKCMxGbnKJ7io4ImPiIs4lHEs+HeaWVRzqMLS5RJ5sVRzDmQ1Ez/mDhEpf6l/C884cfrjUaDZ6d5OG6jA5NkXD09Du8yYIHzDW8ExzFQXBsOiOEb5g+f/i63Koti2d18i0WXa1odNQaoluihrjO2CCGtzboWwRzSPBuj+pCep3DqzNFgrEaFxKJfuvC4et2zLHaaufWe8mvXSGrv4K2qIWKU7vPfVAo3RWjhFvjAjA2mJ7BhQYWcF7zB9zOYCwWVGraQuo8dV64VfM73UJeb25vOPWPhnazLoCeVlcHqV/Qg19f3svzorYXmYDm7+S4Rm0zYXyfYBkUs3KJZa1haKHy8VwCy3rGoqDoAuw+w/AbpHctfF4jRBXzkIa7DJmVq88BPAYPxgd8R3zx3DlXI47uOe3xwaJGe+bUAbMySLGZQSChB8+5Ggcos+KIbyA+wl1dkg3QaOYg1wg9oGIYgEeXkIFRBKrCrirxoW1kwV+OHfvLMTJEUaZTefocSiob05hLb1SSxUtH+clk4BhNihcc3jzM0hF43jFt3rxpd5zOo4ocwyhvWcPllsAskQQgTtko1M5nFTQDUQLNDjNHxRMQ5UOKzgZA+HkJEP9Et5BOweEWEQGr8ZMk5VLSSDEk4p99Nvij6Up01fD3sbu3LRk1vYM8fWkdeSV4sNG6ss5hVfZbRdSj5vrVP8f425Bb59Sbhe5lSO32bvTNiPYThDv+s0MXIUvIj9VuHheHrztHMhqUWD3ehE9aJDWwWP3kBQ3/u2OqyVonRhXeztssqDnkE+AMNph0tse/RXCH+k6Nq94O1FpMb3foLCU6mp1dTtjhL+S4iCsZkFOxFqC9JOicQ/QjwnBH6BqmYazPDrbwu/lOlLZB2lZESTRI5idOh4VIADzwCrGRwc0Le9HOxto5vRcs6FjgQxjpxKZZy3ZtSHZcvK03sUSHir/H1gNhySgKyMWH0y1Jgd+Afn+be61r7iduXNcenLqiO/3QK3O3P/b0uinPTNmsXmkNoHOu6Z3SGZR5Q/pkSrdj4fn4Ncnbs23F3Mtm+MyJ7ydrN3tbhreu5z1Wkz/ia3UmBPJas86sF3i0HCvI27Hipr7UqukdAU/opQcufuySOT7RpdGmPF2f0znOWUJZvCiWbsGxLCVNIYTeLUjQQxHDk3KkRamBbt4hOs+y+GDYZ0a7NiNP12JFCX7xpo62jXf5BIv/nojOJOpx7fUydtktCMlPE7Ox2Vi3zbd/dvLrN5+LY/ZQr4RT2BiqMRsFcinWC4IexxKGiFVpDXaY7y++sUK/Ydm5VjtfOyVLHNiuwerNEoH21nI3wcwlXFbtJoyuY2hTj3YLRhkjiOL/lA6gS6gbA6y6GHiKEqBjONZCaB/oPux22GF+y8AN5YUp/MIOATt8Rk5hSsxRGGdErgVDdll8NWh33OzogJ89uGRJteeDH2dML8Oche8Jo4joNzotuibewWMhVldTR2xmJJoUqQ7LFyUWB/SIFwRD/OmwQBr61d/PhFkk8nmXexQRYZ4YHwzudCj+oLfJko94n/DCX4Tnyq5hjh+phblFSDAbEdo6tKTOwk9ZoV88B+n0BCPE80uz64tffdx21fygs9kWN1isCDvsSaSvDXgtTejcjej+jdtxrdvn4E0ei3nHpdhrR7u1MSaMF3Ah9wDHKaVxDPNu17hBTEfpoLBBrEdpB10Ck4xjN04B/ssEzMaOJKJiQ/SyBJZOCwx0OuhwOejNCUxRFHBoQu8RYfUFU1HIu1Qb27noQsTtCLqrB9ZikIUu/81LLm/SI1hwE46rpCdIoCPGGx9sfM+mja3gN3Vmc7zXy+eynSazVSDDHBGs5vGhPA0VdsOYY8SjQNWQL5qLzCLGvLA0eySVfemJ+RMPuW3bv93+eSLV6aSF85dmBFOt0bRjExvzUyOxKRnibHeSzJSYM1wfwjhUH3ZOGMhpPNcx/Ax2s/bfuV+XuKj3AyYpIpakWk4zyRKBMVaj3lPMJ3KlOJaSh2dhVNDkkrM4/z+1WxNXJPlSu5lPKEvqMB/+H2i3/DH9Y9tdPdrVY/0vj/T/lzaf3f0x2/whfLrxN8fyWfwTwc2HxZ+t74hTzAytneQhQvwp5hEA8T3FTRYzmXuoUhq6diLn8N8rTn7C0ImzsXv4M8ZU40HTO46UJoGL/puQQbmYFr06pNejgN5iVgTwf8B6KLKmnGZPPjfePZqGDFExCprdRx9n71l1JyfsY4nvr/FyqHTMf7ePA7SDjCtogSYKxz5uF/EJHy1BExUBl6r/GF3UeIxMnriezR+joMp9KhPWdQgxDpPExcymWrt6xbEdxdyOY8d24MKOY+iQvdZkjlEGUZMsKOjQ0XLMsR1PoYOKIFdoKUmjBSycn2uhI0lpk0wCSKo0goGsYmdDxVH3OJY2zm8d3Lp1kN96Ko9ygxiwiQ9YP0Q6EoeqJSB5G024tVhQcwWWFAVg8NiA8ZAlcJqxsflCSV4RcPa3hC2cCBReDRfhuGA2JjmTTpQCDB0Beg40C5Dd0D4ZAfKBKAsYMEG0Ze1ba/P4OpdBKv5Wgif2Sxk0OFxQB4S3IkfVgaPhTDr6VgRSbcmTQRdNZXDRVN9XB4YLaBAPpSNH0eBT0eifYyVaidfkPtxjuRwWRPkZUcb0JpqABjocVO+39czvsaqHgmgKehpNISW5Cu6KucOngtFokIhzrziJpqgnx8iUKFRivIHdU425nObup/dM5P5xN1IDfE67fcL/dea9ocar54QC0DuU9wqUDolFGxhK74TGZyL0npwyLAkQAAlA4IjbhTkHqnP5JB7oPB9AlqNvcx/m1JPqavXkUvHq86706ROppM535XlXi0tRPhxEzcGs22ZzZ4PNKBhO9/U9e1KFfp2871b9k3f+8nx/Q4P//F/e+aR+t7ZexX9CP0WAselcNzcfWqXNJheFuXRlkTIWtKn8i5UKNlRfpsDSBHTfRdiUSzDhTP6N7Nx2ZNsA5gKy+oQckNH6pcd2DDMoJ7mejJUQ0zSL3e0aZmBIAMT0OWt8AAWKA+oQv26dOrTOtwRIdTQAxbQP4EKlnOKPXtRK2XGsRrLJUIwoakIg63tvNkMpNvyKOlSEorBvHQqs80EpSyrjz+7Im7k14+VspyU0dJoeT9U9o3SY26Vod5ddKBSQRMXFVj2Vtu+W6O0KkwyCLgv5che5EbPiXdRuELeWe2f3eW2K8x01z1b/oHr82h1TiVvH2wwG1/SmkOQMzVh81f5nNw/CluFVYCfHIbVY7qdirhW8DXy5l68pBrPHptOj19U87BdNhdv2qc+4jdhsabh0YE/7tBUDS5bP7Ii52AYDSVLlvu+GuW5lUoPyRNNKu3jmxNKdTNHu4sdKOI52tzKjBjMRx86pwSyKjj8O/8TT61GXeTxXwhtJ+HZ4XenB69VvjZ1KA65MpQpTaSA6dBLyetAXWQaP+gFkpYWU9GpGYInCfM4qnTOMzURZR2XhAcZWCjodYvmUpZsz40eVr+iZfFKQXmG5ESz3EU5JAY4KqBBz0gcgRoC0MqeCOHZJQKOpkz4gGtFoxOGHPl56ZWxtrD+7YH/Yy/SCMowHBc2OjZOzcsqZLPmp4vUqxQ49XyUprxeuVUzeUzmvScEv6Q3FNWWcGzDuNUadVr5Ey28eX/4k1bBEmaxYqe3MOvFLiveMmjsmaQIkNnmLHawtu0Z2iXloS80EbUlVal6u1awT6FNRaG2CbsLaYHRHi2d9vUbYLdxNNSb0SGTdYmt006lX3cGgW2hz4wuLfrPDKxS8DjO4wtwYeUJr6YQfc6gK41WBuJLUP9MAGM5X+4TcKNVTTQFFy7BbrueMWsQxFNOYcsp5d4miNnbuStfcpR5KrLeiNJUOHX6JDh0MDB0+GDo6ctBhEx1TI36JOWDk4GHy4pcM+kr5ZTg5o3y3PPa6lFY1UY06oUpVQzd57eA4OjpA+KhBX92YMWtibFvGN6JSe3W9Y2scVxGd75HTsC9KgghwUstxirYpsNlAVTNC67GMwhiFPeGlqmnBU8tD7C3+QZODinpH4KmN50MjD/FHhT8AxsTpsUuTHC/tR3Qj5Q8V38GKohylM+EFKP8DOI4q/E+L7xTfYU4tCB40jVbmGijzklKZZwih00KXQ1FaXgVKYYVDAfgQrYF54L+WgCYcA/v07pCjmj2hoKyp7zjloKbDkwzKmiJPWoYTYozkToF2mY37COs/0jxMKCw3XnQnV4o5Mw9qPlOOqUqWqNSucmvObEOVHtCEtZZo3uYJZALL9TSze9NUK6KiAq1UqsbKmGVWit/WI4k9XclED+NtwoiPacNNyrPPKsoapdZLHd5acJ4Zgm4b1zb06IclL4WgE5OOjZvJeNHWAhoOaCVrq5u2ksosVrVP4O1rYd7VTb+F51q7HW2mVeB6+/B4mcoGnx1qVi/7LVRt9wEhc1ih6RaOa0O1rFcHNxcw5vE6Y6kWBMSByMasJBQCZ7JkQeUUcP5mu/nwOPHPirw4d9XRVX/PW917JJNNnw42pNr64m09l7HI5mCgoaO+BuXHtX6wIliOv7j68LKfeewXi6bZHk8qGG1x+bbPCtNopUuxO6e1LuwaDwyjfaK0V0e5T/Io6DE+dwUIybguj5H24+yWgbIw64AmqQzuqg7iMxo/CIEcjQWHWmAvO7l7sBRi/+b49o7CQSvT+6nogbSgWIXnYkFSkiJA1O9H7oqKSDfS+DIQX0kL+SpldKNsJS3kgzL4L1xBF9IVgccvZ8vp8scD4wPQtVHvPZG3Hmfex9+K3EPjxwVgbrLclQA0ZfLspYCxMpkhJsHOaUo/krYx9sCCSGlXEiXqxAor15GZTAZxwUGD17BvHzwOGujbMM7/yodJJaLvTZyp4q/5cNHkM+Wm9VXYdz0qHRqTClAeUtfQ5f0rRbkE3ocQ3eQvUXZ9qCDlTyGPgqIsJctC8576iO38BKfn7ExPOBVD7L5OYDKVAFTQME0/pqStIwRWFS37Bq/63sGVwzX477c/BWS0ENj1ivo79T/U31GBJ9gS2lHdK/i2x/cWreetOviDF/Df1h4cvv8J1KO+pP6WSVf6UQeqoy56DuZG0tCGPhipkt4Qm12Nr5bWGGtMHQsxxGpmqphDkWi0j4ogFLdHIvhOeh/SF42qv8aF1Eycz6f71F+FLw/3Q9wBJqiwPxpdGN0MCfo0fCQtFEr1abwtdvSiCo9KmyhGEQqFSHF7LJWMQfkoUsylZs5M4YL6a6g/mkpH8Z0RnMtEaDP6oAIU6UtD7SgKtUOG4na6oXNpGOM+IUc16FG5YxWsRzv4S92kiEsflEQ1nn7FimIdgaLwnaFsJkKrS39IW2hbNdwiPfIs1Jkv636XB7PUrQruVRpbqJT2Mg1PGCnqQNH+VD7Vj6J0/PoiuABx2+h4Uh5PXySi/grGur+fzkUU+h4b1WUvUHgv0XJUltoiwCHmKOmet+AYhr7ag0m5TK+plIIa2vDwJ6/e0B0SBNlqM0kmK9mdfgJ/bwioLMwRoMpUSnYhzlSfOXf74MbsbDGktzpkvRdOyrqjL+9FhygmAqm4Medpq9YSt2sUOy8vPyaj1orKeBfdXjSm298N6lfvVTRBWqj+XtQPi/4a4qZu9avUbTCg/ntL0rPoHS9LXxHIpekh+QImh0szQHovy5CKluT3zCN3CX8XrtXaN1k7Jms3k3mboCGTtBvnJmwIPjRhsyu2LgRNP7G0HivAWlkhFQCiFBXVmx1guptUt4QqjzAPGoy3k8BEoSx9qS4MdRGNhhrHJ6blnmYirnyhVFJZQRRxV8AcK9DGNNOHscLBFxvVeRNETW1nKpyBPXD2uYVKeyMZqgkG5ILw/ZZab857aYv6PoN09f2WS8Ff24IM4NSikEFbBIZSlPo++gMEXwnRn1RfYWrUyU9C+JUQ/9BD5RiUZJrZr1Riqs8DSqNMZRKc9vKOP17/niipGA0AHFXRQnCrtmWXt3z8Zbu5YHY44GHHdoPB8rrFYJAdlm9YYEjGHQyn//qiRXGYXzQ7FHQJvsIk6nSiqXjIYLWW77agXTnOzLmAWl5IsSQ5HXTKzhLel2Q3zA5XOMWQ52RC0xmr1gfTKCxm+YSdzknNFErCRQbVQthX8IXV9m/f7G2GmcO/aI83e2/6Vhw9A3gUTC9Mp4ZNff382247f0tXPt+1hbrQ1y32r7ajk4WCOqW9praWbHy8vn1JO/zVPz5I0bAyTGnahrc9d9uip55aBC+7xidjdxhOdntBG86LjD8LqCsVywgnKZdZ5DQeIKK6A/TGPEalUjWlT3q7jqnQTjdPjUEIgOR8Xn39d7tgeXmctesd+5D0NS+OOlrUt3792tD9+60H3bbW5u46f5NDxjpCuhd2+7B+1YMvXpH96le+/EDMEHM0xDyxnoCNRFPRi47d7vTAmvOsV27chMQLNgyp37ri8lZhYa4/5/LW8RbRLIUWZToUfrYhmb72J4/tCNutRB+LGGKyW79uzzbNLotA+aBWqgkhjL9hcbBNN+ZmDE4BdnB3zM/Tu6TRe7IRbto5AwPnTJvFozUH9q3Jar5eovkGK5LrvLJ4z/nL589fmxzII9S4Ytstn99QDll/aymkhEvQceepfHmQGcmJxmDX1/jhouQCYGdzoTHKmQQvR2chwFHphAy83WL+yJtdmtBV15tHPoHuQyfRfcVnfY6bvuKL+3atdJDLHQfUWPFvauyAw3EA/RJb0C8P4Nzb2zdd/w2qLvyN6zdtf/uVv/8dT4/7vnKTw+dzrNyl/mR26A/qW8j1Zmh26E3kUv/8JtOpHZSoPLaeq+G6uFncuQD52RbEmmof384IbWeJuwopqNgFbXEwwTRKKY9fAVoIuXjGfubhpA5no7EsINq4efGqDdCXz+B9o71At6PL1HWbpxnspl22Kff812qH45PoJWQ+b23GYBe8YX+Q2CKP3oo8OlRwxOYeVrf/ZuFJdNn1136m54J/m/69u3oKW2g/VRVfOdrNv0r4haLp+Hm2uVBs38xf7Kvvr38L2eQLbSbFrmCD2nbnmwn0/tQ9cxtySz//4h77X174yrVbc1++gM3dyDtwdisMnoIUoiJn3ZMIckkVCU9ELzv4qrta2JXMxteN5tKuZCZcKCLPaDjFNcyQIyHCyZ1zOx+HjUmx0Afag35gkoxGyaJmDWYzeeZUvqenrqGhjoru1ofDHBoZASg/IBygOn+wfVuRUuZ2x/SIcb6bERX5p8pAbBvSI83tFmDJCwNTcv2PDwpyXjLxxCqq/6kW04J5QG/BVv3xYSNGBnCL+FuIqLyFYGPeYsOfHOwvCAOpQv/jxfmKZUBExIyG1eK3ZMuAHhuHj0s2s+lCPUojgtw6m82YNwuPDfbn6Ek2ot1RnCkHXZaAPoe7luPcJSnuyLg3qvZXmDel/bgqXXZcXGScxkiJ3AtW2RFw5VFAHUIDKKcW1MHxbjzE3Hn6JBwN0dzq4KgaDaSphCNWWmA0EuX7U6eY9np+fW+udz3SXhCi1RvIsWy5HAoMQ/mooL0hFAdQgEm8UsMDw19gSWiGQlXwotPM2IkAzwF6vTCgPftLdAysZ2EIqJgsdzXV55Na+CoxhfIddhcCoqZFjGWyfj4Z1NQIkL0SGYSjAJawpVrCgYquZbvFSmr8UOcilz+Z7JsyxFRbTwmiXi3Q++zA5vY1qf5Eb6qjdkYpCdWALqv60SQjXNviziZPoKWucVbXqvN3ztbKGBdYzsXXr3t2anZ+Yx1jMQxbfLQUWF8IEcnibmjpip3/VRZPdRDVb5Id5QT+zp6W7it61+xcsjIZZJnHhGjJNfxLVdldOEVNASGBFSUKsIdFY+loJkrPQCFLTSN0I6pEJ3Hvqhe/N7fvJfXUtJlyLU8EZMAmLLU5Gz1+4yPP3v0u6v/ae+hTpEX9tPrLz+n+bZZFh112xNt4K7FgXdrd3jI/fh4SD9/6zuc3fm4szZ9kWrxOB8OKyicZ7D9+kugmlZPtrNz876qPq/PVx7+raW20di5raWpZ1tmqeanxIVWzwlYyTDTqw4X899QXn30W9X5PYzGm+qMunndRQojyhy8ZTVqdrcQfXsM5xaN8gPJyI1K1VZHyHdUhxho+gxv8ylNl7u5TSlrBbypKsVZJl/nDQ+JR8laZP3zG7Z14iPGHz+AG419AGbSsNBSqaIzpp1ihGm6UhzM6QjWsNJtXLaQTdaExWq+azn+Q3fqXL+LS2k2cRq0yox7EB6Q+vasTOKpDpzNKPAZawopySqeCctaot4BzNv2ghPNWteDocKgFGlYs0DCqb1fOAWucN4iy6ECDaBBQLBnlXS41L3uosJmxYESHPbKad7sRC0J5U0FvHM2iDlTxj/KCpj/dQe27aNIWfOlNNQYlgd4RV4z1MTSPShprHeLdTOqCWe0gP2SvHwY9p982e8gRZsAPaEybrRZ/6Ycao9tWYzHxEuK/5I2mmKUP7Y8UVM4TIbs6DbY2KsbuNTbWTxNIFtxme70zKkW5MbpujjPvj+oYryO/Z93p3Lo9e9YheOLBdXvIYJH5SYE+A3sqd+LSKihH4Zo0al87l8uq7lQqiWpJICk1tnxpVb36TPPDvacLDel6tARcfK4hrR4bLqw/0aX+m4BKFQfgN78+pG5LzvP660PoALxRx+AF89VtIi/zVY2hvBwOF0QmW8MxIBp/lTt6cYsLsMjGXdNWXbPyv0rR9Vp1C8tzlUtXbfxQTuJIQaurfHc8/qZ47L3whAWO3vqOu+Ut3eqWbLDoyrpNZsBwnXTOgrKmgRWUk3LZh/MwAvATuH9yAIyahypPUfmdYaC4TudhxzsFNG+Ro9pYp+lqHOVZtHE5dnplAA/VkFA3oJv0FY0BQuqmOA/glfRF+XRAscQyZ2yKXPvM2TUz53StW3WDcMtvz6lb25q+eEGdy+x1bpm97T6v5/4vbv3OgY3TgDZuOrZjmMk1kcKOY+TRGn18UdTce8OqOkXadmGi/ZouVIP7tlt0fM8ytIasn7fj4WMr7PqpCI/mOjbmLjRMdVNKl3pyMhuiW0U2HWV89pAzWbaykeSHaP4XXva/2Tp7V8+1dzz5H/9RfJsGMZEEKBwv/9P97e3oR/rBg5/7U/ELWl0aiTFqD4fiVVS7rIXrLlF6VVh7pixtFUwHOVs0INpcAeomQQATqVp9XjO6BrQkFfKwt8ctf2MyR8OHqf1PPl+y7Tf8BtWGg24OfydXvFHM96VPcem+vrQIT/xln319Lz3L4+06JpY0/K08qkfdb9DMPMx/4br9+fxplkGgTzbn88VDjE6dV5J/otPMyG3aBTrBzNJmC45J7hIDTZPES9nDJeuQ2bIqpZ8nua2DW5XGpiVbS2/y7Q2yPtbQTAZe9y1uivuKFz5z/MlXXkSJwSdfuQ1dNEBaGgIbZLNBXLLivOnkmcGtW5c0NSpbS2+VkzcE4HCAzPGmxT782G2vPDmIEi++8uTxZ9RHBkgzHHLyBoO4aNmaXo2NwI1YpbzwLsyQDPOymzvOna6S69L6Bz2TK64qGz/ODzHy8/FN/FQZ+EFMJohJBlEtOdgcaD0se5SKA1HxIFYWVW92w14B5WslQKvk/05mkmdQRA7DkdC3uU97qnmL/mGjs6Fdktw7FKPh2kjcaJLczxntyN3QeJ1kNhrulQzdNrfpiMFSSeraSZM2NFcn1ZloUlOn1W2EpDj/gMme5HdhXb/F4XBY+nV4F5+0mx54wCwneb67vRSRbBT5nXxSNj/wcdOXzBiNMCQcAJhPlxzqvd8wKMgTamybZTCYJP8OaY1iurzVYzV80uA8T9J9olZvsCx2TYl6kGysJDXqTTr/ddIau+XyljFJbf2utgY3lotDB2zW2pqra3gyb70TY+f6eYQHb63VBhF1bhqBw4HzIWpeI55L49x1VvLuv5KrLDeym+HCEcY3sokMG2amgGCyU4AJd/OMRUDvQWBhSoAv+EUKaVRpOSaGAnTFhgEqYe1SE0EvqM//+8o1Nz4UThCjggFpxwIRkRC21TkNN979ApqDbkZzcOfdNxqcdbawgESqqwjJHKZE+KEb16xU/+t7Hf7HUXzbTXvdtxwmd6p/fnufbXVcD5QnkUSRlwgV23BG4p75P9lx59v79hX37fzxfE884oyKCCJ5UZSIxYYkfXy1bQ+/ZsW6d/cu6pv3WgXvZnpzndwVo5ZmEL0dTWXo/XyFEoIjHHpKSUzoVzeCA4eyyGBFOtjKYD+xGdNBGt1P6aKklBPVOYEEVDRaM0fDH12cUAcHcgNeT6TRleWjNVPCjTFbIGCO1LW624Sf3nZ9QfCH7GmHNdCcn6aPAnb6+bvC5w88f8M2lzpE909kD2/smOZxR5tjyRV757Y9s+mIZq8G55OLOn4wY8N673WfaHbPFhKBdChsL+ZFyaqT8YLPeP22BQsDiTk1XTJaFz5vYTC8aJbTtXHRnY9PbY73pXE+3ee5rS9dc/2epsjM/dvPv+gIV7G/xGRJu6jN6KodLcbmOgOOjMYwkSyCNmACVfHDbrqPR9NUj5UeiOVdjkmNUvNaldMHgIbuYJKzMqKV4WoOWB1pe8gvbFiVv+2nQpu7tS5iDgRsscbwlJoon3U1RjxeGE80kFicP7LpmbZQaO+KZKwhbvQobTM2htW/sDELuLblX7xs64EvoE4S1U/jNf1KlQutQ3JXzZxEYOECm9977rIFWNZZJbGYt4dD6UBCmO1u/sR13vUbZvygY1Hi0iMXnX/d7DkzI8ENy1c6E4tu82ijFp8y5dF9wqKNLuesReHgQs32MMkxehzwpDMs/ZLceEu+wtCp755pqrciz1WykTyd3lC2EEal01FssBA4MoEeypZwzHH2k8V886yBdZt2bpzvsXfbPfM37ty0bmBW8/N4Dp79Qv7N4n32SWwrk88vvXFBiy25aJbP5fLNWpS0tSy4cenTzxdfxa0vPE0NLNsnMr08KqMagH0kTnG5iMNlwdV4hrMUUJLR7MB+UrktqyTTbsdwHiPBalaZhCa1KFXyUr4Hola4ZdHAk0GlOESFEJmNcVSgV2aBAT7g9Jo1oXTFzDzre4u53vWYl4w4kaJZIHGgZNsgAIhucais/6vhudQGFdCM2aQcgl2PndjajQCVoGiQkumQi4CbHcLO8SjoO3/84/to7rYF86ajGfPxgj8e3HnHAvxHQv4oWTunbEMnq9HOXfhrr6Vmz04l58wZ/gy6+6FHt2/sLR5Ae6L20LRH8LXVmCbjezNbKUYqT480VEJmuARtALFQE2AxwqifTFIuEXaU2pNhBxoC7A7+MNCY6vIklk2oVuhXL/dGH7moYnIxddEjeBAxsQ5mj0z9IhChdSa5Fr0Z9d7wXcxpNJ7KfbdCe9F9NDaR3d86za5vtZB/xfriRHd+o+K4mDWgmKvIHjOzaFTo9JniNu3qDx94RtHEFPGAWigL4bKEZQFcZoiRLKMCjSwfuwGk+ehV5KhtKTeF00lgUF/pUyoKWE5JUyEUbMIU8dSCXPxEIIiuPbaDKrAzmEWsJ+pQCWZLYYDlPzQxKKJkMVcFubigQa5OA+sKrU/l3s3cAnrXkAbKzxVJBx0SnExOh3Z6IXbpU54H7X6EbcnUjkiJqZSuoojR9xeOcMf5b49wC+86nl9+1ytXN6WjdV2z+rbbLcMwJdv7ZnXVRdNNV79y1/L2OApAyyibMxBvx3c98eOBxU+/P/DjJ+qePpGfd++2c4RMY8OiZGbh2jmaZZk5axdmkosaGjPCOdvunZePt2v8y3ZNX6uir2DhXJwf1t5ULsndBfuHGItS+fWYSxLBESt53VVv+nKExHQqSW1cQXBJuqCFstFi3Tw9omJRwLSjDVILjItbpArmbjo+DdSeSiusbj+iyDL8SA+il/VsIY0aV9qvM5n1OpMpodfr7Hp9WtAZCDEYfKJBL8FvF2+FU8PWaZNtcgcO8DYbeenYjiGb7DKkpq+9cGbjOZGpvs2x6PkvnW9LX1M3JXJOY+7CtdPjemdb70y3MsPhcNpEE+C5zQaDuXv+LGrAwuUaKi/8r+tNRh380iZJ9ApSqyQIkkCERslgFES9cbtJ5F28YDNisxETg85DMPkSoyF1TvmvF04VPZlzbjv3+nPXXq2PezxerzEwVX/1Wgi4dUnGI4YBa21uDMR5ordYBMHQ7nZHW82I56O3EpebVIjcsm2EAuMvsfX+4fb5mCHNTJYOn3aHrkVRi2UlNttkFvo+57yoC3FdFznR55iRviYqYEmlK0c4arwMFewZOyrURycx0tc+f357Ox6Il5djHLDRgqKoOX/lPBVGANamcRfT85SpH1Ocj131MrV7IJ6oVrGTiW04ysrfFEuxZx1YM+SjpWUZNT6aJhWopWVa/gBjgAbvthhNBp3BwOuVxY7OP81ovnRW+76ZA7un1bg8Ls+FNdPfmP7spbf8bEf+wPDDN35/+m/bIWzBRldNeEF+5eKHvrWr848dSr9j6UID5nk9ttnxS1PurPX7pnrda10RO9K3uT2uzLQF//nXW+KDje5VU+pc9eGpP0eOO59Snz+dnVJXd9UCz2p3/PHGq3524mszZ3QtbjNsXOFe4zbIssElxh8ZK/NAdfocjAYFupthaRzdK/iSgSJmPxawCz+mWww1E0x1tP1EM49FnZhqYgh5h9G5cf262mSufol+w6K8+tdz2kLEb7RLyfZEzapai2QPGaMBK6mzTJ813SA5Uf939uEGS63e3p7odFjqmvia6XOVuSJB8dpVNYn2pGQ3+kmo7Rwk5xdt0C+pzyVr163f6DQ6iAjpptfwTXUWR2ei3a6vtTTgfd/pR07JAGVb6og1EDWG7FL5vKrYieXOpoDGD4zqgaz/zaiqyI5jAlc+Y2jc4GiEdkZrdkpEzWahjLJupHyowZL8MIc+c9556DOmSS2XcKej6PC556qbhTUfbsNklJc2h97qUh0t2OGo9YmSLnzVTT91CoDMMIvPQONwbr/AzPKdyVLDZF46LfhcBntHu01STC5y0T1ZbBalxmmNBgchHm+t22BsS7fMFgSzZMedaPqnxTZ7Y03YNv2QE9D5apQHrTIKumZfHXEYZvZKohln77mIuEyKZG4MN1sNLp8gTm2ZFuBdzkPTbeGaRnub+Gn15U5sl8yCMLslTaaP579NgbN8haB9nIZxLLAF8RpFSu+rtVcXcrnZHbeLd5dsaFE+Y0ZcMesC1P/wa+pPPq/+1xuh5jeeuexofdDX3LT10OzFvYunXI/WvqQ7vvfAwBUDkcvO5zdtmGPx3aoW//K/rriP349vulAwur+0nY+SKXcvX933wFcM0fDe45c4p1/bY2Btu2AkT/4dcCTG52acwCAJUZsysnanRv79kZWdKBJT1RMj3MirXzgkvKf+c/784+ovinr8DxT/1XOvlHiMT7B5XUbXKAfH4b9+vMGpyVEuWoC3i5z66z/V1vyr55S39k/qr8tClTh/Wr1qkeCx//RfP3UuIXaPsAjdd/rHmsjP2LuCyBirzlE6mMmxtm4oRsMFIHXUC/v/4ZOHB0YN9ANmy+zVkEJZVp/asym0x6ssBn6DmrOp2B3X9oqakg0vbpxdnaSTzSZlF8hMn4BuJtk0tUEWdIpDdH/QlFTNiphXzGblA3gOIC6PoNz1vaNqqRA8NGRWTnOKGQ8UB80KNTWW12RKhFtL3x/qqtKgdWlMQro9M64g5QACVLvsQiUGc+HROBOz4a4p1OKtWLHX3V4Txi71+Tdrgk7ZKwyi8NXX3I7N2GH33eONINOX1d+pN/28JuSwewkS0f957vnXkKZlq37X53AGa95Ec1w4XHN7nV02337N1errT9Q6HKGan6PbUN2XzShScw8QG+bXnn9ODZb0NLnS3VQ910ixB27c/ZR7/HdZgmXTxWhCS6+8rbW3tbUXtbLXY9UKv6cT/Kce4T2W4b9ZPDz/JW2kbd+V12WJJbtO/q4NXdirZaN/76JRa1PoHfRbsyybizeXyMxcTQKvT/f2potPJNjeeh2jxVu4FIMGSlnBj4tYYG+xIDj+LIiel5lsxVJ4gAINkTlB5sU85UX0p9QL1O0dvXzUIdqntUbrnvp8izRVqSUGeRercwh9Bb2S6s+r16n70fUkz/imqX60Nqis3xILzkzOaPR3JGqb3Ld0Xrfi6sz6XmqfM9+fGg6T59SfNKp/a2J8m9wIJ9K7KCPA70xA4FIMX2mgNAEKcnKqBQ5c7LQx4oAZ96dDTPcTe1aziEn5MHa6mZB7bTPODVy6oHid4FDfb1vzyec+uaaNL0BHcrDA1FyqP7FsdVfszy/q2pe06178c6xr9bJnAufOsNkWXIra0BTsSF6+oadnw+XJ4tvqyVQ/XXX9qaZ1hz77tzuPIMGnOOjycyg+9fSRO//22UPr6Jof+efITlEn7GP0jRvA2sqeVCReYjLLEjNPTp89jAVJn9mM9qxn5ofo0+3SnjQ35BcG9vsNpvgLaVN9XeNzbYZGk1TvuP12X1Ojoe25xrp6U/qFuMng3z8uVWPd7bfXNY5Ng/PjsmEXzWZsHM3W5BtbdKPBVH/nnX6jYUyayje+6DpPc5vG8yOZUB5VP5FKtwOUwwb7XjU/ssxjE0sMyZImbPkE7xYo/sZrtybBCjdSOLo4USz4w/7z5nl6Peb4/Hn+OfMCgfkvfnfp8RIXEvUBJD542TE+yDiRnzj+6RklNmTA4PY4ay0ePDNkjje09kRvetKFrqtmRjqmp5c3z+q6c4ozt3RpzfRiPperZkL2py870j1d40DOmaGx0vSK7LP6yMKsc1l3LrR31+zOI1zV+GRh57gWqMKkrOEymDESqb0teuphJ/v6GWwfFKNxi/TCkJHA3WgcjcJQ+B6k3WRoeHwyqOEEVJ7N7RcZ2jMQCIRmdsbrMBHw/LjFgxS7y6mbdx6MWLGQWNyfQn0ad5K/cNWKl15EmzRKpi+tDs349Iu7734GoS4S5I9d9uCRTeg615M3RXtaG+Lm0EzssdQ6PW4DCqT78jjvSTQFCRHx0pwLsO5g1N01q3l5erpjUTLVX2FPegLnLsvloqXRLcJgzZjz8AGh/xKXc3r3kcsuPdI5e9feUK57mTO7kMAgyoq+r9p+fgm2+PJIUHMHLaiB3bNKsnZ7KDPzt9oX5Nh/drwxZrdYdfK1CCWqIKN9f48xGVxuhlGVybqjY6Y6dQY0YICGPJ324sTTfukocKzRPg/YWQ2TkwHuyo8AoRVw5qrHJ8V1Uv421fViF+mMh0L/W3gNiHBSZsRgWqb4pAtWHPXhiuUG2JtEdmfC7iqpSmfJ4CuToKrSxKQUUi5XZNOuFyaa9Jbpo3OeL1HJpbnOzKRznVl4/e3j5pqtnxlzcA4gcX4JcHX8JGAb0qCWdLGhLc7WQNUvfTiolgB7LJ1RzzAjptOYzZTU9yTRUY8QtdBPQ8bpOFJ5YtVwXFHWUtv7h9fa7WvRZnCC4zh6n2pVTqT1eFxT9qPpIal6GHKB4/iH60GytnEp+vEkqk8IjaroXbImuhJZlK3W2hMEVrbWGNXAsMT3S01Fm9ci8/imbcyw1pca4x1tKKRWJ9V1LLUrpuk5Iq0pPaiimco+bhAeq/N4Rs8rlSHL+FZdwlprn6QvxbO1q5UNV0XAUlPGdLgRa9YYOyJUF3OCntvZqJzZrotHZ3kCGOBGPkyXzIh+gT3jdAcsSEpopgbhjI9SFkUPEqMxh5SKirEysUsp3yisZkgMlJKUicaSLEoCusjpoicEjRJht7NgK80O/yX6o6m7UZpe5YVcTHYejl1XJuZiKUR31IJoDQ20yAwtkGGALmqQTnRJlO6kxFeUsSqpGIukFeLOutxRerEO9FqMHuuUp5J1SRmGodB2ubKwpUhueIslhgsCDzWWyHgs2YxmCDrhh4pYbCjh0jgxzGYeJeGhqKwWR4lcVzaTFmOA8lEGMMtLR0l0NtCLzG4SZfwuKvdI6eNuxEKRiwkahFzQrmwqmnVlWeWw69F2diNAvlJpyKDddMYS2QbA1zM0K9TGXpkUm5BMiAbQMaLvKMkwEfJYpmQ7UbIQN2XCMeuQUUhg4akLWuJnGB+1qwh/47VAyGxsFbEgINFmiTbI2E2Ih2CTEYl6CzYYRIStGBEiiDoJEREOV2IkVptB1BNJQFYH0aXgLSGzjydeIkgSRqLAE6PCS3q3KIRrgqIomQgmemSSSMgqmHm9QREsRG/SC8Rk1RmQbNMhvaDTEZ9BqZVqRQEZDWZsEbHZADUKgo5IAQPvkQWeR4S3kJY2URRsuEEnWEQJOiRh3mrR2cSD50kCj4lBL6JmBRMzsiEiSdA6TGSzOQgtt5t43qTDboQIIjUEYV7EXivFSrAOchGDxYFFm07vEgURY7PJQYRancEkC1afFFawYJSw4BUgoUNnqbcLBGNej0WEHFhwCcQM44SRXsRGkyIhem3eIJkVeiFv4jFtPAwjkppFqyRgwUNqBAI9EwzYqJN0iP6zSgYDssi8U5R4BMOtlwRB0JskUagnEia8C8uE2M0GGzHpiYytLvn4ifuIQuwikvQ2gg28UZToVGHktAomvVEUMCwmgVj1Ft6MYe6wgnkiKbWYt9nQGUo+6neRjAwmJOlEUadgFwKwcCGbGUAKw9DrPUQwUkuugsGAEYJxxUgQecTbRF6vw4KeF/UKES2CJJt1Nl7nFDFPx0hwWWsEnd5s1gvIYiWim06s1cRbBQ+MpYEqKNihAj2MkBvgrgZZdRZkssKYSXoJAg08gnnlHbxQw+sJ4rGkgwGF4bZ6oQl6ZJEEm54nomgSiQVGcsndEkI26IIR+WQe5swC04gCMR6ZphIS1yFs1ItCSBR9etjMaB7saKrhBSdPoDbJaXNhsdZh0IVFySwaMAw6D31t4BUdMtuNRLSLvKDzYFJnDSI9wI1k53UeoscAxQABgCvYzCZogUKsOkIwr2uyGYKyDVsJojZAARqJXjSakSzU2glPAHyJYDHEwSUbJZ1eryN2RY8EHa/Y9FCTkdiwyaDTSZKIYVQFHTLy2Aw9gJWGsEEUhm8NfxLqAWTBRFurg2mmkEagAlhWWBQAimtEWLlGrCe8DTpDDAlzvVxjdfFSrY5pGDhHnOLNjG5yUm3CMpavL2m1UhlQP4A5EzvgbBz7loNDEpxu7XMOGmqFP1tcSfU8N0ej+FjsQfy6u/WtuzSFmo7dU2w29dffFO6/QW+VS3cNv4fkkcupJig+tuFBdCA2a+9nNMZS0G9sMB4b2kLWznNw1d+01HQhauF0nQHUSzAdROXfWb6FOt7PcxT1V/M8NwwuKpGHP5I1RWbmHv6Gc2XWFzUh8YfJPJT+fm8kLxwQOCbr6ZIqpuKo0i771lJCuEGuVxVmIW6EU1SFfkRJ4Jr4XzbWqUrRy4zDcYoX/QG9U9cYG7UlyWaOyi62su99VI1B0Fm22xRyBpkd//FXlJha4Of40rdJ6FU2/bj4wAiU/QG3vhcNaGw8NNC7XuDyRU4NaCyVQdq1QRgCqryR712vGdVeXy27OY/aNqGsAufol3X07AQqM58yVLFGKn8ESLM7ZYWgmDYeNCOLFYj6CLroXuh0+YM796qPqI/cSweo9DGde9FFEKB4TaY4vaNiadBFkIl9iargjTIrWuR3E+fzx8bloka0aC6agtXNUtC6BUWTTeSYnXCZm8ZN52Zyy7m1jFNOCRSbxk3IUsPUE38FusShK38NmplfYDI/TAgX8uJSCrz0iUv3Ltt6o9i3c8asXoEf+9loQ++SvXfsXdJrKH02elizbUdWliRMSXDrsr2XPrFU6J01Y2efeKMmQIjzwg1LF6MLm5rdkbo7i5ZJPjEtJJh8nlpf+tJ08bHFS28Qtt9ZF3E3N6HNLFLDJ20j94pbhXe5IDeLu6xkcQRIYT/PyDYgxUaNo2RQ2XhKOSxbFrEh7gynabNr+0yspEdfUsCifBY3cwnP+F71xZv8JGBUpPa4tcZrqidB34naxrjvkK8403fCF4/VHfL5Xq1tHJ+K7D730PKd1y8/sXz16pW7dq54dcU4P8rFofQAqTd5a6zxdkkxgrsp7vtRrfegD/8JHL7ag74YJKqtH5uo+Ma7yw8uP/dHy3fesHL1aih5rLdkJzLP7GNzGlxw1MgJNUtIPyilXXNKfiTl33jsdAG2y7u3YTTl5KMIzZg7sPlw4y1Po/xjb8AeuufXGZ/1JJryzN3dhzf39fh/DPTGUlhzrUxHPUitpjOoy2rS8SWJlWZ6DARRLC2HZKfwj/Y5m0/nN89pR//Ilc1TRb059W31Xfwf6ruO/Orzdu8+j9Sge0qCXVfPVpejL9RH0D3q1RHWlZH3R/ISYTzoxdw6bjO3k9vLHRi1mS8gxmNkexxDzi2lpc5w9iQTbmVyjg3sGyzsupdh21TQtjTplMGYYaasGTmRTJBuZnYHyqI+arEECmFW0JEEuWLIKTFj+ODO0lqJxjxDl6PTPiL482abbCkuvlLHA068Yfme++5YucYobVi25+Dy2Xrzrl1m/ezlB/cs2yAJjc3n7rtvz/INEqTUXYm/bJFt5rxfIL7T61oSS9ddvDCmvVqWJlpiCy9ep72QZSBoOcdLLALgST8fwEOwYw7qAeez8F4ykC/+80vYiLVD0qte4wiHbDlA+W7r5dG0tkV3pVcsXnFD/93pFfVm/YIFenP9ivTd/TMuj52zInX3orZpiO9Ft+mknC0Uduxv2pOcEaaP4ozknqYwe+DBDmPYoWv1EhugReg/AziXU5dePaDDPG/jvWohh47sJ7x2F6OdG/VcAxfhkvTLDGPuYkonZFnjwylnkhIK6lFQoYdI6ROXqUzFIw6Wb4WKQ/SLCoh+UoHq5s/uzKs/Q81F9vwO6lSZdj/m4uQXmpOvqOWjQOnbDZAZylC/Hv+Z+jP8OfVn6qdRJ9XLoV99QFx8YPiffF7zsbssfmSPcKNwI7Ok7ChbptCsX5SE3EuaD4gxm1JVfue49MKNj26//eLhf1z9+mOPXovPN3TZzIbiE+dcsvlgP9H1LMut6Ck+722oi9aghwzdNpNBvaTnmmWru/Ccix/c/ujFRHftpx77zdXFJwwmW5cBX7Do8ObL+of/0bMit6wHz/FE6wK16iUQ121AD3WtXnYNFLZhjIwc1XOeo30jg8nFse+vjOrGy8kyy2u8Hud4vTU3xdLoB3U4ks87DOofDW1W7VYuD8NNYLjVfJV2bb7ybU82/B5fnH3cJ2+ZZkA1BkdZOf40p1lbwFzVDY8yzGIF9tVP9U++gbPbsqu+uuYHxl49a3d07G5Lsxn8sa1jj7WVN5m7ygL2HyZysjO+IFFbBtodW4zLUoymrAVmL98cjqudmyT8TMvM7O5Q+xPerb5tO5WfILDa/SrLhu7VjPQOVowRk9+ND0F/r7JUTIfVSte98A/ODyu+H3bty7kbYTtgqyCrrQ4p1o2z6QYxxD4EBeeR4gwypqt2ZxLrZhfElJmbTJ9pzDuYTqYotilKsWxSPusg3HTF0s2906dNr2u+zKubFlZsM22b0aILkp1YPSy29va21tW0hM71XNCx4OLZy+ag3cKftXGwW7SBUr+0BWFd07w7NgtvV8dUj9aKJet6V0+t8+V07YZZjXaE00dWX2taiHOPhe3JFanmKe6a2o4ZyenL5yWWt2RrOtVvamNmsSvkuosuanwibpIj/bvVy9WbKhHjxpVU6RCluY1sLx0jJBjRFEwymmFV7SMMVCGFHWyVywESLFmcLd/IaUohFG9OZzVJIHfJXhqVrhKZsu8HTBoQfdvnbtv7CcQntvdeZTBaBNMKSyK9etc1s2f19v5szqaOyNvoYanR3RaZv2TBkhuuWXpgulVH6cZLrH6rEJra3D1jQa5v0dTWpQ04P/rtulxo6oVrn83vVkzh6JIbOu21QFM+0L52RsfqBbNmdTtafJ4RLpa+amN2Wqilze50x20mncV8eZs/GpmCGxZGddMjYaer1tvZNXvFgroqvuhF9NZJibZqxmRZnxJZye0UtQFxOd1KVW+1HrdoQ2ZFAFpuV9ZdGSya3qW4Rkcupn33TYZBGm8bsC2iI+baztSehpXLtvnb/Qh35joVM0IWcWqoa/V5m1a1N7fJYdkpWYHmVhqaL7bgFa/07wRaf2psgWglOovotHqjC/u2XHHwM9t3dHa5bHKNsNJuGf0MuRDEeDXiJQI0viWn19dYrjPHxDfVP924eEaw1WcPhn3tHQs+dc6GQytnzHKGECYrDcSMo2bJY0JG0eqV4kZFvf3bV/S3zOyYHgi2tPb171jyCFr0Qk341K3lubFznKEixzHeLv893GOa1YXqvsvj/Oh/2D++vvHf2KTf+a76xHuVe2yMyk0e99FTVrspucvkEQQqblaxC4jurjjVUSexTBR61gRVhaHF1V/opPtw7cjDJZsOCtM5bKZWMoDwRWEmN91asQUacdOdogehSd78URTZov4aN9lPnbJn7C/Z7YJI36d+sGGD3w8/dON3vtPZCT/ym1JI8dGSgzzP8v4sQ/NC1gzNa3/pPhbp36AOs3yd3ymuL4Vgf8nBeA/a9z8p/m/jPNyiqlt2ak+ZkngV1RbZYeGjIU0ogj0BAdMIP0Bkugk1qsRMTCRHFabVH6L8o2b9t/WCJiKP+nWKJWiKEUqUUko2R2KmoEXRAeGOeL1ifknpqR2MenmgZDSZegzIIuQ3F7/IvHxhmLO6LXqCEJWXoD+EiN7itlK7oLqMq7W2AQrxFjQl/FEcZmHFlgHdiChpT9V0mKEfQnVotUuI0lckNZSSfoMuXdIfdRPRTW0e0Nsdkd7E/fiqLTMU/VTH5q7rX9y047d3X/a13Wublyzy67AJi3Ly/zL3HvBxFHf/8M7s7u31snv9pOtF9WTpdHfqOktykass9yYLV1k2WG6YZnPYpth0A6ZjQSBUB0LnifPkkkBCQicQQgKJeEJ4CKEleQhg6VbvzOw1Fdvked////N+bN3O9pnZKb/5le/3jQdvfvDQluZZWnnAEqtpWWJbZ2BeFbMInAuInta9eob3h6H6Q18e3fHivobevZe1993lVru5KTKLsXnFze/ee+Chz5c2+3Yvd9W07VjcWS32TN+yElz01zckK1C+bHMK5P5s6XiJXCtTODL4nrZwvjExuOnyxRZFhWlz01N/mX7h0/19T+1dUT5/rsbEKFmZoea1+2+6//L+Jlw4c7S6ebF1rdXwTGGc7gXLvI+G6kDovxbdeX5nfe+Fl7ZtvMPNKrUVBovQsuzo2/dc8sCnS5u8u5e6qqduXzizWly7/rZcMC9bgNUWoBaSsZDKxLxiD028wORosg8krQPqQR5vxq8fK2wskpe/5IGL6oGWBJ8QiER9USQSmSKmyHiBlm7evaB0/syKmgULy40qWKb0a2wKxay2xmiXL9EUXeDrXyZ+vfiWTZf0mE2akke7q+oDTfPmBpvO728raWgocVVUuCprwLnJZAL9B8kxjp0tczqFYEdFuMOng8DFFeucZhc0NM1fvLW2ecmKgVcTiYNLV19IF9sqatSR4mWR8mkVTrWruW9q9YLa8sqK0mC4M9w0PyIm8LMH4Thhm6HcqL7moXFoClp39CJpkMIAGXheZUiUIlZQxAISjpHk1UGI7zifxKkWqpEmZkhIpnG1CVK1YT4A0oCcEERMWJT0RSPRCPxTYuWKxJSZ4ifHDv6lPrB81gFgcLtMYfONL81snfubAXDP4QOz5lRPm159JNhlj3pb+xNlC2xVxvLm5bGGLSvjWl3IWK9vp/XuaN+2hbHp2/fSW95+e/Nbb22GH/qntXcl561YeMHOhb1NMxYcDnfzZYlSfzXz0xu7b4u1JZa1XrVi5s4ZjYkWj6N+Y8Nle7tDnsYN4U2bumtHbrbX9rTYpvirLGH1FAi1/rrVjdO3NBbTW7f+4Q9b383oWTEWhJoqoirIapnQo3KWGA5o8iNxGDUx1MJQiwIGaZTDIUImT+2EWQ9H6Sd33Di3TIN1r2Vz9x3dN7dM2sCy/qPDSTw2McmjnwTt3xKtDIeBi5O9IHWoK2AUhz666rqL5s276DppI5ZBCt8gkl86keclCmYwDRi0BqQ02YgcgpuAssFQgpjAqKAJgZAy0StIWgApoTaLJ4GW1hSdkO6V+MSlQAMMdDJCsA1SGNsgBYg/iSAFBUj3JqgkxEgEmhx7bwZCAWs/8i9iEoXPEbKczUmYYAryLAEWWgBMkDxL78KhPtnMBzPvHRvHU0xREQ/xIQ1gzsmJ8gfqD+mkwJ6dTsJeiZ47JxMwyeFBjeBmeoeTAvNKId8JlmFTjIRx5xhfq/y4ehpbx8Fx1fb7gpqYpA7Je9Drzvjtxjwocy9NZfJ4hm9Hj39vNj6SouwY9SQ/2JktjMUJGyHxDwjEMEQZxWmZckgCG/yhcHYC5yjJmFBRD/ovr59xbgSAyLkz6h8CM+vL13aKV6xSTi1vjlmQCBNrLp+qXCk+5G05Z+FcNjV1Dd0w8hGJArBXB/+1rqyqurqq7MI/hsCS+ddFxOEEV1Xs53l/cRWX+MxadkPrvL4e8s0fQ2P+VhJjWJ7B0TBLLs3Y65JYPYLSCGXw8Poq4DH5SDgnWC0+DdaATYtg9/pN31/PXCs+s2BJ62KTSnwGLY1AJzSWzdjU+vDr9LUjHvpPoKZz7drOWWedNfJ++kXIb94zLeKMpN8B14Ivp0y5zj2lzvXnsTj+tURuwCOpPxTEMAMRrJnEE0tmxBxnCsFAgoxZRl3wqvjhHY+Ivz6bA/JDSp2e63xrT9+PDy9YcPjHfWufnH6owHqxfwsQbrgDFL1KF4kvih++esH1B5U2+WEFVK7pQ5e/ju6a0Xa4wLpxyYZtF7yK8lgyapL9jf0dxrbyjAHHxYGwThkOLGYzx1oYEnbNWjJNKCzDCAVsRr+mZUhoCxvCGLtZzNm/BbYQbt+bguWj1D5tiRaaGD0jp4toh8rO2zUlRWJfkUJhVjlpZ1CpNygNMiPUasGqyS4Ft0xy6T5AlWNN3pZANLA1EADYelgO0Lu00ChDF+mVQXSDyqxQEG2iBj1K5UAPlaOHmyB6DXrXxEtRria5dN8oVY7KEspjhUh+15ghFlt/ZudjuHMCrxALAxwtT3xiMF+xf9wVWa9BoOck25ghyy4PkoRpGaikzdcbZI6aMLehqUdv7LrtsFFfAdeSM+mXyAZmrrvyasF38jKfcDVGzQJbwZwvrwHkzGyYoWA+BvbZK7UOu7ifnds093BJ19ymHVrpipfIZrd0XUoc/mNx8ftA9jR+yDVfik9mxwWJ58qM5z8KCbNIasLQ91xMQr33x/RBJg/6hQWIsahfBIx6jtgn3vnGtfuXOqzhWy4sr5/W/DJY98YbYEEBFhirs04AA/sS3AE+BncwySs/PTTw0qya3pULWrcGZfIrPwX8p7/MA4SZDJPgg/0AhB7O4INJmAxGNLatLyxFrgy1QfwVToPWAE6P04BEZHq5+Kr4rzv7e8/yeYsqovNm3wqUd96ZvgvjM5w4A4oD2/Cd0BuuYZJ9j2/svqWubpFRcCm1fY+//PjHhz49A6TD8DdnRnO48Lw3KDA6MkrRl6MxzCPZqiUjTVxgJQNOJmgAjRJ0AAfc7OZV6Q81xYzSYGBeEPsZOa/h2V8xVj2YKdjZh8FVckagf220Dl9og2yRni7ZAFQ6K12v5W0GuVKsXgvzeM9JEmU1FnvQY4qMJ2Ce9BgxbvvGknSUA5Mng1bIUXUlUlhjr0gRrfWke3NqobRPgh9LeiFGCCypKwyJTKWyV0+yVzsnlb0XH03NqU3V5WWTFFrxz6eWZ+SibGAARugxxGokTSxeWsqy5jLscQfG7ZLJTMJAiFF41sBmM2AKejnyODp5y+u3BGuD89bP87TQHkGjUlcva+g4r5wzMSoDr2JMXPmeK/aQXd5Ads/raFhWrVZpBFBJjYLF/3kV0Azd5wFpqqyiDLtHP58+0XfLLX1YhKmZN68GdqiCGkEZDs9qUvplBoPMr2yaVZgOh5WChoXPAMMVXTf8+TCEb66FcC0WSpmc7UlOWZEEFUfLNo9kb/JMUCh5cvHizWPJV4iFg0aSLbZNiEnMApkmGl+YQmWgQLn4NqTyBqm6EgalTDo8FySxuQMMAncOkzZ9Nrp+cZp880HJlIHNTxodmg96c3Il4ZbTUyXUKrKmJCHskn0VB2pmoj+MEht3JCYRNhuxF2AOgwOvnkkQGfly2T/scx8lSwcIhwS7sLUW56tm3ezBadsuP3z5tmkdylJlUvOhJom2HclNlY1NTJXNVqlpDRu7erqM4VZNpc1WxTQ1Vm5afv0z//nM9ctpop0O16CnuefUzrxofmXl/ItmbpivqlDdev31t6LN/A23b6+es7OmKBZwOAK1xRZruKaitraiJmy1FNfiY7Gimp1zqrffvu7h7VOnbn+YjP8Sxq2dxOoQVX7efibxVRKXEn0B/mUwHxQvwaZpTg4KGrVa/KlCARKEkrIXky4SNMuTgwRNuFdCqwS9qBTovxJdh5kdExiJUoCeLCglUb/noCezWIToG9kIineGnEOykmXtfZiIkD2N7Z2leO0QefAQJr3sxaSXa5Qwa5G/6lxskb8D0I0z1vQfLd1/P+zV8qCX2MIGCdPmICrWGvVbxE6//724U/MWqPjBdS1H++e0uN6YmMcQce6WsDByvsqRDPrEKfOIX4Nq4W5lQWZPk8dBLS4Jul6t1vIiqWPQK4ifnSKTVCEPO0cto3rzVi82589Cx1EvJYoTCQABR4G646gB4N6bRU0LkeFozH4wVIv9VJ1MzvlFMoczQcm1RRVo6OswN0wfGByYUW87CKYftPUfddd11bnn9M0h22mNADBKeUdfQ0AlpjKuLr8nZv695x8+fH7HvqM7V+pqO14yrm/uGhjoal5vfKnF1dfnakkc7V9eXIY7d1nxcozNkd/r2ONVTnXVlgm6lTuP7qN/l3F6ycW3S3UxNy/pxdHyx2Bk3H5MjJKhMiWmMdIj0Ld0x6R4BaI3k74eDlc2SWeIJFGTC+2YUS/BVN/7XtAuUxqafDg0wOM6AeQnXB6c9jUZlDJ78L178aH6Gah2aMkxI9Gy1iTuPvbBB8cOGn93HYHvcPqRFMeL5xAN5xEe7fidEPOQXfc740Fy8ErT2hZUNRlOUcn2jFezAcl/jM3DsKO1UyTnLpbBao9kvcbEQYIeyQyOUEnJTQxSB1cl0EEmicHpDq6iUXoYyVuSd9jQSGrVQZY6iOo0H0sXGRdJ992j5+jEdwyY+04BcpINL5GR7b3kS5PCAo/U6FGDLR/H6ypLDnQlEl3ffslRR/uHqf6jXOKDY4mDqzCqJlbCHKOnDA6IyXQKvZ9RoDblxvUFhzALWB5zvZJqk6QBLheJKzUp0mTMEs7L2DSbu9JXyO86o54QDNTPKIRywJE+FDmOhokTB7E7IptKJ1G3GPkKdwJahToKlGBoe4nD4uD49LeEmwOi0Zt2Hzwh2calGB8BzQYS1u5CwpxgGu+IwBk8mHsVZGZ4AxgDZROMsuMspeMtp+wJ7AuS8U5IlvQWHQTnKdXiL9VgHXEBoTC4cRbeRsvDoWyq8CivZQ4W9ZYMJ/FTZMRToUO8olgN6tUneYbC4sBJiu7NGta0g3kL6CiVT+OI8xxO/kR726PUT6jXqD9RXyAJSgdcoBI0T+THjo7bZ8ftBybhwz7d+cD/z+4/0/Xjy4uRxw1Zj9QJuE+YvzonpuVxwal8erQgTZ/i+Oj/xevhKY6PzTPGacVlIyBcVCHL/FCupP+cWPCCY+l/TnLwn/8HLxT/edqcnbwBg5sOSQJcgcs01kCeps88Q/2B+ur/fi/537TSnO9KQXu1gSyvgS861iOrGURME3H0I57cCub/SOv+rq1vFK+E0TiI01IrJKcK8pPMPC/bNkECjZKYbyfx/1kbPUOLGrmBSbrxgO0eTpJ2RaekjPb25pzPpHRlvvsAcoc4FERCRyLHl47t003UurEWagIVmxXnBPL5ciwVvixVhSn3NWsyMFhjjNhBYsGOSfbr3DRM1G7iSyB5l1b+cw6yFDnwEpLWiTuAhNGfTWJOzFTWpk36jV34hZCwD0pWnIwKD61wIfdztTJ9nOzT7gnPwUkYxuafrHUb+70O2hPoacSnP5jF4JDw8UNUNeqLnVKk6RmL/p2kQrJ6mqSIaUlaTBLph0kNpwbz0qIbHQSDk5fm89MKkVkcE4I/jy0VMg3gfJIIXk5HIwYf5wthq2M0FI1j6200HrGgo9FGKPlDg4iFZSxmLgnED8TBoYT4h2m4+nsHE4nBVK/bnUylkm53bwrvE2FoGggkMMMFawcw4Ub/0DpMq3CDwSF3yi23Jq1ytB0Cg24FXgkm3A0+Gst5iYyPjgy1QmKdwGKuyRONk/oMxT1xDxKTMK737CiDJoZk8tgHCTcYctMpdwLHpIxS0dliIpVKfXAMYENuyj0yNIabFTOs5GlZx/mGSjAqBGtxAgoR8XUUqTw/LswytBZaoVOS7QpTbWRtWHhAELGnBP0f4/w3x+Xru3DGTpYvMSXlLSW9S8pVYnzOJNLYhJS7sTfAhrEZg0jOnkv/k4kgKa4Ur2jHc+5yCsBMdhDuVNYo7UoxrFSCN1GiRqkU94BD4PCkh4+TFDmCfqRL9oh7lJMflvjbUL5+k80Xlff/yXP3MpMdhAvxy6XnHkJvIA8Fb6J8TXYYzpXySvYOgUOZHIeVkx/G+ZpLXc1EmIVj6mssDwU/2UEmcqZSjzn82YSs4veDcyc9TEn5Oo7ytbOwvsZxWfCTHUT5OmVxJzkMj0/8uOgKnLFJDuOxCLUvuJN8R5wrBRhP64waUubqMe2G/mzyyiLjG2obcGHumd+5EZzqa5NnzgUaJkIvlJ75b3xAcPapvgl+ZiV65s58Pr9j5dOVp6jOjB1akhurJGzWQjQjyZZvdOZW5LUtIFowhmBV47dERJAliG0/PeR2S2TsbneaQEnJcMCbmyYyxQjxn56L3fQCC5o1eAzRNnUF8y57BT4gOhLVj8e2sZYGHyjAvsN5xSJgRmaMsDW1aAQ0RsBgzhGwbXhQ0DDk9cMprAgdlOCtBukBvX5QrweUhFQqIe3SvXkFtzCykCire9EslfOZZyRZx4Jm9pycE5i01gpVBhIWxvczNaChpcrKY/FtJAqEIUmjPIJzQL8yxpmRkTJA9CYWyWP/VG+HpAoawXiqBPA6AY6iRpFUR5Eyot8UroJBMGVOrUhJ2ofaOWskfClSBZK+n57rdrtHyAUM/i2cf1QoPxSVYcRtAZJxMscmfWOO/PbIkQn0t8xgATnujyfDw8jM6R7CMpQvTwtsBFlC5RzdWSGt0OQX0NRAl5jsGsAmfjKbJfqP1pUMdQ3QyVOcgAl8eKALprBrAJn6jvYj4Ve6fJLj1KT51sKCZQ6S9cg8XUiHdPoLaGpCxga6QBLn+xQnmFQ6MT7HgOT4FMcpgmebGE0QfaGCMhD0ONz/GjPxGJJjWk0uqjIbgWGU1K/5mIzJr5A8G6F2drR2zux+2CwZ168kGyZNKAn6Z4809Rzs6TnIfJkxvUvAb/sPrsLskqsO/rx/Nr5Q/G9JWpcM6elr8ANnz6b/jm/tSX9POimFbYg7pDsPjvUZUUm+ptlWKhuP3JLx/yxojGN4coGRxrATGSBV7JrHlo/1vzIZIm4BjY4X0zo1p9brDCzra1m7/dbb12JyXJES8BoSdXj4q3uiYPD74p85r11hMOoUPllHfMPg7sUxlxrHNZPL8A9GkhXPviyHZ0uRfldNLcMzgRZ4w6CWsPkVpC0S+pY3JPmQOmlMi0YLRk7L+LxhJpS1jEl6c6xWJ8pfmLQ1L2q24R94ay753OFzS2+b8ciMW8rPPZxYe+Sy7ge6LzuyNjHUHLz8hp8eXTUvef/hK/o9LVc4Ilvv3XLDPTce3HzvlojjCtDXtaijY9HYn4vOe8CkUpkeOG/ZgdmVWm3l7ANA/tpFcweafAqZUNqyfuqFr392rHvZro3zF/nc3fM27lq6YHBsv7Lgr5AZ93CvOe3oK7EyoaV4OpE3P2Ny2glETUOQnEvkoBfhx+OZmyS+zN0s5ssM4SgyUCuB/aEaJsDBIBbwRMdnDC1c2TzDU2G+iMXcYpZ9FR1Olay0i7/no0yiZJUNBPnhK2kqi/GIMw2oiuvY+rD4bvmR9uFULt9oZZeKrTDr4GpfuUu8yar3VbjAFvOTg/miPAwao9O+19Ig3hSdli/MqsHqsJsa489rpIooP1VL2IyICTVIIFmcaEyKtwAnGA9+SOnD0K2FeidEIz9fSIZ+TuDX4q8DcqvdViW3Xf7A5Tb5lBqrqJR8aWZLvjSzNz78mTjy2cMb0RYwnz380XhC91fOv/HG89ED0GO61q3rslv1VeC1fulu0vVFfNvG/GPQcD2u305eNjOBO5Ts/djjAneXf6NscmvNlEypqmx2qxyXVYz/e2WL2Kr02WLJ0WNQUaHif1s2FYlvKMdW/qwfIm5i371IyaA9TdabMGkXg/9eSSSjIHjq38p8Rs5DG2mWaf9uGhJmnH+XX0/5vCGfTILJ8NTQCV6b4rVJLS9FhWSTMJEpTGYjvvVW6sh7R1JviW+Birfo5FsgNeEenNxEipPx8HpLXCa+lUyCCvAAwGzpupxeBI/FPiST4bkS+8NvofZQB4jm9XvUE8SKj8qEhgNUjnhBOlSQRteg74bSqBSBU19zxuOnSrOFaUMuHcX7AmFBG28T0Pfq0f+kfkiP/mf2GEo/ggRGulefzp0nGzD5bnYrUpn9/BY9dgDf8C2aVmdHvyUYoxhpFAyQK74s+E1/OeGQOMlOZgOkTea/OEiu0+MY3ZEk/sMvovEvlcEblXR1ZqqMWoKltaxvEGcgnCQEPwGMMxtmrIPZCELsaMrkEDbixO01G1WHBvfkg4e6W9c/0HP8o69OxM9aF48XVdSfN3y2r5jYu4p9qG2xKZ+S+/3Ny6YXJaYPNGwUv1qj4/V6t8u39Op7Owd+NhCMXHDCrHC5XOBvsG+luzp+cfrB7bqAzaE109t9DYZhLbG//cPQgI3au9NsiGeZXT6tx1m0rEEhFwLwI5/RVN4cbIkLA2pWzxtxfFS27CxqwWVUDTWd2oH7oYwzxQTyi9KhKBoqFag6TKRQFhMqFzqJymoy/7+qFjrx1EuvPPHIW+/Qf/3bTUaBrdPUCGF7ha/CbLELG5/aIhjLqs87/uChSs+Nw4/8r+oKWlP6Dc/1gsdekJ/7421i3bO7KodkCrpIZuUEmYph6D82RBWyEwbI/Xil/Pky8Pn/riKxbgnJJUR/4JdYP8fpD8zG8TG6sHMyhYKSqeS1I8QQSuNRq3RyLYpYWRCdiNtw5ei13ELm7+T99Rku07HqNbNRgWZ0TMaGwQYwrPak2YSbJ9O2KeE08UrGom7RaBiwW0rAqyctwKHJNVGM5+RX6GYDY9GwKimR7pu8cHnf+JcpE8YdAqYshA8uEMb2JKB+Ri2dAbrgsbveuItM6A1IlCUoP5K4XVwaEncKgkzjLY8WyeRGGW2D5Tcl3r577DXg9hMPgl9Mxwg0GdkbO4JPE3fgSIC5DTfv3VunNgC5HVx334z5muFx14kni356nMiqo9+OHpddzg5RSqoElaES1T1tsLB0SAEEgnMbIPxKmF0phsmVkAQusE7A3AOAeEeb81gjaGlSg6/Em5awZovBIraKrWhjZpeIN7r5SvCvD4zFRaYPwL8qedh+slbZBNpGml0PgHVtICreJao9AfWnn6oDHszL5I5zmJapVKzv5OIEozg9mmQPEB9jKg/q7/FiUDwg4YOw56eThhJWaXakU2afkjeylEbv4HUc871hygdZnxkmHBUlSpjkBG1pFo8Uy+YQjSZ1hEFAATySBTBn5vNkfCmkhW6e7DqOWh/W4xGnl0q4MJ1Ef8eZZNZUMTI4xnJBL/wXai8KxdfEsIMu/T366y2wbtC9BRaOrxUKdPW/Ro7zVIYPhJEwizET5ey8HoUf5zOOfY8kPppiQBRgUmRWdpwz4bEPicVsNHMAYL+p7H/4LNncUlsBhzouTy6sqEWr0dqKzCa2Pj51TlnIQHat5BbmWbKZSX57a5fbxA8uDpaXtEyz25bX4oU7OkTX5tOizu4y2AJlTfMzB7N8NFiXp6XsVJCaSq2mNlO7kSSS+coZ1aPZaJGcYomTS7BAYGRzQQohjECGRgXs/R/HxC6AyyEKWQAXJN6IrZlIBKbgEaDg0SzWUOZeCp4ZpZQatUqhABT+fIMSr9NQQcQwCyWgIPFxk+kLYHB0O24oKhI/530m0LUoffMX4hcZ0CHAo2PiYxlcITDPBK8peEz6H9Kjwc2jlMqaeyFQjFKkLQCyiRQELQ+R6wfPw2BCYL7Jx4ufO4AEQQSEL0zoVUtgDw/4DCyR+PmXJpSlJeeSG8QfmjZLFFVUwSPvG/Myaf3agzrKCNFtNkm+nWOs33hE0xYeJc7uGQhtMp+COO/BDqwpK5JorOQHNLlCMypCpXG0pzPtn9dYs7p5arlvpoZXa+7VsPJBMKXrnv3dwJq9wQpnxnoamxxmyyKbwRUQKhfe4HM0VJUlim0r9PK9SqcGKFv6bs6utyHu007M21WIECJRAmcnMxPut/T4GS4p6YGD9kQiS7uNEkmJE0cCbMvBg4BkxjiWTgWZjcS4JAUIQ+os9OPKcZ+Me4lAS2vqEB3MxLoXPt5ZBEJ4NwSKQABbZwPAPYRP4h9GliYX0gQ4Do9aFCuyWygv1ncFTD6MguDD0EqeaESgfVEPAYaIxFqhx+SjBWDyEIdiJvuFQhKTDonViUTpS745ZpXTtEKpu10Uky88dwgYr4QmdISW264CYO+zL8NP0iLN1M5bMa+2sTQS1po32wMLN59zRfXsZXPi9Mf33z9SplCbjNaT9wMf0D/wIRNUqBXqsg8fEL8Sfwfvf9VRxCf621vDLZ5gdUjlWBUonrpnXV1PY0N5k6dLam8s9h+j96MyTf8uZWJPXSb6O5bp07TI0GPL1LX1nCumrVs/izlDkd591VEJJpaobXN7Q0eoi8ypI2i9dZCVcPioAPZbN2PVC2kBQTJ3YW1pEnSlKfEx2Vc6lW0kGWxIU8FWPUrTKE2jNMEfZKLe2UUjVEWpF20ZtJV0fO+R8bMvF8/sw+6SnMnLaaGEip2LycZkQplYgSrgDXmjBowdgoVbHKqbDeQmdEyYnMaENYYYg0QiHUKLguXzSzsrOwLnuIFZ5b24L9y8yFfq27pg0bnOgDMc6FpzVBFQaACE0BWgj67pCoTR8XMXd21FVy1qTnxcBVgWWH0Vleb66q7y7pXg6QX41EWhW0IsEjWU0fpAR2Vn6fzlK7vLu6rrzZUVPitkIASAocbdmslJfdQ57m0ZWYxJEq68COl/FGfKMbETp/MghXsj0bZT7kwazwJuMgu4zUxSfPddAs+Y0TEA6l3xXawyIOCTKDFKnRC/OYF9bulE8n3xOetByaHyoBXMeF8aIiRcS4IetFGkDp44cRDiX+xRi2SZncTHtR3P5uiBuewogOQ5z6FKL8jkhAKEuEIsCLMxACRweKDbgMMymM3izScOxmO9Z219juR3Qnn2niOikb5bqWTeJFvxgvQNJw5uvA/O37Bpm1SAKHSKNycPnhB6I5mC2McUVdMhKtGddvwIvEVPwCU8N+cbLXEzeSXfBtQvBYNRyxJCzRxGO5MQE3t6/pZqX3do176oXl2k1kf37Tq0rl1ycoEJmBy+tnXWs/RjaWrJgwcu6u60czIZZ+/svujAg0ukgTAjI1E53AwfHg8tHoMnMM7jYeL+uCihjHCXS6EaRZPJSdT98s6edIHjJyYDOUnYHJM9bZihT9qgI0hiSwE3ARchMl1Bet4wMUuxOHqIMPNJv3PIeDFMfMqHkKw3J+9THsjAXeKAe49prDNtPIoD6jPdGsei5ZyiPehkgMDoQMmbnP6+Wq5maDGh0o5S266XJru969yNAzOajYyhRK+xGNSsUDd1c52t52CPFoS1KpCiGXQXK33zXjGlV3CgF/KqjZbHdo6QqYl29z/o3FbVOMsj93HqGqvSPXvqNL6sApfK41LxsBdwCtwmrKNumWSLrCxgtzViiZWWcayEbISWF7kUzn885scGp0EinALrzY8v2GGEWjHJKdSqhIZdLP63+Ckt0yoSBvWQUg8u7O06ARYBVmtkJCkVJL8Vb3qiq1e8VK8cYhT4oxmBbTFQJAQjSGqhcceCH10j5LiPPpLWGID2CLEQaixo60F/tIfgfsveuFd8/HFNkaPuwZfFx18W/wv/3sqMbPhhY1MZHE6zdKLO7RmZQT+H/8CMBZ2dPxnr+4IHHCoQj9WiVVUWw19GIlAKzTv01RsFQXwFRARhI17FNQgC+IVQCy8bp8m8Gp8FEXRdrYDvaJAuhu+cEndeej96dSgD1G9RZEDxC98PX0Gvkx6HHgsi4iskI/T08e/HucJZk7L5CroO33Gm94N4LBvhIlEDKMa9n7m6oDRCvpBgfAUAqQbGZxa8MxHffpI6INWvyFbE+G9QOaFc0kcYr07+jFTC+A8G90xSBwkSL2IgLSyOWhaG6vEJbCQaEDwh4KHZANOvH7mqCq43v/C85lEz6GfAppr0RTqxjk0m0/+Z/hn98KPpTz6MRq8SP1kP1kH3U+Dtk2vvuYe0X/VoQvY/GWw9jwIKHo5FzxU8cQ8Q2A/Ef428l54+A5QWg++DjzqGZzYwzwWHZ6Lh7SXxK6AC62+4+26wEJT+JFNXek7iMllc0FelcagKyFAthSbg8zqBpWCpXLDoNEWylm1DC4hnQXzplDQqbTTKGY1y9R5xu1grbt+zWqFl5EY0Yvaa5XLd+vavbpKE64bpR986Or1B2rnpq/b1OrncDHq1PPMRGZtGBsVBsxwqVl97//3XrlZA6aRR0K9fudcILyfS+ve8u6djD8jpu73fIwfS5xv3rlyvF4y81P+J3OCbwD+GfThRo8ksdKISGzDjzhOeuTOSQYYKLW8GIxjJCcJ19hzOOX67mBprw5LW9URaySMAB90yvdlN6anM36nsIBK0LzBn4p3AWSJR+hOV/yNnMITATyQo37NAywf4frgod2tFet8ZrTlEh4JE9iSdxRmbsEJkz+Q/nawrIfWUwl6fk6dpdzY16U/OzwXk8c4m5MNwhv3CfEz2A/J5AL+bLFnIac1RDiqKLa05fxdM7klsQ4Q7AhDZIwjDwI/ZLchxM8NLJyZyQkLJTRg8pBGf/VhrNGhue08FeE1SYwQXsxt/+Ffxg9u0CiWveRmseoMjJ5Qq4Cr0hpSi+L0fg5kaYETneaB67zaNwai5Dbj++sONLFAqyVHuDfHelzW8UkG/Mt5HMm+3c4xjBiFDOSEtImuJCewRj2O3KpfH7dbrDboJjALpm/lZPEgIvBBIJwOCXIG+ZWw0KnuJ/TWR5dC3VLD52QIP0pIaOIbqlgtlJWCi/bKYjWih0JR+XnwebIb9aEDGnCzpo2jc7udj9JUjuwNbAvvqBgbr9gYC9JVoZy/e2RdgmsTn0xiDFt9Vi6/Gd9Xi++G1I7sC6KbBAXTdlgB9OIBuQjt7A1vG1Iu01h8fpjyJ/6rkJEsnJ/VYlVQKYz1U6TFcqlWTaBTO4MuFlZIjRMtDSwh3eSeuZCHXKhzK6ejFGkLFKl1J7y+kXaXA6DBq7Gr2YqoI+1aXgzyIO/YA9+Vph+mTfEkKB1qZ5HL1oEIPEqkS3mAHCb4FfXIHfV8Aa0l5oy6lgslAwAWSZrOYdBN970m0hlOjIRK1NiGrr8m4D2KaRYOHSIgxN3b5SpX4HWIKPVRM2Q3olWJKqxrUKBQsJWhH7p7lFtFzQdIVDMCkKqU1CmNlAX+BLABCeVlgQjc8DjdmZvfK32TEASwTbSz8ip/BjRlZAF0jXXybQF9W+D3z474MjeymzDe1cNgRnUAqkPpT0AaQIXnSTfSLu/GW2rpe8KbWIL5v0GgNwGcQh6FbHEoP0clVRUW3FHUVrYKDYwDDHrmltrcO/IcG36LV4FvSCegGqG+KQ7B3FbrjlqKiVb2n6vc27FOb8bXkZK4sk1IcSAqEST213QQ2P/2JVBHQfB3vUGtC45p9L0CLiFBpMb6O1By6TmANsKwwJ/l8BHB8tCI76BQDr5aVVBTxWAhiDDJpbwIU22egF32UQWeoZM/PDpxV51Her9RxMjNd0R9+4KoStdoOg2Oq6wl0PRoJerGJZDDUuqb3gg1NT/1JTSusYO2e2qrBMgMLU2MqKz/+Q/RlecpJbCjAAAxo8gYZb8Mx9Fw4eAMH2ogU7S5wK5zgdAhSySSYn/6vUQqtyN8njonS1XDNuCk5z+GEUa4qMxgdUqdB1TB+pBhfS8z5vEVMCW2CmLLwhhKYLLkl49upoQl8QmEV0at9LjHhcICUy+dLu8c4go4bv8blSRouMoPEmfNkKEknSwy8Bc0SbQJIWHafOk/gez6fzwVSDoeYcIm//+55Ir7Jks03ZgFnzFMCP98nvesPhfbPcY377oKqNOC6TX9Kk5GY3EG/WpgnIn/S/0J56kUjksUs0wEt5/NSoZxIHYznkjGKMIQjoZuYSFkM/CEJ4SijMouUxIpmgivFtGIDI/26j1arWEYjWB3oAwifiPe0rsEV1Abpdpypte3grKGNq1QKGV1OmzUMozPaHC7tvhdrwFt6hZK2sg7RStPgJR2SEKyQV4l7p7x0Me93FZn0DKvRqP9yTG3C9DUylmUZCNj3Bc12jVA/hdfu0PJvAsqC3q85hk2ygGZoGiYH1GrtDnugQ63WDah0uw/RDLoRQJbjMutxegTVR2vek3asJl9CdsHGPxyyhXnIJNbnbKiwIavJoUdQlXdoeUFz1hpc0jVf/+S5o2iJsEmh0SjZst7KxX2gmgSPvQbu4rX3oA95rXg9vvIoamIXC5oDWv5PD/9xr9ymvFgFoIIt8vfMeYfXHtAI4qVPSWDPgAqMUvSbaP2wVuJ2z4mY2HOxFYM9WaZI0MVY30qHwnJsnMvpmjAveKYYGZZNDCdEv/nLY7z2co3QdmFXh4016DZxep0Cbt8fCCy40Bnoqo2FKudVtZWGbYbn7xQ0l2v5+i3tTbzMoF4g12k1tCXesrRszXmGssDscFW0rjc+LWAHa2593/4oro1HFRWVESt61+VKCFVwnV2+ZH5RjbfUYtLzPkdFaX3jrNLDrzufxPDZj8m8njK9jDce0QFaSfO+YsuSDntFyOETeKOlKtgydVnmm2Ee5ZasDK4FnDnDohyiQjmH4XhOgAlm5fBs+Hc5MFuwdWY/r33A8tZD9wO/Vik3/VyvEF/F+B4DB+82i4uJTu3O+t9cj7NGk/731yrDw2g1WLZRy1/3pPFx8TY9z6vBtpcVmos1wpJuXotObBc0l+JrUbJ5IY/xjNDAzREOd8rjyxAcZKBJcs1NEjlqMPI0Wr4KJI3G1Ui2mZnyDc4ogysfQY2CxCUCt7T9rfgTuVzJ/0xQviMElKXcT+SmnxiUCrn4y3dIm/sj8EpbVBQwi9du0giLeW2fRoBter2eF5cGl1qXGcC9gl5rSP9Y0PRp+cWCZpOWF5/WCJLNi5XWHXVkrY4bPuaQKcxZrjHmu04uJY1qjLC/H0dy9YNt6RfFR8C3RGHJCZr7s2bprK0aOl6kN714kZgAd4v7/ufc8c5r6MBNKO+7tXwBL5OcUiNpx4ZG23NQyxB8gtloqY0JcY/FEwn58AG0CJIOSGtEmrQY2kdLLNt0Lrf58ZDOfhePMGZr5uicwoHD9nm44NhsAMAun/ieG9x9pW86ODbvngXoyDaP+A7BNX/7Xs56zMp9/4370VZlgIOv4/I86rkGb85eziqV+kN2dgXYdBZn3Wfl1oKzV7P2Q3qlkl25DV9yvfcJNGYsBuVo+cxg5rNHkslkGi2lxbfRDjp0PJl0o1aavsVqhX3oV6uEfUTWljTLYJlOo7aKt4A+q/Sr1ujEBzIX4PVt3SjFfIXqMULNJDhDZkwIo2U4ky/qDZl8Bi/qRnEkBRkiQZ8BOyVaauLRiCkWQT9Omq4NM14CPFrTIsM7aGpAOy0y5lr+pt27NFxk3q6Lu2/rKruNnym86NpWI9fLlJo5295KeG7rLrlt/gV9zW84K2Y0LauZL5c3BDuqp4arncIMm7+pprN8Ksc2etsqGoN+nk4+Pafo6JUztk6vMjOjw2CEGgXPRMARAFwd9wIw8jX8aoRzNZ6VvtNf57epZVD8AaBZtd7uDYNvPBGPRSkDQHwFTQ9yrcUVlrAwCJ5EJkYS2/UtrBQnWDAlM5RZC27RatMP1JVAdw4Wwo2Wg7/TasU+rdldUjc8lEV5kHhOcs8tQf1mJq5Ti8eAwfbHxmUbzcIZ4MvH77Mn0DtLzNqOwqzUvTgZ/MT4NOPXmnGW08/nc4txqtLu3NoMaCdLYvnTjsq0V4bR3/1UG9WNShTBlEk+Dk1GQMJeyi6fpEmHrKpYTAAWawWY2gF7vmB2B4CEDxO+MCpg5oaQj4vgrRARmPt/OFONKQKZ9JdK8afYO0JMYU1civivYFeXjvSzYLtagcnk1PzH58G4eK1Mp9IqTN+8KQ7Nrvpn1Wzxg+kf3fMR0/f7Kj1jBF71sDML/KQXjCyB2zg5yF/61xXQwCsUNKB3/mV5+nM5r4IQ7qEv6e+/7rr+fng03S/ZfgrLXYvLHciXmz1lucG4ktGnrYfvUO47x5ROOGUt5Ir9X5OVWhzJF4+5eEIVKJH8tQe1X3sGKw2vy+qpTowbFzjNJx6rMaD/zX04NHmRGXehZgEv9ZOkISfJjigRUKTIzihFdtBv72SlLoDE/8cZktJ0ly2/Ll/+8aUMnObTj9OgnGGfGVMA0T15bcDBcWUeUxv5enLnirJjsqoAO85cAaTNs69m2nw79gIOECM/sdyfus0HjFqasGDEJTk07sN8jZlIJ9wBMGgBkhGwwwXmaWHbljXWtnR21ExP33WKQn9ur+vaPa0lbOVDOn0guGiDHpoWVPRfdt3ZF97rFMvvB5CT8y3dqQv/1No/a8ec2JLJyhxv2XN2d7Vezm3nGM3upZaiazdsPvJjWLVjB3iMs7J6tYZvWPJcegc1oexx4gGdL/vpx7lxxRNOVx3foeyvF5bv56epCCZT+OGHJiv9yPhispFJ6yOLFZnI6GFXZb+65LAxXu/HYmRBM2cmHGsyDuMxA0JnTMzGBIYQQ7BCCcXXZMRkaZDD6iUqaHcEAg57cDBoF4mNF7jtQWYwrqPDBoMupGhIXOqfY2i7Y+ncC332oN9m7avu8PB2hYJTFRkFe7izyqNTAEHgaa2cAaZ5O4jVBj0TOnJBG+h3SWuFe05zXXN9YGDaHOhy2MsBCNjhJbYAhDsSSz18U6AsVNFkFEyumpImpzU4p8Irsxq1O6gcn3yCxJU5MtiLuY83fgUfMJvIahhasBMMgTDGpMhQonfOVAmuj0Yac8uRP854qorYHAfb54l/Y+RamueNQKHzVHWG7YKxSMUpFHbe01HdZ7X5g3bfhXOX3tFmmOO/NNGgCOkMhjBNZ2si/RepDkh9PNq8bN4OrdEqC5TMDVqdTSU1LpNgbKoIlQWaeM/SxA4IAzZ4iT0AQLnd4YJzpg0E6lHFzXFj5PmsLkNB7EjlVDOqjfXUxdRV1F3U49TPCN8L9obHWrIIhlMLIIER/Yuy6C9jxItk1PcGNuMjhC7B4iPWMpiMWfYcNCASx9di4DMZ0dW1sVrM9YQDM2pALaHr87gJImkG8NJN2hkS77mQjwBgmiKYAJb4aiFxSVLcYfANQyYfvkw+Jijwbi426PWG4mfb2tIvdM2aB37YHgp4FLI2ALRGM2jl1KU+T3u721+q5oYhrXZEa4tNxuKNDtOlXqsMiJckEtAkKNvKrxA/FT+7omKq0mhUTi0/BIOHylE6rVkxOxKdJ3dzPtUs4DEVV0ccJpMjUl1seqq9nUBYt8tU6Ong60IFz1/vrNEP6R/2RiIfTxeXg/un7xOvL6ks0geBV/yHFepcwLrtSK2prNQPPru7pMz0tKJYa+ZLgo7GSxodwWBRw5ypETtQm1R03R2RyB21afqHCysaWZ2ObaxYevyxReVNON1UvohuBCU//7lllWVT/Ffn7W8oDgaLG8jG0QR2iH9x6aEV6MU/BHhHJZCP1eGi3oHGy7+QGNls+1hJraP2Uoeo26lHyTodIxOib80ioae2JhDBGLqGiGeSz5L9eFHUOqLk4wWiPtJgmkFkwoeNY+YfL9qtIczAnMxNmgiGCUetwk1aCIjQ6OkYMDkiZNue1M5w2wtM0kLpl0IWs9kSAt0rVow0bBFf3LweuJcvdzp4GiyXq8NTYuC4whCrKV++vHJKzKAA3SvRsBZ+whFq7wgVFYemzUQLFZgeXLIEvmbXLmt4Nm1/tmG5xo7Sjc/Aj0h6xL7x/PXaqkBR/wzwdFFgWnuwqCjYPi1QBOavjNaENfKVgOYdTuD/TbsZVJo7wuGOoz096V+Cz8XLyky0G2wVz6+2Bpp7Xui018XeTW+eEo87FmoiSv+0pZvmByKRwPzjaBN1OBT0z96cNu3N6emln+xq7JKZTLKuxoHPcZozGjmUZrTidvHvQDfr8KZF4rfTH12A7g52PdqFH9ItauItAWsEHBav90BzOdib9SG6jP0XJeCIfyCTVtBxoSaUXTBjrbApq5QBMYAPwsXKrx3BL0xGZRqAu9UqheWLEjv9a5Uq/SXoUimV5i/KrOJxHgJb6O9megMvzgp7MVcB+oQ6XSVYrzeNrADpW40GXSU8x01fU5nnXcBjk0B48jCyKdb3YAuCiZZZsBdWHJAjwAzIXiwEkBhumWB82WdyPcvLOfne5xUKuf45l0DHOcOPnIK4AS23je5neU6uEEfArfI/jFFS0+B9r0pt+B0Qv6/Vavz0ArUvHYKix4cW2OA9AH+jv2IiTg0l4ZkTfAlqrHkT+I0SqajUljG3B8i3ZgzC6hQpl9fj0euMWkhBJ9Tp9P0z/jiy748ztui1OpjZp/dn9lfOMoCEkeeD6WSQlytB4mhq631TO9fLbTb5+s6p920du0tJ+FWyFHuY2Ecxu7MLdW3GBEwhLorW/eh/3KRQo0X35+JDopmtEM1oTW25ASwBACxNLwBLRF78ARsG3aJFfBAsBX8VfyDydLP4mvhn0Cp+uFX8A+GaD2ztBUWYCU78kPmd+GfxdaAV/yH+XfwpKKb3iT8V/wGmENx7it1H/O50udz4sOcuGwUGzuQJYXJKj0EDuIDAoj/AKSAHAgJH04PpZvpJMHyjD5xPD478DqY06dZu+HAovfjX8Ky56WPgKXDNReJ22Hb+TedffjO4GaxMt/tQfobSR2H/sqlHp4I3nznyDPhCvGU/6AOvpJ9ZDGf+NT3DDp8rsMWYMthyFBpJsHMrpidH448vIxdQOckxH8Yp+QbGx0tT3Zcbk+/tf0H82Hi1z85U2vzih08lL37qqYuT4I2S4h8Ul5CfH+xaMHx4wa5dC5hzF+w6B17R2rHv7YuALtXRmj7P7vOBJ7559NFvHoU33FdUWlp0H7rps/zluwr6i45gZoz3Q4nkokizkR+EWklqweC2ix676KLH4GNkw47hCxp5AB/L/C/slxDNCph3XPCwEQWIxD1jXKCoX4nnwFiPGBWjPX1QCYbHow4cEV8dgk+k5w6C6slifeezl7AvIjkdRyq2U5uwjkUWwjE7MdRZwrgfoS6Duo+AJDE/i6RP7JCMpDCBxBUg2YxG80IrQGKEE8gEGcEwCKDDDD6D+Sfifhb7VNBV8t3RUHFR0N8Z36b9xdrW2TRzw6qVF3xonFlRLb4vflYeTvDOVfGmD99rja5aItdpKvxLXnthU3hGd8Joc8v4P8H4kEmmf8q+mK0o94yIt31zRGfSsBxU+Ex2BV3srfM7954AF4LS25v0AN7XOsdt6O428OpGw5YdFUXnT1uZlMtvgRc4fAp5VTWn9NqLfAquuEgu943w9g3tncYpVbRBbvRGfb3P6xU33ijz1tHP3i9anbVFhn1Bx4C6uNRRq6h58cJHZtornU6dKswHlobnGFsIpqr0reRkFG1Aa13Cph0k1MexOAkNJ2HvAq4fLNVioR5JukJtLBhCA5UOEM5EXLExzE3Ayjiprp00Os7gNQA/QeDq6vaXg/LQolnyZQf7aRivnH7t08b2UMXtD1YE202asNf5izc9/po6Fau7W+y7R83adVV3fvuE16m7XGEoH/id+PeDPcHyCCM3+2VALuM1m58A9FNWl4uZAkrGWMluKw+bjZt5S6y57Rz1qvbqZUZXN2gw2WWs0SjjbEbByiGBneVsaZoL2Zj+fpn6troFjvA6YWo//GXUHPe0OtRenXGKs+OqX/vZWqNX1WUsWqkxBk1ABWrGje+A6hjdx+Bq9WI7Gx7KwzSScKKoPRG0Po/JYzA6UQ3Sj3VZHlved3xgnueBmTs6phhZwDH/A+aKj2vc7VPmvfaZrwXAulXnndcA3e/Yl67etrSS5cRlI+mTztqoE8BC+7nEWBuS+WRhGDV4othRgkOtHAla+F0tYIKNcaClotFfa1MCMEqdkAPWFt3Qsb986e3rpl0O7imsv9nPmIGlpNQCrvkZmK6sWNK3xHaf2FO/q38qBFOYqjE2RiQbJGgWlR0j4JgnXyrDr/Qa8R6lRqsU79TIFcYM9h5aDOnFpFIJknpBYIgtYFjy1RgepWiWTeFnZvxBchDE8Uy8FUznnmPSa0APfjpYp2EEYZg4RjNDQT1ADxeT+ixP1DBHMSx5ZhZRPosnb5GAKDgK52BcpuDQ2Hes1ZISZPx7h2WpzDMle+9YJHrMUJPCWRiXK3gAVcVdWnlhEVAF5fzct6P6DJIIwswyCQvBPi8NoxkpFsvCZCUlcZKCLJerRKxnMZrZ7aFFlySrVy6Z2rxgQeSWm27YPvDIzM193sq1G2fs6amtne+belj8oNjZGosF2unZsx4DNJqhp+7d+7zb7fGiHfYfHx65zun0eqf6E+2Rnu0X/YK5oHn27NYYr5LdtHVLKa2nGXXOT57genNoZUBYmAMGwoyU2cKH0kvwnyw5shu7TEE+vbsHVsL/Tp8No+k9I5/vhTfR54x8BO8kfJUEw5U9SHwYi5CENxetLSiqJkbmJyazZaVZTGrcEiwkCU5sxstIsmgPEdsbDlrEXuvYQ9SF3QNw0DVHekamY9SYwftui8VtBifcZrPbMjJc1tS4pKmJmZ+onN20pOlwU3lZE5gVTsAfbEmOrEtuncGpNdzMNW+tmclp1Bw4is83lZU3McUW/Bzp/2tNZWJ3eVNTOfhBWZOQ3hhO/Bnv/Vn6TYThbeCm+Au7d78QP6DhZOqDZWUH1TJOk74pe1d5YyOaR4GYZk/KABqndZQXcMAI/KAazABfEGwSH6ZHqrHIghwqFAjicYeT4fG7hW4CQSQYt9DBWqyUACGsfkAnsXxJZrpgLKOmwIM8GvXjaNmNDsssRl8YNWN0NijDfEJ4xcWRwCJLjVlGAkHJFEvjsZ/GUwKQ+ELQLBGUZgQ0feKgDC3WhGAxFwmtZEg040vwd9ABmSTZkpud0BRDEwwar9DNJCYeP4zYRWN4Coq0IDke58dkttRwMrSkxCVipJkqVIumfBkJ4DK2glq8FPRp0TIEvdKMH1ATA06IMwMIyAlNYIDQIBmSKgI/H1cBEbijJIPoaU6aM+Jn4gxibRbRcQXxSaLdQqWOS7NjhMDCcJlrzfglNHksqiFcqZkHZ+rZycKbVQqGFdhVjE5pldPi7QzD0jTHyRgDAyAEkF4cZ5AYi8RZBVDO8lk9Sz2qkEsHVAoTr9EArddmZhijKqRrlMllZlugSKnikUxhsJn1W3igKLXRwFvkKIZAYeCUMkbFGQAwWg1GAMwKeQhoWKXWrHSYq+KwzOFmFSqWVqiNnYoKuy2GJgW9rcwQ9HocZg2EMpmK09BF82NmU5mZBs5iDW+ZL4dAJje5GShjWMYfZksY4wMKPe1yysu04RCjkQHaqAyfd2mFRaWG6JUyE22B0ADNOj9on5e+m1bJFJBW0rSKBt+DCoOMVbAySGvLeIXqSaWa1nIQahl5HauhdQoFS0OghAwj18qBXgvjRjPkrJaAPSgPrikybAzyFqXXWbFEmGOsmOGPFBXfmxAS/nIrq/QCgIZvpXaJwWk1Rd0Rr0LDQzXLAC9Ne42X+Kzrp1rKy2neqDx/SkelikEDH+/k5AFz0HiOVs3A2q7Q1Gi/v34ai2SEdfHlOiRqqJQOR8zLO3iFFpqDvN4oKOtWlDQ2d0anqEJuj4fWAq3OrncwG4AAZKgoQEerNDKxG8gNLCtXQqBX0nL8uaF4G2/V2Rz6YqWXK2ennGM0tt6zqwQylReEQ00uXg1aup1+s2mqV047AaipBXSbTdBxTIJ1lpgUtHyfTkEzXH0bAPUuXYUL0ioFKBbMTlDmZ3RatQVo7azcolMBaABqhUGhlaGc0DIXIzBI+mQYnQUAtV7QKRgFZFlGRnNA22RXq1pcCpqztU7pKJY9UM9vlFtNrtaiIgGwUzeo3YzlcoUuXELrGqvD1g65Xg5ZBVer180MymVhW7ulGAi73KbNy+18wK2iywx2CBUs0Bl/JudohlbKOAD1cQbwQyqDHAAZAIyDZj+FMjnUAY1GxmhYGY2qDTAnX1TbLGazwajhGWGWQ8/ximIzasboIxW5bQA0aVCzVhtUlqUq/ZSAX6FmlLzX2+kxsrRGVyazqs0qXYfWoJDZ5DK3lpZV1E4NGf6zdpZXYdWbizFz+MZYh/Ha2oFfrLiw3ASKHWXHOtbs2b658fWl1TNKIPQGUKXLBXUxG9Auik/fO3UG66n22VCxbCrVrBlqV8TpUOmyceZYDtNSbiRDh6kaqoVagj11AkHahw3pmKuLDoYYD56hLRL1MBpJ0DDhZoMcHuGAl4uxeG5HO4wQDOG7yFjSAmqcjCU2xiu/bC2E+tiN+67w6Z795GCzyS3+SjwKlnXV3HD4wmCA4Tedd9HhlBuE6ffe/OXS0m03jvwdTehw/nPfzJl/YOe0C2Y06T6kjwCFsX323mk2ASpo/9zpHU3RcqfygnFrMD++U2aau/Sauaqj8IbqltWc9qIPli+/vadDqwHsb9++b+o/bv6iyfXFR7P/Qp8NwPX3Cg+9ZZ8WazKJ3o8fB2pbor6zKFoms6DmhURDjoUvToZrmKm/FhwRjsZuugpgnuZIDWbEjWVYjyGOMXUBwmOPY1HprG2iBUoEVujPjwnf4pKaHqO4MZi7gzMzN4Uals2t7nMWlfG668o7SvwV9qr6gUd6O5Lb2oOzljQdWWF2d02NLKguqymuifzPg52XbWsDWz44tr9vbue14vCPt+m7MjuAxTvg3ZqFsQqryspxer3dMNfq8VoTlfHlYVfrts7mlU0Brd+sNZaEIu7KSndT5aoDgem7rzv2QZd+248Be23n3L790o44jHeILqtidC/zAYkPaaU6SBRT1sYQJzjfNYQSOVhgOYzFZUrspkGcZgEmhsvBkNIxO6A/DrBFpnSdxSUDPovT84XZSVs1jMsk/h5reMEK3vuRbm4LI5OZHTUe8e8ahVzsMXeq43O66fPWJMx3MS1zmXk/s3i9xuEn0At67bpi3f5mE7q3rDjg+LxT3Cv+0mA2VZiNSoXosHEK8xx2f3xNf//IJwZQDw6M1dFl/MsDE7wfz4AVim29RF4GQxkraG5vMGg/ScwcLPpNMcSGOkIREnRIrKPERkpr8xcFc5yCLMUOER5FybITon0mwUx8g8aQnNTGhaiPzrCekXhqJMdn42hYqq4kUvznyq8VQXuqLTwYbkvZg4qvK/9cHCmp0wOqcxNIbuoElF7sPfAfBw78BxgqqSsHiw+KG3S8PSh+GW5rCwN90M7rwO0HxYfL60qKrSC5ZYuYtNK9+IYDUl4ZnNcA8W7NCLq+U2ylOsvhnFF1XXWJtlVt5A+lB7pgsmtAHCK5oROixDfXOzJAcvK6OAVv6etEgpUHBrsGBsAr+XxkdV4e7NPegtUCWXY4iEQqs8VfqNxhQY/eUFxVsqTZ6m9q9Fubl5SGiw16Ztm4AeYT8K55Vq/LjqSVkpIiL7C7emeZr5lkjAihtcW77ChqR51Yb0qIz9CAUNMCAmhYwbFjoQCJW2aJq20giN0isYwZDxC/WzZOiO0JFg5LnFstZja18va3P3n79pXSBmxj9OJ7Gp1WfO9JpVv5pPieVqcR39MzrOLJJxUsowd+dBL4n1R4FU8CPzoJ/JmTUJV/DNpEdWyv+KpeqZT1fKPRfNMjUyr1oKaX1RnU33yj0aOzoEY6q1ZLZ8VX0Vm95ptv1Jl130/ZSygetVAqgMc1PKzJyAgYqfEHCLsr4baM+YmYTNjDATF3OQHzeazuafHXT/b9anTjw5/tvw5NmMEe8dKhOzBV684XAH9rhYH3LFl55OSN555T6tJyf0WliT2duq9J/ME7+z97eOOFP3/pnxe8CoruuBVYXt4rg6Wlrnmv7bzx5JEI79KWSBhhslTGTlye8Qokik7PBN/4CfEiiQJECrixsAejMyfJGRnmk/q+BKNHjRC0DGLZBN/PY1kQLAz36KCsl01RbdjDiiI8CZzFbCTNAI2LqFt4w7AqS2HYCjLkCY3AEML9w0WQdjJAO8CDg/NlvUH7UPvrgsDH+F+wxkTb2inJyIbORq3uGWORVRBow68bJMiM40KwVjhOzzku1AaF40N2cXo6+SOg/BFcURt8eM8bQq0gCC+w+lK3HYOsOUIhjfY1k56PGv+8YxAXLCjdKD1G/D2kLv3Rj7C+Y3R0hLuR6aQuI354MmkdZ4m4IJIGIFrosbIgmh1pNO5bjIRMAit98BG0yCIINEhqwbMk/nXSNfEWhiAykOUWbitoTWMkqCpYQwewLg+tS5A8Ai0BtIbh9lqOW0vnqQ0uQwLLDFfXoEWJvCw4SlkTRqOzq36qlVZaBR3gGIb37ZxxdPtqq03p29p3dZOMZnRlgFebWVYvN9bq9MWx8pIiDZTxCiULtZzM1qThDabof3RHjQ4k3yOZXmbQynlvWUugqYpBUjmUGZXAHaqR0d8kPnJH17tKS0zNKBMHVrC6oNPGsEa12rRkWpUcsFbftHKdTcYKNFM6td1qVZZcMwhkV+vNrExA8iZDq0w1W4qKm5ZVF7FA7m/o6yxp06i9CmgWVHYI1KzB5WmoXR5UtXirXArI2MtXtvSdr9TRNED/IatTSLy7D3F6dgOlJKNeFbWY2kxdjHpkbk2MZ2SSRAtQSxY7E1VrIAz8aC2HO2M85g+gdS8aGXHMKo928YLQiZ3BsLEbdV2yuIROkAHfjKH1pbSoDJBj5FAIL26lJTr8HjapzjOZ+Y4Fu+QKjbaYMzi1zqcq/2vblgVVVW/0b1uDVomD4uiRP4l/0CoGATjyJxAAwVnX/VRMix+J//P2/iuTD4Lls6ZWMjKtTia78rfhykrIapXq+lUduxbZBHm5BWXMuKzVWsawdmsTWLw0ElLUxOzyIn9LyyNLi6aoXUUX/mPEO12ntXu809yO2zUOllVpXFpW1bOx1+99bs3qVY7ip5p6b5yutXx2RNpc03Htgb6W9j3PbN0JmOSDl81KXK9Vo2YAG5tbd2q0KtSiGjbDNT0X1qG3ozy09mrQ262lrGZ+b3qnw87XOLqf7JgW5WWuuiqZfXahfLGDUlAC5l4nXLFore3EOk/IYYJjP9BzaLA0mBmeOfvhF55/+PDPvb6fi7enX37qfuBnok+9nH4C+O/39vQs/ea6675hm0XHiHjWuneA9Udg2m/TZeLH76wDx0bAX5y/FX+UwU2m2AuQrLYF615oLK7KKI6gZ6DxWAux+QCg7hXDaRanWReIRcMsWvkzWrTMQUMU1o1ocVeW4SR7gXtZT9+6nvlNesN28djrgt0uHAflG/0ze5atXbLQs+PFy3e02qJ2zjyjY033kkSlbPrFa5c0RzxmllHLHTPqarXBSOfZTX5WZuTlHFojaatiy9Zc0gFDzfMWL5rTaDBYamTW2V17dl0Dfti1q9lNa502pfJD8VtgD9rA2ye0vFxTMWvfwiqjb96cigODgIa0obhu1s7pRQahtLG1tVqnv6BTZpw2a2D71R22zq4VyxZOj+l07Eo7Z2mNNrigZd7F3c1OHvUf+oYrOEtjOAirkehiQvLL31iKeGgbSdwSkbKA5AsPTB4D/guYsuxGzN92LqgXR9JfLNjJ/Ha4LPu3cwE9b8FO4GhbvEf8J9DsWdwGpo9So2Am+rmqvX3Rnj0FsqYNSUvVmbibSSlBzacImmKSGVLQLGGlRAr64OkCqOA1k3CDPny6QKoxcnEmr2OZTQuJTflT5hXzf+IM5mlNMSvo4GkzO5TJImjFLKMSu6k4etrcTpDhJZ1pPpvgTBFNVNBuNEjhXAYjjk09TeBXCvssqTPhWOrgyC++Q5wVh/q+Kx/fzp8CfT8Tzl52Ogz+TNQ6cJ8Wij/jO74ayeUmKoYjLIlIhiWyuAXPrlQEC6YWMhrREiBXnBB1YkuD4DF5cBSVQI9ubBBf/9Ed4te3v/GQ4YIjgHtu39u7oaNhlNLoSwxfiCXWAN0L5dolsbaevo4AuF/crAe/LDF8CFa//MQfbweKO54CZS0HYn+69Dnx2/3v23ckOR9432OlVXp7pLWnbdpZnPinZNIn1o9ZZzcSZKBYKIi1DLGMlCHZQ7GGE+tITViNiZWakKhUiS0Q/ZtgyWM+0gdqLzdMaW+p13e1c2xVeVFFuaVYoaItKnWVo3567L4SvaA2tVcbVGi0MPj9prLm8kXeA3v6Do211NEHFldNNdJCWXxxNReeU7tynskdti6Yusl4iS+QkCNJ6sYiTu6HtAUW86VxTfjqI5F1drXJNHfwShABwTGWOJDjpsBraSNkpCVdzgGoFUQL09kwKSQCFSMZkjVlE4YYlTnJJH8snvjJoJZ/h5YpFRrLX7NbXosOgj06u0Xck9mcAAw5ClM/EU/8mNfCdW1AptQnLfIZq3Opk3iF+tQu1oj3zl+dTYg2DTD+J/bEzcdm+zKI0KZMGJBUmNyglrOufcd4bVFimhQHyUK6V4oR6T1j9PaE68mTThfNnYlblWN8/hDxlOiSrHhRaUEdBhLVMPaBR8Oyh0hCGReYOJokLTgS1yPjvEjQBVpQDuhIDe0TMGwucDIR1hOEW8+5K4mGBq5h7twGTtAkknedwywvu0S//ILKyguW6y8pk0WjCzo6hhfTX7/7Rf2Ao0gcsi+v7F1dfOedxat7w8vswM1oq2o6/eDFEcUuMJhIVHmsNmiwGqDN6qlKJDgzrYtU+CsiOtrMjfgH/M4pN04Rfxssm2K1Yq9N8DoYAq9jD05G47GZuhKZfoaxPrqJ/zDu9Hi1KVmj0AI1n8ySJrQCOp8MZdxM0Wo1n8wAz6GKEOIxEKBZ9ouWhasfqeMWNVbN1cXFX8fli5qq5ujitxabmhfEK+7YfIfd3NQdr7gzKp2I/T+0vQdgG0X2P74zu6tV712yZHW525IluVsusR3HThw7ThynOb333pVGCwkQ0oBADAmhtyQEAoEz9Tg6F447+AGXu4O7g4OjlyTW5D+zKzlO4L5w/+/v50S703ZnZ3fKe/Pe+zwQjYo7SeHIHQZjRWdF7q2zD5v7+0F0NnoZ/jiycrKr/C6DtXx0NO/OOYfNJhI4FJG0VeJrI6A0Kh5J7hI5aDZVdEbzemf3kiKx3NtjohHleUNVUfR8iRidmw3K516+75PF+3u7TNcEaFLO5UtByr18INVj0x04hWchClWxMV8VGKyMQp9xutwvRKbU1k7J/02BPFtaEqTjwZJYVn9fsKTSV/BogLYr7TqzQW8w63CIBjJP9aU6K+fPgOMevXGDd8iQzNWZYr8YtRAHB9OzykqCvhGWzCVWqJNoMOfCSvFJBx80jaDSMkneNoDFvbmRGklNphZTlA6vhH7II1bSvBDJrxL2RwgXphtIcvs9US9xqy2YYGKugdUZTfxair8t5HTRSDGVyeAlHxIQHD9etqJUpjeK437ilwPHjRvrwMLn/82KWZXYxrSgT/OzdUqd7rVhG+UaEa2St626G/0zlcZlSmeDjhdvBLLZ0lgzw8hFWtybq5Hoc8Bs2LRoNr120psP/au8/w4wD7R8uXPnl+g42o2OkxDoBN2g8uOrrvoYPYeOoOdICCYO7e3XTQLLgFgXqLB3Ky5QdBnNQlcGkAIJkGt1SiBGjyMxHU+n9j45p2dkTG7W2VQOuZedezq5WsTmZjLtDz73Fjo4Ax65Z242LL6k4hb+Yc4+dtXHoPKyZxjwz0Tev5agNwAN6/eSMeKNGUSMQc+YNEDni/kDEcbEVKEvP0LXvvM7MOHdd9EnIPIp/YAv+c2NK28HhleJ29CE/nBy17U/HLbe7z9z3f6/O9g2VI3WLOloyLjftS6tA877gpJTfqqQIAMYPKku7IkAF697NvC7iO3GpoNhuo/uS2TZz0ntWQmA16RE+n+5PesszigX4cCPOCCiUEJA6LhAJXHFF38CXCjxMpdI+29OSATbckJ36Ix8R4npWGMolvKB5SNWsQY9p0vpYOJcMtlGY760ry3Rv7XM/egddBi9cz+jhVXGYiPTZjzfy8iZ5LKcElF1WRmUSlR9KokUlpXVyMagY0Yj04OzmR54Cj0/ZMUQ/B9UPMpxUJ0vRpjHfN19y3Tv0CF+NEIpw39K8Ih/yFD/G2tnifPFoAcA1IvbP/9Cgr1R0I0BOiLs0PkpSGQjmF3TmqroGAkWEcA5epyiKicrrgiiCw9PKAvl1FfveCbbd0P3qoJopKTMHvcMl+6CdclKmQw+NwS8AILbVaqFn+Mnq/zkxtfGKJWBqWVXaH4k33DhhQRzg4hgfRQS7FRfcb6IiH6VNHEBQ4QHdDFv2c2JhARM5NAuzkMQjoUyRG0YE3d+fi7GTDlh42OpyRoPa/oPSlVAX6quo9WuyMyFHdGCYVOnh8vmjostd1fNiWePtObrcyrHFvtGWiKLwO1Xbx3WUtQwpCjePS5e1Ij+1bv14zLv2OYtQJPpNOQbd7/SVN3y9guWQm+BKV9eCKHSWzKhvGR8eZbGWjyR3l++bX17wFU+PX/mzPZil60ENnVVX9vdtLSxPO72DqlrSwwf175maUdPedPIa/LbtVk1WcE85pnd7TdHa+OCT6NRFyjx/byOjovKoYoxfdRKjaV28hZeRIExteQITk7IokMN+DpiBkI+wTDEhBmSAJmZOJHaZMQdMcYby3BGU5QebDuiF3E8VBeP7MW/v/yUcb2Xh/pmB3zY+wM+muH91rMfy4t/M71/otysUanKrnz8qnKVSmNOfj66smJs1xr4nnA+fzBQVDsxGhH9/mwCnUQPo5Obzp7dBBpBG2hMgAUTa0M51xZXXj+ksGjIkKLCIX+rLWFv23QtuhPtRYev3XSbKFK5c/q4ejx7Lb9e6jCDWeZpFe0rVrR3LAfogfVgAmocP33nXKWqvHCuSqmxyIvc7iK5BRxbM3pMRWVXl3DaZZtY21S0I/kjOHVnZ0dH552onj/Dm2onOpbsLIRfCZUPSe6oWeLyOLd/0jl+7NjxnZ9s93pcC6unXVdxLwdeyuiO1a44snx5extarjpcfR01SDfPiPnmbKqMmkctI3R7iGxx5kAeS5rsIZXDEEw7l0rbqODXTV++5Kbhk/0BnYnsFkf5b8SRDSxaxKW+l4kcmHDIi9ciL/ko+L70Cc6g5GquA+C6uFjMGbiitQCs+ai4ubi4GXZkZGdnOLKz7QSFtD9BjvQnntymcIV/35mO10FjUaipKeStUP1NoqEnnbnVWxpuCri43dSFfXupC7vRSnKXYnA1pzRyhNziOC4MipujUZw4jr+zIyMbzDy1rX/ztlOnttEbtp3qf1tZHQgPLZwrBpKiUEPjtKYsVxRKpOj3zPycoWFfpcqSMeWuyZPvmmLbxt9pED3iwPMAQZuOpYDWBlSFeOgEQQ0oA7CRlPJQJeACOC90CetNT+le1rvM7rftW9o+cqlNr7OBq/eSU3fFsjuWgpGX85QnbVUjFi0cgT7W22z6VWvalyxuA5gwseuif16zQW+z69Za7WvbliwBD1zOaZL5/hCXYCfwz81jQAkPLcAJaMiTDTw0x7rSOaaYkMX4K0ZV9D9y9DxowoHkQw/3PweuA03njz7Sv+U5nEKXrCAqS8kDD/14/iiQonM55eU5cN59X397/1Vlt6Pvj54/+zCQV5ahr7PLy7MH85AE24TyETfqgvvXn+E12L5kHGVO2AL7wJkJW+KDya9ecAb2bZmAMpPxLUzGpUqUYvyziinm75jGkuB6NLxlv4/HCCJLrcsCPBqAV13aEI7oCA4H/ufT4LTB4aZXk5+BprXgptdee60dGpL/Ak3ocZJwM9TjnEZ0EjSuZf7enwVP4rzF6DpcphGeBI5XX0V/7W8/1H5YSBwIDsJWkvA4sIXEdxI/O/L2LYNC6hRIOaeJETsWyMc9QuQnDLSxJZJjs2dH0HepANzw8Hq9zhQbs+50uHb9XY+sb6574nSscj1tukSxtT7RrQIGDRiZGEfOySIgf5oeXjZJlNya9boOzsZRb//jOAh+vPT9SqmsCxLuNTy9bKZOUS9Tr1PvU3+j/kF9Qn1OEW2yqIMmbL8Scvmsh2j3OjgnMOKoXzCWKY5VQX6TwCPY/DGptRCTF3gJ56dyU5pbgaIUIgkRYAUIfD5vD2iKKWlTLJ8L5MNs4loGk/gOWA0MJryiiqsFPTKiRIwXYZrcED8RTyXHTBwQ4LcDVTCMhybJ1IVxasSgAtWQeXHY1VNn1uS4xlUMKVx9wJtbYQvkTx0qFTESUS7nZLW0CADAiTW0Z2tmwAVpWB7DI9G7r9IyfZFdZEAOp9qsUYK/i2UGnY1lTCKVlTsk0Vg0qhMA3GksuL4gViCtz2Hbq3Jj2XqD1CwP0cE8D6hkNZxSJOUkDKeyaguUG8apg/XVGY1ieWamUW78YZ09N8viVnpkOWIOZo3oP64sydXQOT8ETkYltgyTBa5eWxlHZwvnDwW3057ScAnDGUbU2NGQHpE0T6477ZRm0asBJP8m0QUNKyc3lcyJVTpi1WrfgQdO7ZkMGVbC+rgMucPiM7qs1VktuE9I1c5mo6K00gCtkQkbbtIz1kVGtcpEz1EaFVKGhUCRqfEZNSojHVRbH+st8rppvVmt1eUOtWaqaaXC64zbLcEglKneYQ1ilQgzQ5BmQI7DZc23dUgkeXaAyfVJkwzegClPU6prUUkio+98MYeWSCW6KCfrH2XNcUbzS9g8Ge2VP1KI3lQBTiUTcyAHKji4TK8B8uS6DrmoCAD+zsJ+gRaPsX9j+iRKTSC+Glh/ii4hOs1EuMJblvKq5sIo49UcOdxJeH3/KODpOaISSaRkRCePhykS9NF5PTx9iruKFON+x3fZWIrXZK5jdY4lzZvirFim4oDYPXdKKGtMDifP1elNkQJzRpFVKdGYaJVIKVErdTKbRyaWslIT6Jaa8hyuxGavbeiIrkWxpYchbMmoayjdu2JNpnV4TaPeU5Bpz4isexP9C72J/v6HRKC8fVh7gU7Z7Kl0eHPFm0pz788xeDvrOmKBkE5pdBdhbk0vzbTTNOOycfKtBUqVVJ5r1os5PVQwUkZEQ5VSpRExclBgzMuzd4wCwbKyIAC3TF9UrNfUtMYBqByKyVN3ftaq1w+jf/xm3tLfAnvv2LvWLR4Wz5CKffqg2T525C3+jOE2hXlI04oN91GDccYceJXsplbh+UAFlSCQtl2O+aPVwMSJ9CZjqJqmTZh6cIv0TporgPkgTdbh8W8UDGYDRMQRw2WjxQV0zEmkXA5AE3qQt5ImGrwqOlANq4iiE76Qye/d56h5oFO9aGjnqrFDjPk18n0yn883y+fYd/vT8v1y36xmX8b+3n2373PU59oauld1tiyVj7qPnrmqs3mJcvST9bJ9fBnH/l78LyNeYGiZDme0WPPr5DijeRafcfv+jLrHR8uWDu9cBd7o3e+I5xsauld3Ni1Sj36wRr5f5pvl95GCUEtqbJ5NasT/HHUnx6jwg62e0qwvOL+nc/XERntuPV9kVqpCR/yBTtlSxtS6TNb5WF3qeVNZdXnWYTNWC/piAj7IEKqLGkdNomZSc6irqUNkb8xfwLviCwgKtoGU3mjMT6ZDkV5QrsX/eANrohCLxwKR1fF6t4IeLc3v53pIqRgvoYyFWFMA+DQsMNEBPO2aAKvBn5BUwaPfCBQjfy1hf/DgAhpexSBQHNDwu74xDRvKxZkGDdwJTHp9bg5Xz9TVjTQzTlrUYtik1NRD8QxxwAEhYK0ms1bKAJFPVlYwDUprZRILw0DaYqctxXH5epZRvEFzcr/DYTUpGUC79IVenQY+Xb39/I/wRLKZeXfGo9P+NCPvNMqHlejcbdHg5l1lrlEjvqoWS8WM3cUMfaBx0vWdKqdPCvb0n1Mm8zkFS5TUVXNyYD4ElaCc0YOXaU4s0WewEThz+CQVZCDTZT5hc1wtAW4oExN9SCnLcYxGpIEiWq32QA9DSwGQG2ColA2NtIuKISgCZ1QKk0pOm1RWPAwZpRzu+lt28qZ/MuJPklEnvMGZ/KdzQQ1d/jhYd06j6K3tsMiH53MSPHVooa8ow8tpDCImcf5334u+UQDIRCVARBbUxIsL5hrQRN62Oo0zQewXG6kxuCespK6k9lF3UY9RfQO7ZgPOb9lL4dkJ/UB8Vxkuty/T/EL8/3V5nQCi5tKATLI3nCAH9kxZw945/b21E0uCsDfYY99vDyYzeVCn/3gA1P8uv6c3WJJMMImJtRe9Rx9yrxiSpObsnVgrooIlQfwYPcHziYHLgPLngkj5vy0AdgKqJNiLKOKtnNg1iKiUPK2aGoHngIXURt5D4kPUb6g3qD9jSuwCUAEnKADVP7N7OuAEUnjvmv8yTv+X3/PX9I/LQYv+t/f7v/l8LK9EdF7QHuq76GLhfz4kfm3BiwdIDfK79KuvAtR/X5OI8lvP8nuGInxEg+B1v/6l4NFfgHv6+eB55QBIDPwvLutX/v+qjd/rjV9QM31sD8/9UZLLlR/BYB0ub1rn8TB6P6XxiN63l7TZPwKLPrK3laBeQenxffR+/0u8umMCJXh1xxLgxfn2jz7CpT8WtB3T+OkCLnIGL30bSeSIAs+D6UbCkwDBJw5ILZ9siNESCxc883ncOIM4x/ENKk3sg32hlJkwcZ0DaLm/q7JlXQU+tq6tQPeOam3Z0sAfwDUrgPZxd3VtTv0X1bXJ5scW3fUmaKrs8lesbSXHdWBa66iGLS3kwAQr5g5femAoOd6SPN22YuGB5raVC28teA59sjS/MkPWPXbX6NMPrjg9fG5F8y1L8XHogaWzVrY1H1i4oq351oXEHu4CBYmfc4OALakzpoz6hYfHzw77lkzKg15rn9UL8yYt6dx7795O+ssbXvD1v8Jr50V8L9yQ+ObWW7+5iJ2StgNz4pcJNGwgDyjIBxQQY1OYKPxmNKZYEjCRTMThE8mGZAN7zutMxu219mTc6c33wz5jrhH2+fMngAlw3SeLEUIwSXkqNCihVoOEpsJDU8FaJaDE4guUslYwr8f1iwV/LYIdGrEdx1msj38OFqTOgXScPBdLds4xvSoEUg/o4w/4KfmFFx8g7ywpDnajeWge+/agSK4QPokaUSN71u9CcUvcguIshGwq6PLneMBR/OszRU2gz5MDjnqze/pA2eFFDzzwQHJHOrTqTiA9vOipp55KVqIeb5X6jFJ5BuI/clZXeUGvP65+AlyPj31SaZ867keLnlDHhf1CJKZYiNstwe/dT+VTNcRbg8FFEwRXP42puzB0uTHjQwk9knPpjT5XKFLscUVchE/3uHzEoxrOETbAPS6uBAFwob97kQjs1x6pXqH5YBo6+U4SsK9f89p0mFyw9HwUBF/7Lfo9sAwf9zTqR/+C7WOuWl59/5JlRR1LEg3JW5kH1qHfz+5+LvlYPIZeA+I/vgl0V314tcaxcHXoruNPD229/o/2ug3jHm3PPLJ62NpRZdbUN0zLDx149OfiljTyWguXrYQ6fueJ7CuQTQbaE8FUqj51YnEZVzRycSeaQDDRIZMHDz38UgZLFE+jHWDD8t7r5gaaR7U+fGjl5JNPrYPS+iZwC9izKXH4titeq7pGNrRosQwxDXNANXrmUmkiuqH/86WLb8suXlQ6IluDnn28eyJ65N3FszJbhkj1Wx+5f/OVh3/jDoIFa0pqgbQ1zWdxaTz/AMEQGPDOwO/RmtL6gAFClYNBu+kxPeUB/BxSgMcVr85EAHspUf51L1933cvJHbtm2WyzWmuczv0thnZ95orGWfSbxzZsPHZs44Zje9F3p9Aw+bNbVz9h+TvYNmKiwkhwGGRPngIyxkmuv+7802/uEmU797W0xp1il7hiKP3nDcfw9UePbnwKfY+e2XR0/7Lx4IFbCyHY9yQQo++oS/hGMW5PHdWa8utBtk4FAUJAUCHBDx29uAlWmWY6fKHUd+Jo0npf2k5ceCeEMXxvSe/ixb1Ivay9ZKKlOL9ilcUcrmw36tvpfuFL3K+/cdKsm6Vg7N7Tp/fu/j38i0Q3rAr9UfhAP+x8aceOadN30Fm9i5eMaFuMXjqytKxQr8f3qFhldrFwvvAxbxoyftW1M/tP79l7+q3d6GngWwnexumod9qOHS/t3EFQ1S+MFn0roikF7pd5mEcexqND0ZyPF2Jj5slow9wyrQI00TiOxgKAWIABzJ3ROvIGgIj2BXRES5Ql0jtOyXJ+nBKjfTGiSMhGMUVvpOtVEI3HY1/GqSRuODz3+I3VkwudNPO0BnJiz4hrRYlT8iKdtnG3+O+nuXv/WpoMFLyHntP9Rd8WNBd5Cs2FcN/bWplREfRWuhpk7n+A0nU730cT9rnbh1RoNGCPMyqXBcBCdL0xgy712UqaveM5OSxD28Y33TB7lMEAplsrNNrq9aOTn6KbMjw0w7GHwUIw5wG10UgfrUbXPikH05x2BuqNuZYoegHt8Q336N1Go1RLN4F5z33egbbrR4+9eUKdQgFom0pVKfSRuFjo82RPt+6i7xedC78tQkByAymDDXldaYPetMMU/P5I9zARVRBwZuLWiRO3bqZ/HAvNkiQlMUOW5pOQVtmzqHdRP4UPPUrtlgn22aY7ptDUlDtMs+0TtoANpNBEcAZMF+t04qRFiFIIk+sJ4lY0IRwxLZfApQ9N3LhxIpqwRbBzFpPpNkyVYx6+dRCf9j88sIAn7Up5/jLp0nbM4GLbUylc5oQtP/voCQH9L0EacPac8LjTBrWbcfFpMLFlAmlEnDx+XDhebIQAtEuagjL51wQ2Cy+g/0k+iumBTMyfnOHbR3nJQHWkMQ3JBhBxExcjLRs4Cr6SiVKncGTP+K0oBKReC+qzeKUAhax+Hdj1MX98gRwTBP4+ofNbXwC78PFjsKu72K/Z4bd4PBb/Do0f5944cEjodAhf4Efz+cMl+Cs5VD2vU5QChxJm+ZRZfDSGU12DUjP5VB1O9fJ7iQOlGd4NIRisKjjT8QzadnO2zchmbl341/t0Sp29x/M5+t1News9Fs6xZhMwvWVWWjzzghvQ0Ydf7TU5s5yyjG0PHgR5Mw26jJzXLofZb8jULXVLcvQZYttMme2zoGFHtiJs8Yhd6xQeoCkwDR1WwPkczmyxr75SnjXuMkEQEPz04m+iI5Qw8T/H0RzmrwM4FNPFXAyF3jIDE2JzdzrQaVBgRp+A8zgM8pi3kk840WQH+sIBCmCjAxx0AI0Djz0N/l0roZhllBKvsAW4L1dQTdQoago1lVqMudEdmB+9lboP86OniVcx0kvdxI6XzNg4il8jebccrTelnSREyM6gu4BYW8dMRKEpEogV49meNnF6D58exgT7xQxnSgEKR3COBOg4Pe8BisiEjbHLY0JEsNMvokkuWQJ1xA+UaSCGyVWjjiviY1AXiaawEXiYap6oIwkUL5+g1ZiCVEglSqUSKCRGkC2TK8RqsQJIZSKJUiaRnP9Mr4dKqNFAZZfVCsUSk0kiBtZTFotMCg0GKJVNNJmgXGEwKOQ9OK4USfR6iUgJNqE/GwxSTg0xq6TmpBN1OpkYh3BcLJuC0/Q6HFGIJXJw9YsqlQpzBEqlSq+aqlSqjWoglwO1UfUHpdaqBSKRHEolMjGnhMyMI8v7/63Q2jt7ngMOTaR0+ZHDX0GZVKmUJr/7SqooPg2b1WKWFatFyafAv4CUk0k4BZiX2CCRbEhIGt54RSJ9+Q0JHpj/+u5zmezz7+Rs/7cKxbf9Cuen36sl3PefiiTICOejrd9zMu33YJ1WNgLlfiuW6b4Fb+tkmUj0tcHwNTgnUSiSGvgpgl9IVUrZFwDJlEoH0n8mU6tln4HP5Go1Ev9DodUqliyH62iVhGPF2uTu5XdCrYLeYpK60dk+45GLfhVJn1ZgmoEgrVJUpjeGpxqyO18JjP9zjOFBuIVocRTqwHvgwMrX0W2oB932+kpw4BfiJ0EvmPJ6Ov46TY0eda+g13LvqP57B0VA9qAIk41PCSGGT4P2cnWUlfJQE/HYWU4lqKvwnPTTvToTp3ERV9G88jsR3wJeUkY2cEWcQdgv5yDvn5AgDABir2Mg+6/EBqQchnhABNxsfMCUhRIAkQlPcjFeh9If8Qf0HE3KBshtRKzfQwZlMXvKHhxAik4Ee+xbwSqpHP1WDqYSA8AkBZErXF52o0OthEBUU3hF9Qf33TRWpTADVspIJnYqJbA4Vu81KxQypwGY5FoJwSeQx5CtuDM8FGxSKfDz8JAhcrDuyj3QyLaEbSUOuNK8rKVQyTBb+f21NN500F6PrsqQg1L5OS1DESvDcxQcaXVwRUbMXQHgD7rM5egcJweM1BqcmSdRQdi56KoN7beEgipDgQjSrGPtkMPIZr4i2EWvye7mfHSQYXhQMSN+I8nZURsmi+vmj15YIjPbARjcz4RvNPLXfRudgQA347cfCZONdRzmoQtpkQp4CF1Oe3jCzoPfNh2O/OJbnt1w+GCCoyFDA5ZOHDzcgN7unoq5QxwXweuXXA9ZwDCYWZza/SveGJ2Ym5wLPtZb1WIz7ZYgG9wzdy5q1lsNBjZTAl3JP0ucIoPBqgcn5v6k/R2/rv3EJMNDQEuJBBg6gYfEaeElcHzLcSctAHxcR/9i+0EesAybyUpZ/JUZyHL03Bbgqe97rg590jyTkdO4UzEi2ZwW9GH9U8/+ilfw6Zw5t3M6MSNiOAlz+5w5QAOsc+ce5HQMje8jP4jfx5fo47QvvMHtL+F1qX/tG8CcpOB3HFMYBLkSeDRkxBKtsF9ucyZonHB1S3bdiObqwnZ0/XjArlxV7Cypcv66Bt6lMiXaR66y6eYm/wDMQK51tY91qn6uTdlU6FfOOBpXJGYCDM9qGvW/2AQm0U/1kU2Ptt5FmBb9Fc8N+lBfH7kksYhcQpBB08+a3o8hzxujmnkU+YjHwEY8Gamz4Zfb4CHg6RrAW2vzWuRRXSRMnEDCFPkME0TJkvzoiv+xdYkEouCOueIbPrxBbJiaGGF0n+J92TGJQX/gl1qcSOAZ7C10yGbpmD+/w2KrBq2JhBVZef+TAzrDg75VKdXC4xz8qvXBkPaKOeCYIhYlQJbqgIBwZ1Tz8DeBEPF6mg9Iip5P+eXOiakbMSOXHdlCGIItR9TguFO3aZM6qjewmmnTNKxB+5RNP2aMNuqHuuJiHdTpf83MlC82Js8QV5l38XvFd6mSjeaDYP9Bg0ijiRjWomfXGiJq1W79hP4JOuiN6Et3l+ojWs3P9Onwrx2nl+8Jsem3xqN9hkO/vALyXpYRf6TnkdeilKAfgETyq5YvOpG+FuAjxO3vI+0H0m4glfzM949RwwiO1a9qWRWx4gXEeoDY+vJmRC4jR/N+mQAxFSBmpJi8xQSCTihLMgO//PF7xFZZWEaLT5wQ0zhgFf9ViRurVP718nS0QqGC10Cjojp1/lVvBN/Bj+/0zTf4Dn58J5Cnw3/o9OXpSRG+I01uLcWB/mdwAPM6gQtz2Hfx+yIazpgsEkHBcZEUcztGK6GZYv4Bj/J4EBA1pMHbfOy70yfX/O6OgrZ2e83saUt7xtiAzdq1es2Ie1bsvOPN40efLuMsdeU1WmdZKBL//R1V8IUXTVehr2+35hVqIkuu+wvgwII33kP70Bcv9tzzeRMInuz77nTfwY2AkQcyZ44c0z113BN/TMnxOWFeE1FSzEVpMUdqITgNOqDxsbGABPjSG82YZ9OwPkyZaPQpp2mEFxFY5z/BcegoevSZZ+gwDn2DjrYCNV68vtwOhifvZF57Bj0KFMk76bC7/zVDrqH/NbebDuMATgAL0QIw88/eTZv63we7jv/5ihMnTkz4M5iJFqAvNgHoPQ52oZtykh9mmZIfKhTQbcqC7iwTdGMS/kPTAB6tmGJX4X7ZLfRJfrfO48qBvGRjAEyF2C1ocSbgmWaioZDGQ3ew4dTuHUF9TGl+edyC3zDxwqs/u4tR0ecbAWTv/WzBePnh5ZNah4HAsSPAfAice/XudVfPVFfL61pjra2R3JE1NUNHLq5Zfdfda6+bonT6pbUtxW3NpTkjamqHti+sXnMv7M//7ZrDnwDpP+5c8EQ0kLP0jrKbT92OPjskMqMv1+ycqh+qrKmLRuqz69vb67OvW7l652S1N1cerw2XDhHSdlxqxyFgoRLrpBjve/QS4wtvJmciSHEg5i+OBURqKhMf3QFOmxnlfeiyJjwRc0Y9fPmnJhSwD22979n2e9ufPf/Vs3b7s92wFqwTEl5OucSlpz3b3f2sXUT9jAWEsptchC8lF9yHtiaf5hOA/y/CxeJn7xNuJ9gjcxT7A0HmABeVm7TemEZEEcyIzCqy5R8gFtDcoLpeBpP++AH6IOW/dwb64IM/gkkvw8SJ9IOc+BBsOutE/Xmo9++bBX+9m/8OevIA4zyLNgpYigo8t32F3+NU3Ouj2lioCI9Ihlcm4WEFAAEfIBubMWIKE+W1gQjxSDL5gJLHKhAgCPIZzPmEjUUOsUkLBYwLnfhPL7BAHIyXuNihTaFZrVVqdcCusimU0qy8bKViVmC4XgcCBv3tva4AzRhH2O0zc9t1OqdbX+AaO7LRaKgYamYys4uylAolJw3mjSiqzym06wD9IVpw4SQ6/q9tcO+7YA0eLeLwjJX79xxpDAXUTo06vGXJNEeGpchlFYmWahqstsKFmc7HHs1f7Hb5GjWapcqmjIySW07G85x6l0YdWbdy3aKZHZUajYLOcNeG2ppnzNrciJJo2t93/wjaBRqI729yzOsGqTZqAjWPWk1dTd1EfIv4vcRLBP6PGTsOH/3qmEnEEVVsYlnKRaKxQDRmitIcMYoTEdUdE+6GMX+A8wf4rkly8TGEb4BvgyfNVLFA1Eup8VHQvcQXxMgl/FWBiJGhBhkWMYKh0aC+zxjpOW+i2+aUZeTW7H5fU5P8a4fRVjplSqlD1+5hxWVz0G1vltRo3t9dk7vmE6Xyn866k6XdhcXjiwu7S0/WOf+pVH7iqj1Z3lWYOy+3sKv8ZC3Krikhxf2e0jmgh1FPKbUZO7yedp2j1Fjq8ZNKSmreAj1AceVH6Hl0BD3/0ZVXfgQqQDeo+OjYzwySGbWiN+53F4VK784dLYcae0Wx6zi4+birpMQ+bdF89E/3/W+IaoF8dO7dpSE4ri17dHbb+NY76rRfSaVfaevuaB3PJ01ouaNe+6VU+qW2/o4W6K+FstHZ95Rkl7jufyN5H5px3FVcYZ85f9E0e0mJy+/CGfdkj5ZBXDVeR8mTXTn4aeHBy54RhwbLszhKjSnAIdRsainRbvTpiaQ4HKJTZ2MsIvKkVfENxMaCHAjsC2FBeNsJwo0Eorowv4J4CK3DRgSM/JAxHPGQNOJCgUzEYYNHsGoBaWFM9HJ3r7BhwtwpM7zNra1e/5HhpaGK0SvKc/1Zi4P1LTlneobbiopau6W+xqshvJoG5xx4ypd4JLPpa5kKL6DVmJPTOkv8cfRSYVNRqKEIThssFvuotjoO9nSO6g771mdkLBkdmqWiNfURM+2bkVfnUZ+qiytZpzlXrFowwmyXoMm2GNiSbzIVolUhyWpD+1/g8na92VmwnAbwXV+03G+G73ljUZ83Eu24DHdXRNXjeegU71Neze9jzqNWEmsfj5v4kuCtUUiAjAzeFIVHzGENapebV02OEEYikrZKCQEP0aoPhImqvc/Ao41FNOGIm/dOQFwR4JywgbhF0+hTmt/CWgg77rzt/n3lFeXr1q0ECm+Oete6YCCvcfToxjy0Z8iaBTUn6qqbJj19bU/7FHDiQ4b5kIETGmdWdYcyxJAziwz+HtHfRPepSpWdYyqTXw4vLWsbUV5mnDZrOj2+sv2GK8FrL8ulOVkbj5nE/oAzy2Rw5HWUojctpXOb76xgsjrn2xnzPSO3nyzofzpvLJw80e0al7xl7CPPB4IVPV3lYBIDRU+3RD1Z655m0I1bGOWyMWPKyrsusQ3XEussCfAoac6TzwQ8QBP+CXpzKRiz19AZrrfShoJSb5NiL6i7Av72Eu10D2wJHJyyvbxwyuLGa6zJY6iV/uonWPilFyjmt/ibZfCYTgKIGweJVIy3txLwNXnLIzVZDlLwKjzkmwAARTaeeYBqomyBCRS6ecmIinBV5Ic8YDOweNgoDf6G+mBlo3pxL/j3AfTNbfE6g4llvYZw6eSjiZaWxNFn8alYqvBnSeMTDvxpxW1Aweh7F3vqRqAdyGx0QZt+wze/eXRzRfcwT3bb4nw80L89oGR9uGZGkbocnyYvmaUP6pW6tTtX/unA+AN4XdTi/vhv3DaCpp1SnI0R+BdiWiVyEi12Mq6BIUVxEaxQD0cwUE0CqlbKnQ6veIt7n+BUh+yx83A+RHwhvKSIGijFRgXQKE+u335y27ai9oqQ26mXg5iWZlrHBLwSg8YgUwNMfpUP1XfExJBh4/+OLB0ZV4mVcXHWA+2e+hWjavROWbmekUJYuErBMmLt0CzAMLQJvqdz6cvUxir5dpBTURszRMuGN0xtK2M76pTFcsCyYMnv5uUsUekzDU4ImJuH6H352YxZNFlr1LGQASAvSKusUV8wkAGNAEJIy56qovVZdYwERPOBLk2LVWEa9Fkey92F6eehPM7vRYJ+sPgb/nwywEGG9Ad+sAa4mJcgvxAEQKLRYhLAAdU8FWuE9aGsnNranCzaEg7a8vJswfBnRUIKvL84QFICxeh7Z+Ae9NEhk8dlLayytUuSTejD50DrCw+D0tNw4dXLY7/dW08KHAL2e24H9vsYaXsoHAyE0SR7bp7NnpcLvrg84V7mZnT2wPBmmpYyGrjxvVeA8x5gP7T1k2T18j+MeXS+b8fXwPH1jh3fUOACwvQCwdJ2pPws8/ysjxagrCKYnyAIZzz+hugjl+gCxdqUGpkClX+tdSokOhPdc/40Wu6joVuUUOEV4jtz8ByVoRazJ9G7JoZz6cEExtM/9Q5lVlBH90n48Xghydcpx1xq5iW1gnStqTqBDrASMLje5FfoHW2GUqIzoqCPpj2ihAe98sG5GaCNnoTcF2v/Izpp4Gt//hllVkBP9xnOKdmc/heuhhv7/3bJPFTMzwmEHsFfTuBzw8aUKn/KYpNsh6fmJR7Smf+47KXOfAVoBBG15nX00YH70cvzOSC+WqpSc0PfXjnrqWtGjrzmqVlTjjdcTVxxo7jVHww4Ns8FuhsPAPvryXNpZb4zvFIabUcvEQy1G7ZKLeJrJFA6aRa+/E18l8baaxyBINEtJF7JN01fuOb1/WhAu68nrc92UafFRngNJVTztLk6H1xiXbYZ9QvENk+Wz7gP3HCZMJGlcObgQuixn8gLq3Bdz+K6tmH6MqWRxs+SeAYhojseNNJA600OOsXxDS4RwO+NoEMPmBPiEcbzdUQL3aAj4j4XmYt0xYF8+PMl+PuKduU+kpf7cK7Z6s4tU7sAUPiSE/wKAHzqeChoMReczM+5N9tkcWZFVS6CN8aKlRJVRb7XbM4/mZ99T7bF4s4pUXnwhVb4pAVf6NGODFss+JY59+dYLJ68MpzpVlcUeM0JjsuyOB2MVGpYCa40SBlGakA7dhqlIpDhtOZyXLbZ4WClUtOqUjqPzreF3AGzSMrY+bxcq8MGRVLDdtRnkNG0zADi23HA5E9l2gErNV3TP3KlQcrBDIc1l+d9zBcSDMLvODeFzcGbo1xU2PYMhIgyvmCDHc0iWCLIZw4xVhHttcyzeK/zWOdZPTdO2VAb7+pavRCEwJ8tXrZuaEYciCyyyPmExeu1MM+eryJn8KW8oGz18p1HVq3I8nl5voL0KWqQvxaiUVxHNRI/Ka6I7yeaw66IzuCJkPNPDEQv30fD5YiLTtCDeiHvWiyFv9fb33vmjIhKZp65mEgnLoZh/MyZ/l6yezoI7M8PcBxSiUQ//jGX5CBqcCxVTJB58+PFx2tYqEWZ5B0SPEQ8k+N11Ec6ZyZOx7MTizkjNsr0bXvySfT9kxDtH78BB7dtGA9mQQLLR4JoP4Rg1nhIkSJPbpMbj48mWaOPG+XCZThkxomXjFUfFaEoL7+7EYhiFsoYFraZ8VLDpd27xHij2Z+Y9rHU+q5RlV9B+FXlqK716x/eAL+q6sCBro6qr+CGh8H6wRRT8uENZavUSvWqsg0P4yKcelXp+ofXl65Sc13r6TODSSdugJfU4G9dRbVQXdQ0zE1QVL7gPIj3Nyj4RjMRPEQVjy5xkbELE+z7kBPo+I1l3ogYEyR46Rwciwp9l58/Ayl1Fl7ULuDmFAvwdXo4RF9omXckV6q3KGTZWvemURb68fxv63W6+FiCb4v+SuBzedjbE7fHdRFd/XmpXCEdJ5FIrdJu6fsys6xbKpXYJOMkmVolDyrTo3xQa9fi//vGkaJSXMwqldA3h/TS3CPzLIVSNjhqk1sGHsj/ph7fMH77ievSdQAHwecdG9fp6kFu6kJ8Z9sX/FHCpzzJ37s3VZVWOyRdP36iFOYDebcMpSdfHvhY2gUv2xYCUWIWrDP5AybWFxNxMR0xEjbFWB1nDMUCOh+cDJzAOR/dyv50X4iZv2fGl9VX7P0igv6C/hL5Yu+VVV/O2OMADduXLf9++bLtoAG++eab6GEm8TMM7/mmV87TY8+AOvnrLesOHlzX8rocPXVmLH3+la1B9M6QQGAIyA5SvN++lG/stI3BUN6zC9lxuIM6Sp0is0Paa3fKjf1lcfAL+b60opMH/C/vROaiYpbhQTOqGLwCOhjNZUU0A05TgeAhU3CTeTEI4z+bnHzW7ofQb4MX/purQCKJ0Ga0OYk04bYdx4ACVAH58R1tYc3FMn4bStj8Zy76UL3oWRUt+bnUXX7bpk02f/K/uARco5DOgmC6VKEpbhnWWubzlbUOaylGYy6WGIVviW88IBPk+y5B2iMaPaUprLaBeUlH0KKIEDCdwIsZQiYwAL/HDoRgn9/qtyI8IZ/lzPCfBIZYiOKZ/G4z1/8ugZECmQSUOR1i+pI4P8kvFZCiZ5uScdjXn0CpRQEvEpQJxM5cdPie3rvEz2wnPmP0HNEgYgIAL1B+bTUwCWAH5Cw60exDC/f2HkLlJ9HeR8GcdQWHeveC6/1zcPqiT8ENfqaneY4fLcJFCtbxJU6CF0iRG3zNc/Gln4LrfbgNDPpM1M/7KzRQZbzXKEGMGCU+TX/Ox6eDxZRNlMdAi5pCDljF4hGvFSzxYnSEaAKk/FnoeOcYDmBKzf8GTSxqpGdvPLoR/wffb+geu3Hj2O4Nf4mPOH93R3nOuMZx4bH2TlhvEzFWD7eQrTbV+xvDQyubX1x9ftTc2uWzho9mgNjFAWbMiFnLa2Z3nF9tyQ7QanpiHfNJ3URDIJu2d6xc2TFqxYpRqTP6Ed4yZmj9+OQkk9uowlcCu4i2WMcRzwa0SKY2Oc17ZqK/HV/sySwILwYNAIoBenBJqCDTu+Q4sM3c4yu2QSkNTzTNmNGUbFbZislMOA2vhQdS8lsVZSG9yoO7kUejixF7fEMMaICLI2JZHZ24ATpvuCF5fjRoeBcTzMPRE+++i5bMZ4aj4eAo+SXFiLad/8e77zL39svQcHy+AriE/jsS/cg+jPkPI5WDZ6zh1HQyS0HyqnkCSuCAeYDVgEgFGN7G0Y/jeCEioi9AFr+An+bBU1OeOAiGLu+EyEu+oJbFURZP2CIBD5dXscHFaBaw8kD0gkfBAJap2AfKVUUWs20vXbQKfa7x6OSsWJvtUTzVkDfKZKFLuXvCPqvy3gIlq/EUghWvDBfbk91seVkJukJsywKtZUEJ7Ye30Bkq9GKdGZjylQ4HaF4fkth9hXtF725E7ysyxZKJ2SqDXCltPtagk0mk/o9iqkAXdFtCLY/Ww9YMrVuSg05F39ErDVJgaDWEDDkaEKi1cUY4coZe0wVHe2w5E1RSjzb5zEsBvbRFJYaYGCkIgun31Yp0GtMHpbytvyDfSVxiC2GjPJhmJT6F8NfjKTwND8MZueRH6Fd+w9Cl0XOXwDu4IgyFiIQ/yVtusBTCBNPFHybw/MV+UeIcJWNfwfTcorazibZFgCIXXcCUHU3x11EDcnr+1x+n+wSwZyZ+vs/l9DPvned1V5l4Al+aTSm4d3jsBSee10Zimiw1ag36mBszKimrmhhRAOQB1nhcMQL0I6ST/Ww+XedOQdZcls7og7vWt6+fBVs2bt44jNbukw7/7O+fDZfuoy7I5Ff9c3/nfRunlUHNXulWsAokwKqt0r1IJjuGNqIStPGYTKbZJ30SMtAKmSel+xQ36jNzczP160L4b69WIW3t6mqVKrR7gVo8e2puVVXuXq1cunXXrq1SOU5USW49ePBWCSn4xKuvPkEKEq043o6G39McLKWqpoZRHdRUai61Fg/Oy3z2Uf/lmWB3CmiBvL/CgbTBGILqQTrZg+lbkBhG9CXAK/wJCSd62ODYzybSw1pmteD/KH192jSPxUc+6ZWW4nO8RJ3Fx8gc4WryH7zCn9Arg2M/m5hMgItSfXhByOrjocMFXgPdyafR1DmKlBORIx4lLXiuO87T1mFeP6WY2BFytEiwoKyCrJoTuXhDBQJIyHchomrMK3hnUprigJH7aQnA66s7WKbr84bMGFcN3ebIkJVzKuH49/8PWlmZGeWGimt8f3DmKva5K8RDxeXuSnAFOBp+7LEP3kMrKvAlQ8Vx3zvOHAhycUFwqn7JxmkTqnxM7cEcJ/qMlZmd1pK5I9APh27H8ee94aBTGitwgQpXIYgDdtPw8WXox8O35zrRC95wIFMsZw3esNjor+5ck57fd/NtzqcqeHsGBxRx/AYA2W/1OZg00j/vxAgKLo9wBxBx/gBBYuABQnUOWkscUgChYFQbzafTJWG3ziz15xjGT51axlQF6q+ougbcI9NFnXr9sPrwmGhuqTlYka0udHDOvGp3VkEHGKOJafItDlvdkikSkTUpySjLsahGDDV2hQOeurCjLC7TerJNjDuvxpdb1Ek/Wrn+tt6akftnjPAC99Z1AXfHM5bsgzvfffYvPU3O4DVlne8fO9Gsqt7m1ISSsd59W5Y++OTRw92rfTnH4DOamnufQN/gf4/eVhhTO6+p2wC4P53euzEiqtnh1ofTNmUC7hrxv2XG1EoVT1FTwBMlUs6YiaXxmOEYH+9QShcGdFjnYXmLFgJAYRBUmTlj2EjU0gVBQ9QJfJitpMOxsNEUvnx0cY9doyymGTktP7e5TBZH30IQA6o7NNYVTVc+BFjfkVlH4P4hbWsPALCr0F8RGN1gNDUv3HwrvLYotyi/IaoCfYka4/cPet5mVTcnWop/5Lu5GB+h27dTIs2UxlaBQFQxYjxqHtuwMgNBuCm5AW5W21ZMnNFk8hocmS7Z9W6watqceovbYHQBi/iWaPJ4j7GZfvY8fzOWHzPqgXfDUVrKSnmpImoENY/aTO2hDlEnqT9QH1HfgAxA/FcIUpioLxyJ5jMeN5uOF/MbuXwO7YlxngDn0YVNPgJ44IkNUGWmYiL7wq9McH3H8UIdfrYPuAPFhDXn9fSIHM0U5jxEPoAZYb7nkr2XsEnPeQggDZ8k0HmYlvOTOnAuhz8jd9FWjLtY7eWPER30EBev15MbkMe/WJDgTPN4aB6ikuuJxgjyHMEmxvf3B8JEkyUs4vj968vFcgcVBXqNEVxbBQjlJuHsUC8vJClxh85s11vOjRuTW5LZGGDckdyREBQzalAA9H5TRnGBUgKAN8PB+TOaD4iNOptEExzjNnMZxkyJJmeUY56dy4ASVicWiw26HCimjbEXuIW01eKwSxy2SbFsT9Z2hQQzvCWYsA3TStOrErvRGbRZDDap3ZgXaSyxvsAomHygD5js4QJMd+DKxP6MoTuUnEmjKaF10mJGZbq1JCdCmzKcvpjPaVx7w/ndj964MTeUu2QJPmy88dHd52/g01blhfLnzMkP5a0iaWDrJR11XKbRUUEzrAQzBc04HMoKOrODD6Bzv/vdSy8B0aESkXe63GjNtAZyAM0yQC9lcmVMEa0RizldVhMQwQKxjpOI9YEmplhT4KDVsIArkOfqN8w2ZRiNyqh4UqwxO2AKwOIZys1DXAaNr1QZy3G4FeXiyuKGsYu15hHu1P05EX932uyHoVnKWZNkmL7PRed0psJgZHjGywROesGyu/fOnLn37mULBPToBQtvumbSpGtuWrhgF6McPGR47AdhzEjxrEt27WqpMdQUag61mFpPXUPdzHuRJEi5vKNyPR9giVG7Ju3Unk3Jg0k/i6UlxmnvSAG+U/Fy4VRXjAz4ItYogRyyrovrvU/n4QIeXSxMtF2FHwjzGlWkushP5H+g1JtRodFU2r2iL+M6ffXZjmkjJk1qzqtw1NSAeFYsw2AzZJjdWaW5Fd58n1hnNxaasnMbw3Fg9GUVVVfn5/iDweaZM5qzmR9qDqLn0T1Ij5DIZfX3PzBn75w5ewG8vrF7bOPONx9fuXTpysfBlW2zW6pKJtdIgKs19qM41toa436MtcIfwi7r+zanonj6kuYJ6Jg/PBa0/jOYq5dqlWqDLdcXC3qy1AqR3Ki35QbjlVmtvppQYZ2/VT991/TkY1AV7Nq16dpCP3yeVDpHDEafOYPulZR0lzSXomPXqocXFKNj26D3vLxk+PAS5lt8JGuBduDbQUxRKzEfacf0tB9zkyOocdTr1F+ps4AFEuAF1WAKRenCARALeAxEFu8zRUyYoDCEQz7hBIQTGw4QZ/R43jN4Ah4y9+k0YVMM6JWM2+/BaRwm1E2Y0PAZPBpyI/IbMMrS4AXEFI6YwjFMtsdCZB/FAaPpRI3HECD/3VzEYyBrFB/jBnhUPgP/XAb8ucmP422K8LW4pxnIkcehj5GH1os4B57JPXzXII8S4sVrfFoxXu75RBPZ0Rn0mASNTejABL0uX0DbNvBTd9QBYgZROk/EyxJSeQ5Aa9KvA8/VONXtVzI8FRbj305k5dg8WNPccGjnTlA59angqI4s4MpuH5mDPiVH8MrY3H5j7cTSiVstV1oalvUsmNPZCvfLNHZzwJwl2dDWcYECTFv7G/PRB+++u3/3bvZtoW8ttMQs7+kW62GGVApMpnhWp8RSYvmb+8Rxy0nT2SHB+81FyWtzcl403jNc6Iarwo5HYib0vLPkLVP9p9EQOgTGxIpPG8qdD4rFDNSUOu+uSOaZjRZtjdk9pObmwjL0L4vBqqkBmOk0aRviNxVhvuJPf9q3ezf6vBb+MGPDBre7KOQuDm5e6fUUFXm+MMfXr3dZfDk+SyS4aYW3bMTu8Wu2Wq+wDNu0rZrLVjnlGpHNmzF+8vypS+jR85JXjBhRFIsOX/BuhWtIMKMSfJ1R4Z9XgL56G/9VVAAVugDA448n39Y79AoOgnHd3UA1dmx/CVCV4uuSb30cGzEiBo9UVubnFxRMBcrRJrkcwMrKsjKwJhf/GfHf5Mm5ucfAlaRkstuY+isrQ1eUl49VzJjKiMeYzedNQYnEnRHNcxmmApUD3G3GcZcjIvGojFJuClCBjOQyXGsJrhXeg74CquSy0WUWtZTzewPZpRa1BIh8yumeMotCDliZz0ES9YwI1qKvX3mlomLbNeUQ0FJNhs4f/AP+mtSpU2R8ygbGpxxzu8QjXw21hrqDepb6GoiAkadCeEaR2IiLWKJ2YxL5fiaNcI942ocp0p8XPRIrc9bNuZUcXg/CAkQqUUKFHEGL5c0IYwKvUMVUAzyHssTUEHIBTPSJCNadgd+W4KX/eHwRxOcYkRsRUqWMJtdcUg+PzM+XFOohHksv1uKgQ/jB+GpivEUjZ9CbeFdxOk+s2P8Tfq1WpdOxem1rJcguWEuz8BSJ63Tp+LlYQqxgWHqUTFxlUaksBSPbCjIiURDze6GClbJilmWgRMK6aIe9WSrWm0T+SIWz2G/OMdloGVcC5AT+Oo8BG5uNGrYol2FtgOVEMpGCVQE/YIMsrAxWqr6TfrpJKxPhIapgFTiXY4ABamQDtVkL/VKOEYtBkFTDRFKVZFstNCMh9tLibFEe/UjMIpZG1GpQKtXADgBk2y+hHB7R2ktVkqIs3+0ZVXTXQR2OiXGs11FFjwULxZyEQ7sknGzIEJW7scgbMol7RBBAyDAiMZuhlwKxV0ZMUgAjt4V9/hyFQsOJxTLAQlbEPqvQjGRNXNcwwLSOxQ1kcDkDG3k+Ty3WdaoVFnBQL5JMNSnQLXI9viXLseOkSqWnga9nokgkFcvMKqlc7JVDICIVNOfIlRoVflcMDSzPqtQjxwVzv69j1VAhBStYTgauHEw8SAfRDioqRDVhymEcjw27nbpFoBswARAhiu+eKE818HRCikzgUsjqxImQnycTYvideyIqOpwy4xSUydiIAA6LJ3KCaanjKQ7eyjaQQrKMXdww4DNEqesDvIAoEP4JHqio0qBzmbQZ9lJwYoEoFD77WW29N9NfVquta2/NL6ypCzgLM9qd2qaekYVhzET1bNLma6py/UMzCzLl2eBqlSKzQCrdstdaoi7YuxcuyAs2xiPirXu9mR3hSpSbX5ufX0s/XBia2LOwOjZnerm6tDFHb2J/hJdyP6uH+DySM47RUz4pr7EojEqra1GmP9BQVmNWmtROi3Zxli8LeBZeaVginvl/RnkdshVc6AXLdjrTUYKyQMiJHgJ//HBNaXFJQXKtZZ+spAY8T2ouQP9aXB3fuiRREQvOdOp0BUr4yCU0H00pL1Dc1yIyQ5kI4gPQmsgLIvvPATZUzJNqZFUERgKTQpDgosRnWRVD3IqkN7vwYmsiKv8iY+XnLcUovvftPQBQanV5Z+ZMJiwG0h8fltrEo3DgCV2ovasy8OnT4pK2EvG6pyPgDpwD70cHXipumbN3z5yHMjvL1eqhM0VxqU1y9l4xlPbgArdnurPH33jv19v3A9au0xM9f71Ou2kCmIsLCHabF9thxHTPcLILNfDwYQlIuetUg4HWxVx+OqYlVgy/2DBGaMrQ5A/0/OxHt024qbuQ6Us3dA/87kjlwkpQN+oXG/pwqnHgX/DHruXVU+aFUQLFhYZvehKoJ6MDzN09v7bhaflKgk0MyNRiREuJ+LMkO0Rkr4zMvL8UBy48NFwijk37mhQGiCftyyMmIBs4iecfSP08RNTgcPIM6CvkpOg5KUcv1Cp7BEccvHATRBpUw4MgHhyuagARpbYX8mKjJH/pfwjT/14ugVCyB4f7WzpWL++gH+eructXXOy7SzsIRzmX17Ikeg8E8ogSIGXoDELpuSsHa2alRXjwP+m7MBuGLl1d+hr6HKhfcXfMbC9Rr1Bvabr2kcd21l8rEa0USft/SR8GvD4/NDwHj5s3XgFqiS2rKW++Wt2QU/TYrn0vFGY3cBIJnfNLGjODZf5K4ruXbwPZQuCXW5YotriFmS211azlkS6rBe+sJqOwRxjGnVpNudx8W8kcSeA8eCxHXp2dF79nUvSrcydWr5lSOXdyT28nLG5ee+0wkY6bVGBniw9OvP2RrX/dNuYqP5QBCbsCr7pwFWvJtJd11Raiw+j9tCL+R4/IrOIsMYDSGee38b4deZ+NoAvcDc/OW1M578jkRWu2/Vaz8P4pYQgirlBt128evBVIb2mM60pEchkrS95sNgesQBKoXDEccyvj06/oegmUFcnlCklHN7klKAH219egrgG/R7y8zkMRObNRTWyT9CpAdAeIZxc2oCP7nSkFAeK3RAICwCCqPzXxL7Ok0t9LrdLZyTt9kVcuUPGED46bLaTN+vOE/hdgvC/ZJ6JOoR8m/HkWTvy9lC+biAPqlQhflk+b9ZeJ5+J82b6UHybEyzyzUr5WOIobcNjKO+AwUh6i5Uv0oGNVjGhEw+w8dHzb5NUbHh0PN5T3PxG4sgMw6Ls/rn16aRlXX1KlylJaappnzBJRExqqu5Lb1447uTExCtZFz3/fMs/Y+Af07YQ7Xl3BhgJuX+2Ecq/qEtlrDl6J11HXUgcEdOwQj98ZIia0PNVG1FRJREgXwjrM2gQE0FqOxw/7+Qhhu4hKm2vgn8B+CWpbTOSiAPOnEY46S+W1+e2OnIaszAxvW35em9dhMAXMnhyH3d/WzWd53Hwkz8MXyctv82YYjUFS5KdX8Ln4kkVtceLZQvgXb1t0nmoqiQzT2d12nb8b/sdIgoiP7DazzWi0Waz2DItFp1YacdyeSsQhEO/jM+1WIfOyclaLzdjXtgj0oXj6t4hWt3YMi2TkmjOdZf7dLf8xIox1Xi7GEn7BZSBePCTAhX9i6kcKTwOAOpsAfTCOg+cSDNWfgLjPJfsGfNv08eufGq+AFGZTeO9feDYL61zEjwv+7oyWpqB7Dvr41reEeeatJ2l21bzDSeotPN/AK5IfzluVnn2S1K3o4znwDprCE9slz+ZMPxtZKsgII8MswI8sYvxHlgr+eTkqoF6dvBIPkE9QTx8cSgLgzdVqjQEcU2qFNpxBrQYNXypdSCgT0Kb8ZXEUM47qIRQkwUpmBL1k4heM9L8UWIpgl4LXLCioXBMnNgLCt4gHkiXcjccBTZw/wBOQrFwqdRR7fWDI6T3ls4e3hEodRbLM8q5V7T0PzvjDrY+MLLGNUmWALejCjd9dNeaG384ec/3MMWXl2WXWnqtHLvVXt4/pai6R0Q8tHN5ZCORGB7PJajc1FzXQcZEnI8umkI77atczvuikto0jrrCPnN0VXHi0p/eLSdWR/W4v2H8bALtmv7xvvL9qyrQrlu6KvjS5Lbsi02nKK5/doNYsOMzQpmyZLY+dWmQAhtpL1oAxvG4A0W8MFKe32TxGTEIHBBwUPY+2ixc8Iy8YYck7MhmEOT82AJfMD3Au/DPY+Ps/9XiDEgYWeaMaoNdNCEhdQ8Jt66B68rSMYMgGOsonN5hKA0NGJDqmn5hDMxMenP/EBL2sInvJ2KX7D89atCxf7DFmeWMlLdlz988arEkGPnqgVqrw2aFCBr0FKpW3MSrN0C9t49Q9XRlilT3LypY1XF+wZ8bKpqJFj08D804sXmAzz29renD57LvnrjRMKhtXWh+wbYcfX6qwT6dkyQJuafgyL8xeopTrImpSnAtHtWo8eRHjCjXuJa6QAzCJlK6scKJ5zVu0YeX27SvB5llPXfMWWdOSVHp1o0kImi9ekD51o2/Rq+jb7pHXgLsuowsG2TNSPEI/ZQZC7TD1NIAZMB3QO8BAPTMG6maOXlIjQKlbp2mHGy55GH7eJ6ok+ESsP82YKiLSM/ydq4lCukhNxkYgjMl74OKMJoZ3BEDsG3i/gIReyMRTSCbxMRcLkOWT9BucQng13lVxGI/+QCpEgN7CIXgOvRj0mE/VNBFPG0sfPvSEthQsBpkoc+psA8ue2lpR+aBKalQZPNoHJ5wCYlCBzqKd6OyIhhp0UOt6wdR/90l0FnAnl0y/mlffBAlwrPNDQfnSpQeycdNPgkRD5nnnKfTjqRu+6KzeDRJbZ+55HohPmVG/qVgpywDMpM1bTwH+vvhOkx+onoJyrIffBxxYArjYY/5if4KoANjRotzBdt0c33NyCI4fdZncWpcGwaJFvMwZXuJT2nM5rpammEhciYmaSZeWQzOCjDijifWY+ueYPGwT63cwfof/H3Z9MqG32/UwoQf3k8JJCh8SlpmSR4ANjAa2RySzTUA2SM4M5SBhysgwoYQjPx8uCNrtQXtyXPLORGTYsEhCOMJxixaCF4evqKhYMRyVzeDXhatw3/sRrwv5RHZMCUOe/3aYdxbws8Iugj7Fmyq4BEtZF3G3UgUBYQgERU3cBwLC/FEOeELTSzCLiFOcx0LeZK03FPLCp71AbOrPJmH62i703gOPoNMPmeh3SEL/si4QeGDr1w/OAktD3i2aLe+jN+76Hs2d+hTJ3YrjoOju78Ceqae8Ifi3hnC4ITx69KiQxxu67u6H0NuPpMMzH/oKbPWEOjvvQm98sAVI3w15+Rgo+mAL+v7dELHdkF2gmO9S39aG+/9yHsecNmmJjIy31f7/OrsSwCaq9P/eHJkkTXNNjjZt0yZpGuwFNE3TIm1TThGkUBaQuyCVc6FQgXKshEKhiq5QDoFCqbIcFkTZv4oIKwVX5RZQXEHQ4iorrrr+dV2hTR7/994kbcrlf20zM2/em3kz7/q+b773vd+XiYtGMJzMBNpPxlJH5WQ1IuErMmKBTh2X67LJipdkSUFh5bxZFLdJgkHH48SIo1NcMkfIdR4W7kwhxkPVFO0LlSVzdNFkLuCpPTpLDNEZyYMAwx6YPWd7Sh56xso67apUBzq9VZ+o6T6/fxfRUDxpmV1tTopOyeuRYHDXxz54c8vf6zbgdspFxyucKlVar+GPliRohRithovvlZ/kG+FkuacUchszOKfkJVu2/JFcVcIrCWk5s4eOjV+Qn/DAtpKBS4/KGFnmAz0Lip19S7bmF6eoxzYGNswsX3eJW47eNMJ3euYGygfJU2MZQWCrJ6ARSh6Ou+wI/Jy84xmLOmZg0qAJvhy05YHC1X9qfAkyaV0G6Lt6onirPTte5DhGFJPjLaaYzJreiRVWlYpRnmEEtaff5sF2m081WaeyfzbCW7bI8rC1YIEGnpkyqCx4UCfTLp6xuuyhCf2moz6agrFjfOtR4O0ZqXkwut1fI+F/FpBDsekBdEcyM0eI+xFG57xnSo6TKJ0YV4otiapGIdU5MWYTZ0siAPMFUMTiK6v7QP1S1YsH3npm7a7ok3y+O69QaclxjWM+PqPeFY4/xRVkkXiPq6sX/j4xQ6aJZ4YFtwSfG8rH6mQZVmuGTG+WpcMVUGQmDOdjdHymtekGYLT1r3997Og/9zb4+syf0+Whnskrb48Y8MYHx/LlKj1TWMhpouXd3z939v18uVrN25KKOLVa0f099mQLIVthvsKX4npJAA9KVpUhUPaUCI+cdKRTz9NqGGb2Yc+cOeETtpn6Bm0oRz/QAP5QP7viy2ror/5yBepCzok/UW15Aw2wq5CWXvNDeUMrBRPn8ed49ZewX2AVvkuvZqWPd9BQzpZL60y4iHUmBdRSCNxugctL+NhCGCQbx4WT7nbm9LQZBNG0EMb7bRJNYlzMiZj4eLyLQ6YiT3Wv+PheVZ4ioxeL7mNj4o05pviY8Vi49xqZR3p40A1PDxxMLDzs6fFkTWnr2dKamlKuS2kN88ZskgvZoRZPUXZ2kafFZLpG4q61Hedu8hQVedDjRuNrqUXMlva7ayJ9TzKYNRNrRVsctJF/xR0rGdegS2uuQy86hB5Ch6AXLmamNs4N+OY2Ns5lm+Y2wqOMK/A8lv4B7MbsaI9vJN3B3IYD+QgYCiaCaaAcU7+FoAqswN9/a8FGsBXTwp2gEbwM/gwOgrfBEfBXcEbCWGbpKlQ2NFtrk5FNomssXeTLSugLYjaJEkO0zZZDNgn2QqT4vXiPC+aAOAXSWOLHwatzyQRoMztxtgSBVHB4WWiGXtEGc3g3/sgxm1ibF2qg2yOYdAZyn1nn1ZlhZyjovC6Z08GbjQrG6dLxghuaxc4M7jhsikvBeFjRIUKhEFKPglHQnCMHFsNpNtZwhLXFxGpRuS5bh2bpLGY7d8QQy54xxMYZ3of2c5zdbNHDZ7Q5WvhHPUn9wJwkHBRjAy5YjRqfQ41wsj41MAoyZxlexhw6GK1ldqFFbzOp6GttOvMK5Hw6qymAPimE87RFaCh8RB4o5+EwtJLDY6XWh05uObJtFwflu60b4QOff86dPixj52mDay6gv+FW7RRcWAOvpQ6Fzu+XsdAk/4SXo/4wJ9C0Df9x+V2qOn3AsLuXPMIzS4yJHNqsUBjw4RW53GzXGwwGW4xcBYu5RINCASfyiQZ8DXwUcjBZA6cp5TE2I/6zxchUaBO0maLV6BCXGDgNJ6B6LRvPKZQ82sCw8H046qicgU3HjmlbfyfjexVPgUp02odWxcMc9BKnwdfvk/Gwsgcs2nHlL/vkrAcyUBu9D0ZHoeNbYLdvP5OjGw8fZ1TNV9PQu+gIdGueRV9eSYc1rQyuCiOuMVgJOdQVHYD/+RxdCzyFvoJxf/97HzhFyeG27hTcXMJK+hLqe4Bg7gE6DNoGBW7wCMO//UuZa7B0/9LAv5fu586+6stE8Zm+ogz20aWH4eMtPZa9/fay5NfgSwRDHRkye0p0Zyked38ASurpnehjOMASAQbLLzwWf/EJ/tiEeuCUTnhiFZMDvDLBxO5A7yD7PMNpWHq2BE4c0xctDL47c0xBOZODtlUwOvhYJzW6jHzzJrEfHNm7ou738OFTxkFF/NT5KAEdGTH8LBx/+umikbOCR9DCh0bCKqZba3c4kTHMHT2pEhWgT9WGrKLfmU/D/jM2LHslRCPkgPuF2hoTii5KHoboDEkaFHOwuJ3jTiKaGzYcz5IPXizQSM7yBOqZypxjFsrqlj557MgXa9d+ceSYfxFf1wyZ65s2XYcM+t8lZ7Ys2v1u8/r1ze/uXjRl/qsjT+zZ86P3w7UbPnu1Yfaic3PObd9zgqtsleeNWrt2VB53Y/HUqa078orY4MBnnx0YYNPSHdOn29mV3PN1PQJD3FmPT+MleXo75tGj2tZ2jP7v9dB3nLcDvEYgvlAaY4X8ZathjMFKd+hLq6GMhPEOXb57mK/5dkdr8o5vn5yifGHW4wMzYOpf1gXWqFfs2c5cMVqtxqCDXMiIZB/8juzhy2SPhtDwVBpej/c7dnz77Y4n3s2yu2a90HP/N2sC63rk2j4FxJs0uFUgk9bpSD7ijNRLnI36icsAXYEH5IF8UAR6g36YPg/GFHoEGAPG46/6aWAmqADzMKVeDKrBU+BZsBqsw9R6O7iARwRRATnp3mMzkpVy5ts3r1mI3Ig7pMgNEnyy+2wk3W303iPVTOxvjMJdNmeEa0eIpawcE5nCczkEU2i+GMpSJF8DJrPbmykjymsZCNwIyvnNLceYdcy2lmODneG/Qs0UTSLerPQ4WVM8RTOlEm/zQ8dA0WxoqIDGCmiYTX+hcOubzooXb4//YWBFW8bOYM2SN99cUrV/P7ro6t6ru6t8vIVN7DkuwZvr8A4q9j7QyWjvp8FSebLCqraYVAlej00GWlahvbCkiK0PTECX+E7Hj6OPKyrWRvyes3e2qe2ZdrJF2zLt9kxb57GZ9kyyjelsz+TOJd/2h/YUV3SMqShO7pAn/jn2V0lvC/+Q/ICCh6Kxq7swVWlKT8zsLMAogzFGZjJ3gxo2ipUxSnNG2L9BBR5/z1KsidTbvmXvthAw5A6YCBzjtjbX1zezqL5569Zm2FyYceOTjMLCDPhKuo/50ZcOX8kohDUkrZ5cWD6rnsttOZReWJjO9yL7F17A+5A82gnTr4v4SHCb+DDoktCOE09VzSHvtUSaAJFQTSHDMI80yRE2nZduyOHXQ27t+Uv1QzctmD150uzKDUM2vXN268RPhvJJ8XK1sXsZ+nlx9dUVMO5M5YX61dXLt498vHrJOOsknSFR97et3ablZ8k1xtgHXx17GHF57IFT79ZuOecdXVm9rHK0d//GLW/1z+cSRKM6xvPo9Cc+Xn4aaoev3Llr5fCFZeP8TqtBP9Cw9awz3WnUiHE9+7W+7UzQhGRa4keerF1IA8NpradJ/jATIDVtexBSgBOCgxLG0udCR5F6eKB+DWzU0axN8sDhZcO6FStHPsc54miZaC+oL2YaCF6TbNYl0/WTSbGt30KBj2E3kEsCwJJicjL7TknqE22sJooTILfPksJ2zIUEgpGG7GwTAjFOdoGQEKPUdiFYgRa1uxfHenEwWp9ocgop7bj6pNyS/f8Qqbdpwmb71PuaGZqyvPC3lpkHKdniGvzYNVjYFCEg0NwguOY3l1qshU6SgD6tFXHOt4BI8rP/92UXbt3C8jWkcjzxBKqi69pwkqhgbS7RpmBsThtLBXunNGVOPYsQTARb1kfMTPQRvA7HBPs8dQq1oGY2iGP+EjjKNJ5C3zMz4UjUjFrgCOhXM9qAT99NH/BpGTX0622c38aC4CRmYyDActTfR+AfzEYagP7HEdB31gWAwcABXWc9A8iaUVxI4TvMi/qB50EDZtBEPS+4KBT2/XdeaSHuPXfOyIt0LJk217mJi1MjgSIlPiJYXfvVv/ZIaHTyHsJmBBE3sn/kkCH6HP2QITh8zx256H7pQ1oyIq7yndcZrPv80mSQf5/VoDsvRuZ038dBHyRLihDuL1KG4r22+6TOJ6klJaJY4oNO2M2Sr+wG08hCdHShmzLfgt5Dn+pxYsl9M+EsEvRnePzxYV8yPcFcAGwirklRA2HIAaU95IdSciGpwMyYxQIV9S0ulxZht4091utyE0IrEVu6MCJL8rVNAWVNgluwsoyvtJRUhL8UAoZRDuszXogXxvcZpiQ+YJgo/GNVfHSUTm+OTs4UldFRqqhopZiZHG3W66KieRUbRa+CL9bOD6yfX6tIyBzsGfmxiTl6Xtc7OSndOr37dGt6UnJv3fmjQtzHJYUjUrWwye8jS7J8fiaLY+Qiw4hyhtMrWEHgbHKL3CCoOC7WYY+NtTtiOU4lGHCkjRMEVhHYNv/pp+fnz35qxnjLZZ9PZeiUm5dasCrVWVDgTF1VkJqX22lw8VXb4obnKN9sUSgwLRuAJdZygjCiZshqiRQ6YUJVoY4IBXhK2/pzK2O2uYlG1Evn2kl3DyknsKhuJnNOxObNJrm6p2r3TjDnDl27PKjqVXVw0gvfaVXFxX1LZzjjboHeberwAQNiFr5Ol5/5By5/LD2BARVDP7Om8FxKTNBm6DNbjCsjif9TsXTVcydufFTxqhm95zDodWs6py87dIj3Q/mhjrp3+O9Jh2sGCFFfNsx8v++0QV9WxbnCGvK4jBmY1MVlJZj8GVazNX7KbBE/1pKypzDOcjHYunpmYlIi/qIjCvhDt6vdQ/6VeD/fjGXcYsIJbQY1k5TJSNgdJmJko+YEK4c7opeu4aFLJllJZxVpcdK21iDEMXj/wtM/o5afTy/s8URlX0s6xydaupXmddJAtsuEqsMfHa6a0IWFmk55pd0siTyXbulb+UQP5E+x+KQlVbj2+nug39O/lPraKizLT0zMLyvsWpzjUOGscIbKuBizlotKdFgNBmtyoopTx5jjlDgnnJ/KkVPMFiPizMwvzUuQzdO/P9wleeVi2nzmxFHrKRuBD5SwNF023P5xUPIlI5pNEPM8ApArE6IwRyCzCrYQViVjLmCJIh3ArrySY4Or9dn64CpeC2eZHHyft2V2k9Euq83VM65J6LmZcoeYEbXkrzJHup1/Ao2YhJoLlswclJw8aOaSgmbEAJmC5YK79HpmJKOPM8LYYJnBYjHAr8odcM/quis6A8M/gEqYvQZLnBF1qVt9+UZaP19ysq9f2g2Ct/OfW4DzyzRYnnETrRAQdO5wr25T2LXh/uoyIUM933L6ZDJnhDfOjy5ebG4HqJGC639aoopaebW6EabuDQCpx5E5ILbpCjqA+1LEpZI5EafdC/V1y6/VasRa9I1emtUhd5F3/An9RO0aiIdKAMNG42GNJzTpBRkQZMkp+MUAfjczmfzygMhpNh7o1bDBkkIfhsYMH6oyobqWbej8h7N0sXBqyyqomAy3oVa1Ptj/mwt1o0bVXZAOPH5JLEdIxkwyNHoy+mVVC1ofq5v1Iczc1gLLTKqhw+E2vfpmc9s95BC2U+EI3c7HX4CY0uiNuHqN96leTwqg1miYGhFzHiuhKJTK4PJJk3RatmD1PlzhEnIELY0UvIgu7lu9vVAm6nob5elN3zalyxPydaKsMPincN2jm9xfH0L/3ElaYFnErTS4LAb2vbITGh8q3aeNM0ytqppqiNPua73c3nRSX6F8qAd4+I52yIcE1O5Xyke6D2kik9lJxn64UBxpnaRw6zx5t/Kt+6lKpYVJJ+defhTcWo6baUV7sUJtRLvT8lv1x+9eQNzBdHWnYJpZ3aMP0qtbSyOKFrLhIWWbRlBMfkvZSNt5XUIbLLKxg0Y+zCi8bWjKOUkdK4H/9UrAjfxkdpnCouyihIopM2kKJlBJJLF66rBQwsi8elhb/xtriXSD4/WemUooT5fHKSvKl9OeH36vaWNDCY/lPvnkHbWIxU7SRwSlTA9yQQHoD0ro7I2Jkd2NrNjuQWBID8Ec1QQwA3XJtGwWFVZSKFOGOqKv08EsHCar2ojIIkOqJT+tj6AmCNxGinTQdfrM7t1nTkNXYA0Wa5oqJm3aNKmCcl3m5lPz5j3F+A6QUhygCey/6tD3e7UdyNSdxOoMzBCNFRVGEX0YPLEUTl+6FK1F/8nb/kXzzjypyrGwzmmKizUogMVKWk95O5u/2J6HZbpbN9F1gfS3PmAQGAum363PYdGa0jVXJuuV2KqzzUazY+c0hwYUzKZCjLkAOg0mM6414CUzYgBXF1mVSDuxFco69LQBhaZE9OP+82hbzzln1wySK57+YsXcT0fQ/hN53YP2N2ppJALci5fwL+D/bDsL1Sc9V1bgimSbcAXiCPQjjuBKI/vauO/9b6CAJeHSYdmkbZ/NW/HNOo00Bn2RVz08TlGB41CDISW2ZSfd7QqYE6znYaGzshbdDAhYQpJi0BEcg+vwX6G5j4dxHY4Gk+9Th7jP/L8IE3WFIlUl7XtUDPSmaEnva+tzWtzl/LdVYRL65fXP35qz8o4xW3fzD+ZYGP1W81u1e4+HRiXwE9gCXJw5ZZs2lc05wOZJnY+edhynuO5eQ4E4+6KBmjsHq+4AtL94EGoS7IvG09H4j1A3hDNJ98vbCZt25gXauh7y7cwDkfz0wQhvhhKtEtoMKYU7uKq33aAyhG3nZiKtb2RNofr4arNCkYmJ0ebH7spnHwsnf0X4rV6d1IFxEp+yYXZ7bbPSgi9VbJl4V7b7WCh581f0sa0dOTfhV+h/Kf/Noz4oTcBoYDg6JazP8XraG1+QQKeksoXL395dmBCBZvwXoWsv+rix+urKKEJx6MRpw2jpJU7g78cTUsFGSwk322kvuygGHbiyE31TK2pqry2vg/q9Wqk5t4+W7jkuiseljEZvl0rj78Cfbv1CbYq4UJuZKIK79NYRZJQATSTj9tInExHN7PaEZ1BtYbSsDlKR8J0ookuKOEWGUnkAXaLPXaqasevqgtfQh7uU8j0w9sUd0PaGdqlE91IOKJUZ+PLWwR0slJiXcdnRJSntgEQo5328ceQbMPf1F6FhG8c9j/6zTYo/ID0t8HJHI6Z2WYnomCQ5tA24DpCvCiw2t4kLROSkb4QZYqi9g0JEbVMhM7iZ2pVPJBxtjtQxgicj67Qd2y05wqenzu0lNq5uLzUdJCDGbl0bGN1uR1aWA81/3/pV514LCitqth07FrSRON6f5WhpdGQxQ75em5sLP1A01O7+OvgyThjmyAKhZ/FkzA0gM15E/udM1LmpPcWllmkgNVzUe9vV65LNN0eVoxRAXZqlzWT7L9vz3qR6qG1MKZm7Z1Kv5QnK5CirKTXLqVZo0kYKSZMH5fd6dKTPO7awa1z0p68eQ/+OTYi1mhiNuzjNxO6efviPk7OrUUPpm41LHvHlutakPZZW0i+LV25JHP0VHGktmjykdnBBj5aCwiFZwybPmdL55SMo+H56SZc0RfxIVlMy7fdh/fMCXHfL8XdDAUFCARLiSRh5AX8FS37PTNT6ENICUfwiHMFGYucKXpM+DG1GMPREamzEnrK8xDM67YzOedUTVg14CLJ9Y+JlMYKokcuzevP2XrnjVEpN+eLruyZO3HUd4UNl8Y/1mERD84nKyhPo+sZ3GtG4mumVJ5isRxW80pbm8hRk1JZPGy4f1dPERhsNNYKxn1KQ9/N5ugioOJQJPiw+uf36I5P5x0km6Ay6fqJy7HK47s8fbsQ5Uz8yIUwzCYdIpLpgF66FzgB4bR6bDm9tS5Iiwvo2/BLq/4ZuxKQXkE2WlDsoN3dQS0zEifTbcBMQs2my+SnYzQaawCWFQ4x0ZTCJKAYZ0L5vm1+kmAhpZIUMSErREqxCGBJHI6xGwgTdFrYWoU7UjWGlEe8Of40QC1TigW8cOnqVeAFgfLA0WhSjUYMY3RQtogZyAkvpSTBpQDYEvSYRFZBgTMrpU5YvGoqf//PzxQZx2dDPswcw/pAjAbT1zrulfINN2QO+z3p6vqdszsRxPTvp8vGfrnRAdtgGWviFls8NhkWUj/REDZTQLiR8QU92IR1iBMGV6m7InvRXnph6JcLIgpqSaDGpINVeztdvKhQ1imi14uZNhToaB0ngtpig8XWnc4jR3KHAm+DDmwxifEK8xdlW3uDn986kPeZ1Z47HOYRtL/yCBTpZXKYtxxlhByuhXQBIxR7JJD/UhOGuZ2uznIGA8OhboAUTW6rsYXzrP1q//iN+2NWtQR8+JbzXBwkppvhpyERS1/u2XsVhf9vaCzrnaaJWLazbaBNsRpuC9HWXzeNmqYmL6JCBpib0vRf2Q2WoDv+XwX5e9H1TEwSwJ1wAeyIw/RMZQL4mf1OgiSUH2BTExWr1wXb/3SDEDxyEPnOEPmP5hDZVoeS+O9mtD3swxeXmiAzf+toFrdbU2mzSai+81oplrB+o0yicM6b1B6sD/qo3+ROaTp00J/g3q1h/9cGWJuojCp4lsFEd/VpJz6Zj+17PZyKeD371Xb6QfKP6gs0sklyn+shqk7u+luRSFh4lrxWMPAEhftKK6VA1mYUmGKtunQM6iF8wEqaGXmRmyia6RZvREbKmEEDwyeUy9N5P6IR8RfBab2N6urE303BF9jlT31dMTzOcOneOrW9dzc0MTDh3zqVnZ+nTzwVOsp5z6frAc3r8pP8DoclSRQAAAHjalZS/bhNBEMa/PTtxjFEKEpJUaAuUAok7x0maUxorUdI6KVIiNr49+2T7LtpdO/Ij0PEKQENDR0tHhXgIel6Bgrn1YBtwJHDk7G//zMw3364MYE/sQ2D2ifCSWaCB98wBavjMXMEufjBXsSVOmNfwSEyY19EQb5hruAwumTfwMPjEXMeD4BtzA48ru8ybeFIZUBVRrdPsha9YssAOXjMHdOojcwUhvjJXsS+2mdfwVHSY17EjXjHX8FZ8YN7AXvCOuY7t4AtzA8+C78ybOKk8xykK3GIKgww99OEgcQaFCTTRBVGOhPYlWmjiAMekSqKNIf3JpSjrZ5pGTWMZndBJnBa3U5P1+k6eqYmWFypPprLVPDgOZXs4lH7LSqOtNhOdUMA56ckpXxt3PluBEY04L3LXvtO2GNHkilZ6GJMCRbVwpXvjoSKY9WERk5bVeeJ5Hy06PjU2lkuZ41JZ6z4N8s+6S5FyruHa92/JlzKHxBG5cEjf5pKDuNbGZkUuj8LDsOnt+LfGO1RaU3Hr5ZR2p76cpLjC/+/7nVWXWsZ0iX4JS2k0SzEp1y9XDNVIaHXkGx3QmqJV5/PdkAGLLDmN5azrNdP9dYZaWU03mmojXSFdX8vFI7C668rG08L4nZS6k86oRI+UGUjlnMluxv5IXrisqy0/CeOV/eWNcXJuzqpXi8Wrg/fBkS8x/RhE837VbzlD3xn6zt3GUVTKU7P8YVb8T4aIbmrmSu6dj+7JGQ2pydzqCD8Bydvk6AAAAHjafVcFlCPHEVX9EcPe7ZntgOMwOFnBSKvw2ecLM6MyGrU0cxrNzA0sXBgcMNtxmJmZmZkdZmZwmKmqZ7S39/Je7u1VV/f0766u/lXVKqDwf//hTBZUQMEgFC4qnF84r3Bh4ZLCpWRQkUpUpgpVqUZ1alCTWrRCewoXFC4rXEx7aZX20XF0PJ1AJ9JJdDKdQqfSaXQVuipdja5Op9M16Ay6Jl2Lrk3XoevS9ej6dAO6Id2IzqQb001ojdrUoS71yKQ+DWidhnRTuhndnG5Bt6Rb0a1pP51FZ9MBOocO0m3otnQ7uj3dge5Id6I7013ornQ3ujvdg+5J96J7033ovnQ/uj89gB5ID6IH04geQhaNyaYJKZrSjBxy6RDNyaMF+RRQSIcLK4UrCy2KKKaEUtqgTdqibTpCD6WH0cPpEfRIehQ9mh5Dj6XH0bn0eHoCPZGeROfR+XQBXUgX0cV0CV1Kl9GT6XJ6Cj2VnkZPp2fQM+lZ9Gx6Dj2XnkfPpxfQC+lF9GJ6Cb2UXkYvp1fQK+lV9Gp6Db2WXkevpzfQG+lN9GZ6C72V3kZvp3fQO+ld9G56D72X3kfvpw/QB+lD9GH6CH2UPkYfp0/QJ+lT9Gn6DH2WPkefpy/QFfRF+hJ9mb5CX6Wv0dfpG/RN+hZ9m75D36Xv0ffpB/RD+hH9mH5CP6Wf0c/pF/RL+hX9mn5DV9Jv6Xf0e/oD/ZH+RH+mv9Bf6W/0d/oH/ZP+Rf+m/6AAAmCgiBLKqKCKGupooIkWVrAHe7GKfTgOx+MEnIiTCmfgZJyCU3EaroKr4mq4Ok7HNXAGrolr4dq4Dq6L6+H6uAFuiBvhTNwYN8Ea2uigix5M9DHAOoa4KW6Gm+MWuCVuhVtjP87C2TiAc3AQt8FtcTvcHnfAHXEn3Bl3wV1xN9wd98A9cS/cG/fBfXE/3B8PwAPxIDwYIzwEFsaFK2BjAoUpZnDg4hDm8LCAjwAhDiNCjAQpNrCJLWzjCB6Kh+HheAQeiUfh0XgMHovH4Vw8Hk/AE/EknIfzcQEuxEW4GJfgUlyGJ+NyPAVPxdPwdDwDz8Sz8Gw8B8/F8/B8vAAvxIvwYrwEL8XL8HK8Aq/Eq/BqvAavxevwerwBb8Sb8Ga8BW/F2/B2vAPvxLvwbrwH78X78H58AB/Eh/BhfAQfxcfwcXwCn8Sn8Gl8Bp/F5/B5fAFX4Iv4Er6Mr+Cr+Bq+jm/gm/gWvo3v4Lv4Hr6PH+CH+BF+jJ/gp/gZfo5f4Jf4FX6N3+BK/Ba/w+/xB/wRf8Kf8Rf8FX/D3/EP/BP/wr/xH4NTgwHDMIpGySgbFaNq1Iy60TCaRstYMfYYe41VY59xnHG8cYJxonGScbJxinGqcVrh8krqu2tr+9ek7aytLdt23nbytpu3vbw187aft4O8Xc/bYd7uz9rOwaw1s9Y8eHZp5llxXFqksWuXY2VFtlNV/obyglCVHO4nxTixorqIkVqEyXYxjVVUnLreopo4I8+KZgqJUxHdjRME83KkFsGGqhwJgsXI9au6DdLECKbTcuzOfMsz7GBWSiIrdopOsFBVXk2NLC8pJu5CFaPAmjQnwabvsSLD1WWnnIbSlFx/HGw1Qs/aHtluZHuK9wyVlVQiNY1U7FTFFL2gF9jz4tSzZnU+zCR0Al/F9Y3ASxdqxPY0clU2qOV6GpYPR3YwUZWxpVsjsWZF/h8Xx0Ewr4pYWNG8FEaun5Rta6EiqzgN/IS/e5Oym1ieazcStZWMHOXOnKSu9U13kjh1/jbzR56aJs1MtZWfqKiRdSKZ3sr0Q2mcuNPtopyl4foTnpfhcl3PXZlathKvjTbciQoqoWsnaaTKofJt16svrHAktqqobE1kQfYw26kmblKKHStSJdtR7CG5sFacqHA0tuz5phVNWlOLXbjsVZdKUZxeCi0mARMjCCvTIJLxpp6+7OiV8k5JHVJ20uR9NqIgO3lr2dFHqIVeGo+EGPWF6+dqIyOR1ivBXLetw6lilzBOejXXnwYZLLYjpfzYCZJWDstYUWNgptXHlr9UrSgKNrUdjUzVVlQzPQ3z75oR2kXCIzYndo+o0TT1vGauxwvL8/aqLduzFtaOWcWZO2XaKWvKMRKpqtpmovFt1ESxvSBWTfaK7/ozPb3E/vRV1bY85U+sqBxZ/iRYVOxgseA7Li+sma+S+tJfabjjR7GP6Z5sKpW0+OhhKEvaHLDNKbNQRdlmjbwjJuzJDd9QUeLyjqt53wki9wjT1/JqzPiR7cgiyaabMC8zxwvJhPa618wYP+LNo8CYq+0iR3NczU2OW4mTLsYx2yqO25P3xFzp13QicSxv2tDZJcspFVmXU0TLc/05kzNzZSVMY4eP1eLoURGnjZF81inE9cu8eehsN2Yu7zDOeJBlB9mm5DEP2LkS7w1N8WyjlWXwZt26npBtlh+4ujxrOVu5nPqSQxpMMQ4acfDEiOLYcCYcFMwGdp5fHCvPa9ji1ik7NlF1h68xZ7dWhW0VraVhNiIOWc0YOTrKyH3HjOgF9hwzlIbHgmQZzuHBWJU3I455p5RY8Twuc0blw9TGkaumthWrujA3i5PSLArSsCi+LDFH0kl5rCzOEIadJnyVIXvFCjV/3LAYWxuqLv4ZjZmoc2ZcEDGfkHoIPM4YkTtXicMLzpxaynkp4mUV2zD2VInJ69qc5lN7XuNrZHs4fFd2NO32vbMgmPFpdnJAY9dAie9QbdfZ5yrRJ61mKgdppuggzlTtK44bTuF+XIyDiKnGIosTrXHwLCubLipLrhXZ7oAJM2P+T7gkjQO+40ZOZ5nZXFJbVxTO8QnzNVGcW6vM7Yjv3uKMyDmv7okRI6bFuMp5ge95pla0i0fLCtbMuhlTK1JKR4tJg7GJE8TsfFWNUzeRG6sKqWTHss2FSimuMAFnZamUupzIEcap6/EJZlUGh1J3ataCd7d8W5UXajJ3k8ZUTOJdDik2XXEdcLI0NV2bqtVJkI6FSr54XPPvmJGMf8cMMf+O6cu56kfxjV3A6hJRPzq1MlHxnMtG2bNCaTRRkuYiGMu5dDQ2c35rvtUPp0GSL52p2T3zaX2fD5PNLXH197breSpgx+zdnQJ1GtqVBqVfV1uhRGF2u3yBYTavFC/YkNKUQ8s3FsqpzDjXhdakymlO86IqbwmZuaIVnVqYzZMq+5irl+UV5cVQ0wbxNG/PTr7LExAnk6xY6Pgt2pzFagKRcjmXZMOsLI46g2FjV2VpxClHJIevGzKt03Gm8bT1bjNMjxwR37nKVlxAZUFx48pRdaQfXo6rvMnKstBk1qxKiRoxm5hDqRs77NGIk52SwrNlTzhB5dUmXj5a9h0zkieo3UOSoHb3dYJykoVnFu047paZm5wy61lWzUnMmYmr43HMdzeM3XhXQVrdGVsWreKou9at6aefrF/mQbZ35ejLQZfrLOXrwaqnOOiFhpmiGZt9188IndZ1SIy67U49K/m6InDYc1hLZcsIcpQpTF2ZPTBUGhmzcWik8cRw/cg4FG4bUTo25tGmMU5seSar2k7M7tV5aCzECB1rzBE56naG+3ZGE06n4zRR8Yn/OyTHai2HdQ5ePaanc9Oo2+2JMJvbXE3TcX6QvFPc4muubS2fHjtzxJmVCZOFH9Wc0vmlt0xe/Mbi/iyyFuUpv2nnkWFNOHW0B+2VsZuMU3F9fg2cCb2okTV6aI8X8EZHq1RrVz8Nd38VXu3d1c9CfJOfucFmXOEwjQJ3UuLASLfYTHcstSWeb4dc1II0ig+nfGP8HGCqBOUpp2VPFUVIAU/c0IhTudp+vyI/btwNZYzTGTbmpU3ljgP+4eDzH08YdFb02UfLw8tY74TMpGXN9bKaI5/6K5Mg2fVBxtabG/wU51eptolH1tdaWWXTA6NAhjoiuiLkrtZNEX0RAxHrIvTPtoPt/Wvsa6vNI0MBDbvSFdBQQEMBDQU0FNBwWBz11jRiLFpHRFdEL1vtrLZ0+iIGItZFCKi9JkK+tgXUFlC7J8IUIYi2INqCaOe2nb2Wt4LrCK4juI7gOoLrCK4juI7gOrJTV3bqCqIriK4gurl5B/IFD7TzVs8QaDff8oCZt/28lcV7skZPdu3Jrj3Ztac/CLSXQ8+RjU3Z2JRlTQGZAjIFZArIFJApIFNM7QuiL4i+IPqC6OemHtTfBNQfsL+n+puABvJhIKCBgAbyYSDbDGSbQV8m26LJNgNBrAtiXRDCi57woie86AkvesKLnvCiJ7zorQtiKIihIIQUvaEghr3itKOvkUnBmv4gCCGFyaRg0RbREdEV0RNhiuiLGIhYFzEsbShOm6wKJUxZyxRKmEIJUyhhCiVMoYQplDDbsklHNukIQshgChlMIYMpZDCFDKaQwRQymEIGU8hgChlMIYMpZDAlfZldQXQF0RWEcMDsDv8LkjDfogAAAAH//wACAAEAAAAMAAAAFgAAAAIAAQABAiwAAQAEAAAAAgAAAAAAAAABAAAAANWkJwgAAAAAy1HfMAAAAADQ5uXt) format('woff');
 font-weight:400;
 font-style:normal
}

.fa {
    display: inline-block;
    font: normal normal normal 14px/1 FontAwesome;
    font-size: inherit;
    text-rendering: auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
    font-size: 1.33333333em;
    line-height: 0.75em;
    vertical-align: -15%;
}
.fa-2x {
    font-size: 2em;
}
.fa-3x {
    font-size: 3em;
}
.fa-4x {
    font-size: 4em;
}
.fa-5x {
    font-size: 5em;
}
.fa-fw {
    width: 1.28571429em;
    text-align: center;
}
.fa-ul {
    padding-left: 0;
    margin-left: 2.14285714em;
    list-style-type: none;
}
.fa-ul > li {
    position: relative;
}
.fa-li {
    position: absolute;
    left: -2.14285714em;
    width: 2.14285714em;
    top: 0.14285714em;
    text-align: center;
}
.fa-li.fa-lg {
    left: -1.85714286em;
}
.fa-border {
    padding: .2em .25em .15em;
    border: solid 0.08em #eeeeee;
    border-radius: .1em;
}
.fa-pull-left {
    float: left;
}
.fa-pull-right {
    float: right;
}
.fa.fa-pull-left {
    margin-right: .3em;
}
.fa.fa-pull-right {
    margin-left: .3em;
}
/* Deprecated as of 4.4.0 */
.pull-right {
    float: right;
}
.pull-left {
    float: left;
}
.fa.pull-left {
    margin-right: .3em;
}
.fa.pull-right {
    margin-left: .3em;
}
.fa-spin {
    -webkit-animation: fa-spin 2s infinite linear;
    animation: fa-spin 2s infinite linear;
}
.fa-pulse {
    -webkit-animation: fa-spin 1s infinite steps(8);
    animation: fa-spin 1s infinite steps(8);
}
@-webkit-keyframes fa-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}
@keyframes fa-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}
.fa-rotate-90 {
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
    -webkit-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
    transform: rotate(90deg);
}
.fa-rotate-180 {
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
    -webkit-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
    transform: rotate(180deg);
}
.fa-rotate-270 {
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
    -webkit-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
    transform: rotate(270deg);
}
.fa-flip-horizontal {
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
    -webkit-transform: scale(-1, 1);
    -ms-transform: scale(-1, 1);
    transform: scale(-1, 1);
}
.fa-flip-vertical {
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
    -webkit-transform: scale(1, -1);
    -ms-transform: scale(1, -1);
    transform: scale(1, -1);
}
:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical {
    filter: none;
}
.fa-stack {
    position: relative;
    display: inline-block;
    width: 2em;
    height: 2em;
    line-height: 2em;
    vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
    position: absolute;
    left: 0;
    width: 100%;
    text-align: center;
}
.fa-stack-1x {
    line-height: inherit;
}
.fa-stack-2x {
    font-size: 2em;
}
.fa-inverse {
    color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
    content: "\f000";
}
.fa-music:before {
    content: "\f001";
}
.fa-search:before {
    content: "\f002";
}
.fa-envelope-o:before {
    content: "\f003";
}
.fa-heart:before {
    content: "\f004";
}
.fa-star:before {
    content: "\f005";
}
.fa-star-o:before {
    content: "\f006";
}
.fa-user:before {
    content: "\f007";
}
.fa-film:before {
    content: "\f008";
}
.fa-th-large:before {
    content: "\f009";
}
.fa-th:before {
    content: "\f00a";
}
.fa-th-list:before {
    content: "\f00b";
}
.fa-check:before {
    content: "\f00c";
}
.fa-remove:before,
.fa-close:before,
.fa-times:before {
    content: "\f00d";
}
.fa-search-plus:before {
    content: "\f00e";
}
.fa-search-minus:before {
    content: "\f010";
}
.fa-power-off:before {
    content: "\f011";
}
.fa-signal:before {
    content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
    content: "\f013";
}
.fa-trash-o:before {
    content: "\f014";
}
.fa-home:before {
    content: "\f015";
}
.fa-file-o:before {
    content: "\f016";
}
.fa-clock-o:before {
    content: "\f017";
}
.fa-road:before {
    content: "\f018";
}
.fa-download:before {
    content: "\f019" !important;
}
.fa-arrow-circle-o-down:before {
    content: "\f01a";
}
.fa-arrow-circle-o-up:before {
    content: "\f01b";
}
.fa-inbox:before {
    content: "\f01c";
}
.fa-play-circle-o:before {
    content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
    content: "\f01e";
}
.fa-refresh:before {
    content: "\f021";
}
.fa-list-alt:before {
    content: "\f022";
}
.fa-lock:before {
    content: "\f023";
}
.fa-flag:before {
    content: "\f024";
}
.fa-headphones:before {
    content: "\f025";
}
.fa-volume-off:before {
    content: "\f026";
}
.fa-volume-down:before {
    content: "\f027";
}
.fa-volume-up:before {
    content: "\f028";
}
.fa-qrcode:before {
    content: "\f029";
}
.fa-barcode:before {
    content: "\f02a";
}
.fa-tag:before {
    content: "\f02b";
}
.fa-tags:before {
    content: "\f02c";
}
.fa-book:before {
    content: "\f02d";
}
.fa-bookmark:before {
    content: "\f02e";
}
.fa-print:before {
    content: "\f02f";
}
.fa-camera:before {
    content: "\f030";
}
.fa-font:before {
    content: "\f031";
}
.fa-bold:before {
    content: "\f032";
}
.fa-italic:before {
    content: "\f033";
}
.fa-text-height:before {
    content: "\f034";
}
.fa-text-width:before {
    content: "\f035";
}
.fa-align-left:before {
    content: "\f036";
}
.fa-align-center:before {
    content: "\f037";
}
.fa-align-right:before {
    content: "\f038";
}
.fa-align-justify:before {
    content: "\f039";
}
.fa-list:before {
    content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
    content: "\f03b";
}
.fa-indent:before {
    content: "\f03c";
}
.fa-video-camera:before {
    content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
    content: "\f03e";
}
.fa-pencil:before {
    content: "\f040";
}
.fa-map-marker:before {
    content: "\f041";
}
.fa-adjust:before {
    content: "\f042";
}
.fa-tint:before {
    content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
    content: "\f044";
}
.fa-share-square-o:before {
    content: "\f045";
}
.fa-check-square-o:before {
    content: "\f046";
}
.fa-arrows:before {
    content: "\f047";
}
.fa-step-backward:before {
    content: "\f048";
}
.fa-fast-backward:before {
    content: "\f049";
}
.fa-backward:before {
    content: "\f04a";
}
.fa-play:before {
    content: "\f04b";
}
.fa-pause:before {
    content: "\f04c";
}
.fa-stop:before {
    content: "\f04d";
}
.fa-forward:before {
    content: "\f04e";
}
.fa-fast-forward:before {
    content: "\f050";
}
.fa-step-forward:before {
    content: "\f051";
}
.fa-eject:before {
    content: "\f052";
}
.fa-chevron-left:before {
    content: "\f053";
}
.fa-chevron-right:before {
    content: "\f054";
}
.fa-plus-circle:before {
    content: "\f055";
}
.fa-minus-circle:before {
    content: "\f056";
}
.fa-times-circle:before {
    content: "\f057";
}
.fa-check-circle:before {
    content: "\f058";
}
.fa-question-circle:before {
    content: "\f059";
}
.fa-info-circle:before {
    content: "\f05a";
}
.fa-crosshairs:before {
    content: "\f05b";
}
.fa-times-circle-o:before {
    content: "\f05c";
}
.fa-check-circle-o:before {
    content: "\f05d";
}
.fa-ban:before {
    content: "\f05e";
}
.fa-arrow-left:before {
    content: "\f060";
}
.fa-arrow-right:before {
    content: "\f061";
}
.fa-arrow-up:before {
    content: "\f062";
}
.fa-arrow-down:before {
    content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
    content: "\f064";
}
.fa-expand:before {
    content: "\f065";
}
.fa-compress:before {
    content: "\f066";
}
.fa-plus:before {
    content: "\f067";
}
.fa-minus:before {
    content: "\f068";
}
.fa-asterisk:before {
    content: "\f069";
}
.fa-exclamation-circle:before {
    content: "\f06a";
}
.fa-gift:before {
    content: "\f06b";
}
.fa-leaf:before {
    content: "\f06c";
}
.fa-fire:before {
    content: "\f06d";
}
.fa-eye:before {
    content: "\f06e";
}
.fa-eye-slash:before {
    content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
    content: "\f071";
}
.fa-plane:before {
    content: "\f072";
}
.fa-calendar:before {
    content: "\f073";
}
.fa-random:before {
    content: "\f074";
}
.fa-comment:before {
    content: "\f075";
}
.fa-magnet:before {
    content: "\f076";
}
.fa-chevron-up:before {
    content: "\f077";
}
.fa-chevron-down:before {
    content: "\f078";
}
.fa-retweet:before {
    content: "\f079";
}
.fa-shopping-cart:before {
    content: "\f07a";
}
.fa-folder:before {
    content: "\f07b";
}
.fa-folder-open:before {
    content: "\f07c";
}
.fa-arrows-v:before {
    content: "\f07d";
}
.fa-arrows-h:before {
    content: "\f07e";
}
.fa-bar-chart-o:before,
.fa-bar-chart:before {
    content: "\f080";
}
.fa-twitter-square:before {
    content: "\f081";
}
.fa-facebook-square:before {
    content: "\f082";
}
.fa-camera-retro:before {
    content: "\f083";
}
.fa-key:before {
    content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
    content: "\f085";
}
.fa-comments:before {
    content: "\f086";
}
.fa-thumbs-o-up:before {
    content: "\f087";
}
.fa-thumbs-o-down:before {
    content: "\f088";
}
.fa-star-half:before {
    content: "\f089";
}
.fa-heart-o:before {
    content: "\f08a";
}
.fa-sign-out:before {
    content: "\f08b";
}
.fa-linkedin-square:before {
    content: "\f08c";
}
.fa-thumb-tack:before {
    content: "\f08d";
}
.fa-external-link:before {
    content: "\f08e";
}
.fa-sign-in:before {
    content: "\f090";
}
.fa-trophy:before {
    content: "\f091";
}
.fa-github-square:before {
    content: "\f092";
}
.fa-upload:before {
    content: "\f093";
}
.fa-lemon-o:before {
    content: "\f094";
}
.fa-phone:before {
    content: "\f095";
}
.fa-square-o:before {
    content: "\f096";
}
.fa-bookmark-o:before {
    content: "\f097";
}
.fa-phone-square:before {
    content: "\f098";
}
.fa-twitter:before {
    content: "\f099";
}
.fa-facebook-f:before,
.fa-facebook:before {
    content: "\f09a";
}
.fa-github:before {
    content: "\f09b";
}
.fa-unlock:before {
    content: "\f09c";
}
.fa-credit-card:before {
    content: "\f09d";
}
.fa-feed:before,
.fa-rss:before {
    content: "\f09e";
}
.fa-hdd-o:before {
    content: "\f0a0";
}
.fa-bullhorn:before {
    content: "\f0a1";
}
.fa-bell:before {
    content: "\f0f3";
}
.fa-certificate:before {
    content: "\f0a3";
}
.fa-hand-o-right:before {
    content: "\f0a4";
}
.fa-hand-o-left:before {
    content: "\f0a5";
}
.fa-hand-o-up:before {
    content: "\f0a6";
}
.fa-hand-o-down:before {
    content: "\f0a7";
}
.fa-arrow-circle-left:before {
    content: "\f0a8";
}
.fa-arrow-circle-right:before {
    content: "\f0a9";
}
.fa-arrow-circle-up:before {
    content: "\f0aa";
}
.fa-arrow-circle-down:before {
    content: "\f0ab";
}
.fa-globe:before {
    content: "\f0ac";
}
.fa-wrench:before {
    content: "\f0ad";
}
.fa-tasks:before {
    content: "\f0ae";
}
.fa-filter:before {
    content: "\f0b0";
}
.fa-briefcase:before {
    content: "\f0b1";
}
.fa-arrows-alt:before {
    content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
    content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
    content: "\f0c1";
}
.fa-cloud:before {
    content: "\f0c2";
}
.fa-flask:before {
    content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
    content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
    content: "\f0c5";
}
.fa-paperclip:before {
    content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
    content: "\f0c7";
}
.fa-square:before {
    content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
    content: "\f0c9";
}
.fa-list-ul:before {
    content: "\f0ca";
}
.fa-list-ol:before {
    content: "\f0cb";
}
.fa-strikethrough:before {
    content: "\f0cc";
}
.fa-underline:before {
    content: "\f0cd";
}
.fa-table:before {
    content: "\f0ce";
}
.fa-magic:before {
    content: "\f0d0";
}
.fa-truck:before {
    content: "\f0d1";
}
.fa-pinterest:before {
    content: "\f0d2";
}
.fa-pinterest-square:before {
    content: "\f0d3";
}
.fa-google-plus-square:before {
    content: "\f0d4";
}
.fa-google-plus:before {
    content: "\f0d5";
}
.fa-money:before {
    content: "\f0d6";
}
.fa-caret-down:before {
    content: "\f0d7";
}
.fa-caret-up:before {
    content: "\f0d8";
}
.fa-caret-left:before {
    content: "\f0d9";
}
.fa-caret-right:before {
    content: "\f0da";
}
.fa-columns:before {
    content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
    content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
    content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
    content: "\f0de";
}
.fa-envelope:before {
    content: "\f0e0";
}
.fa-linkedin:before {
    content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
    content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
    content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
    content: "\f0e4";
}
.fa-comment-o:before {
    content: "\f0e5";
}
.fa-comments-o:before {
    content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
    content: "\f0e7";
}
.fa-sitemap:before {
    content: "\f0e8";
}
.fa-umbrella:before {
    content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
    content: "\f0ea";
}
.fa-lightbulb-o:before {
    content: "\f0eb";
}
.fa-exchange:before {
    content: "\f0ec";
}
.fa-cloud-download:before {
    content: "\f0ed";
}
.fa-cloud-upload:before {
    content: "\f0ee";
}
.fa-user-md:before {
    content: "\f0f0";
}
.fa-stethoscope:before {
    content: "\f0f1";
}
.fa-suitcase:before {
    content: "\f0f2";
}
.fa-bell-o:before {
    content: "\f0a2";
}
.fa-coffee:before {
    content: "\f0f4";
}
.fa-cutlery:before {
    content: "\f0f5";
}
.fa-file-text-o:before {
    content: "\f0f6";
}
.fa-building-o:before {
    content: "\f0f7";
}
.fa-hospital-o:before {
    content: "\f0f8";
}
.fa-ambulance:before {
    content: "\f0f9";
}
.fa-medkit:before {
    content: "\f0fa";
}
.fa-fighter-jet:before {
    content: "\f0fb";
}
.fa-beer:before {
    content: "\f0fc";
}
.fa-h-square:before {
    content: "\f0fd";
}
.fa-plus-square:before {
    content: "\f0fe";
}
.fa-angle-double-left:before {
    content: "\f100";
}
.fa-angle-double-right:before {
    content: "\f101";
}
.fa-angle-double-up:before {
    content: "\f102";
}
.fa-angle-double-down:before {
    content: "\f103";
}
.fa-angle-left:before {
    content: "\f104";
}
.fa-angle-right:before {
    content: "\f105";
}
.fa-angle-up:before {
    content: "\f106";
}
.fa-angle-down:before {
    content: "\f107";
}
.fa-desktop:before {
    content: "\f108";
}
.fa-laptop:before {
    content: "\f109";
}
.fa-tablet:before {
    content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
    content: "\f10b";
}
.fa-circle-o:before {
    content: "\f10c";
}
.fa-quote-left:before {
    content: "\f10d";
}
.fa-quote-right:before {
    content: "\f10e";
}
.fa-spinner:before {
    content: "\f110";
}
.fa-circle:before {
    content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
    content: "\f112";
}
.fa-github-alt:before {
    content: "\f113";
}
.fa-folder-o:before {
    content: "\f114";
}
.fa-folder-open-o:before {
    content: "\f115";
}
.fa-smile-o:before {
    content: "\f118";
}
.fa-frown-o:before {
    content: "\f119";
}
.fa-meh-o:before {
    content: "\f11a";
}
.fa-gamepad:before {
    content: "\f11b";
}
.fa-keyboard-o:before {
    content: "\f11c";
}
.fa-flag-o:before {
    content: "\f11d";
}
.fa-flag-checkered:before {
    content: "\f11e";
}
.fa-terminal:before {
    content: "\f120";
}
.fa-code:before {
    content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
    content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
    content: "\f123";
}
.fa-location-arrow:before {
    content: "\f124";
}
.fa-crop:before {
    content: "\f125";
}
.fa-code-fork:before {
    content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
    content: "\f127";
}
.fa-question:before {
    content: "\f128";
}
.fa-info:before {
    content: "\f129";
}
.fa-exclamation:before {
    content: "\f12a";
}
.fa-superscript:before {
    content: "\f12b";
}
.fa-subscript:before {
    content: "\f12c";
}
.fa-eraser:before {
    content: "\f12d";
}
.fa-puzzle-piece:before {
    content: "\f12e";
}
.fa-microphone:before {
    content: "\f130";
}
.fa-microphone-slash:before {
    content: "\f131";
}
.fa-shield:before {
    content: "\f132";
}
.fa-calendar-o:before {
    content: "\f133";
}
.fa-fire-extinguisher:before {
    content: "\f134";
}
.fa-rocket:before {
    content: "\f135";
}
.fa-maxcdn:before {
    content: "\f136";
}
.fa-chevron-circle-left:before {
    content: "\f137";
}
.fa-chevron-circle-right:before {
    content: "\f138";
}
.fa-chevron-circle-up:before {
    content: "\f139";
}
.fa-chevron-circle-down:before {
    content: "\f13a";
}
.fa-html5:before {
    content: "\f13b";
}
.fa-css3:before {
    content: "\f13c";
}
.fa-anchor:before {
    content: "\f13d";
}
.fa-unlock-alt:before {
    content: "\f13e";
}
.fa-bullseye:before {
    content: "\f140";
}
.fa-ellipsis-h:before {
    content: "\f141";
}
.fa-ellipsis-v:before {
    content: "\f142";
}
.fa-rss-square:before {
    content: "\f143";
}
.fa-play-circle:before {
    content: "\f144";
}
.fa-ticket:before {
    content: "\f145";
}
.fa-minus-square:before {
    content: "\f146";
}
.fa-minus-square-o:before {
    content: "\f147";
}
.fa-level-up:before {
    content: "\f148";
}
.fa-level-down:before {
    content: "\f149";
}
.fa-check-square:before {
    content: "\f14a";
}
.fa-pencil-square:before {
    content: "\f14b";
}
.fa-external-link-square:before {
    content: "\f14c";
}
.fa-share-square:before {
    content: "\f14d";
}
.fa-compass:before {
    content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
    content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
    content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
    content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
    content: "\f153";
}
.fa-gbp:before {
    content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
    content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
    content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
    content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
    content: "\f158";
}
.fa-won:before,
.fa-krw:before {
    content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
    content: "\f15a";
}
.fa-file:before {
    content: "\f15b";
}
.fa-file-text:before {
    content: "\f15c";
}
.fa-sort-alpha-asc:before {
    content: "\f15d";
}
.fa-sort-alpha-desc:before {
    content: "\f15e";
}
.fa-sort-amount-asc:before {
    content: "\f160";
}
.fa-sort-amount-desc:before {
    content: "\f161";
}
.fa-sort-numeric-asc:before {
    content: "\f162";
}
.fa-sort-numeric-desc:before {
    content: "\f163";
}
.fa-thumbs-up:before {
    content: "\f164";
}
.fa-thumbs-down:before {
    content: "\f165";
}
.fa-youtube-square:before {
    content: "\f166";
}
.fa-youtube:before {
    content: "\f167";
}
.fa-xing:before {
    content: "\f168";
}
.fa-xing-square:before {
    content: "\f169";
}
.fa-youtube-play:before {
    content: "\f16a";
}
.fa-dropbox:before {
    content: "\f16b";
}
.fa-stack-overflow:before {
    content: "\f16c";
}
.fa-instagram:before {
    content: "\f16d";
}
.fa-flickr:before {
    content: "\f16e";
}
.fa-adn:before {
    content: "\f170";
}
.fa-bitbucket:before {
    content: "\f171";
}
.fa-bitbucket-square:before {
    content: "\f172";
}
.fa-tumblr:before {
    content: "\f173";
}
.fa-tumblr-square:before {
    content: "\f174";
}
.fa-long-arrow-down:before {
    content: "\f175";
}
.fa-long-arrow-up:before {
    content: "\f176";
}
.fa-long-arrow-left:before {
    content: "\f177";
}
.fa-long-arrow-right:before {
    content: "\f178";
}
.fa-apple:before {
    content: "\f179";
}
.fa-windows:before {
    content: "\f17a";
}
.fa-android:before {
    content: "\f17b";
}
.fa-linux:before {
    content: "\f17c";
}
.fa-dribbble:before {
    content: "\f17d";
}
.fa-skype:before {
    content: "\f17e";
}
.fa-foursquare:before {
    content: "\f180";
}
.fa-trello:before {
    content: "\f181";
}
.fa-female:before {
    content: "\f182";
}
.fa-male:before {
    content: "\f183";
}
.fa-gittip:before,
.fa-gratipay:before {
    content: "\f184";
}
.fa-sun-o:before {
    content: "\f185";
}
.fa-moon-o:before {
    content: "\f186";
}
.fa-archive:before {
    content: "\f187";
}
.fa-bug:before {
    content: "\f188";
}
.fa-vk:before {
    content: "\f189";
}
.fa-weibo:before {
    content: "\f18a";
}
.fa-renren:before {
    content: "\f18b";
}
.fa-pagelines:before {
    content: "\f18c";
}
.fa-stack-exchange:before {
    content: "\f18d";
}
.fa-arrow-circle-o-right:before {
    content: "\f18e";
}
.fa-arrow-circle-o-left:before {
    content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
    content: "\f191";
}
.fa-dot-circle-o:before {
    content: "\f192";
}
.fa-wheelchair:before {
    content: "\f193";
}
.fa-vimeo-square:before {
    content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
    content: "\f195";
}
.fa-plus-square-o:before {
    content: "\f196";
}
.fa-space-shuttle:before {
    content: "\f197";
}
.fa-slack:before {
    content: "\f198";
}
.fa-envelope-square:before {
    content: "\f199";
}
.fa-wordpress:before {
    content: "\f19a";
}
.fa-openid:before {
    content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
    content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
    content: "\f19d";
}
.fa-yahoo:before {
    content: "\f19e";
}
.fa-google:before {
    content: "\f1a0";
}
.fa-reddit:before {
    content: "\f1a1";
}
.fa-reddit-square:before {
    content: "\f1a2";
}
.fa-stumbleupon-circle:before {
    content: "\f1a3";
}
.fa-stumbleupon:before {
    content: "\f1a4";
}
.fa-delicious:before {
    content: "\f1a5";
}
.fa-digg:before {
    content: "\f1a6";
}
.fa-pied-piper-pp:before {
    content: "\f1a7";
}
.fa-pied-piper-alt:before {
    content: "\f1a8";
}
.fa-drupal:before {
    content: "\f1a9";
}
.fa-joomla:before {
    content: "\f1aa";
}
.fa-language:before {
    content: "\f1ab";
}
.fa-fax:before {
    content: "\f1ac";
}
.fa-building:before {
    content: "\f1ad";
}
.fa-child:before {
    content: "\f1ae";
}
.fa-paw:before {
    content: "\f1b0";
}
.fa-spoon:before {
    content: "\f1b1";
}
.fa-cube:before {
    content: "\f1b2";
}
.fa-cubes:before {
    content: "\f1b3";
}
.fa-behance:before {
    content: "\f1b4";
}
.fa-behance-square:before {
    content: "\f1b5";
}
.fa-steam:before {
    content: "\f1b6";
}
.fa-steam-square:before {
    content: "\f1b7";
}
.fa-recycle:before {
    content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
    content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
    content: "\f1ba";
}
.fa-tree:before {
    content: "\f1bb";
}
.fa-spotify:before {
    content: "\f1bc";
}
.fa-deviantart:before {
    content: "\f1bd";
}
.fa-soundcloud:before {
    content: "\f1be";
}
.fa-database:before {
    content: "\f1c0";
}
.fa-file-pdf-o:before {
    content: "\f1c1";
}
.fa-file-word-o:before {
    content: "\f1c2";
}
.fa-file-excel-o:before {
    content: "\f1c3";
}
.fa-file-powerpoint-o:before {
    content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
    content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
    content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
    content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
    content: "\f1c8";
}
.fa-file-code-o:before {
    content: "\f1c9";
}
.fa-vine:before {
    content: "\f1ca";
}
.fa-codepen:before {
    content: "\f1cb";
}
.fa-jsfiddle:before {
    content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-buoy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
    content: "\f1cd";
}
.fa-circle-o-notch:before {
    content: "\f1ce";
}
.fa-ra:before,
.fa-resistance:before,
.fa-rebel:before {
    content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
    content: "\f1d1";
}
.fa-git-square:before {
    content: "\f1d2";
}
.fa-git:before {
    content: "\f1d3";
}
.fa-y-combinator-square:before,
.fa-yc-square:before,
.fa-hacker-news:before {
    content: "\f1d4";
}
.fa-tencent-weibo:before {
    content: "\f1d5";
}
.fa-qq:before {
    content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
    content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
    content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
    content: "\f1d9";
}
.fa-history:before {
    content: "\f1da";
}
.fa-circle-thin:before {
    content: "\f1db";
}
.fa-header:before {
    content: "\f1dc";
}
.fa-paragraph:before {
    content: "\f1dd";
}
.fa-sliders:before {
    content: "\f1de";
}
.fa-share-alt:before {
    content: "\f1e0";
}
.fa-share-alt-square:before {
    content: "\f1e1";
}
.fa-bomb:before {
    content: "\f1e2";
}
.fa-soccer-ball-o:before,
.fa-futbol-o:before {
    content: "\f1e3";
}
.fa-tty:before {
    content: "\f1e4";
}
.fa-binoculars:before {
    content: "\f1e5";
}
.fa-plug:before {
    content: "\f1e6";
}
.fa-slideshare:before {
    content: "\f1e7";
}
.fa-twitch:before {
    content: "\f1e8";
}
.fa-yelp:before {
    content: "\f1e9";
}
.fa-newspaper-o:before {
    content: "\f1ea";
}
.fa-wifi:before {
    content: "\f1eb";
}
.fa-calculator:before {
    content: "\f1ec";
}
.fa-paypal:before {
    content: "\f1ed";
}
.fa-google-wallet:before {
    content: "\f1ee";
}
.fa-cc-visa:before {
    content: "\f1f0";
}
.fa-cc-mastercard:before {
    content: "\f1f1";
}
.fa-cc-discover:before {
    content: "\f1f2";
}
.fa-cc-amex:before {
    content: "\f1f3";
}
.fa-cc-paypal:before {
    content: "\f1f4";
}
.fa-cc-stripe:before {
    content: "\f1f5";
}
.fa-bell-slash:before {
    content: "\f1f6";
}
.fa-bell-slash-o:before {
    content: "\f1f7";
}
.fa-trash:before {
    content: "\f1f8";
}
.fa-copyright:before {
    content: "\f1f9";
}
.fa-at:before {
    content: "\f1fa";
}
.fa-eyedropper:before {
    content: "\f1fb";
}
.fa-paint-brush:before {
    content: "\f1fc";
}
.fa-birthday-cake:before {
    content: "\f1fd";
}
.fa-area-chart:before {
    content: "\f1fe";
}
.fa-pie-chart:before {
    content: "\f200";
}
.fa-line-chart:before {
    content: "\f201";
}
.fa-lastfm:before {
    content: "\f202";
}
.fa-lastfm-square:before {
    content: "\f203";
}
.fa-toggle-off:before {
    content: "\f204";
}
.fa-toggle-on:before {
    content: "\f205";
}
.fa-bicycle:before {
    content: "\f206";
}
.fa-bus:before {
    content: "\f207";
}
.fa-ioxhost:before {
    content: "\f208";
}
.fa-angellist:before {
    content: "\f209";
}
.fa-cc:before {
    content: "\f20a";
}
.fa-shekel:before,
.fa-sheqel:before,
.fa-ils:before {
    content: "\f20b";
}
.fa-meanpath:before {
    content: "\f20c";
}
.fa-buysellads:before {
    content: "\f20d";
}
.fa-connectdevelop:before {
    content: "\f20e";
}
.fa-dashcube:before {
    content: "\f210";
}
.fa-forumbee:before {
    content: "\f211";
}
.fa-leanpub:before {
    content: "\f212";
}
.fa-sellsy:before {
    content: "\f213";
}
.fa-shirtsinbulk:before {
    content: "\f214";
}
.fa-simplybuilt:before {
    content: "\f215";
}
.fa-skyatlas:before {
    content: "\f216";
}
.fa-cart-plus:before {
    content: "\f217";
}
.fa-cart-arrow-down:before {
    content: "\f218";
}
.fa-diamond:before {
    content: "\f219";
}
.fa-ship:before {
    content: "\f21a";
}
.fa-user-secret:before {
    content: "\f21b";
}
.fa-motorcycle:before {
    content: "\f21c";
}
.fa-street-view:before {
    content: "\f21d";
}
.fa-heartbeat:before {
    content: "\f21e";
}
.fa-venus:before {
    content: "\f221";
}
.fa-mars:before {
    content: "\f222";
}
.fa-mercury:before {
    content: "\f223";
}
.fa-intersex:before,
.fa-transgender:before {
    content: "\f224";
}
.fa-transgender-alt:before {
    content: "\f225";
}
.fa-venus-double:before {
    content: "\f226";
}
.fa-mars-double:before {
    content: "\f227";
}
.fa-venus-mars:before {
    content: "\f228";
}
.fa-mars-stroke:before {
    content: "\f229";
}
.fa-mars-stroke-v:before {
    content: "\f22a";
}
.fa-mars-stroke-h:before {
    content: "\f22b";
}
.fa-neuter:before {
    content: "\f22c";
}
.fa-genderless:before {
    content: "\f22d";
}
.fa-facebook-official:before {
    content: "\f230";
}
.fa-pinterest-p:before {
    content: "\f231";
}
.fa-whatsapp:before {
    content: "\f232";
}
.fa-server:before {
    content: "\f233";
}
.fa-user-plus:before {
    content: "\f234";
}
.fa-user-times:before {
    content: "\f235";
}
.fa-hotel:before,
.fa-bed:before {
    content: "\f236";
}
.fa-viacoin:before {
    content: "\f237";
}
.fa-train:before {
    content: "\f238";
}
.fa-subway:before {
    content: "\f239";
}
.fa-medium:before {
    content: "\f23a";
}
.fa-yc:before,
.fa-y-combinator:before {
    content: "\f23b";
}
.fa-optin-monster:before {
    content: "\f23c";
}
.fa-opencart:before {
    content: "\f23d";
}
.fa-expeditedssl:before {
    content: "\f23e";
}
.fa-battery-4:before,
.fa-battery:before,
.fa-battery-full:before {
    content: "\f240";
}
.fa-battery-3:before,
.fa-battery-three-quarters:before {
    content: "\f241";
}
.fa-battery-2:before,
.fa-battery-half:before {
    content: "\f242";
}
.fa-battery-1:before,
.fa-battery-quarter:before {
    content: "\f243";
}
.fa-battery-0:before,
.fa-battery-empty:before {
    content: "\f244";
}
.fa-mouse-pointer:before {
    content: "\f245";
}
.fa-i-cursor:before {
    content: "\f246";
}
.fa-object-group:before {
    content: "\f247";
}
.fa-object-ungroup:before {
    content: "\f248";
}
.fa-sticky-note:before {
    content: "\f249";
}
.fa-sticky-note-o:before {
    content: "\f24a";
}
.fa-cc-jcb:before {
    content: "\f24b";
}
.fa-cc-diners-club:before {
    content: "\f24c";
}
.fa-clone:before {
    content: "\f24d";
}
.fa-balance-scale:before {
    content: "\f24e";
}
.fa-hourglass-o:before {
    content: "\f250";
}
.fa-hourglass-1:before,
.fa-hourglass-start:before {
    content: "\f251";
}
.fa-hourglass-2:before,
.fa-hourglass-half:before {
    content: "\f252";
}
.fa-hourglass-3:before,
.fa-hourglass-end:before {
    content: "\f253";
}
.fa-hourglass:before {
    content: "\f254";
}
.fa-hand-grab-o:before,
.fa-hand-rock-o:before {
    content: "\f255";
}
.fa-hand-stop-o:before,
.fa-hand-paper-o:before {
    content: "\f256";
}
.fa-hand-scissors-o:before {
    content: "\f257";
}
.fa-hand-lizard-o:before {
    content: "\f258";
}
.fa-hand-spock-o:before {
    content: "\f259";
}
.fa-hand-pointer-o:before {
    content: "\f25a";
}
.fa-hand-peace-o:before {
    content: "\f25b";
}
.fa-trademark:before {
    content: "\f25c";
}
.fa-registered:before {
    content: "\f25d";
}
.fa-creative-commons:before {
    content: "\f25e";
}
.fa-gg:before {
    content: "\f260";
}
.fa-gg-circle:before {
    content: "\f261";
}
.fa-tripadvisor:before {
    content: "\f262";
}
.fa-odnoklassniki:before {
    content: "\f263";
}
.fa-odnoklassniki-square:before {
    content: "\f264";
}
.fa-get-pocket:before {
    content: "\f265";
}
.fa-wikipedia-w:before {
    content: "\f266";
}
.fa-safari:before {
    content: "\f267";
}
.fa-chrome:before {
    content: "\f268";
}
.fa-firefox:before {
    content: "\f269";
}
.fa-opera:before {
    content: "\f26a";
}
.fa-internet-explorer:before {
    content: "\f26b";
}
.fa-tv:before,
.fa-television:before {
    content: "\f26c";
}
.fa-contao:before {
    content: "\f26d";
}
.fa-500px:before {
    content: "\f26e";
}
.fa-amazon:before {
    content: "\f270";
}
.fa-calendar-plus-o:before {
    content: "\f271";
}
.fa-calendar-minus-o:before {
    content: "\f272";
}
.fa-calendar-times-o:before {
    content: "\f273";
}
.fa-calendar-check-o:before {
    content: "\f274";
}
.fa-industry:before {
    content: "\f275";
}
.fa-map-pin:before {
    content: "\f276";
}
.fa-map-signs:before {
    content: "\f277";
}
.fa-map-o:before {
    content: "\f278";
}
.fa-map:before {
    content: "\f279";
}
.fa-commenting:before {
    content: "\f27a";
}
.fa-commenting-o:before {
    content: "\f27b";
}
.fa-houzz:before {
    content: "\f27c";
}
.fa-vimeo:before {
    content: "\f27d";
}
.fa-black-tie:before {
    content: "\f27e";
}
.fa-fonticons:before {
    content: "\f280";
}
.fa-reddit-alien:before {
    content: "\f281";
}
.fa-edge:before {
    content: "\f282";
}
.fa-credit-card-alt:before {
    content: "\f283";
}
.fa-codiepie:before {
    content: "\f284";
}
.fa-modx:before {
    content: "\f285";
}
.fa-fort-awesome:before {
    content: "\f286";
}
.fa-usb:before {
    content: "\f287";
}
.fa-product-hunt:before {
    content: "\f288";
}
.fa-mixcloud:before {
    content: "\f289";
}
.fa-scribd:before {
    content: "\f28a";
}
.fa-pause-circle:before {
    content: "\f28b";
}
.fa-pause-circle-o:before {
    content: "\f28c";
}
.fa-stop-circle:before {
    content: "\f28d";
}
.fa-stop-circle-o:before {
    content: "\f28e";
}
.fa-shopping-bag:before {
    content: "\f290";
}
.fa-shopping-basket:before {
    content: "\f291";
}
.fa-hashtag:before {
    content: "\f292";
}
.fa-bluetooth:before {
    content: "\f293";
}
.fa-bluetooth-b:before {
    content: "\f294";
}
.fa-percent:before {
    content: "\f295";
}
.fa-gitlab:before {
    content: "\f296";
}
.fa-wpbeginner:before {
    content: "\f297";
}
.fa-wpforms:before {
    content: "\f298";
}
.fa-envira:before {
    content: "\f299";
}
.fa-universal-access:before {
    content: "\f29a";
}
.fa-wheelchair-alt:before {
    content: "\f29b";
}
.fa-question-circle-o:before {
    content: "\f29c";
}
.fa-blind:before {
    content: "\f29d";
}
.fa-audio-description:before {
    content: "\f29e";
}
.fa-volume-control-phone:before {
    content: "\f2a0";
}
.fa-braille:before {
    content: "\f2a1";
}
.fa-assistive-listening-systems:before {
    content: "\f2a2";
}
.fa-asl-interpreting:before,
.fa-american-sign-language-interpreting:before {
    content: "\f2a3";
}
.fa-deafness:before,
.fa-hard-of-hearing:before,
.fa-deaf:before {
    content: "\f2a4";
}
.fa-glide:before {
    content: "\f2a5";
}
.fa-glide-g:before {
    content: "\f2a6";
}
.fa-signing:before,
.fa-sign-language:before {
    content: "\f2a7";
}
.fa-low-vision:before {
    content: "\f2a8";
}
.fa-viadeo:before {
    content: "\f2a9";
}
.fa-viadeo-square:before {
    content: "\f2aa";
}
.fa-snapchat:before {
    content: "\f2ab";
}
.fa-snapchat-ghost:before {
    content: "\f2ac";
}
.fa-snapchat-square:before {
    content: "\f2ad";
}
.fa-pied-piper:before {
    content: "\f2ae";
}
.fa-first-order:before {
    content: "\f2b0";
}
.fa-yoast:before {
    content: "\f2b1";
}
.fa-themeisle:before {
    content: "\f2b2";
}
.fa-google-plus-circle:before,
.fa-google-plus-official:before {
    content: "\f2b3";
}
.fa-fa:before,
.fa-font-awesome:before {
    content: "\f2b4";
}
.fa-handshake-o:before {
    content: "\f2b5";
}
.fa-envelope-open:before {
    content: "\f2b6";
}
.fa-envelope-open-o:before {
    content: "\f2b7";
}
.fa-linode:before {
    content: "\f2b8";
}
.fa-address-book:before {
    content: "\f2b9";
}
.fa-address-book-o:before {
    content: "\f2ba";
}
.fa-vcard:before,
.fa-address-card:before {
    content: "\f2bb";
}
.fa-vcard-o:before,
.fa-address-card-o:before {
    content: "\f2bc";
}
.fa-user-circle:before {
    content: "\f2bd";
}
.fa-user-circle-o:before {
    content: "\f2be";
}
.fa-user-o:before {
    content: "\f2c0";
}
.fa-id-badge:before {
    content: "\f2c1";
}
.fa-drivers-license:before,
.fa-id-card:before {
    content: "\f2c2";
}
.fa-drivers-license-o:before,
.fa-id-card-o:before {
    content: "\f2c3";
}
.fa-quora:before {
    content: "\f2c4";
}
.fa-free-code-camp:before {
    content: "\f2c5";
}
.fa-telegram:before {
    content: "\f2c6";
}
.fa-thermometer-4:before,
.fa-thermometer:before,
.fa-thermometer-full:before {
    content: "\f2c7";
}
.fa-thermometer-3:before,
.fa-thermometer-three-quarters:before {
    content: "\f2c8";
}
.fa-thermometer-2:before,
.fa-thermometer-half:before {
    content: "\f2c9";
}
.fa-thermometer-1:before,
.fa-thermometer-quarter:before {
    content: "\f2ca";
}
.fa-thermometer-0:before,
.fa-thermometer-empty:before {
    content: "\f2cb";
}
.fa-shower:before {
    content: "\f2cc";
}
.fa-bathtub:before,
.fa-s15:before,
.fa-bath:before {
    content: "\f2cd";
}
.fa-podcast:before {
    content: "\f2ce";
}
.fa-window-maximize:before {
    content: "\f2d0";
}
.fa-window-minimize:before {
    content: "\f2d1";
}
.fa-window-restore:before {
    content: "\f2d2";
}
.fa-times-rectangle:before,
.fa-window-close:before {
    content: "\f2d3";
}
.fa-times-rectangle-o:before,
.fa-window-close-o:before {
    content: "\f2d4";
}
.fa-bandcamp:before {
    content: "\f2d5";
}
.fa-grav:before {
    content: "\f2d6";
}
.fa-etsy:before {
    content: "\f2d7";
}
.fa-imdb:before {
    content: "\f2d8";
}
.fa-ravelry:before {
    content: "\f2d9";
}
.fa-eercast:before {
    content: "\f2da";
}
.fa-microchip:before {
    content: "\f2db";
}
.fa-snowflake-o:before {
    content: "\f2dc";
}
.fa-superpowers:before {
    content: "\f2dd";
}
.fa-wpexplorer:before {
    content: "\f2de";
}
.fa-meetup:before {
    content: "\f2e0";
}
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
}
.sr-only-focusable:active,
.sr-only-focusable:focus {
    position: static;
    width: auto;
    height: auto;
    margin: 0;
    overflow: visible;
    clip: auto;
}
</style>
    <style>

/*! XP.css v0.2.4 - https://botoxparty.github.io/XP.css/ */


.wbox-body {
	font-family: Arial;
	font-size: 1em;
	color: #222
}

.wbox.surface {
	background: #ece9d8
}

.wbox h1 {
	font-size: 5rem
}

.wbox h2 {
	font-size: 2.5rem
}

.wbox h3 {
	font-size: 2rem
}

.wbox h4 {
	font-size: 1.5rem
}

.wbox u {
	text-decoration: none;
	border-bottom: .5px solid #222
}

.wbox a {
	color: #00f
}

.wbox a:focus {
	outline: 1px dotted #00f
}

.wbox code,
.wbox code * {
	font-family: monospace
}

.wbox pre {
	display: block;
	padding: 12px 8px;
	background-color: #000;
	color: silver;
	font-size: 1rem;
	margin: 0
}

.wbox pre,
.wbox pre * {
	font-family: Perfect DOS VGA\ 437 Win
}

.wbox summary:focus {
	outline: 1px dotted #000
}

.wbox ::-webkit-scrollbar {
	width: 16px
}

.wbox ::-webkit-scrollbar:horizontal {
	height: 17px
}

.wbox ::-webkit-scrollbar-track {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='2' height='2' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M1 0H0v1h1v1h1V1H1V0z' fill='silver'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2 0H1v1H0v1h1V1h1V0z' fill='%23fff'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-thumb {
	background-color: #dfdfdf;
	box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #fff, inset -2px -2px grey, inset 2px 2px #dfdfdf
}

.wbox ::-webkit-scrollbar-button:horizontal:end:increment,
.wbox ::-webkit-scrollbar-button:horizontal:start:decrement,
.wbox ::-webkit-scrollbar-button:vertical:end:increment,
.wbox ::-webkit-scrollbar-button:vertical:start:decrement {
	display: block
}

.wbox ::-webkit-scrollbar-button:vertical:start {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 0H0v16h1V1h14V0z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2 1H1v14h1V2h12V1H2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M16 17H0v-1h15V0h1v17z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 1h-1v14H1v1h14V1z' fill='gray'/%3E%3Cpath fill='silver' d='M2 2h12v13H2z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 6H7v1H6v1H5v1H4v1h7V9h-1V8H9V7H8V6z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:vertical:end {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 0H0v16h1V1h14V0z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2 1H1v14h1V2h12V1H2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M16 17H0v-1h15V0h1v17z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 1h-1v14H1v1h14V1z' fill='gray'/%3E%3Cpath fill='silver' d='M2 2h12v13H2z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M11 6H4v1h1v1h1v1h1v1h1V9h1V8h1V7h1V6z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:horizontal:start {
	width: 16px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 0H0v16h1V1h14V0z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2 1H1v14h1V2h12V1H2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M16 17H0v-1h15V0h1v17z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 1h-1v14H1v1h14V1z' fill='gray'/%3E%3Cpath fill='silver' d='M2 2h12v13H2z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 4H8v1H7v1H6v1H5v1h1v1h1v1h1v1h1V4z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:horizontal:end {
	width: 16px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 0H0v16h1V1h14V0z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2 1H1v14h1V2h12V1H2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M16 17H0v-1h15V0h1v17z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 1h-1v14H1v1h14V1z' fill='gray'/%3E%3Cpath fill='silver' d='M2 2h12v13H2z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M7 4H6v7h1v-1h1V9h1V8h1V7H9V6H8V5H7V4z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox button {
	border: none;
	background: #ece9d8;
	box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #fff, inset -2px -2px grey, inset 2px 2px #dfdfdf;
	border-radius: 0;
	min-width: 75px;
	min-height: 23px;
	padding: 0 12px
}

.wbox button:not(:disabled).active,
.wbox button:not(:disabled):active {
	box-shadow: inset -1px -1px #fff, inset 1px 1px #0a0a0a, inset -2px -2px #dfdfdf, inset 2px 2px grey
}

.wbox button.focused,
.wbox button:focus {
	outline: 1px dotted #000;
	outline-offset: -4px
}

.wbox label {
	display: inline; /*-flex;*/
	align-items: center
}

.wbox input,
.wbox label,
.wbox textarea {
	font-family: "Roboto", Arial;
	font-size: 1em
}

.wbox textarea {
	padding: 3px 4px;
	border: none;
	background-color: #fff;
	box-sizing: border-box;
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
	border-radius: 0
}

.wbox textarea:focus {
	outline: none
}

.wbox select {
	font-family: "Roboto", Arial;
	font-size: 1em;
	border: none;
	background-color: #fff;
	box-sizing: border-box;
	height: 21px;
	appearance: none;
	-webkit-appearance: none;
	-moz-appearance: none;
	position: relative;
	padding: 3px 32px 3px 4px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 0H0v16h1V1h14V0z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2 1H1v14h1V2h12V1H2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M16 17H0v-1h15V0h1v17z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M15 1h-1v14H1v1h14V1z' fill='gray'/%3E%3Cpath fill='silver' d='M2 2h12v13H2z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M11 6H4v1h1v1h1v1h1v1h1V9h1V8h1V7h1V6z' fill='%23000'/%3E%3C/svg%3E");
	background-position: top 2px right 2px;
	background-repeat: no-repeat;
	border-radius: 0
}

.wbox select:focus {
	outline: none;
	color: #fff;
	background-color: #2267cb
}

.wbox select:focus option {
	color: #000;
	background-color: #fff
}

.wbox select:active {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 0h16v17H0V0zm1 16h14V1H1v15z' fill='gray'/%3E%3Cpath fill='silver' d='M1 1h14v15H1z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12 7H5v1h1v1h1v1h1v1h1v-1h1V9h1V8h1V7z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox option {
	font-family: "Roboto", Arial;
	font-size: 1em
}

.wbox .vertical-bar {
	width: 4px;
	height: 20px;
	background: silver;
	box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #fff, inset -2px -2px grey, inset 2px 2px #dfdfdf
}

.wbox &:disabled,
.wbox &:disabled+label {
	color: grey;
	text-shadow: 1px 1px 0 #fff
}

.wbox input[type=radio]+label {
	line-height: 13px;
	position: relative;
	margin-left: 19px
}

.wbox input[type=radio]+label:before {
	content: "";
	position: absolute;
	top: 0;
	left: -19px;
	display: inline-block;
	width: 13px;
	height: 13px;
	margin-right: 6px;
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='12' height='12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 0H4v1H2v1H1v2H0v4h1v2h1V8H1V4h1V2h2V1h4v1h2V1H8V0z' fill='gray'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 1H4v1H2v2H1v4h1v1h1V8H2V4h1V3h1V2h4v1h2V2H8V1z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 3h1v1H9V3zm1 5V4h1v4h-1zm-2 2V9h1V8h1v2H8zm-4 0v1h4v-1H4zm0 0V9H2v1h2z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M11 2h-1v2h1v4h-1v2H8v1H4v-1H2v1h2v1h4v-1h2v-1h1V8h1V4h-1V2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M4 2h4v1h1v1h1v4H9v1H8v1H4V9H3V8H2V4h1V3h1V2z' fill='%23fff'/%3E%3C/svg%3E")
}

.wbox input[type=radio]:active+label:before {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='12' height='12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 0H4v1H2v1H1v2H0v4h1v2h1V8H1V4h1V2h2V1h4v1h2V1H8V0z' fill='gray'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 1H4v1H2v2H1v4h1v1h1V8H2V4h1V3h1V2h4v1h2V2H8V1z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 3h1v1H9V3zm1 5V4h1v4h-1zm-2 2V9h1V8h1v2H8zm-4 0v1h4v-1H4zm0 0V9H2v1h2z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M11 2h-1v2h1v4h-1v2H8v1H4v-1H2v1h2v1h4v-1h2v-1h1V8h1V4h-1V2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M4 2h4v1h1v1h1v4H9v1H8v1H4V9H3V8H2V4h1V3h1V2z' fill='silver'/%3E%3C/svg%3E")
}

.wbox input[type=radio]:checked+label:after {
	content: "";
	display: block;
	width: 5px;
	height: 5px;
	top: 5px;
	left: -14px;
	position: absolute;
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='4' height='4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M3 0H1v1H0v2h1v1h2V3h1V1H3V0z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox input[type=checkbox] {
	appearance: none;
	-webkit-appearance: none;
	-moz-appearance: none;
	margin: 0;
	background: 0;
	position: fixed;
	opacity: 0;
	border: none
}

.wbox input[type=checkbox]+label {
	line-height: 13px;
	position: relative;
	margin-left: 19px
}

.wbox input[type=checkbox]+label:before {
	content: "";
	position: absolute;
	left: -19px;
	display: inline-block;
	width: 13px;
	height: 13px;
	background: #fff;
	box-shadow: inset -1px -1px #fff, inset 1px 1px grey, inset -2px -2px #dfdfdf, inset 2px 2px #0a0a0a;
	margin-right: 6px
}

.wbox input[type=checkbox]:focus+label {
	outline: 1px dotted #000
}

.wbox input[type=checkbox]:active+label:before {
	background: #ece9d8
}

.wbox input[type=checkbox]:checked+label:after {
	content: "";
	display: block;
	width: 11px;
	height: 11px;
	position: absolute;
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='7' height='7' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M7 0H6v1H5v1H4v1H3v1H2V3H1V2H0v3h1v1h1v1h1V6h1V5h1V4h1V3h1V0z' fill='%23000'/%3E%3C/svg%3E");
	top: 1px
}

.wbox input[type=radio][disabled]+label:before {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='12' height='12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 0H4v1H2v1H1v2H0v4h1v2h1V8H1V4h1V2h2V1h4v1h2V1H8V0z' fill='gray'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 1H4v1H2v2H1v4h1v1h1V8H2V4h1V3h1V2h4v1h2V2H8V1z' fill='%23000'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 3h1v1H9V3zm1 5V4h1v4h-1zm-2 2V9h1V8h1v2H8zm-4 0v1h4v-1H4zm0 0V9H2v1h2z' fill='%23DFDFDF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M11 2h-1v2h1v4h-1v2H8v1H4v-1H2v1h2v1h4v-1h2v-1h1V8h1V4h-1V2z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M4 2h4v1h1v1h1v4H9v1H8v1H4V9H3V8H2V4h1V3h1V2z' fill='silver'/%3E%3C/svg%3E")
}

.wbox input[type=radio][disabled]:checked+label:after {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='4' height='4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M3 0H1v1H0v2h1v1h2V3h1V1H3V0z' fill='gray'/%3E%3C/svg%3E")
}

.wbox input[type=checkbox][disabled]+label:before {
	background: #ece9d8
}

.wbox input[type=checkbox][disabled]:checked+label:after {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='7' height='7' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M7 0H6v1H5v1H4v1H3v1H2V3H1V2H0v3h1v1h1v1h1V6h1V5h1V4h1V3h1V0z' fill='gray'/%3E%3C/svg%3E")
}

.wbox input[type=email],
.wbox input[type=password],
.wbox input[type=text] {
	padding: 3px 4px;
	border: none;
	background-color: #fff;
	box-sizing: border-box;
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
	border-radius: 0;
	height: 21px;
	line-height: 2
}

.wbox input[type=email]:focus,
.wbox input[type=password]:focus,
.wbox input[type=text]:focus {
	outline: none
}

.wbox input[type=range] {
	-webkit-appearance: none;
	width: 100%;
	background: transparent
}

.wbox input[type=range]:focus {
	outline: none
}

.wbox input[type=range]::-webkit-slider-thumb {
	-webkit-appearance: none;
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='11' height='21' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 0v16h2v2h2v2h1v-1H3v-2H1V1h9V0z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M1 1v15h1v1h1v1h1v1h2v-1h1v-1h1v-1h1V1z' fill='%23C0C7C8'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 1h1v15H8v2H6v2H5v-1h2v-2h2z' fill='%2387888F'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M10 0h1v16H9v2H7v2H5v1h1v-2h2v-2h2z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox input[type=range]::-moz-range-thumb {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='11' height='21' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 0v16h2v2h2v2h1v-1H3v-2H1V1h9V0z' fill='%23fff'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M1 1v15h1v1h1v1h1v1h2v-1h1v-1h1v-1h1V1z' fill='%23C0C7C8'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 1h1v15H8v2H6v2H5v-1h2v-2h2z' fill='%2387888F'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M10 0h1v16H9v2H7v2H5v1h1v-2h2v-2h2z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox input[type=range]::-webkit-slider-runnable-track {
	background: #000;
	border-right: 1px solid grey;
	border-bottom: 1px solid grey;
	box-shadow: 1px 0 0 #fff, 1px 1px 0 #fff, 0 1px 0 #fff, -1px 0 0 #a9a9a9, -1px -1px 0 #a9a9a9, 0 -1px 0 #a9a9a9, -1px 1px 0 #fff, 1px -1px #a9a9a9
}

.wbox input[type=range]::-moz-range-track {
	background: #000;
	border-right: 1px solid grey;
	border-bottom: 1px solid grey;
	box-shadow: 1px 0 0 #fff, 1px 1px 0 #fff, 0 1px 0 #fff, -1px 0 0 #a9a9a9, -1px -1px 0 #a9a9a9, 0 -1px 0 #a9a9a9, -1px 1px 0 #fff, 1px -1px #a9a9a9
}

.wbox input[type=range].has-box-indicator::-webkit-slider-thumb {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='11' height='21' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 0v20h1V1h9V0z' fill='%23fff'/%3E%3Cpath fill='%23C0C7C8' d='M1 1h8v18H1z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 1h1v19H1v-1h8z' fill='%2387888F'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M10 0h1v21H0v-1h10z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox input[type=range].has-box-indicator::-moz-range-thumb {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg width='11' height='21' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 0v20h1V1h9V0z' fill='%23fff'/%3E%3Cpath fill='%23C0C7C8' d='M1 1h8v18H1z'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M9 1h1v19H1v-1h8z' fill='%2387888F'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M10 0h1v21H0v-1h10z' fill='%23000'/%3E%3C/svg%3E")
}

.wbox .is-vertical {
	display: inline-block;
	width: 4px;
	height: 150px;
	transform: translateY(50%)
}

.wbox .is-vertical>input[type=range] {
	width: 150px;
	height: 4px;
	margin: 0 16px 0 10px;
	transform-origin: left;
	transform: rotate(270deg) translateX(calc(-50% + 8px))
}

.wbox .is-vertical>input[type=range]::-webkit-slider-runnable-track {
	border-left: 1px solid grey;
	border-bottom: 1px solid grey;
	box-shadow: -1px 0 0 #fff, -1px 1px 0 #fff, 0 1px 0 #fff, 1px 0 0 #a9a9a9, 1px -1px 0 #a9a9a9, 0 -1px 0 #a9a9a9, 1px 1px 0 #fff, -1px -1px #a9a9a9
}

.wbox .is-vertical>input[type=range]::-moz-range-track {
	border-left: 1px solid grey;
	border-bottom: 1px solid grey;
	box-shadow: -1px 0 0 #fff, -1px 1px 0 #fff, 0 1px 0 #fff, 1px 0 0 #a9a9a9, 1px -1px 0 #a9a9a9, 0 -1px 0 #a9a9a9, 1px 1px 0 #fff, -1px -1px #a9a9a9
}

.wbox .is-vertical>input[type=range]::-webkit-slider-thumb {
	transform: translateY(-8px) scaleX(-1)
}

.wbox .is-vertical>input[type=range]::-moz-range-thumb {
	transform: translateY(2px) scaleX(-1)
}

.wbox .is-vertical>input[type=range].has-box-indicator::-webkit-slider-thumb {
	transform: translateY(-10px) scaleX(-1)
}

.wbox .is-vertical>input[type=range].has-box-indicator::-moz-range-thumb {
	transform: translateY(0) scaleX(-1)
}

.wbox .window {
	font-size: 1em;
	box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #dfdfdf, inset -2px -2px grey, inset 2px 2px #fff;
	background: #ece9d8;
	padding: 3px
}

.wbox .window fieldset {
	margin-bottom: 9px
}

.wbox .title-bar {
	font-size: 1em;
	background: #000;
	padding: 3px 2px 3px 3px;
	display: flex;
	justify-content: space-between;
	align-items: center
}

.wbox .title-bar-text {
	font-weight: 700;
	color: #fff;
	letter-spacing: 0;
	margin-right: 24px
}

.wbox .title-bar-controls button {
	padding: 0;
	display: block;
	min-width: 16px;
	min-height: 14px
}

.wbox .title-bar-controls button:focus {
	outline: none
}

.wbox .window-body {
	margin: 8px
}

.wbox .window-body pre {
	margin: -8px
}

.wbox .status-bar {
	margin: 0 1px;
	display: flex;
	gap: 1px
}

.wbox .status-bar-field {
	box-shadow: inset -1px -1px #dfdfdf, inset 1px 1px grey;
	flex-grow: 1;
	padding: 2px 3px;
	margin: 0
}

.wbox ul.tree-view {
	font-family: "Roboto", Arial;
	font-size: 1em;
	display: block;
	background: #fff;
	padding: 6px;
	margin: 0
}

.wbox ul.tree-view li {
	list-style-type: none;
	margin-top: 3px
}

.wbox ul.tree-view a {
	text-decoration: none;
	color: #000
}

.wbox ul.tree-view a:focus {
	background-color: #2267cb;
	color: #fff
}

.wbox ul.tree-view ul {
	margin-top: 3px;
	margin-left: 20px; /*16px;*/
	padding-left: 16px;
	border-left: 1px dotted grey
}
.wbox ul.tree-view ul ul { margin-left: 0px !important; }
.wbox ul.tree-view ul ul ul { margin-left: 0px !important; }
.wbox ul.tree-view ul ul ul ul { margin-left: 0px !important; }
.wbox ul.tree-view ul ul ul ul ul { margin-left: 0px !important; }
.wbox ul.tree-view ul ul ul ul ul ul { margin-left: 0px !important; }

.wbox ul.tree-view ul>li {
	position: relative
}

.wbox ul.tree-view ul>li:before {
	content: "";
	display: block;
	position: absolute;
	left: -16px;
	top: 0.5em; /*6px;*/
	width: 12px;
	border-bottom: 1px dotted grey
}

.wbox ul.tree-view ul>li:last-child:after {
	content: "";
	display: block;
	position: absolute;
	left: -20px;
	top: 0.6em; /*7px;*/
	bottom: 0;
	width: 8px;
	background: #fff
}

.wbox ul.tree-view ul details>summary:before {
	margin-left: -22px;
	position: relative;
	z-index: 1
}

.wbox ul.tree-view details {
	margin-top: 0
}

.wbox ul.tree-view details>summary:before {
	text-align: center;
	display: inline-block;
	/*float: left;*/
	content: "+";
	border: 1px solid grey;
	width: 0.8em; /*8px;*/
	height: 0.8em; /*9px;*/
	line-height: 0.5em; /*9px;*/
	margin-right: 5px;
	padding-left: 1px;
	background-color: #fff;
	cursor: pointer;
	vertical-align: middle;
}

.wbox ul.tree-view details[open] summary {
	margin-bottom: 0
}

.wbox ul.tree-view details[open]>summary:before {
	content: "-"
}

.wbox fieldset {
	border: none;
	box-shadow: inset -1px -1px #fff, inset 1px 1px #0a0a0a, inset -2px -2px grey, inset 2px 2px #dfdfdf;
	padding: 10px;
	padding-block-start: 8px;
	margin: 0
}

.wbox legend {
	background: #ece9d8
}

.wbox menu[role=tablist] {
	position: relative;
	margin: 0 0 -2px;
	text-indent: 0;
	list-style-type: none;
	display: flex;
	padding-left: 3px
}

.wbox menu[role=tablist] button {
	z-index: 1;
	display: block;
	color: #222;
	text-decoration: none;
	min-width: unset
}

.wbox menu[role=tablist] button[aria-selected=true] {
	padding-bottom: 2px;
	margin-top: -2px;
	background-color: #ece9d8;
	position: relative;
	z-index: 8;
	margin-left: -3px;
	margin-bottom: 1px
}

.wbox menu[role=tablist] button:focus {
	outline: 1px dotted #222;
	outline-offset: -4px
}

.wbox menu[role=tablist].justified button {
	flex-grow: 1;
	text-align: center
}

.wbox [role=tabpanel] {
	padding: 14px;
	clear: both;
	background: linear-gradient(180deg, #fcfcfe, #f4f3ee);
	border: 1px solid #919b9c;
	position: relative;
	z-index: 2;
	margin-bottom: 9px
}

.wbox ::-webkit-scrollbar {
	width: 17px
}

.wbox ::-webkit-scrollbar-corner {
	background: #dfdfdf
}

.wbox ::-webkit-scrollbar-track:vertical {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 17 1' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eeede5' d='M0 0h1m15 0h1'/%3E%3Cpath stroke='%23f3f1ec' d='M1 0h1'/%3E%3Cpath stroke='%23f4f1ec' d='M2 0h1'/%3E%3Cpath stroke='%23f4f3ee' d='M3 0h1'/%3E%3Cpath stroke='%23f5f4ef' d='M4 0h1'/%3E%3Cpath stroke='%23f6f5f0' d='M5 0h1'/%3E%3Cpath stroke='%23f7f7f3' d='M6 0h1'/%3E%3Cpath stroke='%23f9f8f4' d='M7 0h1'/%3E%3Cpath stroke='%23f9f9f7' d='M8 0h1'/%3E%3Cpath stroke='%23fbfbf8' d='M9 0h1'/%3E%3Cpath stroke='%23fbfbf9' d='M10 0h2'/%3E%3Cpath stroke='%23fdfdfa' d='M12 0h1'/%3E%3Cpath stroke='%23fefefb' d='M13 0h3'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-track:horizontal {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 1 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eeede5' d='M0 0h1M0 16h1'/%3E%3Cpath stroke='%23f3f1ec' d='M0 1h1'/%3E%3Cpath stroke='%23f4f1ec' d='M0 2h1'/%3E%3Cpath stroke='%23f4f3ee' d='M0 3h1'/%3E%3Cpath stroke='%23f5f4ef' d='M0 4h1'/%3E%3Cpath stroke='%23f6f5f0' d='M0 5h1'/%3E%3Cpath stroke='%23f7f7f3' d='M0 6h1'/%3E%3Cpath stroke='%23f9f8f4' d='M0 7h1'/%3E%3Cpath stroke='%23f9f9f7' d='M0 8h1'/%3E%3Cpath stroke='%23fbfbf8' d='M0 9h1'/%3E%3Cpath stroke='%23fbfbf9' d='M0 10h1m-1 1h1'/%3E%3Cpath stroke='%23fdfdfa' d='M0 12h1'/%3E%3Cpath stroke='%23fefefb' d='M0 13h1m-1 1h1m-1 1h1'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-thumb {
	background-position: 50%;
	background-repeat: no-repeat;
	background-color: #c8d6fb;
	background-size: 7px;
	border: 1px solid #fff;
	border-radius: 2px;
	box-shadow: inset -3px 0 #bad1fc, inset 1px 1px #b7caf5
}

.wbox ::-webkit-scrollbar-thumb:vertical {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 7 8' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eef4fe' d='M0 0h6M0 2h6M0 4h6M0 6h6'/%3E%3Cpath stroke='%23bad1fc' d='M6 0h1M6 2h1M6 4h1'/%3E%3Cpath stroke='%23c8d6fb' d='M0 1h1M0 3h1M0 5h1M0 7h1'/%3E%3Cpath stroke='%238cb0f8' d='M1 1h6M1 3h6M1 5h6M1 7h6'/%3E%3Cpath stroke='%23bad3fc' d='M6 6h1'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-thumb:horizontal {
	background-size: 8px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 8 7' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eef4fe' d='M0 0h1m1 0h1m1 0h1m1 0h1M0 1h1m1 0h1m1 0h1m1 0h1M0 2h1m1 0h1m1 0h1m1 0h1M0 3h1m1 0h1m1 0h1m1 0h1M0 4h1m1 0h1m1 0h1m1 0h1M0 5h1m1 0h1m1 0h1m1 0h1'/%3E%3Cpath stroke='%23c8d6fb' d='M1 0h1m1 0h1m1 0h1m1 0h1'/%3E%3Cpath stroke='%238cb0f8' d='M1 1h1m1 0h1m1 0h1m1 0h1M1 2h1m1 0h1m1 0h1m1 0h1M1 3h1m1 0h1m1 0h1m1 0h1M1 4h1m1 0h1m1 0h1m1 0h1M1 5h1m1 0h1m1 0h1m1 0h1M1 6h1m1 0h1m1 0h1m1 0h1'/%3E%3Cpath stroke='%23bad1fc' d='M0 6h1m1 0h1'/%3E%3Cpath stroke='%23bad3fc' d='M4 6h1m1 0h1'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:vertical:start {
	height: 17px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 17 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eeede5' d='M0 0h1m15 0h1M0 1h1M0 2h1M0 3h1M0 4h1M0 5h1M0 6h1M0 7h1M0 8h1M0 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m15 0h1M0 16h1m15 0h1'/%3E%3Cpath stroke='%23fdfdfa' d='M1 0h1'/%3E%3Cpath stroke='%23fff' d='M2 0h14M1 1h1m13 0h1M1 2h1m13 0h1M1 3h1m13 0h1M1 4h1m13 0h1M1 5h1m13 0h1M1 6h1m13 0h1M1 7h1m13 0h1M1 8h1m13 0h1M1 9h1m13 0h1M1 10h1m13 0h1M1 11h1m13 0h1M1 12h1m13 0h1M1 13h1m13 0h1M1 14h1m13 0h1M2 15h13'/%3E%3Cpath stroke='%23e6eefc' d='M2 1h1'/%3E%3Cpath stroke='%23d0dffc' d='M3 1h1M2 2h1'/%3E%3Cpath stroke='%23cad8f9' d='M4 1h1M2 3h1'/%3E%3Cpath stroke='%23c4d2f7' d='M5 1h1'/%3E%3Cpath stroke='%23c0d0f7' d='M6 1h1'/%3E%3Cpath stroke='%23bdcef7' d='M7 1h1M2 6h1'/%3E%3Cpath stroke='%23bbcdf5' d='M8 1h1'/%3E%3Cpath stroke='%23b8cbf6' d='M9 1h1M2 7h1'/%3E%3Cpath stroke='%23b7caf5' d='M10 1h1M2 8h1'/%3E%3Cpath stroke='%23b5c8f7' d='M11 1h1'/%3E%3Cpath stroke='%23b3c7f5' d='M12 1h1'/%3E%3Cpath stroke='%23afc5f4' d='M13 1h1'/%3E%3Cpath stroke='%23dce6f9' d='M14 1h1'/%3E%3Cpath stroke='%23dfe2e1' d='M16 1h1'/%3E%3Cpath stroke='%23e1eafe' d='M3 2h1'/%3E%3Cpath stroke='%23dae6fe' d='M4 2h1M3 3h1'/%3E%3Cpath stroke='%23d4e1fc' d='M5 2h1M3 4h1'/%3E%3Cpath stroke='%23d1e0fd' d='M6 2h1M4 4h1'/%3E%3Cpath stroke='%23d0ddfc' d='M7 2h1M3 5h1'/%3E%3Cpath stroke='%23cedbfd' d='M8 2h1M6 3h1'/%3E%3Cpath stroke='%23cad9fd' d='M9 2h1M7 3h1M5 5h1'/%3E%3Cpath stroke='%23c8d8fb' d='M10 2h1'/%3E%3Cpath stroke='%23c5d6fc' d='M11 2h1m-8 8h1m1 0h1'/%3E%3Cpath stroke='%23c2d3fc' d='M12 2h1m-2 1h1m-9 7h1m0 1h1'/%3E%3Cpath stroke='%23bccefa' d='M13 2h1m-1 2h1m-9 9h2'/%3E%3Cpath stroke='%23b9c9f3' d='M14 2h1M5 14h3'/%3E%3Cpath stroke='%23cfd7dd' d='M16 2h1'/%3E%3Cpath stroke='%23d8e3fc' d='M4 3h1'/%3E%3Cpath stroke='%23d1defd' d='M5 3h1'/%3E%3Cpath stroke='%23c9d8fc' d='M8 3h1M6 4h2M5 6h2M3 7h1'/%3E%3Cpath stroke='%23c5d5fc' d='M9 3h1M3 9h1m3 0h1'/%3E%3Cpath stroke='%23c5d3fc' d='M10 3h1'/%3E%3Cpath stroke='%23bed0fc' d='M12 3h1M9 4h1m-7 7h1m0 1h1'/%3E%3Cpath stroke='%23bccdfa' d='M13 3h1'/%3E%3Cpath stroke='%23baccf4' d='M14 3h1'/%3E%3Cpath stroke='%23bdcbda' d='M16 3h1'/%3E%3Cpath stroke='%23c4d4f7' d='M2 4h1'/%3E%3Cpath stroke='%23cddbfc' d='M5 4h1M3 6h1'/%3E%3Cpath stroke='%23c8d5fb' d='M8 4h1'/%3E%3Cpath stroke='%23bbcefd' d='M10 4h3M9 5h1'/%3E%3Cpath stroke='%23bcccf3' d='M14 4h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c2d5' d='M16 4h1'/%3E%3Cpath stroke='%23bed0f8' d='M2 5h1'/%3E%3Cpath stroke='%23ceddfd' d='M4 5h1'/%3E%3Cpath stroke='%23c8d6fb' d='M6 5h2M3 8h2'/%3E%3Cpath stroke='%234d6185' d='M8 5h1M7 6h3M6 7h5M5 8h3m1 0h3M4 9h3m3 0h3m-8 1h1m5 0h1'/%3E%3Cpath stroke='%23bacdfc' d='M10 5h1m1 0h2M3 12h1'/%3E%3Cpath stroke='%23b9cdfb' d='M11 5h1m-2 1h1m1 0h2m-1 1h1'/%3E%3Cpath stroke='%23a8bbd4' d='M16 5h1'/%3E%3Cpath stroke='%23cddafc' d='M4 6h1'/%3E%3Cpath stroke='%23b7cdfc' d='M11 6h1m0 1h1'/%3E%3Cpath stroke='%23a4b8d3' d='M16 6h1'/%3E%3Cpath stroke='%23cad8fd' d='M4 7h2'/%3E%3Cpath stroke='%23b6cefb' d='M11 7h1m0 1h1'/%3E%3Cpath stroke='%23bacbf4' d='M14 7h1'/%3E%3Cpath stroke='%23a0b5d3' d='M16 7h1m-1 1h1m-1 5h1'/%3E%3Cpath stroke='%23c1d3fb' d='M8 8h1'/%3E%3Cpath stroke='%23b6cdfb' d='M13 8h1m-5 5h1'/%3E%3Cpath stroke='%23b9cbf3' d='M14 8h1'/%3E%3Cpath stroke='%23b4c8f6' d='M2 9h1'/%3E%3Cpath stroke='%23c2d5fc' d='M8 9h1m-1 1h1m-3 1h2'/%3E%3Cpath stroke='%23bdd3fb' d='M9 9h1m-2 3h1'/%3E%3Cpath stroke='%23b5cdfa' d='M13 9h1'/%3E%3Cpath stroke='%23b5c9f3' d='M14 9h1'/%3E%3Cpath stroke='%239fb5d2' d='M16 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c7f6' d='M2 10h1'/%3E%3Cpath stroke='%23c3d5fd' d='M7 10h1'/%3E%3Cpath stroke='%23bad4fc' d='M9 10h1m-1 1h1'/%3E%3Cpath stroke='%23b2cffb' d='M10 10h1m1 0h1m-2 2h1'/%3E%3Cpath stroke='%23b1cbfa' d='M13 10h1'/%3E%3Cpath stroke='%23b3c8f5' d='M14 10h1m-6 4h2'/%3E%3Cpath stroke='%23adc3f6' d='M2 11h1'/%3E%3Cpath stroke='%23c3d3fd' d='M5 11h1'/%3E%3Cpath stroke='%23c1d5fb' d='M8 11h1'/%3E%3Cpath stroke='%23b7d3fc' d='M10 11h1m-2 1h1'/%3E%3Cpath stroke='%23b3d1fc' d='M11 11h1'/%3E%3Cpath stroke='%23afcefb' d='M12 11h1'/%3E%3Cpath stroke='%23aecafa' d='M13 11h1'/%3E%3Cpath stroke='%23b1c8f3' d='M14 11h1'/%3E%3Cpath stroke='%23acc2f5' d='M2 12h1'/%3E%3Cpath stroke='%23c1d2fb' d='M5 12h1'/%3E%3Cpath stroke='%23bed1fc' d='M6 12h2'/%3E%3Cpath stroke='%23b6d1fb' d='M10 12h1'/%3E%3Cpath stroke='%23afccfb' d='M12 12h1'/%3E%3Cpath stroke='%23adc9f9' d='M13 12h1m-2 1h1'/%3E%3Cpath stroke='%23b1c5f3' d='M14 12h1'/%3E%3Cpath stroke='%23aac0f3' d='M2 13h1'/%3E%3Cpath stroke='%23b7cbf9' d='M3 13h1'/%3E%3Cpath stroke='%23b9cefb' d='M4 13h1'/%3E%3Cpath stroke='%23bbcef9' d='M7 13h1'/%3E%3Cpath stroke='%23b9cffb' d='M8 13h1'/%3E%3Cpath stroke='%23b2cdfb' d='M10 13h1'/%3E%3Cpath stroke='%23b0cbf9' d='M11 13h1'/%3E%3Cpath stroke='%23aec8f7' d='M13 13h1'/%3E%3Cpath stroke='%23b0c5f2' d='M14 13h1'/%3E%3Cpath stroke='%23dbe3f8' d='M2 14h1'/%3E%3Cpath stroke='%23b7c6f1' d='M3 14h1'/%3E%3Cpath stroke='%23b8c9f2' d='M4 14h1m3 0h1'/%3E%3Cpath stroke='%23b2c8f4' d='M11 14h1'/%3E%3Cpath stroke='%23b1c6f3' d='M12 14h1'/%3E%3Cpath stroke='%23b0c4f2' d='M13 14h1'/%3E%3Cpath stroke='%23d9e3f6' d='M14 14h1'/%3E%3Cpath stroke='%23aec0d6' d='M16 14h1'/%3E%3Cpath stroke='%23c3d4e7' d='M1 15h1'/%3E%3Cpath stroke='%23aec4e5' d='M15 15h1'/%3E%3Cpath stroke='%23edf1f3' d='M1 16h1'/%3E%3Cpath stroke='%23aac0e1' d='M2 16h1'/%3E%3Cpath stroke='%2394b1d9' d='M3 16h1'/%3E%3Cpath stroke='%2388a7d8' d='M4 16h1'/%3E%3Cpath stroke='%2383a4d3' d='M5 16h1'/%3E%3Cpath stroke='%237da0d4' d='M6 16h1m3 0h3'/%3E%3Cpath stroke='%237e9fd2' d='M7 16h1'/%3E%3Cpath stroke='%237c9fd3' d='M8 16h2'/%3E%3Cpath stroke='%2382a4d6' d='M13 16h1'/%3E%3Cpath stroke='%2394b0dd' d='M14 16h1'/%3E%3Cpath stroke='%23ecf2f7' d='M15 16h1'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:vertical:end {
	height: 17px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 17 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eeede5' d='M0 0h1m15 0h1M0 1h1M0 2h1M0 3h1M0 4h1M0 5h1M0 6h1M0 7h1M0 8h1M0 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m15 0h1M0 16h1m15 0h1'/%3E%3Cpath stroke='%23fdfdfa' d='M1 0h1'/%3E%3Cpath stroke='%23fff' d='M2 0h14M1 1h1m13 0h1M1 2h1m13 0h1M1 3h1m13 0h1M1 4h1m13 0h1M1 5h1m13 0h1M1 6h1m13 0h1M1 7h1m13 0h1M1 8h1m13 0h1M1 9h1m13 0h1M1 10h1m13 0h1M1 11h1m13 0h1M1 12h1m13 0h1M1 13h1m13 0h1M1 14h1m13 0h1M2 15h13'/%3E%3Cpath stroke='%23e6eefc' d='M2 1h1'/%3E%3Cpath stroke='%23d0dffc' d='M3 1h1M2 2h1'/%3E%3Cpath stroke='%23cad8f9' d='M4 1h1M2 3h1'/%3E%3Cpath stroke='%23c4d2f7' d='M5 1h1'/%3E%3Cpath stroke='%23c0d0f7' d='M6 1h1'/%3E%3Cpath stroke='%23bdcef7' d='M7 1h1M2 6h1'/%3E%3Cpath stroke='%23bbcdf5' d='M8 1h1'/%3E%3Cpath stroke='%23b8cbf6' d='M9 1h1M2 7h1'/%3E%3Cpath stroke='%23b7caf5' d='M10 1h1M2 8h1'/%3E%3Cpath stroke='%23b5c8f7' d='M11 1h1'/%3E%3Cpath stroke='%23b3c7f5' d='M12 1h1'/%3E%3Cpath stroke='%23afc5f4' d='M13 1h1'/%3E%3Cpath stroke='%23dce6f9' d='M14 1h1'/%3E%3Cpath stroke='%23dfe2e1' d='M16 1h1'/%3E%3Cpath stroke='%23e1eafe' d='M3 2h1'/%3E%3Cpath stroke='%23dae6fe' d='M4 2h1M3 3h1'/%3E%3Cpath stroke='%23d4e1fc' d='M5 2h1M3 4h1'/%3E%3Cpath stroke='%23d1e0fd' d='M6 2h1M4 4h1'/%3E%3Cpath stroke='%23d0ddfc' d='M7 2h1M3 5h1'/%3E%3Cpath stroke='%23cedbfd' d='M8 2h1M6 3h1'/%3E%3Cpath stroke='%23cad9fd' d='M9 2h1M7 3h1M5 5h1'/%3E%3Cpath stroke='%23c8d8fb' d='M10 2h1'/%3E%3Cpath stroke='%23c5d6fc' d='M11 2h1m-8 8h3'/%3E%3Cpath stroke='%23c2d3fc' d='M12 2h1m-2 1h1m-9 7h1m0 1h1'/%3E%3Cpath stroke='%23bccefa' d='M13 2h1m-1 2h1m-9 9h2'/%3E%3Cpath stroke='%23b9c9f3' d='M14 2h1M5 14h3'/%3E%3Cpath stroke='%23cfd7dd' d='M16 2h1'/%3E%3Cpath stroke='%23d8e3fc' d='M4 3h1'/%3E%3Cpath stroke='%23d1defd' d='M5 3h1'/%3E%3Cpath stroke='%23c9d8fc' d='M8 3h1M6 4h2M6 6h2M3 7h1'/%3E%3Cpath stroke='%23c5d5fc' d='M9 3h1M3 9h3'/%3E%3Cpath stroke='%23c5d3fc' d='M10 3h1'/%3E%3Cpath stroke='%23bed0fc' d='M12 3h1M9 4h1m-7 7h1m0 1h1'/%3E%3Cpath stroke='%23bccdfa' d='M13 3h1'/%3E%3Cpath stroke='%23baccf4' d='M14 3h1'/%3E%3Cpath stroke='%23bdcbda' d='M16 3h1'/%3E%3Cpath stroke='%23c4d4f7' d='M2 4h1'/%3E%3Cpath stroke='%23cddbfc' d='M5 4h1M3 6h1'/%3E%3Cpath stroke='%23c8d5fb' d='M8 4h1'/%3E%3Cpath stroke='%23bbcefd' d='M10 4h3M9 5h1M8 6h1'/%3E%3Cpath stroke='%23bcccf3' d='M14 4h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c2d5' d='M16 4h1'/%3E%3Cpath stroke='%23bed0f8' d='M2 5h1'/%3E%3Cpath stroke='%23ceddfd' d='M4 5h1'/%3E%3Cpath stroke='%23c8d6fb' d='M6 5h3M3 8h2'/%3E%3Cpath stroke='%23bacdfc' d='M10 5h1m1 0h2M3 12h1'/%3E%3Cpath stroke='%23b9cdfb' d='M11 5h1M9 6h2m1 0h2m-1 1h1'/%3E%3Cpath stroke='%23a8bbd4' d='M16 5h1'/%3E%3Cpath stroke='%23cddafc' d='M4 6h1'/%3E%3Cpath stroke='%234d6185' d='M5 6h1m5 0h1M4 7h3m3 0h3M5 8h3m1 0h3M6 9h5m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%23a4b8d3' d='M16 6h1'/%3E%3Cpath stroke='%23c1d3fb' d='M7 7h2M8 8h1'/%3E%3Cpath stroke='%23b6cefb' d='M9 7h1m2 1h1m-2 1h2'/%3E%3Cpath stroke='%23bacbf4' d='M14 7h1'/%3E%3Cpath stroke='%23a0b5d3' d='M16 7h1m-1 1h1m-1 5h1'/%3E%3Cpath stroke='%23b6cdfb' d='M13 8h1m-5 5h1'/%3E%3Cpath stroke='%23b9cbf3' d='M14 8h1'/%3E%3Cpath stroke='%23b4c8f6' d='M2 9h1'/%3E%3Cpath stroke='%23b5cdfa' d='M13 9h1'/%3E%3Cpath stroke='%23b5c9f3' d='M14 9h1'/%3E%3Cpath stroke='%239fb5d2' d='M16 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c7f6' d='M2 10h1'/%3E%3Cpath stroke='%23b2cffb' d='M10 10h3m-2 2h1'/%3E%3Cpath stroke='%23b1cbfa' d='M13 10h1'/%3E%3Cpath stroke='%23b3c8f5' d='M14 10h1m-6 4h2'/%3E%3Cpath stroke='%23adc3f6' d='M2 11h1'/%3E%3Cpath stroke='%23c3d3fd' d='M5 11h1'/%3E%3Cpath stroke='%23c2d5fc' d='M6 11h2'/%3E%3Cpath stroke='%23bad4fc' d='M9 11h1'/%3E%3Cpath stroke='%23b7d3fc' d='M10 11h1m-2 1h1'/%3E%3Cpath stroke='%23b3d1fc' d='M11 11h1'/%3E%3Cpath stroke='%23afcefb' d='M12 11h1'/%3E%3Cpath stroke='%23aecafa' d='M13 11h1'/%3E%3Cpath stroke='%23b1c8f3' d='M14 11h1'/%3E%3Cpath stroke='%23acc2f5' d='M2 12h1'/%3E%3Cpath stroke='%23c1d2fb' d='M5 12h1'/%3E%3Cpath stroke='%23bed1fc' d='M6 12h2'/%3E%3Cpath stroke='%23bdd3fb' d='M8 12h1'/%3E%3Cpath stroke='%23b6d1fb' d='M10 12h1'/%3E%3Cpath stroke='%23afccfb' d='M12 12h1'/%3E%3Cpath stroke='%23adc9f9' d='M13 12h1m-2 1h1'/%3E%3Cpath stroke='%23b1c5f3' d='M14 12h1'/%3E%3Cpath stroke='%23aac0f3' d='M2 13h1'/%3E%3Cpath stroke='%23b7cbf9' d='M3 13h1'/%3E%3Cpath stroke='%23b9cefb' d='M4 13h1'/%3E%3Cpath stroke='%23bbcef9' d='M7 13h1'/%3E%3Cpath stroke='%23b9cffb' d='M8 13h1'/%3E%3Cpath stroke='%23b2cdfb' d='M10 13h1'/%3E%3Cpath stroke='%23b0cbf9' d='M11 13h1'/%3E%3Cpath stroke='%23aec8f7' d='M13 13h1'/%3E%3Cpath stroke='%23b0c5f2' d='M14 13h1'/%3E%3Cpath stroke='%23dbe3f8' d='M2 14h1'/%3E%3Cpath stroke='%23b7c6f1' d='M3 14h1'/%3E%3Cpath stroke='%23b8c9f2' d='M4 14h1m3 0h1'/%3E%3Cpath stroke='%23b2c8f4' d='M11 14h1'/%3E%3Cpath stroke='%23b1c6f3' d='M12 14h1'/%3E%3Cpath stroke='%23b0c4f2' d='M13 14h1'/%3E%3Cpath stroke='%23d9e3f6' d='M14 14h1'/%3E%3Cpath stroke='%23aec0d6' d='M16 14h1'/%3E%3Cpath stroke='%23c3d4e7' d='M1 15h1'/%3E%3Cpath stroke='%23aec4e5' d='M15 15h1'/%3E%3Cpath stroke='%23edf1f3' d='M1 16h1'/%3E%3Cpath stroke='%23aac0e1' d='M2 16h1'/%3E%3Cpath stroke='%2394b1d9' d='M3 16h1'/%3E%3Cpath stroke='%2388a7d8' d='M4 16h1'/%3E%3Cpath stroke='%2383a4d3' d='M5 16h1'/%3E%3Cpath stroke='%237da0d4' d='M6 16h1m3 0h3'/%3E%3Cpath stroke='%237e9fd2' d='M7 16h1'/%3E%3Cpath stroke='%237c9fd3' d='M8 16h2'/%3E%3Cpath stroke='%2382a4d6' d='M13 16h1'/%3E%3Cpath stroke='%2394b0dd' d='M14 16h1'/%3E%3Cpath stroke='%23ecf2f7' d='M15 16h1'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:horizontal:start {
	width: 17px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 17 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eeede5' d='M0 0h17m-1 1h1m-1 14h1m-1 1h1'/%3E%3Cpath stroke='%23fdfdfa' d='M0 1h1'/%3E%3Cpath stroke='%23fff' d='M1 1h15M0 2h1m14 0h1M0 3h1m14 0h1M0 4h1m14 0h1M0 5h1m14 0h1M0 6h1m14 0h1M0 7h1m14 0h1M0 8h1m14 0h1M0 9h1m14 0h1M0 10h1m14 0h1M0 11h1m14 0h1M0 12h1m14 0h1M0 13h1m14 0h1M0 14h1m14 0h1M1 15h14'/%3E%3Cpath stroke='%23e6eefc' d='M1 2h1'/%3E%3Cpath stroke='%23d0dffc' d='M2 2h1M1 3h1'/%3E%3Cpath stroke='%23cad8f9' d='M3 2h1M1 4h1'/%3E%3Cpath stroke='%23c4d2f7' d='M4 2h1'/%3E%3Cpath stroke='%23c0d0f7' d='M5 2h1'/%3E%3Cpath stroke='%23bdcef7' d='M6 2h1M1 7h1'/%3E%3Cpath stroke='%23bbcdf5' d='M7 2h2'/%3E%3Cpath stroke='%23b8cbf6' d='M9 2h1M1 8h1'/%3E%3Cpath stroke='%23b7caf5' d='M10 2h1M1 9h1'/%3E%3Cpath stroke='%23b5c8f7' d='M11 2h1'/%3E%3Cpath stroke='%23b3c7f5' d='M12 2h1'/%3E%3Cpath stroke='%23afc5f4' d='M13 2h1'/%3E%3Cpath stroke='%23dce6f9' d='M14 2h1'/%3E%3Cpath stroke='%23dfe2e1' d='M16 2h1'/%3E%3Cpath stroke='%23e1eafe' d='M2 3h1'/%3E%3Cpath stroke='%23dae6fe' d='M3 3h1M2 4h1'/%3E%3Cpath stroke='%23d4e1fc' d='M4 3h1M2 5h1'/%3E%3Cpath stroke='%23d1e0fd' d='M5 3h1M3 5h1'/%3E%3Cpath stroke='%23d0ddfc' d='M6 3h1M2 6h1'/%3E%3Cpath stroke='%23cedbfd' d='M7 3h1M5 4h1'/%3E%3Cpath stroke='%23cddbfc' d='M8 3h1M4 5h1M2 7h1'/%3E%3Cpath stroke='%23cad9fd' d='M9 3h1M6 4h1M4 6h1'/%3E%3Cpath stroke='%23c8d8fb' d='M10 3h1'/%3E%3Cpath stroke='%23c5d6fc' d='M11 3h1m-9 7h3'/%3E%3Cpath stroke='%23c2d3fc' d='M12 3h1m-2 1h1M2 10h1m0 1h1'/%3E%3Cpath stroke='%23bccefa' d='M13 3h1m-1 2h1M4 13h2'/%3E%3Cpath stroke='%23b9c9f3' d='M14 3h1M4 14h3'/%3E%3Cpath stroke='%23cfd7dd' d='M16 3h1'/%3E%3Cpath stroke='%23d8e3fc' d='M3 4h1'/%3E%3Cpath stroke='%23d1defd' d='M4 4h1'/%3E%3Cpath stroke='%23c9d8fc' d='M7 4h1M5 5h2M4 7h1M2 8h1'/%3E%3Cpath stroke='%234d6185' d='M8 4h1M7 5h3M6 6h3M5 7h3M4 8h3M5 9h3m-2 1h3m-2 1h3m-2 1h1'/%3E%3Cpath stroke='%23c5d5fc' d='M9 4h1'/%3E%3Cpath stroke='%23c5d3fc' d='M10 4h1'/%3E%3Cpath stroke='%23bed0fc' d='M12 4h1M2 11h1m0 1h1'/%3E%3Cpath stroke='%23bccdfa' d='M13 4h1'/%3E%3Cpath stroke='%23baccf4' d='M14 4h1'/%3E%3Cpath stroke='%23bdcbda' d='M16 4h1'/%3E%3Cpath stroke='%23c4d4f7' d='M1 5h1'/%3E%3Cpath stroke='%23bbcefd' d='M10 5h3M9 6h1'/%3E%3Cpath stroke='%23bcccf3' d='M14 5h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c2d5' d='M16 5h1'/%3E%3Cpath stroke='%23bed0f8' d='M1 6h1'/%3E%3Cpath stroke='%23ceddfd' d='M3 6h1'/%3E%3Cpath stroke='%23c8d6fb' d='M5 6h1M2 9h3'/%3E%3Cpath stroke='%23bacdfc' d='M10 6h1m1 0h2M2 12h1'/%3E%3Cpath stroke='%23b9cdfb' d='M11 6h1M8 7h3m1 0h2m-1 1h1'/%3E%3Cpath stroke='%23a8bbd4' d='M16 6h1'/%3E%3Cpath stroke='%23cddafc' d='M3 7h1'/%3E%3Cpath stroke='%23b7cdfc' d='M11 7h1m0 1h1'/%3E%3Cpath stroke='%23a4b8d3' d='M16 7h1'/%3E%3Cpath stroke='%23cad8fd' d='M3 8h1'/%3E%3Cpath stroke='%23c1d3fb' d='M7 8h2'/%3E%3Cpath stroke='%23b6cefb' d='M9 8h3M9 9h4'/%3E%3Cpath stroke='%23bacbf4' d='M14 8h1'/%3E%3Cpath stroke='%23a0b5d3' d='M16 8h1m-1 1h1m-1 4h1'/%3E%3Cpath stroke='%23bdd3fb' d='M8 9h1m-2 3h1'/%3E%3Cpath stroke='%23b6cdfb' d='M13 9h1m-5 4h1'/%3E%3Cpath stroke='%23b9cbf3' d='M14 9h1'/%3E%3Cpath stroke='%23b1c7f6' d='M1 10h1'/%3E%3Cpath stroke='%23bad4fc' d='M9 10h1'/%3E%3Cpath stroke='%23b2cffb' d='M10 10h3m-2 2h1'/%3E%3Cpath stroke='%23b1cbfa' d='M13 10h1'/%3E%3Cpath stroke='%23b3c8f5' d='M14 10h1m-6 4h2'/%3E%3Cpath stroke='%239fb5d2' d='M16 10h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23adc3f6' d='M1 11h1'/%3E%3Cpath stroke='%23c3d3fd' d='M4 11h1'/%3E%3Cpath stroke='%23c2d5fc' d='M5 11h2'/%3E%3Cpath stroke='%23b7d3fc' d='M10 11h1m-2 1h1'/%3E%3Cpath stroke='%23b3d1fc' d='M11 11h1'/%3E%3Cpath stroke='%23afcefb' d='M12 11h1'/%3E%3Cpath stroke='%23aecafa' d='M13 11h1'/%3E%3Cpath stroke='%23b1c8f3' d='M14 11h1'/%3E%3Cpath stroke='%23acc2f5' d='M1 12h1'/%3E%3Cpath stroke='%23c1d2fb' d='M4 12h1'/%3E%3Cpath stroke='%23bed1fc' d='M5 12h2'/%3E%3Cpath stroke='%23b6d1fb' d='M10 12h1'/%3E%3Cpath stroke='%23afccfb' d='M12 12h1'/%3E%3Cpath stroke='%23adc9f9' d='M13 12h1m-2 1h1'/%3E%3Cpath stroke='%23b1c5f3' d='M14 12h1'/%3E%3Cpath stroke='%23aac0f3' d='M1 13h1'/%3E%3Cpath stroke='%23b7cbf9' d='M2 13h1'/%3E%3Cpath stroke='%23b9cefb' d='M3 13h1'/%3E%3Cpath stroke='%23bbcef9' d='M6 13h1'/%3E%3Cpath stroke='%23b9cffb' d='M7 13h1'/%3E%3Cpath stroke='%23b8cffa' d='M8 13h1'/%3E%3Cpath stroke='%23b2cdfb' d='M10 13h1'/%3E%3Cpath stroke='%23b0cbf9' d='M11 13h1'/%3E%3Cpath stroke='%23aec8f7' d='M13 13h1'/%3E%3Cpath stroke='%23b0c5f2' d='M14 13h1'/%3E%3Cpath stroke='%23dbe3f8' d='M1 14h1'/%3E%3Cpath stroke='%23b7c6f1' d='M2 14h1'/%3E%3Cpath stroke='%23b8c9f2' d='M3 14h1m3 0h2'/%3E%3Cpath stroke='%23b2c8f4' d='M11 14h1'/%3E%3Cpath stroke='%23b1c6f3' d='M12 14h1'/%3E%3Cpath stroke='%23b0c4f2' d='M13 14h1'/%3E%3Cpath stroke='%23d9e3f6' d='M14 14h1'/%3E%3Cpath stroke='%23aec0d6' d='M16 14h1'/%3E%3Cpath stroke='%23c3d4e7' d='M0 15h1'/%3E%3Cpath stroke='%23aec4e5' d='M15 15h1'/%3E%3Cpath stroke='%23edf1f3' d='M0 16h1'/%3E%3Cpath stroke='%23aac0e1' d='M1 16h1'/%3E%3Cpath stroke='%2394b1d9' d='M2 16h1'/%3E%3Cpath stroke='%2388a7d8' d='M3 16h1'/%3E%3Cpath stroke='%2383a4d3' d='M4 16h1'/%3E%3Cpath stroke='%237da0d4' d='M5 16h1m4 0h3'/%3E%3Cpath stroke='%237e9fd2' d='M6 16h1'/%3E%3Cpath stroke='%237c9fd3' d='M7 16h3'/%3E%3Cpath stroke='%2382a4d6' d='M13 16h1'/%3E%3Cpath stroke='%2394b0dd' d='M14 16h1'/%3E%3Cpath stroke='%23ecf2f7' d='M15 16h1'/%3E%3C/svg%3E")
}

.wbox ::-webkit-scrollbar-button:horizontal:end {
	width: 17px;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 17 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23eeede5' d='M0 0h17m-1 1h1m-1 14h1m-1 1h1'/%3E%3Cpath stroke='%23fdfdfa' d='M0 1h1'/%3E%3Cpath stroke='%23fff' d='M1 1h15M0 2h1m14 0h1M0 3h1m14 0h1M0 4h1m14 0h1M0 5h1m14 0h1M0 6h1m14 0h1M0 7h1m14 0h1M0 8h1m14 0h1M0 9h1m14 0h1M0 10h1m14 0h1M0 11h1m14 0h1M0 12h1m14 0h1M0 13h1m14 0h1M0 14h1m14 0h1M1 15h14'/%3E%3Cpath stroke='%23e6eefc' d='M1 2h1'/%3E%3Cpath stroke='%23d0dffc' d='M2 2h1M1 3h1'/%3E%3Cpath stroke='%23cad8f9' d='M3 2h1M1 4h1'/%3E%3Cpath stroke='%23c4d2f7' d='M4 2h1'/%3E%3Cpath stroke='%23c0d0f7' d='M5 2h1'/%3E%3Cpath stroke='%23bdcef7' d='M6 2h1M1 7h1'/%3E%3Cpath stroke='%23bbcdf5' d='M7 2h2'/%3E%3Cpath stroke='%23b8cbf6' d='M9 2h1M1 8h1'/%3E%3Cpath stroke='%23b7caf5' d='M10 2h1'/%3E%3Cpath stroke='%23b5c8f7' d='M11 2h1'/%3E%3Cpath stroke='%23b3c7f5' d='M12 2h1'/%3E%3Cpath stroke='%23afc5f4' d='M13 2h1'/%3E%3Cpath stroke='%23dce6f9' d='M14 2h1'/%3E%3Cpath stroke='%23dfe2e1' d='M16 2h1'/%3E%3Cpath stroke='%23e1eafe' d='M2 3h1'/%3E%3Cpath stroke='%23dae6fe' d='M3 3h1M2 4h1'/%3E%3Cpath stroke='%23d4e1fc' d='M4 3h1M2 5h1'/%3E%3Cpath stroke='%23d1e0fd' d='M5 3h1M3 5h1'/%3E%3Cpath stroke='%23d0ddfc' d='M6 3h1M2 6h1'/%3E%3Cpath stroke='%23cedbfd' d='M7 3h1M5 4h1'/%3E%3Cpath stroke='%23cddbfc' d='M8 3h1M4 5h1M2 7h1'/%3E%3Cpath stroke='%23cad9fd' d='M9 3h1M6 4h1M4 6h1'/%3E%3Cpath stroke='%23c8d8fb' d='M10 3h1'/%3E%3Cpath stroke='%23c5d6fc' d='M11 3h1m-9 7h3'/%3E%3Cpath stroke='%23c2d3fc' d='M12 3h1m-2 1h1M2 10h1m0 1h1'/%3E%3Cpath stroke='%23bccefa' d='M13 3h1m-1 2h1M4 13h2'/%3E%3Cpath stroke='%23b9c9f3' d='M14 3h1M4 14h3'/%3E%3Cpath stroke='%23cfd7dd' d='M16 3h1'/%3E%3Cpath stroke='%23d8e3fc' d='M3 4h1'/%3E%3Cpath stroke='%23d1defd' d='M4 4h1'/%3E%3Cpath stroke='%234d6185' d='M7 4h1M6 5h3M7 6h3M8 7h3M9 8h3M8 9h3m-4 1h3m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%23c8d6fb' d='M8 4h1M5 6h2'/%3E%3Cpath stroke='%23c5d5fc' d='M9 4h1M2 9h5'/%3E%3Cpath stroke='%23c5d3fc' d='M10 4h1'/%3E%3Cpath stroke='%23bed0fc' d='M12 4h1M9 5h1m-8 6h1m0 1h1'/%3E%3Cpath stroke='%23bccdfa' d='M13 4h1'/%3E%3Cpath stroke='%23baccf4' d='M14 4h1'/%3E%3Cpath stroke='%23bdcbda' d='M16 4h1'/%3E%3Cpath stroke='%23c4d4f7' d='M1 5h1'/%3E%3Cpath stroke='%23c9d8fc' d='M5 5h1M4 7h3M2 8h1'/%3E%3Cpath stroke='%23bbcefd' d='M10 5h3M7 7h1'/%3E%3Cpath stroke='%23bcccf3' d='M14 5h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c2d5' d='M16 5h1'/%3E%3Cpath stroke='%23bed0f8' d='M1 6h1'/%3E%3Cpath stroke='%23ceddfd' d='M3 6h1'/%3E%3Cpath stroke='%23bacdfc' d='M10 6h1m1 0h2M2 12h1'/%3E%3Cpath stroke='%23b9cdfb' d='M11 6h1m0 1h2m-1 1h1'/%3E%3Cpath stroke='%23a8bbd4' d='M16 6h1'/%3E%3Cpath stroke='%23cddafc' d='M3 7h1'/%3E%3Cpath stroke='%23b7cdfc' d='M11 7h1m0 1h1'/%3E%3Cpath stroke='%23a4b8d3' d='M16 7h1'/%3E%3Cpath stroke='%23cad8fd' d='M3 8h3'/%3E%3Cpath stroke='%23c1d3fb' d='M6 8h3'/%3E%3Cpath stroke='%23bacbf4' d='M14 8h1'/%3E%3Cpath stroke='%23a0b5d3' d='M16 8h1m-1 5h1'/%3E%3Cpath stroke='%23b4c8f6' d='M1 9h1'/%3E%3Cpath stroke='%23c2d5fc' d='M7 9h1m-3 2h1'/%3E%3Cpath stroke='%23b6cefb' d='M11 9h2'/%3E%3Cpath stroke='%23b5cdfa' d='M13 9h1'/%3E%3Cpath stroke='%23b5c9f3' d='M14 9h1'/%3E%3Cpath stroke='%239fb5d2' d='M16 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b1c7f6' d='M1 10h1'/%3E%3Cpath stroke='%23c3d5fd' d='M6 10h1'/%3E%3Cpath stroke='%23b2cffb' d='M10 10h3m-2 2h1'/%3E%3Cpath stroke='%23b1cbfa' d='M13 10h1'/%3E%3Cpath stroke='%23b3c8f5' d='M14 10h1m-6 4h2'/%3E%3Cpath stroke='%23adc3f6' d='M1 11h1'/%3E%3Cpath stroke='%23c3d3fd' d='M4 11h1'/%3E%3Cpath stroke='%23bad4fc' d='M9 11h1'/%3E%3Cpath stroke='%23b7d3fc' d='M10 11h1m-2 1h1'/%3E%3Cpath stroke='%23b3d1fc' d='M11 11h1'/%3E%3Cpath stroke='%23afcefb' d='M12 11h1'/%3E%3Cpath stroke='%23aecafa' d='M13 11h1'/%3E%3Cpath stroke='%23b1c8f3' d='M14 11h1'/%3E%3Cpath stroke='%23acc2f5' d='M1 12h1'/%3E%3Cpath stroke='%23c1d2fb' d='M4 12h1'/%3E%3Cpath stroke='%23bed1fc' d='M5 12h2'/%3E%3Cpath stroke='%23bbd3fd' d='M8 12h1'/%3E%3Cpath stroke='%23b6d1fb' d='M10 12h1'/%3E%3Cpath stroke='%23afccfb' d='M12 12h1'/%3E%3Cpath stroke='%23adc9f9' d='M13 12h1m-2 1h1'/%3E%3Cpath stroke='%23b1c5f3' d='M14 12h1'/%3E%3Cpath stroke='%23aac0f3' d='M1 13h1'/%3E%3Cpath stroke='%23b7cbf9' d='M2 13h1'/%3E%3Cpath stroke='%23b9cefb' d='M3 13h1'/%3E%3Cpath stroke='%23bbcef9' d='M6 13h1'/%3E%3Cpath stroke='%23b9cffb' d='M7 13h1'/%3E%3Cpath stroke='%23b8cffa' d='M8 13h1'/%3E%3Cpath stroke='%23b6cdfb' d='M9 13h1'/%3E%3Cpath stroke='%23b2cdfb' d='M10 13h1'/%3E%3Cpath stroke='%23b0cbf9' d='M11 13h1'/%3E%3Cpath stroke='%23aec8f7' d='M13 13h1'/%3E%3Cpath stroke='%23b0c5f2' d='M14 13h1'/%3E%3Cpath stroke='%23dbe3f8' d='M1 14h1'/%3E%3Cpath stroke='%23b7c6f1' d='M2 14h1'/%3E%3Cpath stroke='%23b8c9f2' d='M3 14h1m3 0h2'/%3E%3Cpath stroke='%23b2c8f4' d='M11 14h1'/%3E%3Cpath stroke='%23b1c6f3' d='M12 14h1'/%3E%3Cpath stroke='%23b0c4f2' d='M13 14h1'/%3E%3Cpath stroke='%23d9e3f6' d='M14 14h1'/%3E%3Cpath stroke='%23aec0d6' d='M16 14h1'/%3E%3Cpath stroke='%23c3d4e7' d='M0 15h1'/%3E%3Cpath stroke='%23aec4e5' d='M15 15h1'/%3E%3Cpath stroke='%23edf1f3' d='M0 16h1'/%3E%3Cpath stroke='%23aac0e1' d='M1 16h1'/%3E%3Cpath stroke='%2394b1d9' d='M2 16h1'/%3E%3Cpath stroke='%2388a7d8' d='M3 16h1'/%3E%3Cpath stroke='%2383a4d3' d='M4 16h1'/%3E%3Cpath stroke='%237da0d4' d='M5 16h1m4 0h3'/%3E%3Cpath stroke='%237e9fd2' d='M6 16h1'/%3E%3Cpath stroke='%237c9fd3' d='M7 16h3'/%3E%3Cpath stroke='%2382a4d6' d='M13 16h1'/%3E%3Cpath stroke='%2394b0dd' d='M14 16h1'/%3E%3Cpath stroke='%23ecf2f7' d='M15 16h1'/%3E%3C/svg%3E")
}

.wbox .window {
	box-shadow: inset -1px -1px #00138c, inset 1px 1px #0831d9, inset -2px -2px #001ea0, inset 2px 2px #166aee, inset -3px -3px #003bda, inset 3px 3px #0855dd;
	border-top-left-radius: 8px;
	border-top-right-radius: 8px;
	padding: 0 0 3px;
	-webkit-font-smoothing: antialiased
}

.wbox .title-bar {
	font-family: Trebuchet MS;
	background: linear-gradient(180deg, #0997ff, #0053ee 8%, #0050ee 40%, #06f 88%, #06f 93%, #005bff 95%, #003dd7 96%, #003dd7);
	padding: 3px 5px 3px 3px;
	border-top: 1px solid #0831d9;
	border-left: 1px solid #0831d9;
	border-right: 1px solid #001ea0;
	border-top-left-radius: 8px;
	border-top-right-radius: 7px;
	font-size: 13px;
	text-shadow: 1px 1px #0f1089;
	height: 21px
}

.wbox .title-bar-text {
	padding-left: 3px
}

.wbox .title-bar-controls {
	display: flex
}

.wbox .title-bar-controls button {
	min-width: 21px;
	min-height: 21px;
	margin-left: 2px;
	background-repeat: no-repeat;
	background-position: 50%;
	box-shadow: none;
	background-color: #0050ee;
	transition: background .1s;
	border: none
}

.wbox .title-bar-controls button:active,
.wbox .title-bar-controls button:focus,
.wbox .title-bar-controls button:hover {
	box-shadow: none!important
}

.wbox .title-bar-controls button[aria-label=Minimize] {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%236696eb' d='M1 0h1m17 0h1'/%3E%3Cpath stroke='%23e5edfb' d='M2 0h1'/%3E%3Cpath stroke='%23fff' d='M3 0h16M0 2h1M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m19 0h1M0 6h1m19 0h1M0 7h1m19 0h1M0 8h1m19 0h1M0 9h1m19 0h1M0 10h1m19 0h1M0 11h1m19 0h1M0 12h1m19 0h1M0 13h1m4 0h7m8 0h1M0 14h1m4 0h7m8 0h1M0 15h1m4 0h7m8 0h1M0 16h1m19 0h1M0 17h1m19 0h1m-1 1h1M2 20h16'/%3E%3Cpath stroke='%236693e9' d='M0 1h1m19 0h1'/%3E%3Cpath stroke='%23dce5fd' d='M1 1h1'/%3E%3Cpath stroke='%23739af8' d='M2 1h1'/%3E%3Cpath stroke='%23608cf7' d='M3 1h1M2 8h1'/%3E%3Cpath stroke='%235584f6' d='M4 1h1'/%3E%3Cpath stroke='%234d7ef6' d='M5 1h1M1 6h1m5 4h1'/%3E%3Cpath stroke='%23487af5' d='M6 1h1'/%3E%3Cpath stroke='%234276f5' d='M7 1h1M3 14h1'/%3E%3Cpath stroke='%234478f5' d='M8 1h1m5 3h1M2 12h1'/%3E%3Cpath stroke='%233e73f5' d='M9 1h2'/%3E%3Cpath stroke='%233b71f5' d='M11 1h2'/%3E%3Cpath stroke='%23336cf4' d='M13 1h2'/%3E%3Cpath stroke='%23306af4' d='M15 1h1'/%3E%3Cpath stroke='%232864f4' d='M16 1h1'/%3E%3Cpath stroke='%231f5def' d='M17 1h1'/%3E%3Cpath stroke='%233467e0' d='M18 1h1'/%3E%3Cpath stroke='%23d2dbf2' d='M19 1h1'/%3E%3Cpath stroke='%23769cf8' d='M1 2h1'/%3E%3Cpath stroke='%2390aff9' d='M2 2h1'/%3E%3Cpath stroke='%2394b2f9' d='M3 2h1'/%3E%3Cpath stroke='%2385a7f8' d='M4 2h1'/%3E%3Cpath stroke='%23759cf8' d='M5 2h1'/%3E%3Cpath stroke='%236e97f8' d='M6 2h1M2 6h1'/%3E%3Cpath stroke='%236892f7' d='M7 2h1'/%3E%3Cpath stroke='%236690f7' d='M8 2h1'/%3E%3Cpath stroke='%23628ef7' d='M9 2h1m0 1h1'/%3E%3Cpath stroke='%235f8cf7' d='M10 2h1'/%3E%3Cpath stroke='%235e8bf7' d='M11 2h1'/%3E%3Cpath stroke='%235988f6' d='M12 2h1'/%3E%3Cpath stroke='%235685f6' d='M13 2h1'/%3E%3Cpath stroke='%235082f6' d='M14 2h1'/%3E%3Cpath stroke='%23497cf5' d='M15 2h1'/%3E%3Cpath stroke='%233f75f5' d='M16 2h1m-2 2h1'/%3E%3Cpath stroke='%23326bf2' d='M17 2h1'/%3E%3Cpath stroke='%23235ce3' d='M18 2h1'/%3E%3Cpath stroke='%23305cc5' d='M19 2h1'/%3E%3Cpath stroke='%23e5ecfb' d='M20 2h1'/%3E%3Cpath stroke='%236590f7' d='M1 3h1'/%3E%3Cpath stroke='%2397b4f9' d='M2 3h1'/%3E%3Cpath stroke='%239ab7fa' d='M3 3h1'/%3E%3Cpath stroke='%2389aaf9' d='M4 3h1M2 4h1'/%3E%3Cpath stroke='%237aa0f8' d='M5 3h1'/%3E%3Cpath stroke='%23729af8' d='M6 3h1'/%3E%3Cpath stroke='%236d95f8' d='M7 3h1'/%3E%3Cpath stroke='%236892f8' d='M8 3h1M2 7h1'/%3E%3Cpath stroke='%23658ff7' d='M9 3h1'/%3E%3Cpath stroke='%23618df7' d='M11 3h1'/%3E%3Cpath stroke='%235d8af7' d='M12 3h1M3 9h1'/%3E%3Cpath stroke='%235987f6' d='M13 3h1M2 9h1'/%3E%3Cpath stroke='%235283f6' d='M14 3h1'/%3E%3Cpath stroke='%234c7ef6' d='M15 3h1'/%3E%3Cpath stroke='%234377f5' d='M16 3h1'/%3E%3Cpath stroke='%23376ef2' d='M17 3h1'/%3E%3Cpath stroke='%23285fe3' d='M18 3h1'/%3E%3Cpath stroke='%231546b9' d='M19 3h1'/%3E%3Cpath stroke='%235886f6' d='M1 4h1'/%3E%3Cpath stroke='%238dadf9' d='M3 4h1'/%3E%3Cpath stroke='%237fa3f8' d='M4 4h1'/%3E%3Cpath stroke='%237199f8' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%236a93f8' d='M6 4h1M4 6h1M3 7h1'/%3E%3Cpath stroke='%23648ef7' d='M7 4h1'/%3E%3Cpath stroke='%235e8af7' d='M8 4h1'/%3E%3Cpath stroke='%235986f7' d='M9 4h1M5 9h1m-2 1h1'/%3E%3Cpath stroke='%235482f6' d='M10 4h1'/%3E%3Cpath stroke='%235180f6' d='M11 4h1'/%3E%3Cpath stroke='%234b7cf5' d='M12 4h1'/%3E%3Cpath stroke='%234a7cf5' d='M13 4h1'/%3E%3Cpath stroke='%233a72f4' d='M16 4h1'/%3E%3Cpath stroke='%23346cf2' d='M17 4h1'/%3E%3Cpath stroke='%232a61e3' d='M18 4h1'/%3E%3Cpath stroke='%231848bb' d='M19 4h1'/%3E%3Cpath stroke='%235282f6' d='M1 5h1m4 6h1m-3 1h1'/%3E%3Cpath stroke='%23799ff8' d='M2 5h1'/%3E%3Cpath stroke='%237ca1f8' d='M3 5h1'/%3E%3Cpath stroke='%236791f8' d='M5 5h1'/%3E%3Cpath stroke='%23608bf7' d='M6 5h1M4 8h1'/%3E%3Cpath stroke='%235985f7' d='M7 5h1'/%3E%3Cpath stroke='%235381f6' d='M8 5h1M6 9h1'/%3E%3Cpath stroke='%234d7bf6' d='M9 5h1M8 6h1'/%3E%3Cpath stroke='%234677f5' d='M10 5h1'/%3E%3Cpath stroke='%234173f5' d='M11 5h1'/%3E%3Cpath stroke='%233a6ff4' d='M12 5h1'/%3E%3Cpath stroke='%23386ef4' d='M13 5h1'/%3E%3Cpath stroke='%23346cf4' d='M14 5h1'/%3E%3Cpath stroke='%23326cf4' d='M15 5h1'/%3E%3Cpath stroke='%23316bf4' d='M16 5h1M3 16h1'/%3E%3Cpath stroke='%233069f1' d='M17 5h1'/%3E%3Cpath stroke='%232c62e4' d='M18 5h1'/%3E%3Cpath stroke='%231d4cbc' d='M19 5h1m-1 1h1'/%3E%3Cpath stroke='%237099f8' d='M3 6h1'/%3E%3Cpath stroke='%23628cf8' d='M5 6h1'/%3E%3Cpath stroke='%235b86f7' d='M6 6h1'/%3E%3Cpath stroke='%235480f7' d='M7 6h1'/%3E%3Cpath stroke='%234777f6' d='M9 6h1'/%3E%3Cpath stroke='%234072f5' d='M10 6h1'/%3E%3Cpath stroke='%233a6ff5' d='M11 6h1'/%3E%3Cpath stroke='%23346df4' d='M12 6h1'/%3E%3Cpath stroke='%23306bf4' d='M13 6h1'/%3E%3Cpath stroke='%232d69f4' d='M14 6h1'/%3E%3Cpath stroke='%232c69f5' d='M15 6h1'/%3E%3Cpath stroke='%232d69f5' d='M16 6h1'/%3E%3Cpath stroke='%232e69f2' d='M17 6h1'/%3E%3Cpath stroke='%232c63e5' d='M18 6h1'/%3E%3Cpath stroke='%234679f5' d='M1 7h1M1 8h1'/%3E%3Cpath stroke='%23658ff8' d='M4 7h1'/%3E%3Cpath stroke='%235e89f7' d='M5 7h1'/%3E%3Cpath stroke='%235783f7' d='M6 7h1'/%3E%3Cpath stroke='%23507ef6' d='M7 7h1'/%3E%3Cpath stroke='%234a79f6' d='M8 7h1'/%3E%3Cpath stroke='%234375f5' d='M9 7h1'/%3E%3Cpath stroke='%233d71f5' d='M10 7h1'/%3E%3Cpath stroke='%23366ef4' d='M11 7h1M2 14h1'/%3E%3Cpath stroke='%232f6bf5' d='M12 7h1'/%3E%3Cpath stroke='%232b69f5' d='M13 7h1'/%3E%3Cpath stroke='%232867f5' d='M14 7h1'/%3E%3Cpath stroke='%232766f5' d='M15 7h1'/%3E%3Cpath stroke='%232a68f5' d='M16 7h1'/%3E%3Cpath stroke='%232c69f2' d='M17 7h1'/%3E%3Cpath stroke='%232a62e4' d='M18 7h1'/%3E%3Cpath stroke='%231c4cbd' d='M19 7h1'/%3E%3Cpath stroke='%23628df8' d='M3 8h1'/%3E%3Cpath stroke='%235b87f7' d='M5 8h1'/%3E%3Cpath stroke='%235482f7' d='M6 8h1'/%3E%3Cpath stroke='%234e7cf6' d='M7 8h1'/%3E%3Cpath stroke='%234778f6' d='M8 8h1'/%3E%3Cpath stroke='%234174f5' d='M9 8h1'/%3E%3Cpath stroke='%233a71f5' d='M10 8h1'/%3E%3Cpath stroke='%23346ef4' d='M11 8h1'/%3E%3Cpath stroke='%232d6bf5' d='M12 8h1'/%3E%3Cpath stroke='%232869f5' d='M13 8h1'/%3E%3Cpath stroke='%232467f5' d='M14 8h1'/%3E%3Cpath stroke='%232266f5' d='M15 8h1'/%3E%3Cpath stroke='%232567f5' d='M16 8h1'/%3E%3Cpath stroke='%232968f2' d='M17 8h1'/%3E%3Cpath stroke='%232963e4' d='M18 8h1'/%3E%3Cpath stroke='%231b4bbd' d='M19 8h1'/%3E%3Cpath stroke='%233c72f4' d='M1 9h1'/%3E%3Cpath stroke='%235d89f7' d='M4 9h1'/%3E%3Cpath stroke='%234e7ef6' d='M7 9h1'/%3E%3Cpath stroke='%23477af5' d='M8 9h1'/%3E%3Cpath stroke='%234178f5' d='M9 9h1'/%3E%3Cpath stroke='%233a74f5' d='M10 9h1'/%3E%3Cpath stroke='%233472f5' d='M11 9h1'/%3E%3Cpath stroke='%232c6ff5' d='M12 9h1'/%3E%3Cpath stroke='%23276cf5' d='M13 9h1'/%3E%3Cpath stroke='%23236af6' d='M14 9h1'/%3E%3Cpath stroke='%232069f6' d='M15 9h1'/%3E%3Cpath stroke='%232268f5' d='M16 9h1'/%3E%3Cpath stroke='%232569f2' d='M17 9h1'/%3E%3Cpath stroke='%232562e6' d='M18 9h1'/%3E%3Cpath stroke='%23194bbe' d='M19 9h1'/%3E%3Cpath stroke='%23376ef4' d='M1 10h1'/%3E%3Cpath stroke='%235181f6' d='M2 10h1'/%3E%3Cpath stroke='%235785f7' d='M3 10h1m1 0h1'/%3E%3Cpath stroke='%235281f6' d='M6 10h1'/%3E%3Cpath stroke='%23477bf6' d='M8 10h1'/%3E%3Cpath stroke='%234179f6' d='M9 10h1'/%3E%3Cpath stroke='%233b77f5' d='M10 10h1'/%3E%3Cpath stroke='%233474f5' d='M11 10h1'/%3E%3Cpath stroke='%232c72f6' d='M12 10h1'/%3E%3Cpath stroke='%23266ff6' d='M13 10h1'/%3E%3Cpath stroke='%23226df6' d='M14 10h1'/%3E%3Cpath stroke='%231e6bf6' d='M15 10h1'/%3E%3Cpath stroke='%231f6af6' d='M16 10h1'/%3E%3Cpath stroke='%23216af3' d='M17 10h1'/%3E%3Cpath stroke='%232162e6' d='M18 10h1'/%3E%3Cpath stroke='%231649be' d='M19 10h1'/%3E%3Cpath stroke='%23326bf4' d='M1 11h1'/%3E%3Cpath stroke='%234b7df5' d='M2 11h1'/%3E%3Cpath stroke='%235483f6' d='M3 11h1'/%3E%3Cpath stroke='%235684f7' d='M4 11h1'/%3E%3Cpath stroke='%235583f7' d='M5 11h1'/%3E%3Cpath stroke='%234d80f6' d='M7 11h1'/%3E%3Cpath stroke='%23487df6' d='M8 11h1'/%3E%3Cpath stroke='%23427cf6' d='M9 11h1'/%3E%3Cpath stroke='%233c7af6' d='M10 11h1'/%3E%3Cpath stroke='%233478f6' d='M11 11h1'/%3E%3Cpath stroke='%232d76f6' d='M12 11h1'/%3E%3Cpath stroke='%232673f7' d='M13 11h1'/%3E%3Cpath stroke='%232171f7' d='M14 11h1'/%3E%3Cpath stroke='%231c6ff6' d='M15 11h1'/%3E%3Cpath stroke='%231c6df6' d='M16 11h1'/%3E%3Cpath stroke='%231c6af4' d='M17 11h1'/%3E%3Cpath stroke='%231c61e6' d='M18 11h1'/%3E%3Cpath stroke='%231248bf' d='M19 11h1'/%3E%3Cpath stroke='%232b66f4' d='M1 12h1'/%3E%3Cpath stroke='%234e7ff6' d='M3 12h1'/%3E%3Cpath stroke='%235383f6' d='M5 12h1'/%3E%3Cpath stroke='%235182f6' d='M6 12h1'/%3E%3Cpath stroke='%234d81f7' d='M7 12h1'/%3E%3Cpath stroke='%23487ff6' d='M8 12h1'/%3E%3Cpath stroke='%23437ff6' d='M9 12h1'/%3E%3Cpath stroke='%233d7ef6' d='M10 12h1'/%3E%3Cpath stroke='%23357cf6' d='M11 12h1'/%3E%3Cpath stroke='%232d7af7' d='M12 12h1'/%3E%3Cpath stroke='%232677f7' d='M13 12h1'/%3E%3Cpath stroke='%232174f7' d='M14 12h1'/%3E%3Cpath stroke='%231b71f7' d='M15 12h1'/%3E%3Cpath stroke='%23186ef7' d='M16 12h1'/%3E%3Cpath stroke='%23186af4' d='M17 12h1'/%3E%3Cpath stroke='%23165fe7' d='M18 12h1'/%3E%3Cpath stroke='%230f47c0' d='M19 12h1'/%3E%3Cpath stroke='%232562f3' d='M1 13h1'/%3E%3Cpath stroke='%233d73f4' d='M2 13h1'/%3E%3Cpath stroke='%23487bf5' d='M3 13h1'/%3E%3Cpath stroke='%234e80f6' d='M4 13h1'/%3E%3Cpath stroke='%232d7cf7' d='M12 13h1'/%3E%3Cpath stroke='%232679f8' d='M13 13h1'/%3E%3Cpath stroke='%232077f7' d='M14 13h1'/%3E%3Cpath stroke='%231973f7' d='M15 13h1'/%3E%3Cpath stroke='%23166ff7' d='M16 13h1'/%3E%3Cpath stroke='%231369f4' d='M17 13h1'/%3E%3Cpath stroke='%23105de8' d='M18 13h1'/%3E%3Cpath stroke='%230a44bf' d='M19 13h1'/%3E%3Cpath stroke='%231e5df3' d='M1 14h1'/%3E%3Cpath stroke='%23497bf5' d='M4 14h1'/%3E%3Cpath stroke='%232d7df7' d='M12 14h1'/%3E%3Cpath stroke='%23257af8' d='M13 14h1'/%3E%3Cpath stroke='%231e77f8' d='M14 14h1'/%3E%3Cpath stroke='%231773f8' d='M15 14h1'/%3E%3Cpath stroke='%23116df7' d='M16 14h1'/%3E%3Cpath stroke='%230d66f4' d='M17 14h1m-3 3h1'/%3E%3Cpath stroke='%230b59e7' d='M18 14h1'/%3E%3Cpath stroke='%230641c0' d='M19 14h1m-6 5h1'/%3E%3Cpath stroke='%231859f3' d='M1 15h1'/%3E%3Cpath stroke='%232e68f4' d='M2 15h1'/%3E%3Cpath stroke='%233a71f4' d='M3 15h1'/%3E%3Cpath stroke='%234277f5' d='M4 15h1'/%3E%3Cpath stroke='%232a7cf8' d='M12 15h1'/%3E%3Cpath stroke='%23247af8' d='M13 15h1'/%3E%3Cpath stroke='%231d77f8' d='M14 15h1'/%3E%3Cpath stroke='%231573f8' d='M15 15h1'/%3E%3Cpath stroke='%230e6cf8' d='M16 15h1'/%3E%3Cpath stroke='%230963f4' d='M17 15h1'/%3E%3Cpath stroke='%230556e7' d='M18 15h1'/%3E%3Cpath stroke='%23023fbf' d='M19 15h1'/%3E%3Cpath stroke='%231456f3' d='M1 16h1'/%3E%3Cpath stroke='%232562f4' d='M2 16h1'/%3E%3Cpath stroke='%233971f4' d='M4 16h1'/%3E%3Cpath stroke='%233d74f5' d='M5 16h1'/%3E%3Cpath stroke='%233d74f6' d='M6 16h1'/%3E%3Cpath stroke='%233b75f5' d='M7 16h1'/%3E%3Cpath stroke='%233976f5' d='M8 16h1'/%3E%3Cpath stroke='%233777f5' d='M9 16h1'/%3E%3Cpath stroke='%233278f6' d='M10 16h1'/%3E%3Cpath stroke='%232c78f7' d='M11 16h1'/%3E%3Cpath stroke='%232577f7' d='M12 16h1'/%3E%3Cpath stroke='%231f76f7' d='M13 16h1'/%3E%3Cpath stroke='%231972f7' d='M14 16h1'/%3E%3Cpath stroke='%23116ef8' d='M15 16h1'/%3E%3Cpath stroke='%230b68f7' d='M16 16h1'/%3E%3Cpath stroke='%230560f4' d='M17 16h1'/%3E%3Cpath stroke='%230253e6' d='M18 16h1'/%3E%3Cpath stroke='%23013dbe' d='M19 16h1'/%3E%3Cpath stroke='%230e50ed' d='M1 17h1'/%3E%3Cpath stroke='%231c5bef' d='M2 17h1'/%3E%3Cpath stroke='%232863f0' d='M3 17h1'/%3E%3Cpath stroke='%232f68f0' d='M4 17h1'/%3E%3Cpath stroke='%23336bf1' d='M5 17h1'/%3E%3Cpath stroke='%23346cf1' d='M6 17h1'/%3E%3Cpath stroke='%23316cf2' d='M7 17h1'/%3E%3Cpath stroke='%23316df2' d='M8 17h1'/%3E%3Cpath stroke='%232e6ff2' d='M9 17h1'/%3E%3Cpath stroke='%232a70f2' d='M10 17h1'/%3E%3Cpath stroke='%232570f3' d='M11 17h1'/%3E%3Cpath stroke='%231f6ff3' d='M12 17h1'/%3E%3Cpath stroke='%23196df4' d='M13 17h1'/%3E%3Cpath stroke='%23136af4' d='M14 17h1'/%3E%3Cpath stroke='%230760f3' d='M16 17h1'/%3E%3Cpath stroke='%23025af0' d='M17 17h1'/%3E%3Cpath stroke='%23004de2' d='M18 17h1'/%3E%3Cpath stroke='%23003ab9' d='M19 17h1'/%3E%3Cpath stroke='%23e5eefd' d='M0 18h1'/%3E%3Cpath stroke='%23285edf' d='M1 18h1'/%3E%3Cpath stroke='%23134fdf' d='M2 18h1'/%3E%3Cpath stroke='%231b55df' d='M3 18h1'/%3E%3Cpath stroke='%23215ae2' d='M4 18h1'/%3E%3Cpath stroke='%23255ce1' d='M5 18h1'/%3E%3Cpath stroke='%23265de0' d='M6 18h1'/%3E%3Cpath stroke='%23245ce1' d='M7 18h1'/%3E%3Cpath stroke='%23235ee2' d='M8 18h1'/%3E%3Cpath stroke='%23215ee2' d='M9 18h1'/%3E%3Cpath stroke='%231e5ee2' d='M10 18h1'/%3E%3Cpath stroke='%231b5fe5' d='M11 18h1'/%3E%3Cpath stroke='%23165ee5' d='M12 18h1'/%3E%3Cpath stroke='%23135de6' d='M13 18h1'/%3E%3Cpath stroke='%230e5be5' d='M14 18h1'/%3E%3Cpath stroke='%230958e6' d='M15 18h1'/%3E%3Cpath stroke='%230454e6' d='M16 18h1'/%3E%3Cpath stroke='%23014ee2' d='M17 18h1'/%3E%3Cpath stroke='%230045d3' d='M18 18h1'/%3E%3Cpath stroke='%231f4eb8' d='M19 18h1'/%3E%3Cpath stroke='%23679ef6' d='M0 19h1m19 0h1'/%3E%3Cpath stroke='%23d0daf1' d='M1 19h1'/%3E%3Cpath stroke='%232856c3' d='M2 19h1'/%3E%3Cpath stroke='%230d3fb6' d='M3 19h1'/%3E%3Cpath stroke='%231144bd' d='M4 19h1'/%3E%3Cpath stroke='%231245bb' d='M5 19h1'/%3E%3Cpath stroke='%231445b9' d='M6 19h1'/%3E%3Cpath stroke='%231244b9' d='M7 19h1'/%3E%3Cpath stroke='%231345bc' d='M8 19h1'/%3E%3Cpath stroke='%231346bd' d='M9 19h1'/%3E%3Cpath stroke='%231045be' d='M10 19h1'/%3E%3Cpath stroke='%230d45c0' d='M11 19h1'/%3E%3Cpath stroke='%230a45c1' d='M12 19h1'/%3E%3Cpath stroke='%230844c3' d='M13 19h1'/%3E%3Cpath stroke='%23033fc0' d='M15 19h1'/%3E%3Cpath stroke='%23013fc3' d='M16 19h1'/%3E%3Cpath stroke='%23003bbe' d='M17 19h1'/%3E%3Cpath stroke='%231f4eb9' d='M18 19h1'/%3E%3Cpath stroke='%23cfd8ed' d='M19 19h1'/%3E%3Cpath stroke='%23669bf5' d='M1 20h1m17 0h1'/%3E%3Cpath stroke='%23e5edfd' d='M18 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Minimize]:hover {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%2393b1ed' d='M1 0h1m17 0h1'/%3E%3Cpath stroke='%23f3f6fd' d='M2 0h1m17 2h1M0 18h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m19 0h1M0 6h1m19 0h1M0 7h1m19 0h1M0 8h1m19 0h1M0 9h1m19 0h1M0 10h1m19 0h1M0 11h1m19 0h1M0 12h1m19 0h1M0 13h1m4 0h7m8 0h1M0 14h1m4 0h7m8 0h1M0 15h1m4 0h7m8 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h11'/%3E%3Cpath stroke='%23f5f7fd' d='M18 0h1M0 2h1m19 16h1M2 20h1'/%3E%3Cpath stroke='%2393b0ec' d='M0 1h1m19 0h1'/%3E%3Cpath stroke='%23dce7ff' d='M1 1h1'/%3E%3Cpath stroke='%2372a1ff' d='M2 1h1m4 3h1M5 6h1'/%3E%3Cpath stroke='%236a9cff' d='M3 1h1'/%3E%3Cpath stroke='%235f94ff' d='M4 1h1M4 11h2'/%3E%3Cpath stroke='%23558eff' d='M5 1h1M3 12h1'/%3E%3Cpath stroke='%23518bff' d='M6 1h1m3 4h1'/%3E%3Cpath stroke='%234a86ff' d='M7 1h1'/%3E%3Cpath stroke='%234b87ff' d='M8 1h1m2 4h1M2 12h1'/%3E%3Cpath stroke='%234684ff' d='M9 1h2'/%3E%3Cpath stroke='%234482ff' d='M11 1h1m4 1h1m-5 3h1M1 9h1m0 4h1'/%3E%3Cpath stroke='%234080ff' d='M12 1h1M3 15h1'/%3E%3Cpath stroke='%233b7cff' d='M13 1h1'/%3E%3Cpath stroke='%233a7bff' d='M14 1h1'/%3E%3Cpath stroke='%233678ff' d='M15 1h1'/%3E%3Cpath stroke='%232e73ff' d='M16 1h1'/%3E%3Cpath stroke='%23276cf9' d='M17 1h1'/%3E%3Cpath stroke='%233a73e7' d='M18 1h1'/%3E%3Cpath stroke='%23d3ddf3' d='M19 1h1'/%3E%3Cpath stroke='%2373a1ff' d='M1 2h1'/%3E%3Cpath stroke='%2397b9ff' d='M2 2h1'/%3E%3Cpath stroke='%239cbdff' d='M3 2h1'/%3E%3Cpath stroke='%2390b5ff' d='M4 2h1'/%3E%3Cpath stroke='%2382acff' d='M5 2h1M5 4h1'/%3E%3Cpath stroke='%237ba7ff' d='M6 2h1M2 6h1'/%3E%3Cpath stroke='%2375a3ff' d='M7 2h1'/%3E%3Cpath stroke='%236f9fff' d='M8 2h1M3 8h1'/%3E%3Cpath stroke='%236c9dff' d='M9 2h1M1 3h1'/%3E%3Cpath stroke='%23689bff' d='M10 2h1M5 8h1M3 9h1'/%3E%3Cpath stroke='%236599ff' d='M11 2h1m0 1h1M5 9h1'/%3E%3Cpath stroke='%236095ff' d='M12 2h1m0 1h1M8 5h1'/%3E%3Cpath stroke='%235d93ff' d='M13 2h1'/%3E%3Cpath stroke='%23568eff' d='M14 2h1'/%3E%3Cpath stroke='%234f8aff' d='M15 2h1M3 13h1m0 1h1'/%3E%3Cpath stroke='%233878fb' d='M17 2h1'/%3E%3Cpath stroke='%232969eb' d='M18 2h1'/%3E%3Cpath stroke='%233566cb' d='M19 2h1'/%3E%3Cpath stroke='%239ebeff' d='M2 3h1'/%3E%3Cpath stroke='%23a4c2ff' d='M3 3h1'/%3E%3Cpath stroke='%2399baff' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%238ab0ff' d='M5 3h1'/%3E%3Cpath stroke='%2382abff' d='M6 3h1'/%3E%3Cpath stroke='%2379a6ff' d='M7 3h1'/%3E%3Cpath stroke='%2374a3ff' d='M8 3h1'/%3E%3Cpath stroke='%2371a0ff' d='M9 3h1'/%3E%3Cpath stroke='%236d9eff' d='M10 3h1M5 7h1M4 8h1'/%3E%3Cpath stroke='%23699bff' d='M11 3h1'/%3E%3Cpath stroke='%235a91ff' d='M14 3h1M2 10h1m1 2h1'/%3E%3Cpath stroke='%23538cff' d='M15 3h1M2 11h1'/%3E%3Cpath stroke='%234986ff' d='M16 3h1'/%3E%3Cpath stroke='%233d7cfc' d='M17 3h1'/%3E%3Cpath stroke='%232e6cea' d='M18 3h1'/%3E%3Cpath stroke='%231b52c2' d='M19 3h1'/%3E%3Cpath stroke='%236296ff' d='M1 4h1'/%3E%3Cpath stroke='%2391b5ff' d='M2 4h1'/%3E%3Cpath stroke='%238fb4ff' d='M4 4h1'/%3E%3Cpath stroke='%237aa6ff' d='M6 4h1'/%3E%3Cpath stroke='%236b9dff' d='M8 4h1'/%3E%3Cpath stroke='%236598ff' d='M9 4h1'/%3E%3Cpath stroke='%235f95ff' d='M10 4h1M7 7h1m-2 3h1'/%3E%3Cpath stroke='%235b92ff' d='M11 4h1'/%3E%3Cpath stroke='%23548dff' d='M12 4h1M1 6h1m2 7h1'/%3E%3Cpath stroke='%23528cff' d='M13 4h1'/%3E%3Cpath stroke='%234c88ff' d='M14 4h1m-5 2h1'/%3E%3Cpath stroke='%234785ff' d='M15 4h1'/%3E%3Cpath stroke='%234280ff' d='M16 4h1'/%3E%3Cpath stroke='%233b7afb' d='M17 4h1'/%3E%3Cpath stroke='%23316fec' d='M18 4h1'/%3E%3Cpath stroke='%231f55c3' d='M19 4h1'/%3E%3Cpath stroke='%235990ff' d='M1 5h1m7 0h1'/%3E%3Cpath stroke='%2385adff' d='M2 5h1'/%3E%3Cpath stroke='%238bb1ff' d='M3 5h1'/%3E%3Cpath stroke='%2384acff' d='M4 5h1'/%3E%3Cpath stroke='%2378a5ff' d='M5 5h1'/%3E%3Cpath stroke='%2370a0ff' d='M6 5h1'/%3E%3Cpath stroke='%23679aff' d='M7 5h1'/%3E%3Cpath stroke='%234180ff' d='M13 5h1'/%3E%3Cpath stroke='%233d7eff' d='M14 5h1'/%3E%3Cpath stroke='%233b7bff' d='M15 5h1'/%3E%3Cpath stroke='%23397aff' d='M16 5h1M1 11h1'/%3E%3Cpath stroke='%233979fc' d='M17 5h1'/%3E%3Cpath stroke='%233370ec' d='M18 5h1m-1 1h1'/%3E%3Cpath stroke='%232357c3' d='M19 5h1'/%3E%3Cpath stroke='%2381aaff' d='M3 6h1'/%3E%3Cpath stroke='%237aa7ff' d='M4 6h1'/%3E%3Cpath stroke='%236b9cff' d='M6 6h1'/%3E%3Cpath stroke='%236297ff' d='M7 6h1m-3 4h1'/%3E%3Cpath stroke='%235c93ff' d='M8 6h1M7 8h1m-2 3h1'/%3E%3Cpath stroke='%23548eff' d='M9 6h1'/%3E%3Cpath stroke='%234483ff' d='M11 6h1M5 16h1'/%3E%3Cpath stroke='%233d7fff' d='M12 6h1'/%3E%3Cpath stroke='%23387bff' d='M13 6h1'/%3E%3Cpath stroke='%233679ff' d='M14 6h1m1 0h1'/%3E%3Cpath stroke='%233579ff' d='M15 6h1'/%3E%3Cpath stroke='%233879fc' d='M17 6h1'/%3E%3Cpath stroke='%232358c5' d='M19 6h1'/%3E%3Cpath stroke='%234e89ff' d='M1 7h1'/%3E%3Cpath stroke='%2371a1ff' d='M2 7h1'/%3E%3Cpath stroke='%2377a5ff' d='M3 7h1'/%3E%3Cpath stroke='%2374a2ff' d='M4 7h1'/%3E%3Cpath stroke='%23669aff' d='M6 7h1'/%3E%3Cpath stroke='%235890ff' d='M8 7h1'/%3E%3Cpath stroke='%23508dff' d='M9 7h1'/%3E%3Cpath stroke='%234989ff' d='M10 7h1'/%3E%3Cpath stroke='%234183ff' d='M11 7h1'/%3E%3Cpath stroke='%233a7fff' d='M12 7h1'/%3E%3Cpath stroke='%23357bff' d='M13 7h1'/%3E%3Cpath stroke='%23317aff' d='M14 7h2'/%3E%3Cpath stroke='%23337aff' d='M16 7h1'/%3E%3Cpath stroke='%23367bfc' d='M17 7h1'/%3E%3Cpath stroke='%233372ed' d='M18 7h1'/%3E%3Cpath stroke='%232359c5' d='M19 7h1'/%3E%3Cpath stroke='%234d88ff' d='M1 8h1'/%3E%3Cpath stroke='%23699cff' d='M2 8h1'/%3E%3Cpath stroke='%236398ff' d='M6 8h1'/%3E%3Cpath stroke='%23548fff' d='M8 8h1'/%3E%3Cpath stroke='%234d8cff' d='M9 8h1'/%3E%3Cpath stroke='%23468aff' d='M10 8h1'/%3E%3Cpath stroke='%233f86ff' d='M11 8h1'/%3E%3Cpath stroke='%233983ff' d='M12 8h1'/%3E%3Cpath stroke='%233380ff' d='M13 8h1'/%3E%3Cpath stroke='%232f7fff' d='M14 8h2'/%3E%3Cpath stroke='%233280ff' d='M16 8h1'/%3E%3Cpath stroke='%233580fc' d='M17 8h1'/%3E%3Cpath stroke='%233276ed' d='M18 8h1'/%3E%3Cpath stroke='%23235ac6' d='M19 8h1'/%3E%3Cpath stroke='%236196ff' d='M2 9h1m3 0h1m-4 1h1'/%3E%3Cpath stroke='%23689aff' d='M4 9h1'/%3E%3Cpath stroke='%235b93ff' d='M7 9h1'/%3E%3Cpath stroke='%235491ff' d='M8 9h1'/%3E%3Cpath stroke='%234f90ff' d='M9 9h1'/%3E%3Cpath stroke='%234890ff' d='M10 9h1'/%3E%3Cpath stroke='%23428eff' d='M11 9h1'/%3E%3Cpath stroke='%233b8dff' d='M12 9h1'/%3E%3Cpath stroke='%23348aff' d='M13 9h1'/%3E%3Cpath stroke='%233189ff' d='M14 9h1'/%3E%3Cpath stroke='%232f88ff' d='M15 9h1'/%3E%3Cpath stroke='%233188ff' d='M16 9h1'/%3E%3Cpath stroke='%233385fc' d='M17 9h1'/%3E%3Cpath stroke='%233079ed' d='M18 9h1'/%3E%3Cpath stroke='%23215cc8' d='M19 9h1'/%3E%3Cpath stroke='%233f7fff' d='M1 10h1'/%3E%3Cpath stroke='%236397ff' d='M4 10h1'/%3E%3Cpath stroke='%235993ff' d='M7 10h1'/%3E%3Cpath stroke='%235492ff' d='M8 10h1'/%3E%3Cpath stroke='%235093ff' d='M9 10h1'/%3E%3Cpath stroke='%234a95ff' d='M10 10h1'/%3E%3Cpath stroke='%234496ff' d='M11 10h1'/%3E%3Cpath stroke='%233d96ff' d='M12 10h1'/%3E%3Cpath stroke='%233694ff' d='M13 10h1'/%3E%3Cpath stroke='%233193ff' d='M14 10h1'/%3E%3Cpath stroke='%232f92ff' d='M15 10h1'/%3E%3Cpath stroke='%233090ff' d='M16 10h1'/%3E%3Cpath stroke='%23328cfc' d='M17 10h1'/%3E%3Cpath stroke='%232e7def' d='M18 10h1'/%3E%3Cpath stroke='%231e5dc9' d='M19 10h1'/%3E%3Cpath stroke='%235c92ff' d='M3 11h1m1 1h1'/%3E%3Cpath stroke='%235792ff' d='M7 11h1m-1 1h1'/%3E%3Cpath stroke='%235594ff' d='M8 11h1'/%3E%3Cpath stroke='%235298ff' d='M9 11h1'/%3E%3Cpath stroke='%234d9cff' d='M10 11h1'/%3E%3Cpath stroke='%23479eff' d='M11 11h1'/%3E%3Cpath stroke='%23409fff' d='M12 11h1'/%3E%3Cpath stroke='%23379fff' d='M13 11h1'/%3E%3Cpath stroke='%23339dff' d='M14 11h1'/%3E%3Cpath stroke='%232f9bff' d='M15 11h1'/%3E%3Cpath stroke='%232e97ff' d='M16 11h1'/%3E%3Cpath stroke='%232e91fc' d='M17 11h1'/%3E%3Cpath stroke='%232a80f0' d='M18 11h1'/%3E%3Cpath stroke='%231b5dcb' d='M19 11h1'/%3E%3Cpath stroke='%233275ff' d='M1 12h1'/%3E%3Cpath stroke='%235991ff' d='M6 12h1'/%3E%3Cpath stroke='%235596ff' d='M8 12h1'/%3E%3Cpath stroke='%23529cff' d='M9 12h1'/%3E%3Cpath stroke='%234fa1ff' d='M10 12h1'/%3E%3Cpath stroke='%234aa6ff' d='M11 12h1'/%3E%3Cpath stroke='%2342a9ff' d='M12 12h1'/%3E%3Cpath stroke='%233aa9ff' d='M13 12h1'/%3E%3Cpath stroke='%2334a7ff' d='M14 12h1'/%3E%3Cpath stroke='%2330a5ff' d='M15 12h1'/%3E%3Cpath stroke='%232ca0ff' d='M16 12h1'/%3E%3Cpath stroke='%232a96fd' d='M17 12h1'/%3E%3Cpath stroke='%232581f1' d='M18 12h1'/%3E%3Cpath stroke='%23185dcc' d='M19 12h1'/%3E%3Cpath stroke='%232d72ff' d='M1 13h1m0 3h1'/%3E%3Cpath stroke='%2344afff' d='M12 13h1'/%3E%3Cpath stroke='%233eb1ff' d='M13 13h1'/%3E%3Cpath stroke='%2337afff' d='M14 13h1'/%3E%3Cpath stroke='%232fabff' d='M15 13h1'/%3E%3Cpath stroke='%2329a4ff' d='M16 13h1'/%3E%3Cpath stroke='%232599fd' d='M17 13h1'/%3E%3Cpath stroke='%231e80f2' d='M18 13h1'/%3E%3Cpath stroke='%23145bcd' d='M19 13h1'/%3E%3Cpath stroke='%23276eff' d='M1 14h1'/%3E%3Cpath stroke='%233d7dff' d='M2 14h1'/%3E%3Cpath stroke='%234985ff' d='M3 14h1'/%3E%3Cpath stroke='%2343b1ff' d='M12 14h1'/%3E%3Cpath stroke='%233eb4ff' d='M13 14h1'/%3E%3Cpath stroke='%2335b2ff' d='M14 14h1'/%3E%3Cpath stroke='%232caeff' d='M15 14h1'/%3E%3Cpath stroke='%2324a5ff' d='M16 14h1'/%3E%3Cpath stroke='%231f97fd' d='M17 14h1'/%3E%3Cpath stroke='%231980f3' d='M18 14h1'/%3E%3Cpath stroke='%23105ace' d='M19 14h1'/%3E%3Cpath stroke='%23216aff' d='M1 15h1'/%3E%3Cpath stroke='%233578ff' d='M2 15h1'/%3E%3Cpath stroke='%234885ff' d='M4 15h1'/%3E%3Cpath stroke='%2341afff' d='M12 15h1'/%3E%3Cpath stroke='%233bb2ff' d='M13 15h1'/%3E%3Cpath stroke='%2333b1ff' d='M14 15h1'/%3E%3Cpath stroke='%232aadff' d='M15 15h1'/%3E%3Cpath stroke='%2321a3ff' d='M16 15h1'/%3E%3Cpath stroke='%231a95fd' d='M17 15h1'/%3E%3Cpath stroke='%23137cf2' d='M18 15h1'/%3E%3Cpath stroke='%230c59cf' d='M19 15h1'/%3E%3Cpath stroke='%231c66ff' d='M1 16h1'/%3E%3Cpath stroke='%233879ff' d='M3 16h1'/%3E%3Cpath stroke='%233f7eff' d='M4 16h1'/%3E%3Cpath stroke='%234584ff' d='M6 16h1'/%3E%3Cpath stroke='%234587ff' d='M7 16h1'/%3E%3Cpath stroke='%23468eff' d='M8 16h1'/%3E%3Cpath stroke='%234696ff' d='M9 16h1'/%3E%3Cpath stroke='%23439cff' d='M10 16h1'/%3E%3Cpath stroke='%233fa3ff' d='M11 16h1'/%3E%3Cpath stroke='%233ba8ff' d='M12 16h1'/%3E%3Cpath stroke='%233af' d='M13 16h1'/%3E%3Cpath stroke='%232da9ff' d='M14 16h1'/%3E%3Cpath stroke='%2324a6ff' d='M15 16h1'/%3E%3Cpath stroke='%231d9eff' d='M16 16h1'/%3E%3Cpath stroke='%231690fd' d='M17 16h1'/%3E%3Cpath stroke='%231078f1' d='M18 16h1'/%3E%3Cpath stroke='%230b57ce' d='M19 16h1'/%3E%3Cpath stroke='%231761f9' d='M1 17h1'/%3E%3Cpath stroke='%23246bfa' d='M2 17h1'/%3E%3Cpath stroke='%232f72fb' d='M3 17h1'/%3E%3Cpath stroke='%233676fb' d='M4 17h1'/%3E%3Cpath stroke='%233a7afb' d='M5 17h1'/%3E%3Cpath stroke='%233b7bfc' d='M6 17h1'/%3E%3Cpath stroke='%233b7efc' d='M7 17h1'/%3E%3Cpath stroke='%233c84fc' d='M8 17h1'/%3E%3Cpath stroke='%233b8afc' d='M9 17h1'/%3E%3Cpath stroke='%233990fc' d='M10 17h1'/%3E%3Cpath stroke='%233695fc' d='M11 17h1'/%3E%3Cpath stroke='%233299fc' d='M12 17h1'/%3E%3Cpath stroke='%232c9cfd' d='M13 17h1'/%3E%3Cpath stroke='%23259bfd' d='M14 17h1'/%3E%3Cpath stroke='%231e97fd' d='M15 17h1'/%3E%3Cpath stroke='%231790fc' d='M16 17h1'/%3E%3Cpath stroke='%231184fa' d='M17 17h1'/%3E%3Cpath stroke='%230c6ded' d='M18 17h1'/%3E%3Cpath stroke='%230850c8' d='M19 17h1'/%3E%3Cpath stroke='%232f6ae4' d='M1 18h1'/%3E%3Cpath stroke='%231b5fe9' d='M2 18h1'/%3E%3Cpath stroke='%232163e8' d='M3 18h1'/%3E%3Cpath stroke='%232868eb' d='M4 18h1'/%3E%3Cpath stroke='%232c6aea' d='M5 18h1'/%3E%3Cpath stroke='%232e6dea' d='M6 18h1'/%3E%3Cpath stroke='%232d6deb' d='M7 18h1'/%3E%3Cpath stroke='%232c71ec' d='M8 18h1'/%3E%3Cpath stroke='%232c76ec' d='M9 18h1'/%3E%3Cpath stroke='%232a79ed' d='M10 18h1'/%3E%3Cpath stroke='%23287eef' d='M11 18h1'/%3E%3Cpath stroke='%232481f1' d='M12 18h1'/%3E%3Cpath stroke='%232182f1' d='M13 18h1'/%3E%3Cpath stroke='%231c80f1' d='M14 18h1'/%3E%3Cpath stroke='%231880f3' d='M15 18h1'/%3E%3Cpath stroke='%23117af2' d='M16 18h1'/%3E%3Cpath stroke='%230c6eed' d='M17 18h1'/%3E%3Cpath stroke='%230a5ddd' d='M18 18h1'/%3E%3Cpath stroke='%23265dc1' d='M19 18h1'/%3E%3Cpath stroke='%2393b4f2' d='M0 19h1m19 0h1'/%3E%3Cpath stroke='%23d1ddf4' d='M1 19h1'/%3E%3Cpath stroke='%232e61ca' d='M2 19h1'/%3E%3Cpath stroke='%23134bbf' d='M3 19h1'/%3E%3Cpath stroke='%23164fc2' d='M4 19h1'/%3E%3Cpath stroke='%231950c1' d='M5 19h1'/%3E%3Cpath stroke='%231b52c1' d='M6 19h1'/%3E%3Cpath stroke='%231a52c3' d='M7 19h1'/%3E%3Cpath stroke='%231954c6' d='M8 19h1'/%3E%3Cpath stroke='%231b58c9' d='M9 19h1'/%3E%3Cpath stroke='%231858c8' d='M10 19h1'/%3E%3Cpath stroke='%23165bcd' d='M11 19h1'/%3E%3Cpath stroke='%23145cd0' d='M12 19h1'/%3E%3Cpath stroke='%23135cd0' d='M13 19h1'/%3E%3Cpath stroke='%230f58cc' d='M14 19h1'/%3E%3Cpath stroke='%230d5ad2' d='M15 19h1'/%3E%3Cpath stroke='%230b58d1' d='M16 19h1'/%3E%3Cpath stroke='%230951cb' d='M17 19h1'/%3E%3Cpath stroke='%23265ec3' d='M18 19h1'/%3E%3Cpath stroke='%23d0daee' d='M19 19h1'/%3E%3Cpath stroke='%2393b3f2' d='M1 20h1m17 0h1'/%3E%3Cpath stroke='%23fefefe' d='M14 20h1'/%3E%3Cpath stroke='%23fdfdfd' d='M15 20h1m1 0h1'/%3E%3Cpath stroke='%23fcfcfc' d='M16 20h1'/%3E%3Cpath stroke='%23f2f5fc' d='M18 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Minimize]:not(:disabled):active {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%2393b1ed' d='M1 0h1m17 0h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m15 0h1M0 2h1m19 0h1M0 18h1m19 0h1M2 20h1m15 0h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m19 0h1M0 6h1m19 0h1M0 7h1m19 0h1M0 8h1m19 0h1M0 9h1m19 0h1M0 10h1m19 0h1M0 11h1m19 0h1M0 12h1m19 0h1M0 13h1m19 0h1M0 14h1m19 0h1M0 15h1m19 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h15'/%3E%3Cpath stroke='%23a7bcee' d='M0 1h1m19 0h1'/%3E%3Cpath stroke='%23cfd3da' d='M1 1h1'/%3E%3Cpath stroke='%231f3b5f' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%23002453' d='M3 1h1M1 4h1'/%3E%3Cpath stroke='%23002557' d='M4 1h1'/%3E%3Cpath stroke='%23002658' d='M5 1h1'/%3E%3Cpath stroke='%2300285c' d='M6 1h1'/%3E%3Cpath stroke='%23002a61' d='M7 1h1'/%3E%3Cpath stroke='%23002d67' d='M8 1h1'/%3E%3Cpath stroke='%23002f6b' d='M9 1h1'/%3E%3Cpath stroke='%23002f6c' d='M10 1h1M1 10h1'/%3E%3Cpath stroke='%23003273' d='M11 1h1'/%3E%3Cpath stroke='%23003478' d='M12 1h1M5 2h1'/%3E%3Cpath stroke='%2300357b' d='M13 1h1M2 5h1m-2 8h1'/%3E%3Cpath stroke='%2300377f' d='M14 1h1M6 2h1'/%3E%3Cpath stroke='%23003780' d='M15 1h1'/%3E%3Cpath stroke='%23003984' d='M16 1h1'/%3E%3Cpath stroke='%23003882' d='M17 1h1M3 3h1'/%3E%3Cpath stroke='%231f5295' d='M18 1h1'/%3E%3Cpath stroke='%23cfdae9' d='M19 1h1'/%3E%3Cpath stroke='%23002a62' d='M2 2h1'/%3E%3Cpath stroke='%23003070' d='M3 2h1'/%3E%3Cpath stroke='%23003275' d='M4 2h1'/%3E%3Cpath stroke='%23003883' d='M7 2h1M1 17h1'/%3E%3Cpath stroke='%23003a88' d='M8 2h1'/%3E%3Cpath stroke='%23003d8f' d='M9 2h1M2 9h1'/%3E%3Cpath stroke='%23003e90' d='M10 2h1'/%3E%3Cpath stroke='%23004094' d='M11 2h1'/%3E%3Cpath stroke='%23004299' d='M12 2h1M2 12h1'/%3E%3Cpath stroke='%2300439b' d='M13 2h1'/%3E%3Cpath stroke='%2300449e' d='M14 2h1M2 14h1'/%3E%3Cpath stroke='%2300459f' d='M15 2h1'/%3E%3Cpath stroke='%230045a1' d='M16 2h1m1 0h1M2 17h1'/%3E%3Cpath stroke='%230045a0' d='M17 2h1M2 15h1'/%3E%3Cpath stroke='%231f5aa8' d='M19 2h1'/%3E%3Cpath stroke='%23002452' d='M1 3h1'/%3E%3Cpath stroke='%23003170' d='M2 3h1'/%3E%3Cpath stroke='%23003b8b' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%23003c8f' d='M5 3h1'/%3E%3Cpath stroke='%23003e94' d='M6 3h1'/%3E%3Cpath stroke='%23004099' d='M7 3h1'/%3E%3Cpath stroke='%2300429d' d='M8 3h1'/%3E%3Cpath stroke='%230044a2' d='M9 3h1'/%3E%3Cpath stroke='%230046a5' d='M10 3h1'/%3E%3Cpath stroke='%230048a8' d='M11 3h1'/%3E%3Cpath stroke='%230049ab' d='M12 3h1m-3 2h1'/%3E%3Cpath stroke='%23004aac' d='M13 3h1'/%3E%3Cpath stroke='%23004aad' d='M14 3h1'/%3E%3Cpath stroke='%23004bae' d='M15 3h2m1 0h1M3 14h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23004baf' d='M17 3h1m-5 2h1m-7 5h1m-5 7h1m-1 1h1'/%3E%3Cpath stroke='%23004bad' d='M19 3h1M3 13h1m-1 6h1'/%3E%3Cpath stroke='%23037' d='M2 4h1m-2 8h1'/%3E%3Cpath stroke='%23003d92' d='M4 4h1'/%3E%3Cpath stroke='%23003f97' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%2300419d' d='M6 4h1M4 6h1'/%3E%3Cpath stroke='%230043a1' d='M7 4h1'/%3E%3Cpath stroke='%230045a4' d='M8 4h1'/%3E%3Cpath stroke='%230047a8' d='M9 4h1M4 9h1'/%3E%3Cpath stroke='%230048ab' d='M10 4h1m-7 6h1'/%3E%3Cpath stroke='%230049ad' d='M11 4h1m-2 2h1m-6 5h1'/%3E%3Cpath stroke='%23004aae' d='M12 4h1m-1 1h1m-2 1h1m-6 5h1m-3 1h2'/%3E%3Cpath stroke='%23004cb0' d='M13 4h1m0 1h1m-8 6h1m-4 2h1'/%3E%3Cpath stroke='%23004db1' d='M14 4h3m-2 1h2m-4 1h4M7 12h1m-4 2h1m-1 1h1m-1 1h2'/%3E%3Cpath stroke='%23004db2' d='M17 4h3m-3 1h3m-2 1h2m-8 1h1m6 0h1m-9 1h1m-4 3h1m-5 6h2m-2 1h4m-4 1h4'/%3E%3Cpath stroke='%23002555' d='M1 5h1'/%3E%3Cpath stroke='%23003d90' d='M3 5h1'/%3E%3Cpath stroke='%2300409c' d='M5 5h1'/%3E%3Cpath stroke='%230042a1' d='M6 5h1M5 6h1'/%3E%3Cpath stroke='%230044a5' d='M7 5h1M6 6h1'/%3E%3Cpath stroke='%230046a8' d='M8 5h1M5 8h1'/%3E%3Cpath stroke='%230047aa' d='M9 5h1'/%3E%3Cpath stroke='%230049ac' d='M11 5h1m-7 5h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%2300275a' d='M1 6h1'/%3E%3Cpath stroke='%23003781' d='M2 6h1m-2 9h1'/%3E%3Cpath stroke='%23003f95' d='M3 6h1'/%3E%3Cpath stroke='%230045a9' d='M7 6h1'/%3E%3Cpath stroke='%230046aa' d='M8 6h1M6 7h1'/%3E%3Cpath stroke='%230047ac' d='M9 6h1M7 7h1'/%3E%3Cpath stroke='%23004bb0' d='M12 6h1M8 9h1m-3 3h1'/%3E%3Cpath stroke='%23004eb3' d='M17 6h1m-5 1h1m4 0h1m0 1h1M10 9h1m-2 1h1m-3 6h1m-2 1h2m0 2h1'/%3E%3Cpath stroke='%2300295f' d='M1 7h1'/%3E%3Cpath stroke='%23003985' d='M2 7h1'/%3E%3Cpath stroke='%2300419b' d='M3 7h1'/%3E%3Cpath stroke='%230043a2' d='M4 7h1'/%3E%3Cpath stroke='%230044a6' d='M5 7h1'/%3E%3Cpath stroke='%230048ad' d='M8 7h1M6 9h1'/%3E%3Cpath stroke='%230049ae' d='M9 7h1M7 8h2m-3 2h1'/%3E%3Cpath stroke='%23004aaf' d='M10 7h1M9 8h1M7 9h1'/%3E%3Cpath stroke='%23004cb1' d='M11 7h1m-2 1h1M9 9h1m-2 1h1'/%3E%3Cpath stroke='%23004fb3' d='M14 7h1'/%3E%3Cpath stroke='%23004fb4' d='M15 7h3m-6 1h1m5 0h1m0 1h1M8 12h1m-1 6h1m0 1h1'/%3E%3Cpath stroke='%23002b63' d='M1 8h1'/%3E%3Cpath stroke='%23003b8a' d='M2 8h1'/%3E%3Cpath stroke='%2300439f' d='M3 8h1'/%3E%3Cpath stroke='%230045a5' d='M4 8h1'/%3E%3Cpath stroke='%230047ab' d='M6 8h1M5 9h1'/%3E%3Cpath stroke='%230050b5' d='M13 8h2m1 0h2m-7 1h1m-2 1h1m8 0h1M9 11h1m-2 5h1m-1 1h1m1 2h1'/%3E%3Cpath stroke='%230051b6' d='M15 8h1m2 1h1m0 2h1m-1 1h1m-1 5h1M9 18h1m1 1h1'/%3E%3Cpath stroke='%23002d68' d='M1 9h1'/%3E%3Cpath stroke='%230045a3' d='M3 9h1'/%3E%3Cpath stroke='%230052b7' d='M12 9h1m-2 1h1m-2 1h1m-2 1h1m9 1h1m-8 6h2m3 0h1'/%3E%3Cpath stroke='%230053b8' d='M13 9h1m2 0h2m0 1h1m0 4h1M9 16h1m9 0h1M9 17h1m0 1h1m3 1h1m1 0h1'/%3E%3Cpath stroke='%230054b9' d='M14 9h2m2 9h1m-4 1h1'/%3E%3Cpath stroke='%23003f93' d='M2 10h1'/%3E%3Cpath stroke='%230047a7' d='M3 10h1'/%3E%3Cpath stroke='%230055ba' d='M12 10h1m4 0h1m-7 1h1m6 0h1m-9 6h1m0 1h1'/%3E%3Cpath stroke='%230056bb' d='M13 10h1m2 0h1m1 2h1m-9 4h1'/%3E%3Cpath stroke='%230057bc' d='M14 10h2m-5 2h1m6 5h1m-7 1h1m4 0h1'/%3E%3Cpath stroke='%23003172' d='M1 11h1'/%3E%3Cpath stroke='%23004095' d='M2 11h1'/%3E%3Cpath stroke='%230048aa' d='M3 11h1'/%3E%3Cpath stroke='%230058bd' d='M12 11h1m4 0h1m0 2h1m-6 5h1'/%3E%3Cpath stroke='%230059be' d='M13 11h1m2 0h1m-6 5h1m6 0h1m-5 2h1m1 0h1'/%3E%3Cpath stroke='%23005abf' d='M14 11h2m-4 1h1m4 0h1m-6 5h1m2 1h1'/%3E%3Cpath stroke='%230055b9' d='M10 12h1'/%3E%3Cpath stroke='%23005cc1' d='M13 12h1m2 0h1m-5 1h1m4 0h1m-5 4h1'/%3E%3Cpath stroke='%23005dc2' d='M14 12h1m-3 2h1m4 0h1m-6 1h1m4 1h1m-4 1h1m1 0h1'/%3E%3Cpath stroke='%23005ec3' d='M15 12h1m-3 1h1m2 0h1m0 2h1m-5 1h1m1 1h1'/%3E%3Cpath stroke='%2300449d' d='M2 13h1'/%3E%3Cpath stroke='%2378a2d8' d='M5 13h7m-7 1h7m-7 1h7'/%3E%3Cpath stroke='%23005fc4' d='M14 13h1m-2 1h1m2 0h1m-4 1h1'/%3E%3Cpath stroke='%230060c5' d='M15 13h1m-2 1h1m1 1h1m-2 1h1'/%3E%3Cpath stroke='%2300367e' d='M1 14h1'/%3E%3Cpath stroke='%230061c6' d='M15 14h1m-2 1h1'/%3E%3Cpath stroke='%230059bd' d='M18 14h1'/%3E%3Cpath stroke='%230062c6' d='M15 15h1'/%3E%3Cpath stroke='%23005abe' d='M18 15h1'/%3E%3Cpath stroke='%230054b8' d='M19 15h1'/%3E%3Cpath stroke='%23003881' d='M1 16h1'/%3E%3Cpath stroke='%230046a1' d='M2 16h1'/%3E%3Cpath stroke='%23004eb2' d='M6 16h1'/%3E%3Cpath stroke='%23005cc0' d='M12 16h1'/%3E%3Cpath stroke='%23005fc3' d='M14 16h1'/%3E%3Cpath stroke='%230060c4' d='M16 16h1'/%3E%3Cpath stroke='%230058bc' d='M11 17h1'/%3E%3Cpath stroke='%23005bc0' d='M17 17h1'/%3E%3Cpath stroke='%231f5294' d='M1 18h1'/%3E%3Cpath stroke='%230046a2' d='M2 18h1'/%3E%3Cpath stroke='%231f66be' d='M19 18h1'/%3E%3Cpath stroke='%23a7bef0' d='M0 19h1m0 1h1m17 0h1'/%3E%3Cpath stroke='%23cfdae8' d='M1 19h1'/%3E%3Cpath stroke='%231f5ba9' d='M2 19h1'/%3E%3Cpath stroke='%231f66bf' d='M18 19h1'/%3E%3Cpath stroke='%23cfdef1' d='M19 19h1'/%3E%3Cpath stroke='%2393b4f2' d='M20 19h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Maximize] {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%236696eb' d='M1 0h1'/%3E%3Cpath stroke='%23e5edfb' d='M2 0h1'/%3E%3Cpath stroke='%23fff' d='M3 0h16M0 2h1M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m4 0h11m4 0h1M0 6h1m4 0h11m4 0h1M0 7h1m4 0h11m4 0h1M0 8h1m4 0h1m9 0h1m4 0h1M0 9h1m4 0h1m9 0h1m4 0h1M0 10h1m4 0h1m9 0h1m4 0h1M0 11h1m4 0h1m9 0h1m4 0h1M0 12h1m4 0h1m9 0h1m4 0h1M0 13h1m4 0h1m9 0h1m4 0h1M0 14h1m4 0h1m9 0h1m4 0h1M0 15h1m4 0h11m4 0h1M0 16h1m19 0h1M0 17h1m19 0h1m-1 1h1M2 20h16'/%3E%3Cpath stroke='%236694eb' d='M19 0h1'/%3E%3Cpath stroke='%236693e9' d='M0 1h1m19 0h1'/%3E%3Cpath stroke='%23dce5fd' d='M1 1h1'/%3E%3Cpath stroke='%23739af8' d='M2 1h1'/%3E%3Cpath stroke='%23608cf7' d='M3 1h1M2 8h1'/%3E%3Cpath stroke='%235584f6' d='M4 1h1'/%3E%3Cpath stroke='%234d7ef6' d='M5 1h1M1 6h1m5 4h1'/%3E%3Cpath stroke='%23487af5' d='M6 1h1'/%3E%3Cpath stroke='%234276f5' d='M7 1h1M3 14h1'/%3E%3Cpath stroke='%234478f5' d='M8 1h1m5 3h1M2 12h1'/%3E%3Cpath stroke='%233e73f5' d='M9 1h2'/%3E%3Cpath stroke='%233b71f5' d='M11 1h2'/%3E%3Cpath stroke='%23336cf4' d='M13 1h2'/%3E%3Cpath stroke='%23306af4' d='M15 1h1'/%3E%3Cpath stroke='%232864f4' d='M16 1h1'/%3E%3Cpath stroke='%231f5def' d='M17 1h1'/%3E%3Cpath stroke='%233467e0' d='M18 1h1'/%3E%3Cpath stroke='%23d2dbf2' d='M19 1h1'/%3E%3Cpath stroke='%23769cf8' d='M1 2h1'/%3E%3Cpath stroke='%2390aff9' d='M2 2h1'/%3E%3Cpath stroke='%2394b2f9' d='M3 2h1'/%3E%3Cpath stroke='%2385a7f8' d='M4 2h1'/%3E%3Cpath stroke='%23759cf8' d='M5 2h1'/%3E%3Cpath stroke='%236e97f8' d='M6 2h1M2 6h1'/%3E%3Cpath stroke='%236892f7' d='M7 2h1'/%3E%3Cpath stroke='%236690f7' d='M8 2h1'/%3E%3Cpath stroke='%23628ef7' d='M9 2h1m0 1h1'/%3E%3Cpath stroke='%235f8cf7' d='M10 2h1'/%3E%3Cpath stroke='%235e8bf7' d='M11 2h1'/%3E%3Cpath stroke='%235988f6' d='M12 2h1'/%3E%3Cpath stroke='%235685f6' d='M13 2h1'/%3E%3Cpath stroke='%235082f6' d='M14 2h1'/%3E%3Cpath stroke='%23497cf5' d='M15 2h1'/%3E%3Cpath stroke='%233f75f5' d='M16 2h1m-2 2h1'/%3E%3Cpath stroke='%23326bf2' d='M17 2h1'/%3E%3Cpath stroke='%23235ce3' d='M18 2h1'/%3E%3Cpath stroke='%23305cc5' d='M19 2h1'/%3E%3Cpath stroke='%23e5ecfb' d='M20 2h1'/%3E%3Cpath stroke='%236590f7' d='M1 3h1'/%3E%3Cpath stroke='%2397b4f9' d='M2 3h1'/%3E%3Cpath stroke='%239ab7fa' d='M3 3h1'/%3E%3Cpath stroke='%2389aaf9' d='M4 3h1M2 4h1'/%3E%3Cpath stroke='%237aa0f8' d='M5 3h1'/%3E%3Cpath stroke='%23729af8' d='M6 3h1'/%3E%3Cpath stroke='%236d95f8' d='M7 3h1'/%3E%3Cpath stroke='%236892f8' d='M8 3h1M2 7h1'/%3E%3Cpath stroke='%23658ff7' d='M9 3h1'/%3E%3Cpath stroke='%23618df7' d='M11 3h1'/%3E%3Cpath stroke='%235d8af7' d='M12 3h1M3 9h1'/%3E%3Cpath stroke='%235987f6' d='M13 3h1M2 9h1'/%3E%3Cpath stroke='%235283f6' d='M14 3h1'/%3E%3Cpath stroke='%234c7ef6' d='M15 3h1'/%3E%3Cpath stroke='%234377f5' d='M16 3h1'/%3E%3Cpath stroke='%23376ef2' d='M17 3h1'/%3E%3Cpath stroke='%23285fe3' d='M18 3h1'/%3E%3Cpath stroke='%231546b9' d='M19 3h1'/%3E%3Cpath stroke='%235886f6' d='M1 4h1'/%3E%3Cpath stroke='%238dadf9' d='M3 4h1'/%3E%3Cpath stroke='%237fa3f8' d='M4 4h1'/%3E%3Cpath stroke='%237199f8' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%236a93f8' d='M6 4h1M4 6h1M3 7h1'/%3E%3Cpath stroke='%23648ef7' d='M7 4h1'/%3E%3Cpath stroke='%235e8af7' d='M8 4h1'/%3E%3Cpath stroke='%235986f7' d='M9 4h1m-6 6h1'/%3E%3Cpath stroke='%235482f6' d='M10 4h1'/%3E%3Cpath stroke='%235180f6' d='M11 4h1'/%3E%3Cpath stroke='%234b7cf5' d='M12 4h1'/%3E%3Cpath stroke='%234a7cf5' d='M13 4h1'/%3E%3Cpath stroke='%233a72f4' d='M16 4h1'/%3E%3Cpath stroke='%23346cf2' d='M17 4h1'/%3E%3Cpath stroke='%232a61e3' d='M18 4h1'/%3E%3Cpath stroke='%231848bb' d='M19 4h1'/%3E%3Cpath stroke='%235282f6' d='M1 5h1m4 6h1m-3 1h1'/%3E%3Cpath stroke='%23799ff8' d='M2 5h1'/%3E%3Cpath stroke='%237ca1f8' d='M3 5h1'/%3E%3Cpath stroke='%23316bf4' d='M16 5h1M3 16h1'/%3E%3Cpath stroke='%233069f1' d='M17 5h1'/%3E%3Cpath stroke='%232c62e4' d='M18 5h1'/%3E%3Cpath stroke='%231d4cbc' d='M19 5h1m-1 1h1'/%3E%3Cpath stroke='%237099f8' d='M3 6h1'/%3E%3Cpath stroke='%232d69f5' d='M16 6h1'/%3E%3Cpath stroke='%232e69f2' d='M17 6h1'/%3E%3Cpath stroke='%232c63e5' d='M18 6h1'/%3E%3Cpath stroke='%234679f5' d='M1 7h1M1 8h1'/%3E%3Cpath stroke='%23658ff8' d='M4 7h1'/%3E%3Cpath stroke='%232a68f5' d='M16 7h1'/%3E%3Cpath stroke='%232c69f2' d='M17 7h1'/%3E%3Cpath stroke='%232a62e4' d='M18 7h1'/%3E%3Cpath stroke='%231c4cbd' d='M19 7h1'/%3E%3Cpath stroke='%23628df8' d='M3 8h1'/%3E%3Cpath stroke='%23608bf7' d='M4 8h1'/%3E%3Cpath stroke='%235482f7' d='M6 8h1'/%3E%3Cpath stroke='%234e7cf6' d='M7 8h1'/%3E%3Cpath stroke='%234778f6' d='M8 8h1'/%3E%3Cpath stroke='%234174f5' d='M9 8h1'/%3E%3Cpath stroke='%233a71f5' d='M10 8h1'/%3E%3Cpath stroke='%23346ef4' d='M11 8h1'/%3E%3Cpath stroke='%232d6bf5' d='M12 8h1'/%3E%3Cpath stroke='%232869f5' d='M13 8h1'/%3E%3Cpath stroke='%232467f5' d='M14 8h1'/%3E%3Cpath stroke='%232567f5' d='M16 8h1'/%3E%3Cpath stroke='%232968f2' d='M17 8h1'/%3E%3Cpath stroke='%232963e4' d='M18 8h1'/%3E%3Cpath stroke='%231b4bbd' d='M19 8h1'/%3E%3Cpath stroke='%233c72f4' d='M1 9h1'/%3E%3Cpath stroke='%235d89f7' d='M4 9h1'/%3E%3Cpath stroke='%235381f6' d='M6 9h1'/%3E%3Cpath stroke='%234e7ef6' d='M7 9h1'/%3E%3Cpath stroke='%23477af5' d='M8 9h1'/%3E%3Cpath stroke='%234178f5' d='M9 9h1'/%3E%3Cpath stroke='%233a74f5' d='M10 9h1'/%3E%3Cpath stroke='%233472f5' d='M11 9h1'/%3E%3Cpath stroke='%232c6ff5' d='M12 9h1'/%3E%3Cpath stroke='%23276cf5' d='M13 9h1'/%3E%3Cpath stroke='%23236af6' d='M14 9h1'/%3E%3Cpath stroke='%232268f5' d='M16 9h1'/%3E%3Cpath stroke='%232569f2' d='M17 9h1'/%3E%3Cpath stroke='%232562e6' d='M18 9h1'/%3E%3Cpath stroke='%23194bbe' d='M19 9h1'/%3E%3Cpath stroke='%23376ef4' d='M1 10h1'/%3E%3Cpath stroke='%235181f6' d='M2 10h1'/%3E%3Cpath stroke='%235785f7' d='M3 10h1'/%3E%3Cpath stroke='%235281f6' d='M6 10h1'/%3E%3Cpath stroke='%23477bf6' d='M8 10h1'/%3E%3Cpath stroke='%234179f6' d='M9 10h1'/%3E%3Cpath stroke='%233b77f5' d='M10 10h1'/%3E%3Cpath stroke='%233474f5' d='M11 10h1'/%3E%3Cpath stroke='%232c72f6' d='M12 10h1'/%3E%3Cpath stroke='%23266ff6' d='M13 10h1'/%3E%3Cpath stroke='%23226df6' d='M14 10h1'/%3E%3Cpath stroke='%231f6af6' d='M16 10h1'/%3E%3Cpath stroke='%23216af3' d='M17 10h1'/%3E%3Cpath stroke='%232162e6' d='M18 10h1'/%3E%3Cpath stroke='%231649be' d='M19 10h1'/%3E%3Cpath stroke='%23326bf4' d='M1 11h1'/%3E%3Cpath stroke='%234b7df5' d='M2 11h1'/%3E%3Cpath stroke='%235483f6' d='M3 11h1'/%3E%3Cpath stroke='%235684f7' d='M4 11h1'/%3E%3Cpath stroke='%234d80f6' d='M7 11h1'/%3E%3Cpath stroke='%23487df6' d='M8 11h1'/%3E%3Cpath stroke='%23427cf6' d='M9 11h1'/%3E%3Cpath stroke='%233c7af6' d='M10 11h1'/%3E%3Cpath stroke='%233478f6' d='M11 11h1'/%3E%3Cpath stroke='%232d76f6' d='M12 11h1'/%3E%3Cpath stroke='%232673f7' d='M13 11h1'/%3E%3Cpath stroke='%232171f7' d='M14 11h1'/%3E%3Cpath stroke='%231c6df6' d='M16 11h1'/%3E%3Cpath stroke='%231c6af4' d='M17 11h1'/%3E%3Cpath stroke='%231c61e6' d='M18 11h1'/%3E%3Cpath stroke='%231248bf' d='M19 11h1'/%3E%3Cpath stroke='%232b66f4' d='M1 12h1'/%3E%3Cpath stroke='%234e7ff6' d='M3 12h1'/%3E%3Cpath stroke='%235182f6' d='M6 12h1'/%3E%3Cpath stroke='%234d81f7' d='M7 12h1'/%3E%3Cpath stroke='%23487ff6' d='M8 12h1'/%3E%3Cpath stroke='%23437ff6' d='M9 12h1'/%3E%3Cpath stroke='%233d7ef6' d='M10 12h1'/%3E%3Cpath stroke='%23357cf6' d='M11 12h1'/%3E%3Cpath stroke='%232d7af7' d='M12 12h1'/%3E%3Cpath stroke='%232677f7' d='M13 12h1'/%3E%3Cpath stroke='%232174f7' d='M14 12h1'/%3E%3Cpath stroke='%23186ef7' d='M16 12h1'/%3E%3Cpath stroke='%23186af4' d='M17 12h1'/%3E%3Cpath stroke='%23165fe7' d='M18 12h1'/%3E%3Cpath stroke='%230f47c0' d='M19 12h1'/%3E%3Cpath stroke='%232562f3' d='M1 13h1'/%3E%3Cpath stroke='%233d73f4' d='M2 13h1'/%3E%3Cpath stroke='%23487bf5' d='M3 13h1'/%3E%3Cpath stroke='%234e80f6' d='M4 13h1'/%3E%3Cpath stroke='%234e81f6' d='M6 13h1'/%3E%3Cpath stroke='%234b80f6' d='M7 13h1'/%3E%3Cpath stroke='%23477ff6' d='M8 13h1'/%3E%3Cpath stroke='%23427ff6' d='M9 13h1'/%3E%3Cpath stroke='%233c7ff6' d='M10 13h1'/%3E%3Cpath stroke='%23367ff7' d='M11 13h1'/%3E%3Cpath stroke='%232d7cf7' d='M12 13h1'/%3E%3Cpath stroke='%232679f8' d='M13 13h1'/%3E%3Cpath stroke='%232077f7' d='M14 13h1'/%3E%3Cpath stroke='%23166ff7' d='M16 13h1'/%3E%3Cpath stroke='%231369f4' d='M17 13h1'/%3E%3Cpath stroke='%23105de8' d='M18 13h1'/%3E%3Cpath stroke='%230a44bf' d='M19 13h1'/%3E%3Cpath stroke='%231e5df3' d='M1 14h1'/%3E%3Cpath stroke='%23366ef4' d='M2 14h1'/%3E%3Cpath stroke='%23497bf5' d='M4 14h1'/%3E%3Cpath stroke='%234a7ef7' d='M6 14h1'/%3E%3Cpath stroke='%23487ef6' d='M7 14h1'/%3E%3Cpath stroke='%23457ff6' d='M8 14h1'/%3E%3Cpath stroke='%234180f6' d='M9 14h1'/%3E%3Cpath stroke='%233b7ff6' d='M10 14h1'/%3E%3Cpath stroke='%23357ff7' d='M11 14h1'/%3E%3Cpath stroke='%232d7df7' d='M12 14h1'/%3E%3Cpath stroke='%23257af8' d='M13 14h1'/%3E%3Cpath stroke='%231e77f8' d='M14 14h1'/%3E%3Cpath stroke='%23116df7' d='M16 14h1'/%3E%3Cpath stroke='%230d66f4' d='M17 14h1m-3 3h1'/%3E%3Cpath stroke='%230b59e7' d='M18 14h1'/%3E%3Cpath stroke='%230641c0' d='M19 14h1m-6 5h1'/%3E%3Cpath stroke='%231859f3' d='M1 15h1'/%3E%3Cpath stroke='%232e68f4' d='M2 15h1'/%3E%3Cpath stroke='%233a71f4' d='M3 15h1'/%3E%3Cpath stroke='%234277f5' d='M4 15h1'/%3E%3Cpath stroke='%230e6cf8' d='M16 15h1'/%3E%3Cpath stroke='%230963f4' d='M17 15h1'/%3E%3Cpath stroke='%230556e7' d='M18 15h1'/%3E%3Cpath stroke='%23023fbf' d='M19 15h1'/%3E%3Cpath stroke='%231456f3' d='M1 16h1'/%3E%3Cpath stroke='%232562f4' d='M2 16h1'/%3E%3Cpath stroke='%233971f4' d='M4 16h1'/%3E%3Cpath stroke='%233d74f5' d='M5 16h1'/%3E%3Cpath stroke='%233d74f6' d='M6 16h1'/%3E%3Cpath stroke='%233b75f5' d='M7 16h1'/%3E%3Cpath stroke='%233976f5' d='M8 16h1'/%3E%3Cpath stroke='%233777f5' d='M9 16h1'/%3E%3Cpath stroke='%233278f6' d='M10 16h1'/%3E%3Cpath stroke='%232c78f7' d='M11 16h1'/%3E%3Cpath stroke='%232577f7' d='M12 16h1'/%3E%3Cpath stroke='%231f76f7' d='M13 16h1'/%3E%3Cpath stroke='%231972f7' d='M14 16h1'/%3E%3Cpath stroke='%23116ef8' d='M15 16h1'/%3E%3Cpath stroke='%230b68f7' d='M16 16h1'/%3E%3Cpath stroke='%230560f4' d='M17 16h1'/%3E%3Cpath stroke='%230253e6' d='M18 16h1'/%3E%3Cpath stroke='%23013dbe' d='M19 16h1'/%3E%3Cpath stroke='%230e50ed' d='M1 17h1'/%3E%3Cpath stroke='%231c5bef' d='M2 17h1'/%3E%3Cpath stroke='%232863f0' d='M3 17h1'/%3E%3Cpath stroke='%232f68f0' d='M4 17h1'/%3E%3Cpath stroke='%23336bf1' d='M5 17h1'/%3E%3Cpath stroke='%23346cf1' d='M6 17h1'/%3E%3Cpath stroke='%23316cf2' d='M7 17h1'/%3E%3Cpath stroke='%23316df2' d='M8 17h1'/%3E%3Cpath stroke='%232e6ff2' d='M9 17h1'/%3E%3Cpath stroke='%232a70f2' d='M10 17h1'/%3E%3Cpath stroke='%232570f3' d='M11 17h1'/%3E%3Cpath stroke='%231f6ff3' d='M12 17h1'/%3E%3Cpath stroke='%23196df4' d='M13 17h1'/%3E%3Cpath stroke='%23136af4' d='M14 17h1'/%3E%3Cpath stroke='%230760f3' d='M16 17h1'/%3E%3Cpath stroke='%23025af0' d='M17 17h1'/%3E%3Cpath stroke='%23004de2' d='M18 17h1'/%3E%3Cpath stroke='%23003ab9' d='M19 17h1'/%3E%3Cpath stroke='%23e5eefd' d='M0 18h1'/%3E%3Cpath stroke='%23285edf' d='M1 18h1'/%3E%3Cpath stroke='%23134fdf' d='M2 18h1'/%3E%3Cpath stroke='%231b55df' d='M3 18h1'/%3E%3Cpath stroke='%23215ae2' d='M4 18h1'/%3E%3Cpath stroke='%23255ce1' d='M5 18h1'/%3E%3Cpath stroke='%23265de0' d='M6 18h1'/%3E%3Cpath stroke='%23245ce1' d='M7 18h1'/%3E%3Cpath stroke='%23235ee2' d='M8 18h1'/%3E%3Cpath stroke='%23215ee2' d='M9 18h1'/%3E%3Cpath stroke='%231e5ee2' d='M10 18h1'/%3E%3Cpath stroke='%231b5fe5' d='M11 18h1'/%3E%3Cpath stroke='%23165ee5' d='M12 18h1'/%3E%3Cpath stroke='%23135de6' d='M13 18h1'/%3E%3Cpath stroke='%230e5be5' d='M14 18h1'/%3E%3Cpath stroke='%230958e6' d='M15 18h1'/%3E%3Cpath stroke='%230454e6' d='M16 18h1'/%3E%3Cpath stroke='%23014ee2' d='M17 18h1'/%3E%3Cpath stroke='%230045d3' d='M18 18h1'/%3E%3Cpath stroke='%231f4eb8' d='M19 18h1'/%3E%3Cpath stroke='%23679ef6' d='M0 19h1'/%3E%3Cpath stroke='%23d0daf1' d='M1 19h1'/%3E%3Cpath stroke='%232856c3' d='M2 19h1'/%3E%3Cpath stroke='%230d3fb6' d='M3 19h1'/%3E%3Cpath stroke='%231144bd' d='M4 19h1'/%3E%3Cpath stroke='%231245bb' d='M5 19h1'/%3E%3Cpath stroke='%231445b9' d='M6 19h1'/%3E%3Cpath stroke='%231244b9' d='M7 19h1'/%3E%3Cpath stroke='%231345bc' d='M8 19h1'/%3E%3Cpath stroke='%231346bd' d='M9 19h1'/%3E%3Cpath stroke='%231045be' d='M10 19h1'/%3E%3Cpath stroke='%230d45c0' d='M11 19h1'/%3E%3Cpath stroke='%230a45c1' d='M12 19h1'/%3E%3Cpath stroke='%230844c3' d='M13 19h1'/%3E%3Cpath stroke='%23033fc0' d='M15 19h1'/%3E%3Cpath stroke='%23013fc3' d='M16 19h1'/%3E%3Cpath stroke='%23003bbe' d='M17 19h1'/%3E%3Cpath stroke='%231f4eb9' d='M18 19h1'/%3E%3Cpath stroke='%23cfd8ed' d='M19 19h1'/%3E%3Cpath stroke='%23669bf5' d='M20 19h1M1 20h1'/%3E%3Cpath stroke='%23e5edfd' d='M18 20h1'/%3E%3Cpath stroke='%236699f3' d='M19 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Maximize]:hover {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23afc2ef' d='M1 0h1m17 0h1M0 1h1m19 0h1M0 19h1m19 0h1M1 20h1m17 0h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m17 2h1M0 18h1m17 2h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m4 0h11m4 0h1M0 6h1m4 0h11m4 0h1M0 7h1m4 0h11m4 0h1M0 8h1m4 0h1m9 0h1m4 0h1M0 9h1m4 0h1m9 0h1m4 0h1M0 10h1m4 0h1m9 0h1m4 0h1M0 11h1m4 0h1m9 0h1m4 0h1M0 12h1m4 0h1m9 0h1m4 0h1M0 13h1m4 0h1m9 0h1m4 0h1M0 14h1m4 0h1m9 0h1m4 0h1M0 15h1m4 0h11m4 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h15'/%3E%3Cpath stroke='%23f5f7fd' d='M18 0h1M0 2h1m19 16h1M2 20h1'/%3E%3Cpath stroke='%23dce7ff' d='M1 1h1'/%3E%3Cpath stroke='%2372a1ff' d='M2 1h1m4 3h1'/%3E%3Cpath stroke='%236a9cff' d='M3 1h1'/%3E%3Cpath stroke='%235f94ff' d='M4 1h1M4 11h1'/%3E%3Cpath stroke='%23558eff' d='M5 1h1M3 12h1'/%3E%3Cpath stroke='%23518bff' d='M6 1h1'/%3E%3Cpath stroke='%234a86ff' d='M7 1h1'/%3E%3Cpath stroke='%234b87ff' d='M8 1h1M2 12h1'/%3E%3Cpath stroke='%234684ff' d='M9 1h2'/%3E%3Cpath stroke='%234482ff' d='M11 1h1m4 1h1M1 9h1m0 4h1'/%3E%3Cpath stroke='%234080ff' d='M12 1h1M3 15h1'/%3E%3Cpath stroke='%233b7cff' d='M13 1h1'/%3E%3Cpath stroke='%233a7bff' d='M14 1h1'/%3E%3Cpath stroke='%233678ff' d='M15 1h1'/%3E%3Cpath stroke='%232e73ff' d='M16 1h1'/%3E%3Cpath stroke='%23276cf9' d='M17 1h1'/%3E%3Cpath stroke='%233a73e7' d='M18 1h1'/%3E%3Cpath stroke='%23d3ddf3' d='M19 1h1'/%3E%3Cpath stroke='%2373a1ff' d='M1 2h1'/%3E%3Cpath stroke='%2397b9ff' d='M2 2h1'/%3E%3Cpath stroke='%239cbdff' d='M3 2h1'/%3E%3Cpath stroke='%2390b5ff' d='M4 2h1'/%3E%3Cpath stroke='%2382acff' d='M5 2h1M5 4h1'/%3E%3Cpath stroke='%237ba7ff' d='M6 2h1M2 6h1'/%3E%3Cpath stroke='%2375a3ff' d='M7 2h1'/%3E%3Cpath stroke='%236f9fff' d='M8 2h1M3 8h1'/%3E%3Cpath stroke='%236c9dff' d='M9 2h1M1 3h1'/%3E%3Cpath stroke='%23689bff' d='M10 2h1M3 9h1'/%3E%3Cpath stroke='%236599ff' d='M11 2h1m0 1h1'/%3E%3Cpath stroke='%236095ff' d='M12 2h1m0 1h1'/%3E%3Cpath stroke='%235d93ff' d='M13 2h1'/%3E%3Cpath stroke='%23568eff' d='M14 2h1'/%3E%3Cpath stroke='%234f8aff' d='M15 2h1M3 13h1m0 1h1'/%3E%3Cpath stroke='%233878fb' d='M17 2h1'/%3E%3Cpath stroke='%232969eb' d='M18 2h1'/%3E%3Cpath stroke='%233566cb' d='M19 2h1'/%3E%3Cpath stroke='%239ebeff' d='M2 3h1'/%3E%3Cpath stroke='%23a4c2ff' d='M3 3h1'/%3E%3Cpath stroke='%2399baff' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%238ab0ff' d='M5 3h1'/%3E%3Cpath stroke='%2382abff' d='M6 3h1'/%3E%3Cpath stroke='%2379a6ff' d='M7 3h1'/%3E%3Cpath stroke='%2374a3ff' d='M8 3h1'/%3E%3Cpath stroke='%2371a0ff' d='M9 3h1'/%3E%3Cpath stroke='%236d9eff' d='M10 3h1M4 8h1'/%3E%3Cpath stroke='%23699bff' d='M11 3h1'/%3E%3Cpath stroke='%235a91ff' d='M14 3h1M2 10h1m1 2h1'/%3E%3Cpath stroke='%23538cff' d='M15 3h1M2 11h1'/%3E%3Cpath stroke='%234986ff' d='M16 3h1'/%3E%3Cpath stroke='%233d7cfc' d='M17 3h1'/%3E%3Cpath stroke='%232e6cea' d='M18 3h1'/%3E%3Cpath stroke='%231b52c2' d='M19 3h1'/%3E%3Cpath stroke='%236296ff' d='M1 4h1'/%3E%3Cpath stroke='%2391b5ff' d='M2 4h1'/%3E%3Cpath stroke='%238fb4ff' d='M4 4h1'/%3E%3Cpath stroke='%237aa6ff' d='M6 4h1'/%3E%3Cpath stroke='%236b9dff' d='M8 4h1'/%3E%3Cpath stroke='%236598ff' d='M9 4h1'/%3E%3Cpath stroke='%235f95ff' d='M10 4h1m-5 6h1'/%3E%3Cpath stroke='%235b92ff' d='M11 4h1'/%3E%3Cpath stroke='%23548dff' d='M12 4h1M1 6h1m2 7h1'/%3E%3Cpath stroke='%23528cff' d='M13 4h1'/%3E%3Cpath stroke='%234c88ff' d='M14 4h1'/%3E%3Cpath stroke='%234785ff' d='M15 4h1'/%3E%3Cpath stroke='%234280ff' d='M16 4h1'/%3E%3Cpath stroke='%233b7afb' d='M17 4h1'/%3E%3Cpath stroke='%23316fec' d='M18 4h1'/%3E%3Cpath stroke='%231f55c3' d='M19 4h1'/%3E%3Cpath stroke='%235990ff' d='M1 5h1'/%3E%3Cpath stroke='%2385adff' d='M2 5h1'/%3E%3Cpath stroke='%238bb1ff' d='M3 5h1'/%3E%3Cpath stroke='%2384acff' d='M4 5h1'/%3E%3Cpath stroke='%23397aff' d='M16 5h1M1 11h1'/%3E%3Cpath stroke='%233979fc' d='M17 5h1'/%3E%3Cpath stroke='%233370ec' d='M18 5h1m-1 1h1'/%3E%3Cpath stroke='%232357c3' d='M19 5h1'/%3E%3Cpath stroke='%2381aaff' d='M3 6h1'/%3E%3Cpath stroke='%237aa7ff' d='M4 6h1'/%3E%3Cpath stroke='%233679ff' d='M16 6h1'/%3E%3Cpath stroke='%233879fc' d='M17 6h1'/%3E%3Cpath stroke='%232358c5' d='M19 6h1'/%3E%3Cpath stroke='%234e89ff' d='M1 7h1'/%3E%3Cpath stroke='%2371a1ff' d='M2 7h1'/%3E%3Cpath stroke='%2377a5ff' d='M3 7h1'/%3E%3Cpath stroke='%2374a2ff' d='M4 7h1'/%3E%3Cpath stroke='%23337aff' d='M16 7h1'/%3E%3Cpath stroke='%23367bfc' d='M17 7h1'/%3E%3Cpath stroke='%233372ed' d='M18 7h1'/%3E%3Cpath stroke='%232359c5' d='M19 7h1'/%3E%3Cpath stroke='%234d88ff' d='M1 8h1'/%3E%3Cpath stroke='%23699cff' d='M2 8h1'/%3E%3Cpath stroke='%236398ff' d='M6 8h1'/%3E%3Cpath stroke='%235c93ff' d='M7 8h1m-2 3h1'/%3E%3Cpath stroke='%23548fff' d='M8 8h1'/%3E%3Cpath stroke='%234d8cff' d='M9 8h1'/%3E%3Cpath stroke='%23468aff' d='M10 8h1'/%3E%3Cpath stroke='%233f86ff' d='M11 8h1'/%3E%3Cpath stroke='%233983ff' d='M12 8h1'/%3E%3Cpath stroke='%233380ff' d='M13 8h1'/%3E%3Cpath stroke='%232f7fff' d='M14 8h1'/%3E%3Cpath stroke='%233280ff' d='M16 8h1'/%3E%3Cpath stroke='%233580fc' d='M17 8h1'/%3E%3Cpath stroke='%233276ed' d='M18 8h1'/%3E%3Cpath stroke='%23235ac6' d='M19 8h1'/%3E%3Cpath stroke='%236196ff' d='M2 9h1m3 0h1m-4 1h1'/%3E%3Cpath stroke='%23689aff' d='M4 9h1'/%3E%3Cpath stroke='%235b93ff' d='M7 9h1'/%3E%3Cpath stroke='%235491ff' d='M8 9h1'/%3E%3Cpath stroke='%234f90ff' d='M9 9h1'/%3E%3Cpath stroke='%234890ff' d='M10 9h1'/%3E%3Cpath stroke='%23428eff' d='M11 9h1'/%3E%3Cpath stroke='%233b8dff' d='M12 9h1'/%3E%3Cpath stroke='%23348aff' d='M13 9h1'/%3E%3Cpath stroke='%233189ff' d='M14 9h1'/%3E%3Cpath stroke='%233188ff' d='M16 9h1'/%3E%3Cpath stroke='%233385fc' d='M17 9h1'/%3E%3Cpath stroke='%233079ed' d='M18 9h1'/%3E%3Cpath stroke='%23215cc8' d='M19 9h1'/%3E%3Cpath stroke='%233f7fff' d='M1 10h1'/%3E%3Cpath stroke='%236397ff' d='M4 10h1'/%3E%3Cpath stroke='%235993ff' d='M7 10h1'/%3E%3Cpath stroke='%235492ff' d='M8 10h1'/%3E%3Cpath stroke='%235093ff' d='M9 10h1'/%3E%3Cpath stroke='%234a95ff' d='M10 10h1'/%3E%3Cpath stroke='%234496ff' d='M11 10h1'/%3E%3Cpath stroke='%233d96ff' d='M12 10h1'/%3E%3Cpath stroke='%233694ff' d='M13 10h1'/%3E%3Cpath stroke='%233193ff' d='M14 10h1'/%3E%3Cpath stroke='%233090ff' d='M16 10h1'/%3E%3Cpath stroke='%23328cfc' d='M17 10h1'/%3E%3Cpath stroke='%232e7def' d='M18 10h1'/%3E%3Cpath stroke='%231e5dc9' d='M19 10h1'/%3E%3Cpath stroke='%235c92ff' d='M3 11h1'/%3E%3Cpath stroke='%235792ff' d='M7 11h1m-1 1h1'/%3E%3Cpath stroke='%235594ff' d='M8 11h1'/%3E%3Cpath stroke='%235298ff' d='M9 11h1'/%3E%3Cpath stroke='%234d9cff' d='M10 11h1'/%3E%3Cpath stroke='%23479eff' d='M11 11h1'/%3E%3Cpath stroke='%23409fff' d='M12 11h1'/%3E%3Cpath stroke='%23379fff' d='M13 11h1'/%3E%3Cpath stroke='%23339dff' d='M14 11h1'/%3E%3Cpath stroke='%232e97ff' d='M16 11h1'/%3E%3Cpath stroke='%232e91fc' d='M17 11h1'/%3E%3Cpath stroke='%232a80f0' d='M18 11h1'/%3E%3Cpath stroke='%231b5dcb' d='M19 11h1'/%3E%3Cpath stroke='%233275ff' d='M1 12h1'/%3E%3Cpath stroke='%235991ff' d='M6 12h1'/%3E%3Cpath stroke='%235596ff' d='M8 12h1'/%3E%3Cpath stroke='%23529cff' d='M9 12h1'/%3E%3Cpath stroke='%234fa1ff' d='M10 12h1'/%3E%3Cpath stroke='%234aa6ff' d='M11 12h1'/%3E%3Cpath stroke='%2342a9ff' d='M12 12h1'/%3E%3Cpath stroke='%233aa9ff' d='M13 12h1'/%3E%3Cpath stroke='%2334a7ff' d='M14 12h1'/%3E%3Cpath stroke='%232ca0ff' d='M16 12h1'/%3E%3Cpath stroke='%232a96fd' d='M17 12h1'/%3E%3Cpath stroke='%232581f1' d='M18 12h1'/%3E%3Cpath stroke='%23185dcc' d='M19 12h1'/%3E%3Cpath stroke='%232d72ff' d='M1 13h1m0 3h1'/%3E%3Cpath stroke='%235790ff' d='M6 13h1'/%3E%3Cpath stroke='%235490ff' d='M7 13h1'/%3E%3Cpath stroke='%235597ff' d='M8 13h1'/%3E%3Cpath stroke='%23539fff' d='M9 13h1'/%3E%3Cpath stroke='%234fa4ff' d='M10 13h1'/%3E%3Cpath stroke='%234aaaff' d='M11 13h1'/%3E%3Cpath stroke='%2344afff' d='M12 13h1'/%3E%3Cpath stroke='%233eb1ff' d='M13 13h1'/%3E%3Cpath stroke='%2337afff' d='M14 13h1'/%3E%3Cpath stroke='%2329a4ff' d='M16 13h1'/%3E%3Cpath stroke='%232599fd' d='M17 13h1'/%3E%3Cpath stroke='%231e80f2' d='M18 13h1'/%3E%3Cpath stroke='%23145bcd' d='M19 13h1'/%3E%3Cpath stroke='%23276eff' d='M1 14h1'/%3E%3Cpath stroke='%233d7dff' d='M2 14h1'/%3E%3Cpath stroke='%234985ff' d='M3 14h1'/%3E%3Cpath stroke='%23528dff' d='M6 14h1'/%3E%3Cpath stroke='%23518fff' d='M7 14h1'/%3E%3Cpath stroke='%235196ff' d='M8 14h1'/%3E%3Cpath stroke='%23509fff' d='M9 14h1'/%3E%3Cpath stroke='%234ea6ff' d='M10 14h1'/%3E%3Cpath stroke='%2349acff' d='M11 14h1'/%3E%3Cpath stroke='%2343b1ff' d='M12 14h1'/%3E%3Cpath stroke='%233eb4ff' d='M13 14h1'/%3E%3Cpath stroke='%2335b2ff' d='M14 14h1'/%3E%3Cpath stroke='%2324a5ff' d='M16 14h1'/%3E%3Cpath stroke='%231f97fd' d='M17 14h1'/%3E%3Cpath stroke='%231980f3' d='M18 14h1'/%3E%3Cpath stroke='%23105ace' d='M19 14h1'/%3E%3Cpath stroke='%23216aff' d='M1 15h1'/%3E%3Cpath stroke='%233578ff' d='M2 15h1'/%3E%3Cpath stroke='%234885ff' d='M4 15h1'/%3E%3Cpath stroke='%2321a3ff' d='M16 15h1'/%3E%3Cpath stroke='%231a95fd' d='M17 15h1'/%3E%3Cpath stroke='%23137cf2' d='M18 15h1'/%3E%3Cpath stroke='%230c59cf' d='M19 15h1'/%3E%3Cpath stroke='%231c66ff' d='M1 16h1'/%3E%3Cpath stroke='%233879ff' d='M3 16h1'/%3E%3Cpath stroke='%233f7eff' d='M4 16h1'/%3E%3Cpath stroke='%234483ff' d='M5 16h1'/%3E%3Cpath stroke='%234584ff' d='M6 16h1'/%3E%3Cpath stroke='%234587ff' d='M7 16h1'/%3E%3Cpath stroke='%23468eff' d='M8 16h1'/%3E%3Cpath stroke='%234696ff' d='M9 16h1'/%3E%3Cpath stroke='%23439cff' d='M10 16h1'/%3E%3Cpath stroke='%233fa3ff' d='M11 16h1'/%3E%3Cpath stroke='%233ba8ff' d='M12 16h1'/%3E%3Cpath stroke='%233af' d='M13 16h1'/%3E%3Cpath stroke='%232da9ff' d='M14 16h1'/%3E%3Cpath stroke='%2324a6ff' d='M15 16h1'/%3E%3Cpath stroke='%231d9eff' d='M16 16h1'/%3E%3Cpath stroke='%231690fd' d='M17 16h1'/%3E%3Cpath stroke='%231078f1' d='M18 16h1'/%3E%3Cpath stroke='%230b57ce' d='M19 16h1'/%3E%3Cpath stroke='%231761f9' d='M1 17h1'/%3E%3Cpath stroke='%23246bfa' d='M2 17h1'/%3E%3Cpath stroke='%232f72fb' d='M3 17h1'/%3E%3Cpath stroke='%233676fb' d='M4 17h1'/%3E%3Cpath stroke='%233a7afb' d='M5 17h1'/%3E%3Cpath stroke='%233b7bfc' d='M6 17h1'/%3E%3Cpath stroke='%233b7efc' d='M7 17h1'/%3E%3Cpath stroke='%233c84fc' d='M8 17h1'/%3E%3Cpath stroke='%233b8afc' d='M9 17h1'/%3E%3Cpath stroke='%233990fc' d='M10 17h1'/%3E%3Cpath stroke='%233695fc' d='M11 17h1'/%3E%3Cpath stroke='%233299fc' d='M12 17h1'/%3E%3Cpath stroke='%232c9cfd' d='M13 17h1'/%3E%3Cpath stroke='%23259bfd' d='M14 17h1'/%3E%3Cpath stroke='%231e97fd' d='M15 17h1'/%3E%3Cpath stroke='%231790fc' d='M16 17h1'/%3E%3Cpath stroke='%231184fa' d='M17 17h1'/%3E%3Cpath stroke='%230c6ded' d='M18 17h1'/%3E%3Cpath stroke='%230850c8' d='M19 17h1'/%3E%3Cpath stroke='%232f6ae4' d='M1 18h1'/%3E%3Cpath stroke='%231b5fe9' d='M2 18h1'/%3E%3Cpath stroke='%232163e8' d='M3 18h1'/%3E%3Cpath stroke='%232868eb' d='M4 18h1'/%3E%3Cpath stroke='%232c6aea' d='M5 18h1'/%3E%3Cpath stroke='%232e6dea' d='M6 18h1'/%3E%3Cpath stroke='%232d6deb' d='M7 18h1'/%3E%3Cpath stroke='%232c71ec' d='M8 18h1'/%3E%3Cpath stroke='%232c76ec' d='M9 18h1'/%3E%3Cpath stroke='%232a79ed' d='M10 18h1'/%3E%3Cpath stroke='%23287eef' d='M11 18h1'/%3E%3Cpath stroke='%232481f1' d='M12 18h1'/%3E%3Cpath stroke='%232182f1' d='M13 18h1'/%3E%3Cpath stroke='%231c80f1' d='M14 18h1'/%3E%3Cpath stroke='%231880f3' d='M15 18h1'/%3E%3Cpath stroke='%23117af2' d='M16 18h1'/%3E%3Cpath stroke='%230c6eed' d='M17 18h1'/%3E%3Cpath stroke='%230a5ddd' d='M18 18h1'/%3E%3Cpath stroke='%23265dc1' d='M19 18h1'/%3E%3Cpath stroke='%23d1ddf4' d='M1 19h1'/%3E%3Cpath stroke='%232e61ca' d='M2 19h1'/%3E%3Cpath stroke='%23134bbf' d='M3 19h1'/%3E%3Cpath stroke='%23164fc2' d='M4 19h1'/%3E%3Cpath stroke='%231950c1' d='M5 19h1'/%3E%3Cpath stroke='%231b52c1' d='M6 19h1'/%3E%3Cpath stroke='%231a52c3' d='M7 19h1'/%3E%3Cpath stroke='%231954c6' d='M8 19h1'/%3E%3Cpath stroke='%231b58c9' d='M9 19h1'/%3E%3Cpath stroke='%231858c8' d='M10 19h1'/%3E%3Cpath stroke='%23165bcd' d='M11 19h1'/%3E%3Cpath stroke='%23145cd0' d='M12 19h1'/%3E%3Cpath stroke='%23135cd0' d='M13 19h1'/%3E%3Cpath stroke='%230f58cc' d='M14 19h1'/%3E%3Cpath stroke='%230d5ad2' d='M15 19h1'/%3E%3Cpath stroke='%230b58d1' d='M16 19h1'/%3E%3Cpath stroke='%230951cb' d='M17 19h1'/%3E%3Cpath stroke='%23265ec3' d='M18 19h1'/%3E%3Cpath stroke='%23d0daee' d='M19 19h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Maximize]:not(:disabled):active {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23b3c4ef' d='M1 0h1m17 0h1M0 1h1m19 0h1M0 19h1m19 0h1M1 20h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m17 2h1M0 18h1m17 2h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m19 0h1M0 6h1m19 0h1M0 7h1m19 0h1M0 8h1m19 0h1M0 9h1m19 0h1M0 10h1m19 0h1M0 11h1m19 0h1M0 12h1m19 0h1M0 13h1m19 0h1M0 14h1m19 0h1M0 15h1m19 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h15'/%3E%3Cpath stroke='%23f5f7fd' d='M18 0h1M0 2h1m19 16h1M2 20h1'/%3E%3Cpath stroke='%23cfd3da' d='M1 1h1'/%3E%3Cpath stroke='%231f3b5f' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%23002453' d='M3 1h1M1 4h1'/%3E%3Cpath stroke='%23002557' d='M4 1h1'/%3E%3Cpath stroke='%23002658' d='M5 1h1'/%3E%3Cpath stroke='%2300285c' d='M6 1h1'/%3E%3Cpath stroke='%23002a61' d='M7 1h1'/%3E%3Cpath stroke='%23002d67' d='M8 1h1'/%3E%3Cpath stroke='%23002f6b' d='M9 1h1'/%3E%3Cpath stroke='%23002f6c' d='M10 1h1M1 10h1'/%3E%3Cpath stroke='%23003273' d='M11 1h1'/%3E%3Cpath stroke='%23003478' d='M12 1h1M5 2h1'/%3E%3Cpath stroke='%2300357b' d='M13 1h1M2 5h1m-2 8h1'/%3E%3Cpath stroke='%2300377f' d='M14 1h1M6 2h1'/%3E%3Cpath stroke='%23003780' d='M15 1h1'/%3E%3Cpath stroke='%23003984' d='M16 1h1'/%3E%3Cpath stroke='%23003882' d='M17 1h1M3 3h1'/%3E%3Cpath stroke='%231f5295' d='M18 1h1'/%3E%3Cpath stroke='%23cfdae9' d='M19 1h1'/%3E%3Cpath stroke='%23002a62' d='M2 2h1'/%3E%3Cpath stroke='%23003070' d='M3 2h1'/%3E%3Cpath stroke='%23003275' d='M4 2h1'/%3E%3Cpath stroke='%23003883' d='M7 2h1M1 17h1'/%3E%3Cpath stroke='%23003a88' d='M8 2h1'/%3E%3Cpath stroke='%23003d8f' d='M9 2h1M2 9h1'/%3E%3Cpath stroke='%23003e90' d='M10 2h1'/%3E%3Cpath stroke='%23004094' d='M11 2h1'/%3E%3Cpath stroke='%23004299' d='M12 2h1M2 12h1'/%3E%3Cpath stroke='%2300439b' d='M13 2h1'/%3E%3Cpath stroke='%2300449e' d='M14 2h1M2 14h1'/%3E%3Cpath stroke='%2300459f' d='M15 2h1'/%3E%3Cpath stroke='%230045a1' d='M16 2h1m1 0h1M2 17h1'/%3E%3Cpath stroke='%230045a0' d='M17 2h1M2 15h1'/%3E%3Cpath stroke='%231f5aa8' d='M19 2h1'/%3E%3Cpath stroke='%23002452' d='M1 3h1'/%3E%3Cpath stroke='%23003170' d='M2 3h1'/%3E%3Cpath stroke='%23003b8b' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%23003c8f' d='M5 3h1'/%3E%3Cpath stroke='%23003e94' d='M6 3h1'/%3E%3Cpath stroke='%23004099' d='M7 3h1'/%3E%3Cpath stroke='%2300429d' d='M8 3h1'/%3E%3Cpath stroke='%230044a2' d='M9 3h1'/%3E%3Cpath stroke='%230046a5' d='M10 3h1'/%3E%3Cpath stroke='%230048a8' d='M11 3h1'/%3E%3Cpath stroke='%230049ab' d='M12 3h1'/%3E%3Cpath stroke='%23004aac' d='M13 3h1'/%3E%3Cpath stroke='%23004aad' d='M14 3h1'/%3E%3Cpath stroke='%23004bae' d='M15 3h2m1 0h1M3 14h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23004baf' d='M17 3h1M7 10h1m-5 7h1m-1 1h1'/%3E%3Cpath stroke='%23004bad' d='M19 3h1M3 13h1m-1 6h1'/%3E%3Cpath stroke='%23037' d='M2 4h1m-2 8h1'/%3E%3Cpath stroke='%23003d92' d='M4 4h1'/%3E%3Cpath stroke='%23003f97' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%2300419d' d='M6 4h1M4 6h1'/%3E%3Cpath stroke='%230043a1' d='M7 4h1'/%3E%3Cpath stroke='%230045a4' d='M8 4h1'/%3E%3Cpath stroke='%230047a8' d='M9 4h1M4 9h1'/%3E%3Cpath stroke='%230048ab' d='M10 4h1m-7 6h1'/%3E%3Cpath stroke='%230049ad' d='M11 4h1'/%3E%3Cpath stroke='%23004aae' d='M12 4h1m-7 7h1m-3 1h1'/%3E%3Cpath stroke='%23004cb0' d='M13 4h1m-7 7h1m-4 2h1'/%3E%3Cpath stroke='%23004db1' d='M14 4h3m-1 1h1m-1 1h1M7 12h1m-2 1h1m-3 1h1m1 0h1m-3 1h1m-1 1h2'/%3E%3Cpath stroke='%23004db2' d='M17 4h3m-3 1h3m-2 1h2m-1 1h1m-9 1h1m-4 3h1m-5 6h2m-2 1h4m-4 1h4'/%3E%3Cpath stroke='%23002555' d='M1 5h1'/%3E%3Cpath stroke='%23003d90' d='M3 5h1'/%3E%3Cpath stroke='%2378a2d8' d='M5 5h11M5 6h11M5 7h11M5 8h1m9 0h1M5 9h1m9 0h1M5 10h1m9 0h1M5 11h1m9 0h1M5 12h1m9 0h1M5 13h1m9 0h1M5 14h1m9 0h1M5 15h11'/%3E%3Cpath stroke='%2300275a' d='M1 6h1'/%3E%3Cpath stroke='%23003781' d='M2 6h1m-2 9h1'/%3E%3Cpath stroke='%23003f95' d='M3 6h1'/%3E%3Cpath stroke='%23004eb3' d='M17 6h1m0 1h1m0 1h1M10 9h1m-2 1h1m-3 6h1m-2 1h2m0 2h1'/%3E%3Cpath stroke='%2300295f' d='M1 7h1'/%3E%3Cpath stroke='%23003985' d='M2 7h1'/%3E%3Cpath stroke='%2300419b' d='M3 7h1'/%3E%3Cpath stroke='%230043a2' d='M4 7h1'/%3E%3Cpath stroke='%23004fb4' d='M16 7h2m-6 1h1m5 0h1m0 1h1M8 12h1m-1 6h1m0 1h1'/%3E%3Cpath stroke='%23002b63' d='M1 8h1'/%3E%3Cpath stroke='%23003b8a' d='M2 8h1'/%3E%3Cpath stroke='%2300439f' d='M3 8h1'/%3E%3Cpath stroke='%230045a5' d='M4 8h1'/%3E%3Cpath stroke='%230047ab' d='M6 8h1'/%3E%3Cpath stroke='%230049ae' d='M7 8h2m-3 2h1'/%3E%3Cpath stroke='%23004aaf' d='M9 8h1M7 9h1'/%3E%3Cpath stroke='%23004cb1' d='M10 8h1M9 9h1m-2 1h1'/%3E%3Cpath stroke='%230050b5' d='M13 8h2m1 0h2m-7 1h1m-2 1h1m8 0h1M9 11h1m-2 2h1m-1 3h1m-1 1h1m1 2h1'/%3E%3Cpath stroke='%23002d68' d='M1 9h1'/%3E%3Cpath stroke='%230045a3' d='M3 9h1'/%3E%3Cpath stroke='%230048ad' d='M6 9h1'/%3E%3Cpath stroke='%23004bb0' d='M8 9h1m-3 3h1'/%3E%3Cpath stroke='%230052b7' d='M12 9h1m-2 1h1m-2 1h1m-2 1h1m9 1h1m-8 6h2m3 0h1'/%3E%3Cpath stroke='%230053b8' d='M13 9h1m2 0h2m0 1h1M9 13h1m9 1h1M9 16h1m9 0h1M9 17h1m0 1h1m3 1h1m1 0h1'/%3E%3Cpath stroke='%230054b9' d='M14 9h1m-6 5h1m8 4h1m-4 1h1'/%3E%3Cpath stroke='%230051b6' d='M18 9h1m0 2h1m-1 1h1M8 14h1m10 3h1M9 18h1m1 1h1'/%3E%3Cpath stroke='%23003f93' d='M2 10h1'/%3E%3Cpath stroke='%230047a7' d='M3 10h1'/%3E%3Cpath stroke='%230055ba' d='M12 10h1m4 0h1m-7 1h1m6 0h1m-9 6h1m0 1h1'/%3E%3Cpath stroke='%230056bb' d='M13 10h1m2 0h1m1 2h1m-9 1h1m-1 3h1'/%3E%3Cpath stroke='%230057bc' d='M14 10h1m-4 2h1m-2 2h1m7 3h1m-7 1h1m4 0h1'/%3E%3Cpath stroke='%23003172' d='M1 11h1'/%3E%3Cpath stroke='%23004095' d='M2 11h1'/%3E%3Cpath stroke='%230048aa' d='M3 11h1'/%3E%3Cpath stroke='%230049ac' d='M4 11h1m-2 1h1'/%3E%3Cpath stroke='%230058bd' d='M12 11h1m4 0h1m0 2h1m-6 5h1'/%3E%3Cpath stroke='%230059be' d='M13 11h1m2 0h1m-6 2h1m-1 3h1m6 0h1m-5 2h1m1 0h1'/%3E%3Cpath stroke='%23005abf' d='M14 11h1m-3 1h1m4 0h1m-7 2h1m0 3h1m2 1h1'/%3E%3Cpath stroke='%230055b9' d='M10 12h1'/%3E%3Cpath stroke='%23005cc1' d='M13 12h1m2 0h1m-5 1h1m4 0h1m-5 4h1'/%3E%3Cpath stroke='%23005dc2' d='M14 12h1m-3 2h1m4 0h1m-1 2h1m-4 1h1m1 0h1'/%3E%3Cpath stroke='%2300449d' d='M2 13h1'/%3E%3Cpath stroke='%23004eb2' d='M7 13h1m-2 3h1'/%3E%3Cpath stroke='%23005ec3' d='M13 13h1m2 0h1m0 2h1m-5 1h1m1 1h1'/%3E%3Cpath stroke='%23005fc4' d='M14 13h1m-2 1h1m2 0h1'/%3E%3Cpath stroke='%2300367e' d='M1 14h1'/%3E%3Cpath stroke='%23004fb3' d='M7 14h1'/%3E%3Cpath stroke='%230060c5' d='M14 14h1m1 1h1m-2 1h1'/%3E%3Cpath stroke='%230059bd' d='M18 14h1'/%3E%3Cpath stroke='%23005abe' d='M18 15h1'/%3E%3Cpath stroke='%230054b8' d='M19 15h1'/%3E%3Cpath stroke='%23003881' d='M1 16h1'/%3E%3Cpath stroke='%230046a1' d='M2 16h1'/%3E%3Cpath stroke='%23005cc0' d='M12 16h1'/%3E%3Cpath stroke='%23005fc3' d='M14 16h1'/%3E%3Cpath stroke='%230060c4' d='M16 16h1'/%3E%3Cpath stroke='%230058bc' d='M11 17h1'/%3E%3Cpath stroke='%23005bc0' d='M17 17h1'/%3E%3Cpath stroke='%231f5294' d='M1 18h1'/%3E%3Cpath stroke='%230046a2' d='M2 18h1'/%3E%3Cpath stroke='%231f66be' d='M19 18h1'/%3E%3Cpath stroke='%23cfdae8' d='M1 19h1'/%3E%3Cpath stroke='%231f5ba9' d='M2 19h1'/%3E%3Cpath stroke='%231f66bf' d='M18 19h1'/%3E%3Cpath stroke='%23cfdef1' d='M19 19h1'/%3E%3Cpath stroke='%23b2c3ee' d='M19 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Help] {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23b5c6ef' d='M1 0h1m17 0h1M0 1h1m19 0h1M0 19h1m19 0h1M1 20h1m17 0h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m17 2h1M0 18h1m17 2h1'/%3E%3Cpath stroke='%23fff' d='M3 0h16M0 2h1M0 3h1m19 0h1M0 4h1m8 0h3m8 0h1M0 5h1m7 0h1m3 0h1m7 0h1M0 6h1m6 0h1m5 0h1m6 0h1M0 7h1m12 0h1m6 0h1M0 8h1m12 0h1m6 0h1M0 9h1m12 0h1m6 0h1M0 10h1m10 0h2m7 0h1M0 11h1m9 0h1m9 0h1M0 12h1m9 0h1m9 0h1M0 13h1m19 0h1M0 14h1m19 0h1M0 15h1m9 0h1m9 0h1M0 16h1m9 0h1m9 0h1M0 17h1m19 0h1m-1 1h1M2 20h16'/%3E%3Cpath stroke='%23dce5fd' d='M1 1h1'/%3E%3Cpath stroke='%23739af8' d='M2 1h1'/%3E%3Cpath stroke='%23608cf7' d='M3 1h1M2 8h1'/%3E%3Cpath stroke='%235584f6' d='M4 1h1'/%3E%3Cpath stroke='%234d7ef6' d='M5 1h1M1 6h1m5 4h1'/%3E%3Cpath stroke='%23487af5' d='M6 1h1'/%3E%3Cpath stroke='%234276f5' d='M7 1h1M3 14h1'/%3E%3Cpath stroke='%234478f5' d='M8 1h1m5 3h1M2 12h1'/%3E%3Cpath stroke='%233e73f5' d='M9 1h2'/%3E%3Cpath stroke='%233b71f5' d='M11 1h2'/%3E%3Cpath stroke='%23336cf4' d='M13 1h2'/%3E%3Cpath stroke='%23306af4' d='M15 1h1'/%3E%3Cpath stroke='%232864f4' d='M16 1h1'/%3E%3Cpath stroke='%231f5def' d='M17 1h1'/%3E%3Cpath stroke='%233467e0' d='M18 1h1'/%3E%3Cpath stroke='%23d2dbf2' d='M19 1h1'/%3E%3Cpath stroke='%23769cf8' d='M1 2h1'/%3E%3Cpath stroke='%2390aff9' d='M2 2h1'/%3E%3Cpath stroke='%2394b2f9' d='M3 2h1'/%3E%3Cpath stroke='%2385a7f8' d='M4 2h1'/%3E%3Cpath stroke='%23759cf8' d='M5 2h1'/%3E%3Cpath stroke='%236e97f8' d='M6 2h1M2 6h1'/%3E%3Cpath stroke='%236892f7' d='M7 2h1'/%3E%3Cpath stroke='%236690f7' d='M8 2h1'/%3E%3Cpath stroke='%23628ef7' d='M9 2h1m0 1h1'/%3E%3Cpath stroke='%235f8cf7' d='M10 2h1'/%3E%3Cpath stroke='%235e8bf7' d='M11 2h1'/%3E%3Cpath stroke='%235988f6' d='M12 2h1'/%3E%3Cpath stroke='%235685f6' d='M13 2h1'/%3E%3Cpath stroke='%235082f6' d='M14 2h1'/%3E%3Cpath stroke='%23497cf5' d='M15 2h1'/%3E%3Cpath stroke='%233f75f5' d='M16 2h1m-2 2h1'/%3E%3Cpath stroke='%23326bf2' d='M17 2h1'/%3E%3Cpath stroke='%23235ce3' d='M18 2h1'/%3E%3Cpath stroke='%23305cc5' d='M19 2h1'/%3E%3Cpath stroke='%236590f7' d='M1 3h1'/%3E%3Cpath stroke='%2397b4f9' d='M2 3h1'/%3E%3Cpath stroke='%239ab7fa' d='M3 3h1'/%3E%3Cpath stroke='%2389aaf9' d='M4 3h1M2 4h1'/%3E%3Cpath stroke='%237aa0f8' d='M5 3h1'/%3E%3Cpath stroke='%23729af8' d='M6 3h1'/%3E%3Cpath stroke='%236d95f8' d='M7 3h1'/%3E%3Cpath stroke='%236892f8' d='M8 3h1M2 7h1'/%3E%3Cpath stroke='%23658ff7' d='M9 3h1'/%3E%3Cpath stroke='%23618df7' d='M11 3h1'/%3E%3Cpath stroke='%235d8af7' d='M12 3h1M3 9h1'/%3E%3Cpath stroke='%235987f6' d='M13 3h1M2 9h1'/%3E%3Cpath stroke='%235283f6' d='M14 3h1'/%3E%3Cpath stroke='%234c7ef6' d='M15 3h1M5 14h1'/%3E%3Cpath stroke='%234377f5' d='M16 3h1'/%3E%3Cpath stroke='%23376ef2' d='M17 3h1'/%3E%3Cpath stroke='%23285fe3' d='M18 3h1'/%3E%3Cpath stroke='%231546b9' d='M19 3h1'/%3E%3Cpath stroke='%235886f6' d='M1 4h1'/%3E%3Cpath stroke='%238dadf9' d='M3 4h1'/%3E%3Cpath stroke='%237fa3f8' d='M4 4h1'/%3E%3Cpath stroke='%237199f8' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%236a93f8' d='M6 4h1M4 6h1M3 7h1'/%3E%3Cpath stroke='%2392aff9' d='M7 4h1'/%3E%3Cpath stroke='%23e1e9fd' d='M8 4h1'/%3E%3Cpath stroke='%23e0e8fd' d='M12 4h1'/%3E%3Cpath stroke='%2381a4f8' d='M13 4h1'/%3E%3Cpath stroke='%233a72f4' d='M16 4h1'/%3E%3Cpath stroke='%23346cf2' d='M17 4h1'/%3E%3Cpath stroke='%232a61e3' d='M18 4h1'/%3E%3Cpath stroke='%231848bb' d='M19 4h1'/%3E%3Cpath stroke='%235282f6' d='M1 5h1m4 6h1m-3 1h1'/%3E%3Cpath stroke='%23799ff8' d='M2 5h1'/%3E%3Cpath stroke='%237ca1f8' d='M3 5h1'/%3E%3Cpath stroke='%236791f8' d='M5 5h1'/%3E%3Cpath stroke='%238eacf9' d='M6 5h1'/%3E%3Cpath stroke='%23f3f6fe' d='M7 5h1'/%3E%3Cpath stroke='%23d8e2fd' d='M9 5h1'/%3E%3Cpath stroke='%23cfdcfc' d='M10 5h1'/%3E%3Cpath stroke='%23ecf1fe' d='M11 5h1'/%3E%3Cpath stroke='%23eff4fe' d='M13 5h1'/%3E%3Cpath stroke='%23749af7' d='M14 5h1'/%3E%3Cpath stroke='%23326cf4' d='M15 5h1'/%3E%3Cpath stroke='%23316bf4' d='M16 5h1M3 16h1'/%3E%3Cpath stroke='%233069f1' d='M17 5h1'/%3E%3Cpath stroke='%232c62e4' d='M18 5h1'/%3E%3Cpath stroke='%231d4cbc' d='M19 5h1m-1 1h1'/%3E%3Cpath stroke='%237099f8' d='M3 6h1'/%3E%3Cpath stroke='%23628cf8' d='M5 6h1'/%3E%3Cpath stroke='%23d3dffd' d='M6 6h1'/%3E%3Cpath stroke='%23b2c6fb' d='M8 6h1'/%3E%3Cpath stroke='%234777f6' d='M9 6h1'/%3E%3Cpath stroke='%234072f5' d='M10 6h1'/%3E%3Cpath stroke='%234a7bf6' d='M11 6h1'/%3E%3Cpath stroke='%23c8d7fc' d='M12 6h1'/%3E%3Cpath stroke='%23c6d6fc' d='M14 6h1'/%3E%3Cpath stroke='%232c69f5' d='M15 6h1'/%3E%3Cpath stroke='%232d69f5' d='M16 6h1'/%3E%3Cpath stroke='%232e69f2' d='M17 6h1'/%3E%3Cpath stroke='%232c63e5' d='M18 6h1'/%3E%3Cpath stroke='%234679f5' d='M1 7h1M1 8h1'/%3E%3Cpath stroke='%23658ff8' d='M4 7h1'/%3E%3Cpath stroke='%235e89f7' d='M5 7h1'/%3E%3Cpath stroke='%23e6edfe' d='M6 7h1'/%3E%3Cpath stroke='%23e5ecfe' d='M7 7h1'/%3E%3Cpath stroke='%235a85f7' d='M8 7h1'/%3E%3Cpath stroke='%234375f5' d='M9 7h1'/%3E%3Cpath stroke='%233d71f5' d='M10 7h1'/%3E%3Cpath stroke='%23366ef4' d='M11 7h1M2 14h1'/%3E%3Cpath stroke='%236c97f8' d='M12 7h1'/%3E%3Cpath stroke='%23cfddfd' d='M14 7h1'/%3E%3Cpath stroke='%232766f5' d='M15 7h1'/%3E%3Cpath stroke='%232a68f5' d='M16 7h1'/%3E%3Cpath stroke='%232c69f2' d='M17 7h1'/%3E%3Cpath stroke='%232a62e4' d='M18 7h1'/%3E%3Cpath stroke='%231c4cbd' d='M19 7h1'/%3E%3Cpath stroke='%23628df8' d='M3 8h1'/%3E%3Cpath stroke='%23608bf7' d='M4 8h1'/%3E%3Cpath stroke='%235b87f7' d='M5 8h1'/%3E%3Cpath stroke='%235482f7' d='M6 8h1'/%3E%3Cpath stroke='%234e7cf6' d='M7 8h1'/%3E%3Cpath stroke='%234778f6' d='M8 8h1'/%3E%3Cpath stroke='%234174f5' d='M9 8h1'/%3E%3Cpath stroke='%233a71f5' d='M10 8h1'/%3E%3Cpath stroke='%23346ef4' d='M11 8h1'/%3E%3Cpath stroke='%2385a9f9' d='M12 8h1'/%3E%3Cpath stroke='%23cbdbfd' d='M14 8h1'/%3E%3Cpath stroke='%232266f5' d='M15 8h1'/%3E%3Cpath stroke='%232567f5' d='M16 8h1'/%3E%3Cpath stroke='%232968f2' d='M17 8h1'/%3E%3Cpath stroke='%232963e4' d='M18 8h1'/%3E%3Cpath stroke='%231b4bbd' d='M19 8h1'/%3E%3Cpath stroke='%233c72f4' d='M1 9h1'/%3E%3Cpath stroke='%235d89f7' d='M4 9h1'/%3E%3Cpath stroke='%235986f7' d='M5 9h1m-2 1h1'/%3E%3Cpath stroke='%235381f6' d='M6 9h1'/%3E%3Cpath stroke='%234e7ef6' d='M7 9h1'/%3E%3Cpath stroke='%23477af5' d='M8 9h1'/%3E%3Cpath stroke='%234178f5' d='M9 9h1'/%3E%3Cpath stroke='%233a74f5' d='M10 9h1'/%3E%3Cpath stroke='%2396b6fa' d='M11 9h1'/%3E%3Cpath stroke='%23f2f6fe' d='M12 9h1'/%3E%3Cpath stroke='%2393b6fb' d='M14 9h1'/%3E%3Cpath stroke='%232069f6' d='M15 9h1'/%3E%3Cpath stroke='%232268f5' d='M16 9h1'/%3E%3Cpath stroke='%232569f2' d='M17 9h1'/%3E%3Cpath stroke='%232562e6' d='M18 9h1'/%3E%3Cpath stroke='%23194bbe' d='M19 9h1'/%3E%3Cpath stroke='%23376ef4' d='M1 10h1'/%3E%3Cpath stroke='%235181f6' d='M2 10h1'/%3E%3Cpath stroke='%235785f7' d='M3 10h1m1 0h1'/%3E%3Cpath stroke='%235281f6' d='M6 10h1'/%3E%3Cpath stroke='%23477bf6' d='M8 10h1'/%3E%3Cpath stroke='%234e82f7' d='M9 10h1'/%3E%3Cpath stroke='%23cadafc' d='M10 10h1'/%3E%3Cpath stroke='%23a0c0fb' d='M13 10h1'/%3E%3Cpath stroke='%232a72f6' d='M14 10h1'/%3E%3Cpath stroke='%231e6bf6' d='M15 10h1'/%3E%3Cpath stroke='%231f6af6' d='M16 10h1'/%3E%3Cpath stroke='%23216af3' d='M17 10h1'/%3E%3Cpath stroke='%232162e6' d='M18 10h1'/%3E%3Cpath stroke='%231649be' d='M19 10h1'/%3E%3Cpath stroke='%23326bf4' d='M1 11h1'/%3E%3Cpath stroke='%234b7df5' d='M2 11h1'/%3E%3Cpath stroke='%235483f6' d='M3 11h1'/%3E%3Cpath stroke='%235684f7' d='M4 11h1'/%3E%3Cpath stroke='%235583f7' d='M5 11h1'/%3E%3Cpath stroke='%234d80f6' d='M7 11h1'/%3E%3Cpath stroke='%23487df6' d='M8 11h1'/%3E%3Cpath stroke='%23bcd1fc' d='M9 11h1'/%3E%3Cpath stroke='%23dde8fd' d='M11 11h1'/%3E%3Cpath stroke='%235f97f8' d='M12 11h1'/%3E%3Cpath stroke='%232673f7' d='M13 11h1'/%3E%3Cpath stroke='%232171f7' d='M14 11h1'/%3E%3Cpath stroke='%231c6ff6' d='M15 11h1'/%3E%3Cpath stroke='%231c6df6' d='M16 11h1'/%3E%3Cpath stroke='%231c6af4' d='M17 11h1'/%3E%3Cpath stroke='%231c61e6' d='M18 11h1'/%3E%3Cpath stroke='%231248bf' d='M19 11h1'/%3E%3Cpath stroke='%232b66f4' d='M1 12h1'/%3E%3Cpath stroke='%234e7ff6' d='M3 12h1'/%3E%3Cpath stroke='%235383f6' d='M5 12h1'/%3E%3Cpath stroke='%235182f6' d='M6 12h1'/%3E%3Cpath stroke='%234d81f7' d='M7 12h1'/%3E%3Cpath stroke='%23487ff6' d='M8 12h1'/%3E%3Cpath stroke='%23dfe9fd' d='M9 12h1'/%3E%3Cpath stroke='%234687f7' d='M11 12h1'/%3E%3Cpath stroke='%232d7af7' d='M12 12h1'/%3E%3Cpath stroke='%232677f7' d='M13 12h1'/%3E%3Cpath stroke='%232174f7' d='M14 12h1'/%3E%3Cpath stroke='%231b71f7' d='M15 12h1'/%3E%3Cpath stroke='%23186ef7' d='M16 12h1'/%3E%3Cpath stroke='%23186af4' d='M17 12h1'/%3E%3Cpath stroke='%23165fe7' d='M18 12h1'/%3E%3Cpath stroke='%230f47c0' d='M19 12h1'/%3E%3Cpath stroke='%232562f3' d='M1 13h1'/%3E%3Cpath stroke='%233d73f4' d='M2 13h1'/%3E%3Cpath stroke='%23487bf5' d='M3 13h1'/%3E%3Cpath stroke='%234e80f6' d='M4 13h1'/%3E%3Cpath stroke='%235081f6' d='M5 13h1'/%3E%3Cpath stroke='%234e81f6' d='M6 13h1'/%3E%3Cpath stroke='%234b80f6' d='M7 13h1'/%3E%3Cpath stroke='%23477ff6' d='M8 13h1'/%3E%3Cpath stroke='%23d2e0fd' d='M9 13h1'/%3E%3Cpath stroke='%23edf3fe' d='M10 13h1'/%3E%3Cpath stroke='%23367ff7' d='M11 13h1'/%3E%3Cpath stroke='%232d7cf7' d='M12 13h1'/%3E%3Cpath stroke='%232679f8' d='M13 13h1'/%3E%3Cpath stroke='%232077f7' d='M14 13h1'/%3E%3Cpath stroke='%231973f7' d='M15 13h1'/%3E%3Cpath stroke='%23166ff7' d='M16 13h1'/%3E%3Cpath stroke='%231369f4' d='M17 13h1'/%3E%3Cpath stroke='%23105de8' d='M18 13h1'/%3E%3Cpath stroke='%230a44bf' d='M19 13h1'/%3E%3Cpath stroke='%231e5df3' d='M1 14h1'/%3E%3Cpath stroke='%23497bf5' d='M4 14h1'/%3E%3Cpath stroke='%234a7ef7' d='M6 14h1'/%3E%3Cpath stroke='%23487ef6' d='M7 14h1'/%3E%3Cpath stroke='%23457ff6' d='M8 14h1'/%3E%3Cpath stroke='%234180f6' d='M9 14h1'/%3E%3Cpath stroke='%233b7ff6' d='M10 14h1'/%3E%3Cpath stroke='%23357ff7' d='M11 14h1'/%3E%3Cpath stroke='%232d7df7' d='M12 14h1'/%3E%3Cpath stroke='%23257af8' d='M13 14h1'/%3E%3Cpath stroke='%231e77f8' d='M14 14h1'/%3E%3Cpath stroke='%231773f8' d='M15 14h1'/%3E%3Cpath stroke='%23116df7' d='M16 14h1'/%3E%3Cpath stroke='%230d66f4' d='M17 14h1m-3 3h1'/%3E%3Cpath stroke='%230b59e7' d='M18 14h1'/%3E%3Cpath stroke='%230641c0' d='M19 14h1m-6 5h1'/%3E%3Cpath stroke='%231859f3' d='M1 15h1'/%3E%3Cpath stroke='%232e68f4' d='M2 15h1'/%3E%3Cpath stroke='%233a71f4' d='M3 15h1'/%3E%3Cpath stroke='%234277f5' d='M4 15h1'/%3E%3Cpath stroke='%23467af5' d='M5 15h1'/%3E%3Cpath stroke='%23457af6' d='M6 15h1'/%3E%3Cpath stroke='%23437bf6' d='M7 15h1'/%3E%3Cpath stroke='%23417cf6' d='M8 15h1'/%3E%3Cpath stroke='%23cbdcfd' d='M9 15h1'/%3E%3Cpath stroke='%23327df7' d='M11 15h1'/%3E%3Cpath stroke='%232a7cf8' d='M12 15h1'/%3E%3Cpath stroke='%23247af8' d='M13 15h1'/%3E%3Cpath stroke='%231d77f8' d='M14 15h1'/%3E%3Cpath stroke='%231573f8' d='M15 15h1'/%3E%3Cpath stroke='%230e6cf8' d='M16 15h1'/%3E%3Cpath stroke='%230963f4' d='M17 15h1'/%3E%3Cpath stroke='%230556e7' d='M18 15h1'/%3E%3Cpath stroke='%23023fbf' d='M19 15h1'/%3E%3Cpath stroke='%231456f3' d='M1 16h1'/%3E%3Cpath stroke='%232562f4' d='M2 16h1'/%3E%3Cpath stroke='%233971f4' d='M4 16h1'/%3E%3Cpath stroke='%233d74f5' d='M5 16h1'/%3E%3Cpath stroke='%233d74f6' d='M6 16h1'/%3E%3Cpath stroke='%233b75f5' d='M7 16h1'/%3E%3Cpath stroke='%233976f5' d='M8 16h1'/%3E%3Cpath stroke='%23f5f8fe' d='M9 16h1'/%3E%3Cpath stroke='%232c78f7' d='M11 16h1'/%3E%3Cpath stroke='%232577f7' d='M12 16h1'/%3E%3Cpath stroke='%231f76f7' d='M13 16h1'/%3E%3Cpath stroke='%231972f7' d='M14 16h1'/%3E%3Cpath stroke='%23116ef8' d='M15 16h1'/%3E%3Cpath stroke='%230b68f7' d='M16 16h1'/%3E%3Cpath stroke='%230560f4' d='M17 16h1'/%3E%3Cpath stroke='%230253e6' d='M18 16h1'/%3E%3Cpath stroke='%23013dbe' d='M19 16h1'/%3E%3Cpath stroke='%230e50ed' d='M1 17h1'/%3E%3Cpath stroke='%231c5bef' d='M2 17h1'/%3E%3Cpath stroke='%232863f0' d='M3 17h1'/%3E%3Cpath stroke='%232f68f0' d='M4 17h1'/%3E%3Cpath stroke='%23336bf1' d='M5 17h1'/%3E%3Cpath stroke='%23346cf1' d='M6 17h1'/%3E%3Cpath stroke='%23316cf2' d='M7 17h1'/%3E%3Cpath stroke='%23316df2' d='M8 17h1'/%3E%3Cpath stroke='%232e6ff2' d='M9 17h1'/%3E%3Cpath stroke='%232a70f2' d='M10 17h1'/%3E%3Cpath stroke='%232570f3' d='M11 17h1'/%3E%3Cpath stroke='%231f6ff3' d='M12 17h1'/%3E%3Cpath stroke='%23196df4' d='M13 17h1'/%3E%3Cpath stroke='%23136af4' d='M14 17h1'/%3E%3Cpath stroke='%230760f3' d='M16 17h1'/%3E%3Cpath stroke='%23025af0' d='M17 17h1'/%3E%3Cpath stroke='%23004de2' d='M18 17h1'/%3E%3Cpath stroke='%23003ab9' d='M19 17h1'/%3E%3Cpath stroke='%23285edf' d='M1 18h1'/%3E%3Cpath stroke='%23134fdf' d='M2 18h1'/%3E%3Cpath stroke='%231b55df' d='M3 18h1'/%3E%3Cpath stroke='%23215ae2' d='M4 18h1'/%3E%3Cpath stroke='%23255ce1' d='M5 18h1'/%3E%3Cpath stroke='%23265de0' d='M6 18h1'/%3E%3Cpath stroke='%23245ce1' d='M7 18h1'/%3E%3Cpath stroke='%23235ee2' d='M8 18h1'/%3E%3Cpath stroke='%23215ee2' d='M9 18h1'/%3E%3Cpath stroke='%231e5ee2' d='M10 18h1'/%3E%3Cpath stroke='%231b5fe5' d='M11 18h1'/%3E%3Cpath stroke='%23165ee5' d='M12 18h1'/%3E%3Cpath stroke='%23135de6' d='M13 18h1'/%3E%3Cpath stroke='%230e5be5' d='M14 18h1'/%3E%3Cpath stroke='%230958e6' d='M15 18h1'/%3E%3Cpath stroke='%230454e6' d='M16 18h1'/%3E%3Cpath stroke='%23014ee2' d='M17 18h1'/%3E%3Cpath stroke='%230045d3' d='M18 18h1'/%3E%3Cpath stroke='%231f4eb8' d='M19 18h1'/%3E%3Cpath stroke='%23d0daf1' d='M1 19h1'/%3E%3Cpath stroke='%232856c3' d='M2 19h1'/%3E%3Cpath stroke='%230d3fb6' d='M3 19h1'/%3E%3Cpath stroke='%231144bd' d='M4 19h1'/%3E%3Cpath stroke='%231245bb' d='M5 19h1'/%3E%3Cpath stroke='%231445b9' d='M6 19h1'/%3E%3Cpath stroke='%231244b9' d='M7 19h1'/%3E%3Cpath stroke='%231345bc' d='M8 19h1'/%3E%3Cpath stroke='%231346bd' d='M9 19h1'/%3E%3Cpath stroke='%231045be' d='M10 19h1'/%3E%3Cpath stroke='%230d45c0' d='M11 19h1'/%3E%3Cpath stroke='%230a45c1' d='M12 19h1'/%3E%3Cpath stroke='%230844c3' d='M13 19h1'/%3E%3Cpath stroke='%23033fc0' d='M15 19h1'/%3E%3Cpath stroke='%23013fc3' d='M16 19h1'/%3E%3Cpath stroke='%23003bbe' d='M17 19h1'/%3E%3Cpath stroke='%231f4eb9' d='M18 19h1'/%3E%3Cpath stroke='%23cfd8ed' d='M19 19h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Help]:hover {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%2393b1ee' d='M1 0h1'/%3E%3Cpath stroke='%23f3f6fd' d='M2 0h1m17 2h1M0 18h1m17 2h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m8 0h3m8 0h1M0 5h1m7 0h1m3 0h1m7 0h1M0 6h1m6 0h1m5 0h1m6 0h1M0 7h1m12 0h1m6 0h1M0 8h1m12 0h1m6 0h1M0 9h1m12 0h1m6 0h1M0 10h1m10 0h2m7 0h1M0 11h1m9 0h1m9 0h1M0 12h1m9 0h1m9 0h1M0 13h1m19 0h1M0 14h1m19 0h1M0 15h1m9 0h1m9 0h1M0 16h1m9 0h1m9 0h1M0 17h1m19 0h1M3 20h15'/%3E%3Cpath stroke='%23f5f7fd' d='M18 0h1M0 2h1m19 16h1M2 20h1'/%3E%3Cpath stroke='%2393b1ed' d='M19 0h1M0 1h1'/%3E%3Cpath stroke='%23dce7ff' d='M1 1h1'/%3E%3Cpath stroke='%2372a1ff' d='M2 1h1m2 5h1'/%3E%3Cpath stroke='%236a9cff' d='M3 1h1'/%3E%3Cpath stroke='%235f94ff' d='M4 1h1M4 11h2'/%3E%3Cpath stroke='%23558eff' d='M5 1h1M3 12h1'/%3E%3Cpath stroke='%23518bff' d='M6 1h1'/%3E%3Cpath stroke='%234a86ff' d='M7 1h1'/%3E%3Cpath stroke='%234b87ff' d='M8 1h1M2 12h1'/%3E%3Cpath stroke='%234684ff' d='M9 1h2'/%3E%3Cpath stroke='%234482ff' d='M11 1h1m4 1h1M1 9h1m0 4h1'/%3E%3Cpath stroke='%234080ff' d='M12 1h1M3 15h1'/%3E%3Cpath stroke='%233b7cff' d='M13 1h1'/%3E%3Cpath stroke='%233a7bff' d='M14 1h1'/%3E%3Cpath stroke='%233678ff' d='M15 1h1'/%3E%3Cpath stroke='%232e73ff' d='M16 1h1'/%3E%3Cpath stroke='%23276cf9' d='M17 1h1'/%3E%3Cpath stroke='%233a73e7' d='M18 1h1'/%3E%3Cpath stroke='%23d3ddf3' d='M19 1h1'/%3E%3Cpath stroke='%2393b0ed' d='M20 1h1'/%3E%3Cpath stroke='%2373a1ff' d='M1 2h1'/%3E%3Cpath stroke='%2397b9ff' d='M2 2h1'/%3E%3Cpath stroke='%239cbdff' d='M3 2h1'/%3E%3Cpath stroke='%2390b5ff' d='M4 2h1'/%3E%3Cpath stroke='%2382acff' d='M5 2h1M5 4h1'/%3E%3Cpath stroke='%237ba7ff' d='M6 2h1M2 6h1'/%3E%3Cpath stroke='%2375a3ff' d='M7 2h1'/%3E%3Cpath stroke='%236f9fff' d='M8 2h1M3 8h1'/%3E%3Cpath stroke='%236c9dff' d='M9 2h1M1 3h1'/%3E%3Cpath stroke='%23689bff' d='M10 2h1M5 8h1M3 9h1'/%3E%3Cpath stroke='%236599ff' d='M11 2h1m0 1h1M5 9h1'/%3E%3Cpath stroke='%236095ff' d='M12 2h1m0 1h1'/%3E%3Cpath stroke='%235d93ff' d='M13 2h1'/%3E%3Cpath stroke='%23568eff' d='M14 2h1'/%3E%3Cpath stroke='%234f8aff' d='M15 2h1M3 13h1m0 1h1'/%3E%3Cpath stroke='%233878fb' d='M17 2h1'/%3E%3Cpath stroke='%232969eb' d='M18 2h1'/%3E%3Cpath stroke='%233566cb' d='M19 2h1'/%3E%3Cpath stroke='%239ebeff' d='M2 3h1'/%3E%3Cpath stroke='%23a4c2ff' d='M3 3h1'/%3E%3Cpath stroke='%2399baff' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%238ab0ff' d='M5 3h1'/%3E%3Cpath stroke='%2382abff' d='M6 3h1'/%3E%3Cpath stroke='%2379a6ff' d='M7 3h1'/%3E%3Cpath stroke='%2374a3ff' d='M8 3h1'/%3E%3Cpath stroke='%2371a0ff' d='M9 3h1'/%3E%3Cpath stroke='%236d9eff' d='M10 3h1M5 7h1M4 8h1'/%3E%3Cpath stroke='%23699bff' d='M11 3h1'/%3E%3Cpath stroke='%235a91ff' d='M14 3h1M2 10h1m1 2h1'/%3E%3Cpath stroke='%23538cff' d='M15 3h1M2 11h1'/%3E%3Cpath stroke='%234986ff' d='M16 3h1'/%3E%3Cpath stroke='%233d7cfc' d='M17 3h1'/%3E%3Cpath stroke='%232e6cea' d='M18 3h1'/%3E%3Cpath stroke='%231b52c2' d='M19 3h1'/%3E%3Cpath stroke='%236296ff' d='M1 4h1'/%3E%3Cpath stroke='%2391b5ff' d='M2 4h1'/%3E%3Cpath stroke='%238fb4ff' d='M4 4h1'/%3E%3Cpath stroke='%237aa6ff' d='M6 4h1m7 1h1'/%3E%3Cpath stroke='%239bbdff' d='M7 4h1'/%3E%3Cpath stroke='%23e3edff' d='M8 4h1'/%3E%3Cpath stroke='%23e1ebff' d='M12 4h1'/%3E%3Cpath stroke='%2387afff' d='M13 4h1'/%3E%3Cpath stroke='%234c88ff' d='M14 4h1m-5 2h1m-6 9h1'/%3E%3Cpath stroke='%234785ff' d='M15 4h1'/%3E%3Cpath stroke='%234280ff' d='M16 4h1'/%3E%3Cpath stroke='%233b7afb' d='M17 4h1'/%3E%3Cpath stroke='%23316fec' d='M18 4h1'/%3E%3Cpath stroke='%231f55c3' d='M19 4h1'/%3E%3Cpath stroke='%235990ff' d='M1 5h1'/%3E%3Cpath stroke='%2385adff' d='M2 5h1'/%3E%3Cpath stroke='%238bb1ff' d='M3 5h1'/%3E%3Cpath stroke='%2384acff' d='M4 5h1'/%3E%3Cpath stroke='%2378a5ff' d='M5 5h1'/%3E%3Cpath stroke='%239bf' d='M6 5h1'/%3E%3Cpath stroke='%23f4f7ff' d='M7 5h1'/%3E%3Cpath stroke='%23dbe7ff' d='M9 5h1'/%3E%3Cpath stroke='%23d2e1ff' d='M10 5h1'/%3E%3Cpath stroke='%23edf3ff' d='M11 5h1'/%3E%3Cpath stroke='%23f0f5ff' d='M13 5h1'/%3E%3Cpath stroke='%233b7bff' d='M15 5h1'/%3E%3Cpath stroke='%23397aff' d='M16 5h1M1 11h1'/%3E%3Cpath stroke='%233979fc' d='M17 5h1'/%3E%3Cpath stroke='%233370ec' d='M18 5h1m-1 1h1'/%3E%3Cpath stroke='%232357c3' d='M19 5h1'/%3E%3Cpath stroke='%23548dff' d='M1 6h1m2 7h1'/%3E%3Cpath stroke='%2381aaff' d='M3 6h1'/%3E%3Cpath stroke='%237aa7ff' d='M4 6h1'/%3E%3Cpath stroke='%23d8e5ff' d='M6 6h1'/%3E%3Cpath stroke='%23b9d0ff' d='M8 6h1'/%3E%3Cpath stroke='%23548eff' d='M9 6h1'/%3E%3Cpath stroke='%23538dff' d='M11 6h1'/%3E%3Cpath stroke='%23cbdcff' d='M12 6h1'/%3E%3Cpath stroke='%23c9dbff' d='M14 6h1'/%3E%3Cpath stroke='%233579ff' d='M15 6h1'/%3E%3Cpath stroke='%233679ff' d='M16 6h1'/%3E%3Cpath stroke='%233879fc' d='M17 6h1'/%3E%3Cpath stroke='%232358c5' d='M19 6h1'/%3E%3Cpath stroke='%234e89ff' d='M1 7h1'/%3E%3Cpath stroke='%2371a1ff' d='M2 7h1'/%3E%3Cpath stroke='%2377a5ff' d='M3 7h1'/%3E%3Cpath stroke='%2374a2ff' d='M4 7h1'/%3E%3Cpath stroke='%23e8f0ff' d='M6 7h1'/%3E%3Cpath stroke='%23e7efff' d='M7 7h1'/%3E%3Cpath stroke='%23679aff' d='M8 7h1'/%3E%3Cpath stroke='%23508dff' d='M9 7h1'/%3E%3Cpath stroke='%234989ff' d='M10 7h1'/%3E%3Cpath stroke='%234183ff' d='M11 7h1'/%3E%3Cpath stroke='%2374a5ff' d='M12 7h1'/%3E%3Cpath stroke='%23d1e1ff' d='M14 7h1'/%3E%3Cpath stroke='%23317aff' d='M15 7h1'/%3E%3Cpath stroke='%23337aff' d='M16 7h1'/%3E%3Cpath stroke='%23367bfc' d='M17 7h1'/%3E%3Cpath stroke='%233372ed' d='M18 7h1'/%3E%3Cpath stroke='%232359c5' d='M19 7h1'/%3E%3Cpath stroke='%234d88ff' d='M1 8h1'/%3E%3Cpath stroke='%23699cff' d='M2 8h1'/%3E%3Cpath stroke='%236398ff' d='M6 8h1'/%3E%3Cpath stroke='%235c93ff' d='M7 8h1m-2 3h1'/%3E%3Cpath stroke='%23548fff' d='M8 8h1'/%3E%3Cpath stroke='%234d8cff' d='M9 8h1'/%3E%3Cpath stroke='%23468aff' d='M10 8h1'/%3E%3Cpath stroke='%233f86ff' d='M11 8h1'/%3E%3Cpath stroke='%238cb7ff' d='M12 8h1'/%3E%3Cpath stroke='%23cde0ff' d='M14 8h1'/%3E%3Cpath stroke='%232f7fff' d='M15 8h1'/%3E%3Cpath stroke='%233280ff' d='M16 8h1'/%3E%3Cpath stroke='%233580fc' d='M17 8h1'/%3E%3Cpath stroke='%233276ed' d='M18 8h1'/%3E%3Cpath stroke='%23235ac6' d='M19 8h1'/%3E%3Cpath stroke='%236196ff' d='M2 9h1m3 0h1m-4 1h1'/%3E%3Cpath stroke='%23689aff' d='M4 9h1'/%3E%3Cpath stroke='%235b93ff' d='M7 9h1'/%3E%3Cpath stroke='%235491ff' d='M8 9h1'/%3E%3Cpath stroke='%234f90ff' d='M9 9h1'/%3E%3Cpath stroke='%234890ff' d='M10 9h1'/%3E%3Cpath stroke='%239dc5ff' d='M11 9h1'/%3E%3Cpath stroke='%23f3f8ff' d='M12 9h1'/%3E%3Cpath stroke='%239ac5ff' d='M14 9h1'/%3E%3Cpath stroke='%232f88ff' d='M15 9h1'/%3E%3Cpath stroke='%233188ff' d='M16 9h1'/%3E%3Cpath stroke='%233385fc' d='M17 9h1'/%3E%3Cpath stroke='%233079ed' d='M18 9h1'/%3E%3Cpath stroke='%23215cc8' d='M19 9h1'/%3E%3Cpath stroke='%233f7fff' d='M1 10h1'/%3E%3Cpath stroke='%236397ff' d='M4 10h1'/%3E%3Cpath stroke='%236297ff' d='M5 10h1'/%3E%3Cpath stroke='%235f95ff' d='M6 10h1'/%3E%3Cpath stroke='%235993ff' d='M7 10h1'/%3E%3Cpath stroke='%235492ff' d='M8 10h1'/%3E%3Cpath stroke='%235c9aff' d='M9 10h1'/%3E%3Cpath stroke='%23cee2ff' d='M10 10h1'/%3E%3Cpath stroke='%23a7d0ff' d='M13 10h1'/%3E%3Cpath stroke='%233897ff' d='M14 10h1'/%3E%3Cpath stroke='%232f92ff' d='M15 10h1'/%3E%3Cpath stroke='%233090ff' d='M16 10h1'/%3E%3Cpath stroke='%23328cfc' d='M17 10h1'/%3E%3Cpath stroke='%232e7def' d='M18 10h1'/%3E%3Cpath stroke='%231e5dc9' d='M19 10h1'/%3E%3Cpath stroke='%235c92ff' d='M3 11h1m1 1h1'/%3E%3Cpath stroke='%235792ff' d='M7 11h1m-1 1h1'/%3E%3Cpath stroke='%235594ff' d='M8 11h1'/%3E%3Cpath stroke='%23c2dbff' d='M9 11h1'/%3E%3Cpath stroke='%23e0efff' d='M11 11h1'/%3E%3Cpath stroke='%236eb6ff' d='M12 11h1'/%3E%3Cpath stroke='%23379fff' d='M13 11h1'/%3E%3Cpath stroke='%23339dff' d='M14 11h1'/%3E%3Cpath stroke='%232f9bff' d='M15 11h1'/%3E%3Cpath stroke='%232e97ff' d='M16 11h1'/%3E%3Cpath stroke='%232e91fc' d='M17 11h1'/%3E%3Cpath stroke='%232a80f0' d='M18 11h1'/%3E%3Cpath stroke='%231b5dcb' d='M19 11h1'/%3E%3Cpath stroke='%233275ff' d='M1 12h1'/%3E%3Cpath stroke='%235991ff' d='M6 12h1'/%3E%3Cpath stroke='%235596ff' d='M8 12h1'/%3E%3Cpath stroke='%23e2eeff' d='M9 12h1'/%3E%3Cpath stroke='%2359adff' d='M11 12h1'/%3E%3Cpath stroke='%2342a9ff' d='M12 12h1'/%3E%3Cpath stroke='%233aa9ff' d='M13 12h1'/%3E%3Cpath stroke='%2334a7ff' d='M14 12h1'/%3E%3Cpath stroke='%2330a5ff' d='M15 12h1'/%3E%3Cpath stroke='%232ca0ff' d='M16 12h1'/%3E%3Cpath stroke='%232a96fd' d='M17 12h1'/%3E%3Cpath stroke='%232581f1' d='M18 12h1'/%3E%3Cpath stroke='%23185dcc' d='M19 12h1'/%3E%3Cpath stroke='%232d72ff' d='M1 13h1m0 3h1'/%3E%3Cpath stroke='%235790ff' d='M5 13h2'/%3E%3Cpath stroke='%235490ff' d='M7 13h1'/%3E%3Cpath stroke='%235597ff' d='M8 13h1'/%3E%3Cpath stroke='%23d6e8ff' d='M9 13h1'/%3E%3Cpath stroke='%23eef6ff' d='M10 13h1'/%3E%3Cpath stroke='%234aaaff' d='M11 13h1'/%3E%3Cpath stroke='%2344afff' d='M12 13h1'/%3E%3Cpath stroke='%233eb1ff' d='M13 13h1'/%3E%3Cpath stroke='%2337afff' d='M14 13h1'/%3E%3Cpath stroke='%232fabff' d='M15 13h1'/%3E%3Cpath stroke='%2329a4ff' d='M16 13h1'/%3E%3Cpath stroke='%232599fd' d='M17 13h1'/%3E%3Cpath stroke='%231e80f2' d='M18 13h1'/%3E%3Cpath stroke='%23145bcd' d='M19 13h1'/%3E%3Cpath stroke='%23276eff' d='M1 14h1'/%3E%3Cpath stroke='%233d7dff' d='M2 14h1'/%3E%3Cpath stroke='%234985ff' d='M3 14h1'/%3E%3Cpath stroke='%23528cff' d='M5 14h1'/%3E%3Cpath stroke='%23528dff' d='M6 14h1'/%3E%3Cpath stroke='%23518fff' d='M7 14h1'/%3E%3Cpath stroke='%235196ff' d='M8 14h1'/%3E%3Cpath stroke='%23509fff' d='M9 14h1'/%3E%3Cpath stroke='%234ea6ff' d='M10 14h1'/%3E%3Cpath stroke='%2349acff' d='M11 14h1'/%3E%3Cpath stroke='%2343b1ff' d='M12 14h1'/%3E%3Cpath stroke='%233eb4ff' d='M13 14h1'/%3E%3Cpath stroke='%2335b2ff' d='M14 14h1'/%3E%3Cpath stroke='%232caeff' d='M15 14h1'/%3E%3Cpath stroke='%2324a5ff' d='M16 14h1'/%3E%3Cpath stroke='%231f97fd' d='M17 14h1'/%3E%3Cpath stroke='%231980f3' d='M18 14h1'/%3E%3Cpath stroke='%23105ace' d='M19 14h1'/%3E%3Cpath stroke='%23216aff' d='M1 15h1'/%3E%3Cpath stroke='%233578ff' d='M2 15h1'/%3E%3Cpath stroke='%234885ff' d='M4 15h1'/%3E%3Cpath stroke='%234d89ff' d='M6 15h1'/%3E%3Cpath stroke='%234c8cff' d='M7 15h1'/%3E%3Cpath stroke='%234d94ff' d='M8 15h1'/%3E%3Cpath stroke='%23cfe4ff' d='M9 15h1'/%3E%3Cpath stroke='%2347aaff' d='M11 15h1'/%3E%3Cpath stroke='%2341afff' d='M12 15h1'/%3E%3Cpath stroke='%233bb2ff' d='M13 15h1'/%3E%3Cpath stroke='%2333b1ff' d='M14 15h1'/%3E%3Cpath stroke='%232aadff' d='M15 15h1'/%3E%3Cpath stroke='%2321a3ff' d='M16 15h1'/%3E%3Cpath stroke='%231a95fd' d='M17 15h1'/%3E%3Cpath stroke='%23137cf2' d='M18 15h1'/%3E%3Cpath stroke='%230c59cf' d='M19 15h1'/%3E%3Cpath stroke='%231c66ff' d='M1 16h1'/%3E%3Cpath stroke='%233879ff' d='M3 16h1'/%3E%3Cpath stroke='%233f7eff' d='M4 16h1'/%3E%3Cpath stroke='%234483ff' d='M5 16h1'/%3E%3Cpath stroke='%234584ff' d='M6 16h1'/%3E%3Cpath stroke='%234587ff' d='M7 16h1'/%3E%3Cpath stroke='%23468eff' d='M8 16h1'/%3E%3Cpath stroke='%23f6faff' d='M9 16h1'/%3E%3Cpath stroke='%233fa3ff' d='M11 16h1'/%3E%3Cpath stroke='%233ba8ff' d='M12 16h1'/%3E%3Cpath stroke='%233af' d='M13 16h1'/%3E%3Cpath stroke='%232da9ff' d='M14 16h1'/%3E%3Cpath stroke='%2324a6ff' d='M15 16h1'/%3E%3Cpath stroke='%231d9eff' d='M16 16h1'/%3E%3Cpath stroke='%231690fd' d='M17 16h1'/%3E%3Cpath stroke='%231078f1' d='M18 16h1'/%3E%3Cpath stroke='%230b57ce' d='M19 16h1'/%3E%3Cpath stroke='%231761f9' d='M1 17h1'/%3E%3Cpath stroke='%23246bfa' d='M2 17h1'/%3E%3Cpath stroke='%232f72fb' d='M3 17h1'/%3E%3Cpath stroke='%233676fb' d='M4 17h1'/%3E%3Cpath stroke='%233a7afb' d='M5 17h1'/%3E%3Cpath stroke='%233b7bfc' d='M6 17h1'/%3E%3Cpath stroke='%233b7efc' d='M7 17h1'/%3E%3Cpath stroke='%233c84fc' d='M8 17h1'/%3E%3Cpath stroke='%233b8afc' d='M9 17h1'/%3E%3Cpath stroke='%233990fc' d='M10 17h1'/%3E%3Cpath stroke='%233695fc' d='M11 17h1'/%3E%3Cpath stroke='%233299fc' d='M12 17h1'/%3E%3Cpath stroke='%232c9cfd' d='M13 17h1'/%3E%3Cpath stroke='%23259bfd' d='M14 17h1'/%3E%3Cpath stroke='%231e97fd' d='M15 17h1'/%3E%3Cpath stroke='%231790fc' d='M16 17h1'/%3E%3Cpath stroke='%231184fa' d='M17 17h1'/%3E%3Cpath stroke='%230c6ded' d='M18 17h1'/%3E%3Cpath stroke='%230850c8' d='M19 17h1'/%3E%3Cpath stroke='%232f6ae4' d='M1 18h1'/%3E%3Cpath stroke='%231b5fe9' d='M2 18h1'/%3E%3Cpath stroke='%232163e8' d='M3 18h1'/%3E%3Cpath stroke='%232868eb' d='M4 18h1'/%3E%3Cpath stroke='%232c6aea' d='M5 18h1'/%3E%3Cpath stroke='%232e6dea' d='M6 18h1'/%3E%3Cpath stroke='%232d6deb' d='M7 18h1'/%3E%3Cpath stroke='%232c71ec' d='M8 18h1'/%3E%3Cpath stroke='%232c76ec' d='M9 18h1'/%3E%3Cpath stroke='%232a79ed' d='M10 18h1'/%3E%3Cpath stroke='%23287eef' d='M11 18h1'/%3E%3Cpath stroke='%232481f1' d='M12 18h1'/%3E%3Cpath stroke='%232182f1' d='M13 18h1'/%3E%3Cpath stroke='%231c80f1' d='M14 18h1'/%3E%3Cpath stroke='%231880f3' d='M15 18h1'/%3E%3Cpath stroke='%23117af2' d='M16 18h1'/%3E%3Cpath stroke='%230c6eed' d='M17 18h1'/%3E%3Cpath stroke='%230a5ddd' d='M18 18h1'/%3E%3Cpath stroke='%23265dc1' d='M19 18h1'/%3E%3Cpath stroke='%2393b4f2' d='M0 19h1'/%3E%3Cpath stroke='%23d1ddf4' d='M1 19h1'/%3E%3Cpath stroke='%232e61ca' d='M2 19h1'/%3E%3Cpath stroke='%23134bbf' d='M3 19h1'/%3E%3Cpath stroke='%23164fc2' d='M4 19h1'/%3E%3Cpath stroke='%231950c1' d='M5 19h1'/%3E%3Cpath stroke='%231b52c1' d='M6 19h1'/%3E%3Cpath stroke='%231a52c3' d='M7 19h1'/%3E%3Cpath stroke='%231954c6' d='M8 19h1'/%3E%3Cpath stroke='%231b58c9' d='M9 19h1'/%3E%3Cpath stroke='%231858c8' d='M10 19h1'/%3E%3Cpath stroke='%23165bcd' d='M11 19h1'/%3E%3Cpath stroke='%23145cd0' d='M12 19h1'/%3E%3Cpath stroke='%23135cd0' d='M13 19h1'/%3E%3Cpath stroke='%230f58cc' d='M14 19h1'/%3E%3Cpath stroke='%230d5ad2' d='M15 19h1'/%3E%3Cpath stroke='%230b58d1' d='M16 19h1'/%3E%3Cpath stroke='%230951cb' d='M17 19h1'/%3E%3Cpath stroke='%23265ec3' d='M18 19h1'/%3E%3Cpath stroke='%23d0daee' d='M19 19h1'/%3E%3Cpath stroke='%2393b3f2' d='M20 19h1M1 20h1'/%3E%3Cpath stroke='%2393b2f1' d='M19 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Help]:not(:disabled):active {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23a7bdef' d='M1 0h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m15 0h1M0 2h1m19 0h1M0 18h1m19 0h1M2 20h1m15 0h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m19 0h1M0 6h1m19 0h1M0 7h1m19 0h1M0 8h1m19 0h1M0 9h1m19 0h1M0 10h1m19 0h1M0 11h1m19 0h1M0 12h1m19 0h1M0 13h1m19 0h1M0 14h1m19 0h1M0 15h1m19 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h1m5 0h9'/%3E%3Cpath stroke='%23a7bdee' d='M19 0h1M0 1h1'/%3E%3Cpath stroke='%23cfd3da' d='M1 1h1'/%3E%3Cpath stroke='%231f3b5f' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%23002453' d='M3 1h1M1 4h1'/%3E%3Cpath stroke='%23002557' d='M4 1h1'/%3E%3Cpath stroke='%23002658' d='M5 1h1'/%3E%3Cpath stroke='%2300285c' d='M6 1h1'/%3E%3Cpath stroke='%23002a61' d='M7 1h1'/%3E%3Cpath stroke='%23002d67' d='M8 1h1'/%3E%3Cpath stroke='%23002f6b' d='M9 1h1'/%3E%3Cpath stroke='%23002f6c' d='M10 1h1M1 10h1'/%3E%3Cpath stroke='%23003273' d='M11 1h1'/%3E%3Cpath stroke='%23003478' d='M12 1h1M5 2h1'/%3E%3Cpath stroke='%2300357b' d='M13 1h1M2 5h1m-2 8h1'/%3E%3Cpath stroke='%2300377f' d='M14 1h1M6 2h1'/%3E%3Cpath stroke='%23003780' d='M15 1h1'/%3E%3Cpath stroke='%23003984' d='M16 1h1'/%3E%3Cpath stroke='%23003882' d='M17 1h1M3 3h1'/%3E%3Cpath stroke='%231f5295' d='M18 1h1'/%3E%3Cpath stroke='%23cfdae9' d='M19 1h1'/%3E%3Cpath stroke='%23a7bcee' d='M20 1h1'/%3E%3Cpath stroke='%23002a62' d='M2 2h1'/%3E%3Cpath stroke='%23003070' d='M3 2h1'/%3E%3Cpath stroke='%23003275' d='M4 2h1'/%3E%3Cpath stroke='%23003883' d='M7 2h1M1 17h1'/%3E%3Cpath stroke='%23003a88' d='M8 2h1'/%3E%3Cpath stroke='%23003d8f' d='M9 2h1M2 9h1'/%3E%3Cpath stroke='%23003e90' d='M10 2h1'/%3E%3Cpath stroke='%23004094' d='M11 2h1'/%3E%3Cpath stroke='%23004299' d='M12 2h1M2 12h1'/%3E%3Cpath stroke='%2300439b' d='M13 2h1'/%3E%3Cpath stroke='%2300449e' d='M14 2h1M2 14h1'/%3E%3Cpath stroke='%2300459f' d='M15 2h1'/%3E%3Cpath stroke='%230045a1' d='M16 2h1m1 0h1M2 17h1'/%3E%3Cpath stroke='%230045a0' d='M17 2h1M2 15h1'/%3E%3Cpath stroke='%231f5aa8' d='M19 2h1'/%3E%3Cpath stroke='%23002452' d='M1 3h1'/%3E%3Cpath stroke='%23003170' d='M2 3h1'/%3E%3Cpath stroke='%23003b8b' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%23003c8f' d='M5 3h1'/%3E%3Cpath stroke='%23003e94' d='M6 3h1'/%3E%3Cpath stroke='%23004099' d='M7 3h1'/%3E%3Cpath stroke='%2300429d' d='M8 3h1'/%3E%3Cpath stroke='%230044a2' d='M9 3h1'/%3E%3Cpath stroke='%230046a5' d='M10 3h1'/%3E%3Cpath stroke='%230048a8' d='M11 3h1'/%3E%3Cpath stroke='%230049ab' d='M12 3h1'/%3E%3Cpath stroke='%23004aac' d='M13 3h1'/%3E%3Cpath stroke='%23004aad' d='M14 3h1'/%3E%3Cpath stroke='%23004bae' d='M15 3h2m1 0h1M3 14h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23004baf' d='M17 3h1M7 10h1m-5 7h1m-1 1h1'/%3E%3Cpath stroke='%23004bad' d='M19 3h1M3 13h1m-1 6h1'/%3E%3Cpath stroke='%23037' d='M2 4h1m-2 8h1'/%3E%3Cpath stroke='%23003d92' d='M4 4h1'/%3E%3Cpath stroke='%23003f97' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%2300419d' d='M6 4h1M4 6h1'/%3E%3Cpath stroke='%230a4aa5' d='M7 4h1'/%3E%3Cpath stroke='%234e7ec0' d='M8 4h1'/%3E%3Cpath stroke='%23789ed1' d='M9 4h1'/%3E%3Cpath stroke='%23789ed3' d='M10 4h1'/%3E%3Cpath stroke='%23789fd4' d='M11 4h1m0 1h1'/%3E%3Cpath stroke='%235184c7' d='M12 4h1'/%3E%3Cpath stroke='%230b54b3' d='M13 4h1m0 1h1'/%3E%3Cpath stroke='%23004db1' d='M14 4h3m-2 1h2m-2 1h2M7 12h1m-2 1h1m-3 1h3m-3 1h2m-2 1h2'/%3E%3Cpath stroke='%23004db2' d='M17 4h3m-3 1h3m-2 1h2m-1 1h1m-9 1h1m-4 3h1m-5 6h2m-2 1h4m-4 1h4'/%3E%3Cpath stroke='%23002555' d='M1 5h1'/%3E%3Cpath stroke='%23003d90' d='M3 5h1'/%3E%3Cpath stroke='%2300409c' d='M5 5h1'/%3E%3Cpath stroke='%230949a4' d='M6 5h1'/%3E%3Cpath stroke='%23668ec8' d='M7 5h1'/%3E%3Cpath stroke='%23789dd1' d='M8 5h1M7 6h1'/%3E%3Cpath stroke='%23497cc1' d='M9 5h1'/%3E%3Cpath stroke='%234178c0' d='M10 5h1'/%3E%3Cpath stroke='%23608dcb' d='M11 5h1'/%3E%3Cpath stroke='%236693cf' d='M13 5h1'/%3E%3Cpath stroke='%2300275a' d='M1 6h1'/%3E%3Cpath stroke='%23003781' d='M2 6h1m-2 9h1'/%3E%3Cpath stroke='%23003f95' d='M3 6h1'/%3E%3Cpath stroke='%230042a1' d='M5 6h1'/%3E%3Cpath stroke='%234073bb' d='M6 6h1'/%3E%3Cpath stroke='%232661b6' d='M8 6h1'/%3E%3Cpath stroke='%230047ac' d='M9 6h1'/%3E%3Cpath stroke='%230049ad' d='M10 6h1m-6 5h1'/%3E%3Cpath stroke='%23004aae' d='M11 6h1m-6 5h1m-3 1h2'/%3E%3Cpath stroke='%234077c4' d='M12 6h1'/%3E%3Cpath stroke='%2378a1d6' d='M13 6h1'/%3E%3Cpath stroke='%234079c4' d='M14 6h1'/%3E%3Cpath stroke='%23004eb3' d='M17 6h1m0 1h1m0 1h1M10 9h1m-2 1h1m-3 6h1m-2 1h2m0 2h1'/%3E%3Cpath stroke='%2300295f' d='M1 7h1'/%3E%3Cpath stroke='%23003985' d='M2 7h1'/%3E%3Cpath stroke='%2300419b' d='M3 7h1'/%3E%3Cpath stroke='%230043a2' d='M4 7h1'/%3E%3Cpath stroke='%230044a6' d='M5 7h1'/%3E%3Cpath stroke='%235684c6' d='M6 7h1'/%3E%3Cpath stroke='%235686c8' d='M7 7h1'/%3E%3Cpath stroke='%230049ac' d='M8 7h1m-4 3h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%230049ae' d='M9 7h1M7 8h2m-3 2h1'/%3E%3Cpath stroke='%23004aaf' d='M10 7h1M9 8h1M7 9h1'/%3E%3Cpath stroke='%23004cb1' d='M11 7h1m-2 1h1M9 9h1m-2 1h1'/%3E%3Cpath stroke='%230a53b5' d='M12 7h1'/%3E%3Cpath stroke='%2378a1d7' d='M13 7h1'/%3E%3Cpath stroke='%234881c8' d='M14 7h1'/%3E%3Cpath stroke='%23004fb4' d='M15 7h3m0 1h1m0 1h1M8 12h1m-2 3h1m0 3h1m0 1h1'/%3E%3Cpath stroke='%23002b63' d='M1 8h1'/%3E%3Cpath stroke='%23003b8a' d='M2 8h1'/%3E%3Cpath stroke='%2300439f' d='M3 8h1'/%3E%3Cpath stroke='%230045a5' d='M4 8h1'/%3E%3Cpath stroke='%230046a8' d='M5 8h1'/%3E%3Cpath stroke='%230047ab' d='M6 8h1M5 9h1'/%3E%3Cpath stroke='%23145db9' d='M12 8h1'/%3E%3Cpath stroke='%2378a2d8' d='M13 8h1'/%3E%3Cpath stroke='%23457fc8' d='M14 8h1'/%3E%3Cpath stroke='%230051b6' d='M15 8h1m2 1h1m0 2h1m-1 1h1M8 14h1m-1 1h1m10 2h1M9 18h1m1 1h1'/%3E%3Cpath stroke='%230050b5' d='M16 8h2m1 2h1M8 13h1m-1 3h1m-1 1h1m1 2h1'/%3E%3Cpath stroke='%23002d68' d='M1 9h1'/%3E%3Cpath stroke='%230045a3' d='M3 9h1'/%3E%3Cpath stroke='%230047a8' d='M4 9h1'/%3E%3Cpath stroke='%230048ad' d='M6 9h1'/%3E%3Cpath stroke='%23004bb0' d='M8 9h1m-3 3h1m-2 1h1'/%3E%3Cpath stroke='%231b62bd' d='M11 9h1'/%3E%3Cpath stroke='%236899d4' d='M12 9h1'/%3E%3Cpath stroke='%2378a4d9' d='M13 9h1'/%3E%3Cpath stroke='%231f68c1' d='M14 9h1'/%3E%3Cpath stroke='%230054b9' d='M15 9h1m-7 5h1m8 4h1m-4 1h1'/%3E%3Cpath stroke='%230053b8' d='M16 9h2m0 1h1m0 4h1m-1 2h1M9 17h1m0 1h1m3 1h1m1 0h1'/%3E%3Cpath stroke='%23003f93' d='M2 10h1'/%3E%3Cpath stroke='%230047a7' d='M3 10h1'/%3E%3Cpath stroke='%230048ab' d='M4 10h1'/%3E%3Cpath stroke='%23407cc7' d='M10 10h1'/%3E%3Cpath stroke='%2378a3d9' d='M11 10h1m-2 1h1'/%3E%3Cpath stroke='%2378a5da' d='M12 10h1m-3 2h1'/%3E%3Cpath stroke='%23256ec4' d='M13 10h1'/%3E%3Cpath stroke='%230057bb' d='M14 10h1'/%3E%3Cpath stroke='%230057bc' d='M15 10h1m-5 2h1m-2 2h1m7 3h1m-7 1h1m4 0h1'/%3E%3Cpath stroke='%230056bb' d='M16 10h1m1 2h1'/%3E%3Cpath stroke='%230055ba' d='M17 10h1m0 1h1m-9 6h1m0 1h1'/%3E%3Cpath stroke='%23003172' d='M1 11h1'/%3E%3Cpath stroke='%23004095' d='M2 11h1'/%3E%3Cpath stroke='%230048aa' d='M3 11h1'/%3E%3Cpath stroke='%23004cb0' d='M7 11h1m-4 2h1'/%3E%3Cpath stroke='%233272c4' d='M9 11h1'/%3E%3Cpath stroke='%23538cd0' d='M11 11h1'/%3E%3Cpath stroke='%23065cbf' d='M12 11h1'/%3E%3Cpath stroke='%230059be' d='M13 11h1m2 0h1m-6 2h1m-1 3h1m6 0h1m-5 2h1m1 0h1'/%3E%3Cpath stroke='%23005abf' d='M14 11h2m-4 1h1m4 0h1m-7 2h1m-1 1h1m0 2h1m2 1h1'/%3E%3Cpath stroke='%230058bd' d='M17 11h1m0 2h1m-6 5h1'/%3E%3Cpath stroke='%23538ace' d='M9 12h1'/%3E%3Cpath stroke='%23005cc1' d='M13 12h1m2 0h1m-5 1h1m4 0h1m-5 4h1'/%3E%3Cpath stroke='%23005dc2' d='M14 12h1m-3 2h1m4 0h1m-6 1h1m4 1h1m-4 1h1m1 0h1'/%3E%3Cpath stroke='%23005ec3' d='M15 12h1m-3 1h1m2 0h1m0 2h1m-5 1h1m1 1h1'/%3E%3Cpath stroke='%2300449d' d='M2 13h1'/%3E%3Cpath stroke='%23004eb2' d='M7 13h1m-2 2h1m-1 1h1'/%3E%3Cpath stroke='%234581cb' d='M9 13h1'/%3E%3Cpath stroke='%236297d5' d='M10 13h1'/%3E%3Cpath stroke='%23005fc4' d='M14 13h1m-2 1h1m2 0h1m-4 1h1'/%3E%3Cpath stroke='%230060c5' d='M15 13h1m-2 1h1m1 1h1m-2 1h1'/%3E%3Cpath stroke='%230052b7' d='M19 13h1m-8 6h2m3 0h1'/%3E%3Cpath stroke='%2300367e' d='M1 14h1'/%3E%3Cpath stroke='%23004fb3' d='M7 14h1'/%3E%3Cpath stroke='%230061c6' d='M15 14h1m-2 1h1'/%3E%3Cpath stroke='%230059bd' d='M18 14h1'/%3E%3Cpath stroke='%23407fca' d='M9 15h1'/%3E%3Cpath stroke='%2378a6dc' d='M10 15h1'/%3E%3Cpath stroke='%230062c6' d='M15 15h1'/%3E%3Cpath stroke='%23005abe' d='M18 15h1'/%3E%3Cpath stroke='%230054b8' d='M19 15h1'/%3E%3Cpath stroke='%23003881' d='M1 16h1'/%3E%3Cpath stroke='%230046a1' d='M2 16h1'/%3E%3Cpath stroke='%236c9bd5' d='M9 16h1'/%3E%3Cpath stroke='%2378a6db' d='M10 16h1'/%3E%3Cpath stroke='%23005cc0' d='M12 16h1'/%3E%3Cpath stroke='%23005fc3' d='M14 16h1'/%3E%3Cpath stroke='%230060c4' d='M16 16h1'/%3E%3Cpath stroke='%230058bc' d='M11 17h1'/%3E%3Cpath stroke='%23005bc0' d='M17 17h1'/%3E%3Cpath stroke='%231f5294' d='M1 18h1'/%3E%3Cpath stroke='%230046a2' d='M2 18h1'/%3E%3Cpath stroke='%231f66be' d='M19 18h1'/%3E%3Cpath stroke='%23a7bef0' d='M0 19h1m19 0h1M1 20h1'/%3E%3Cpath stroke='%23cfdae8' d='M1 19h1'/%3E%3Cpath stroke='%231f5ba9' d='M2 19h1'/%3E%3Cpath stroke='%231f66bf' d='M18 19h1'/%3E%3Cpath stroke='%23cfdef1' d='M19 19h1'/%3E%3Cpath stroke='%23fefefe' d='M4 20h1m3 0h1'/%3E%3Cpath stroke='%23fdfdfd' d='M5 20h1m1 0h1'/%3E%3Cpath stroke='%23fcfcfc' d='M6 20h1'/%3E%3Cpath stroke='%23a7bdf0' d='M19 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Close] {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23b3c4ef' d='M1 0h1m17 0h1M0 1h1m19 0h1M0 19h1m19 0h1M1 20h1m17 0h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m17 2h1M0 18h1m17 2h1'/%3E%3Cpath stroke='%23fff' d='M3 0h16M0 2h1M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m5 0h1m7 0h1m5 0h1M0 6h1m4 0h3m5 0h3m4 0h1M0 7h1m5 0h3m3 0h3m5 0h1M0 8h1m6 0h3m1 0h3m6 0h1M0 9h1m7 0h5m7 0h1M0 10h1m8 0h3m8 0h1M0 11h1m7 0h5m7 0h1M0 12h1m6 0h3m1 0h2m7 0h1M0 13h1m5 0h3m3 0h3m5 0h1M0 14h1m4 0h3m5 0h3m4 0h1M0 15h1m5 0h1m7 0h1m5 0h1M0 16h1m19 0h1M0 17h1m19 0h1m-1 1h1M2 20h16'/%3E%3Cpath stroke='%23fae1dc' d='M1 1h1'/%3E%3Cpath stroke='%23eb8b73' d='M2 1h1'/%3E%3Cpath stroke='%23e97b60' d='M3 1h1'/%3E%3Cpath stroke='%23e77155' d='M4 1h1'/%3E%3Cpath stroke='%23e66a4d' d='M5 1h1M1 6h1m5 4h1'/%3E%3Cpath stroke='%23e56648' d='M6 1h1'/%3E%3Cpath stroke='%23e46142' d='M7 1h1'/%3E%3Cpath stroke='%23e46344' d='M8 1h1m5 3h1M2 12h1'/%3E%3Cpath stroke='%23e45f3e' d='M9 1h2'/%3E%3Cpath stroke='%23e35c3b' d='M11 1h2'/%3E%3Cpath stroke='%23e25633' d='M13 1h2'/%3E%3Cpath stroke='%23e25330' d='M15 1h1'/%3E%3Cpath stroke='%23e04d28' d='M16 1h1'/%3E%3Cpath stroke='%23dc451f' d='M17 1h1'/%3E%3Cpath stroke='%23d05334' d='M18 1h1'/%3E%3Cpath stroke='%23efd8d2' d='M19 1h1'/%3E%3Cpath stroke='%23ec8d76' d='M1 2h1'/%3E%3Cpath stroke='%23efa390' d='M2 2h1'/%3E%3Cpath stroke='%23f0a694' d='M3 2h1'/%3E%3Cpath stroke='%23ee9a85' d='M4 2h1'/%3E%3Cpath stroke='%23eb8d75' d='M5 2h1'/%3E%3Cpath stroke='%23ea876e' d='M6 2h1'/%3E%3Cpath stroke='%23ea8168' d='M7 2h1'/%3E%3Cpath stroke='%23e97f66' d='M8 2h1'/%3E%3Cpath stroke='%23e97c62' d='M9 2h1m0 1h1'/%3E%3Cpath stroke='%23e8795f' d='M10 2h1'/%3E%3Cpath stroke='%23e8795e' d='M11 2h1'/%3E%3Cpath stroke='%23e87559' d='M12 2h1'/%3E%3Cpath stroke='%23e77256' d='M13 2h1'/%3E%3Cpath stroke='%23e66e50' d='M14 2h1'/%3E%3Cpath stroke='%23e56849' d='M15 2h1'/%3E%3Cpath stroke='%23e4603f' d='M16 2h1m-2 2h1'/%3E%3Cpath stroke='%23e05532' d='M17 2h1'/%3E%3Cpath stroke='%23d04623' d='M18 2h1'/%3E%3Cpath stroke='%23b64b30' d='M19 2h1'/%3E%3Cpath stroke='%23e97f65' d='M1 3h1'/%3E%3Cpath stroke='%23f0a997' d='M2 3h1'/%3E%3Cpath stroke='%23f1ac9a' d='M3 3h1'/%3E%3Cpath stroke='%23ee9d89' d='M4 3h1M2 4h1'/%3E%3Cpath stroke='%23ec917a' d='M5 3h1'/%3E%3Cpath stroke='%23eb8b72' d='M6 3h1'/%3E%3Cpath stroke='%23ea856d' d='M7 3h1'/%3E%3Cpath stroke='%23e98168' d='M8 3h1M2 7h1'/%3E%3Cpath stroke='%23e87e65' d='M9 3h1'/%3E%3Cpath stroke='%23e97b61' d='M11 3h1'/%3E%3Cpath stroke='%23e8775d' d='M12 3h1M3 9h1'/%3E%3Cpath stroke='%23e87459' d='M13 3h1M2 9h1'/%3E%3Cpath stroke='%23e66f52' d='M14 3h1'/%3E%3Cpath stroke='%23e56a4c' d='M15 3h1'/%3E%3Cpath stroke='%23e46343' d='M16 3h1'/%3E%3Cpath stroke='%23e15937' d='M17 3h1'/%3E%3Cpath stroke='%23d24a28' d='M18 3h1'/%3E%3Cpath stroke='%23aa3315' d='M19 3h1'/%3E%3Cpath stroke='%23e87458' d='M1 4h1'/%3E%3Cpath stroke='%23efa18d' d='M3 4h1'/%3E%3Cpath stroke='%23ed957f' d='M4 4h1'/%3E%3Cpath stroke='%23eb8a71' d='M5 4h1M4 5h1'/%3E%3Cpath stroke='%23ea836a' d='M6 4h1M4 6h1M3 7h1'/%3E%3Cpath stroke='%23e97d64' d='M7 4h1'/%3E%3Cpath stroke='%23e8785e' d='M8 4h1'/%3E%3Cpath stroke='%23e77359' d='M9 4h1'/%3E%3Cpath stroke='%23e76f54' d='M10 4h1'/%3E%3Cpath stroke='%23e66d51' d='M11 4h1'/%3E%3Cpath stroke='%23e5684b' d='M12 4h1'/%3E%3Cpath stroke='%23e5684a' d='M13 4h1'/%3E%3Cpath stroke='%23e35c3a' d='M16 4h1m-7 4h1m-8 7h1'/%3E%3Cpath stroke='%23e05634' d='M17 4h1'/%3E%3Cpath stroke='%23d24c2a' d='M18 4h1'/%3E%3Cpath stroke='%23ac3618' d='M19 4h1'/%3E%3Cpath stroke='%23e76f52' d='M1 5h1m4 6h1m-3 1h1'/%3E%3Cpath stroke='%23ec9179' d='M2 5h1'/%3E%3Cpath stroke='%23ec937c' d='M3 5h1'/%3E%3Cpath stroke='%23f7ccc2' d='M5 5h1'/%3E%3Cpath stroke='%23e77259' d='M7 5h1M5 9h1'/%3E%3Cpath stroke='%23e76d53' d='M8 5h1'/%3E%3Cpath stroke='%23e5684d' d='M9 5h1M8 6h1'/%3E%3Cpath stroke='%23e46446' d='M10 5h1'/%3E%3Cpath stroke='%23e45f41' d='M11 5h1'/%3E%3Cpath stroke='%23e35b3a' d='M12 5h1m-2 1h1'/%3E%3Cpath stroke='%23e35938' d='M13 5h1'/%3E%3Cpath stroke='%23f3bbad' d='M15 5h1'/%3E%3Cpath stroke='%23e25531' d='M16 5h1'/%3E%3Cpath stroke='%23df5330' d='M17 5h1'/%3E%3Cpath stroke='%23d34e2c' d='M18 5h1'/%3E%3Cpath stroke='%23ad3a1d' d='M19 5h1m-1 1h1'/%3E%3Cpath stroke='%23eb876e' d='M2 6h1'/%3E%3Cpath stroke='%23eb8a70' d='M3 6h1'/%3E%3Cpath stroke='%23e46447' d='M9 6h1'/%3E%3Cpath stroke='%23e45f40' d='M10 6h1'/%3E%3Cpath stroke='%23e25634' d='M12 6h1'/%3E%3Cpath stroke='%23e2522d' d='M16 6h1'/%3E%3Cpath stroke='%23df522e' d='M17 6h1'/%3E%3Cpath stroke='%23d34d2c' d='M18 6h1'/%3E%3Cpath stroke='%23e56546' d='M1 7h1M1 8h1'/%3E%3Cpath stroke='%23e97e65' d='M4 7h1'/%3E%3Cpath stroke='%23e8775e' d='M5 7h1'/%3E%3Cpath stroke='%23e46143' d='M9 7h1'/%3E%3Cpath stroke='%23e45d3d' d='M10 7h1'/%3E%3Cpath stroke='%23e35836' d='M11 7h1'/%3E%3Cpath stroke='%23e24e27' d='M15 7h1'/%3E%3Cpath stroke='%23e2502a' d='M16 7h1'/%3E%3Cpath stroke='%23e0512c' d='M17 7h1'/%3E%3Cpath stroke='%23d34d2a' d='M18 7h1'/%3E%3Cpath stroke='%23ad391c' d='M19 7h1'/%3E%3Cpath stroke='%23e87a60' d='M2 8h1m1 0h1'/%3E%3Cpath stroke='%23e87c62' d='M3 8h1'/%3E%3Cpath stroke='%23e8745b' d='M5 8h1'/%3E%3Cpath stroke='%23e76e54' d='M6 8h1'/%3E%3Cpath stroke='%23e24d24' d='M14 8h1'/%3E%3Cpath stroke='%23e24b22' d='M15 8h1'/%3E%3Cpath stroke='%23e24d25' d='M16 8h1'/%3E%3Cpath stroke='%23e05029' d='M17 8h1'/%3E%3Cpath stroke='%23d44c29' d='M18 8h1'/%3E%3Cpath stroke='%23ae391b' d='M19 8h1'/%3E%3Cpath stroke='%23e35d3c' d='M1 9h1'/%3E%3Cpath stroke='%23e8765d' d='M4 9h1'/%3E%3Cpath stroke='%23e66f53' d='M6 9h1'/%3E%3Cpath stroke='%23e56b4e' d='M7 9h1'/%3E%3Cpath stroke='%23e45127' d='M13 9h1'/%3E%3Cpath stroke='%23e44f23' d='M14 9h1'/%3E%3Cpath stroke='%23e34c20' d='M15 9h1'/%3E%3Cpath stroke='%23e34d22' d='M16 9h1'/%3E%3Cpath stroke='%23e14f25' d='M17 9h1'/%3E%3Cpath stroke='%23d54a25' d='M18 9h1'/%3E%3Cpath stroke='%23af3719' d='M19 9h1'/%3E%3Cpath stroke='%23e35937' d='M1 10h1'/%3E%3Cpath stroke='%23e76d51' d='M2 10h1'/%3E%3Cpath stroke='%23e87257' d='M3 10h1'/%3E%3Cpath stroke='%23e87359' d='M4 10h1'/%3E%3Cpath stroke='%23e77157' d='M5 10h1'/%3E%3Cpath stroke='%23e66e52' d='M6 10h1'/%3E%3Cpath stroke='%23e56747' d='M8 10h1'/%3E%3Cpath stroke='%23e5572c' d='M12 10h1'/%3E%3Cpath stroke='%23e55326' d='M13 10h1'/%3E%3Cpath stroke='%23e55022' d='M14 10h1'/%3E%3Cpath stroke='%23e54d1e' d='M15 10h1'/%3E%3Cpath stroke='%23e54d1f' d='M16 10h1'/%3E%3Cpath stroke='%23e24e21' d='M17 10h1'/%3E%3Cpath stroke='%23d64921' d='M18 10h1'/%3E%3Cpath stroke='%23af3516' d='M19 10h1'/%3E%3Cpath stroke='%23e25432' d='M1 11h1'/%3E%3Cpath stroke='%23e5694b' d='M2 11h1'/%3E%3Cpath stroke='%23e77054' d='M3 11h1'/%3E%3Cpath stroke='%23e77156' d='M4 11h1'/%3E%3Cpath stroke='%23e87055' d='M5 11h1'/%3E%3Cpath stroke='%23e66c4d' d='M7 11h1'/%3E%3Cpath stroke='%23e75526' d='M13 11h1'/%3E%3Cpath stroke='%23e75221' d='M14 11h1'/%3E%3Cpath stroke='%23e64e1c' d='M15 11h1'/%3E%3Cpath stroke='%23e64d1c' d='M16 11h1'/%3E%3Cpath stroke='%23e34c1c' d='M17 11h1'/%3E%3Cpath stroke='%23d6461c' d='M18 11h1'/%3E%3Cpath stroke='%23b03312' d='M19 11h1'/%3E%3Cpath stroke='%23e14f2b' d='M1 12h1'/%3E%3Cpath stroke='%23e66b4e' d='M3 12h1'/%3E%3Cpath stroke='%23e76f53' d='M5 12h1'/%3E%3Cpath stroke='%23e66e51' d='M6 12h1'/%3E%3Cpath stroke='%23e7653d' d='M10 12h1'/%3E%3Cpath stroke='%23fef5f1' d='M13 12h1'/%3E%3Cpath stroke='%23e85421' d='M14 12h1'/%3E%3Cpath stroke='%23e8501b' d='M15 12h1'/%3E%3Cpath stroke='%23e74d18' d='M16 12h1'/%3E%3Cpath stroke='%23e44a18' d='M17 12h1'/%3E%3Cpath stroke='%23d74216' d='M18 12h1'/%3E%3Cpath stroke='%23b2310f' d='M19 12h1'/%3E%3Cpath stroke='%23e04b25' d='M1 13h1m0 3h1'/%3E%3Cpath stroke='%23e35e3d' d='M2 13h1'/%3E%3Cpath stroke='%23e56748' d='M3 13h1'/%3E%3Cpath stroke='%23e66c4e' d='M4 13h1'/%3E%3Cpath stroke='%23e66d50' d='M5 13h1'/%3E%3Cpath stroke='%23e76842' d='M9 13h1'/%3E%3Cpath stroke='%23e7653c' d='M10 13h1'/%3E%3Cpath stroke='%23e86236' d='M11 13h1'/%3E%3Cpath stroke='%23e95019' d='M15 13h1m-2 3h1'/%3E%3Cpath stroke='%23e84c16' d='M16 13h1'/%3E%3Cpath stroke='%23e44713' d='M17 13h1'/%3E%3Cpath stroke='%23d83f10' d='M18 13h1'/%3E%3Cpath stroke='%23b12d0a' d='M19 13h1'/%3E%3Cpath stroke='%23df451e' d='M1 14h1'/%3E%3Cpath stroke='%23e25836' d='M2 14h1'/%3E%3Cpath stroke='%23e46242' d='M3 14h1m0 1h1'/%3E%3Cpath stroke='%23e56749' d='M4 14h1'/%3E%3Cpath stroke='%23e66845' d='M8 14h1'/%3E%3Cpath stroke='%23e76741' d='M9 14h1'/%3E%3Cpath stroke='%23e7643b' d='M10 14h1'/%3E%3Cpath stroke='%23e86235' d='M11 14h1'/%3E%3Cpath stroke='%23ea5e2d' d='M12 14h1'/%3E%3Cpath stroke='%23e94a11' d='M16 14h1m-2 2h1'/%3E%3Cpath stroke='%23e6440d' d='M17 14h1'/%3E%3Cpath stroke='%23d73b0b' d='M18 14h1'/%3E%3Cpath stroke='%23b12b06' d='M19 14h1'/%3E%3Cpath stroke='%23de4018' d='M1 15h1'/%3E%3Cpath stroke='%23e1512e' d='M2 15h1'/%3E%3Cpath stroke='%23f5c1b5' d='M5 15h1'/%3E%3Cpath stroke='%23e66543' d='M7 15h1'/%3E%3Cpath stroke='%23e66541' d='M8 15h1'/%3E%3Cpath stroke='%23e6643d' d='M9 15h1'/%3E%3Cpath stroke='%23e76238' d='M10 15h1'/%3E%3Cpath stroke='%23e86032' d='M11 15h1'/%3E%3Cpath stroke='%23e95c2a' d='M12 15h1'/%3E%3Cpath stroke='%23ea5924' d='M13 15h1'/%3E%3Cpath stroke='%23f7b8a1' d='M15 15h1'/%3E%3Cpath stroke='%23e9480e' d='M16 15h1'/%3E%3Cpath stroke='%23e54009' d='M17 15h1'/%3E%3Cpath stroke='%23d73605' d='M18 15h1'/%3E%3Cpath stroke='%23b02702' d='M19 15h1'/%3E%3Cpath stroke='%23dd3c14' d='M1 16h1'/%3E%3Cpath stroke='%23e15431' d='M3 16h1'/%3E%3Cpath stroke='%23e35b39' d='M4 16h1'/%3E%3Cpath stroke='%23e45e3d' d='M5 16h1'/%3E%3Cpath stroke='%23e45f3d' d='M6 16h1'/%3E%3Cpath stroke='%23e45e3b' d='M7 16h1'/%3E%3Cpath stroke='%23e55e39' d='M8 16h1'/%3E%3Cpath stroke='%23e55e37' d='M9 16h1'/%3E%3Cpath stroke='%23e65d32' d='M10 16h1'/%3E%3Cpath stroke='%23e75b2c' d='M11 16h1'/%3E%3Cpath stroke='%23e85725' d='M12 16h1'/%3E%3Cpath stroke='%23e9541f' d='M13 16h1'/%3E%3Cpath stroke='%23e8440b' d='M16 16h1'/%3E%3Cpath stroke='%23e43d05' d='M17 16h1'/%3E%3Cpath stroke='%23d63302' d='M18 16h1'/%3E%3Cpath stroke='%23af2601' d='M19 16h1'/%3E%3Cpath stroke='%23d8370e' d='M1 17h1'/%3E%3Cpath stroke='%23db431c' d='M2 17h1'/%3E%3Cpath stroke='%23dd4c28' d='M3 17h1'/%3E%3Cpath stroke='%23de522f' d='M4 17h1'/%3E%3Cpath stroke='%23df5533' d='M5 17h1'/%3E%3Cpath stroke='%23e05734' d='M6 17h1'/%3E%3Cpath stroke='%23e05531' d='M7 17h1'/%3E%3Cpath stroke='%23e05631' d='M8 17h1'/%3E%3Cpath stroke='%23e1562e' d='M9 17h1'/%3E%3Cpath stroke='%23e2552a' d='M10 17h1'/%3E%3Cpath stroke='%23e45325' d='M11 17h1'/%3E%3Cpath stroke='%23e4501f' d='M12 17h1'/%3E%3Cpath stroke='%23e54c19' d='M13 17h1'/%3E%3Cpath stroke='%23e54813' d='M14 17h1'/%3E%3Cpath stroke='%23e5430d' d='M15 17h1'/%3E%3Cpath stroke='%23e43e07' d='M16 17h1'/%3E%3Cpath stroke='%23e03802' d='M17 17h1'/%3E%3Cpath stroke='%23d12f00' d='M18 17h1'/%3E%3Cpath stroke='%23aa2300' d='M19 17h1'/%3E%3Cpath stroke='%23cd4928' d='M1 18h1'/%3E%3Cpath stroke='%23cc3813' d='M2 18h1'/%3E%3Cpath stroke='%23cc3e1b' d='M3 18h1'/%3E%3Cpath stroke='%23cf4421' d='M4 18h1'/%3E%3Cpath stroke='%23cf4725' d='M5 18h1'/%3E%3Cpath stroke='%23cf4726' d='M6 18h1'/%3E%3Cpath stroke='%23cf4624' d='M7 18h1'/%3E%3Cpath stroke='%23d04723' d='M8 18h1'/%3E%3Cpath stroke='%23d14621' d='M9 18h1'/%3E%3Cpath stroke='%23d2451e' d='M10 18h1'/%3E%3Cpath stroke='%23d5451b' d='M11 18h1'/%3E%3Cpath stroke='%23d54216' d='M12 18h1'/%3E%3Cpath stroke='%23d64013' d='M13 18h1'/%3E%3Cpath stroke='%23d53d0e' d='M14 18h1'/%3E%3Cpath stroke='%23d63909' d='M15 18h1'/%3E%3Cpath stroke='%23d53504' d='M16 18h1'/%3E%3Cpath stroke='%23d13001' d='M17 18h1'/%3E%3Cpath stroke='%23c22a00' d='M18 18h1'/%3E%3Cpath stroke='%23ab3c1f' d='M19 18h1'/%3E%3Cpath stroke='%23eed6d0' d='M1 19h1'/%3E%3Cpath stroke='%23b54428' d='M2 19h1'/%3E%3Cpath stroke='%23a62b0d' d='M3 19h1'/%3E%3Cpath stroke='%23ac3011' d='M4 19h1'/%3E%3Cpath stroke='%23ab3112' d='M5 19h1'/%3E%3Cpath stroke='%23a93214' d='M6 19h1'/%3E%3Cpath stroke='%23a93012' d='M7 19h1'/%3E%3Cpath stroke='%23ac3213' d='M8 19h1'/%3E%3Cpath stroke='%23ad3213' d='M9 19h1'/%3E%3Cpath stroke='%23ae3110' d='M10 19h1'/%3E%3Cpath stroke='%23b1300d' d='M11 19h1'/%3E%3Cpath stroke='%23b22e0a' d='M12 19h1'/%3E%3Cpath stroke='%23b42d08' d='M13 19h1'/%3E%3Cpath stroke='%23b12a06' d='M14 19h1'/%3E%3Cpath stroke='%23b12803' d='M15 19h1'/%3E%3Cpath stroke='%23b42701' d='M16 19h1'/%3E%3Cpath stroke='%23ae2400' d='M17 19h1'/%3E%3Cpath stroke='%23ac3c1f' d='M18 19h1'/%3E%3Cpath stroke='%23ead4cf' d='M19 19h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Close]:hover {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23b5c6ef' d='M1 0h1m17 0h1M0 1h1m19 0h1M0 19h1m19 0h1M1 20h1m17 0h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m17 2h1M0 18h1m17 2h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m5 0h1m7 0h1m5 0h1M0 6h1m4 0h3m5 0h3m4 0h1M0 7h1m5 0h3m3 0h3m5 0h1M0 8h1m6 0h3m1 0h3m6 0h1M0 9h1m7 0h5m7 0h1M0 10h1m8 0h3m8 0h1M0 11h1m7 0h5m7 0h1M0 12h1m6 0h3m1 0h2m7 0h1M0 13h1m5 0h3m3 0h3m5 0h1M0 14h1m4 0h3m5 0h3m4 0h1M0 15h1m5 0h1m7 0h1m5 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h3m5 0h7'/%3E%3Cpath stroke='%23f5f7fd' d='M18 0h1M0 2h1m19 16h1M2 20h1'/%3E%3Cpath stroke='%23ffe4e1' d='M1 1h1'/%3E%3Cpath stroke='%23ff9285' d='M2 1h1m4 3h1M2 7h1'/%3E%3Cpath stroke='%23ff8c7f' d='M3 1h1'/%3E%3Cpath stroke='%23ff8375' d='M4 1h1m5 3h1'/%3E%3Cpath stroke='%23ff7b6c' d='M5 1h1M3 12h1'/%3E%3Cpath stroke='%23ff7868' d='M6 1h1m3 4h1'/%3E%3Cpath stroke='%23ff7362' d='M7 1h1'/%3E%3Cpath stroke='%23ff7363' d='M8 1h1m2 4h1M2 12h1'/%3E%3Cpath stroke='%23ff705f' d='M9 1h1M6 16h1'/%3E%3Cpath stroke='%23ff6f5f' d='M10 1h1'/%3E%3Cpath stroke='%23ff6e5d' d='M11 1h1m4 1h1m-5 3h1M2 13h1'/%3E%3Cpath stroke='%23ff6b5a' d='M12 1h1M3 15h1'/%3E%3Cpath stroke='%23f65' d='M13 1h2'/%3E%3Cpath stroke='%23ff6250' d='M15 1h1M2 15h1'/%3E%3Cpath stroke='%23ff5d4a' d='M16 1h1'/%3E%3Cpath stroke='%23fa5643' d='M17 1h1'/%3E%3Cpath stroke='%23eb6151' d='M18 1h1'/%3E%3Cpath stroke='%23f5dad7' d='M19 1h1'/%3E%3Cpath stroke='%23ff9386' d='M1 2h1'/%3E%3Cpath stroke='%23ffaea5' d='M2 2h1'/%3E%3Cpath stroke='%23ffb2a9' d='M3 2h1'/%3E%3Cpath stroke='%23ffa99f' d='M4 2h1'/%3E%3Cpath stroke='%23ff9e93' d='M5 2h1m0 1h1M5 4h1'/%3E%3Cpath stroke='%23ff998d' d='M6 2h1M4 6h1'/%3E%3Cpath stroke='%23ff9488' d='M7 2h1m0 1h1'/%3E%3Cpath stroke='%23ff9083' d='M8 2h1M3 8h1'/%3E%3Cpath stroke='%23ff8e80' d='M9 2h1'/%3E%3Cpath stroke='%23ff8b7d' d='M10 2h1M5 8h1M3 9h1'/%3E%3Cpath stroke='%23ff887a' d='M11 2h1m0 1h1M5 9h1'/%3E%3Cpath stroke='%23ff8475' d='M12 2h1M8 5h1'/%3E%3Cpath stroke='%23ff8172' d='M13 2h1M7 9h1m-3 3h1'/%3E%3Cpath stroke='%23ff7c6d' d='M14 2h1'/%3E%3Cpath stroke='%23ff7666' d='M15 2h1M1 7h1m1 6h1m0 1h1'/%3E%3Cpath stroke='%23fc6352' d='M17 2h1'/%3E%3Cpath stroke='%23e54' d='M18 2h1'/%3E%3Cpath stroke='%23d3594b' d='M19 2h1'/%3E%3Cpath stroke='%23ff8d80' d='M1 3h1'/%3E%3Cpath stroke='%23ffb3ab' d='M2 3h1'/%3E%3Cpath stroke='%23ffb8b0' d='M3 3h1'/%3E%3Cpath stroke='%23ffb0a6' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%23ffa49a' d='M5 3h1'/%3E%3Cpath stroke='%23ff988d' d='M7 3h1M6 4h1'/%3E%3Cpath stroke='%23ff9184' d='M9 3h1'/%3E%3Cpath stroke='%23ff8e81' d='M10 3h1M4 8h1'/%3E%3Cpath stroke='%23ff8c7e' d='M11 3h1M2 8h1'/%3E%3Cpath stroke='%23ff8576' d='M13 3h1M6 9h1m-4 1h1'/%3E%3Cpath stroke='%23ff7f70' d='M14 3h1M1 5h1m0 5h1m1 2h1'/%3E%3Cpath stroke='%23ff796a' d='M15 3h1M2 11h1'/%3E%3Cpath stroke='%23ff7161' d='M16 3h1M3 14h1'/%3E%3Cpath stroke='%23fc6857' d='M17 3h1'/%3E%3Cpath stroke='%23ed5948' d='M18 3h1M6 18h1'/%3E%3Cpath stroke='%23cb4233' d='M19 3h1'/%3E%3Cpath stroke='%23ff8577' d='M1 4h1m0 5h1'/%3E%3Cpath stroke='%23ffaaa0' d='M2 4h1'/%3E%3Cpath stroke='%23ffa89e' d='M4 4h1'/%3E%3Cpath stroke='%23ff8d7f' d='M8 4h1'/%3E%3Cpath stroke='%23ff8879' d='M9 4h1'/%3E%3Cpath stroke='%23ff8071' d='M11 4h1M8 6h1'/%3E%3Cpath stroke='%23ff7a6b' d='M12 4h1M1 6h1m7 0h1m-6 7h1'/%3E%3Cpath stroke='%23ff7969' d='M13 4h1'/%3E%3Cpath stroke='%23ff7464' d='M14 4h1m-5 2h1'/%3E%3Cpath stroke='%23ff7060' d='M15 4h1'/%3E%3Cpath stroke='%23ff6c5b' d='M16 4h1m-4 1h1'/%3E%3Cpath stroke='%23fc6655' d='M17 4h1'/%3E%3Cpath stroke='%23ef5c4b' d='M18 4h1'/%3E%3Cpath stroke='%23cc4636' d='M19 4h1'/%3E%3Cpath stroke='%23ffa095' d='M2 5h1'/%3E%3Cpath stroke='%23ffa59b' d='M3 5h1'/%3E%3Cpath stroke='%23ff9f94' d='M4 5h1'/%3E%3Cpath stroke='%23ffd5d1' d='M5 5h1'/%3E%3Cpath stroke='%23ff8a7c' d='M7 5h1'/%3E%3Cpath stroke='%23ff7e6f' d='M9 5h1'/%3E%3Cpath stroke='%23ffc2bb' d='M15 5h1'/%3E%3Cpath stroke='%23ff6554' d='M16 5h1'/%3E%3Cpath stroke='%23fc6453' d='M17 5h1'/%3E%3Cpath stroke='%23ee5d4d' d='M18 5h1'/%3E%3Cpath stroke='%23cd4939' d='M19 5h1'/%3E%3Cpath stroke='%23ff998e' d='M2 6h1'/%3E%3Cpath stroke='%23ff9d92' d='M3 6h1'/%3E%3Cpath stroke='%23ff6f5e' d='M11 6h1'/%3E%3Cpath stroke='%23ff6a58' d='M12 6h1'/%3E%3Cpath stroke='%23ff6451' d='M16 6h1'/%3E%3Cpath stroke='%23fd6451' d='M17 6h1'/%3E%3Cpath stroke='%23ee5e4d' d='M18 6h1'/%3E%3Cpath stroke='%23ce4a3a' d='M19 6h1'/%3E%3Cpath stroke='%23ff968a' d='M3 7h1'/%3E%3Cpath stroke='%23ff9487' d='M4 7h1'/%3E%3Cpath stroke='%23ff8f82' d='M5 7h1'/%3E%3Cpath stroke='%23ff7968' d='M9 7h1m-3 8h1'/%3E%3Cpath stroke='%23ff7463' d='M10 7h1'/%3E%3Cpath stroke='%23ff6f5d' d='M11 7h1'/%3E%3Cpath stroke='%23ff6450' d='M15 7h1'/%3E%3Cpath stroke='%23ff6552' d='M16 7h1'/%3E%3Cpath stroke='%23fd6653' d='M17 7h1'/%3E%3Cpath stroke='%23f0604e' d='M18 7h1'/%3E%3Cpath stroke='%23ce4a3b' d='M19 7h1'/%3E%3Cpath stroke='%23ff7565' d='M1 8h1'/%3E%3Cpath stroke='%23ff8677' d='M6 8h1m-2 2h1'/%3E%3Cpath stroke='%23ff7664' d='M10 8h1'/%3E%3Cpath stroke='%23ff6a53' d='M14 8h1'/%3E%3Cpath stroke='%23ff6953' d='M15 8h1'/%3E%3Cpath stroke='%23ff6b55' d='M16 8h1'/%3E%3Cpath stroke='%23fd6b56' d='M17 8h1'/%3E%3Cpath stroke='%23f06350' d='M18 8h1'/%3E%3Cpath stroke='%23cf4c3b' d='M19 8h1'/%3E%3Cpath stroke='%23ff6d5d' d='M1 9h1'/%3E%3Cpath stroke='%23ff8b7c' d='M4 9h1'/%3E%3Cpath stroke='%23ff775d' d='M13 9h1'/%3E%3Cpath stroke='%23ff745a' d='M14 9h1'/%3E%3Cpath stroke='%23ff7359' d='M15 9h1'/%3E%3Cpath stroke='%23ff735a' d='M16 9h1'/%3E%3Cpath stroke='%23fd715a' d='M17 9h1'/%3E%3Cpath stroke='%23f16752' d='M18 9h1'/%3E%3Cpath stroke='%23d24e3c' d='M19 9h1'/%3E%3Cpath stroke='%23ff6a59' d='M1 10h1m2 6h1'/%3E%3Cpath stroke='%23ff8778' d='M4 10h1'/%3E%3Cpath stroke='%23ff8374' d='M6 10h1m-3 1h2'/%3E%3Cpath stroke='%23ff8171' d='M7 10h1m-5 1h1'/%3E%3Cpath stroke='%23ff8271' d='M8 10h1m-2 1h1'/%3E%3Cpath stroke='%23ff8369' d='M12 10h1'/%3E%3Cpath stroke='%23ff8165' d='M13 10h1'/%3E%3Cpath stroke='%23ff7e61' d='M14 10h1'/%3E%3Cpath stroke='%23ff7d5f' d='M15 10h1'/%3E%3Cpath stroke='%23ff7b5f' d='M16 10h1'/%3E%3Cpath stroke='%23fd775d' d='M17 10h1'/%3E%3Cpath stroke='%23f36a53' d='M18 10h1'/%3E%3Cpath stroke='%23d34e3c' d='M19 10h1'/%3E%3Cpath stroke='%23ff6553' d='M1 11h1'/%3E%3Cpath stroke='%23ff8273' d='M6 11h1'/%3E%3Cpath stroke='%23ff8c6c' d='M13 11h1'/%3E%3Cpath stroke='%23ff8969' d='M14 11h1'/%3E%3Cpath stroke='%23ff8665' d='M15 11h1'/%3E%3Cpath stroke='%23ff8262' d='M16 11h1'/%3E%3Cpath stroke='%23fd7c5e' d='M17 11h1'/%3E%3Cpath stroke='%23f46d54' d='M18 11h1'/%3E%3Cpath stroke='%23d64f3b' d='M19 11h1'/%3E%3Cpath stroke='%23ff5f4d' d='M1 12h1'/%3E%3Cpath stroke='%23ff8070' d='M6 12h1'/%3E%3Cpath stroke='%23ff9279' d='M10 12h1'/%3E%3Cpath stroke='%23fff8f6' d='M13 12h1'/%3E%3Cpath stroke='%23ff936f' d='M14 12h1'/%3E%3Cpath stroke='%23ff906c' d='M15 12h1'/%3E%3Cpath stroke='%23ff8967' d='M16 12h1'/%3E%3Cpath stroke='%23fe7f5f' d='M17 12h1'/%3E%3Cpath stroke='%23f56e52' d='M18 12h1'/%3E%3Cpath stroke='%23d84f39' d='M19 12h1'/%3E%3Cpath stroke='%23ff5c4a' d='M1 13h1'/%3E%3Cpath stroke='%23ff7d6e' d='M5 13h1'/%3E%3Cpath stroke='%23ff907a' d='M9 13h1'/%3E%3Cpath stroke='%23ff957c' d='M10 13h1'/%3E%3Cpath stroke='%23ff9a7e' d='M11 13h1'/%3E%3Cpath stroke='%23ff9670' d='M15 13h1'/%3E%3Cpath stroke='%23ff8e68' d='M16 13h1'/%3E%3Cpath stroke='%23fe815e' d='M17 13h1'/%3E%3Cpath stroke='%23f66c4f' d='M18 13h1'/%3E%3Cpath stroke='%23da4d36' d='M19 13h1'/%3E%3Cpath stroke='%23ff5744' d='M1 14h1'/%3E%3Cpath stroke='%23ff6857' d='M2 14h1'/%3E%3Cpath stroke='%23ff8672' d='M8 14h1'/%3E%3Cpath stroke='%23ff8f78' d='M9 14h1'/%3E%3Cpath stroke='%23ff967c' d='M10 14h1'/%3E%3Cpath stroke='%23ff9c7e' d='M11 14h1'/%3E%3Cpath stroke='%23ffa07e' d='M12 14h1'/%3E%3Cpath stroke='%23ff8e66' d='M16 14h1'/%3E%3Cpath stroke='%23fe7f5a' d='M17 14h1m-3 3h1'/%3E%3Cpath stroke='%23f76a4b' d='M18 14h1'/%3E%3Cpath stroke='%23da4a33' d='M19 14h1'/%3E%3Cpath stroke='%23ff523f' d='M1 15h1'/%3E%3Cpath stroke='%23ff7160' d='M4 15h1'/%3E%3Cpath stroke='%23ffc7c1' d='M5 15h1'/%3E%3Cpath stroke='%23ff836f' d='M8 15h1'/%3E%3Cpath stroke='%23ff8b74' d='M9 15h1'/%3E%3Cpath stroke='%23ff9379' d='M10 15h1'/%3E%3Cpath stroke='%23ff9a7c' d='M11 15h1'/%3E%3Cpath stroke='%23ff9e7c' d='M12 15h1'/%3E%3Cpath stroke='%23ffa07a' d='M13 15h1'/%3E%3Cpath stroke='%23ffd5c5' d='M15 15h1'/%3E%3Cpath stroke='%23ff8b62' d='M16 15h1'/%3E%3Cpath stroke='%23fe7c56' d='M17 15h1'/%3E%3Cpath stroke='%23f76545' d='M18 15h1'/%3E%3Cpath stroke='%23db4931' d='M19 15h1'/%3E%3Cpath stroke='%23ff4f3a' d='M1 16h1'/%3E%3Cpath stroke='%23ff5c49' d='M2 16h1'/%3E%3Cpath stroke='%23ff6452' d='M3 16h1'/%3E%3Cpath stroke='%23ff6e5e' d='M5 16h1'/%3E%3Cpath stroke='%23ff7462' d='M7 16h1'/%3E%3Cpath stroke='%23ff7c68' d='M8 16h1'/%3E%3Cpath stroke='%23ff846d' d='M9 16h1'/%3E%3Cpath stroke='%23ff8b71' d='M10 16h1'/%3E%3Cpath stroke='%23ff9174' d='M11 16h1'/%3E%3Cpath stroke='%23ff9674' d='M12 16h1'/%3E%3Cpath stroke='%23ff9571' d='M13 16h1'/%3E%3Cpath stroke='%23ff946d' d='M14 16h1'/%3E%3Cpath stroke='%23ff8d66' d='M15 16h1'/%3E%3Cpath stroke='%23ff855c' d='M16 16h1'/%3E%3Cpath stroke='%23fe7650' d='M17 16h1'/%3E%3Cpath stroke='%23f66141' d='M18 16h1'/%3E%3Cpath stroke='%23da462f' d='M19 16h1'/%3E%3Cpath stroke='%23fa4935' d='M1 17h1'/%3E%3Cpath stroke='%23fb5441' d='M2 17h1'/%3E%3Cpath stroke='%23fc5c4a' d='M3 17h1'/%3E%3Cpath stroke='%23fb6150' d='M4 17h1'/%3E%3Cpath stroke='%23fc6554' d='M5 17h1'/%3E%3Cpath stroke='%23fc6756' d='M6 17h1'/%3E%3Cpath stroke='%23fc6a58' d='M7 17h1'/%3E%3Cpath stroke='%23fc715c' d='M8 17h1'/%3E%3Cpath stroke='%23fc7761' d='M9 17h1'/%3E%3Cpath stroke='%23fd7e64' d='M10 17h1'/%3E%3Cpath stroke='%23fd8367' d='M11 17h1'/%3E%3Cpath stroke='%23fe8566' d='M12 17h1'/%3E%3Cpath stroke='%23fe8664' d='M13 17h1'/%3E%3Cpath stroke='%23fe8460' d='M14 17h1'/%3E%3Cpath stroke='%23fe7651' d='M16 17h1'/%3E%3Cpath stroke='%23fc6b47' d='M17 17h1'/%3E%3Cpath stroke='%23f2573a' d='M18 17h1'/%3E%3Cpath stroke='%23d4402a' d='M19 17h1'/%3E%3Cpath stroke='%23e85848' d='M1 18h1'/%3E%3Cpath stroke='%23ed4a37' d='M2 18h1'/%3E%3Cpath stroke='%23ec4f3d' d='M3 18h1'/%3E%3Cpath stroke='%23ee5443' d='M4 18h1'/%3E%3Cpath stroke='%23ed5746' d='M5 18h1'/%3E%3Cpath stroke='%23ee5a48' d='M7 18h1'/%3E%3Cpath stroke='%23ef5e4b' d='M8 18h1'/%3E%3Cpath stroke='%23f0644e' d='M9 18h1'/%3E%3Cpath stroke='%23f16750' d='M10 18h1'/%3E%3Cpath stroke='%23f46c52' d='M11 18h1'/%3E%3Cpath stroke='%23f66d51' d='M12 18h1'/%3E%3Cpath stroke='%23f66e51' d='M13 18h1'/%3E%3Cpath stroke='%23f66c4e' d='M14 18h1'/%3E%3Cpath stroke='%23f86a4a' d='M15 18h1'/%3E%3Cpath stroke='%23f76343' d='M16 18h1'/%3E%3Cpath stroke='%23f3583a' d='M17 18h1'/%3E%3Cpath stroke='%23e54930' d='M18 18h1'/%3E%3Cpath stroke='%23cd5140' d='M19 18h1'/%3E%3Cpath stroke='%23f6d9d6' d='M1 19h1'/%3E%3Cpath stroke='%23d25344' d='M2 19h1'/%3E%3Cpath stroke='%23c93c2b' d='M3 19h1'/%3E%3Cpath stroke='%23ca3f2f' d='M4 19h1'/%3E%3Cpath stroke='%23ca4131' d='M5 19h1'/%3E%3Cpath stroke='%23ca4333' d='M6 19h1'/%3E%3Cpath stroke='%23cc4332' d='M7 19h1'/%3E%3Cpath stroke='%23cf4434' d='M8 19h1'/%3E%3Cpath stroke='%23d24936' d='M9 19h1'/%3E%3Cpath stroke='%23d34936' d='M10 19h1'/%3E%3Cpath stroke='%23d84b37' d='M11 19h1'/%3E%3Cpath stroke='%23da4c36' d='M12 19h1'/%3E%3Cpath stroke='%23dc4d36' d='M13 19h1'/%3E%3Cpath stroke='%23d94933' d='M14 19h1'/%3E%3Cpath stroke='%23de4a32' d='M15 19h1'/%3E%3Cpath stroke='%23dd482f' d='M16 19h1'/%3E%3Cpath stroke='%23d6402a' d='M17 19h1'/%3E%3Cpath stroke='%23cf5140' d='M18 19h1'/%3E%3Cpath stroke='%23f1d8d5' d='M19 19h1'/%3E%3Cpath stroke='%23fefefe' d='M6 20h1m3 0h1'/%3E%3Cpath stroke='%23fdfdfd' d='M7 20h1m1 0h1'/%3E%3Cpath stroke='%23fcfcfc' d='M8 20h1'/%3E%3C/svg%3E")
}

.wbox .title-bar-controls button[aria-label=Close]:not(:disabled):active {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 21 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23a7bced' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%23f4f6fd' d='M2 0h1m15 0h1M0 2h1m19 0h1M0 18h1m19 0h1M2 20h1m15 0h1'/%3E%3Cpath stroke='%23fff' d='M3 0h15M0 3h1m19 0h1M0 4h1m19 0h1M0 5h1m19 0h1M0 6h1m19 0h1M0 7h1m19 0h1M0 8h1m19 0h1M0 9h1m19 0h1M0 10h1m19 0h1M0 11h1m19 0h1M0 12h1m19 0h1M0 13h1m19 0h1M0 14h1m19 0h1M0 15h1m19 0h1M0 16h1m19 0h1M0 17h1m19 0h1M3 20h15'/%3E%3Cpath stroke='%23a7baec' d='M19 0h1m0 1h1'/%3E%3Cpath stroke='%23dad2d0' d='M1 1h1'/%3E%3Cpath stroke='%23643529' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%235a1d0d' d='M3 1h1'/%3E%3Cpath stroke='%235d1e0d' d='M4 1h1'/%3E%3Cpath stroke='%235f1e0e' d='M5 1h1'/%3E%3Cpath stroke='%2363200e' d='M6 1h1'/%3E%3Cpath stroke='%2368210f' d='M7 1h1'/%3E%3Cpath stroke='%236f2310' d='M8 1h1'/%3E%3Cpath stroke='%23732511' d='M9 1h1'/%3E%3Cpath stroke='%23752511' d='M10 1h1M1 10h1'/%3E%3Cpath stroke='%237c2712' d='M11 1h1'/%3E%3Cpath stroke='%23822912' d='M12 1h1M5 2h1'/%3E%3Cpath stroke='%23852a13' d='M13 1h1M2 5h1m-2 8h1'/%3E%3Cpath stroke='%23892b13' d='M14 1h1'/%3E%3Cpath stroke='%238a2b14' d='M15 1h1M6 2h1'/%3E%3Cpath stroke='%238e2d14' d='M16 1h1M7 2h1'/%3E%3Cpath stroke='%238c2c14' d='M17 1h1M2 6h1'/%3E%3Cpath stroke='%239d4732' d='M18 1h1M1 18h1'/%3E%3Cpath stroke='%23ebd8d3' d='M19 1h1'/%3E%3Cpath stroke='%2369220f' d='M2 2h1'/%3E%3Cpath stroke='%23782611' d='M3 2h1'/%3E%3Cpath stroke='%237e2812' d='M4 2h1'/%3E%3Cpath stroke='%23932e15' d='M8 2h1'/%3E%3Cpath stroke='%239a3016' d='M9 2h1'/%3E%3Cpath stroke='%239c3116' d='M10 2h1'/%3E%3Cpath stroke='%23a03217' d='M11 2h1'/%3E%3Cpath stroke='%23a43418' d='M12 2h1'/%3E%3Cpath stroke='%23a73518' d='M13 2h1'/%3E%3Cpath stroke='%23aa3618' d='M14 2h1M2 14h1'/%3E%3Cpath stroke='%23ab3618' d='M15 2h1'/%3E%3Cpath stroke='%23ad3719' d='M16 2h1m1 0h1M2 16h1m-1 1h1'/%3E%3Cpath stroke='%23ac3618' d='M17 2h1'/%3E%3Cpath stroke='%23b24e35' d='M19 2h1'/%3E%3Cpath stroke='%23591c0d' d='M1 3h1M1 4h1'/%3E%3Cpath stroke='%23792711' d='M2 3h1'/%3E%3Cpath stroke='%238d2c14' d='M3 3h1'/%3E%3Cpath stroke='%23962e15' d='M4 3h1'/%3E%3Cpath stroke='%239a2f16' d='M5 3h1'/%3E%3Cpath stroke='%23a13117' d='M6 3h1'/%3E%3Cpath stroke='%23a63317' d='M7 3h1'/%3E%3Cpath stroke='%23aa3418' d='M8 3h1'/%3E%3Cpath stroke='%23af3619' d='M9 3h1'/%3E%3Cpath stroke='%23b23719' d='M10 3h1M8 4h1M4 8h1'/%3E%3Cpath stroke='%23b5391a' d='M11 3h1'/%3E%3Cpath stroke='%23b73a1b' d='M12 3h1'/%3E%3Cpath stroke='%23b93b1b' d='M13 3h1'/%3E%3Cpath stroke='%23ba3b1b' d='M14 3h2m3 0h1M3 13h1m-1 1h1m-1 5h1'/%3E%3Cpath stroke='%23bb3b1b' d='M16 3h3M3 15h1'/%3E%3Cpath stroke='%23802812' d='M2 4h1m-2 8h1'/%3E%3Cpath stroke='%23962f15' d='M3 4h1'/%3E%3Cpath stroke='%239e3016' d='M4 4h1'/%3E%3Cpath stroke='%23a43216' d='M5 4h1'/%3E%3Cpath stroke='%23aa3317' d='M6 4h1M4 6h1'/%3E%3Cpath stroke='%23ae3518' d='M7 4h1'/%3E%3Cpath stroke='%23b5381a' d='M9 4h1M4 9h1'/%3E%3Cpath stroke='%23b8391a' d='M10 4h1m-7 6h1'/%3E%3Cpath stroke='%23ba3a1b' d='M11 4h1m-8 7h2'/%3E%3Cpath stroke='%23bc3b1c' d='M12 4h1m-9 8h1'/%3E%3Cpath stroke='%23bd3c1c' d='M13 4h1m-1 1h1m-2 1h1m-7 6h1m-3 1h2'/%3E%3Cpath stroke='%23be3d1c' d='M14 4h3m-1 1h1m-1 1h1M4 14h1m-1 1h1m-1 1h2'/%3E%3Cpath stroke='%23bf3d1c' d='M17 4h3m-3 1h3m-2 1h2m-1 1h1M4 17h2m-2 1h4m-4 1h4'/%3E%3Cpath stroke='%235b1d0d' d='M1 5h1'/%3E%3Cpath stroke='%239c3016' d='M3 5h1'/%3E%3Cpath stroke='%23a43217' d='M4 5h1'/%3E%3Cpath stroke='%23b8553e' d='M5 5h1'/%3E%3Cpath stroke='%23d59485' d='M6 5h1M5 6h1'/%3E%3Cpath stroke='%23b33619' d='M7 5h1'/%3E%3Cpath stroke='%23b53719' d='M8 5h1'/%3E%3Cpath stroke='%23b8381a' d='M9 5h1M6 8h1'/%3E%3Cpath stroke='%23b9391b' d='M10 5h1'/%3E%3Cpath stroke='%23ba391b' d='M11 5h1M6 9h1m-2 1h1'/%3E%3Cpath stroke='%23bc3b1b' d='M12 5h1m-2 1h1m-6 5h1m-2 1h1'/%3E%3Cpath stroke='%23dc9887' d='M14 5h1'/%3E%3Cpath stroke='%23c85d42' d='M15 5h1M5 15h1'/%3E%3Cpath stroke='%23611f0e' d='M1 6h1'/%3E%3Cpath stroke='%23a23217' d='M3 6h1'/%3E%3Cpath stroke='%23d79585' d='M6 6h1'/%3E%3Cpath stroke='%23d89585' d='M7 6h1'/%3E%3Cpath stroke='%23b8371a' d='M8 6h1'/%3E%3Cpath stroke='%23ba391a' d='M9 6h1'/%3E%3Cpath stroke='%23bb3a1b' d='M10 6h1m-5 4h1'/%3E%3Cpath stroke='%23dd9887' d='M13 6h3m-4 1h1m-2 1h1M9 9h1m-2 2h1m-2 1h1m-2 1h1m-2 1h2'/%3E%3Cpath stroke='%23c03e1d' d='M17 6h1m-2 1h3m0 1h1m-1 1h1M7 16h1m-2 1h2m0 1h1'/%3E%3Cpath stroke='%2365200e' d='M1 7h1'/%3E%3Cpath stroke='%23902d15' d='M2 7h1'/%3E%3Cpath stroke='%23a73418' d='M3 7h1'/%3E%3Cpath stroke='%23af3518' d='M4 7h1'/%3E%3Cpath stroke='%23b43619' d='M5 7h1'/%3E%3Cpath stroke='%23d99585' d='M6 7h1'/%3E%3Cpath stroke='%23da9686' d='M7 7h1'/%3E%3Cpath stroke='%23db9686' d='M8 7h1M7 8h1'/%3E%3Cpath stroke='%23bc3a1b' d='M9 7h1M7 9h1'/%3E%3Cpath stroke='%23bd3b1b' d='M10 7h1m-4 3h1'/%3E%3Cpath stroke='%23be3c1c' d='M11 7h1m-2 1h1m-3 2h1m-2 1h1'/%3E%3Cpath stroke='%23de9987' d='M13 7h2m-3 1h2m-4 1h2m-3 1h1m-2 2h1m-2 2h1'/%3E%3Cpath stroke='%23c03f1d' d='M15 7h1m-9 8h1'/%3E%3Cpath stroke='%236a220f' d='M1 8h1'/%3E%3Cpath stroke='%23952f15' d='M2 8h1'/%3E%3Cpath stroke='%23ac3518' d='M3 8h1'/%3E%3Cpath stroke='%23b63719' d='M5 8h1'/%3E%3Cpath stroke='%23dc9786' d='M8 8h2M8 9h1'/%3E%3Cpath stroke='%23c2401d' d='M14 8h1m2 0h1m1 3h1M8 14h1m-1 2h1m-1 1h1m0 1h1m1 1h1'/%3E%3Cpath stroke='%23c2401e' d='M15 8h2m1 1h1M8 15h1'/%3E%3Cpath stroke='%23c13f1d' d='M18 8h1m0 2h1M9 19h2'/%3E%3Cpath stroke='%23702410' d='M1 9h1'/%3E%3Cpath stroke='%239b3016' d='M2 9h1'/%3E%3Cpath stroke='%23b03619' d='M3 9h1'/%3E%3Cpath stroke='%23b9381a' d='M5 9h1'/%3E%3Cpath stroke='%23df9a88' d='M12 9h1m-2 1h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%23c4421e' d='M13 9h1m2 0h2m0 1h1M9 13h1m9 1h1m-1 1h1M9 16h1m9 0h1M9 17h1m0 1h1m3 1h3'/%3E%3Cpath stroke='%23c5431e' d='M14 9h1'/%3E%3Cpath stroke='%23c5431f' d='M15 9h1m-4 1h1m5 1h1m-9 1h1m-2 2h1m-1 1h1m0 2h1m0 1h1m6 0h1'/%3E%3Cpath stroke='%239e3217' d='M2 10h1'/%3E%3Cpath stroke='%23b4381a' d='M3 10h1'/%3E%3Cpath stroke='%23df9a87' d='M10 10h1m-2 1h1m-2 2h1'/%3E%3Cpath stroke='%23c6441f' d='M13 10h1m3 0h1m-8 3h1m-1 3h1'/%3E%3Cpath stroke='%23c74520' d='M14 10h2m-6 4h1m-1 1h1m7 2h1m-7 1h1m4 0h1'/%3E%3Cpath stroke='%23c7451f' d='M16 10h1m1 2h1'/%3E%3Cpath stroke='%237b2711' d='M1 11h1'/%3E%3Cpath stroke='%23a13217' d='M2 11h1'/%3E%3Cpath stroke='%23b7391a' d='M3 11h1'/%3E%3Cpath stroke='%23e09b88' d='M11 11h1'/%3E%3Cpath stroke='%23e29d89' d='M12 11h1'/%3E%3Cpath stroke='%23c94621' d='M13 11h1m-3 2h1'/%3E%3Cpath stroke='%23ca4721' d='M14 11h1m2 1h1m-7 2h1m-1 1h1m0 2h1m2 1h1'/%3E%3Cpath stroke='%23ca4821' d='M15 11h1m1 6h1'/%3E%3Cpath stroke='%23c94620' d='M16 11h1m1 3h1m-8 2h1m6 0h1'/%3E%3Cpath stroke='%23c84620' d='M17 11h1m0 2h1'/%3E%3Cpath stroke='%23a53418' d='M2 12h1'/%3E%3Cpath stroke='%23b83a1b' d='M3 12h1'/%3E%3Cpath stroke='%23e19d89' d='M11 12h1'/%3E%3Cpath stroke='%23e39e89' d='M12 12h1'/%3E%3Cpath stroke='%23e0947c' d='M13 12h1'/%3E%3Cpath stroke='%23cc4a22' d='M14 12h1m-3 2h1m4 0h1m-6 1h1'/%3E%3Cpath stroke='%23cd4a22' d='M15 12h1m0 1h1m0 2h1m-5 1h1m1 1h1'/%3E%3Cpath stroke='%23cb4922' d='M16 12h1m0 1h1m-5 4h1'/%3E%3Cpath stroke='%23c3411e' d='M19 12h1m-1 1h1m-1 4h1m-8 2h2m3 0h1'/%3E%3Cpath stroke='%23a93618' d='M2 13h1'/%3E%3Cpath stroke='%23dd9987' d='M7 13h1m-2 2h1'/%3E%3Cpath stroke='%23e39f8a' d='M12 13h1'/%3E%3Cpath stroke='%23e59f8b' d='M13 13h1'/%3E%3Cpath stroke='%23e5a08b' d='M14 13h1m-2 1h1'/%3E%3Cpath stroke='%23ce4c23' d='M15 13h1m0 3h1'/%3E%3Cpath stroke='%23882b13' d='M1 14h1'/%3E%3Cpath stroke='%23e6a08b' d='M14 14h1'/%3E%3Cpath stroke='%23e6a18b' d='M15 14h1m-2 1h1'/%3E%3Cpath stroke='%23ce4b23' d='M16 14h1m-4 1h1'/%3E%3Cpath stroke='%238b2c14' d='M1 15h1m-1 1h1'/%3E%3Cpath stroke='%23ac3619' d='M2 15h1'/%3E%3Cpath stroke='%23d76b48' d='M15 15h1'/%3E%3Cpath stroke='%23cf4c23' d='M16 15h1m-2 1h1'/%3E%3Cpath stroke='%23c94721' d='M18 15h1m-3 3h1'/%3E%3Cpath stroke='%23bb3c1b' d='M3 16h1'/%3E%3Cpath stroke='%23bf3e1d' d='M6 16h1'/%3E%3Cpath stroke='%23cb4821' d='M12 16h1'/%3E%3Cpath stroke='%23cd4b23' d='M14 16h1'/%3E%3Cpath stroke='%23cc4922' d='M17 16h1m-4 1h1m1 0h1'/%3E%3Cpath stroke='%238d2d14' d='M1 17h1'/%3E%3Cpath stroke='%23bc3c1b' d='M3 17h1m-1 1h1'/%3E%3Cpath stroke='%23c84520' d='M11 17h1m1 1h1'/%3E%3Cpath stroke='%23ae3719' d='M2 18h1'/%3E%3Cpath stroke='%23c94720' d='M14 18h1'/%3E%3Cpath stroke='%23c95839' d='M19 18h1'/%3E%3Cpath stroke='%23a7bdf0' d='M0 19h1m0 1h1'/%3E%3Cpath stroke='%23ead7d3' d='M1 19h1'/%3E%3Cpath stroke='%23b34e35' d='M2 19h1'/%3E%3Cpath stroke='%23c03e1c' d='M8 19h1'/%3E%3Cpath stroke='%23c9583a' d='M18 19h1'/%3E%3Cpath stroke='%23f3dbd4' d='M19 19h1'/%3E%3Cpath stroke='%23a7bcef' d='M20 19h1m-2 1h1'/%3E%3C/svg%3E")
}

.wbox .status-bar {
	margin: 0 3px;
	box-shadow: inset 0 1px 2px grey;
	padding: 2px 1px;
	gap: 0
}

.wbox .status-bar-field {
	font-family: "Roboto", Arial;
	-webkit-font-smoothing: antialiased;
	box-shadow: none;
	padding: 1px 2px;
	border-right: 1px solid rgba(208, 206, 191, .75);
	border-left: 1px solid hsla(0, 0%, 100%, .75)
}

.wbox .status-bar-field:first-of-type {
	border-left: none
}

.wbox .status-bar-field:last-of-type {
	border-right: none
}

.wbox button {
	font-family: "Roboto", Arial;
	-webkit-font-smoothing: antialiased;
	font-size: 1em;
	box-sizing: border-box;
	border: 1px solid #003c74;
	background: linear-gradient(180deg, #fff, #ecebe5 86%, #d8d0c4);
	box-shadow: none;
	border-radius: 3px
}

.wbox button:not(:disabled).active,
.wbox button:not(:disabled):active {
	box-shadow: none;
	background: linear-gradient(180deg, #cdcac3, #e3e3db 8%, #e5e5de 94%, #f2f2f1)
}

.wbox button:not(:disabled):hover {
	box-shadow: inset -1px 1px #fff0cf, inset 1px 2px #fdd889, inset -2px 2px #fbc761, inset 2px -2px #e5a01a
}

.wbox button.focused,
.wbox button:focus {
	box-shadow: inset -1px 1px #cee7ff, inset 1px 2px #98b8ea, inset -2px 2px #bcd4f6, inset 1px -1px #89ade4, inset 2px -2px #89ade4
}

.wbox button::-moz-focus-inner {
	border: 0
}

.wbox input,
.wbox label,
.wbox option,
.wbox select,
.wbox textarea {
	-webkit-font-smoothing: antialiased
}

.wbox select {
	border: 1px solid #7f9db9;
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 15 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23e6eefc' d='M0 0h1'/%3E%3Cpath stroke='%23d1e0fd' d='M1 0h1M0 1h1m3 0h2M2 3h1M2 4h1'/%3E%3Cpath stroke='%23cad8f9' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23c4d3f7' d='M3 0h1M0 3h1M0 4h1'/%3E%3Cpath stroke='%23bfd0f8' d='M4 0h2M0 5h1'/%3E%3Cpath stroke='%23bdcef7' d='M6 0h1M0 6h1'/%3E%3Cpath stroke='%23baccf4' d='M7 0h1m6 2h1m-1 5h1m-1 1h1'/%3E%3Cpath stroke='%23b8cbf6' d='M8 0h1M0 7h1M0 8h1'/%3E%3Cpath stroke='%23b7caf5' d='M9 0h2M0 9h1'/%3E%3Cpath stroke='%23b5c8f7' d='M11 0h1'/%3E%3Cpath stroke='%23b3c7f5' d='M12 0h1'/%3E%3Cpath stroke='%23afc5f4' d='M13 0h1'/%3E%3Cpath stroke='%23dce6f9' d='M14 0h1'/%3E%3Cpath stroke='%23e1eafe' d='M1 1h1'/%3E%3Cpath stroke='%23dae6fe' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%23d4e1fc' d='M3 1h1M1 3h1M1 4h1'/%3E%3Cpath stroke='%23d0ddfc' d='M6 1h1M1 5h1'/%3E%3Cpath stroke='%23cedbfd' d='M7 1h1M4 2h2'/%3E%3Cpath stroke='%23cad9fd' d='M8 1h1M6 2h1M3 5h1'/%3E%3Cpath stroke='%23c8d8fb' d='M9 1h2'/%3E%3Cpath stroke='%23c5d6fc' d='M11 1h1M2 11h4'/%3E%3Cpath stroke='%23c2d3fc' d='M12 1h1m-2 1h1M1 11h1m0 1h2m-2 1h2'/%3E%3Cpath stroke='%23bccefa' d='M13 1h1m-1 1h1m-1 1h1m-1 1h1M3 15h4'/%3E%3Cpath stroke='%23b9c9f3' d='M14 1h1M3 16h4'/%3E%3Cpath stroke='%23d8e3fc' d='M2 2h1'/%3E%3Cpath stroke='%23d1defd' d='M3 2h1'/%3E%3Cpath stroke='%23c9d8fc' d='M7 2h1M4 3h3M4 4h3M3 6h1m1 0h2M1 7h1M1 8h1'/%3E%3Cpath stroke='%23c5d5fc' d='M8 2h1m-8 8h5'/%3E%3Cpath stroke='%23c5d3fc' d='M9 2h2'/%3E%3Cpath stroke='%23bed0fc' d='M12 2h1M8 3h1M8 4h1m-8 8h1m-1 1h1m0 1h1m1 0h3'/%3E%3Cpath stroke='%23cddbfc' d='M3 3h1M3 4h1M1 6h2'/%3E%3Cpath stroke='%23c8d5fb' d='M7 3h1M7 4h1'/%3E%3Cpath stroke='%23bbcefd' d='M9 3h4M9 4h4M8 5h1M7 6h1'/%3E%3Cpath stroke='%23bcccf3' d='M14 3h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23ceddfd' d='M2 5h1'/%3E%3Cpath stroke='%23c8d6fb' d='M4 5h4M1 9h3'/%3E%3Cpath stroke='%23bacdfc' d='M9 5h2m1 0h2M1 14h1'/%3E%3Cpath stroke='%23b9cdfb' d='M11 5h1M8 6h2m2 0h2m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%234d6185' d='M4 6h1m5 0h1M3 7h3m3 0h3M4 8h3m1 0h3M5 9h5m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%23b7cdfc' d='M11 6h1m0 1h1m-1 1h1'/%3E%3Cpath stroke='%23cad8fd' d='M2 7h1M2 8h2'/%3E%3Cpath stroke='%23c1d3fb' d='M6 7h2M7 8h1M4 9h1'/%3E%3Cpath stroke='%23b6cefb' d='M8 7h1m2 1h1m-2 1h3m-2 1h2'/%3E%3Cpath stroke='%23b6cdfb' d='M13 9h1m-6 6h1'/%3E%3Cpath stroke='%23b9cbf3' d='M14 9h1'/%3E%3Cpath stroke='%23b4c8f6' d='M0 10h1'/%3E%3Cpath stroke='%23bdd3fb' d='M9 10h2m-4 4h1'/%3E%3Cpath stroke='%23b5cdfa' d='M13 10h1'/%3E%3Cpath stroke='%23b5c9f3' d='M14 10h1'/%3E%3Cpath stroke='%23b1c7f6' d='M0 11h1'/%3E%3Cpath stroke='%23c3d5fd' d='M6 11h1'/%3E%3Cpath stroke='%23bad4fc' d='M8 11h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b2cffb' d='M9 11h4m-2 3h1'/%3E%3Cpath stroke='%23b1cbfa' d='M13 11h1m-3 4h1'/%3E%3Cpath stroke='%23b3c8f5' d='M14 11h1m-7 5h3'/%3E%3Cpath stroke='%23adc3f6' d='M0 12h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23c2d5fc' d='M4 12h4m-4 1h4'/%3E%3Cpath stroke='%23b7d3fc' d='M9 12h2m-2 1h2m-3 1h1'/%3E%3Cpath stroke='%23b3d1fc' d='M11 12h1m-1 1h1'/%3E%3Cpath stroke='%23afcdfb' d='M12 12h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23afcbfa' d='M13 12h1m-1 1h1'/%3E%3Cpath stroke='%23b2c8f4' d='M14 12h1m-1 1h1m-4 3h1'/%3E%3Cpath stroke='%23c1d2fb' d='M3 14h1'/%3E%3Cpath stroke='%23b6d1fb' d='M9 14h2'/%3E%3Cpath stroke='%23adc9f9' d='M13 14h1m-2 1h1'/%3E%3Cpath stroke='%23b1c6f3' d='M14 14h1m-3 2h1'/%3E%3Cpath stroke='%23abc1f4' d='M0 15h1'/%3E%3Cpath stroke='%23b7cbf9' d='M1 15h1'/%3E%3Cpath stroke='%23b9cefb' d='M2 15h1'/%3E%3Cpath stroke='%23b9cffb' d='M7 15h1'/%3E%3Cpath stroke='%23b2cdfb' d='M9 15h2'/%3E%3Cpath stroke='%23aec8f7' d='M13 15h1'/%3E%3Cpath stroke='%23b0c5f2' d='M14 15h1m-2 1h1'/%3E%3Cpath stroke='%23dbe3f8' d='M0 16h1'/%3E%3Cpath stroke='%23b7c6f1' d='M1 16h1'/%3E%3Cpath stroke='%23b8c9f2' d='M2 16h1m4 0h1'/%3E%3Cpath stroke='%23d9e3f6' d='M14 16h1'/%3E%3C/svg%3E");
	background-size: 1.2em;
	background-position: right 2px center; 
}

.wbox select:focus {
	box-shadow: inset 2px 2px #fff, inset -2px -2px #fff
}

.wbox select:hover {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 15 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23cfdbec' d='M0 0h1'/%3E%3Cpath stroke='%23b4c7eb' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%23abbee9' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23a5b9e7' d='M3 0h1M0 3h1M0 4h1'/%3E%3Cpath stroke='%23a0b4e5' d='M4 0h2'/%3E%3Cpath stroke='%239cb2e5' d='M6 0h1M0 6h1'/%3E%3Cpath stroke='%2398b1e4' d='M7 0h1'/%3E%3Cpath stroke='%2397aee2' d='M8 0h1M0 7h1M0 8h1'/%3E%3Cpath stroke='%2395ade5' d='M9 0h2M0 9h1'/%3E%3Cpath stroke='%2394abe4' d='M11 0h1'/%3E%3Cpath stroke='%2390aae4' d='M12 0h1M0 10h1'/%3E%3Cpath stroke='%238aa6e3' d='M13 0h1M0 12h1m-1 1h1'/%3E%3Cpath stroke='%23c2cfea' d='M14 0h1'/%3E%3Cpath stroke='%23fdffff' d='M1 1h1'/%3E%3Cpath stroke='%23f6ffff' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%23eefcff' d='M3 1h1M1 3h1M1 4h1'/%3E%3Cpath stroke='%23e9faff' d='M4 1h2M3 2h1M2 3h1M2 4h1'/%3E%3Cpath stroke='%23e5f6ff' d='M6 1h1M1 5h2'/%3E%3Cpath stroke='%23e3f4ff' d='M7 1h1M4 2h2'/%3E%3Cpath stroke='%23dff2fe' d='M8 1h1M6 2h1M3 5h1'/%3E%3Cpath stroke='%23dbf1ff' d='M9 1h2'/%3E%3Cpath stroke='%23d8edfc' d='M11 1h1M2 11h4'/%3E%3Cpath stroke='%23d4e9fc' d='M12 1h1m-2 1h1M1 11h1m0 1h1m-1 1h1'/%3E%3Cpath stroke='%23cde2fc' d='M13 1h1m-1 1h1m-1 1h1m-1 1h1M3 15h3'/%3E%3Cpath stroke='%2397ace0' d='M14 1h1M3 16h4'/%3E%3Cpath stroke='%23f2feff' d='M2 2h1'/%3E%3Cpath stroke='%23ddf0fe' d='M7 2h1M4 3h3M4 4h3M3 6h1m1 0h2M1 7h1M1 8h1'/%3E%3Cpath stroke='%23d8ebfc' d='M8 2h1m-8 8h5'/%3E%3Cpath stroke='%23d8eafc' d='M9 2h2'/%3E%3Cpath stroke='%23d0e5fc' d='M12 2h1M8 3h1M8 4h1m-8 8h1m-1 1h1m0 1h1'/%3E%3Cpath stroke='%2398aee1' d='M14 2h1m-1 5h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23e2f3fd' d='M3 3h1M3 4h1M1 6h1'/%3E%3Cpath stroke='%23dcecfd' d='M7 3h1M7 4h1'/%3E%3Cpath stroke='%23cde4fc' d='M9 3h4M9 4h4M8 5h1'/%3E%3Cpath stroke='%239bafe0' d='M14 3h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%239db3e6' d='M0 5h1'/%3E%3Cpath stroke='%23dcedfd' d='M4 5h4M1 9h3'/%3E%3Cpath stroke='%23cae2fd' d='M9 5h2m1 0h2M1 14h1m4 1h1'/%3E%3Cpath stroke='%23c8e1fb' d='M11 5h1M8 6h2m2 0h2m-1 1h1m-1 1h1M2 15h1'/%3E%3Cpath stroke='%23e1f2fe' d='M2 6h1'/%3E%3Cpath stroke='%234d6185' d='M4 6h1m5 0h1M3 7h3m3 0h3M4 8h3m1 0h3M5 9h5m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%23d2eafe' d='M7 6h1M6 7h2M7 8h1M4 9h1'/%3E%3Cpath stroke='%23c6e2fd' d='M11 6h1m0 1h1m-1 1h1'/%3E%3Cpath stroke='%23dff0fc' d='M2 7h1M2 8h2'/%3E%3Cpath stroke='%23c5e3fc' d='M8 7h1m2 1h1m-2 1h4m-3 1h2m-5 5h1'/%3E%3Cpath stroke='%23ceeafd' d='M9 10h2m-4 4h1'/%3E%3Cpath stroke='%23c2e2fc' d='M13 10h1m-5 5h2'/%3E%3Cpath stroke='%2392ade2' d='M14 10h1'/%3E%3Cpath stroke='%238da9e4' d='M0 11h1'/%3E%3Cpath stroke='%23d5ebfd' d='M6 11h1'/%3E%3Cpath stroke='%23cbedff' d='M8 11h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23c0e4fc' d='M9 11h4m-2 3h1'/%3E%3Cpath stroke='%23bee0fc' d='M13 11h1'/%3E%3Cpath stroke='%2391abe1' d='M14 11h1m-7 5h3'/%3E%3Cpath stroke='%23d5eafd' d='M3 12h1m-1 1h1'/%3E%3Cpath stroke='%23d4ebfc' d='M4 12h3m-3 1h3'/%3E%3Cpath stroke='%23d2ecfe' d='M7 12h1m-1 1h1'/%3E%3Cpath stroke='%23c6ebff' d='M9 12h2m-2 1h2m-3 1h1'/%3E%3Cpath stroke='%23c2eaff' d='M11 12h1m-1 1h1'/%3E%3Cpath stroke='%23bde3fd' d='M12 12h1m-1 1h1'/%3E%3Cpath stroke='%23b9ddfb' d='M13 12h1m-1 1h1m-1 1h1m-2 1h1'/%3E%3Cpath stroke='%238da9e1' d='M14 12h1m-1 1h1m-3 3h1'/%3E%3Cpath stroke='%2388a3e3' d='M0 14h1'/%3E%3Cpath stroke='%23d2e9fe' d='M3 14h1'/%3E%3Cpath stroke='%23d0e8fc' d='M4 14h3'/%3E%3Cpath stroke='%23c4e8fe' d='M9 14h2'/%3E%3Cpath stroke='%23bde0fb' d='M12 14h1m-2 1h1'/%3E%3Cpath stroke='%238fa7df' d='M14 14h1'/%3E%3Cpath stroke='%2387a0de' d='M0 15h1'/%3E%3Cpath stroke='%23c5ddfc' d='M1 15h1'/%3E%3Cpath stroke='%23c8e3fb' d='M7 15h1'/%3E%3Cpath stroke='%23b9dafb' d='M13 15h1'/%3E%3Cpath stroke='%238ca7de' d='M14 15h1m-2 1h1'/%3E%3Cpath stroke='%23c3cde7' d='M0 16h1'/%3E%3Cpath stroke='%2393a7df' d='M1 16h1'/%3E%3Cpath stroke='%2396acdf' d='M2 16h1m4 0h1'/%3E%3Cpath stroke='%2390abe0' d='M11 16h1'/%3E%3Cpath stroke='%23becbe6' d='M14 16h1'/%3E%3C/svg%3E")
}

.wbox select:active {
	background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 15 17' shape-rendering='crispEdges'%3E%3Cpath stroke='%23bbc2dc' d='M0 0h1'/%3E%3Cpath stroke='%23a2acdc' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%2398a1dd' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23919bda' d='M3 0h1M0 3h1M0 4h1'/%3E%3Cpath stroke='%238c97dc' d='M4 0h2M0 5h1'/%3E%3Cpath stroke='%238793db' d='M6 0h1M0 6h1'/%3E%3Cpath stroke='%238592d9' d='M7 0h1'/%3E%3Cpath stroke='%23838fda' d='M8 0h1M0 7h1M0 8h1'/%3E%3Cpath stroke='%23828dd9' d='M9 0h2M0 9h1'/%3E%3Cpath stroke='%237f8ada' d='M11 0h1'/%3E%3Cpath stroke='%237b88da' d='M12 0h1'/%3E%3Cpath stroke='%237786d9' d='M13 0h1'/%3E%3Cpath stroke='%23afb6db' d='M14 0h1'/%3E%3Cpath stroke='%236e8ef1' d='M1 1h1'/%3E%3Cpath stroke='%236e94f1' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%237598f1' d='M3 1h1'/%3E%3Cpath stroke='%237d9df1' d='M4 1h2M1 6h1'/%3E%3Cpath stroke='%23809df1' d='M6 1h1M1 7h1M1 8h1'/%3E%3Cpath stroke='%2383a0f0' d='M7 1h1'/%3E%3Cpath stroke='%23899fef' d='M8 1h1m4 1h1'/%3E%3Cpath stroke='%238d9eef' d='M9 1h3M1 12h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23869df0' d='M12 1h1'/%3E%3Cpath stroke='%238096f1' d='M13 1h1'/%3E%3Cpath stroke='%23b9c9f3' d='M14 1h1M3 16h4'/%3E%3Cpath stroke='%23759cf1' d='M2 2h1'/%3E%3Cpath stroke='%237ca4f0' d='M3 2h1M3 3h1M3 4h1M2 5h2'/%3E%3Cpath stroke='%2380a6f1' d='M4 2h2'/%3E%3Cpath stroke='%2383a7f0' d='M6 2h1M4 3h2M4 4h2'/%3E%3Cpath stroke='%238daaef' d='M7 2h1'/%3E%3Cpath stroke='%2390a7ef' d='M8 2h3'/%3E%3Cpath stroke='%2394a8ef' d='M11 2h1'/%3E%3Cpath stroke='%2390a4ef' d='M12 2h1m0 1h1m-1 1h1m-8 8h1m-1 1h1m-5 1h1'/%3E%3Cpath stroke='%23baccf4' d='M14 2h1m-1 5h1m-1 1h1'/%3E%3Cpath stroke='%237396f2' d='M1 3h1M1 4h1'/%3E%3Cpath stroke='%23759ef1' d='M2 3h1M2 4h1'/%3E%3Cpath stroke='%2390b1f2' d='M6 3h1M6 4h1M6 5h1'/%3E%3Cpath stroke='%2393aff2' d='M7 3h1M7 4h1'/%3E%3Cpath stroke='%2397afee' d='M8 3h3M8 4h3'/%3E%3Cpath stroke='%239aaaee' d='M11 3h1m-1 1h1'/%3E%3Cpath stroke='%2397abee' d='M12 3h1m-1 1h1m0 1h1M3 14h1m-2 1h1'/%3E%3Cpath stroke='%23bcccf3' d='M14 3h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%237997f1' d='M1 5h1'/%3E%3Cpath stroke='%2383a6f4' d='M4 5h2'/%3E%3Cpath stroke='%239aaff1' d='M7 5h1'/%3E%3Cpath stroke='%239eb1f2' d='M8 5h1m0 6h2'/%3E%3Cpath stroke='%239bb0ef' d='M9 5h4M3 15h1'/%3E%3Cpath stroke='%23809ff1' d='M2 6h1'/%3E%3Cpath stroke='%2387a3f4' d='M3 6h1M2 7h1M2 8h2'/%3E%3Cpath stroke='%234d6185' d='M4 6h1m5 0h1M3 7h3m3 0h3M4 8h3m1 0h3M5 9h5m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%2393acf2' d='M5 6h3M6 7h2M7 8h1M4 9h1'/%3E%3Cpath stroke='%239eaef2' d='M8 6h2'/%3E%3Cpath stroke='%239baeef' d='M11 6h3m-8 8h1'/%3E%3Cpath stroke='%2395abf4' d='M8 7h1'/%3E%3Cpath stroke='%23a2b2ee' d='M12 7h2m-2 1h2m-7 6h1'/%3E%3Cpath stroke='%23a3b4f3' d='M11 8h1m-4 3h1'/%3E%3Cpath stroke='%238da3f3' d='M1 9h1m-1 1h5m-3 1h1'/%3E%3Cpath stroke='%2389a3f3' d='M2 9h2'/%3E%3Cpath stroke='%2397adf2' d='M10 9h1'/%3E%3Cpath stroke='%23a6b6f2' d='M11 9h2m-2 2h1'/%3E%3Cpath stroke='%23a4b7ed' d='M13 9h1m-6 3h3m-3 1h3'/%3E%3Cpath stroke='%23b9cbf3' d='M14 9h1'/%3E%3Cpath stroke='%237c89db' d='M0 10h1'/%3E%3Cpath stroke='%23a5b6f1' d='M9 10h2'/%3E%3Cpath stroke='%23a8b8f1' d='M11 10h2'/%3E%3Cpath stroke='%23aabcef' d='M13 10h1m-3 2h1m-1 1h1m-5 2h1'/%3E%3Cpath stroke='%23b5c9f3' d='M14 10h1'/%3E%3Cpath stroke='%237988db' d='M0 11h1'/%3E%3Cpath stroke='%2390a4f2' d='M1 11h2m1 0h2'/%3E%3Cpath stroke='%238da1ef' d='M6 11h1m-5 1h4m-4 1h4'/%3E%3Cpath stroke='%23a9bcf2' d='M12 11h1'/%3E%3Cpath stroke='%23afbfed' d='M13 11h1m-6 4h1'/%3E%3Cpath stroke='%23b3c8f5' d='M14 11h1m-7 5h3'/%3E%3Cpath stroke='%237583db' d='M0 12h1m-1 1h1'/%3E%3Cpath stroke='%2397a7ee' d='M7 12h1m-1 1h1'/%3E%3Cpath stroke='%23b4c7ee' d='M12 12h1m-1 1h1m-4 2h2'/%3E%3Cpath stroke='%23b7c9ee' d='M13 12h1m-1 1h1m-3 2h1'/%3E%3Cpath stroke='%23b2c8f4' d='M14 12h1m-1 1h1m-4 3h1'/%3E%3Cpath stroke='%237381d9' d='M0 14h1m-1 1h1'/%3E%3Cpath stroke='%239baaef' d='M4 14h2'/%3E%3Cpath stroke='%23a9baee' d='M8 14h1m-3 1h1'/%3E%3Cpath stroke='%23adbcef' d='M9 14h2'/%3E%3Cpath stroke='%23b4c2ee' d='M11 14h1'/%3E%3Cpath stroke='%23becfed' d='M12 14h1'/%3E%3Cpath stroke='%23c4d4ec' d='M13 14h1m-2 1h1'/%3E%3Cpath stroke='%23b1c6f3' d='M14 14h1m-3 2h1'/%3E%3Cpath stroke='%23a2b6ee' d='M4 15h2'/%3E%3Cpath stroke='%23d2deeb' d='M13 15h1'/%3E%3Cpath stroke='%23b0c5f2' d='M14 15h1m-2 1h1'/%3E%3Cpath stroke='%23dbe3f8' d='M0 16h1'/%3E%3Cpath stroke='%23b7c6f1' d='M1 16h1'/%3E%3Cpath stroke='%23b8c9f2' d='M2 16h1m4 0h1'/%3E%3Cpath stroke='%23d9e3f6' d='M14 16h1'/%3E%3C/svg%3E")
}

.wbox input[type=radio] {
	appearance: none;
	-webkit-appearance: none;
	-moz-appearance: none;
	margin: 0;
	background: 0;
	/*position: fixed;*/
	opacity: 0;
	border: none
}

.wbox input[type=radio]+label {
	line-height: 16px
}

.wbox input[type=radio]+label:before {
	background: linear-gradient(135deg, #dcdcd7, #fff);
	border-radius: 50%;
	border: 1px solid #1d5281
}

.wbox input[type=radio]:not([disabled]):not(:active)+label:hover:before {
	box-shadow: inset -2px -2px #f8b636, inset 2px 2px #fedf9c
}

.wbox input[type=radio]:active+label:before {
	background: linear-gradient(135deg, #b0b0a7, #e3e1d2)
}

.wbox input[type=radio]:checked+label:after {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 5 5' shape-rendering='crispEdges'%3E%3Cpath stroke='%23a9dca6' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%234dbf4a' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23a0d29e' d='M3 0h1M0 3h1'/%3E%3Cpath stroke='%2355d551' d='M1 1h1'/%3E%3Cpath stroke='%2343c33f' d='M2 1h1'/%3E%3Cpath stroke='%2329a826' d='M3 1h1'/%3E%3Cpath stroke='%239acc98' d='M4 1h1M1 4h1'/%3E%3Cpath stroke='%2342c33f' d='M1 2h1'/%3E%3Cpath stroke='%2338b935' d='M2 2h1'/%3E%3Cpath stroke='%2321a121' d='M3 2h1'/%3E%3Cpath stroke='%23269623' d='M4 2h1'/%3E%3Cpath stroke='%232aa827' d='M1 3h1'/%3E%3Cpath stroke='%2322a220' d='M2 3h1'/%3E%3Cpath stroke='%23139210' d='M3 3h1'/%3E%3Cpath stroke='%2398c897' d='M4 3h1'/%3E%3Cpath stroke='%23249624' d='M2 4h1'/%3E%3Cpath stroke='%2398c997' d='M3 4h1'/%3E%3C/svg%3E")
}

.wbox input[type=radio]:focus+label {
	outline: 1px dotted #000
}

.wbox input[type=radio][disabled]+label:before {
	border: 1px solid #cac8bb;
	background: #fff
}

.wbox input[type=radio][disabled]:checked+label:after {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 5 5' shape-rendering='crispEdges'%3E%3Cpath stroke='%23e8e6da' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%23d2ceb5' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23e5e3d4' d='M3 0h1M0 3h1'/%3E%3Cpath stroke='%23d7d3bd' d='M1 1h1'/%3E%3Cpath stroke='%23d0ccb2' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%23c7c2a2' d='M3 1h1M1 3h1'/%3E%3Cpath stroke='%23e2dfd0' d='M4 1h1M1 4h1'/%3E%3Cpath stroke='%23cdc8ac' d='M2 2h1'/%3E%3Cpath stroke='%23c5bf9f' d='M3 2h1M2 3h1'/%3E%3Cpath stroke='%23c3bd9c' d='M4 2h1'/%3E%3Cpath stroke='%23bfb995' d='M3 3h1'/%3E%3Cpath stroke='%23e2dfcf' d='M4 3h1M3 4h1'/%3E%3Cpath stroke='%23c4be9d' d='M2 4h1'/%3E%3C/svg%3E")
}

.wbox input[type=checkbox]+label:before {
	box-shadow: none;
	border: 1px solid #1d5281;
	background: linear-gradient(135deg, #dcdcd7, #fff)
}

.wbox input[type=checkbox]:checked+label:after {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 11 11' shape-rendering='crispEdges'%3E%3Cpath stroke='%2322a122' d='M8 2h1M7 3h2M2 4h1m3 0h3M2 5h2m1 0h3M2 6h5M3 7h3M4 8h1'/%3E%3C/svg%3E");
	left: -17px
}

.wbox input[type=checkbox]:not([disabled]):not(:active)+label:hover:before {
	box-shadow: inset -2px -2px #f8b636, inset 2px 2px #fedf9c
}

.wbox input[type=checkbox]:active+label:before {
	background: linear-gradient(135deg, #b0b0a7, #e3e1d2)
}

.wbox input[type=checkbox][disabled]+label:before {
	background: #fff;
	border: 1px solid #cac8bb
}

.wbox input[type=checkbox][disabled]:checked+label:after {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 11 11' shape-rendering='crispEdges'%3E%3Cpath stroke='%23cac8bb' d='M8 2h1M7 3h2M2 4h1m3 0h3M2 5h2m1 0h3M2 6h5M3 7h3M4 8h1'/%3E%3C/svg%3E")
}

.wbox input[type=email],
.wbox input[type=password],
.wbox input[type=text],
.wbox select {
	height: auto;
}

.wbox input::selection {
	background: #2267cb;
	color: #fff
}

.wbox textarea::selection {
	background: #2267cb;
	color: #fff
}

.wbox input[type=range]::-webkit-slider-thumb {
	height: 21px;
	width: 11px;
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 11 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23becbd3' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%23b6c5cd' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23b5c4cd' d='M3 0h5M0 3h1M0 4h1M0 5h1M0 6h1M0 7h1M0 8h1M0 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23afbfc8' d='M8 0h1M0 14h1'/%3E%3Cpath stroke='%239fb2be' d='M9 0h1M0 15h1'/%3E%3Cpath stroke='%23a6d1b1' d='M1 1h1'/%3E%3Cpath stroke='%236fd16e' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%2367ce65' d='M3 1h1M1 3h1'/%3E%3Cpath stroke='%2366ce64' d='M4 1h3'/%3E%3Cpath stroke='%2362cd61' d='M7 1h1'/%3E%3Cpath stroke='%2345c343' d='M8 1h1M7 2h1'/%3E%3Cpath stroke='%2363ac76' d='M9 1h1M2 16h1m0 1h1m0 1h1'/%3E%3Cpath stroke='%23879aa6' d='M10 1h1'/%3E%3Cpath stroke='%2363cd62' d='M2 2h1'/%3E%3Cpath stroke='%2349c547' d='M3 2h1M2 3h1'/%3E%3Cpath stroke='%2347c446' d='M4 2h3'/%3E%3Cpath stroke='%2321b71f' d='M8 2h1'/%3E%3Cpath stroke='%231da41c' d='M9 2h1'/%3E%3Cpath stroke='%237d8e99' d='M10 2h1'/%3E%3Cpath stroke='%2325b923' d='M3 3h1'/%3E%3Cpath stroke='%2321b81f' d='M4 3h4M2 15h1'/%3E%3Cpath stroke='%231ea71c' d='M8 3h1'/%3E%3Cpath stroke='%231b9619' d='M9 3h1'/%3E%3Cpath stroke='%23778892' d='M10 3h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f7f7f4' d='M1 4h1M1 5h1M1 6h1M1 7h1M1 8h1M1 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f5f5f2' d='M2 4h1M2 5h1M2 6h1M2 7h1M2 8h1M2 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f3f3ef' d='M3 4h5M3 5h5M3 6h5M3 7h5M3 8h5M3 9h5m-5 1h5m-5 1h5m-5 1h5m-5 1h4m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%23dcdcd9' d='M8 4h1M8 5h1M8 6h1M8 7h1M8 8h1M8 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23c3c3c0' d='M9 4h1M9 5h1M9 6h1M9 7h1M9 8h1M9 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f1f1ed' d='M7 13h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%23dbdbd8' d='M8 13h1'/%3E%3Cpath stroke='%23c4c4c1' d='M9 13h1'/%3E%3Cpath stroke='%234bc549' d='M1 14h1'/%3E%3Cpath stroke='%23f4f4f1' d='M2 14h1'/%3E%3Cpath stroke='%23e6e6e2' d='M7 14h1m-2 1h1'/%3E%3Cpath stroke='%23cececa' d='M8 14h1'/%3E%3Cpath stroke='%231a9319' d='M9 14h1'/%3E%3Cpath stroke='%23788993' d='M10 14h1'/%3E%3Cpath stroke='%2369b17b' d='M1 15h1'/%3E%3Cpath stroke='%23f2f2ee' d='M3 15h1m0 1h1'/%3E%3Cpath stroke='%23d0d0cc' d='M7 15h1m-2 1h1'/%3E%3Cpath stroke='%231a9118' d='M8 15h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%234c845a' d='M9 15h1'/%3E%3Cpath stroke='%2372838d' d='M10 15h1'/%3E%3Cpath stroke='%2391a6b2' d='M1 16h1m0 1h1m0 1h1m0 1h1'/%3E%3Cpath stroke='%2321b61f' d='M3 16h1m0 1h1'/%3E%3Cpath stroke='%23e7e7e3' d='M5 16h1'/%3E%3Cpath stroke='%234b8259' d='M8 16h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%236e7e88' d='M9 16h1m-2 1h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%23d7d7d4' d='M5 17h1'/%3E%3Cpath stroke='%231da21b' d='M5 18h1'/%3E%3Cpath stroke='%23589868' d='M5 19h1'/%3E%3Cpath stroke='%2380929e' d='M5 20h1'/%3E%3C/svg%3E");
	transform: translateY(-8px)
}

.wbox input[type=range]::-moz-range-thumb {
	height: 21px;
	width: 11px;
	border: 0;
	border-radius: 0;
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 11 21' shape-rendering='crispEdges'%3E%3Cpath stroke='%23becbd3' d='M1 0h1M0 1h1'/%3E%3Cpath stroke='%23b6c5cd' d='M2 0h1M0 2h1'/%3E%3Cpath stroke='%23b5c4cd' d='M3 0h5M0 3h1M0 4h1M0 5h1M0 6h1M0 7h1M0 8h1M0 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23afbfc8' d='M8 0h1M0 14h1'/%3E%3Cpath stroke='%239fb2be' d='M9 0h1M0 15h1'/%3E%3Cpath stroke='%23a6d1b1' d='M1 1h1'/%3E%3Cpath stroke='%236fd16e' d='M2 1h1M1 2h1'/%3E%3Cpath stroke='%2367ce65' d='M3 1h1M1 3h1'/%3E%3Cpath stroke='%2366ce64' d='M4 1h3'/%3E%3Cpath stroke='%2362cd61' d='M7 1h1'/%3E%3Cpath stroke='%2345c343' d='M8 1h1M7 2h1'/%3E%3Cpath stroke='%2363ac76' d='M9 1h1M2 16h1m0 1h1m0 1h1'/%3E%3Cpath stroke='%23879aa6' d='M10 1h1'/%3E%3Cpath stroke='%2363cd62' d='M2 2h1'/%3E%3Cpath stroke='%2349c547' d='M3 2h1M2 3h1'/%3E%3Cpath stroke='%2347c446' d='M4 2h3'/%3E%3Cpath stroke='%2321b71f' d='M8 2h1'/%3E%3Cpath stroke='%231da41c' d='M9 2h1'/%3E%3Cpath stroke='%237d8e99' d='M10 2h1'/%3E%3Cpath stroke='%2325b923' d='M3 3h1'/%3E%3Cpath stroke='%2321b81f' d='M4 3h4M2 15h1'/%3E%3Cpath stroke='%231ea71c' d='M8 3h1'/%3E%3Cpath stroke='%231b9619' d='M9 3h1'/%3E%3Cpath stroke='%23778892' d='M10 3h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f7f7f4' d='M1 4h1M1 5h1M1 6h1M1 7h1M1 8h1M1 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f5f5f2' d='M2 4h1M2 5h1M2 6h1M2 7h1M2 8h1M2 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f3f3ef' d='M3 4h5M3 5h5M3 6h5M3 7h5M3 8h5M3 9h5m-5 1h5m-5 1h5m-5 1h5m-5 1h4m-4 1h3m-2 1h1'/%3E%3Cpath stroke='%23dcdcd9' d='M8 4h1M8 5h1M8 6h1M8 7h1M8 8h1M8 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23c3c3c0' d='M9 4h1M9 5h1M9 6h1M9 7h1M9 8h1M9 9h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f1f1ed' d='M7 13h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%23dbdbd8' d='M8 13h1'/%3E%3Cpath stroke='%23c4c4c1' d='M9 13h1'/%3E%3Cpath stroke='%234bc549' d='M1 14h1'/%3E%3Cpath stroke='%23f4f4f1' d='M2 14h1'/%3E%3Cpath stroke='%23e6e6e2' d='M7 14h1m-2 1h1'/%3E%3Cpath stroke='%23cececa' d='M8 14h1'/%3E%3Cpath stroke='%231a9319' d='M9 14h1'/%3E%3Cpath stroke='%23788993' d='M10 14h1'/%3E%3Cpath stroke='%2369b17b' d='M1 15h1'/%3E%3Cpath stroke='%23f2f2ee' d='M3 15h1m0 1h1'/%3E%3Cpath stroke='%23d0d0cc' d='M7 15h1m-2 1h1'/%3E%3Cpath stroke='%231a9118' d='M8 15h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%234c845a' d='M9 15h1'/%3E%3Cpath stroke='%2372838d' d='M10 15h1'/%3E%3Cpath stroke='%2391a6b2' d='M1 16h1m0 1h1m0 1h1m0 1h1'/%3E%3Cpath stroke='%2321b61f' d='M3 16h1m0 1h1'/%3E%3Cpath stroke='%23e7e7e3' d='M5 16h1'/%3E%3Cpath stroke='%234b8259' d='M8 16h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%236e7e88' d='M9 16h1m-2 1h1m-2 1h1m-2 1h1'/%3E%3Cpath stroke='%23d7d7d4' d='M5 17h1'/%3E%3Cpath stroke='%231da21b' d='M5 18h1'/%3E%3Cpath stroke='%23589868' d='M5 19h1'/%3E%3Cpath stroke='%2380929e' d='M5 20h1'/%3E%3C/svg%3E");
	transform: translateY(2px)
}

.wbox input[type=range]::-webkit-slider-runnable-track {
	width: 100%;
	height: 2px;
	box-sizing: border-box;
	background: #ecebe4;
	border-right: 1px solid #f3f2ea;
	border-bottom: 1px solid #f3f2ea;
	border-radius: 2px;
	box-shadow: 1px 0 0 #fff, 1px 1px 0 #fff, 0 1px 0 #fff, -1px 0 0 #9d9c99, -1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, -1px 1px 0 #fff, 1px -1px #9d9c99
}

.wbox input[type=range]::-moz-range-track {
	width: 100%;
	height: 2px;
	box-sizing: border-box;
	background: #ecebe4;
	border-right: 1px solid #f3f2ea;
	border-bottom: 1px solid #f3f2ea;
	border-radius: 2px;
	box-shadow: 1px 0 0 #fff, 1px 1px 0 #fff, 0 1px 0 #fff, -1px 0 0 #9d9c99, -1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, -1px 1px 0 #fff, 1px -1px #9d9c99
}

.wbox input[type=range].has-box-indicator::-webkit-slider-thumb {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 11 22' shape-rendering='crispEdges'%3E%3Cpath stroke='%23f2f1e7' d='M0 0h1m9 0h1M0 21h1m9 0h1'/%3E%3Cpath stroke='%23879aa6' d='M1 0h1m8 20h1'/%3E%3Cpath stroke='%237d8e99' d='M2 0h1m7 19h1'/%3E%3Cpath stroke='%23778892' d='M3 0h5m2 3h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23788993' d='M8 0h1m1 2h1'/%3E%3Cpath stroke='%2372838d' d='M9 0h1m0 1h1'/%3E%3Cpath stroke='%239fb2be' d='M0 1h1m8 20h1'/%3E%3Cpath stroke='%2363af76' d='M1 1h1m7 19h1'/%3E%3Cpath stroke='%231eab1c' d='M2 1h1m6 18h1'/%3E%3Cpath stroke='%231c9d1a' d='M3 1h1'/%3E%3Cpath stroke='%231b9a1a' d='M4 1h3m1 0h1m0 1h1'/%3E%3Cpath stroke='%231b9b1a' d='M7 1h1'/%3E%3Cpath stroke='%234d875b' d='M9 1h1'/%3E%3Cpath stroke='%23afbfc8' d='M0 2h1m7 19h1'/%3E%3Cpath stroke='%2346ca44' d='M1 2h1m5 17h1m0 1h1'/%3E%3Cpath stroke='%2322be20' d='M2 2h1m5 17h1'/%3E%3Cpath stroke='%231faf1d' d='M3 2h1'/%3E%3Cpath stroke='%231fae1d' d='M4 2h3'/%3E%3Cpath stroke='%231fad1d' d='M7 2h1'/%3E%3Cpath stroke='%231da11b' d='M8 2h1'/%3E%3Cpath stroke='%23b5c4cd' d='M0 3h1M0 4h1M0 5h1M0 6h1M0 7h1M0 8h1M0 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m2 3h5'/%3E%3Cpath stroke='%23f7f7f4' d='M1 3h1M1 4h1M1 5h1M1 6h1M1 7h1M1 8h1M1 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f5f5f2' d='M2 3h1M2 4h1M2 5h1M2 6h1M2 7h1M2 8h1M2 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f3f3ef' d='M3 3h4M3 4h5M3 5h5M3 6h5M3 7h5M3 8h5M3 9h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5'/%3E%3Cpath stroke='%23f1f1ed' d='M7 3h1'/%3E%3Cpath stroke='%23dbdbd8' d='M8 3h1'/%3E%3Cpath stroke='%23c4c4c1' d='M9 3h1'/%3E%3Cpath stroke='%23ddddd9' d='M8 4h1M8 18h1'/%3E%3Cpath stroke='%23c6c6c3' d='M9 4h1M9 18h1'/%3E%3Cpath stroke='%23dcdcd9' d='M8 5h1M8 6h1M8 7h1M8 8h1M8 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23c3c3c0' d='M9 5h1M9 6h1M9 7h1M9 8h1M9 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b6c5cd' d='M0 19h1m1 2h1'/%3E%3Cpath stroke='%2370d66f' d='M1 19h1m0 1h1'/%3E%3Cpath stroke='%2364d362' d='M2 19h1'/%3E%3Cpath stroke='%234acb48' d='M3 19h1'/%3E%3Cpath stroke='%2348cb46' d='M4 19h3'/%3E%3Cpath stroke='%23becbd3' d='M0 20h1m0 1h1'/%3E%3Cpath stroke='%23a6d2b1' d='M1 20h1'/%3E%3Cpath stroke='%2367d466' d='M3 20h1'/%3E%3Cpath stroke='%2366d465' d='M4 20h3'/%3E%3Cpath stroke='%2363d362' d='M7 20h1'/%3E%3C/svg%3E");
	transform: translateY(-10px)
}

.wbox input[type=range].has-box-indicator::-moz-range-thumb {
	background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -0.5 11 22' shape-rendering='crispEdges'%3E%3Cpath stroke='%23f2f1e7' d='M0 0h1m9 0h1M0 21h1m9 0h1'/%3E%3Cpath stroke='%23879aa6' d='M1 0h1m8 20h1'/%3E%3Cpath stroke='%237d8e99' d='M2 0h1m7 19h1'/%3E%3Cpath stroke='%23778892' d='M3 0h5m2 3h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23788993' d='M8 0h1m1 2h1'/%3E%3Cpath stroke='%2372838d' d='M9 0h1m0 1h1'/%3E%3Cpath stroke='%239fb2be' d='M0 1h1m8 20h1'/%3E%3Cpath stroke='%2363af76' d='M1 1h1m7 19h1'/%3E%3Cpath stroke='%231eab1c' d='M2 1h1m6 18h1'/%3E%3Cpath stroke='%231c9d1a' d='M3 1h1'/%3E%3Cpath stroke='%231b9a1a' d='M4 1h3m1 0h1m0 1h1'/%3E%3Cpath stroke='%231b9b1a' d='M7 1h1'/%3E%3Cpath stroke='%234d875b' d='M9 1h1'/%3E%3Cpath stroke='%23afbfc8' d='M0 2h1m7 19h1'/%3E%3Cpath stroke='%2346ca44' d='M1 2h1m5 17h1m0 1h1'/%3E%3Cpath stroke='%2322be20' d='M2 2h1m5 17h1'/%3E%3Cpath stroke='%231faf1d' d='M3 2h1'/%3E%3Cpath stroke='%231fae1d' d='M4 2h3'/%3E%3Cpath stroke='%231fad1d' d='M7 2h1'/%3E%3Cpath stroke='%231da11b' d='M8 2h1'/%3E%3Cpath stroke='%23b5c4cd' d='M0 3h1M0 4h1M0 5h1M0 6h1M0 7h1M0 8h1M0 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m2 3h5'/%3E%3Cpath stroke='%23f7f7f4' d='M1 3h1M1 4h1M1 5h1M1 6h1M1 7h1M1 8h1M1 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f5f5f2' d='M2 3h1M2 4h1M2 5h1M2 6h1M2 7h1M2 8h1M2 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23f3f3ef' d='M3 3h4M3 4h5M3 5h5M3 6h5M3 7h5M3 8h5M3 9h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5m-5 1h5'/%3E%3Cpath stroke='%23f1f1ed' d='M7 3h1'/%3E%3Cpath stroke='%23dbdbd8' d='M8 3h1'/%3E%3Cpath stroke='%23c4c4c1' d='M9 3h1'/%3E%3Cpath stroke='%23ddddd9' d='M8 4h1M8 18h1'/%3E%3Cpath stroke='%23c6c6c3' d='M9 4h1M9 18h1'/%3E%3Cpath stroke='%23dcdcd9' d='M8 5h1M8 6h1M8 7h1M8 8h1M8 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23c3c3c0' d='M9 5h1M9 6h1M9 7h1M9 8h1M9 9h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1m-1 1h1'/%3E%3Cpath stroke='%23b6c5cd' d='M0 19h1m1 2h1'/%3E%3Cpath stroke='%2370d66f' d='M1 19h1m0 1h1'/%3E%3Cpath stroke='%2364d362' d='M2 19h1'/%3E%3Cpath stroke='%234acb48' d='M3 19h1'/%3E%3Cpath stroke='%2348cb46' d='M4 19h3'/%3E%3Cpath stroke='%23becbd3' d='M0 20h1m0 1h1'/%3E%3Cpath stroke='%23a6d2b1' d='M1 20h1'/%3E%3Cpath stroke='%2367d466' d='M3 20h1'/%3E%3Cpath stroke='%2366d465' d='M4 20h3'/%3E%3Cpath stroke='%2363d362' d='M7 20h1'/%3E%3C/svg%3E");
	transform: translateY(0)
}

.wbox .is-vertical>input[type=range]::-webkit-slider-runnable-track {
	border-left: 1px solid #f3f2ea;
	border-right: 0;
	border-bottom: 1px solid #f3f2ea;
	box-shadow: -1px 0 0 #fff, -1px 1px 0 #fff, 0 1px 0 #fff, 1px 0 0 #9d9c99, 1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, 1px 1px 0 #fff, -1px -1px #9d9c99
}

.wbox .is-vertical>input[type=range]::-moz-range-track {
	border-left: 1px solid #f3f2ea;
	border-right: 0;
	border-bottom: 1px solid #f3f2ea;
	box-shadow: -1px 0 0 #fff, -1px 1px 0 #fff, 0 1px 0 #fff, 1px 0 0 #9d9c99, 1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, 1px 1px 0 #fff, -1px -1px #9d9c99
}

.wbox fieldset {
	box-shadow: none;
	background: #fff;
	border: 1px solid #d0d0bf;
	border-radius: 4px;
	padding-top: 10px
}

.wbox legend {
	background: transparent;
	color: #0046d5
}

.wbox .field-row {
	display: flex;
	align-items: center
}

.wbox .field-row>*+* {
	margin-left: 6px
}

.wbox [class^=field-row]+[class^=field-row] {
	margin-top: 6px
}

.wbox .field-row-stacked {
	display: flex;
	flex-direction: column
}

.wbox .field-row-stacked *+* {
	margin-top: 6px
}

.wbox menu[role=tablist] button {
	background: linear-gradient(180deg, #fff, #fafaf9 26%, #f0f0ea 95%, #ecebe5);
	margin-left: -1px;
	margin-right: 2px;
	border-radius: 0;
	border-color: #91a7b4;
	border-top-right-radius: 3px;
	border-top-left-radius: 3px;
	padding: 0 12px 3px
}

.wbox menu[role=tablist] button:hover {
	box-shadow: unset;
	border-top: 1px solid #e68b2c;
	box-shadow: inset 0 2px #ffc73c
}

.wbox menu[role=tablist] button[aria-selected=true] {
	background: #fcfcfe;
	border-color: #919b9c;
	margin-right: -1px;
	border-bottom: 1px solid transparent;
	border-top: 1px solid #e68b2c;
	box-shadow: inset 0 2px #ffc73c
}

.wbox menu[role=tablist] button[aria-selected=true]:first-of-type:before {
	content: "";
	display: block;
	position: absolute;
	z-index: -1;
	top: 100%;
	left: -1px;
	height: 2px;
	width: 0;
	border-left: 1px solid #919b9c
}

.wbox [role=tabpanel] {
	box-shadow: inset 1px 1px #fcfcfe, inset -1px -1px #fcfcfe, 1px 2px 2px 0 rgba(208, 206, 191, .75)
}

.wbox section {
  margin-bottom: 2em;
}

.wbox article {
  height : 100%;
  overflow:hidden;
}

.wbox ul.tree-view {
	-webkit-font-smoothing: auto;
	border: 1px solid #7f9db9;
	padding: 2px 5px
}


/*# sourceMappingURL=XP.css.map */

.wbox .hbox table {
  border: 0px;
}
.wbox .vbox table {
  border: 0px;
  display : inline-block;
}
.wbox .hbox .field-row,
.wbox .hbox .field-row-stacked {
  display:inline-block;
  margin-left: 5px;
  margin-right:5px;
}
.wbox .hbox .field-row label,
.wbox .hbox .field-row-stacked label {
  margin-right:5px;
}
</style>
 
    <script type="text/javascript">
      var Version = '1.3.1'
      process={
        argv:{} // filled with URL parameters ...
      } 
      function parseUrlParams(url) {
        if (!url) return {};
        url = url.replace(/#[^$]+$/,'');
        var queryString = url.substring( url.indexOf('?') + 1 );
        if (queryString == url) return {};
        var params = {}, queries, temp, i, l;
        // Split into key/value pairs
        queries = queryString.split("&");
        // Convert the array of strings into an object
        for ( i = 0, l = queries.length; i < l; i++ ) {
            temp = queries[i].split('=');
            if (temp[1]==undefined) temp[1]='true';
            params[temp[0]] = temp[1].replace('%20',' ');
        }
        return params;
      }
      function parseUrl(url) {
        function toParams (avl) {
          var params = {};
          avl.forEach(function (av) {
            var parts=av.split('=');
            params[parts[0]]=parts[1];
          })
          return params;
        }
        var tokens = url.match(/((file|http|https|udp|tcp):\/\/)?([a-zA-Z0-9_\.\-]+):(\[?[0-9]+\]?|\*)(\/[^\?]+)?(\?.+$)?/)
        if (!tokens) {
          tokens   = url.match(/((file|http|https|udp|tcp):\/\/)?([a-zA-Z0-9_\.\-]*)(\/[^\?]*)?(\?.+$)?/);
          return  {
            proto:  tokens[2],
            host:   tokens[3],
            port:   undefined,
            path:   tokens[4]||'',
            params:  tokens[5] && toParams(tokens[5].replace(/^\?/,'').split('&')),
          }
        } else return  {
          proto:  tokens[2],
          host:   tokens[3],
          port:   tokens[4] && Number(tokens[4]),
          path:   tokens[5]||'',
          params:  tokens[6] && toParams(tokens[6].replace(/^\?/,'').split('&')),
        }
      }
      var Config = {
        mode      : 'javascript',
        file      : '',
        thisthat  : true,
        turbo     : true, // enhanced scoped javascript compilation (snippet code)
        webxUrl     : 'localhost:9177',
        modules     : [],
        workdir     : '/',
      }
      var urldesc = parseUrl(document.URL),
          urlparams = urldesc.params;
      Object.assign(process.argv,urlparams);
      Object.assign(Config,urlparams);
      if (Config.script) Config.script=unescape(Config.script);
      Workers=[];
      BrowserVersion  = (function(){
        var ua= navigator.userAgent, tem, 
        M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if(/trident/i.test(M[1])){
          tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
          return 'IE '+(tem[1] || '');
        }
        if(M[1]=== 'Chrome'){
          tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
          if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
        }
        M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
        if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
        return {name:M[0],version:M[1]};
      })()
      process.argv.browser=BrowserVersion;
      Object.assign(process.argv,urldesc);
      function nop() {}
      Papa={init:nop};
      BufferObjects={init:nop};
      BufferSegment={init:nop};
   </script>
    <script type="text/javascript" charset="utf-8">/* https://github.com/feross/buffer */
/* Buffer Polyfill for Browsers */

function BufferInit() {
! function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).buffer = t()
    }
}(function() {
    return function() {
        return function t(r, e, n) {
            function i(f, u) {
                if (!e[f]) {
                    if (!r[f]) {
                        var s = "function" == typeof require && require;
                        if (!u && s) return s(f, !0);
                        if (o) return o(f, !0);
                        var h = new Error("Cannot find module '" + f + "'");
                        throw h.code = "MODULE_NOT_FOUND", h
                    }
                    var a = e[f] = {
                        exports: {}
                    };
                    r[f][0].call(a.exports, function(t) {
                        return i(r[f][1][t] || t)
                    }, a, a.exports, t, r, e, n)
                }
                return e[f].exports
            }
            for (var o = "function" == typeof require && require, f = 0; f < n.length; f++) i(n[f]);
            return i
        }
    }()({
        1: [function(t, r, e) {
            (function(r) {
                "use strict";
                var n = t("base64-js"),
                    i = t("ieee754"),
                    o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                e.Buffer = r, e.SlowBuffer = function(t) {
                    +t != t && (t = 0);
                    return r.alloc(+t)
                }, e.INSPECT_MAX_BYTES = 50;
                var f = 2147483647;

                function u(t) {
                    if (t > f) throw new RangeError('The value "' + t + '" is invalid for option "size"');
                    var e = new Uint8Array(t);
                    return Object.setPrototypeOf(e, r.prototype), e
                }

                function r(t, r, e) {
                    if ("number" == typeof t) {
                        if ("string" == typeof r) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return a(t)
                    }
                    return s(t, r, e)
                }

                function s(t, e, n) {
                    if ("string" == typeof t) return function(t, e) {
                        "string" == typeof e && "" !== e || (e = "utf8");
                        if (!r.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
                        var n = 0 | l(t, e),
                            i = u(n),
                            o = i.write(t, e);
                        o !== n && (i = i.slice(0, o));
                        return i
                    }(t, e);
                    if (ArrayBuffer.isView(t)) return p(t);
                    if (null == t) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
                    if (z(t, ArrayBuffer) || t && z(t.buffer, ArrayBuffer)) return function(t, e, n) {
                        if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
                        if (t.byteLength < e + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        var i;
                        i = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, e) : new Uint8Array(t, e, n);
                        return Object.setPrototypeOf(i, r.prototype), i
                    }(t, e, n);
                    if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var i = t.valueOf && t.valueOf();
                    if (null != i && i !== t) return r.from(i, e, n);
                    var o = function(t) {
                        if (r.isBuffer(t)) {
                            var e = 0 | c(t.length),
                                n = u(e);
                            return 0 === n.length ? n : (t.copy(n, 0, 0, e), n)
                        }
                        if (void 0 !== t.length) return "number" != typeof t.length || D(t.length) ? u(0) : p(t);
                        if ("Buffer" === t.type && Array.isArray(t.data)) return p(t.data)
                    }(t);
                    if (o) return o;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return r.from(t[Symbol.toPrimitive]("string"), e, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
                }

                function h(t) {
                    if ("number" != typeof t) throw new TypeError('"size" argument must be of type number');
                    if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"')
                }

                function a(t) {
                    return h(t), u(t < 0 ? 0 : 0 | c(t))
                }

                function p(t) {
                    for (var r = t.length < 0 ? 0 : 0 | c(t.length), e = u(r), n = 0; n < r; n += 1) e[n] = 255 & t[n];
                    return e
                }

                function c(t) {
                    if (t >= f) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + f.toString(16) + " bytes");
                    return 0 | t
                }

                function l(t, e) {
                    if (r.isBuffer(t)) return t.length;
                    if (ArrayBuffer.isView(t) || z(t, ArrayBuffer)) return t.byteLength;
                    if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
                    var n = t.length,
                        i = arguments.length > 2 && !0 === arguments[2];
                    if (!i && 0 === n) return 0;
                    for (var o = !1;;) switch (e) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return P(t).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return j(t).length;
                        default:
                            if (o) return i ? -1 : P(t).length;
                            e = ("" + e).toLowerCase(), o = !0
                    }
                }

                function y(t, r, e) {
                    var n = t[r];
                    t[r] = t[e], t[e] = n
                }

                function g(t, e, n, i, o) {
                    if (0 === t.length) return -1;
                    if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), D(n = +n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
                        if (o) return -1;
                        n = t.length - 1
                    } else if (n < 0) {
                        if (!o) return -1;
                        n = 0
                    }
                    if ("string" == typeof e && (e = r.from(e, i)), r.isBuffer(e)) return 0 === e.length ? -1 : w(t, e, n, i, o);
                    if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : w(t, [e], n, i, o);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function w(t, r, e, n, i) {
                    var o, f = 1,
                        u = t.length,
                        s = r.length;
                    if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                        if (t.length < 2 || r.length < 2) return -1;
                        f = 2, u /= 2, s /= 2, e /= 2
                    }

                    function h(t, r) {
                        return 1 === f ? t[r] : t.readUInt16BE(r * f)
                    }
                    if (i) {
                        var a = -1;
                        for (o = e; o < u; o++)
                            if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                                if (-1 === a && (a = o), o - a + 1 === s) return a * f
                            } else -1 !== a && (o -= o - a), a = -1
                    } else
                        for (e + s > u && (e = u - s), o = e; o >= 0; o--) {
                            for (var p = !0, c = 0; c < s; c++)
                                if (h(t, o + c) !== h(r, c)) {
                                    p = !1;
                                    break
                                }
                            if (p) return o
                        }
                    return -1
                }

                function d(t, r, e, n) {
                    e = Number(e) || 0;
                    var i = t.length - e;
                    n ? (n = Number(n)) > i && (n = i) : n = i;
                    var o = r.length;
                    n > o / 2 && (n = o / 2);
                    for (var f = 0; f < n; ++f) {
                        var u = parseInt(r.substr(2 * f, 2), 16);
                        if (D(u)) return f;
                        t[e + f] = u
                    }
                    return f
                }

                function v(t, r, e, n) {
                    return N(P(r, t.length - e), t, e, n)
                }

                function b(t, r, e, n) {
                    return N(function(t) {
                        for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
                        return r
                    }(r), t, e, n)
                }

                function m(t, r, e, n) {
                    return b(t, r, e, n)
                }

                function E(t, r, e, n) {
                    return N(j(r), t, e, n)
                }

                function B(t, r, e, n) {
                    return N(function(t, r) {
                        for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f) e = t.charCodeAt(f), n = e >> 8, i = e % 256, o.push(i), o.push(n);
                        return o
                    }(r, t.length - e), t, e, n)
                }

                function A(t, r, e) {
                    return 0 === r && e === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(r, e))
                }

                function U(t, r, e) {
                    e = Math.min(t.length, e);
                    for (var n = [], i = r; i < e;) {
                        var o, f, u, s, h = t[i],
                            a = null,
                            p = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                        if (i + p <= e) switch (p) {
                            case 1:
                                h < 128 && (a = h);
                                break;
                            case 2:
                                128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                                break;
                            case 3:
                                o = t[i + 1], f = t[i + 2], 128 == (192 & o) && 128 == (192 & f) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & f) > 2047 && (s < 55296 || s > 57343) && (a = s);
                                break;
                            case 4:
                                o = t[i + 1], f = t[i + 2], u = t[i + 3], 128 == (192 & o) && 128 == (192 & f) && 128 == (192 & u) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & f) << 6 | 63 & u) > 65535 && s < 1114112 && (a = s)
                        }
                        null === a ? (a = 65533, p = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += p
                    }
                    return function(t) {
                        var r = t.length;
                        if (r <= T) return String.fromCharCode.apply(String, t);
                        var e = "",
                            n = 0;
                        for (; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += T));
                        return e
                    }(n)
                }
                e.kMaxLength = f, r.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var t = new Uint8Array(1),
                            r = {
                                foo: function() {
                                    return 42
                                }
                            };
                        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(t, r), 42 === t.foo()
                    } catch (t) {
                        return !1
                    }
                }(), r.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(r.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(r.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.byteOffset
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && r[Symbol.species] === r && Object.defineProperty(r, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), r.poolSize = 8192, r.from = function(t, r, e) {
                    return s(t, r, e)
                }, Object.setPrototypeOf(r.prototype, Uint8Array.prototype), Object.setPrototypeOf(r, Uint8Array), r.alloc = function(t, r, e) {
                    return function(t, r, e) {
                        return h(t), t <= 0 ? u(t) : void 0 !== r ? "string" == typeof e ? u(t).fill(r, e) : u(t).fill(r) : u(t)
                    }(t, r, e)
                }, r.allocUnsafe = function(t) {
                    return a(t)
                }, r.allocUnsafeSlow = function(t) {
                    return a(t)
                }, r.isBuffer = function(t) {
                    return null != t && !0 === t._isBuffer && t !== r.prototype
                }, r.compare = function(t, e) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), z(e, Uint8Array) && (e = r.from(e, e.offset, e.byteLength)), !r.isBuffer(t) || !r.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (t === e) return 0;
                    for (var n = t.length, i = e.length, o = 0, f = Math.min(n, i); o < f; ++o)
                        if (t[o] !== e[o]) {
                            n = t[o], i = e[o];
                            break
                        }
                    return n < i ? -1 : i < n ? 1 : 0
                }, r.isEncoding = function(t) {
                    switch (String(t).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, r.concat = function(t, e) {
                    if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === t.length) return r.alloc(0);
                    var n;
                    if (void 0 === e)
                        for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                    var i = r.allocUnsafe(e),
                        o = 0;
                    for (n = 0; n < t.length; ++n) {
                        var f = t[n];
                        if (z(f, Uint8Array) && (f = r.from(f)), !r.isBuffer(f)) throw new TypeError('"list" argument must be an Array of Buffers');
                        f.copy(i, o), o += f.length
                    }
                    return i
                }, r.byteLength = l, r.prototype._isBuffer = !0, r.prototype.swap16 = function() {
                    var t = this.length;
                    if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var r = 0; r < t; r += 2) y(this, r, r + 1);
                    return this
                }, r.prototype.swap32 = function() {
                    var t = this.length;
                    if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var r = 0; r < t; r += 4) y(this, r, r + 3), y(this, r + 1, r + 2);
                    return this
                }, r.prototype.swap64 = function() {
                    var t = this.length;
                    if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var r = 0; r < t; r += 8) y(this, r, r + 7), y(this, r + 1, r + 6), y(this, r + 2, r + 5), y(this, r + 3, r + 4);
                    return this
                }, r.prototype.toString = function() {
                    var t = this.length;
                    return 0 === t ? "" : 0 === arguments.length ? U(this, 0, t) : function(t, r, e) {
                        var n = !1;
                        if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
                        if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
                        if ((e >>>= 0) <= (r >>>= 0)) return "";
                        for (t || (t = "utf8");;) switch (t) {
                            case "hex":
                                return L(this, r, e);
                            case "utf8":
                            case "utf-8":
                                return U(this, r, e);
                            case "ascii":
                                return I(this, r, e);
                            case "latin1":
                            case "binary":
                                return S(this, r, e);
                            case "base64":
                                return A(this, r, e);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return R(this, r, e);
                            default:
                                if (n) throw new TypeError("Unknown encoding: " + t);
                                t = (t + "").toLowerCase(), n = !0
                        }
                    }.apply(this, arguments)
                }, r.prototype.toLocaleString = r.prototype.toString, r.prototype.equals = function(t) {
                    if (!r.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                    return this === t || 0 === r.compare(this, t)
                }, r.prototype.inspect = function() {
                    var t = "",
                        r = e.INSPECT_MAX_BYTES;
                    return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"
                }, o && (r.prototype[o] = r.prototype.inspect), r.prototype.compare = function(t, e, n, i, o) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), !r.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
                    if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), e < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError("out of range index");
                    if (i >= o && e >= n) return 0;
                    if (i >= o) return -1;
                    if (e >= n) return 1;
                    if (this === t) return 0;
                    for (var f = (o >>>= 0) - (i >>>= 0), u = (n >>>= 0) - (e >>>= 0), s = Math.min(f, u), h = this.slice(i, o), a = t.slice(e, n), p = 0; p < s; ++p)
                        if (h[p] !== a[p]) {
                            f = h[p], u = a[p];
                            break
                        }
                    return f < u ? -1 : u < f ? 1 : 0
                }, r.prototype.includes = function(t, r, e) {
                    return -1 !== this.indexOf(t, r, e)
                }, r.prototype.indexOf = function(t, r, e) {
                    return g(this, t, r, e, !0)
                }, r.prototype.lastIndexOf = function(t, r, e) {
                    return g(this, t, r, e, !1)
                }, r.prototype.write = function(t, r, e, n) {
                    if (void 0 === r) n = "utf8", e = this.length, r = 0;
                    else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
                    else {
                        if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        r >>>= 0, isFinite(e) ? (e >>>= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
                    }
                    var i = this.length - r;
                    if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    n || (n = "utf8");
                    for (var o = !1;;) switch (n) {
                        case "hex":
                            return d(this, t, r, e);
                        case "utf8":
                        case "utf-8":
                            return v(this, t, r, e);
                        case "ascii":
                            return b(this, t, r, e);
                        case "latin1":
                        case "binary":
                            return m(this, t, r, e);
                        case "base64":
                            return E(this, t, r, e);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return B(this, t, r, e);
                        default:
                            if (o) throw new TypeError("Unknown encoding: " + n);
                            n = ("" + n).toLowerCase(), o = !0
                    }
                }, r.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                var T = 4096;

                function I(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
                    return n
                }

                function S(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
                    return n
                }

                function L(t, r, e) {
                    var n = t.length;
                    (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
                    for (var i = "", o = r; o < e; ++o) i += F[t[o]];
                    return i
                }

                function R(t, r, e) {
                    for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
                    return i
                }

                function C(t, r, e) {
                    if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                    if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
                }

                function O(t, e, n, i, o, f) {
                    if (!r.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (e > o || e < f) throw new RangeError('"value" argument is out of bounds');
                    if (n + i > t.length) throw new RangeError("Index out of range")
                }

                function _(t, r, e, n, i, o) {
                    if (e + n > t.length) throw new RangeError("Index out of range");
                    if (e < 0) throw new RangeError("Index out of range")
                }

                function x(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || _(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4
                }

                function M(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || _(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8
                }
                r.prototype.slice = function(t, e) {
                    var n = this.length;
                    (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t);
                    var i = this.subarray(t, e);
                    return Object.setPrototypeOf(i, r.prototype), i
                }, r.prototype.readUIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n
                }, r.prototype.readUIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);) n += this[t + --r] * i;
                    return n
                }, r.prototype.readUInt8 = function(t, r) {
                    return t >>>= 0, r || C(t, 1, this.length), this[t]
                }, r.prototype.readUInt16LE = function(t, r) {
                    return t >>>= 0, r || C(t, 2, this.length), this[t] | this[t + 1] << 8
                }, r.prototype.readUInt16BE = function(t, r) {
                    return t >>>= 0, r || C(t, 2, this.length), this[t] << 8 | this[t + 1]
                }, r.prototype.readUInt32LE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
                }, r.prototype.readUInt32BE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
                }, r.prototype.readIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n
                }, r.prototype.readIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) o += this[t + --n] * i;
                    return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o
                }, r.prototype.readInt8 = function(t, r) {
                    return t >>>= 0, r || C(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                }, r.prototype.readInt16LE = function(t, r) {
                    t >>>= 0, r || C(t, 2, this.length);
                    var e = this[t] | this[t + 1] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt16BE = function(t, r) {
                    t >>>= 0, r || C(t, 2, this.length);
                    var e = this[t + 1] | this[t] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt32LE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
                }, r.prototype.readInt32BE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
                }, r.prototype.readFloatLE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), i.read(this, t, !0, 23, 4)
                }, r.prototype.readFloatBE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), i.read(this, t, !1, 23, 4)
                }, r.prototype.readDoubleLE = function(t, r) {
                    return t >>>= 0, r || C(t, 8, this.length), i.read(this, t, !0, 52, 8)
                }, r.prototype.readDoubleBE = function(t, r) {
                    return t >>>= 0, r || C(t, 8, this.length), i.read(this, t, !1, 52, 8)
                }, r.prototype.writeUIntLE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || O(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = 1,
                        o = 0;
                    for (this[r] = 255 & t; ++o < e && (i *= 256);) this[r + o] = t / i & 255;
                    return r + e
                }, r.prototype.writeUIntBE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || O(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = e - 1,
                        o = 1;
                    for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);) this[r + i] = t / o & 255;
                    return r + e
                }, r.prototype.writeUInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 1, 255, 0), this[r] = 255 & t, r + 1
                }, r.prototype.writeUInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 65535, 0), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeUInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeUInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t, r + 4
                }, r.prototype.writeUInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeIntLE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        O(this, t, r, e, i - 1, -i)
                    }
                    var o = 0,
                        f = 1,
                        u = 0;
                    for (this[r] = 255 & t; ++o < e && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeIntBE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        O(this, t, r, e, i - 1, -i)
                    }
                    var o = e - 1,
                        f = 1,
                        u = 0;
                    for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
                }, r.prototype.writeInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 32767, -32768), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 2147483647, -2147483648), this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4
                }, r.prototype.writeInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeFloatLE = function(t, r, e) {
                    return x(this, t, r, !0, e)
                }, r.prototype.writeFloatBE = function(t, r, e) {
                    return x(this, t, r, !1, e)
                }, r.prototype.writeDoubleLE = function(t, r, e) {
                    return M(this, t, r, !0, e)
                }, r.prototype.writeDoubleBE = function(t, r, e) {
                    return M(this, t, r, !1, e)
                }, r.prototype.copy = function(t, e, n, i) {
                    if (!r.isBuffer(t)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0;
                    if (0 === t.length || 0 === this.length) return 0;
                    if (e < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (i < 0) throw new RangeError("sourceEnd out of bounds");
                    i > this.length && (i = this.length), t.length - e < i - n && (i = t.length - e + n);
                    var o = i - n;
                    if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(e, n, i);
                    else if (this === t && n < e && e < i)
                        for (var f = o - 1; f >= 0; --f) t[f + e] = this[f + n];
                    else Uint8Array.prototype.set.call(t, this.subarray(n, i), e);
                    return o
                }, r.prototype.fill = function(t, e, n, i) {
                    if ("string" == typeof t) {
                        if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                        if ("string" == typeof i && !r.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                        if (1 === t.length) {
                            var o = t.charCodeAt(0);
                            ("utf8" === i && o < 128 || "latin1" === i) && (t = o)
                        }
                    } else "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t));
                    if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index");
                    if (n <= e) return this;
                    var f;
                    if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t)
                        for (f = e; f < n; ++f) this[f] = t;
                    else {
                        var u = r.isBuffer(t) ? t : r.from(t, i),
                            s = u.length;
                        if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                        for (f = 0; f < n - e; ++f) this[f + e] = u[f % s]
                    }
                    return this
                };
                var k = /[^+\/0-9A-Za-z-_]/g;

                function P(t, r) {
                    var e;
                    r = r || 1 / 0;
                    for (var n = t.length, i = null, o = [], f = 0; f < n; ++f) {
                        if ((e = t.charCodeAt(f)) > 55295 && e < 57344) {
                            if (!i) {
                                if (e > 56319) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (f + 1 === n) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = e;
                                continue
                            }
                            if (e < 56320) {
                                (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                                continue
                            }
                            e = 65536 + (i - 55296 << 10 | e - 56320)
                        } else i && (r -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, e < 128) {
                            if ((r -= 1) < 0) break;
                            o.push(e)
                        } else if (e < 2048) {
                            if ((r -= 2) < 0) break;
                            o.push(e >> 6 | 192, 63 & e | 128)
                        } else if (e < 65536) {
                            if ((r -= 3) < 0) break;
                            o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                        } else {
                            if (!(e < 1114112)) throw new Error("Invalid code point");
                            if ((r -= 4) < 0) break;
                            o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                        }
                    }
                    return o
                }

                function j(t) {
                    return n.toByteArray(function(t) {
                        if ((t = (t = t.split("=")[0]).trim().replace(k, "")).length < 2) return "";
                        for (; t.length % 4 != 0;) t += "=";
                        return t
                    }(t))
                }

                function N(t, r, e, n) {
                    for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i) r[i + e] = t[i];
                    return i
                }

                function z(t, r) {
                    return t instanceof r || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === r.name
                }

                function D(t) {
                    return t != t
                }
                var F = function() {
                    for (var t = new Array(256), r = 0; r < 16; ++r)
                        for (var e = 16 * r, n = 0; n < 16; ++n) t[e + n] = "0123456789abcdef" [r] + "0123456789abcdef" [n];
                    return t
                }()
            }).call(this, t("buffer").Buffer)
        }, {
            "base64-js": 2,
            buffer: 5,
            ieee754: 3
        }],
        2: [function(t, r, e) {
            "use strict";
            e.byteLength = function(t) {
                var r = h(t),
                    e = r[0],
                    n = r[1];
                return 3 * (e + n) / 4 - n
            }, e.toByteArray = function(t) {
                var r, e, n = h(t),
                    f = n[0],
                    u = n[1],
                    s = new o(function(t, r, e) {
                        return 3 * (r + e) / 4 - e
                    }(0, f, u)),
                    a = 0,
                    p = u > 0 ? f - 4 : f;
                for (e = 0; e < p; e += 4) r = i[t.charCodeAt(e)] << 18 | i[t.charCodeAt(e + 1)] << 12 | i[t.charCodeAt(e + 2)] << 6 | i[t.charCodeAt(e + 3)], s[a++] = r >> 16 & 255, s[a++] = r >> 8 & 255, s[a++] = 255 & r;
                2 === u && (r = i[t.charCodeAt(e)] << 2 | i[t.charCodeAt(e + 1)] >> 4, s[a++] = 255 & r);
                1 === u && (r = i[t.charCodeAt(e)] << 10 | i[t.charCodeAt(e + 1)] << 4 | i[t.charCodeAt(e + 2)] >> 2, s[a++] = r >> 8 & 255, s[a++] = 255 & r);
                return s
            }, e.fromByteArray = function(t) {
                for (var r, e = t.length, i = e % 3, o = [], f = 0, u = e - i; f < u; f += 16383) o.push(a(t, f, f + 16383 > u ? u : f + 16383));
                1 === i ? (r = t[e - 1], o.push(n[r >> 2] + n[r << 4 & 63] + "==")) : 2 === i && (r = (t[e - 2] << 8) + t[e - 1], o.push(n[r >> 10] + n[r >> 4 & 63] + n[r << 2 & 63] + "="));
                return o.join("")
            };
            for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = 0, s = f.length; u < s; ++u) n[u] = f[u], i[f.charCodeAt(u)] = u;

            function h(t) {
                var r = t.length;
                if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var e = t.indexOf("=");
                return -1 === e && (e = r), [e, e === r ? 0 : 4 - e % 4]
            }

            function a(t, r, e) {
                for (var i, o, f = [], u = r; u < e; u += 3) i = (t[u] << 16 & 16711680) + (t[u + 1] << 8 & 65280) + (255 & t[u + 2]), f.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]);
                return f.join("")
            }
            i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
        }, {}],
        3: [function(t, r, e) {
            e.read = function(t, r, e, n, i) {
                var o, f, u = 8 * i - n - 1,
                    s = (1 << u) - 1,
                    h = s >> 1,
                    a = -7,
                    p = e ? i - 1 : 0,
                    c = e ? -1 : 1,
                    l = t[r + p];
                for (p += c, o = l & (1 << -a) - 1, l >>= -a, a += u; a > 0; o = 256 * o + t[r + p], p += c, a -= 8);
                for (f = o & (1 << -a) - 1, o >>= -a, a += n; a > 0; f = 256 * f + t[r + p], p += c, a -= 8);
                if (0 === o) o = 1 - h;
                else {
                    if (o === s) return f ? NaN : 1 / 0 * (l ? -1 : 1);
                    f += Math.pow(2, n), o -= h
                }
                return (l ? -1 : 1) * f * Math.pow(2, o - n)
            }, e.write = function(t, r, e, n, i, o) {
                var f, u, s, h = 8 * o - i - 1,
                    a = (1 << h) - 1,
                    p = a >> 1,
                    c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    l = n ? 0 : o - 1,
                    y = n ? 1 : -1,
                    g = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0;
                for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, f = a) : (f = Math.floor(Math.log(r) / Math.LN2), r * (s = Math.pow(2, -f)) < 1 && (f--, s *= 2), (r += f + p >= 1 ? c / s : c * Math.pow(2, 1 - p)) * s >= 2 && (f++, s /= 2), f + p >= a ? (u = 0, f = a) : f + p >= 1 ? (u = (r * s - 1) * Math.pow(2, i), f += p) : (u = r * Math.pow(2, p - 1) * Math.pow(2, i), f = 0)); i >= 8; t[e + l] = 255 & u, l += y, u /= 256, i -= 8);
                for (f = f << i | u, h += i; h > 0; t[e + l] = 255 & f, l += y, f /= 256, h -= 8);
                t[e + l - y] |= 128 * g
            }
        }, {}],
        4: [function(t, r, e) {
            arguments[4][2][0].apply(e, arguments)
        }, {
            dup: 2
        }],
        5: [function(t, r, e) {
            (function(r) {
                "use strict";
                var n = t("base64-js"),
                    i = t("ieee754");
                e.Buffer = r, e.SlowBuffer = function(t) {
                    +t != t && (t = 0);
                    return r.alloc(+t)
                }, e.INSPECT_MAX_BYTES = 50;
                var o = 2147483647;

                function f(t) {
                    if (t > o) throw new RangeError('The value "' + t + '" is invalid for option "size"');
                    var e = new Uint8Array(t);
                    return e.__proto__ = r.prototype, e
                }

                function r(t, r, e) {
                    if ("number" == typeof t) {
                        if ("string" == typeof r) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return h(t)
                    }
                    return u(t, r, e)
                }

                function u(t, e, n) {
                    if ("string" == typeof t) return function(t, e) {
                        "string" == typeof e && "" !== e || (e = "utf8");
                        if (!r.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
                        var n = 0 | c(t, e),
                            i = f(n),
                            o = i.write(t, e);
                        o !== n && (i = i.slice(0, o));
                        return i
                    }(t, e);
                    if (ArrayBuffer.isView(t)) return a(t);
                    if (null == t) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
                    if (z(t, ArrayBuffer) || t && z(t.buffer, ArrayBuffer)) return function(t, e, n) {
                        if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
                        if (t.byteLength < e + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        var i;
                        i = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, e) : new Uint8Array(t, e, n);
                        return i.__proto__ = r.prototype, i
                    }(t, e, n);
                    if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var i = t.valueOf && t.valueOf();
                    if (null != i && i !== t) return r.from(i, e, n);
                    var o = function(t) {
                        if (r.isBuffer(t)) {
                            var e = 0 | p(t.length),
                                n = f(e);
                            return 0 === n.length ? n : (t.copy(n, 0, 0, e), n)
                        }
                        if (void 0 !== t.length) return "number" != typeof t.length || D(t.length) ? f(0) : a(t);
                        if ("Buffer" === t.type && Array.isArray(t.data)) return a(t.data)
                    }(t);
                    if (o) return o;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return r.from(t[Symbol.toPrimitive]("string"), e, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
                }

                function s(t) {
                    if ("number" != typeof t) throw new TypeError('"size" argument must be of type number');
                    if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"')
                }

                function h(t) {
                    return s(t), f(t < 0 ? 0 : 0 | p(t))
                }

                function a(t) {
                    for (var r = t.length < 0 ? 0 : 0 | p(t.length), e = f(r), n = 0; n < r; n += 1) e[n] = 255 & t[n];
                    return e
                }

                function p(t) {
                    if (t >= o) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
                    return 0 | t
                }

                function c(t, e) {
                    if (r.isBuffer(t)) return t.length;
                    if (ArrayBuffer.isView(t) || z(t, ArrayBuffer)) return t.byteLength;
                    if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
                    var n = t.length,
                        i = arguments.length > 2 && !0 === arguments[2];
                    if (!i && 0 === n) return 0;
                    for (var o = !1;;) switch (e) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return P(t).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return j(t).length;
                        default:
                            if (o) return i ? -1 : P(t).length;
                            e = ("" + e).toLowerCase(), o = !0
                    }
                }

                function l(t, r, e) {
                    var n = t[r];
                    t[r] = t[e], t[e] = n
                }

                function y(t, e, n, i, o) {
                    if (0 === t.length) return -1;
                    if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), D(n = +n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
                        if (o) return -1;
                        n = t.length - 1
                    } else if (n < 0) {
                        if (!o) return -1;
                        n = 0
                    }
                    if ("string" == typeof e && (e = r.from(e, i)), r.isBuffer(e)) return 0 === e.length ? -1 : g(t, e, n, i, o);
                    if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : g(t, [e], n, i, o);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function g(t, r, e, n, i) {
                    var o, f = 1,
                        u = t.length,
                        s = r.length;
                    if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                        if (t.length < 2 || r.length < 2) return -1;
                        f = 2, u /= 2, s /= 2, e /= 2
                    }

                    function h(t, r) {
                        return 1 === f ? t[r] : t.readUInt16BE(r * f)
                    }
                    if (i) {
                        var a = -1;
                        for (o = e; o < u; o++)
                            if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                                if (-1 === a && (a = o), o - a + 1 === s) return a * f
                            } else -1 !== a && (o -= o - a), a = -1
                    } else
                        for (e + s > u && (e = u - s), o = e; o >= 0; o--) {
                            for (var p = !0, c = 0; c < s; c++)
                                if (h(t, o + c) !== h(r, c)) {
                                    p = !1;
                                    break
                                }
                            if (p) return o
                        }
                    return -1
                }

                function w(t, r, e, n) {
                    e = Number(e) || 0;
                    var i = t.length - e;
                    n ? (n = Number(n)) > i && (n = i) : n = i;
                    var o = r.length;
                    n > o / 2 && (n = o / 2);
                    for (var f = 0; f < n; ++f) {
                        var u = parseInt(r.substr(2 * f, 2), 16);
                        if (D(u)) return f;
                        t[e + f] = u
                    }
                    return f
                }

                function d(t, r, e, n) {
                    return N(P(r, t.length - e), t, e, n)
                }

                function v(t, r, e, n) {
                    return N(function(t) {
                        for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
                        return r
                    }(r), t, e, n)
                }

                function b(t, r, e, n) {
                    return v(t, r, e, n)
                }

                function m(t, r, e, n) {
                    return N(j(r), t, e, n)
                }

                function E(t, r, e, n) {
                    return N(function(t, r) {
                        for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f) e = t.charCodeAt(f), n = e >> 8, i = e % 256, o.push(i), o.push(n);
                        return o
                    }(r, t.length - e), t, e, n)
                }

                function B(t, r, e) {
                    return 0 === r && e === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(r, e))
                }

                function A(t, r, e) {
                    e = Math.min(t.length, e);
                    for (var n = [], i = r; i < e;) {
                        var o, f, u, s, h = t[i],
                            a = null,
                            p = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                        if (i + p <= e) switch (p) {
                            case 1:
                                h < 128 && (a = h);
                                break;
                            case 2:
                                128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                                break;
                            case 3:
                                o = t[i + 1], f = t[i + 2], 128 == (192 & o) && 128 == (192 & f) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & f) > 2047 && (s < 55296 || s > 57343) && (a = s);
                                break;
                            case 4:
                                o = t[i + 1], f = t[i + 2], u = t[i + 3], 128 == (192 & o) && 128 == (192 & f) && 128 == (192 & u) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & f) << 6 | 63 & u) > 65535 && s < 1114112 && (a = s)
                        }
                        null === a ? (a = 65533, p = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += p
                    }
                    return function(t) {
                        var r = t.length;
                        if (r <= U) return String.fromCharCode.apply(String, t);
                        var e = "",
                            n = 0;
                        for (; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += U));
                        return e
                    }(n)
                }
                e.kMaxLength = o, r.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var t = new Uint8Array(1);
                        return t.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function() {
                                return 42
                            }
                        }, 42 === t.foo()
                    } catch (t) {
                        return !1
                    }
                }(), r.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(r.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(r.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.byteOffset
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && r[Symbol.species] === r && Object.defineProperty(r, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), r.poolSize = 8192, r.from = function(t, r, e) {
                    return u(t, r, e)
                }, r.prototype.__proto__ = Uint8Array.prototype, r.__proto__ = Uint8Array, r.alloc = function(t, r, e) {
                    return function(t, r, e) {
                        return s(t), t <= 0 ? f(t) : void 0 !== r ? "string" == typeof e ? f(t).fill(r, e) : f(t).fill(r) : f(t)
                    }(t, r, e)
                }, r.allocUnsafe = function(t) {
                    return h(t)
                }, r.allocUnsafeSlow = function(t) {
                    return h(t)
                }, r.isBuffer = function(t) {
                    return null != t && !0 === t._isBuffer && t !== r.prototype
                }, r.compare = function(t, e) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), z(e, Uint8Array) && (e = r.from(e, e.offset, e.byteLength)), !r.isBuffer(t) || !r.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (t === e) return 0;
                    for (var n = t.length, i = e.length, o = 0, f = Math.min(n, i); o < f; ++o)
                        if (t[o] !== e[o]) {
                            n = t[o], i = e[o];
                            break
                        }
                    return n < i ? -1 : i < n ? 1 : 0
                }, r.isEncoding = function(t) {
                    switch (String(t).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, r.concat = function(t, e) {
                    if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === t.length) return r.alloc(0);
                    var n;
                    if (void 0 === e)
                        for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                    var i = r.allocUnsafe(e),
                        o = 0;
                    for (n = 0; n < t.length; ++n) {
                        var f = t[n];
                        if (z(f, Uint8Array) && (f = r.from(f)), !r.isBuffer(f)) throw new TypeError('"list" argument must be an Array of Buffers');
                        f.copy(i, o), o += f.length
                    }
                    return i
                }, r.byteLength = c, r.prototype._isBuffer = !0, r.prototype.swap16 = function() {
                    var t = this.length;
                    if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var r = 0; r < t; r += 2) l(this, r, r + 1);
                    return this
                }, r.prototype.swap32 = function() {
                    var t = this.length;
                    if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var r = 0; r < t; r += 4) l(this, r, r + 3), l(this, r + 1, r + 2);
                    return this
                }, r.prototype.swap64 = function() {
                    var t = this.length;
                    if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var r = 0; r < t; r += 8) l(this, r, r + 7), l(this, r + 1, r + 6), l(this, r + 2, r + 5), l(this, r + 3, r + 4);
                    return this
                }, r.prototype.toString = function() {
                    var t = this.length;
                    return 0 === t ? "" : 0 === arguments.length ? A(this, 0, t) : function(t, r, e) {
                        var n = !1;
                        if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
                        if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
                        if ((e >>>= 0) <= (r >>>= 0)) return "";
                        for (t || (t = "utf8");;) switch (t) {
                            case "hex":
                                return S(this, r, e);
                            case "utf8":
                            case "utf-8":
                                return A(this, r, e);
                            case "ascii":
                                return T(this, r, e);
                            case "latin1":
                            case "binary":
                                return I(this, r, e);
                            case "base64":
                                return B(this, r, e);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return L(this, r, e);
                            default:
                                if (n) throw new TypeError("Unknown encoding: " + t);
                                t = (t + "").toLowerCase(), n = !0
                        }
                    }.apply(this, arguments)
                }, r.prototype.toLocaleString = r.prototype.toString, r.prototype.equals = function(t) {
                    if (!r.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                    return this === t || 0 === r.compare(this, t)
                }, r.prototype.inspect = function() {
                    var t = "",
                        r = e.INSPECT_MAX_BYTES;
                    return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"
                }, r.prototype.compare = function(t, e, n, i, o) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), !r.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
                    if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), e < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError("out of range index");
                    if (i >= o && e >= n) return 0;
                    if (i >= o) return -1;
                    if (e >= n) return 1;
                    if (this === t) return 0;
                    for (var f = (o >>>= 0) - (i >>>= 0), u = (n >>>= 0) - (e >>>= 0), s = Math.min(f, u), h = this.slice(i, o), a = t.slice(e, n), p = 0; p < s; ++p)
                        if (h[p] !== a[p]) {
                            f = h[p], u = a[p];
                            break
                        }
                    return f < u ? -1 : u < f ? 1 : 0
                }, r.prototype.includes = function(t, r, e) {
                    return -1 !== this.indexOf(t, r, e)
                }, r.prototype.indexOf = function(t, r, e) {
                    return y(this, t, r, e, !0)
                }, r.prototype.lastIndexOf = function(t, r, e) {
                    return y(this, t, r, e, !1)
                }, r.prototype.write = function(t, r, e, n) {
                    if (void 0 === r) n = "utf8", e = this.length, r = 0;
                    else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
                    else {
                        if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        r >>>= 0, isFinite(e) ? (e >>>= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
                    }
                    var i = this.length - r;
                    if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    n || (n = "utf8");
                    for (var o = !1;;) switch (n) {
                        case "hex":
                            return w(this, t, r, e);
                        case "utf8":
                        case "utf-8":
                            return d(this, t, r, e);
                        case "ascii":
                            return v(this, t, r, e);
                        case "latin1":
                        case "binary":
                            return b(this, t, r, e);
                        case "base64":
                            return m(this, t, r, e);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return E(this, t, r, e);
                        default:
                            if (o) throw new TypeError("Unknown encoding: " + n);
                            n = ("" + n).toLowerCase(), o = !0
                    }
                }, r.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                var U = 4096;

                function T(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
                    return n
                }

                function I(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
                    return n
                }

                function S(t, r, e) {
                    var n = t.length;
                    (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
                    for (var i = "", o = r; o < e; ++o) i += k(t[o]);
                    return i
                }

                function L(t, r, e) {
                    for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
                    return i
                }

                function R(t, r, e) {
                    if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                    if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
                }

                function C(t, e, n, i, o, f) {
                    if (!r.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (e > o || e < f) throw new RangeError('"value" argument is out of bounds');
                    if (n + i > t.length) throw new RangeError("Index out of range")
                }

                function O(t, r, e, n, i, o) {
                    if (e + n > t.length) throw new RangeError("Index out of range");
                    if (e < 0) throw new RangeError("Index out of range")
                }

                function _(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || O(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4
                }

                function x(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || O(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8
                }
                r.prototype.slice = function(t, e) {
                    var n = this.length;
                    (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t);
                    var i = this.subarray(t, e);
                    return i.__proto__ = r.prototype, i
                }, r.prototype.readUIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n
                }, r.prototype.readUIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);) n += this[t + --r] * i;
                    return n
                }, r.prototype.readUInt8 = function(t, r) {
                    return t >>>= 0, r || R(t, 1, this.length), this[t]
                }, r.prototype.readUInt16LE = function(t, r) {
                    return t >>>= 0, r || R(t, 2, this.length), this[t] | this[t + 1] << 8
                }, r.prototype.readUInt16BE = function(t, r) {
                    return t >>>= 0, r || R(t, 2, this.length), this[t] << 8 | this[t + 1]
                }, r.prototype.readUInt32LE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
                }, r.prototype.readUInt32BE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
                }, r.prototype.readIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n
                }, r.prototype.readIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) o += this[t + --n] * i;
                    return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o
                }, r.prototype.readInt8 = function(t, r) {
                    return t >>>= 0, r || R(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                }, r.prototype.readInt16LE = function(t, r) {
                    t >>>= 0, r || R(t, 2, this.length);
                    var e = this[t] | this[t + 1] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt16BE = function(t, r) {
                    t >>>= 0, r || R(t, 2, this.length);
                    var e = this[t + 1] | this[t] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt32LE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
                }, r.prototype.readInt32BE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
                }, r.prototype.readFloatLE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), i.read(this, t, !0, 23, 4)
                }, r.prototype.readFloatBE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), i.read(this, t, !1, 23, 4)
                }, r.prototype.readDoubleLE = function(t, r) {
                    return t >>>= 0, r || R(t, 8, this.length), i.read(this, t, !0, 52, 8)
                }, r.prototype.readDoubleBE = function(t, r) {
                    return t >>>= 0, r || R(t, 8, this.length), i.read(this, t, !1, 52, 8)
                }, r.prototype.writeUIntLE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = 1,
                        o = 0;
                    for (this[r] = 255 & t; ++o < e && (i *= 256);) this[r + o] = t / i & 255;
                    return r + e
                }, r.prototype.writeUIntBE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = e - 1,
                        o = 1;
                    for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);) this[r + i] = t / o & 255;
                    return r + e
                }, r.prototype.writeUInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 1, 255, 0), this[r] = 255 & t, r + 1
                }, r.prototype.writeUInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeUInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeUInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t, r + 4
                }, r.prototype.writeUInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeIntLE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        C(this, t, r, e, i - 1, -i)
                    }
                    var o = 0,
                        f = 1,
                        u = 0;
                    for (this[r] = 255 & t; ++o < e && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeIntBE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        C(this, t, r, e, i - 1, -i)
                    }
                    var o = e - 1,
                        f = 1,
                        u = 0;
                    for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
                }, r.prototype.writeInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4
                }, r.prototype.writeInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeFloatLE = function(t, r, e) {
                    return _(this, t, r, !0, e)
                }, r.prototype.writeFloatBE = function(t, r, e) {
                    return _(this, t, r, !1, e)
                }, r.prototype.writeDoubleLE = function(t, r, e) {
                    return x(this, t, r, !0, e)
                }, r.prototype.writeDoubleBE = function(t, r, e) {
                    return x(this, t, r, !1, e)
                }, r.prototype.copy = function(t, e, n, i) {
                    if (!r.isBuffer(t)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0;
                    if (0 === t.length || 0 === this.length) return 0;
                    if (e < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (i < 0) throw new RangeError("sourceEnd out of bounds");
                    i > this.length && (i = this.length), t.length - e < i - n && (i = t.length - e + n);
                    var o = i - n;
                    if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(e, n, i);
                    else if (this === t && n < e && e < i)
                        for (var f = o - 1; f >= 0; --f) t[f + e] = this[f + n];
                    else Uint8Array.prototype.set.call(t, this.subarray(n, i), e);
                    return o
                }, r.prototype.fill = function(t, e, n, i) {
                    if ("string" == typeof t) {
                        if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                        if ("string" == typeof i && !r.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                        if (1 === t.length) {
                            var o = t.charCodeAt(0);
                            ("utf8" === i && o < 128 || "latin1" === i) && (t = o)
                        }
                    } else "number" == typeof t && (t &= 255);
                    if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index");
                    if (n <= e) return this;
                    var f;
                    if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t)
                        for (f = e; f < n; ++f) this[f] = t;
                    else {
                        var u = r.isBuffer(t) ? t : r.from(t, i),
                            s = u.length;
                        if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                        for (f = 0; f < n - e; ++f) this[f + e] = u[f % s]
                    }
                    return this
                };
                var M = /[^+\/0-9A-Za-z-_]/g;

                function k(t) {
                    return t < 16 ? "0" + t.toString(16) : t.toString(16)
                }

                function P(t, r) {
                    var e;
                    r = r || 1 / 0;
                    for (var n = t.length, i = null, o = [], f = 0; f < n; ++f) {
                        if ((e = t.charCodeAt(f)) > 55295 && e < 57344) {
                            if (!i) {
                                if (e > 56319) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (f + 1 === n) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = e;
                                continue
                            }
                            if (e < 56320) {
                                (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                                continue
                            }
                            e = 65536 + (i - 55296 << 10 | e - 56320)
                        } else i && (r -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, e < 128) {
                            if ((r -= 1) < 0) break;
                            o.push(e)
                        } else if (e < 2048) {
                            if ((r -= 2) < 0) break;
                            o.push(e >> 6 | 192, 63 & e | 128)
                        } else if (e < 65536) {
                            if ((r -= 3) < 0) break;
                            o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                        } else {
                            if (!(e < 1114112)) throw new Error("Invalid code point");
                            if ((r -= 4) < 0) break;
                            o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                        }
                    }
                    return o
                }

                function j(t) {
                    return n.toByteArray(function(t) {
                        if ((t = (t = t.split("=")[0]).trim().replace(M, "")).length < 2) return "";
                        for (; t.length % 4 != 0;) t += "=";
                        return t
                    }(t))
                }

                function N(t, r, e, n) {
                    for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i) r[i + e] = t[i];
                    return i
                }

                function z(t, r) {
                    return t instanceof r || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === r.name
                }

                function D(t) {
                    return t != t
                }
            }).call(this, t("buffer").Buffer)
        }, {
            "base64-js": 4,
            buffer: 5,
            ieee754: 6
        }],
        6: [function(t, r, e) {
            arguments[4][3][0].apply(e, arguments)
        }, {
            dup: 3
        }]
    }, {}, [1])(1)
});
Buffer=buffer.Buffer;

/* Remove any buffer toJSON bindings */
if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
if (!ArrayBuffer['isView']) {
  ArrayBuffer.isView = function(a) {
    return a !== null && typeof(a) === "object" && a['buffer'] instanceof ArrayBuffer;
  }
};
}

BufferInit();
</script>
    <script type="text/javascript" charset="utf-8">/*! NoSleep.js v0.12.0 - git.io/vfn01 - Rich Tibbett - MIT license */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["NoSleep"] = factory();
	else
		root["NoSleep"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(1),
    webm = _require.webm,
    mp4 = _require.mp4;

// Detect iOS browsers < version 10


var oldIOS = function oldIOS() {
  return typeof navigator !== "undefined" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream;
};

// Detect native Wake Lock API support
var nativeWakeLock = function nativeWakeLock() {
  return "wakeLock" in navigator;
};

var NoSleep = function () {
  function NoSleep() {
    var _this = this;

    _classCallCheck(this, NoSleep);

    this.enabled = false;
    if (nativeWakeLock()) {
      this._wakeLock = null;
      var handleVisibilityChange = function handleVisibilityChange() {
        if (_this._wakeLock !== null && document.visibilityState === "visible") {
          _this.enable();
        }
      };
      document.addEventListener("visibilitychange", handleVisibilityChange);
      document.addEventListener("fullscreenchange", handleVisibilityChange);
    } else if (oldIOS()) {
      this.noSleepTimer = null;
    } else {
      // Set up no sleep video element
      this.noSleepVideo = document.createElement("video");

      this.noSleepVideo.setAttribute("title", "No Sleep");
      this.noSleepVideo.setAttribute("playsinline", "");

      this._addSourceToVideo(this.noSleepVideo, "webm", webm);
      this._addSourceToVideo(this.noSleepVideo, "mp4", mp4);

      this.noSleepVideo.addEventListener("loadedmetadata", function () {
        if (_this.noSleepVideo.duration <= 1) {
          // webm source
          _this.noSleepVideo.setAttribute("loop", "");
        } else {
          // mp4 source
          _this.noSleepVideo.addEventListener("timeupdate", function () {
            if (_this.noSleepVideo.currentTime > 0.5) {
              _this.noSleepVideo.currentTime = Math.random();
            }
          });
        }
      });
    }
  }

  _createClass(NoSleep, [{
    key: "_addSourceToVideo",
    value: function _addSourceToVideo(element, type, dataURI) {
      var source = document.createElement("source");
      source.src = dataURI;
      source.type = "video/" + type;
      element.appendChild(source);
    }
  }, {
    key: "enable",
    value: function enable() {
      var _this2 = this;

      if (nativeWakeLock()) {
        return navigator.wakeLock.request("screen").then(function (wakeLock) {
          _this2._wakeLock = wakeLock;
          _this2.enabled = true;
          console.log("Wake Lock active.");
          _this2._wakeLock.addEventListener("release", function () {
            // ToDo: Potentially emit an event for the page to observe since
            // Wake Lock releases happen when page visibility changes.
            // (https://web.dev/wakelock/#wake-lock-lifecycle)
            console.log("Wake Lock released.");
          });
        }).catch(function (err) {
          _this2.enabled = false;
          console.error(err.name + ", " + err.message);
          throw err;
        });
      } else if (oldIOS()) {
        this.disable();
        console.warn("\n        NoSleep enabled for older iOS devices. This can interrupt\n        active or long-running network requests from completing successfully.\n        See https://github.com/richtr/NoSleep.js/issues/15 for more details.\n      ");
        this.noSleepTimer = window.setInterval(function () {
          if (!document.hidden) {
            window.location.href = window.location.href.split("#")[0];
            window.setTimeout(window.stop, 0);
          }
        }, 15000);
        this.enabled = true;
        return Promise.resolve();
      } else {
        var playPromise = this.noSleepVideo.play();
        return playPromise.then(function (res) {
          _this2.enabled = true;
          return res;
        }).catch(function (err) {
          _this2.enabled = false;
          throw err;
        });
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (nativeWakeLock()) {
        if (this._wakeLock) {
          this._wakeLock.release();
        }
        this._wakeLock = null;
      } else if (oldIOS()) {
        if (this.noSleepTimer) {
          console.warn("\n          NoSleep now disabled for older iOS devices.\n        ");
          window.clearInterval(this.noSleepTimer);
          this.noSleepTimer = null;
        }
      } else {
        this.noSleepVideo.pause();
      }
      this.enabled = false;
    }
  }, {
    key: "isEnabled",
    get: function get() {
      return this.enabled;
    }
  }]);

  return NoSleep;
}();

module.exports = NoSleep;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  webm: "data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK",
  mp4: "data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw"
};

/***/ })
/******/ ]);
});</script>
    <script type="text/javascript" charset="utf-8">/* global window, exports, define */

function SprintfInit () {
    'use strict'

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxXC])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case 'C':
                        for (var ci=0;ci<ph.width;ci++) output += arg;
                        continue;
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8)
                        break
                    case 's':
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 't':
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                        break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16)
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%')
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (typeof exports !== 'undefined') {
        exports['sprintf'] = sprintf
        exports['vsprintf'] = vsprintf
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf
        window['vsprintf'] = vsprintf

        if (typeof define === 'function' && define['amd']) {
            define(function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                }
            })
        }
    }
    /* eslint-enable quote-props */
    return sprintf
}
SprintfInit(); 
</script>
    <script>var CoreModule = {};
CoreModule['com/io']='com/io.browser';
CoreModule['crypto']='os/crypto';
CoreModule['util']='os/util';
CoreModule['http']='os/http.browser';
CoreModule['url']='os/url';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['fs']='';
CoreModule['stream']='';
CoreModule['zlib']='';
CoreModule['dgram']='';
CoreModule['net']='';
CoreModule['child_process']='';
CoreModule['dns']='';
CoreModule['buffer']='os/buffer';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
PATH=[".","/home/sbosse/proj/workbook/src"];
if (typeof global == "undefined")  global=(typeof window != "undefined"?window:{})
if (typeof process == "undefined") var process={browser:true};
Require=function(modupath) {
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}, module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,window,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,window,process);
  else return undefined;
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
var FilesEmbedded = {};
var FileEmbedd = function (path,format) {};
var FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='browser';
Script=function(){};

BundleModuleCode['os/buffer']=function (module,exports,global,process){
var Ieee754 = Require('os/buffer_ieee754');

/* ------- base64-js -------- */
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}
/* ------- base64-js -------- */

var assert;

exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= {
    ok : function(cond,msg) {
      if (cond != true) {
        console.log('** Assertion failed: '+msg+' **');
        throw Error(msg);
      }
    }
  };
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new TypeError('First argument needs to be a number, ' +
                            'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          // Round-up subject[i] to a UInt8.
          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
          //                                  = 80
          this[i] = ((subject[i] % 256) + 256) % 256;
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var b = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(b)) throw new Error('Invalid hex string');
    this[offset + i] = b;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }
  // TODO
  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
};
BundleModuleCode['os/buffer_ieee754']=function (module,exports,global,process){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};
};
BundleModuleCode['com/io.browser']=function (module,exports,global,process){
    /*
    ************
    ** Browser
    ************
    */

    var tracing = true;
    var stderr_fun = function (str) { console.log(str); };
    var stdout_fun = function (str) { console.log(str); };
    var args=[];

    module.exports = {
        checkOptions : function(options,defaultOptions) {
          return Object.assign({}, defaultOptions||{}, options) },

        checkOption : function (option,defaultOption) { 
          return option==undefined? defaultOption:option },

        config: {
            columns:undefined,
            rows:undefined
        },
        /*
         ** FILE IO
         * TODO WebStorage
         */
        close: function (fd) {
            return;
        },
        exists: function (path) {
            return false;
        },
        open: function (path, mode) {
            var fd = Fs.openSync(path, mode);
            return fd;
        },

        read: function (fd, len, foff) {
            // TODO
        },
        read_file: function (path) {
            return '';
        },

        read_line: function (fd) {
            // TODO
        },
        /**
         *
         * @param fd
         * @param buf
         * @param boff
         * @param len
         * @param [foff]
         * @returns {*}
         */
        read_buf: function (fd, buf, boff, len, foff) {
            return -1;
        },
        sync: function (fd) {
            return;
        },
        
        /**
         *
         * @param fd
         * @param data
         * @param [foff]
         * @returns {*}
         */
        write: function (fd, data, foff) {
            return -1;
        },
        /**
         *
         * @param fd
         * @param buf
         * @param bpos
         * @param blen
         * @param [foff]
         * @returns {*}
         */
        write_buf: function (fd, buf, bpos, blen, foff) {
            return -1;
        },

        /*
         ** CONSOLE IO
         */
        debug: function (msg) {
            stderr_fun('Debug: ' + msg);
        },
        err: function (msg) {
            stderr_fun('Error: ' + msg);
            throw Error(msg);
        },
        fail: function (msg) {
            stderr_fun('Fatal Error: ' + msg);
        },
        inspect: function (obj) {
            return;
        },
        stacktrace: function () {
            var e = new Error('dummy');
            var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                .split('\n');
            stderr_fun('Stack Trace');
            stderr_fun('--------------------------------');
            for(var i in stack) {
                if (i>0) {
                    var line = stack[i];
                    if(line.indexOf('Module.',0)>=0) break;
                    stderr_fun(line);
                }
            }
            stderr_fun('--------------------------------');
        },
        time : function () {
          return Date.now()
        },
        /**
         *
         * @param e
         * @param where
         */
        printstack: function (e,where) {
            if (where==undefined) stderr_fun(e);
            else stderr_fun(where+': '+e);
        },
        /**
         *
         * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
         */
        log: function (condmsg) {
            if (condmsg != true) console.warn(condmsg);
        },
        out: function (msg) {
            stdout_fun(msg)
        },
        warn: function (msg) {
            stderr_fun('Warning: ' + msg);
        },


        set_stderr: function(fun) {
            stderr_fun=fun;
        },
        set_stdout: function(fun) {
            stdout_fun=fun;
        },

        stderr: function (msg) {
            stderr_fun(msg);
        },
        stdout: function (msg) {
            stdout_fun(msg);
        },

        /** Write a message with a time stamp written to the trace file.
         *
         * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
         */
        trace: function (condmsg) {
            if (condmsg != true && tracefile != undefined) {
                var date = new Date();
                var time = date.getTime();
                this.log('[' + time + '] ' + condmsg + '\n');
            }
        },
        tracing: tracing,
        /**
         *
         * @param {string} path
         */
        trace_open: function (path) {
            return undefined;
        },

        exit: function (n) {
            return;
        },
        /**
         *
         * @returns {*} RSS HEAP in kBytes {data,heap}
         */
        mem: function () {
            return {data:0,heap:0};
        },

        getenv: function (name, def) {
            return def;
        },
        workdir: function () {
            return '';
        },
        /**
         *  @return {string []}
         */
        getargs: function () {
            return args;
        },
        set_args: function (argv) {
            args=argv;
        }
    };
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['os/util']=function (module,exports,global,process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = function isBuffer(arg) {
  return arg && typeof arg === 'object'
             && typeof arg.copy === 'function'
             && typeof arg.fill === 'function'
             && typeof arg.readUInt8 === 'function';
};

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */

exports.inherits = Require('os/inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
};
BundleModuleCode['os/inherits']=function (module,exports,global,process){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['plugins/utils/utils.js']=function (module,exports,global,process){
var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')
else console.log('HTTP Browser Module Ver. 1.1.3 initialized.');

inspect=Require('plugins/utils/inspect.js');
_=null;

Utils = {
  addCSS : function (styles) {
    var styleSheet = document.createElement("style")
    styleSheet.type = "text/css"
    styleSheet.innerText = styles
    document.head.appendChild(styleSheet)    
  },
  
  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  beep : function (duration,volume,frequency,type) {
    if (!Utils.audioCtx) Utils.audioCtx=new(window.AudioContext || window.webkitAudioContext)();
    
    var oscillator = Utils.audioCtx.createOscillator();
    var gainNode = Utils.audioCtx.createGain();
    duration=duration||10;
    volume=volume||100;
    frequency=frequency||1000;
    type=type||'sine';
    oscillator.connect(gainNode);
    gainNode.connect(Utils.audioCtx.destination);

    gainNode.gain.value = volume;
    oscillator.frequency.value = frequency;
    oscillator.type = type;


    oscillator.start();

    setTimeout(
      function() {
        oscillator.stop();
      },
      duration
    );
    
    oscillator.onended = function () {
        Utils.audioCtx.close();
        Utils.audioCtx=null;
    };
  },

  BrowserVersion :(function(){
      var ua= navigator.userAgent, tem, 
      M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
      }
      if(M[1]=== 'Chrome'){
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
      }
      M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
      if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
      return {name:M[0],version:M[1]};
    })(),

  /** Change CSS 
   *
   */
  changeCSS: function changeCSS(theClass,element,value) {
     var cssRules;

     for (var S = 0; S < document.styleSheets.length; S++) {
	   try {
	     document.styleSheets[S].insertRule(theClass+' { '+element+': '+value+'; }',
                                            document.styleSheets[S][cssRules].length);
	   } catch(err) {
	     try{
           document.styleSheets[S].addRule(theClass,element+': '+value+';');
	     } catch(err){
		     try{
			   if (document.styleSheets[S]['rules']) {
			     cssRules = 'rules';
			    } else if (document.styleSheets[S]['cssRules']) {
			     cssRules = 'cssRules';
			    } else {
			     //no rules found... browser unknown
			    }

			    for (var R = 0; R < document.styleSheets[S][cssRules].length; R++) {
			      if (document.styleSheets[S][cssRules][R].selectorText == theClass) {
				    if(document.styleSheets[S][cssRules][R].style[element]){
				      document.styleSheets[S][cssRules][R].style[element] = value;
				      break;
				    }
			      }
		        }
		     } catch (err){}
	     }
	   }
    }
  },
  
  copy : function (o) {
    // recursively copy objects
    var _o,p;
    if (Utils.isArray(o)) {
      if (typeof o[0] != 'object') return o.slice();
      else return o.map(function (e) {
            if (typeof e == 'object') return Utils.copy(e);
              else return e;
            });
      
    } else if (Utils.isObject(o)) {
      if (o instanceof Date) return o;
      _o={};
      for(p in o) _o[p]=(typeof o[p]=='object'?Utils.copy(o[p]):o[p]);
      return _o;
    } 
    else if (Utils.isString(o)) 
      return o.slice();
    else return o;
  
  },
  
  empty : function (v) {
    if (v == undefined) return true;
    if (Utils.isString(v)) return v=='';
    if (Utils.isArray(v)) return v.length==0;
    if (Utils.isObject(v)) return Object.keys(v).length==0;
    return false    
  },
  
  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  eraseCookie:function eraseCookie(name) {   
      document.cookie = name+'=; Max-Age=-99999999;';  
  },



  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  getCookie:function getCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for(var i=0;i < ca.length;i++) {
          var c = ca[i];
          while (c.charAt(0)==' ') c = c.substring(1,c.length);
          if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
      }
      return Utils.sessionCache[name]; // fallback 
  },

  getCookieObject:function (name,def) {
      var nameEQ = name + "=";
      try {
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
          var c = ca[i];
          while (c.charAt(0)==' ') c = c.substring(1,c.length);
          if (c.indexOf(nameEQ) == 0) return JSONfn.parse(c.substring(nameEQ.length,c.length));
        }
        return def;
      } catch (e) {
      console.log(e)
        return def;
      }
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*[a-zA-Z0-9_]*\([^\)]+\))/)[1];
    }
  },
  
  inspect : inspect,
  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isMatrix: function isMatrix(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isBoolean (o) {
      return typeof o == "boolean"
  },
  isString: function isString(o) {
      return typeof o == "string"
  },
  isStruct: function isStruct(o) {
      return !Utils.isArray(o) && Utils.isObject(o)
  },
  isTypedArray: function isTypedArray(o) {
      return Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },

  // toplevel entry for loading JS/JSON/JSOB/CSV files
  load : function (url,mimetype,cb) {
    var text;
    function filedia(e,process) {
        popup.confirm({
          content : url+':<br>\n'+e+'<br>\n',
        },function (reply)  {            
            if (!reply.proceed) return;
            Common.loadFile(function (data) {
              if (!data) return;
              cb(process(data));
            },false)
        });      
    }
    if (typeof mimetype == 'function') cb=mimetype,mimetype=null;
    if (!mimetype && url.match(/\.json$/)) mimetype='JSON';
    if (!mimetype && url.match(/\.js/)) mimetype='JS';
    if (!mimetype && url.match(/\.csv/)) mimetype='CSV';
    switch (mimetype && mimetype.replace(/application\//,'')) {
      case 'JSON':
        if (cb) return Utils.loadFile(url,function (text,err) {
          if (!err) cb(Utils.ofJSON(text));
        });
        else return Utils.ofJSON(Utils.loadFile(url));
      case 'JSOB':
        if (cb) return Utils.loadFile(url,function (text,err) {
          if (!err) cb(Utils.ofString(text));
        });
        else return Utils.ofString(Utils.loadFile(url));
      case 'CSV':
        if (cb) return Utils.loadFile(url,function (text,err) {
          if (!err) cb(Utils.ofCSV(text));
          else filedia(err,Utils.ofCSV);
        });
        else {
          text =Utils.loadFile(url,null,true);
          if (typeof text != 'string') return text;
          else return Utils.ofCSV(text);
        }
      case 'JS': 
      default:
        return Utils.loadScript(url);
        break; 
    };

  },
  
  loadFile: function (url,cb) {
    var result,error,_cb=cb;
    if (!_cb) _cb=function (_result,_error) { result=_result; error=_error; }; 
    try {
      // print(url+params)
      var request = new XMLHttpRequest();
      request.open("GET",url, cb);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                _cb(allText);
            } else _cb(null,'GET from '+url+' failed (status)');
        }
      }
      request.onerror = function (err) {
        _cb(null,'GET from '+url+' failed (error)')
      }
      request.send(null);
    } catch (e) {
      _cb(null,e)
    }
    return error||result;
  },

  loadScript: function (filename) {
    var fileref = document.createElement('script');
    fileref.setAttribute("type", "text/javascript");
    fileref.setAttribute("src", filename);
    if (typeof fileref != "undefined")
        document.getElementsByTagName("head")[0].appendChild(fileref)
  },
  
  name: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^function[ ]*([a-zA-Z0-9_]*)\([^\)]+\)/)[1];
    }
  },

  ofCSV : function (source,convert) {
    try {
      Papa.parse(source,{
        skipEmptyLines: true,
        dynamicTyping: true,
        complete: function(results) {
          data=results.data;
          if (convert) { // first line must be header
            header=data.shift();
            data=data.map(function (row) {
              var r={};
              header.forEach(function (col,i) { r[col]=row[i] });
              return r; 
            }) 
          }
        }
      });
      if (data && data[0].length==1) data=data.map(function (row) { return row[0] });
      return data;
    } catch (e) {
      return e;
    }
  },
  
  ofJSON : function (source) {
    return JSONfn.parse(source,{});
  },
  
  /** Convert agent text sources to agent code in JSOB format
   *
   */
  ofString : function (source) {
    var code;
    try {
      // execute script in private context
      eval('code = '+source);
    } catch (e) { console.log(e,source) };
    return code; 
  },

  parseUrl : function (url) {
    if (!url) return {};
    var queryString = url.substring( url.indexOf('?') + 1 );
    if (queryString == url) return {};
    var params = {}, queries, temp, i, l;

    // Split into key/value pairs
    queries = queryString.split("&");

    // Convert the array of strings into an object
    for ( i = 0, l = queries.length; i < l; i++ ) {
        temp = queries[i].split('=');
        if (temp[1]==undefined) temp[1]='true';
        params[temp[0]] = temp[1].replace('%20',' ');
    }

    return params;
  },


  save : function (path,data,mimetype) {
    if (!mimetype && path.match(/\.json$/)) mimetype='JSON';
    if (!mimetype && path.match(/\.csv/)) mimetype='CSV';
    switch (mimetype && mimetype.replace(/application\//,'')) {
      case 'JSON':
        if (typeof data == 'object') data=JSONfn.stringify(data);
        break;
    }
    return Common.saveFile(data,path);
  },

  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },


  /** Cookie Management
   *
   */
  sessionCache : {},

  setCookie:function setCookie(name,value,days) {
      var expires = "";
      if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days*24*60*60*1000));
          expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
      Utils.sessionCache[name]=value; // fallback if cookies are denied
  },

  setCookieObject:function (name,obj,days) {
      var expires = "";
      var value = JSONfn.stringify(obj);
      if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days*24*60*60*1000));
          expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
  },
  
  stringToArrayBuffer : function (str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);

    for (var i=0, strLen=str.length; i<strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }

    return buf;
  },

  stringToUint8Array : function (str) {
    var bufView = new Uint8Array(str.length);

    for (var i=0, strLen=str.length; i<strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }

    return bufView;
  },
  
  time : function () { return Date.now() },
  
  /** Convert any object to text source in JSOB format
  *
  */
  toString : function (o) {
    var usebuffer=false;
    var p,i,keys,s='',sep,tokens;
    if (o===null) return 'null';
    else if (Utils.isArray(o)) {
      s='[';sep='';
      for(p in o) {
        s=s+sep+Utils.toString(o[p]);
        sep=',';
      }
      s+=']';
    } else if (o instanceof Buffer) {    
      s='Buffer([';sep='';
      for(i=0;i<o.length;i++) {
        s=s+sep+Utils.toString(o[i]);
        sep=',';
      }
      s+='])';  
    } else if (o instanceof Error) {    
      s='(new Error("'+o.toString()+'"))';
    } else if (Utils.isTypedArray(o)) {    
      s='(new '+Utils.TypedArrayToName(o)+'([';sep='';
      var b=Array.prototype.slice.call(o);
      for(i=0;i<b.length;i++) {
        s=s+sep+String(b[i]);
        sep=',';
      }
      s+=']))';  
    } else if (typeof o == 'object') {
      s='{';sep='';
      keys=Object.keys(o);
      for(i in keys) {
        p=keys[i];
        if (o[p]==undefined) continue;
        s=s+sep+"'"+p+"'"+':'+Utils.toString(o[p]);
        sep=',';
      }
      s+='}';
      if (o.__constructor__) s = '(function () { var o='+s+'; o.__proto__='+o.__constructor__+'.prototype; return o})()';
    } else if (typeof o == 'string')
      s="'"+
            o.toString().replace(/'/g,'\\\'')
                        .replace(/\n/g,'\\n')+
        "'"; 
    else if (typeof o == 'function') {
      s=o.toString(true);   // try minification (true) if supported by platform
      if (tokens=s.match(/function[ ]+([a-zA-Z0-9]+)[ ]*\(\)[ ]*{[^\[]*\[native code\][^}]*}/)) {
        return tokens[1];
      } else return s;
    } else if (o != undefined)
      s=o.toString();
    else s='undefined';
    return s;
  },


  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
        if (ftyp==Int8Array   || ftyp instanceof Int8Array) return 'Int8Array';
        if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return 'Uint8Array';
        if (ftyp==Int16Array  || ftyp instanceof Int16Array) return 'Int16Array';
        if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return 'Uint16Array';
        if (ftyp==Int32Array  || ftyp instanceof Int32Array) return 'Int32Array';
        if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return 'Uint32Array';
        if (ftyp==Float32Array || ftyp instanceof Float32Array) return 'Float32Array';
        if (ftyp==Float64Array || ftyp instanceof Float64Array) return 'Float64Array';
  },


  uniqueID : function (length) {
    var s='',
        keys=['a','b','c','d','e','f','g','h','i','j','k','l',
              'o','p','q','r','s','t','u','v','w','x','y','z'];
    keys=keys.concat(keys,keys.map(function (k) { return k.toUpperCase() }));
    keys=keys.concat([1,2,3,4,5,6,7,8,9]);
    for(var i=0;i<length;i++) {
      s+= (keys[(Math.random()*keys.length)|0]);
    }
    return s;
  },

  /** request
   *  typeof @options = { url:string, host: string, port:number, path:string, method:"GET"|"PUT", body?:string, headers:{} } 
   *  typeof @callback = function (err, xhr, body)
   */

  request : function (options, callback) {
    var DEFAULT_TIMEOUT = 2000;
    function is_crossDomain(url) {
      var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/


      // jQuery #8138, IE may throw an exception when accessing
      // a field from window.location if document.domain has been set
      var ajaxLocation
      try { ajaxLocation = location.href }
      catch (e) {
        // Use the href attribute of an A element since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
      }

      if (ajaxLocation.match('file:')) return true;

      var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
          , parts = rurl.exec(url.toLowerCase() )

      var result = !!(
        parts &&
        (  parts[1] != ajaxLocParts[1]
        || parts[2] != ajaxLocParts[2]
        || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
        )
      )

      //console.debug('is_crossDomain('+url+') -> ' + result)
      return result
    }

    try {
      var xhr = new XHR(),
          err,
          url = options.url || options.uri || ((options.proto?options.proto:'http')+'://'+options.host+':'+(options.port?options.port:80)+'/'+options.path),
          is_cors = is_crossDomain(url),
          supports_cors = ('withCredentials' in xhr)

      if(is_cors && !supports_cors) {
        err = new Error('Browser does not support cross-origin request: ' + options.uri)
        err.cors = 'unsupported'
        return callback(err, xhr)
      }
      options.headers = options.headers || {};
      options.timeout = options.timeout || DEFAULT_TIMEOUT;
      options.headers = options.headers || {};
      options.body    = options.body || null;

      if(is_cors) xhr.withCredentials = !! options.withCredentials;
      xhr.timeout = options.timeout;

      xhr.onopen = function () {
        for (var key in options.headers)
          xhr.setRequestHeader(key, options.headers[key])      
      }

      xhr.onload = function () {
       if(xhr.status === 0) {
          err = new Error('EREQUEST')
          callback(err, xhr)
       } 
       else callback(null,xhr,xhr.responseText)   
      }

      xhr.ontimeout = function () {
        // XMLHttpRequest timed out. Do something here.
        err = new Error('ETIMEOUT')
        err.duration = options.timeout
        callback(err,xhr, null)
      };

      xhr.onrror = function () {
        // XMLHttpRequest failed. Do something here.
        err = new Error('ESERVER')
        callback(err,xhr, null)
      };

      xhr.onreadystatechange = function () {
        if (xhr.readyState === XHR.DONE) {
          if(xhr.status === 0) {
            err = new Error('ENETWORK')
            callback(err, xhr)
          } 
        }
      };

      switch (options.method) {
        case 'GET':
        case 'get':
          xhr.open('GET', url, true /* async */);
          xhr.send()
          break;
        case 'PUT':
        case 'POST':
        case 'put':
        case 'post':
          xhr.open('POST', url, true /* async */);
          xhr.send(options.body)
          break;
      }
    } catch (e) { _log(options,e);console.log(['xhr error: ',options.host,options.path,e].join(' ')); }
  },
  
  GET: function (url,params,cb,sync) {
    var result;
    // if (sync && !cb) cb=function (_result) { result=_result }; 
    if (url.indexOf('http')!=0) url = 'http://'+url;
    try {
      if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
      } else params='';
      // print(url+params)
      var request = new XMLHttpRequest();
      request.open("GET",url+params, !sync);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                if (allText!='') result=JSONfn.parse(allText);
                else result = new Error('GET data error (empty data)');
                if (cb) cb(result);
            } else {
              result=new Error('GET from '+url+params+' failed (status '+request.status+')');
              if (cb) cb(result)
            }
        }
      }
      request.onerror = function (error) {
        result='Error: GET from '+url+params+' failed: '+error;
        if (cb) cb(result);
      }
      request.send(null);
    } catch (error) {
      result=new Error('GET from '+url+params+' failed: '+error.toString());
      if (cb) cb(result);      
    }
    return result;
  },
  
  POST: function (url,data,cb,sync){
    var result;
    // if (sync && !cb) cb=function (_result) { result=_result }; 
    if (url.indexOf('http')!=0) url = 'http://'+url;
    try {
      var request = new XMLHttpRequest();
      request.open("POST", url, !sync);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                try {           
                  if (allText!='') result=JSONfn.parse(allText)
                  else result=new Error('POST data error (empty data)');
                } catch (e) {
                  result = new Error(e.toString());
                }
                if (cb) cb(result);
            } else {
                result = new Error('POST to '+url+' failed (status)');
                if (cb) cb(result);
            }
        }
      }
      request.onerror = function (error) {
        result = new Error('POST to '+url+' failed: '+error);
        if (cb) cb(result)
      }
      request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      request.send(JSONfn.stringify(data));
    } catch (error) {
      result=new Error('POST to '+url+' failed: '+error.toString());
      if (cb) cb(result)
    }
    return result;
  },


  version: '1.5.1'
}

Utils._init = function () {
  Object.addProperty = function (obj,name,fun) {
    if (obj.prototype[name]) return;
    obj.prototype[name]=fun;
    Object.defineProperty(obj.prototype, name, {enumerable: false});
  };

  Object.updateProperty = function (obj,name,fun) {
    obj.prototype[name]=fun;
    Object.defineProperty(obj.prototype, name, {enumerable: false});
  };

  // Array static methods extensions
  if (!Array.create) Array.create = function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    }
    
  if (!Array.matrix) Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
  // Array prototype extensions
  Object.addProperty(Array,'last',function () { return this[this.length-1] });

  // String static methods extensions
  if (!String.create) String.create = function(size,init) {
        var i, s='';
        init=init||' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
  };
  if (!String.copy) String.copy = function(src) {
        var i,dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
  }; 
  if (!String.get) String.get = function (str,index) {
        return str.charAt(index);
  }
  if (!String.hex) String.hex = function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
  }; 
  if (!String.set) String.set = function (str,index,char) {
    return str.substr(0, index) + char + str.substr(index+1)
  }
  // String prototype extensions
  Object.addProperty(String,'contains', function (el) {
    return this.includes(el)
  })
  
  Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
  });
  
  if (typeof assert == 'undefined') assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
  };
}

Utils._init();




};
BundleModuleCode['plugins/utils/inspect.js']=function (module,exports,global,process){
/**
 * Module exports.
 */
function InspectInit() {

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @license MIT (© Joyent)
 */
/* legacy: obj, showHidden, depth, colors*/

function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeNoColor(str, styleType) {
  return str;
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isUndefined(arg) {
  return arg === void 0;
}

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isNull(arg) {
  return arg === null;
}

function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwn(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  try {
    if (ctx.showHidden && Object.getOwnPropertyNames) {
      keys = Object.getOwnPropertyNames(value);
    }
  } catch (e) {
    // ignore
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (Array.isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = { value: void 0 };
  try {
    // ie6 › navigator.toString
    // throws Error: Object doesn't support this property or method
    desc.value = value[key];
  } catch (e) {
    // ignore
  }
  try {
    // ie10 › Object.getOwnPropertyDescriptor(window.location, 'hash')
    // throws TypeError: Object doesn't support this action
    if (Object.getOwnPropertyDescriptor) {
      desc = Object.getOwnPropertyDescriptor(value, key) || desc;
    }
  } catch (e) {
    // ignore
  }
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwn(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
return inspect
}

window.inspect =InspectInit();
if (typeof module != 'undefined') module.exports=InspectInit();
};

Base64=Require('os/base64');
//Buffer=Require('os/buffer').Buffer;
window.UTILS=UTILS = Require('plugins/utils/utils.js');
</script>
    <script>var CoreModule = {};
CoreModule['com/io']='com/io.browser';
CoreModule['crypto']='os/crypto';
CoreModule['util']='os/util';
CoreModule['http']='os/http.browser';
CoreModule['url']='os/url';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['fs']='';
CoreModule['stream']='';
CoreModule['zlib']='';
CoreModule['dgram']='';
CoreModule['net']='';
CoreModule['child_process']='';
CoreModule['dns']='';
CoreModule['buffer']='os/buffer';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
// PATH=[".","/home/sbosse/proj/workbook/src"];
if (typeof global == "undefined")  global=(typeof window != "undefined"?window:{})
if (typeof process == "undefined") var process={browser:true};
Require=function(modupath) {
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}, module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,window,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,window,process);
  else return undefined;
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
var FilesEmbedded = {};
var FileEmbedd = function (path,format) {};
var FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='browser';
Script=function(){};

BundleModuleCode['os/buffer']=function (module,exports,global,process){
var Ieee754 = Require('os/buffer_ieee754');

/* ------- base64-js -------- */
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}
/* ------- base64-js -------- */

var assert;

exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= {
    ok : function(cond,msg) {
      if (cond != true) {
        console.log('** Assertion failed: '+msg+' **');
        throw Error(msg);
      }
    }
  };
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new TypeError('First argument needs to be a number, ' +
                            'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          // Round-up subject[i] to a UInt8.
          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
          //                                  = 80
          this[i] = ((subject[i] % 256) + 256) % 256;
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var b = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(b)) throw new Error('Invalid hex string');
    this[offset + i] = b;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }
  // TODO
  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
};
BundleModuleCode['os/buffer_ieee754']=function (module,exports,global,process){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};
};
BundleModuleCode['com/io.browser']=function (module,exports,global,process){
    /*
    ************
    ** Browser
    ************
    */

    var tracing = true;
    var stderr_fun = function (str) { console.log(str); };
    var stdout_fun = function (str) { console.log(str); };
    var args=[];

    module.exports = {
        checkOptions : function(options,defaultOptions) {
          return Object.assign({}, defaultOptions||{}, options) },

        checkOption : function (option,defaultOption) { 
          return option==undefined? defaultOption:option },

        config: {
            columns:undefined,
            rows:undefined
        },
        /*
         ** FILE IO
         * TODO WebStorage
         */
        close: function (fd) {
            return;
        },
        exists: function (path) {
            return false;
        },
        open: function (path, mode) {
            var fd = Fs.openSync(path, mode);
            return fd;
        },

        read: function (fd, len, foff) {
            // TODO
        },
        read_file: function (path) {
            return '';
        },

        read_line: function (fd) {
            // TODO
        },
        /**
         *
         * @param fd
         * @param buf
         * @param boff
         * @param len
         * @param [foff]
         * @returns {*}
         */
        read_buf: function (fd, buf, boff, len, foff) {
            return -1;
        },
        sync: function (fd) {
            return;
        },
        
        /**
         *
         * @param fd
         * @param data
         * @param [foff]
         * @returns {*}
         */
        write: function (fd, data, foff) {
            return -1;
        },
        /**
         *
         * @param fd
         * @param buf
         * @param bpos
         * @param blen
         * @param [foff]
         * @returns {*}
         */
        write_buf: function (fd, buf, bpos, blen, foff) {
            return -1;
        },

        /*
         ** CONSOLE IO
         */
        debug: function (msg) {
            stderr_fun('Debug: ' + msg);
        },
        err: function (msg) {
            stderr_fun('Error: ' + msg);
            throw Error(msg);
        },
        fail: function (msg) {
            stderr_fun('Fatal Error: ' + msg);
        },
        inspect: function (obj) {
            return;
        },
        stacktrace: function () {
            var e = new Error('dummy');
            var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                .split('\n');
            stderr_fun('Stack Trace');
            stderr_fun('--------------------------------');
            for(var i in stack) {
                if (i>0) {
                    var line = stack[i];
                    if(line.indexOf('Module.',0)>=0) break;
                    stderr_fun(line);
                }
            }
            stderr_fun('--------------------------------');
        },
        time : function () {
          return Date.now()
        },
        /**
         *
         * @param e
         * @param where
         */
        printstack: function (e,where) {
            if (where==undefined) stderr_fun(e);
            else stderr_fun(where+': '+e);
        },
        /**
         *
         * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
         */
        log: function (condmsg) {
            if (condmsg != true) console.warn(condmsg);
        },
        out: function (msg) {
            stdout_fun(msg)
        },
        warn: function (msg) {
            stderr_fun('Warning: ' + msg);
        },


        set_stderr: function(fun) {
            stderr_fun=fun;
        },
        set_stdout: function(fun) {
            stdout_fun=fun;
        },

        stderr: function (msg) {
            stderr_fun(msg);
        },
        stdout: function (msg) {
            stdout_fun(msg);
        },

        /** Write a message with a time stamp written to the trace file.
         *
         * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
         */
        trace: function (condmsg) {
            if (condmsg != true && tracefile != undefined) {
                var date = new Date();
                var time = date.getTime();
                this.log('[' + time + '] ' + condmsg + '\n');
            }
        },
        tracing: tracing,
        /**
         *
         * @param {string} path
         */
        trace_open: function (path) {
            return undefined;
        },

        exit: function (n) {
            return;
        },
        /**
         *
         * @returns {*} RSS HEAP in kBytes {data,heap}
         */
        mem: function () {
            return {data:0,heap:0};
        },

        getenv: function (name, def) {
            return def;
        },
        workdir: function () {
            return '';
        },
        /**
         *  @return {string []}
         */
        getargs: function () {
            return args;
        },
        set_args: function (argv) {
            args=argv;
        }
    };
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['os/util']=function (module,exports,global,process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = function isBuffer(arg) {
  return arg && typeof arg === 'object'
             && typeof arg.copy === 'function'
             && typeof arg.fill === 'function'
             && typeof arg.readUInt8 === 'function';
};

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */

exports.inherits = Require('os/inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
};
BundleModuleCode['os/inherits']=function (module,exports,global,process){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['plugins/math/math.js']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.48.1X
 **
 **    $INFO:
 **
 **  Extended math Library
 **
 **    $ENDOFINFO
 */

if (typeof Utils == 'undefined') Require('plugins/com/utils')
var MatrixTA = Require('plugins/math/matrixTA')
  MatrixTA.EVD = Require('plugins/math/matrixTA-EVD');
  MatrixTA.SVD = Require('plugins/math/matrixTA-SVD');
  
var VectorTA = Require('plugins/math/vectorTA')
var Matrix  = Require('plugins/math/matrix')
var Vector  = Require('plugins/math/vector')
var Line    = Require('plugins/math/line')
var Plane   = Require('plugins/math/plane')
var Stats   = Require('plugins/math/stats')
var DWT     = Require('plugins/math/dwt5')
var Numeric = Require('plugins/math/numeric')
var Regression  = Require('plugins/math/regression')
var Polyfit     = Require('plugins/math/polyfit')
var Smoothers   = Require('plugins/math/smoothers')
var LinLogReg   = Require('plugins/ml/reg')
var Bin   = Require('plugins/math/data-bin')
Require('plugins/math/matja')
var Points = Require('plugins/math/points');
var Vol    = Require('plugins/math/vol');

var MAN  = FileEmbedded('plugins/math/help.md','utf8');
Math.help = function (topic) {
  // TODO
  return MAN
}

// Generic array vector & matrix modules
Math.Line     = Line;
Math.Matrix   = Matrix;
Math.Plane    = Plane;
Math.Vector   = Vector;
Math.DWT      = DWT;
Math.numeric  = Numeric;
Math.regression = {
  polyfit : Polyfit,
  linlog  : LinLogReg,
  regression : Regression,
  smoothers : Smoothers,
};
Math.statistics = Stats;

// Typedarray vector & matrix modules
Math.MatrixTA = MatrixTA;
Math.VectorTA = VectorTA;
Math.Vol3      = Vol.Vol3;

var FFT     = Require('plugins/math/fft')
Math.FFT    = FFT;
var CONV    = Require('plugins/math/conv')
Math.Convolution = CONV;

Math.points = Points;

Math.version  = '1.49.1X'

var none = null;

// Dynamic array method extensions (more extension in MatrixTA!)
Object.addProperty(Array,'abs', function () {
  return this.map(Math.abs)
})
Object.addProperty(Array,'add', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b+v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b+v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]+v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]+v })});
  }
})
Object.addProperty(Array,'append', function (a) {
  for(var i=0;i<a.length;i++) this.push(a[i]);
  return this
})

Object.addProperty(Array,'contains', function (elements,test,single) {
  if (Utils.isArray(elements) && !single)  {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (this[i]==elements[j]) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (test(this[i],elements[j])) return true;  
      } 
  
  } else {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        if (this[i]==elements) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        if (test(this[i],elements)) return true;  
      } 
  }
  return false;
})
Object.addProperty(Array,'div', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b[j][i] })});
  }
})
Object.addProperty(Array,'extend', function (array) {
  for(var i=0;i<array.length;i++) this.push(array[i]);
  return this;
})
if (!Array.prototype.flat) {
  Object.addProperty(Array,'flat', function flat () {
    var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

    return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
      if (Array.isArray(cur)) {
        acc.push.apply(acc, flat.call(cur, depth - 1));
      } else {
        acc.push(cur);
      }
      return acc;
    }, []) : Array.prototype.slice.call(this);
  })
}

Object.addProperty(Array,'head', function (num) {
  return this.slice(0,num||1);
})

Object.addProperty(Array,'index', function (offset) {
  offset=offset||0;
  return this.map(function (v,i) { return i+offset });
})

Object.addProperty(Array,'mul', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b*v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b*v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]*v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]*v })});
  }
})

if (!Array.prototype.includes) {
  Object.addProperty(Array,'includes', function (r,e) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var t = Object(this),
            n = t.length >>> 0;
        if (0 === n) return !1;
        var i, o, a = 0 | e,
            u = Math.max(0 <= a ? a : n - Math.abs(a), 0);
        for (; u < n;) {
            if ((i = t[u]) === (o = r) || "number" == typeof i && "number" == typeof o && isNaN(i) && isNaN(o)) return !0;
            u++
        }
        return !1
    });
};
Object.addProperty(Array,'intersect', function (second) {
  var result=[];
  for(var i=0;i<this.length;i++) {
    for(var j=0;j<second.length;j++)
      if (Math.equal(this[i],second[j])) result.push(this[i]);
  }
  return result;
})

Object.addProperty(Array,'loop', function (callback,tmo) {
  var self=this;
  Code.later(tmo||1,function (id,index) {
    callback(self[index],index);
    return index<(self.length-1);
  })
})

Object.addProperty(Array,'match', function (test) {
  if (test.length != this.length) return false;
  for(var i=0;i<this.length;i++) if (this[i]!=test[i]) return false;
  return true;
})

Object.addProperty(Array,'pad', function (size,v,left) {
  v=v||0;
  if (size<this.length) return this.slice();
  var ext = Array.init(size-this.length,v);
  if (!left) return this.concat(ext);
  else return ext.concat(this);
})

Object.addProperty(Array,'sample', function (frag,filter) {
  var m = Math.floor(this.length/frag),
      i,
      fn,
      s=0,
      res=[];
  filter=filter||'mean';
  switch (filter) {
    case 'mean':
      fn=function (a,b,i) {
        if (i!=frag-1) return a+b;
        else return (a+b)/frag;
      };
      break;
    case 'peak':
      fn=function (a,b,i) {
        return a>b?a:b;
      };
      break;
  }
  for(i=0;i<m;i++) {
    s=this.slice(i*frag,i*frag+frag).reduce(fn);
    res.push(s);
  }
  return res;
})
Object.addProperty(Array,'search', function (test) {
  for(var i=0;i<this.length;i++) if (test(this[i])) return this[i];
  return
})

// Shuffle array randomly (uniform distribution)
// if weak is set true then the original
// element position acts like a magnet, i.e.,
// elements are stay mostly in their array original region
// (localized non-uniform distribution)
Object.addProperty(Array,'shuffle', function (weak) {
  if (weak) return this.slice().sort(function () { return Math.random()-0.5 });
  var array=this;
  for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;  
});

Object.addProperty(Array,'split', function (frag) {
  var rows = this.length/frag,
      cols = frag,
      j,
      mat=[];
  for(j=0;j<rows;j++) {
    mat.push(this.slice(j*cols,j*cols+cols));
  }
  return mat;
})
Object.addProperty(Array,'subtract', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b[j][i] })});
  }
})
Object.addProperty(Array,'tail', function (num) {
  return this.slice(this.length-(num||1));
})
Object.addProperty(Array,'toObject', function (keys) {
  var o={};
  for(var i=0;i<this.length;i++) {
    var key = keys?keys[i]||String(i):String(i);
    o[key]=this[i];
  }
  return o;
})
Object.addProperty(Array,'transpose', function () {
  var rows = this.length, i, cols = this[0].length, j;
  var elements = [], i = cols;
  while (i--) { j = rows;
    elements[i] = [];
    while (j--) {
      elements[i][j] = this[j][i];
    }
  }
  return elements;
})
if (!Array.prototype.unflat) {
  Object.addProperty(Array,'unflat', function unflat (n) {
      // suppports only 1d->2d transformation
      var rows = [];
      for(var i=0;i<=(this.length-n);i+=n) rows.push(this.slice(i,i+n));
      return rows;
  })
}
Object.addProperty(Array,'without', function (without) {
  if (Utils.isArray(without)) {
    return this.filter(function (el) {
      var found=false;
      for(var i=0;i<without.length;i++) 
        found = found  | Math.equal(el,without[i])
      return !found; 
    });
  } else return this.filter(function (el) { return !Math.equal(el,without) });
})

// Static array method extensions

// Simple array array matrix
Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
Array.matrix3d =  function (n,m,k,init) {
    var x,y,z,mat;
    mat=new Array(n);
    for(x=0;x<n;x++) {
      mat[x]=new Array(m);
      for(y=0;y<m;y++) {
        mat[x][y]=new Array(k);
        if (init!=undefined) {
          if (typeof init == 'function')
            for(var z=0;z<k;z++) mat[x][y][z]=init(x,y,z);
          else
            for(var z=0;z<k;z++) mat[x][y][z]=init; 
        }  
      }
    }
    return mat;
  };
Array.random = function (n,a,b) {
  var res=[];
  a=a||0;
  b=b||1;
  for(var i=0;i<n;i++) res.push(Math.random()*(b-a)+a);
  return res;
}

Array.sequence = function (a,b,step,func) {
  var res=[], preci=1;
  step=step||1;
  if (step < 1) {
    preci = Math.ceil(Math.log10(1/step))
    for(var i=a;i<=b;i += step) res.push(func?func(i):Math.precision(i,preci));
  } else for(var i=a;i<=b;i += step) res.push(func?func(i):i);
  return res;
}

// Transpose matrix (array of arrays) by swapping rows and columns
Array.transpose = function (matrix) {
  var t=[];
  for (var i=0;i<matrix[0].length;i++) {
    var row=[];
    for(var j=0;j<matrix.length;j++) {
      row.push(matrix[j][i]);
    }
    t.push(row);
  }
  return t;
}  
// Simple array vectorA
Array.vector = function (cols,init) {
  if (init==undefined) init=0;
  if (typeof init != 'function') return Array(cols).fill(init);
  var row=[];
  for(var j=0;j<cols;j++) row.push(init(j));
  return row;
};
Array.init=Array.vector;

// Dynamic Object method extensions

Object.addProperty(Object,'toArray', function () {
  var self=this;
  return Object.keys(this).map(function (key) {
    return self[key]
  })
})


// Angle of line (p1,p2)  or delty vector
// +---------X
// |    270
// | 180 *  0
// |    90 
// Y
Math.angle = function (p1,p2) {
  var pd=[],i=0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') {
        if (i==0) dx=(p1[p]-p2[p]);
        else if (i==1) dy=(p1[p]-p2[p]);
        i++;
      }
  } else { 
    for(var p in p1) {
        if (i==0) dx=p1[p];
        else if (i==1) dy=p1[p];
        i++;    
    }
  }
  var theta = Math.atan2(dy, dx); // range (-PI, PI]
  theta *= 180 / Math.PI;
  if (theta < 0) theta = 360 + theta; // range [0, 360)
  return theta;
}
// Element-wise mean average computation
Math.average = function () {
  var ret=0,count=0;
  for (var i in arguments) {
    if (typeof arguments[i]=='number') ret+=arguments[i];
    else if (Utils.isObject(arguments[i])) {
      if (!ret) ret={}
      for(var j in arguments[i]) {
        if (!ret[j]) ret[j]=0;
        ret[j] += arguments[i][j];
      }
    } else if (Utils.isArray(arguments[i])) {
      if (!ret) ret=[];
      for(var j in arguments[i]) {
        if (!ret[j]) ret[j]=0;
        ret[j] += arguments[i][j];
      }    
    }
    count++;
  }
  if (typeof ret=='number') ret /= count;
  else {
    for(var i in ret) ret[i] /= count;
  }
  return ret;
}

Math.bin = Bin;

// mass of center of (optionally weighted) points
// typeof @pts = {x:numebr,y:number,weight?:number } | number [x,y] []
Math.center = function (pts) {
  var n,center,weight,totalmass=0,totalx=0,totaly=0;
  for (var i in pts)
  {
    n=pts[i]; if (n.length==2) n={x:n[0],y:n[1]};
    weight=(n.weight==undefined?1:n.weight);
    totalmass += weight;
    totalx += (n.x*weight);
    totaly += (n.y*weight);
  }
  center = {x:totalx/totalmass,y:totaly/totalmass}
  return center;
}

// Coding and Decoding

// Multi-level: Math.code(['A','B','C'],{A:1,B:2,C:4}) -> 7
// One-hot:     Math.code('A',['A','B','C']) -> [1,0,0]
Math.code = function (list,codes) {
  var y=0;
  if (typeof list == 'string' && Utils.isArray(codes)) {
    // One-hot
    var width = codes.length,
        index = codes.indexOf(list);
    y=[];
    for(var i=0;i<width;i++) y.push(i==index?1:0);
    return y;
  }
  // Multi-level
  if (!Utils.isArray(list)) list=[list];
  for(var i=0;i<list.length;i++) {
    if (list[i]!=undefined) y += (codes[list[i]]); 
  }
  return y; 
}
Math.code.onehot = function (classes,symbol,low,high) {
  if (low==undefined) low=0;
  if (high==undefined) high=1;
  return classes.map(function (c) { return symbol==c?high:low })
}
Math.code.interval = function (values,min,max,step,prefix,relative) {
  function code(x) {
    if (x<min) return (prefix?prefix:'')+'-';
    if (x > max) return (prefix?prefix:'')+'+';
    var xn = (x-min)/(max-min),
        sn = (step)/(max-min)
    return (prefix?prefix:0)+(relative?Math.floor(xn/sn):(min+Math.floor(xn/sn)*step))
  }
  if (Utils.isArray(values)) return values.map(code);
  else return code(values);
}
Math.contains = function (a,element) {
  if (Utils.isArray(a)) {
    return a.contains(element,Math.equal,true);
  } else if (Uitls.isObject(a)) {
    
  } else if (typeof a == 'string') {
    return a.indexOf(String(element))!=-1
  } 
}
// Returns dataspace and datatype of numerical objects
Math.dataspace = function (o) {
  if (Utils.isArrayArrayArray(o)) return [o.length,o[0].length,o[0][0].length];
  else if (Utils.isArrayArray(o)) return [o.length,o[0].length];
  else if (Utils.isArray(o))  return [o.length].concat(Math.dataspace(o[0]));
  else if (Math.Matrix.isMatrix(o)) return [o.rows,o.columns];
  else if (Math.MatrixTA.isMatrix(o)) return [o.rows,o.columns];
  else if (Utils.isBuffer(o)) return [o.length];
  return [];
}
Math.datatype = function (o,sig) {
  if (Utils.isArrayArray(o)) return Math.datatype(o[0][0],sig)+(sig?' [][]':'');
  else if (Utils.isArray(o))  return Math.datatype(o[0],sig)+(sig?' []':'');
  else if (Math.Matrix.isMatrix(o)) return Math.datatype(o.data[0][0],sig)+(sig?' Matrix':'');
  else if (Math.MatrixTA.isMatrix(o)) return o.datatype+(sig?' MatrixTA':'');
  else if (Utils.isBuffer(o)) return 'Buffer';
  else if (typeof o == 'object') return '{'+Object.keys(o).map(function (key) {
    return key+':'+Math.datatype(o[key],sig)
  }).join(',')+'}';
  return typeof o;
}

// Multi-level: Math.decode(7,{A:1,B:2,C:4}) -> ['A','B','C']
// One-hot:     Math.decode([1,0,0],['A','B','C'])
Math.decode = function (value, codes,mutual) {
  var list=[],y=value;
  if (Utils.isArray(value) && Utils.isArray(codes)) {
    // One-hot
    return codes[value.indexOf(value.max())]
  }
  // Multi-level
  if (mutual == undefined) {
    var sum=0;
    Object.keys(codes).forEach(function (code,index) {
      if (codes[code] & sum) mutual=true;
      if (codes[code]==0) mutual=true;
      sum += codes[code];
    })
  }
  Object.keys(codes).forEach(function (code) {
    if (mutual || y<0 || codes[code]<0) {
      if (y==codes[code]) list.push(code) 
    } 
    else 
    if ((y & codes[code]) ||
        y==codes[code]) list.push(code);
  })
  return list; 
}

// API changed! h/points swapped!
Math.derivative = function (data,order,h,points) {
  // https://math.stackexchange.com/questions/302160/correct-way-to-calculate-numeric-derivative-in-discrete-time
  var result;
  data=data.data||data; // comp. with Matrix
  order=order||1;
  points=points||2;
  h=h||1;
  if (Utils.isArray(data)||Utils.isTypedArray(data)) {
    result=[];
    switch (order) {
      case 1:
        switch (points) {
          case 1:
            for(var i=0; i<(data.length-1); i++) {
              result.push((data[i+1]-data[i])/h);
            }
            break;
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-data[i-1])/(2*h));
            }
            break;
          case 3:
            for(var i=2; i<(data.length-3); i++) {
              result.push((data[i-2]-8*data[i-1]+8*data[i+1]-data[i+2])/(12*h));
            }
            break;
        }
        break;
       case 2:
        switch (points) {
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-2*data[i]+data[i-1])/(h*h));
            }
            break;
        }
        break;
    }
  }
  return result;
} 
Math.delta = function (p1,p2) {
  var pd=p1.length?[]:{};
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') pd[p]=p1[p]-p2[p];
  } 
  return pd;
}
Math.distance = function (p1,p2,one) {
  var y=one?1:0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') y+=Math.pow(p1[p]-p2[p],2);
  } else {
    for(var p in p1) 
      if (typeof p1[p] == 'number') y+=Math.pow(p1[p],2);
  }
  return Math.sqrt(y)-(one?1:0) 
}
Math.deviation = function (values) {
  // d3.deviation comp. via variance (n-1)
  var v = Math.variance(values);
  return v ? Math.sqrt(v) : v;
}
// For sorting; sort down
Math.down = function (a,b) {
  return a>b?-1:1
}
Math.equal = function (a,b) {
    var i;
    if (Utils.isNumber(a) && Utils.isNumber(b)) return a==b;
    else if (Utils.isArray(a) && Utils.isArray(b)) {
      if (a.length!=b.length) return false;
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isObject(a) && Utils.isObject(b)) {
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isString(a) && Utils.isString(b))
      return (a.length==b.length && a==b)
    return false;
  }
Math.frac = function (x,frac) {
  if (frac<=1) {
    frac=(1/frac)|0;
    return Math.round(x*frac)/frac;
  } else {
    return Math.floor(x-(x%frac));
  }
}
Math.id = function (x) { return x }
Math.int = function (x) { return x|0 }
Math.decr = function (x) { return x-1 }
Math.incr = function (x) { return x+1 }

Math.isFloat = function (x) {
  function isFloat32Array(x) {
    if (typeof x[0] == 'object') return isFloat32Array(x[0]);
    if (typeof x.data == 'object') return isFloat32Array(x.data);
    return (x instanceof Array) ||
           (x instanceof Float32Array) ||
           (x instanceof Float64Array)
  }
  return typeof x == 'number'?true:
          (typeof x == 'object'?isFloat32Array(x):false)
}
Math.isNumber = function (x) {
  return !isNaN(Number(x)) 
}

// Hilbert transform using FFT (input data length must be a power of 2!) 
// Returns real, imaginary, and magnitude (norm) vectors (same length as input)
Math.hilbert = function hilbert(inp) {
  var N=inp.length,
      N2=N/2,
      fft = Math.FFT.FFT(N);
  var re1 = inp.slice();
  var im1 = Array.vector(N);
  fft.fft1d(re1,im1)
  var re2=re1.slice();
  var im2=im1.slice();
  for(var i=1;i<N2;i++) { re2[i]*=2; im2[i]*=2; }
  for(var i=N2+1;i<N;i++) { re2[i]=0; im2[i]=0; }  
  fft.ifft1d(re2,im2);
  return {re:re2, im:im2, mag:re2.map(function (r,i) {
      return Math.sqrt(r*r+im2[i]*im2[i]);
    })
  }
}

// Find and return nearest point in a point series {x=index in points,y=best value}
Math.nearest = function (points,valu,epsilon,test) {
  var best;
  if (!test) {
    for(var i in points) {
      if (epsilon==undefined) { // find any nearest value
        if (best==undefined ||
            Math.abs(points[i]-valu)<Math.abs(points[best]-valu))
          best=i;
      } else {
        if ((best!=undefined && Math.abs(points[i]-valu)<Math.abs(points[best]-valu))||
            (Math.abs(points[i]-valu) <= epsilon)) best=i;
      }
    }
  }
  if (best!=undefined) return {x:best,y:points[best]}
}

Math.precision = function (number, precision) {
  if (precision==undefined) {
    precision=number;
    return function (number) { return Math.precision(number,precision) }
  }
  var factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
}
// generate gaussian noise (Standard Normal variate using Box-Muller transform)
// https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
Math.random.gaussian = function (min,max,skew) {
    min=min||0;
    max=max||1;
    skew=skew||1;
    var u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    var num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) num = Math.random.gaussian(min, max, skew); // resample between 0 and 1 if out of range
    num = Math.pow(num, skew); // Skew
    num *= max - min; // Stretch to fill range
    num += min; // offset to min
    return num;
}
// uniform distribution
Math.random.int = function (n,b) {
  return b==undefined?(Math.random()*n)|0:((Math.random()*(b-n))+n)|0
}
Math.random.int8 = function () {
  return 128-((Math.random()*256)|0)
}
Math.random.uint8 = function () {
  return (Math.random()*256)|0
}
Math.random.int16 = function () {
  var R=65536;
  return (R/2)-((Math.random()*R)|0)
}
Math.random.uint16 = function () {
  var R=65536;
  return (Math.random()*R)|0
}
Math.random.int32 = function () {
  var R=65536*65536;
  return (R/2)-Math.floor(((Math.random()*R)))
}
Math.random.uint32 = function () {
  var R=65536*65536;
  return Math.floor((Math.random()*R))
}
Math.random.range = function(min,max) {
  return min+Math.random()*(max-min)
}
Math.random.interval = function(min,max) {
  return Math.round(min+Math.random()*(max-min))
}
Math.random.noise = function(val,eps,relative) {
  return relative?val+Math.random.gaussian(-Math.abs(val*eps),Math.abs(val*eps)):val+Math.random.gaussian(-eps,eps);
}
Math.random.frac = function (a,b,frac) {
    var r,n,p,i,keys,k;
    if (Utils.isArray(a)) {
      n = a.length;
      if (n>0)
        return a[Math.random.int(n)];  
      else
        return none;
    } else if (Utils.isObject(a)) {
      keys=Object.keys(a);
      n = keys.length;
      if (n>0)
        return a[keys[Math.random.int(n)]];  
      else
        return none;
    } else if (b==undefined) {b=a;a=0}; 
    if (!frac ||frac==1)
      return Math.random.interval(a,b);
    else {
      r=Math.random.range(a,b);
      return ((r/frac)|0)*frac;
    }
}

// Random selection (one or multiple samples from collection / array / object)
Math.random.select = function (o,samples) {
  var r,n,p,i,keys,k;
  if (samples) {
    var A=[],index;
    var data = Utils.isArray(o)?o:Utils.isObject(o)?Object.keys(o):[];
    function shuffle(array) {
      var m = array.length, t, i;
      // While there remain elements to shuffle
      while (m) {
        // Pick a remaining element
        i = Math.floor(Math.random() * m--);
        // And swap it with the current element.
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }
      return array;
    }
    index=Array(data.length).fill().map(function (x,i) { return i });
    index=shuffle(index);
    for(var i=0;i<samples;i++) {
      A.push(data[index[i]]);
    }
    if (Utils.isArray(o)) return A;
    else if (Utils.isObject(o)) {
      return A.map(function (key) { o[key] });
    }
  }
  if (Utils.isArray(o)) {
    n = o.length;
    if (n>0)
      return o[Math.random.int(n)];  
    else
      return none;
  } else if (Utils.isObject(o)) {
    keys=Object.keys(o);
    n = keys.length;
    if (n>0)
      return o[keys[Math.random.int(n)]];  
    else
      return none;
  }
}

Math.pulse = function (length,off,on,pulses) {
  var v = Array.init(length,off);
  if (!Utils.isMatrix(pulses)) pulses=[pulses];
  pulses.forEach(function (pulse) {
    if (Utils.isArray(pulse) && pulse.length==2) 
      for(var i=pulse[0];i<=pulse[1];i++) v[i]=on;
  });
  return v;
}

// Reshape an array or a matrix
Math.reshape = function (array, rows, cols ) {
  var dims = cols!=undefined?[rows,cols]:[rows];
  function _reshape (array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array
    var tmpArray2
    // for each dimensions starting by the last one and ignoring the first one
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex]
      tmpArray2 = []

      // aggregate the elements of the current tmpArray in elements of the requested size
      var length = tmpArray.length / size
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size))
      }
      // set it as the new tmpArray for the next loop turn or for return
      tmpArray = tmpArray2
    }

    return tmpArray
  }
  function _flatten (array) {
    var flat = []

    array.forEach(function callback (value) {
      if (Array.isArray(value)) {
        value.forEach(callback) // traverse through sub-arrays recursively
      } else {
        flat.push(value)
      }
    })
    return flat
  }
  return _reshape(_flatten(array),dims)
  
}

Math.scale = function (vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return scala.shift+(vrow-scala.off)*scala.k
    else if (scala.length)
      return scala[0].shift+(vrow-scala[0].off)*scala[0].k;
    else
      return scala.shift+(vrow-scala.off[0])*scala.k[0];
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off)*scala.k })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return scala[i].shift+(col-scala[i].off)*scala[i].k })
  else
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off[i])*scala.k[i] })
}

// Compute scaling descriptor for a given data set -> [0,1]
// Target output range of scaled data: [shift+0,shift+1] with shift=shift||0;
Math.scale0 = function (data,lower,upper) {
  var min=data.min(),
      max=data.max();
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  return {
    k:(upper-lower)/(max-min),
    off:min,
    shift:lower,
    min:min,
    max:max
  }
}
Math.scale1 = function (min,max,lower,upper) {
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  return {
    k:(upper-lower)/(max-min),
    off:min,
    shift:lower,
    min:min,
    max:max
  }
}

// Select column(s) from array rows (array array matrix)
// Start column ia a, end column is b (column range)
Math.select = function (data,a,b){
  if (b==undefined) {
    return data.map(function(object) { 
      return object[a]
    })
  }else {
    return data.map(function(object) {
      return object.slice(a,b+1)
    })
  }
}

// Returns a number sequence set
Math.sequence = Array.sequence;

// Math core extensions
Math.signal = {
  chirp : function (N,period,offset,width) {
    var limiter=Math.gaussian(Math.sequence(1,N),offset,width),
        wave = Math.sequence(0,N-1,1,function (i) { return Math.sin(i/period*2*Math.PI) }).mul(limiter);
    return wave;
  },
  energy: function (data) {
    if (Utils.isArray(data)) {
      var s=0;
      data.forEach(function (v) {
        s+= Math.pow(v,2);
      });
      return s/data.length;
    }
  },
  filter : {
    boxcar : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||3;
      switch (points) {
        case 3:
          for(var i=1;i<array.length-1;i++) result.push(
            (array[i-1]+array[i]+array[i+1])/3
          );
          return result;
          break;
      }
    },
    // 0 > k > 1 !!!
    lowpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.z == undefined) state.z=0;
      t=(1-k)*x+state.z*k;
      y=t;
      state.z=t;
      return y;
    },
    // 0 > k > 1 !!!!
    highpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.y == undefined) state.y=0;
      if (state.x == undefined) state.x=0;
      // t=(1-k)*x+state.z*(-k);
      t=k*(state.y+x-state.x);
      y=t;
      state.y=t;
      state.x=x;
      return y;    
    },
    // Function constructors
    lowPass : function (k,state) {
      return function (x) { return Math.signal.filter.lowpass(x,k,state) }
    },
    highPass : function (k,state) {
      return function (x) { return Math.signal.filter.highpass(x,k,state) }
    },
    triangular : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||5;
      switch (points) {
        case 5:
          for(var i=2;i<array.length-2;i++) result.push(
            (array[i-2]+2*array[i-1]+3*array[i]+2*array[i+1]+array[i+2])/9
          );
          return result;
          break;
      }
    },
    
  },
  meanAbsoluteDeviation: function(data) {
    var mean = Math.signal.mean(data);
       return Math.signal.mean(data.map(function(num) {
         return Math.abs(num - mean);
       }));
  },
  mean:function (data) { return data.mean() },
  peak: function (data) {
    if (Utils.isArray(data)) {
      return Math.max(Math.abs(data.max()),Math.abs(data.min()));
    }  
  },
  rms: function (data) {
    return Math.sqrt(data.map(Math.sq).sum()/data.length)
  },
  sample : function (data,frag,filter) {
    return data.sample(frag,filter)
  },
  standardDeviation: function(data) {
    return Math.sqrt(Math.signal.variance(data));
  },
  variance: function (data) {
    if (Utils.isArray(data)) {
      return data.variance()
    }
  },
}

Math.sq = function (x) { return x*x }

Math.sum = function (a,b) {
  return a+b
}
// Return unique identifier name [a-zA-Z0-9]
Math.unique = function (length) {
  return Math.random().toString(36).substr(2, 2+length);
}
// For sorting; sort up
Math.up = function (a,b) {
  return a<b?-1:1
}

Math.variance = function (values) {
  var count = 0;
  var delta;
  var mean = 0;
  var sum = 0;
  for (var value of values) {
    if (value != null && (value = +value) >= value) {
      delta = value - mean;
      mean += delta / ++count;
      sum += delta * (value - mean);
    }
  }
  if (count > 1) return sum / (count - 1);
}

Math.window = {
  // window functions returning mask array of width w
  // https://github.com/scijs/window-function
  
  //////////////// WINDOWS ////////////////
  gaussian : function (w,sigma) {
    var res=[];
    sigma=sigma||0.4;
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i-nm12)/sigma/nm12,
          h=Math.exp(-0.5*f*f);
      res.push(h)
    }
    return res;
  },
  
  hamming : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 0.54 - 0.46 * Math.cos(Math.PI*2*i/(w-1));
      res.push(h)
    }
    return res;
  },
  
  hann: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      var t = -0.9999999+2*(i/(w+1));
      var h = Math.sqrt(2)/2 * (1+Math.cos(t*Math.PI)) / 
              Math.sqrt(1+Math.pow(Math.cos(t*Math.PI),2) ) * (
              Math.abs(t)<1?1:0);
      res.push(h)
    }
    return res;
  },
  
  rect: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      res.push(1)
    }
    return res;
  },
  
  triangular : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 1 - Math.abs( 2 * (i - 0.5*(w-1)) / w );
      res.push(h)
    }
    return res;
  },
  
  welch : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i - nm12)/nm12,
          h = 1 - f*f  ;
      res.push(h)
    }
    return res;
  },
  
  /////////////////////// MASKING /////////////////////  
  mask: function (data,off,width,win,arg) {
    var mask = (win||Math.window.hann)(width,arg);
    var res=[];
    for(var i=0;i<width;i++) res.push(data[off+i]*mask[i]);
    return res;
  },
  

}
Math.zip = function (v1,v2) {
  if (typeof v1[0]=='number' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return [row,v2[index]]
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return row.concat(v2[index])
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return row.concat([v2[index]])
    })
  if (typeof v1[0]=='number' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return [row].concat(v2[index])
    })
  
} 
if (typeof module != 'undefined') module.exports=Math
if (typeof window != 'undefined') console.log('Math '+Math.version+' loaded.');
};
BundleModuleCode['plugins/math/matrixTA']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.14.1X
 **
 **    $INFO:
 **
 **  Numerical Matrix Module associated with typed arrays, but with generic array compatibility. 
 **  A matrix provides a wrapper and multi-dimensional array view for one-dimensional byte arrays (typed arrays using buffers).
 **
 **  Examples:
 **
 ** // From shared array buffer:
 ** Math.MatrixTA({data:function (size) { return new SharedArrayBuffer(size) } OR data:SharedArrayBuffer(size),
 ** rows:10,columns:10,datatype:'Float32'})
 **
 ** // From shared memory segment
 ** var sm = BufferSegment(...);
 ** Math.MatrixTA({
 **  data : sm,
 **  rows:10,columns:10,datatype:'Float32'
 ** });
 **
 **
 **    $ENDOFINFO
 */

var version = "1.14.1X"

var utils  =  Require('plugins/math/matrixTA-utils');
var Vector =  Require('plugins/math/vectorTA');

var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

integer = function (v)  { return Math.floor(v) }
divide = function (a,b) { return Math.floor(a/b) }


var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString,
    DataSize = Utils.DataSize,
    TypedArrayOfName = Utils.TypedArrayOfName;


function todo (what) { throw ("Not implemented: Matrix."+what) }
function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(name+'must be a number');
  }
}
function transpose (layout) {
  switch (layout) {
    case 12: return 21;
    case 21: return 12;
  }
}
/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

// Most generic versions - always overwrite (polyfill/vector definitions)
Object.updateProperty(Array,'get', function (i,j,k) {
  if (k!=undefined)
   return this[i][j][k];
  else if (j!=undefined)
   return this[i][j];
  else
   return this[i];
})
Object.updateProperty(Array,'getRow', function (i) {
 return this[i];
})

Object.updateProperty(Array,'info', function () {
  var rows,columns,levels;
  if (isArrayArrayArray(this)) levels=this.length,rows=this[0].length,columns=this[0][0].length;
  else if (isArrayArray(this)) rows=this.length,columns=this[0].length;
  else columns=this.length;
  if (levels) return {
    dtn:'Array',
    size:levels*rows*columns,
    levels:levels,
    rows:rows,
    columns:columns,
    dims:3,
    offset:0,
  }; else if (rows) return {
    dtn:'Array',
    size:rows*columns,
    rows:rows,
    columns:columns,
    dims:2,
    offset:0,
  }; else return {
    dtn:'Array',
    size:columns,
    columns:columns,
    dims:1,
    offset:0,
  }
})


Object.updateProperty(Array,'mapRow', function (i,f) {
 return this[i].map(f);
})

Object.updateProperty(Array,'max', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] > m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] > m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.max.apply(null, this) // vector
  else   // matrix
    return Math.max.apply(null,this.map(function (row) { return Math.max.apply(null, row) }))
})


Object.updateProperty(Array,'mean', function () {
  if (typeof this[0] == 'number')
    return this.sum()/this.length // vector
  else   // matrix
    return this.sum()/(this.length*this[0].length)
})

// this and b can be vectors or matrix objects
// returns always a matrix
Object.updateProperty(Array,'merge', function (b,align) {
  var a=this;
  if (!b || a.length!=b.length) throw "array.merge: length mismatch";
  if (align && align.indexOf('c')==0) {
    // columns alignment ab
    if (Utils.isArray(a[0]))
      return a.map(function (row,index) {
        return Utils.isArray(row)?row.concat(b[index]):[row,b[index]];
      });
    else // a is vector
      return a.map(function (row,index) {
        return Utils.isArray(row)?[row].concat(b[index]):[row,b[index]];
      })
  } else if (!align || align.indexOf('r')==0) {
    // row alignment a
    //               b
    if (!Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b).map(function (row) { return [row] });
    else if (Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b.map(function (row) { return [row] }));
    else if (!Utils.isArray(a[0]) && Utils.isArray(b[0])) return a.map(function (row) { return [row] }).concat(b);
    else return a.concat(b);
  }
})

Object.updateProperty(Array,'min', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] < m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] < m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.min.apply(null, this) // vector
  else    // matrix
    return Math.min.apply(null,this.map(function (row) { return Math.min.apply(null, row) }))
})


Object.updateProperty(Array,'pluck', function (key) {
  var collection=this;
  return collection.map(function(object) {
    return object == null ? undefined : object[key];
  });
})

Object.updateProperty(Array,'print', function (format) {
  var i,j,k,s='',sep='', info=this.info();
  if (!format) format = '%4.2f';
  switch (info.dims) {
    case 1:
      for(j=0;j<info.columns;j++) {
        if (j!=0) s = s + '\n';
        s = s + sprintf(format,this[j]) ;
      }
      break;
    case 2:
      for(j=0;j<info.rows;j++) {
        sep = '';
        if (j!=0) s = s + '\n';
        for (i=0;i<info.columns;i++) {
          s = s + sep + sprintf(format,this[j][i]) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<info.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(j=0;j<info.rows;j++) {
          sep = '';
          if (j!=0) s = s + '\n';
          for (i=0;i<info.columns;i++) {
            s = s + sep + sprintf(format,this[k][j][i]) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
})

Object.updateProperty(Array,'prod', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a*b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a*b })
    }).reduce(function (a,b) { return a*b })
})

// sub(row number|[row0,row1]|[[rowa,rowb,rowc,..]],col number|[col0,col1]|[[cola,colb,colc,..]])
Object.updateProperty(Array,'sub', function (i /*row/col*/,j /*col?*/) {
  var res;
  if (typeof i == 'number') res = this[i];
  else if (isArrayArray(i)) {
    res=[]
    for(var k in i[0]) {
      res.push(this[i[0][k]])
    }
  } else if (isArray(i) && i.length==2) res = this.slice(i[0],i[1]+1);
  else res=this;
  if (!isArrayArray(res)) {
    if (typeof j == 'number') res = res[j];
    else if (isArrayArray(j)) {
      res=res.filter(function (col,coli) {
        return j[0].indexOf(coli)!=-1
      })
    } else if (isArray(j) && j.length==2) res = res(j[0],j[1]+1);
  } else if (isArray(res)) {
    if (typeof j == 'number') 
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a[j]]:a).concat([b[j]]) });
    else if (isArrayArray(j)) {
      res=res.map(function (row) {
        return row.filter(function (col,coli) {
          return j[0].indexOf(coli)!=-1
        })
      })
    } else if (isArray(j) && j.length==2)
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a.slice(j[0],j[1]+1)]:a)
                .concat([b.slice(j[0],j[1]+1)]) });
  }
  return res;
})

Object.updateProperty(Array,'set', function (a,b,c,d) {
  if (d!=undefined)
   return this[a][b][c]=d;
  else if (c!=undefined)
   return this[a][b]=c;
  else
   return this[a]=b;
})

Object.updateProperty(Array,'setRow', function (i,row) {
 return this[i]=row;
})

Object.updateProperty(Array,'sum', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a+b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a+b })
    }).reduce(function (a,b) { return a+b })
})

// [][] -> [] == flat
Object.updateProperty(Array,'unwrap', function () {
  return this.flat();
})

Object.updateProperty(Array,'variance', function () {
  // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
  var sigma1=0,sigma2=0,n=0;
  if (typeof this[0] == 'number') {
    for(var i=0;i<this.length;i++) {
      sigma1 += (this[i]*this[i]);
      sigma2 += this[i];
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/this.length)/this.length);
  } else {  // matrix
    for(var i=0;i<this.length;i++) {
      for(var j=0;j<this[i].length;j++) {
        sigma1 += (this[i][j]*this[i][j]);
        sigma2 += this[i][j];
        n++;
      }
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/n)/n);
  }
})

// [] -> [][]
Object.updateProperty(Array,'wrap', function () {
  return this.map(function (row) { return [row] });
})



/****************** MATRIX ***************************/
// Matrix object based on typed arrays!
// Supports mixed mode typed arrays and generic arrays!
// {type:function,dtn:string} specifies data type
//
// dataspace : [levels,rows,columns]
// Usage:
// Matrix(columns:number)
// Matrix(rows:number,columns:number)
// Matrix(rows:number,columns:number,levels:number)
// Matrix(rows:number,columns:number,options:{dtn:string})
// Matrix([])
// Matrix([][])
// Matrix([][][])
// Matrix({data:buffer|typedarray|SharedArrayBuffer,rows:numner,columns:number,dtn:..})
//
// typeof return = Matrix

function Matrix (a,b,c,d) {
  var self = this;
  var rows,columns,levels,dims=2,dtn,dt=Matrix.options.dt,data,
      layout=12,size,transpose,offset=0;
  var options = isObject(d)?d:(isObject(c)?c:(isObject(b)?b:{}));
  this.tag='MatrixTA';
  if (!(this instanceof Matrix)) return new Matrix(a,b,c,d);
  if (isNumber(a) && isNumber(b)) {
    // Create new empty matrix (2/3 dims)
    rows=a;
    columns=b;
    if (isNumber(c)) levels=c;
    dims=levels?3:2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    size=rows*columns;
    if (levels) size *= levels;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.data)
      data=new dt(options.data);
    else if (dt.name=='Array')
      data=new Array(rows).fill(null).map(function (row) { return new Array(columns).fill(0) });
    else
      data=new dt(size);
  } 
  else if (isNumber(a)) {
    // Create a new empty matrix vector (rows=1)
    rows=1;
    columns=a;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    size=columns;
    if (options.data)
      data=new dt(options.data);
    else
      data=new dt(size);
  } 
  else if (isArrayArray(a)) {
    if (options.datatype) options.dtn=options.datatype+'Array';
    rows=a.length;
    columns=a[0].length;
    if (isArrayArrayArray(a)) levels=rows,rows=a[0].length,columns=a[0][0].length;
    size=rows*columns;
    if (levels) size *= levels;
    dims=levels?3:2;
    if (options.type) dt=options.type;
    if (options.dtn)  {
      dt=TypedArrayOfName[options.dtn];
    }
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(size);
      switch (layout) {
        case 12:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[coli+rowi*columns]=col;
            })
          });
          break;
        case 21:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[rowi+coli*rows]=col;   // TBCHECK!
            })
          });
          break;
      }
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isArray(a)) {
    // Vector 
    rows=1;
    columns=a.length;
    size=columns;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=[a];
    }
  } else if (a instanceof Matrix) {
    if (options.transpose) {
      // transposeView !
      rows=a.columns;
      columns=a.rows;
      levels=a.levels;
      size=a.size;
      dims=a.dims;
      transpose=true;
      data=a.data;
      dtn=a.dtn;
      switch (a.layout) {
        case 12: layout=21; break;
        case 21: layout=12; break;
        case 123: layout=321; break;
        case 321: layout=123; break;
      }
    } else {
      // Copy (and convert?)
      if (options.datatype) options.dtn=options.datatype+'Array';
      rows=options.rows||a.rows;
      columns=options.columns||a.columns;
      levels=options.levels||a.levels;
      dims=a.dims;
      size=rows*columns;
      if(levels) size*=levels;
      transpose=false;
      scale=options.scale;
      if ((options.dtn && options.dtn != a.dtn) || size != a.size) {
        // convert or resize dtn
        dtn = options.dtn;
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      } else {
        dtn=a.dtn;
        if (dtn != 'Array')
          data=a.data.slice();
        else {
          // TODO dims=3
          data=a.data.map(function (row) { return row.slice() });
        }
      }
      if (a.scale) this.scale=a.scale;
      if (a.complex) this.complex=a.complex;
      layout=a.layout;
    }
  } else if (isObject(a)) {
      // Partial matrix object
      if (a.dataspace) {
        if (a.dataspace.length==1)
          a.rows=1,a.columns=a.dataspace[0];
        else if (a.dataspace.length==2) 
          a.rows=a.dataspace[0],
          a.columns=a.dataspace[1];
        else if (a.dataspace.length==3) 
          a.levels=a.dataspace[0],
          a.rows=a.dataspace[1],
          a.columns=a.dataspace[2];
      }
      if (a.datatype) a.dtn=a.datatype+'Array';
      rows=a.rows||(a.y && a.x);
      columns=a.columns||a.y||a.x;
      levels=a.levels||a.z;
      size=a.size||((rows?rows:1)*(columns?columns:1)*(levels?levels:1));
      dims=a.dims||(levels?3:(rows?2:1));
      layout=a.layout||(levels?123:(rows?12:1));
      dtn=a.dtn||'Float32Array';
      dt=TypedArrayOfName[a.dtn];
      if (!a.data) a.data=new dt(size);
      if (typeof BufferSegment != 'undefined' && a.data instanceof BufferSegment) {
        // Buffer segment allocated data
        this.block = a.data.object(a.dtn,size);
        a.data = this.block.data;
        delete this.block.data;
      } else if (typeof a.data == 'function') {
        // allocation function for a buffer returning array buffer or segment block with sliced buffer ..
        var block=a.data(size*DataSize[dtn.replace(/Array/,'')]);
        if (Utils.isBufferArray(block)) a.data=block; 
        else {
          this.block={addr:block.addr,size:block.size,segment:block.segment};
          a.data=block.data;
        }
      } else if (a.block) {
        // Buffer sgement allocated data, too
        this.block=a.block;
        var sm = BufferSegments[a.block.segment];
        if (sm) {
          var block = sm.object(dtn,size,this.block.addr);
          a.data=block.data;
        }
      } 
      
      if (Utils.isBuffer(a.data)) data=new dt(a.data.buffer,a.offset);
      else if (Utils.isBufferArray(a.data)) data=new dt(a.data,a.offset);
      else
        data=a.data;
  }
  if (levels) this.levels=levels;   // z
  this.rows     = rows;                   // x
  this.columns  = columns;             // x/y
  this.size     = size;              // number of elements
  this.layout   = layout;
  this.data     = data;
  this.dims     = dims;
  this.dataspace  = levels?[levels,rows,columns]:[rows,columns];
  this.length   = levels?levels:(rows?rows:columns);
  
  this.dtn=dtn||dt.name;
  this.datatype=this.dtn.replace(/Array/,'');
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  // get/set index order: 
  // 1. column(x)
  // 2. row(x),column(y)
  // 3. row(x),column(y),level(z)
  

  if (Matrix.options.compatLayout) {
    // Old WRONG layouts; but needed for backward compatibility! Enabled with Matrx.options.compatLayout=true;
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (column,row)   { return this.data[row][column] };
          this.set=function (column,row,v) { this.data[row][column]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[row][column][level] };
          this.set=function (row,column,level,v) { this.data[row][column][level]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 12:
        // x=row,y=column
        this.index = function (x,y)   { return x*this.columns+y}
        this.get = function (x,y)     { return this.data[x*this.columns+y] }
        this.set = function (x,y,v)   { return this.data[x*this.columns+y]=v }
        break;
      case 21:
        // x=row,y=column      
        this.index = function (x,y)   { return y*this.rows+x }
        this.get = function (x,y)     { return this.data[y*this.rows+x] }
        this.set = function (x,y,v)   { return this.data[y*this.rows+x]=v }
        break;
      case 123:
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+y*this.columns+x*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[z+y*this.levels*this.rows+x*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+y*this.levels*this.rows+x*this.levels]=v }
        break;
      case 321:
        // x=row,y=column,z=level
        // TBC
        this.index = function (x,y,z) { return x+y*this.rows+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[x+y*this.rows+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[x+y*this.rows+z*this.columns*this.rows]=v }
        break;
    }

  } else {
    // New correct layouts!
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (row,column)   { return this.data[column][row] };
          this.set=function (row,column,v) { this.data[column][row]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[level][row][column] };
          this.set=function (row,column,level,v) { this.data[level][row][column]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // C0,C1,..
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 21:
        // C0:R0R1..RM,C1:R0R1..RM,..
        // x=row,y=column
        this.index = function (x,y)   { return x+y*this.rows}
        this.get = function (x,y)     { return this.data[x+y*this.rows] }
        this.set = function (x,y,v)   { return this.data[x+y*this.rows]=v }
        break;
      case 12:
        // R0:C0C1..CN,R1:C0C1..CN,..
        // x=row,y=column      
        this.index = function (x,y)   { return y+x*this.columns }
        this.get = function (x,y)     { return this.data[y+this.columns*x] }
        this.set = function (x,y,v)   { return this.data[y+this.columns*x]=v }
        break;
      case 321:
        // C0: R0:L0L1..LO,R1:L0L1..LO,..
        // C1: ..
        // x=row,y=column,z=level
        // TBC??
        this.index = function (x,y,z) { return z+x*this.levels+y*this.levels*this.rows }
        this.get = function (x,y,z)   { return this.data[z+x*this.levels+y*this.levels*this.rows] }
        this.set = function (x,y,z,v) { return this.data[z+x*this.levels+y*this.levels*this.rows]=v }
        break;
      case 312:
        // RGB format!!!!!
        // R0: C0:L0L1..LO,C1:L0L1..LO,..
        // R1: ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+x*this.levels*this.columns+y*this.levels }
        this.get = function (x,y,z)   { return this.data[z+x*this.levels*this.columns+y*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+x*this.levels*this.columns+y*this.levels]=v }
        break;
      case 123:
        // Z0: R0:C0C1..CN,R1:C0C1..CN,.. 
        // Z1; ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return y+x*this.columns+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[y+x*this.columns+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[y+x*this.columns+z*this.columns*this.rows]=v }
        break;
    }
  }
  this.__constructor__='Math.MatrixTA';
}



Matrix.options = {
  // Degault TA change must be applied to dt (and dtn)!
  dt : Float32Array,
  dtn : 'Float32Array',
  compatLayout : false,   // old wrong matrix layout for backward compatibility
}


/******** STATIC MEMBERS ********/
Matrix.abs = function (m) {
  return Matrix.clone(m).abs();
}

Matrix.add = function (m,v) {
  return Matrix.clone(m).add(v);
}

Matrix.clone = function (src) {
  return Matrix(src);
}

Matrix.columnVector = function (array) {
  return Matrix(array)
}

// Return an (typed)array
Matrix.checkArray = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof _MatrixConstructor) return arrayOrMatrix.data;
  else return arrayOrMatrix;
}

// Return a Matrix
Matrix.checkMatrix = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof Matrix) return arrayOrMatrix;
  else return Matrix(arrayOrMatrix);
}

Matrix.checkMatrixSize = function (matrix1,matrix2) {
  if (matrix1.dims != matrix2.dims) return false;
  if (matrix1.rows != matrix2.rows ||
      matrix1.columns != matrix2.columns ||
      matrix1.levels != matrix2.levels ) return false;
}

Matrix.cos = function (m) {
  return Matrix.clone(m).cos();
}

Matrix.crop = function (m,bbox) {
  if (m.dims!=2) throw "Matrix.crop: matrix.dims<>2";
  if (Utils.isArray(bbox)) {
    // [x,y,w,h]
    return m.subMatrix(bbox[1],bbox[1]+bbox[3]-1,
                       bbox[0],bbox[0]+bbox[2]-1)
  } else if (Utils.isObject(bbox) && bbox.w && bbox.h) {
    // {x,y,w,h}
    return m.subMatrix(bbox.y,bbox.y+bbox.h-1,
                       bbox.x,bbox.x+bbox.w-1)  
  } else if (Utils.isObject(bbox) && bbox.width && bbox.height) {
    // {x,y,width,height}
    return m.subMatrix(bbox.y,bbox.y+bbox.height-1,
                       bbox.x,bbox.x+bbox.width-1)  
  }
}

Matrix.diag = function (array,rows,columns) {
  if (!rows) rows=array.length;
  if (!columns) columns=rows;
  if (rows!=columns) Matrix.error("Not a square matrix",'diag');
  return Matrix(rows,columns).fill(function (i,j) {
    return i==j?array[i]:0;
  })
}

Matrix.div = function (m,v) {
  return Matrix.clone(m).div(v);
}

Matrix.empty = function (rows,columns) {
  return Matrix(rows,columns);
}

Matrix.error = function (what,where,ref) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.errorRange = function (what,where,ref) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

Matrix.eye = function (rows,columns,val,options) {
  if (!val) val=1;
  if (!columns) columns=rows;
  return Matrix(rows,columns,options).fill(function (i,j) {
    return i==j?val:0;
  });
}
 
Matrix.exp = function (m) {
  return Matrix.clone(m).exp();
}

// create an Uint8 RGB Matrix from raw RGBA image data [3,rows,columns]
// supports image descriptors {width,height,depth,data}, too
Matrix.fromImage = function (widthOrImage,height,imgData) {
  var image= {};
  if (typeof widthOrImage == 'object') {
    image = widthOrImage;
  } else {
    image.width=widthOrImage;
    image.height=height;
    image.depth=4;
    image.data=imgData;
  }
  // imgData is RGBA => RGB layout 123
  var mat = Matrix({
    rows:image.height,
    columns:image.width,
    levels:3,
    layouet:123,
    datatype : 'Uint8',
  })
  var row=0,col=0;
  for(var i=0;i<image.data.length;i=i+4) {
    var r=image.data[i],
        g=image.data[i+1],
        b=image.data[i+2],
        a=image.data[i+3]/255,
        r2=255,g2=255,b2 = 255;
    var r3 = Math.round(((1 - a) * r2) + (a * r))
    var g3 = Math.round(((1 - a) * g2) + (a * g))
    var b3 = Math.round(((1 - a) * b2) + (a * b))
    mat.set(row,col,0,r3);
    mat.set(row,col,1,g3);
    mat.set(row,col,2,b3);
    col++;
    if (col==image.width) { col=0; row++ };
  }
  return mat;
}

Matrix.isMatrix = function (o) {
  return (o instanceof Matrix)
}

// Identity matrix (squared)
Matrix.I = function (n,options) { return Matrix.eye(n,n,1,options) };

Matrix.max =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','max');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
    case 3:
      break;
  }
  return result;
}

Matrix.min =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','min');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, levels, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
  }
  return result;
}


Matrix.mod = function (m,v) {
  return Matrix.clone(m).mod(v);
}

Matrix.mul = function (m,v) {
  return Matrix.clone(m).mul(v);
}

Matrix.neg = function (m) {
  return Matrix.clone(m).neg();
}

Matrix.ones = function (rows,columns) {
  return Matrix(rows,columns).fill(1);
}

Matrix.rand = function (rows, columns, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return rng();
  });
}
/* rows, [cols,] [levels] options? */
Matrix.Random = function (a,b,c,d) {
  var dataspace=[],options={};
  if (typeof c == 'number') dataspace.push(c);  
  if (typeof a == 'number') dataspace.push(a);  
  if (typeof b == 'number') dataspace.push(b);  
  if (typeof a == 'object') options=a;
  if (typeof b == 'object') options=b;
  if (typeof c == 'object') options=c;
  if (typeof d == 'object') options=d;
  if (dataspace.length) options.dataspace=dataspace;
  if (!options.datatype) options.datatype='Float32';
  var mat = Matrix(options);
  var rng=Math.random;
  if (/int8/.test(options.datatype)) rng=function() { return (Math.random()*255)|0 };
  if (/int16/.test(options.datatype)) rng=function() { return (Math.random()*(65535))|0 };
  if (/int32/.test(options.datatype)) rng=function() { return (Math.random()*(4294967295))|0 };  
  mat.fill(rng);
  return mat
}
Matrix.randInt = function (rows, columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}
// resize a matrix (up- and downscaling) with different algorithms
// resize supports:
// 'nn': nearest neighbor algorihm (default, up- and down.scaling)
// 'mean': mean filter kernel (down-scaling)
// 'min': minimum value slection filter kernel (down-scaling)
// 'max': maximum value selection filter kernel (down-scaling)
// 'linear: bilinear filter kernel (up-sclaing)

Matrix.resize = function (src,a,b,c,d) {
  var dataspaceSrc=src.dataspace,
      datatype=src.datatype,
      meth='nn',
      options={},
      dataspaceDst=[];
  if (typeof a == 'number') dataspaceDst.push(a);
  if (typeof b == 'number') dataspaceDst.push(b);
  if (typeof c == 'number') dataspaceDst.push(c);
  if (typeof b == 'string') meth=b;
  if (typeof c == 'string') meth=c;
  if (typeof d == 'string') meth=d;  
  var dst = Matrix({dataspace:dataspaceDst,datatype:datatype});
  if (src.dims==2) {
    var rows=dst.rows,
        cols=dst.columns,
        rowsS=src.rows,
        colsS=src.columns,
        rowSD=rowsS/rows,
        colSD=colsS/cols;
    // default nearest neighbor method
    if (meth=='nn') {
      for(var i=0;i<rows;i++)
        for(var j=0;j<cols;j++) {
          var iS=Math.floor(i*rowSD),
              jS=Math.floor(j*colSD);
          dst.set(i,j,src.get(iS,jS)); 
      }
    } else if (meth=='mean') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var sum=0,n=0;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { sum+=v;  } n++; /* padding with zeros? */
          }
          return sum/n;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='max' || meth=='peak') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var max;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { max=max==undefined?v:Math.max(v,max) } 
          }
          return max;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='min') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var min;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { min=min==undefined?v:Math.min(v,min) } 
          }
          return min;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='linear') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var sum=0,n=0;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              var w = 1-Math.distance([i-row,j-col])/Math.distance([rowR,colR]);
              if (v!=undefined)  { sum+=(v*w); }  n++; /* padding with zeros? */
          }
          return sum/n;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else if (rowSD<1 && colSD<1) {
        // see https://chao-ji.github.io/jekyll/update/2018/07/19/BilinearResize.html
        var rowR=rowsS/rows,
            colR=colsS/cols;
        function kernel(i,j) {
          var x_l = Math.floor(colR * j), y_l = Math.floor(rowR * i)
              x_h = Math.ceil(colR * j),  y_h = Math.ceil(rowR * i);
          var x_weight = (colR * j) - x_l,
              y_weight = (rowR * i) - y_l;
          var a = src.get(y_l, x_l)||0,
              b = src.get(y_l, x_h)||0,
              c = src.get(y_h, x_l)||0,
              d = src.get(y_h, x_h)||0;
          return a * (1 - x_weight) * (1 - y_weight) + 
                 b * x_weight * (1 - y_weight) + 
                 c * y_weight * (1 - x_weight) + 
                 d * x_weight * y_weight
        }
        // up-scaling; extrapolation
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            dst.set(i,j,kernel(i,j));
        }
      } else throw "Matrix.resize: not supported resize method";
    } else throw "Matrix.resize: not supported resize method";
  }
  return dst;
}

Matrix.sin = function (m) {
  return Matrix.clone(m).sin();
}

Matrix.sub = function (m,v) {
  return Matrix.clone(m).sub(v);
}

// Returns now image descriptor { width, height, depth=4, data:UintArray }
Matrix.toImage = function (matrix) {
  // TODO matrix.layout != 123
  switch (matrix.dims) {
    case 2:
      var data = new Uint8Array(matrix.size*4);
      matrix.forEach(function (v,row,col) {
        data[0+col*4+row*matrix.columns*4]=v;
        data[1+col*4+row*matrix.columns*4]=v;
        data[2+col*4+row*matrix.columns*4]=v;
        // set alpha to 255
        data[3+col*4+row*matrix.columns*4]=255;
      });
      break;
    case 3:
      var data = new Uint8Array(matrix.rows*matrix.columns*4);
      matrix.forEach(function (v,row,col,level) {
        data[level+col*4+row*matrix.columns*4]=v;
        // set alpha to 255
        data[3+col*4+row*matrix.columns*4]=255;
      });
      break;
  }
  return { width:matrix.columns, height:matrix.rows, depth:4, data : data };
}

Matrix.zero = function (rows,columns) {
  return Matrix(columns,rows).fill(0);
}

Matrix.version = version;

/********* INSTANCE MEMBERS *********/


Matrix.prototype.abs = function (v) {
  this.eval(Math.abs);
  return this; 
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.add = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] += v.data[i];
    return result;
  } else result.eval(function (x) {return x+v});
  return result; 
}

// Apply a function to all elements AND update the elements by the return value of f!
Matrix.prototype.apply = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        this.set(j,f.call(this,this.get(j),j))
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          this.set(i,j,f.call(this,this.get(i,j),i,j))
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            this.set(i,j,k,f.call(this,this.get(i,j,k),i,j,k))
      return this;
  }
}

// Iterate over all elements of matrix and apply function to matrix elements (w/o matrix update)
Matrix.prototype.forEach = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        f.call(this,this.get(j),j)
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          f.call(this,this.get(i,j),i,j)
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            f.call(this,this.get(i,j,k),i,j,k)
      return this;
  }
}

Matrix.prototype.checkIndex = function(x,y,z) {
  switch (this.dims) {
    case 1: return x>=0&&x<this.columns;
    case 2: return y>=0&&y<this.columns&&x>=0&&x<this.rows;
    case 3: return y>=0&&y<this.columns&&x>=0&&x<this.rows&&z>=0&&z<this.levels;
  }
}

Matrix.prototype.checkMatrixDims = function(dims) {
  if (this.dims != dims) this.errorRange('Matrix has not expected dimension '+dims);
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkColumnIndex = function(index, outer) {
  var max = outer ? this.columns : this.columns - 1;
  if (index < 0 || index > max) this.errorRange('Column index out of range');
}


/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkRowIndex = function(index, outer) {
  var max = outer ? this.rows : this.rows - 1;
  if (index < 0 || index > max)
    this.errorRange('Row index out of range');
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkRowVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.columns) 
    this.errorRange(
      'vector size must be the same as the number of columns'
    );
  
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkColumnVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.rows) 
    this.errorRange('vector size must be the same as the number of rows');
  
  return vector;
}

Matrix.prototype.checkIndices = function(rowIndices, columnIndices) {
  return {
    row: this.checkRowIndices(rowIndices),
    column: this.checkColumnIndices(columnIndices)
  };
}

Matrix.prototype.checkRowIndices = function(rowIndices) {
  var self=this;
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= self.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

Matrix.prototype.checkColumnIndices = function(columnIndices) {
  var self=this;
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= self.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

Matrix.prototype.checkRange = function(startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 4) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= this.rows ||
    endRow < 0 ||
    endRow >= this.rows ||
    startColumn < 0 ||
    startColumn >= this.columns ||
    endColumn < 0 ||
    endColumn >= this.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

Matrix.prototype.clone = function () {
  return Matrix(this);
}


// Return array or vector
Matrix.prototype.col = function (index,asVector) {
  var col=[];
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 2: col=this.data.pluck(index); break;
        case 3: throw new Error ('EINVALID');
      }
    default:
      switch (this.dims) {
        case 2: for(var i=0;i<this.rows;i++) col.push(this.get(i,index)); break;
        case 3: throw new Error ('EINVALID');
      }
  }
  return asVector?Math.VectorTA(col,{dtn:this.dtn}):col;
}

Matrix.prototype.getCol = Matrix.prototype.col;
Matrix.prototype.pluck = Matrix.prototype.col;

/** Copy (1) a sorurce array (vector) into this matrix (row/column w or w/o subrange), or (2) create a copy of this matrix (empty argument list)
 *
 * copy()
 * copy([a,b]|[],[v1,v2,...])
 * copy(number,[a,b]|[],[v1,v2,...])
 * copy([a,b]|[],number,[v1,v2,...])
 * copy(number,number,[a,b]|[],[v1,v2,...])
 * ..
 */
 
Matrix.prototype.copy = function (a,b,c,d) {
  var x,y,z,rx,ry,rz,i,j,k,src;

  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;

  if (isArray(d)) src=d;
  if (isVector(d)) src=d;
  
  if (!src && !d && (isArray(c) || isVector(c))) src=c,rz=undefined;
  if (!src && !c && (isArray(b) || isVector(b))) src=b,ry=undefined;
  if (!src && !a && (isArray(a) || isVector(a))) src=a,rx=[0,this.columns-1];  // 1-dim only
    
  if (isVector(src)) src=src.data;
  if (!src) return Matrix({
    rows:this.rows,
    columns:this.columns,
    levels:this.levels,
    dtn:this.dtn,
    layout:this.layout,
    data:this.data.slice()
  })
  
  if (!src) throw "Matrix.copy: no source array provided";
  if (rx && rx.length==0) rx=[0,this.rows-1];
  if (ry && ry.length==0) ry=[0,this.columns-1];
  if (rz && rz.length==0) rz=[0,this.levels-1];
  if (rx && (rx[1]-rx[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (ry && (ry[1]-ry[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (rz && (rz[1]-rz[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
   
  switch (this.dims) {
    case 1:
      for(x=rx[0];x<rx[1];x++) this.data[x]=src[x-rx[0]];
      break;
    case 2:
      if (rx && j != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j)]=src[x-rx[0]];
      else if (i != undefined && ry)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y)]=src[y-ry[0]];
      else todo('copy 2'); 
      break;   
    case 3:
      if (rx && j != undefined && k != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j,k)]=src[x-rx[0]];
      else if (ry && i != undefined && k != undefined)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y,k)]=src[y-ry[0]];
      else if (rz && i != undefined && j != undefined)
        for(z=rz[0];z<=rz[1];z++) 
          this.data[this.index(i,j,z)]=src[z-rz[0]];
      else todo('copy 3');    
      break;
  }
  return this;
}

/** Convert size using a data filter.
 ** TODO: actually only down-sizing is sipported! Need up-sizing, too
 ** The target size must be provided.
 *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
 */

Matrix.prototype.convert = function (a,b,c,d) {
  var i,j,k,l,p,v,m,ni,nj,nk,filter;
  
  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isString(b)) filter=b;
  if (isString(c)) filter=c;
  if (isString(d)) filter=d;
  if (!filter) filter='mean';

  if (!i) throw "Matrix.convert: no target size (number, first dim.)";
  if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";
    
  if (!k) k= {datatype:this.datatype,layout:this.layout}
  else l= {datatype:this.datatype,layout:this.layout}
  m = Matrix(i,j,k,l);
      
  if (typeof filter != 'function') switch (filter) {
    case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
    case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
    case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
    case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
    case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
    case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
    default:          filter = function () { return 0 }
  }
  switch (this.dims) {
    case 1:
      ni=Math.floor(this.columns/m.columns);
      if (ni>0) {
        for(i=0;i<m.columns;i++) {
          v=this.data[i*ni]; 
          for(p=1;p<ni;p++) {
            v=filter(v,this.data[i*ni+p],p,ni);
          }
          m.data[i]=v;
        }
      } else {
        // TODO up-sizing
      }
      break;
    case 2:
      // TBC
      ni=Math.floor(this.rows/m.rows);
      nj=Math.floor(this.columns/m.columns);
      if (ni>0 && nj>0) {
        for(i=0;i<m.rows;i++) {
          for(j=0;j<m.columns;j++) {
            for(p=0;p<ni;p++) {
              for(q=0;q<nj;q++) {
                if (p==0 && q==0) 
                  v=this.get(i*ni,j*nj);
                else
                  v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
              }
            }
            m.set(i,j,v);
          }
        }
      } else {
        // TODO: up-sizing
      }
      break;
  }
  return m;
}


Matrix.prototype.cos = function (v) {
  this.eval(Math.cos);
  return this; 
}

Matrix.prototype.diag = function (v) {
  if (v!=undefined) {
    // set diagonal
    if (this.rows!=this.columns) return;
    for(var i=0;i<this.rows;i++) this.set(i,i,v);
    return this;
  }
  // TODO Vector
  var a = [];
  if (this.rows!=this.columns) return;
  for(var i=0;i<this.rows;i++) a.push(this.get(i,i));
  return a; 
}

Matrix.prototype.dim = function () {
  switch (this.dims) {
    case 1: return [this.columns];
    case 2: return [this.rows,this.columns];
    case 3: return [this.rows,this.columns,this.levels];
  }
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.div = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] /= v.data[i];
    return result;
  } else result.eval(function (x) {return x/v});
  return result; 
}

Matrix.prototype.divide = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)/b);
    case 2: return this.set(a,b,this.get(a,b)/c);
    case 3: return this.set(a,b,c,this.get(a,b,c)/d);
  }
}

Matrix.prototype.error = function (what,where) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.prototype.errorRange = function (what,where) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

// Evaluate all elements x of matrix by applying function f(x)
Matrix.prototype.eval = function (f) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            this.set(i,f(this.get(i)))
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              this.set(i,j,f(this.get(i,j)))
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                this.set(i,j,k,f(this.get(i,j,k)))
          break;
      }
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i]);
  }
  return this;
}

Matrix.prototype.exp = function (v) {
  this.eval(Math.exp);
  return this; 
}

Matrix.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
    switch (this.dims) {
      case 1:
        for(i=0; i < this.columns; i++) 
          this.set(i,valueOrFunction(i.j))
        return this;
      case 2:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            this.set(i,j,valueOrFunction(i,j))
        return this;
      case 3:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            for(k=0; k < this.levels; k++) 
              this.set(i,j,k,valueOrFunction(i,j,k))
        return this;
    }
  } else this.data.fill(valueOrFunction);
  return this;
}

// Flattens a matruix by reducing the dimension
// [level,rows,columns] -> [rows,columns]
// [rows,columns] -> [rows]
Matrix.prototype.flatten = function (flatten) {
  if (!flatten) flatten=function (vl) { return vl.reduce(function (a,b) { return a+b }) };
  switch (this.dims) {
    case 3:
      var mf = Matrix(this.rows,this.columns,{datatype:this.datatype});
      for (var row=0;row<this.rows;row++) {
        for (var col=0;col<this.columns;col++) {
          var vl=[];
          for (var z=0;z<this.levels;z++) {
            vl.push(this.get(row,col,z));
          }
          mf.set(row,col,flatten(vl)/this.levels);
        }
      }
      return mf;
      break;
  }
}
Matrix.prototype.forEach = function (f,linear) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            f.call(this,this.get(i),i)
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              f.call(this,this.get(i,j),i,j)
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                f.call(this,this.get(i,j,k),i,j,k)
          break;
      }
      break;
    default:
      if (linear) for(i=0;i<this.size;i++) {
        f.call(this,this.data[i],i);
      } else {
        switch (this.dims) {
          case 1:
            for(i=0; i < this.columns; i++) 
              f.call(this,this.get(i),i)
            break;
          case 2:
            for(i=0; i < this.rows;i++) 
              for(j=0; j < this.columns; j++) 
                f.call(this,this.get(i,j),i,j)
            break
          case 3:
            for(i=0; i < this.rows;i++) 
              for(j=0; j < this.columns; j++) 
                for(k=0; k < this.levels; k++) 
                  f.call(this,this.get(i,j,k),i,j,k)
            break;
        }      
      }
  }
  return this;
}

// x += delta
Matrix.prototype.incr = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)+b);
    case 2: return this.set(a,b,this.get(a,b)+c);
    case 3: return this.set(a,b,c,this.get(a,b,c)+d);
  }
}

Matrix.prototype.info = function () {
  var o = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    layout:this.layout,
    dims:this.dims,
    dataspace:this.dataspace,
    datatype:this.datatype,
  }
  if (this.rows) o.rows=this.rows;
  if (this.levels) o.levels=this.levels;
  if (this.scaler) o.scaler=this.scaler;
  if (this.complex) o.complex=true;
  return o;
}


Matrix.prototype.isColumnVector = function () {
   return this.columns === 1;
}

Matrix.prototype.isEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isEchelonForm = false;
        checked = true;
      }
    }
    i++;
  }
  return isEchelonForm;
}

Matrix.prototype.isReducedEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isReducedEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isReducedEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isReducedEchelonForm = false;
        checked = true;
      }
    }
    for (var k = j + 1; k < this.rows; k++) {
      if (this.get(i, k) !== 0) {
        isReducedEchelonForm = false;
      }
    }
    i++;
  }
  return isReducedEchelonForm;
}
Matrix.prototype.isRowVector = function () {
   return this.rows === 1;
}

Matrix.prototype.isSquare = function () {
  return this.rows==this.columns
}

Matrix.prototype.isSymmetric = function () {
  if (this.isSquare()) {
        for (var i = 0; i < this.rows; i++) {
          for (var j = 0; j <= i; j++) {
            if (this.get(i, j) !== this.get(j, i)) {
              return false;
            }
          }
        }
        return true;
      }
  return false;
}

/** Iterate over matrix elements
 * Parameter arrays specify iteration ranges, FORALL='*' specifies a target vector range
 * iter(function (@elem,@index,@array))
 * iter(number [],function)
 * iter(number [],number [],function)
 * iter(number [],number [],number [],function)
 * Examples: 
 *  m.iter(FORALL,[],[],f)   <=> for all x-vectors with y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([], FORALL,[],f)  <=> for all y-vectors with x in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([],[],[],f)       <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter(f)                <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *
 *
 */
  
Matrix.prototype.iter = function (a,b,c,d) {
  var func,rx,ry,rz,x,y,z,
      self=this;
  if (isFunction(a)) func=a;
  else if (isFunction(b)) func=b;
  else if (isFunction(c)) func=c;
  else if (isFunction(d)) func=d;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;
  if (isString(a)) rx=a;
  if (isString(b)) ry=b;
  if (isString(c)) rz=c;
  if (!func) throw "Matrx.iter: no function supplied";
  if (!rx && !ry && !rz) // linear iteration over all elements
    return this.data.forEach(func);
  switch (this.dims) {
    case 1: break;
  // TODO
      todo('iter 1')
    case 2: break;
  // TODO
      todo('iter 2')
    case 3:
      if (isArray(rx) && rx.length==0) rx=[0,this.rows];
      if (isArray(ry) && ry.length==0) ry=[0,this.columns];
      if (isArray(rz) && rz.length==0) rz=[0,this.levels];
      if (rz == FORALL) {
        for(x=rx[0];x<rx[1];x++) {
          for(y=ry[0];y<ry[1];y++) {
            func(x,y,this.subMatrixRange(x,y,ALL))
          }
        }
      } else if (rx==FORALL) {
  // TODO
        todo('iter 3.ryx=FORALL')
      
      } else if (ry==FORALL) {
  // TODO
        todo('iter 3.ry=FORALL')
      
      } else {
        // single data cell iteration
  // TODO
        todo('iter 3')
      }
  }
  // TODO
  return this;
}

Matrix.prototype.map = function (f,asArray) {
  var res,i,j,k;
  switch (this.dims) {
    case 1:
      res = Matrix(this.columns,{dtn:asArray?'Array':this.dtn});
      for(j=0;j<this.columns;j++)
        res.set(j,f(this.get(j),j));
      break;
    case 2:
      res = Matrix(this.rows,this.columns,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          res.set(i,j,f(this.get(i,j),i,j));
      break;
    case 3:
      res = Matrix(this.rows,this.columns,this.levels,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          for(k=0;k<this.levels;k++)
            res.set(i,j,k,f(this.get(i,j,k),i,j,k));
      break;
  }
  return res;
}


// Row mapping function
Matrix.prototype.mapRow = function (f) {
  var res=[];
  for(var row=0;row<this.rows;row++) {
    res.push(f(this.getRow(row),row));
  }
  return res;
}

/** Return minimum and maximum value of the matrix
 *
 */
Matrix.prototype.minmax = function () {
  var d0=Number.MAX_VALUE,d1=-Number.MAX_VALUE;
  for (i = 0;i < this.size; i++) {
    d0=Math.min(d0,this.data[i]);
    d1=Math.max(d1,this.data[i]);    
  }
  return { min:d0, max:d1 };
}
Matrix.prototype.max = function () {
  return this.minmax().max
}
Matrix.prototype.min = function () {
  return this.minmax().min
}
Matrix.prototype.mapToArray = function (f) {
  var res = new Array(this.size);
  for(var i=0;i<this.rows;i++)
    for(var j=0;j<this.columns;j++)
      res[i*this.columns+j]=f?f(this.get(i,j),i,j):this.get(i,j);
  return res;
}

Matrix.prototype.mapToArrayArray = function (f) {
  var res = new Array(this.rows);
  for(var i=0;i<this.rows;i++) {
    res[i]=new Array(this.columns);
    for(var j=0;j<this.columns;j++)
      res[i][j]=f?f(this.get(i,j),i,j):this.get(i,j);
  }
  return res;
}

Matrix.prototype.mapToArrayArrayArray = function (f) {
  var res = new Array(this.levels);
  for(var i=0;i<this.levels;i++) {
    res[i]=new Array(this.rows);
    for(var j=0;j<this.rows;j++) {
      res[i][j]=new Array(this.columns);
      for(var k=0;k<this.columns;k++) {
        res[i][j][k]=f?f(this.get(i,j,k),i,j,k):this.get(i,j,k);
      }
    }
  }
  return res;
}

// x *= k
Matrix.prototype.multiply = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)*b);
    case 2: return this.set(a,b,this.get(a,b)*c);
    case 3: return this.set(a,b,c,this.get(a,b,c)*d);
  }
}

Matrix.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Matrix.prototype.mod = function (v) {
  this.eval(function (x) {return x%v});
  return this; 
}

/**
     * Returns the matrix product between this and other
     * @param {Matrix} other
     * @return {Matrix}
     */
Matrix.prototype.mmul = function (other) {
  this.checkMatrixDims(2);
  other = Matrix.checkMatrix(other);
  if (this.columns !== other.rows) {
    // eslint-disable-next-line no-console
    console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
  }

  var m = this.rows;
  var n = this.columns;
  var p = other.columns;

  var result = Matrix(m, p, {dtn:this.dtn});

  var Bcolj = new Array(n);
  for (var j = 0; j < p; j++) {
    for (var k = 0; k < n; k++) {
      Bcolj[k] = other.get(k, j);
    }
    for (var i = 0; i < m; i++) {
      var s = 0;
      for (k = 0; k < n; k++) {
        s += this.get(i, k) * Bcolj[k];
      }
      result.set(i, j, s);
    }
  }
  return result;
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.mul = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] *= v.data[i];
    return result;
  } else result.eval(function (x) {return x*v});
  return result; 
}

Matrix.prototype.neg = function (v) {
  this.eval(function (x) {return -x});
  return this; 
}

Matrix.prototype.prod = function (v) {
  var i,j,k,v = 1;
  // Comp. mode
  switch (this.dtn+this.dims) {
    case 'Array1':
      for (i = 0; i < this.columns; i++) {
          v *= this.data[i];
      }
      break;
    case 'Array2':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          v *= this.data[i][j];
        }
      }
      break;
    case 'Array3':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          for (k = 0; k < this.levels; k++) {
            v *= this.data[i][j][k];
          }
        }
      }
      break;
    default:
      for (i = 0; i < this.size; i++) v *= this.data[i];
  }
  return v;
}

Matrix.prototype.print = function (format) {
  var i,j,k,s='',sep='';
  if (!format) format = '%4.2f';
  switch (this.dims) {
    case 1:
      for(i=0;i<this.columns;i++) {
        if (i!=0) s = s + '\n';
        s = s + sprintf(format,this.get(i)) ;
      }
      break;
    case 2:
      for(i=0;i<this.rows;i++) {
        sep = '';
        if (i!=0) s = s + '\n';
        for (j=0;j<this.columns;j++) {
          s = s + sep + sprintf(format,this.get(i,j)) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<this.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(i=0;i<this.rows;i++) {
          sep = '';
          if (i!=0) s = s + '\n';
          for (j=0;j<this.columns;j++) {
            s = s + sep + sprintf(format,this.get(i,j,k)) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
}

/** Reduce dimension: Linear matrix data reduction applying a function (a,b) -> c to all elements.
 *  Returns a scalar value or any other object accumulated by the supplied function
 */
Matrix.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

// Return array or vector (layout=12: matrix view if !copy)
Matrix.prototype.row = function (index,asVector,copy) {
  this.checkMatrixDims(2);
  this.checkRowIndex(index);
  var row,data,i,j;
  switch (this.dtn) {
    case 'Array':
      if (this.layout==12) {
        if (!asVector)
          return this.data[index];
        else
          return Vector(this.data[index]);
      } else {
        // transposed view
        if (!asVector) {
          row = new Array(this.columns);
          if (this.rows==1) return this.data;
          for (i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
        } else {
          if (this.rows==1) return this.data;
          row= Vector(this.columns,{dtn:this.dtn});
          for (i = 0; i < this.columns; i++) {
            row.set(i, this.get(index, i));
          };
        }  
      }
      break;
    default:
      // With advanced slicing
      if (!asVector) {
        row = new Array(this.columns);
        if (this.rows==1) return this.data.toArray();
        for (i = 0; i < this.columns; i++) {
          row[i] = this.get(index, i);
        }
      } else if (this.layout == 12) {
        if (copy) {
          data = this.data.slice(index*this.columns,(index+1)*this.columns);
          row= Vector({dtn:this.dtn,data:data,columns:this.columns});
        } else {
          row= Vector({dtn:this.dtn,data:this.data,offset:index*this.columns,columns:this.columns});
        }
      } else {
        if (this.rows==1) return this.data;
        row= Vector(this.columns,{dtn:this.dtn});
        for (i = 0; i < this.columns; i++) {
          row.set(i, this.get(index, i));
        };
      }   
  }
  
  return row;
}
Matrix.prototype.getRow=Matrix.prototype.row;

/** resize matrix
** NO: (only modifying meta data - not buffer data)
** YES: interpol/extrapol
 *  TODO: offset
 */
Matrix.prototype.resize = function (options) {
  for(var p in options) {
    switch (p) {
      case 'rows':
      case 'columns':
      case 'levels':
        this[p]=options[p];
        break;
      case 'offset':
        // TODO
        break;
    }
  }
  this.size=this.columns*(this.rows?this.rows:1)*(this.levels?this.levels:1);
  this.length=this.rows?this.rows:this.columns;
  return this
}


Matrix.prototype.reverseRow = function (row) {
  var t,len=this.columns;
  for(var i=0;i<(len/2)|0;i++) {
    t=this.get(row,i);
    this.set(row,i,this.get(row,len-i-1));
    this.set(row,len-i-1,t);
  }
  return this; 
}

/** Scale (and/or adjust offset optionally of) all matrix elements -= offset *= k
 * scale(k)
 * scale(k,inplace:boolean)
 * scale(k,offset)
 * scale(k,offset,inplace:boolean)
 */
 
Matrix.prototype.scale = function (a,b,c) {
  var m,k=1,offset,inplace=false;
  if (isNumber(a)) k=a;
  if (isBoolean(b)) inplace=b;
  else if (isBoolean(c)) inplace=c;
  if (isNumber(b)) offset=b;
  else if (isNumber(c)) offset=c;
  
  m = inplace?this:this.copy();
  if (k!=1) {
    if (offset)
      for(var i=0;i<m.data.length;i++) m.data[i]=(m.data[i]-offset)*k;
    else
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]*k;
  } else if (offset) {
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]-offset;  
  }
  return m;
}

/*
Return a new matrix based on a selection of rows and columns
selection(rowIndices: Array<number>, columnIndices: Array<number>): Matrix
Parameters
rowIndices (Array<number>) The row indices to select. Order matters and an index can be more than once.
columnIndices (Array<number>) The column indices to select. Order matters and an index can be use more than once.
Returns 
Matrix: The new matrix 
*/
Matrix.prototype.selection = function (rowIndices,columnIndices) {
  this.checkMatrixDims(2);
  var newMatrix = Matrix(rowIndices.length,columnIndices.length,{dtn:this.dtn});
  for (var i = 0; i < rowIndices.length; i++) {
    var rowIndex = rowIndices[i];
    for (var j = 0; j < columnIndices.length; j++) {
      var columnIndex = columnIndices[j];
      newMatrix.set(i,j, this.get(rowIndex, columnIndex));
    }
  }
  return newMatrix;
}


// Set a row of the matrix
Matrix.prototype.setRow = function (row,data) {
  data=Matrix.checkArray(data);
  for(var i=0;i<this.columns;i++) {
     this.set(row,i,data[i]); 
  }
}

// Share a matrix (data must be either a sharedarraybuffer or a buffer segment object
Matrix.prototype.__share = function () {
  if (this.block) {
    // Matrix buffer is part of a Shared Memory Segment Buffer (SMS) TODO
    return {
      data : { data : [], block : this.block, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn   : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  } else if (typeof SharedArrayBuffer != 'undefined' && this.data instanceof SharedArrayBuffer) {
    // Browser/Web Worker: Shared Array Buffer
    return {
      data : { data : this.data, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn  : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  } else if (typeof SharedArrayBuffer != 'undefined' && this.data.buffer instanceof SharedArrayBuffer) {
    // Browser/Web Worker: Shared Array Buffer
    return {
      data : { data : this.data.buffer, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn  : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  }
}
// Slice of data in major dimension
Matrix.prototype.slice = function (i,offset) {
  var rows,columns,levels;
  switch (this.dims) {
    case 1:
      return Matrix(this,{columns:i,offset:offset,slice:true});
      break;
    case 2:
    case 3:
      return Matrix(this,{rows:i,offset:offset,slice:true});
      break;
  }
}

Matrix.prototype.sin = function () {
  this.eval(Math.sin);
  return this;
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Matrix.prototype.size = function () {
  return  this.size;
}


// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.sub = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] -= v.data[i];
    return result;
  } else result.eval(function (x) {return x-v});
  return result; 
}


/** Return a sub-matrix (2 dims only)
 *
 */
Matrix.prototype.subMatrix = function (startRow, endRow, startColumn, endColumn) {
  this.checkMatrixDims(2);
  this.checkRange(startRow, endRow, startColumn, endColumn);
  var newMatrix = Matrix(endRow - startRow + 1, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = startRow; i <= endRow; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      newMatrix.set(i - startRow,j - startColumn, this.get(i, j));
    }
  }
  return newMatrix;
}

/** Return a sub-matrix (1-3 dims)
 *
 * rx:row,ry:column,rz?:level
 */
Matrix.prototype.subMatrixRange = function (rx,ry,rz) {
  var i,j,i0,i1,x0,x1,y0,y1,z0,z1,res;
  switch (this.dims) {
    case 1:
      // simple case, return sliced array
      x0=0,x1=this.i-1;
      if (isRange(rx)) x0=rx[0],x1=rx[1];
      else throw "Matrix.subMatrixRange: no range";
      var i0=x0,i1=i0+1+x1;
      return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
    case 2:
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    case 3:
      if ((isAll(rz) || (isRange(rz))) && isNumber(rx) && isNumber(ry) && (Matrix.options.compatLayout?this.layout==123:this.layout==321)) {
        // simple case, return sliced array (1-dim matrix)
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        var i0=this.index(rx,ry,z0),i1=i0+1+z1;
        return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
      } else if (isNumber(rz)) {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=rz;
        res = Matrix(x1-x0+1,y1-y0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            res.set(i-x0,j-y0, this.get(i,j,z0));
        return res;
      } else  {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        if (isNumber(rz)) z0=z1=rz;        
        res = Matrix(x1-x0+1,y1-y0+1,z1-z0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            for(var k=z0;k<=z1;k++)
              res.set(i-x0,j-y0,k-z0,this.get(i,j,k));
        return res;
      }
  }
}

Matrix.prototype.subMatrixRow = function (indices, startColumn, endColumn) {
  this.checkMatrixDims(2);
  if (startColumn === undefined) startColumn = 0;
  if (endColumn === undefined) endColumn = this.columns - 1;
  if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(indices.length, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      if (indices[i] < 0 || indices[i] >= this.rows) {
        throw new RangeError('Row index out of range: '+indices[i]);
      }
      newMatrix.set(i, j - startColumn, this.get(indices[i], j));
    }
  }
  return newMatrix;
}

Matrix.prototype.subMatrixColumn = function (indices, startRow, endRow) {
  this.checkMatrixDims(2);
  if (startRow === undefined) startRow = 0;
  if (endRow === undefined) endRow = this.rows - 1;
  if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(endRow - startRow + 1, indices.length, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startRow; j <= endRow; j++) {
      if (indices[i] < 0 || indices[i] >= this.columns) {
        throw new RangeError('Column index out of range: '+indices[i]);
      }
      newMatrix.set(j - startRow, i, this.get(j, indices[i]));
    }
  }
  return newMatrix;
}


Matrix.prototype.subRowVector = function (vector) {
  this.checkMatrixDims(2);
  vector = this.checkRowVector(vector);
  for (var i = 0; i < this.rows; i++) {
    for (var j = 0; j < this.columns; j++) {
      this.set(i, j, this.get(i, j) - vector[j]);
    }
  }
  return this;
}

Matrix.prototype.setSubMatrix = function (matrix, startRow, startColumn) {
  matrix = this.checkMatrix(matrix);
  this.checkMatrixDims(2);
  matrix.checkMatrixDims(2);
  var endRow = startRow + matrix.rows - 1;
  var endColumn = startColumn + matrix.columns - 1;
  this.checkRange(startRow, endRow, startColumn, endColumn);
  for (var i = 0; i < matrix.rows; i++) {
    for (var j = 0; j < matrix.columns; j++) {
      this.set(startRow + i,startColumn + j) = matrix.get(i, j);
    }
  }
  return this;
}

Matrix.prototype.sum = function (by) {
  var i,j,k,v=0;
  switch (by) {
    case 'row':
      return this.sumByRow();
    case 'column':
      return this.sumByColumn();
    default:
      switch (this.dtn+this.dims) {
        case 'Array1':
          for (i = 0; i < this.columns; i++) {
              v += this.data[i];
          }
          break;
        case 'Array2':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              v += this.data[i][j];
            }
          }
          break;
        case 'Array3':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              for (k = 0; k < this.levels; k++) {
                v += this.data[i][j][k];
              }
            }
          }
          break;
        default:
          for (i = 0; i < this.size; i++) v += this.data[i];
      }
      return v;
  }
}

Matrix.prototype.sumByRow = function () {
  var sum = Matrix.zeros(this.rows, 1);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.sumByColumn = function() {
  var sum = Matrix.zeros(1, this.columns);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.toCsv = function (sep) {
  sep=sep||',';
  switch (this.dims) {
    case 1: return Array.from(this.data).join('\n');
    case 2: return this.mapToArrayArray().map(function (row) {
      return row.join(sep);
    }).join('\n');
  }
}

Matrix.prototype.toArray = function (rx,ry,rz) {
  switch (this.dims) {
    case 1: return Array.from(this.data);
    case 2: return this.mapToArrayArray();
    case 3: return this.mapToArrayArrayArray();
  }
}

Matrix.prototype.toBuffer = function () {
  return this.data.buffer;
}

Matrix.prototype.toJson = function () {
  return JSON.stringify(this.toArray());
}

Matrix.prototype.transpose = function () {
  utils.checkMatrixDims(this,2);
  if (!Matrix.native || this.rows != this.columns || this.dtn != 'Float32Array') {
    var result = Matrix(this.columns, this.rows,{datatype:this.datatype});
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          result.set(j, i, this.get(i, j));
        }
    }
    return result;
  } else if (Matrix.native) {
    /* Native BLAS support */
    var res = Matrix(this.columns,this.rows,{dtn:this.dtn});
    if (this.dtn == 'Float32Array')
      Matrix.native.blas.stran_(Buffer(this.data.buffer),
                                Buffer(res.data.buffer),
                                Matrix.native.intPtr(this.rows),
                                Matrix.native.intPtr(this.columns));
    return res;
  }
}

Matrix.prototype.transposeView = function () {
  utils.checkMatrixDims(this,2);
  var res = Matrix(this,{transpose:true});
  return res;
}

Matrix.ALL=ALL;
Matrix.FOREACH=FOREACH;
Matrix.FORALL=FORALL;
Matrix.utils = utils;

module.exports = Matrix 
};
BundleModuleCode['plugins/math/matrixTA-utils']=function (module,exports,global,process){
// Matrix Utility Functions
// TypedArray version
// Ver. 1.3.1

'use strict';

function checkMatrixDims(matrix, dims) {
  if (matrix.dims != dims) throw new Error('Matrix has not expected dimension '+dims);
}
/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  var max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  var max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns'
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices)
  };
}

function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= matrix.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= matrix.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function getRange(from, to) {
  var arr = new Array(to - from + 1);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = from + i;
  }
  return arr;
}

function sumByRow(matrix) {
  var sum = Matrix.zeros(matrix.rows, 1);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  var sum = Matrix.zeros(1, matrix.columns);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumAll(matrix) {
  var i,j,k,v = 0;
  // Comp. mode
  switch (matrix.dtn) {
    case 'Array':
      for (i = 0; i < matrix.rows; i++) {
        for (j = 0; j < matrix.columns; j++) {
          v += matrix.data[i][j];
        }
      }
      break;
    default:
      for (i = 0; i < matrix.size; i++) v += matrix.data[i];
  }
  return v;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}

function getFilled2DArray(rows,columns,init) {
  var a = Array(rows);
  for(var i = 0;i < rows; i++) {
    a[i]=Array(columns).fill(init)
  }
  return a;
}

function hypotenuse(a, b) {
  var r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}

// function squaredEuclidean(p: number[], q: number[])
function squaredEuclidean(p, q) {
  var d = 0;
  for (var i = 0; i < p.length; i++) {
    d += (p[i] - q[i]) * (p[i] - q[i]);
  }
  return d;
}

// function euclidean(p: number[], q: number[]) 
function euclidean(p, q) {
  return Math.sqrt(squaredEuclidean(p, q));
}

var defaultOptions = {
  distanceFunction: squaredEuclidean
}
// function nearestVector(listVectors: Matrix, vector: number[],  options = defaultOptions)
function nearestVector(
  listVectors,
  vector,
  options
) {
  options=checkOptions(options,{distanceFunction: squaredEuclidean});
  const distanceFunction = checkOption(
    options.distanceFunction, defaultOptions.distanceFunction);
  const similarityFunction = checkOption(
    options.similarityFunction, defaultOptions.similarityFunction);

  let vectorIndex = -1;
  if (typeof similarityFunction === 'function') {
    // maximum similarity
    let maxSim = Number.MIN_VALUE;
    for (let j = 0; j < listVectors.rows; j++) {
      const sim = similarityFunction(vector, listVectors.getRow(j));
      if (sim > maxSim) {
        maxSim = sim;
        vectorIndex = j;
      }
    }
  } else if (typeof distanceFunction === 'function') {
    // minimum distance
    let minDist = Number.MAX_VALUE;
    for (let i = 0; i < listVectors.rows; i++) {
      const dist = distanceFunction(vector, listVectors.getRow(i));
      if (dist < minDist) {
        minDist = dist;
        vectorIndex = i;
      }
    }
  } else {
    throw new Error("A similarity or distance function it's required");
  }

  return vectorIndex;
}

// function findNearestVector(  vectorList: Matrix,  vector: Vector,  options: IOptions = defaultOptions) 
function findNearestVector(
  vectorList,
  vector,
  options
) {
  const index = nearestVector(vectorList, vector, options);
  return vectorList[index];
}

module.exports = {
  checkMatrixDims:checkMatrixDims,
  checkRowIndex:checkRowIndex,
  checkRowVector:checkRowVector,
  checkColumnIndex:checkColumnIndex,
  checkColumnVector:checkColumnVector,
  checkIndices:checkIndices,
  checkRowIndices:checkRowIndices,
  checkColumnIndices:checkColumnIndices,
  checkRange:checkRange,
  euclidean:euclidean,
  findNearestVector:findNearestVector,findNearestVector,
  getFilled2DArray:getFilled2DArray,
  getRange:getRange,
  hypotenuse:hypotenuse,
  nearestVector:nearestVector,nearestVector,
  sumByRow:sumByRow,
  sumByColumn:sumByColumn,
  sumAll:sumAll,
  squaredEuclidean:squaredEuclidean,
}
};
BundleModuleCode['plugins/math/vectorTA']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.6.1X
 **
 **    $INFO:
 ** 
 **   Vector module supporting typed and generic arrays.
 **   
 ** 
 **    $ENDOFINFO
 */

var isArray = Utils.isArray,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isString = Utils.isString,
    TypedArrayOfName = Utils.TypedArrayOfName;

/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

Object.addProperty(Array,'get', function (i) {
  return this[i];
})
Object.addProperty(Array,'set', function (a,b) {
  this[a]=b;
})

  
Object.addProperty(Array,'print', function (format) {
  var i,s='',sep='', columns=this.length,complex=isArray(this[0]);
  if (!format) format = '%4.2f';
  for(i=0;i<columns;i++) {
    if (i!=0) s = s + '\n';
    if (complex) 
      s = s + sprintf(format,this[i][0]) + ',' +
              sprintf(format,this[i][1]);
    else
      s = s + sprintf(format,this[i]) ;
  }    
  return s;
})


Object.addProperty(Array,'info', function () {
  return {
    dtn:'Array',
    size:this.length,
    columns:this.length,
    offset:0,
  }
})

Object.addProperty(Array,'unique', function () {
  var array=this;
  var length = array ? array.length : 0;
  function baseUniq(array) {
    var index = -1,
        length = array.length,
        seen,
        result = [];

    seen = result;
    outer:
    while (++index < length) {
      var value = array[index];
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === value) {
          continue outer;
        }
      }
      result.push(value);
    }
    return result;
  }
  if (!length) {
    return [];
  }
  return baseUniq(array);
})

Object.addProperty(Array,'min', function () {
  return Math.min.apply(null, this) 
})

Object.addProperty(Array,'max', function () {
  return Math.max.apply(null, this) 
})


Object.addProperty(Int16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Int32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float64Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})

/********************* STRING Conversion ******************************/
function toUTF8Array(str) {
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 
                      0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            charcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)
            utf8.push(0xf0 | (charcode >>18), 
                      0x80 | ((charcode>>12) & 0x3f), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}

function fromUTF8Array(data) { // array of bytes
    var str = '', i;
    for (i = 0; i < data.length; i++) {
        var value = data[i];
        if (value < 0x80) {
            str += String.fromCharCode(value);
        } else if (value > 0xBF && value < 0xE0) {
            str += String.fromCharCode((value & 0x1F) << 6 | data[i + 1] & 0x3F);
            i += 1;
        } else if (value > 0xDF && value < 0xF0) {
            str += String.fromCharCode((value & 0x0F) << 12 | (data[i + 1] & 0x3F) << 6 | data[i + 2] & 0x3F);
            i += 2;
        } else {
            // surrogate pair
            var charCode = ((value & 0x07) << 18 | (data[i + 1] & 0x3F) << 12 | (data[i + 2] & 0x3F) << 6 | data[i + 3] & 0x3F) - 0x010000;

            str += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00); 
            i += 3;
        }
    }
    return str;
}

var complex = {
  //-------------------------------------------------
  // Add two complex numbers
  //-------------------------------------------------
  add : function (a, b)
  {
      return [a[0] + b[0], a[1] + b[1]];
  },

  //-------------------------------------------------
  // Subtract two complex numbers
  //-------------------------------------------------
  subtract : function (a, b)
  {
      return [a[0] - b[0], a[1] - b[1]];
  },

  //-------------------------------------------------
  // Multiply two complex numbers
  //
  // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
  //-------------------------------------------------
  multiply : function (a, b) 
  {
      return [(a[0] * b[0] - a[1] * b[1]), 
              (a[0] * b[1] + a[1] * b[0])];
  },

  //-------------------------------------------------
  // Calculate |a + bi|
  //
  // sqrt(a*a + b*b)
  //-------------------------------------------------
  magnitude : function (offset,c) 
  {
      return Math.sqrt(c[offset]*c[offset] + c[offset+1]*c[offset+1]); 
  },
  
  phase : function (offset,c) 
  {
      return c[offset]!=0?Math.atan(c[offset+1]/c[offset])*180/Math.PI:(c[offset+1]>0?90:-90); 
  }

}

/*********** VECTOR ************/
function Vector(a,b) {
  var self = this;
  var i,columns,size,offset=0,dim=1,dtn,dt=Vector.options.dt,data;
  
  if (!(this instanceof Vector)) return new Vector(a,b);
  var options=isObject(b)?b:{};
  this.tag='VectorTA';
  
  if (isNumber(a)) {
    // Create a new empty vector (rows=1)
    columns=a;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    size=columns;
    if (options.complex) size *=2;
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(size);
  } else if (isArray(a)) {
    size=columns=a.length;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isObject(a)) {
    // partial object
    columns=a.columns;
    size=a.size||columns;
    scale=options.scale;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && a.dtn != options.dtn) {
      // convert dtn
      if (isArray(a.data) && !scale)
        data=new dt(a.data);
      else {
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      }
      dtn=options.dtn;
    } else {
      dtn=a.dtn;
      data=a.data;
      offset=a.offset;
    }
    if (a.scale) this.scale=a.scale;
    if (a.complex) this.complex=a.complex;
  } else if (isString(a)) {
    columns=a.length;
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(toUTF8Array(a));
  }
  
  this.columns=columns;
  this.size=this.length=size;
  this.layout=1;
  this.data=data;
  this.dims=dim;
  this.offset=offset;
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  this.dtn=dtn||dt.name;
  
  if (this.dtn=='Array') this._arrayFix();

  this.__constructor__='Math.VectorTA';
}
Vector.options = {
  dt : Float32Array,
  dtn : 'Float32Array'
}

/********* STATIC MEMBERS *********/
Vector.abs = function (m) {
  return Vector.clone(m).abs();
}

Vector.add = function (m,v) {
  return Vector.clone(m).add(v);
}

Vector.clone = function (src) {
  return Vector(src);
}

Vector.checkVector = function (o) {
  if (o instanceof Vector) return o;
  else return Vector(o);
}

Vector.cos = function (m) {
  return Vector.clone(m).cos();
}

Vector.div = function (m,v) {
  return Vector.clone(m).div(v);
}

Vector.empty = function (columns) {
  return Vector(columns);
}

Vector.exp = function (m) {
  return Vector.clone(m).exp();
}

Vector.init = function (columns,valueOrCallback) {
  return Vector(columns).fill(valueOrCallback);
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.max =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]= Math.max(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.min =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]=Math.min(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.mod = function (m,v) {
  return Vector.clone(m).mod(v);
}

Vector.mul = function (m,v) {
  return Vector.clone(m).mul(v);
}

Vector.neg = function (m) {
  return Vector.clone(m).neg();
}

Vector.ones = function (columns) {
  return Vector(columns).fill(1);
}

Vector.rand = function (columns, rng, options) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns,options).fill(function () {
    return rng();
  });
}
Vector.Random=function (columns,options) {
  return Vector.rand(columns,options&&options.rng,options)
};
Vector.randInt = function (columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}

Vector.sin = function (m) {
  return Vector.clone(m).sin();
}

Vector.sub = function (m,v) {
  return Vector.clone(m).sub(v);
}

Vector.zero = function (columns) {
  return Vector(columns).fill(0);
}



/********* INSTANCE MEMBERS *********/
// Fix some prototype methods for generic array data content
Vector.prototype._arrayFix = function () {
  var self=this;
  this.get=function (column)   { return self.data[self.offset+column] };
  this.set=function (column,v) { self.data[self.offset+column]=v };
}

Vector.prototype.abs = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.abs(this.data[i]);
  return this; 
}

Vector.prototype.add = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]+=v;
  return this; 
}

Vector.prototype.apply = function (f) {
  for(var i=0; i < this.columns; i++) 
    this.set(i,f.call(this,i))
  return this;
}

Vector.prototype.clone = function () {
  return Vector(this);
}

Vector.prototype.cos = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.cos(this.data[i]);
  return this; 
}

Vector.prototype.div = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]/=v;
  return this; 
}

Vector.prototype.divide = function (column,k) {
  return this.data[column] /= k;
}

// Evaluate all elements x of matrix by applying function f(x)
Vector.prototype.eval = function (f) {
  var i;
  switch (this.dtn) {
    case 'Array':
      for(i=0; i < this.columns; i++) 
        this.set(i,f(this.get(i)))
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i],i);
  }
  return this;
}

Vector.prototype.exp = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.exp(this.data[i]);
  return this; 
}

Vector.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
      for(var i=0;i<this.columns;i++) {
        this.data[i]=valueOrFunction(i);
      } 
  } else this.data.fill(valueOrFunction);
  return this;
}

Vector.prototype.filter = function (f,asArray) {
  var i,j=0,res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(i=0;i<this.columns;i++) {
    v=f(this.data[i],i);
    if (v) res.data[j]=this.data[i],j++;
  }
  return j<this.columns?res.slice(j):res;
}

Vector.prototype.get = function (column) {
  return this.data[this.offset+column];
}

Vector.prototype.imag = function (i) {
  if (this.complex) return this.get(i*2+1);
}

Vector.prototype.incr = function (column,delta) {
  return this.data[column] += delta;
}

Vector.prototype.info = function () {
  var i = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    offset:this.offset,
  }
  if (this.scaler) i.scaler=this.scaler;
  if (this.complex) i.complex=true;
  return i;
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.prototype.magnitude = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.magnitude(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.map = function (f,asArray) {
  var res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(var i=0;i<this.columns;i++)
    res.data[i]=f(this.data[i],i);
  return res;
}

Vector.prototype.multiply = function (column,k) {
  return this.data[column] *= k;
}

Vector.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Vector.prototype.mod = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=this.data[i]%v;
  return this; 
}

Vector.prototype.mul = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]*=v;
  return this; 
}

Vector.prototype.neg = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]=-this.data[i];
  return this; 
}

Vector.prototype.pad = function (n,v,left) { 
  var ext = Vector.init(n,v); 
  if (!left) ext.data.set(this.data);
  else ext.data.set(this.data,this.length);
  return ext;
}

Vector.prototype.phase = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.phase(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.prod = function (v) {
  var i,j,v = 1;
  for (i = 0; i < this.size; i++) v *= this.data[i];
  return v;
}

Vector.prototype.print = function (format,transpose) {
  var j, s='';
  if (!format) format = '%4.2f';
  if (!this.complex)
    for(j=0;j<this.columns;j++) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + sprintf(format,this.data[j]) ;
    }
  else
    for(j=0;j<this.columns;j=j+2) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + '('+sprintf(format,this.data[j])+','+sprintf(format,this.data[j+1])+')' ;
    }
  
  return s;
}

Vector.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

Vector.prototype.real = function (i) {
  if (this.complex) return this.get(i*2);
}

Vector.prototype.resize = function (options) {
  if ((options.offset && (options.columns+options.offset) > this.columns) ||
      !options.columns) throw new Error('Vecotr.resize: invalid argument(s)');
  this.columns=options.columns;
  if (options.offset) this.offset=options.offset;
  this.size=this.length=this.columns;
  if (options.slice) 
    this.data=options.offset?this.data.slice(options.offset,options.columns+offset):
                             this.data.slice(0,options.columns);
  return this;
}

Vector.prototype.set = function (column,val) {
  this.data[this.offset+column]=val;
  return this;
}

Vector.prototype.sin = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.sin(this.data[i]);
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Vector.prototype.size = function () {
  return  this.size;
}

/** Return new vecotr with sliced data
 *
 */
Vector.prototype.slice = function (columns,offset) {
  return Vector(this,{columns:columns,offset:offset,slice:true});
}

Vector.prototype.sub = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]-=v;
  return this; 
}

Vector.prototype.subRange = function (columns,offset) {
  offset=checkOption(offset,0);
  var res=Vector({columns:columns,data:this.data.slice(offset,columns+offset),dtn:this.dtn});
  return res;
}

Vector.prototype.sum = function () {
  var sum=0;
  for(var i=0;i<this.size;i++) sum += this.data[i];
  return sum
}

Vector.prototype.toArray = function () {
  if (!this.complex) return Array.prototype.slice.call(this.data);
}

module.exports = Vector;
};
BundleModuleCode['plugins/math/matrixTA-EVD']=function (module,exports,global,process){
// Matrix EigenvalueDecomposition
// TypedArray version 
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function EigenvalueDecomposition(matrix, options) {
  if (!(this instanceof EigenvalueDecomposition)) return new EigenvalueDecomposition(matrix,options);
  options=checkOptions(options);
  var assumeSymmetric = checkOption(options.assumeSymmetric,false);

  matrix = Matrix.checkMatrix(matrix);
  if (!matrix.isSquare()) {
    throw new Error('EigenvalueDecomposition: Matrix is not a square matrix');
  }

  var n = matrix.columns;
  var V = Matrix(n, n);
  var d = new Array(n);
  var e = new Array(n);
  var value = matrix;
  var i, j;

  var isSymmetric = false;
  if (assumeSymmetric) {
    isSymmetric = true;
  } else {
    isSymmetric = matrix.isSymmetric();
  }

  if (isSymmetric) {
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        V.set(i,j, value.get(i, j));
      }
    }
    tred2(n, e, d, V);
    tql2(n, e, d, V);
  } else {
    var H = Matrix(n, n);
    var ort = new Array(n);
    for (j = 0; j < n; j++) {
      for (i = 0; i < n; i++) {
        H.set(i,j,  value.get(i, j));
      }
    }
    orthes(n, H, ort, V);
    hqr2(n, e, d, V, H);
  }

  this.n = n;
  this.e = e;
  this.d = d;
  this.V = V;
}

EigenvalueDecomposition.prototype = {
  /**
   *
   * @return {Array<number>}
   */
  get realEigenvalues() {
    return this.d;
  },

  /**
   *
   * @return {Array<number>}
   */
  get imaginaryEigenvalues() {
    return this.e;
  },

  /**
   *
   * @return {Matrix}
   */
  get eigenvectorMatrix() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    var n = this.n;
    var e = this.e;
    var d = this.d;
    var X = new Matrix(n, n);
    var i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i,j,0);
      }
      X.set(i,i,d[i]);
      if (e[i] > 0) {
        X.set(i,i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i,i - 1,e[i]);
      }
    }
    return X;
  },
}

function tred2(n, e, d, V) {
  var f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1,j);
        V.set(i,j, 0);
        V.set(j,i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j,i,f);
        g = e[j] + V.get(j,j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k,j) * d[k];
          e[k] += V.get(k,j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.incr(k,j, -(f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1,j);
        V.set(i,j,0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1,i, V.get(i,i));
    V.set(i,i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k,i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k,i + 1) * V.get(k,j);
        }
        for (k = 0; k <= i; k++) {
          V.incr(k,j, -(g * d[k]));
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k,i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
    V.set(n - 1,j, 0);
  }

  V.set(n - 1,n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  var f = 0;
  var tst1 = 0;
  var eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      iter = 0;
      do {
        iter = iter + 1;

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k,i + 1);
            V.set(k,i + 1, s * V.get(k,i) + c * h);
            V.set(k,i, c * V.get(k,i) - s * h);
          }
        }

        p = -s * s2 * c3 * el1 * e[l] / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j,i);
        V.set(j,i, V.get(j,k));
        V.set(j,k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  var low = 0;
  var high = n - 1;
  var f, g, h, i, j, m;
  var scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i,m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i,m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i,j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.incr(i,j, -(f * ort[i]));
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i,j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.incr(i,j, -(f * ort[j]));
        }
      }

      ort[m] = scale * ort[m];
      H.set(m,m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i,j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m,m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i,m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i,j);
        }

        g = g / ort[m] / H.get(m,m - 1);
        for (i = m; i <= high; i++) {
          V.incr(i,j, g * ort[i]);
        }
      }
    }
  }
}


function hqr2(nn, e, d, V, H) {
  var n = nn - 1;
  var low = 0;
  var high = nn - 1;
  var eps = Number.EPSILON;
  var exshift = 0;
  var norm = 0;
  var p = 0;
  var q = 0;
  var r = 0;
  var s = 0;
  var z = 0;
  var iter = 0;
  var i, j, k, l, m, t, w, x, y;
  var ra, sa, vr, vi;
  var notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i,i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i,j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1,l - 1)) + Math.abs(H.get(l,l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l,l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.incr(n,n,exshift);
      d[n] = H.get(n,n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n,n - 1) * H.get(n - 1,n);
      p = (H.get(n - 1,n - 1) - H.get(n,n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.incr(n,n,exshift);
      H.incr(n - 1,n - 1,exshift);
      x = H.get(n,n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n,n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1,j);
          H.set(n - 1,j, q * z + p * H.get(n,j));
          H.set(n,j, q * H.get(n,j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i,n - 1);
          H.set(i,n - 1, q * z + p * H.get(i,n));
          H.set(i,n, q * H.get(i,n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i,n - 1);
          V.set(i,n - 1, q * z + p * V.get(i,n));
          V.set(i,n,  q * V.get(i,n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n,n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1,n - 1);
        w = H.get(n,n - 1) * H.get(n - 1,n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.incr(i,i, -x);
        }
        s = Math.abs(H.get(n,n - 1)) + Math.abs(H.get(n - 1,n - 2));
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.incr(i,i, -s);
          }
          exshift += s;
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m,m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1,m) + H.get(m,m + 1);
        q = H.get(m + 1,m + 1) - z - r - s;
        r = H.get(m + 2,m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m,m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1,m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1,m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i,i - 2, 0);
        if (i > m + 2) {
          H.set(i,i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k,k - 1);
          q = H.get(k + 1,k - 1);
          r = notlast ? H.get(k + 2,k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k,k - 1, -s * x);
          } else if (l !== m) {
            H.set(k,k - 1, -H.get(k,k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k,j) + q * H.get(k + 1,j);
            if (notlast) {
              p = p + r * H.get(k + 2,j);
              H.incr(k + 2,j, -(p * z));
            }

            H.incr(k,j, -(p * x));
            H.incr(k + 1,j, -(p * y));
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i,k) + y * H.get(i,k + 1);
            if (notlast) {
              p = p + z * H.get(i,k + 2);
              H.incr(i,k + 2, -(p * r));
            }

            H.incr(i,k, -p);
            H.incr(i,k + 1, -(p * q));
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i,k) + y * V.get(i,k + 1);
            if (notlast) {
              p = p + z * V.get(i,k + 2);
              V.incr(i,k + 2 , -(p * r));
            }

            V.incr(i,k,-p);
            V.incr(i,k + 1,-(p * q));
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n,n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i,i, -p);
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i,j) * H.get(j,n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i,n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i,n, t);
            H.set(i + 1,n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z);
          }

          t = Math.abs(H.get(i,n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n, t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n,n - 1)) > Math.abs(H.get(n - 1,n))) {
        H.set(n - 1,n - 1, q / H.get(n,n - 1));
        H.set(n - 1,n, -(H.get(n,n) - p) / H.get(n,n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1,n), H.get(n - 1,n - 1) - p, q);
        H.set(n - 1,n - 1, cdivres[0]);
        H.set(n - 1,n,  cdivres[1]);
      }

      H.set(n,n - 1,  0);
      H.set(n,n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i,j) * H.get(j,n - 1);
          sa = sa + H.get(i,j) * H.get(j,n);
        }

        w = H.get(i,i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi
            );
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(i + 1,n - 1,(-ra - w * H.get(i,n - 1) + q * H.get(i,n)) / x);
              H.set(i + 1,n, (-sa - w * H.get(i,n) - q * H.get(i,n - 1)) / x);
            } else {
              cdivres = cdiv(-r - y * H.get(i,n - 1), -s - y * H.get(i,n), z, q);
              H.set(i + 1,n - 1, cdivres[0]);
              H.set(i + 1,n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i,n - 1)), Math.abs(H.get(i,n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n - 1, t);
              H.divide(j,n, t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i,j,  H.get(i,j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i,k) * H.get(k,j);
      }
      V.set(i,j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  var r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}

module.exports = EigenvalueDecomposition
};
BundleModuleCode['plugins/math/matrixTA-SVD']=function (module,exports,global,process){
// Matrix SingularValueDecomposition
// TypedArray version
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function SingularValueDecomposition(matrix, options) {
  if (!(this instanceof SingularValueDecomposition)) return new SingularValueDecomposition(matrix,options);
  options=checkOptions(options);
  var value = Matrix.checkMatrix(matrix);

  var m = value.rows;
  var n = value.columns;

  var computeLeftSingularVectors = checkOption(options.computeLeftSingularVectors,true)
  var computeRightSingularVectors = checkOption(options.computeRightSingularVectors,true)
  var autoTranspose = checkOption(options.autoTranspose,false)

  var wantu = Boolean(computeLeftSingularVectors);
  var wantv = Boolean(computeRightSingularVectors);

  var swapped = false;
  var a;
  if (m < n) {
    if (!autoTranspose) {
      a = value.clone();
      // eslint-disable-next-line no-console
      console.warn(
        'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
      );
    } else {    
      a = value.transpose();
      m = a.rows;
      n = a.columns;
      swapped = true;
      var aux = wantu;
      wantu = wantv;
      wantv = aux;
    }
  } else {
    a = value.clone();
  }

  var nu = Math.min(m, n);
  var ni = Math.min(m + 1, n);
  var s = new Array(ni);
  var U = Matrix(m, nu, {dtn:value.dtn}); 
  var V = Matrix(n, n,  {dtn:value.dtn});  

  var e = new Array(n);
  var work = new Array(m);

  var si = new Array(ni);
  for (var i = 0; i < ni; i++) si[i] = i;

  var nct = Math.min(m - 1, n);
  var nrt = Math.max(0, Math.min(n - 2, m));
  var mrc = Math.max(nct, nrt);
  
  for (var k = 0; k < mrc; k++) {
    if (k < nct) {
      s[k] = 0;
      for (var i = k; i < m; i++) {
        s[k] = hypotenuse(s[k], a.get(i,k));
      }
      if (s[k] !== 0) {
        if (a.get(k,k) < 0) {
          s[k] = -s[k];
        }
        for (var i = k; i < m; i++) {
          a.divide(i,k,s[k]);
        }
        a.incr(k,k,1);
      }
      s[k] = -s[k];
    }

    for (var j = k + 1; j < n; j++) {
      if (k < nct && s[k] !== 0) {
        var t = 0;
        for (var i = k; i < m; i++) {
          t += a.get(i,k) * a.get(i,j);
        }
        t = -t / a.get(k,k);
        for (var i = k; i < m; i++) {
          a.incr(i,j, t * a.get(i,k));
        }
      }
      e[j] = a.get(k,j);
    }
    
    if (wantu && k < nct) {
      for (var i = k; i < m; i++) {
        U.set(i,k, a.get(i,k));
      }
    }
    
    if (k < nrt) {
      e[k] = 0;
      for (var i = k + 1; i < n; i++) {
        e[k] = hypotenuse(e[k], e[i]);
      }
      if (e[k] !== 0) {
        if (e[k + 1] < 0) {
          e[k] = 0 - e[k];
        }
        for (var i = k + 1; i < n; i++) {
          e[i] /= e[k];
        }
        e[k + 1] += 1;
      }
      e[k] = -e[k];
      if (k + 1 < m && e[k] !== 0) {
        for (var i = k + 1; i < m; i++) {
          work[i] = 0;
        }
        for (var i = k + 1; i < m; i++) {
          for (var j = k + 1; j < n; j++) {
            work[i] += e[j] * a.get(i,j);
          }
        }
        for (var j = k + 1; j < n; j++) {
          var t = -e[j] / e[k + 1];
          for (var i = k + 1; i < m; i++) {
            a.incr(i,j, t * work[i]);
          }
        }
      }
      if (wantv) {
        for (var i = k + 1; i < n; i++) {
          V.set(i,k, e[i]);
        }
      }
    }
  }

  var p = Math.min(n, m + 1);
  if (nct < n) {
    s[nct] = a.get(nct,nct);
  }
  if (m < p) {
    s[p - 1] = 0;
  }
  if (nrt + 1 < p) {
    e[nrt] = a.get(nrt,p - 1);
  }
  e[p - 1] = 0;

  if (wantu) {
    for (var j = nct; j < nu; j++) {
      for (var i = 0; i < m; i++) {
        U.set(i,j, 0);
      }
      U.set(j,j, 1);
    }
    for (var k = nct - 1; k >= 0; k--) {
      if (s[k] !== 0) {
        for (var j = k + 1; j < nu; j++) {
          var t = 0;
          for (var i = k; i < m; i++) {
            t += U.get(i,k) * U.get(i,j);
          }
          t = -t / U.get(k,k);
          for (var i = k; i < m; i++) {
            U.incr(i,j, t * U.get(i,k));
          }
        }
        for (var i = k; i < m; i++) {
          U.set(i,k, -U.get(i,k));
        }
        U.incr(k,k,1); // = 1 + U[k][k];
        for (var i = 0; i < k - 1; i++) {
          U.set(i,k,0);
        }
      } else {
        for (var i = 0; i < m; i++) {
          U.set(i,k,0);
        }
        U.set(k,k,1);
      }
    }
  }

  if (wantv) {
    for (var k = n - 1; k >= 0; k--) {
      if (k < nrt && e[k] !== 0) {
        for (var j = k + 1; j < n; j++) {
          var t = 0;
          for (var i = k + 1; i < n; i++) {
            t += V.get(i,k) * V.get(i,j);
          }
          t = -t / V.get(k + 1,k);
          for (var i = k + 1; i < n; i++) {
            V.incr(i,j, t * V.get(i,k));
          }
        }
      }
      for (var i = 0; i < n; i++) {
        V.set(i,k,0);
      }
      V.set(k,k, 1);
    }
  }
  
  var pp = p - 1;
  var iter = 0;
  var eps = Number.EPSILON;
  
  while (p > 0) {
    var k, kase;
    for (k = p - 2; k >= -1; k--) {
      if (k === -1) {
        break;
      }
      const alpha =
        Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
      if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
        e[k] = 0;
        break;
      }
    }
    if (k === p - 2) {
      kase = 4;
    } else {
      var ks;
      for (ks = p - 1; ks >= k; ks--) {
        if (ks === k) {
          break;
        }
        var t =
          (ks !== p ? Math.abs(e[ks]) : 0) +
          (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
        if (Math.abs(s[ks]) <= eps * t) {
          s[ks] = 0;
          break;
        }
      }
      if (ks === k) {
        kase = 3;
      } else if (ks === p - 1) {
        kase = 1;
      } else {
        kase = 2;
        k = ks;
      }
    }

    k++;

    switch (kase) {
      case 1: {
        var f = e[p - 2];
        e[p - 2] = 0;
        for (var j = p - 2; j >= k; j--) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          if (j !== k) {
            f = -sn * e[j - 1];
            e[j - 1] = cs * e[j - 1];
          }
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,p - 1);
              V,set(i,p - 1, -sn * V.get(i,j) + cs * V.get(i,p - 1));
              V.set(i,j, t);
            }
          }
        }
        break;
      }
      case 2: {
        var f = e[k - 1];
        e[k - 1] = 0;
        for (var j = k; j < p; j++) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          f = -sn * e[j];
          e[j] = cs * e[j];
          if (wantu) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U[i][k - 1];
              U.set(i,k - 1, -sn * U.get(i,j) + cs * U.get(i,k - 1));
              U.set(i,j,t);
            }
          }
        }
        break;
      }
      case 3: {
        const scale = Math.max(
          Math.abs(s[p - 1]),
          Math.abs(s[p - 2]),
          Math.abs(e[p - 2]),
          Math.abs(s[k]),
          Math.abs(e[k])
        );
        const sp = s[p - 1] / scale;
        const spm1 = s[p - 2] / scale;
        const epm1 = e[p - 2] / scale;
        const sk = s[k] / scale;
        const ek = e[k] / scale;
        const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
        const c = sp * epm1 * (sp * epm1);
        var shift = 0;
        if (b !== 0 || c !== 0) {
          if (b < 0) {
            shift = 0 - Math.sqrt(b * b + c);
          } else {
            shift = Math.sqrt(b * b + c);
          }
          shift = c / (b + shift);
        }
        var f = (sk + sp) * (sk - sp) + shift;
        var g = sk * ek;
        for (var j = k; j < p - 1; j++) {
          var t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          var cs = f / t;
          var sn = g / t;
          if (j !== k) {
            e[j - 1] = t;
          }
          f = cs * s[j] + sn * e[j];
          e[j] = cs * e[j] - sn * s[j];
          g = sn * s[j + 1];
          s[j + 1] = cs * s[j + 1];
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,j + 1);
              V.set(i,j + 1, -sn * V.get(i,j) + cs * V.get(i,j + 1));
              V.set(i,j, t);
            }
          }
          t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          cs = f / t;
          sn = g / t;
          s[j] = t;
          f = cs * e[j] + sn * s[j + 1];
          s[j + 1] = -sn * e[j] + cs * s[j + 1];
          g = sn * e[j + 1];
          e[j + 1] = cs * e[j + 1];
          if (wantu && j < m - 1) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U.get(i,j + 1);
              U.set(i,j + 1,  -sn * U.get(i,j) + cs * U.get(i,j + 1));
              U.set(i,j, t);
            }
          }
        }
        e[p - 2] = f;
        iter = iter + 1;
        break;
      }
      case 4: {
        if (s[k] <= 0) {
          s[k] = s[k] < 0 ? -s[k] : 0;
          if (wantv) {
            for (var i = 0; i <= pp; i++) {
              V.set(i,k, -V.get(i,k));
            }
          }
        }
        while (k < pp) {
          if (s[k] >= s[k + 1]) {
            break;
          }
          var t = s[k];
          s[k] = s[k + 1];
          s[k + 1] = t;
          if (wantv && k < n - 1) {
            for (var i = 0; i < n; i++) {
              t = V.get(i,k + 1);
              V.set(i,k + 1, V.get(i,k));
              V.set(i,k, t);
            }
          }
          if (wantu && k < m - 1) {
            for (var i = 0; i < m; i++) {
              t = U.get(i,k + 1);
              U.set(i,k + 1,  U.get(i,k));
              U.set(i,k, t);
            }
          }
          k++;
        }
        iter = 0;
        p--;
        break;
      }
      // no default
    }
  }

  if (swapped) {
    var tmp = V;
    V = U;
    U = tmp;
  }

  this.m = m;
  this.n = n;
  this.s = s;
  this.U = U;
  this.V = V;

    
}

SingularValueDecomposition.prototype = {
  /**
   *
   * @return {number}
   */
  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  },

  /**
   *
   * @return {number}
   */
  get norm2() {
    return this.s[0];
  },

  /**
   *
   * @return {number}
   */
  get rank() {
    var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    var r = 0;
    var s = this.s;
    for (var i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  },

  /**
   *
   * @return {Array<number>}
   */
  get diagonal() {
    return this.s;
  },

  /**
   *
   * @return {number}
   */
  get threshold() {
    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
  },

  /**
   *
   * @return {Matrix}
   */
  get leftSingularVectors() {
    if (!Matrix.isMatrix(this.U)) {
      this.U = new Matrix(this.U);
    }
    return this.U;
  },

  /**
   *
   * @return {Matrix}
   */
  get rightSingularVectors() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    return Matrix.diag(this.s);
  }
}
  /**
   * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
   * var svd = SingularValueDecomposition(A);
   * var x = svd.solve(b);
   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
   * @return {Matrix} - The vector x
   */
SingularValueDecomposition.prototype.solve = function(value) {
  var Y = value;
  var e = this.threshold;
  var scols = this.s.length;
  var Ls = Matrix.zeros(scols, scols);

  for (var i = 0; i < scols; i++) {
    if (Math.abs(this.s[i]) <= e) {
      Ls.set(i,i, 0);
    } else {
      Ls.set(i,i, 1 / this.s[i]);
    }
  }

  var U = this.U;
  var V = this.rightSingularVectors;

  var VL = V.mmul(Ls);
  var vrows = V.rows;
  var urows = U.length;
  var VLU = Matrix.zeros(vrows, urows);

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < scols; k++) {
        sum += VL.get(i,k) * U.get(j,k);
      }
      VLU.set(i,j, sum);
    }
  }

  return VLU.mmul(Y);
}

  /**
   *
   * @param {Array<number>} value
   * @return {Matrix}
   */
SingularValueDecomposition.prototype.solveForDiagonal = function (value) {
  return this.solve(Matrix.diag(value));
}

  /**
   * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
   * var svd = SingularValueDecomposition(A);
   * var inverseA = svd.inverse();
   * @return {Matrix} - The approximation of the inverse of the matrix
   */
SingularValueDecomposition.prototype.inverse = function () {
  var V = this.V;
  var e = this.threshold;
  var vrows = V.rows;
  var vcols = V.columns;
  var X = Matrix(vrows, this.s.length, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < vcols; j++) {
      if (Math.abs(this.s[j]) > e) {
        X.set(i,j, V.get(i,j) / this.s[j]);
      } else {
        X.set(i,j, 0);
      }
    }
  }

  var U = this.U;

  var urows = U.rows;
  var ucols = U.columns;
  var Y = Matrix(vrows, urows, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < ucols; k++) {
        sum += X.get(i,k) * U.get(j,k);
      }
      Y.set(i,j, sum);
    }
  }

  return Y;
}

module.exports = SingularValueDecomposition;
};
BundleModuleCode['plugins/math/matrix']=function (module,exports,global,process){
/* Matrix array objects
** Version 1.3.4
*/
var version = "1.4.1"
var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;

// elements:[rows,columns,levels] (3D not supported by methods)
function Matrix(elements,options,aux) {
  if (!(this instanceof Matrix)) return new Matrix(elements,options,aux);
  options=options||{};
  this.tag='Matrix';
  var space=[];
  if (Utils.isNumber(elements)) space.push(elements);
  if (Utils.isNumber(options)) space.push(options);  
  if (Utils.isNumber(aux)) space.unshift(aux); // !!!
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.data=Array(space[0]).fill(0);
    if (space.length>1) for(var i=0;i<space[0];i++) this.data[i]=Array(space[1]).fill(0);
    if (space.length>2) for(var i=0;i<space[0];i++) 
                          for(var j=0;j<space[1];j++) this.data[i][j]=Array(space[2]).fill(0);
    this.dims=space.length;
    
  } else  
    this.setData(elements,options.reference);
  this.__constructor__='Math.Matrix';
};

Matrix.version=version;

Matrix.create = Matrix
// var $M = Matrix.create;

Matrix.isMatrix = function (o) {
  return o instanceof Matrix
}

Matrix.I = function(n) {
  var els = [], i = n, j;
  while (i--) { j = n;
    els[i] = [];
    while (j--) {
      els[i][j] = (i === j) ? 1 : 0;
    }
  }
  return Matrix.create(els);
};

Matrix.Init = function(rows,columns,callback) {
  var els = [], i = rows, j;
  while (i--) { j = columns;
    els[i] = [];
    if (typeof callback == 'function')
    while (j--) {
      els[i][j] = callback(i,j);
    }
    else
    while (j--) {
      els[i][j] = callback; // constant value
    }
  }
  return Matrix.create(els);
};

Matrix.Diagonal = function(elements) {
  var i = elements.length;
  var M = Matrix.I(i);
  while (i--) {
    M.data[i][i] = elements[i];
  }
  return M;
};

Matrix.Rotation = function(theta, a) {
  if (!a) {
    return Matrix.create([
      [Math.cos(theta),  -Math.sin(theta)],
      [Math.sin(theta),   Math.cos(theta)]
    ]);
  }
  var axis = a.dup();
  if (axis.data.length !== 3) { return null; }
  var mod = axis.modulus();
  var x = axis.data[0]/mod, y = axis.data[1]/mod, z = axis.data[2]/mod;
  var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
  // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
  // That proof rotates the co-ordinate system so theta becomes -theta and sin
  // becomes -sin here.
  return Matrix.create([
    [ t*x*x + c, t*x*y - s*z, t*x*z + s*y ],
    [ t*x*y + s*z, t*y*y + c, t*y*z - s*x ],
    [ t*x*z - s*y, t*y*z + s*x, t*z*z + c ]
  ],{reference:true});
};

Matrix.RotationX = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  1,  0,  0 ],
    [  0,  c, -s ],
    [  0,  s,  c ]
  ],{reference:true});
};
Matrix.RotationY = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c,  0,  s ],
    [  0,  1,  0 ],
    [ -s,  0,  c ]
  ],{reference:true});
};
Matrix.RotationZ = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c, -s,  0 ],
    [  s,  c,  0 ],
    [  0,  0,  1 ]
  ],{reference:true});
};

Matrix.Random = function(n, m) {
  return Matrix.Zero(n, m).map(
    function() { return Math.random(); }
  );
};

Matrix.Zero = function(n, m) {
  var els = [], i = n, j;
  while (i--) { j = m;
    els[i] = [];
    while (j--) {
      els[i][j] = 0;
    }
  }
  return Matrix.create(els,{reference:true});
};

Matrix.prototype = {

  add: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x + M[i][j]; });
  },

  addColumn : function (index,data) {
    var T = this, cols = T.data[0].length;
    if (index==cols) {
      // simple, append on right side
      T.data.forEach(function (row,i) {
        row.push(data[i])
      })
    }
    return T;
  },
  
  apply: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        this.data[i][j]=fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  augment: function(matrix) {
    if (this.data.length === 0) { return this.dup(); }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    var T = this.dup(), cols = T.data[0].length;
    var i = T.data.length, nj = M[0].length, j;
    if (i !== M.length) { return null; }
    while (i--) { j = nj;
      while (j--) {
        T.data[i][cols + j] = M[i][j];
      }
    }
    return T;
  },

  canMultiplyFromLeft: function(matrix) {
    if (this.data.length === 0) { return false; }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    // this.columns should equal matrix.rows
    return (this.data[0].length === M.length);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b,c,d) {
    var i,j,k,p,v,m,ni,nj,nk,filter;

    if (isNumber(a)) i=a;
    if (isNumber(b)) j=b;
    if (isNumber(c)) k=c;
    if (isString(b)) filter=b;
    if (isString(c)) filter=c;
    if (isString(d)) filter=d;
    if (!filter) filter='mean';

    if (!i) throw "Matrix.convert: no target size (number, first dim.)";
    if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";

    m = Matrix(i,j,k);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.rows/m.rows);
    nj=Math.floor(this.columns/m.columns);
    for(i=0;i<m.rows;i++) {
      for(j=0;j<m.columns;j++) {
        for(p=0;p<ni;p++) {
          for(q=0;q<nj;q++) {
            if (p==0 && q==0) 
              v=this.get(i*ni,j*nj);
            else
              v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
          }
        }
        m.set(i,j,v);
      }
    }
    return m;
  },

  col: function(j,asVector) {
    if (this.data.length === 0) { return null; }
    if (j >= this.data[0].length) { return null; }
    var col = [], n = this.data.length;
    for (var i = 0; i < n; i++) { col.push(this.data[i][j]); }
    return asVector?Math.Vector.create(col):col;
  },

  cols: function() {
    if (this.data.length === 0) { return 0; }
    return this.data[0].length;
  },

  derivative : function (order,points,h) {
    // TODO >1dim return Matrix.create(Math.derivative(this.data,order,points,h),{reference:true});
  },
  
  determinant: function() {
    if (this.data.length === 0) { return 1; }
    if (!this.isSquare()) { return null; }
    var M = this.toRightTriangular();
    var det = M.data[0][0], n = M.data.length;
    for (var i = 1; i < n; i++) {
      det = det * M.data[i][i];
    }
    return det;
  },

  diagonal: function() {
    if (!this.isSquare) { return null; }
    var els = [], n = this.data.length;
    for (var i = 0; i < n; i++) {
      els.push(this.data[i][i]);
    }
    return Math.Vector.create(els);
  },

  dimensions: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return {rows: this.data.length, cols: cols};
  },

  dup: function() {
    return Matrix.create(this.data);
  },

  // row,col
  e: function(i,j) {
    if (i < 1 || i > this.data.length || j < 1 || j > this.data[0].length) { return null; }
    return this.data[i-1][j-1];
  },

  eql: function(matrix) {
    var M = matrix.data || matrix;
    if (!M[0] || typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0 || M.length === 0) {
      return this.data.length === M.length;
    }
    if (this.data.length !== M.length) { return false; }
    if (this.data[0].length !== M[0].length) { return false; }
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j] - M[i][j]) > Math.precision) { return false; }
      }
    }
    return true;
  },

  forEach: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  get: function (i,j) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j];    
  },

  get rows () {
    return this.data.length;
  },
  get columns () {
    return this.data[0].length;
  },

  indexOf: function(x) {
    if (this.data.length === 0) { return null; }
    var index = null, ni = this.data.length, i, nj = this.data[0].length, j;
    for (i = 0; i < ni; i++) {
      for (j = 0; j < nj; j++) {
        if (this.data[i][j] === x) { return {i: i+1, j: j+1}; }
      }
    }
    return null;
  },

  inspect: function() {
    var matrix_rows = [];
    var n = this.data.length;
    if (n === 0) return '[]';
    for (var i = 0; i < n; i++) {
      matrix_rows.push(Math.Vector.create(this.data[i]).inspect());
    }
    return matrix_rows.join('\n');
  },

  inverse: function() {
    if (this.data.length === 0) { return null; }
    if (!this.isSquare() || this.isSingular()) { return null; }
    var n = this.data.length, i= n, j;
    var M = this.augment(Matrix.I(n)).toRightTriangular();
    var np = M.data[0].length, p, els, divisor;
    var inverse_elements = [], new_element;
    // Matrix. is non-singular so there will be no zeros on the
    // diagonal. Cycle through rows from last to first.
    while (i--) {
      // First, normalise diagonal elements to 1
      els = [];
      inverse_elements[i] = [];
      divisor = M.data[i][i];
      for (p = 0; p < np; p++) {
        new_element = M.data[i][p] / divisor;
        els.push(new_element);
        // Shuffle off the current row of the right hand side into the results
        // array as it will not be modified by later runs through this loop
        if (p >= n) { inverse_elements[i].push(new_element); }
      }
      M.data[i] = els;
      // Then, subtract this row from those above it to give the identity matrix
      // on the left hand side
      j = i;
      while (j--) {
        els = [];
        for (p = 0; p < np; p++) {
          els.push(M.data[j][p] - M.data[i][p] * M.data[j][i]);
        }
        M.data[j] = els;
      }
    }
    return Matrix.create(inverse_elements);
  },

  isSameSizeAs: function(matrix) {
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0) { return M.length === 0; }
    return (this.data.length === M.length &&
        this.data[0].length === M[0].length);
  },

  isSingular: function() {
    return (this.isSquare() && this.determinant() === 0);
  },

  isSquare: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return (this.data.length === cols);
  },

  iter: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  loop: function(fn, context, tmo) {
    var tmo=typeof context=='number'?context:(tmo||1);
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    var timer = setInterval(tmo,function () {
      if (i<ni) { 
        if (j<nj) {
          fn.call(context, this.data[i][j], i, j);
          j++;
        } else j = 0,i++;
      } else clearInterval(timer);
    });
    return this;
  },
  
  max: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] > m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) > Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  map: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        els[i][j] = fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  mapRow : function (f) {
    var res=[];
    for(var row=0;row<this.rows;row++) {
      res.push(f(this.data[row],row));
    }
    return res;
  },

  min: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] < m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) < Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minor: function(a, b, c, d) {
    if (this.data.length === 0) { return null; }
    var elements = [], ni = c, i, nj, j;
    var rows = this.data.length, cols = this.data[0].length;
    while (ni--) { i = c - ni - 1;
      elements[i] = [];
      nj = d;
      while (nj--) { j = d - nj - 1;
        elements[i][j] = this.data[(a+i-1)%rows][(b+j-1)%cols];
      }
    }
    return Matrix.create(elements);
  },

  multiply: function(matrix) {
    if (this.data.length === 0) { return null; }
    if (!matrix.data) {
      return this.map(function(x) { return x * matrix; });
    }
    var returnVector = matrix.modulus ? true : false;
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.canMultiplyFromLeft(M)) { return null; }
    var i = this.data.length, nj = M[0].length, j;
    var cols = this.data[0].length, c, elements = [], sum;
    while (i--) { j = nj;
      elements[i] = [];
      while (j--) { c = cols;
        sum = 0;
        while (c--) {
          sum += this.data[i][c] * M[c][j];
        }
        elements[i][j] = sum;
      }
    }
    var M = Matrix.create(elements);
    return returnVector ? M.col(0,true) : M;
  },

  print : function (preci) {
    return this.dims==3?this.data.map(function (m) { return m.print() }).join('\n\n'):this.data.print(preci)
  },
  
  rank: function() {
    if (this.data.length === 0) { return 0; }
    var M = this.toRightTriangular(), rank = 0;
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(M.data[i][j]) > Math.precision) { rank++; break; }
      }
    }
    return rank;
  },

  // typeof @options = { rows, columns, algorithm?:'bilinear', ..}
  resize : function (options) {
    var space=this.dataspace,
        new_space=[],
        interp = 'nearest-neighbor',  // resize with interpolation 
        offset=[];
    if (Utils.isArray(options)) { // [row0,col0,row1,col1]
      switch (options.length) {
        case 2:
          new_space=[options[1]-options[0]];
          offset=[options[0]];
          break;
        case 4:
          new_space=[options[2]-options[0], options[3]-options[1]];
          offeset=[options[0],options[1]];
          break;
      }
    } else for(var p in options) {
      switch (p) {
        case 'rows':    new_space[0]=options[p]; break;
        case 'columns': new_space[1]=options[p]; break;
        case 'levels':  new_space[2]=options[p]; break;
        case 'dataspace': new_space=dataspace; break;
        case 'algorithm': interp=options[p]; break;
        case 'offset':
          offset=options[p];
          break;
      }
    }
    if (typeof offset == 'number') offset=[offset];
    
    // from https://github.com/LinusU/resize-image-data
    function nearestNeighbor (src, dst) {
      for (var y = 0; y < dst.rows; y++) {
        for (var x = 0; x < dst.columns; x++) {
          var srcX = Math.floor(x * src.columns / dst.columns)
          var srcY = Math.floor(y * src.rows / dst.rows)
          dst.data[y][x]=src.data[srcY][srcX];
        }
      }
    }
    function bilinearInterpolation (src, dst) {
      function interpolate (k, kMin, kMax, vMin, vMax) {
        return ((k - kMin) * vMax + (kMax - k) * vMin)
      }
      function interpolateHorizontal (x, y, xMin, xMax) {
        var vMin = src.data[y][xMin]
        if (xMin === xMax) return vMin;
        var vMax = src.data[y][xMax];
        return interpolate(x, xMin, xMax, vMin, vMax)
      }
      function interpolateVertical (x, xMin, xMax, y, yMin, yMax) {
        var vMin = interpolateHorizontal(x, yMin, xMin, xMax);
        if (yMin === yMax) return vMin;
        var vMax = interpolateHorizontal(x, yMax, xMin, xMax);
        return interpolate(y, yMin, yMax, vMin, vMax)
      }
      for (var y = 0; y < dst.rows; y++) {
        for (var x = 0; x < dst.columns; x++) {
          var srcX = x * src.columns / dst.columns
          var srcY = y * src.rows / dst.rows
          var xMin = Math.floor(srcX)
          var yMin = Math.floor(srcY)
          var xMax = Math.min(Math.ceil(srcX), src.columns - 1)
          var yMax = Math.min(Math.ceil(srcY), src.rows - 1)
          dst.data[y][x] = interpolateVertical(srcX, xMin, xMax, srcY, yMin, yMax)
         }
      }
    }
    
    switch (new_space.length) {
      case 0:
        // shrink rows
        if (offset.length==1) {
          return this.slice(offset[0]);        
        }
        break;
      case 1:
        // shrink/expand rows
        if (new_space[0]<space[0]) {
          offset=offset[0]||0;
          return this.slice(offset,offset+new_space[0]);
        }
        break;
      case 2:
        switch (interp) {
          case 'biliniear-interpolation':
          case 'bilinear':
            var src = this,
                dst = Matrix(new_space[0],new_space[1]);
            bilinearInterpolation(src,dst);
            return dst;
            break;
          case 'nearest-neighbor':
          case 'nearest':
          default:
            var src = this,
                dst = Matrix(new_space[0],new_space[1]);
            nearestNeighbor(src,dst);
            return dst;
            break;
        }
     
    }
    return new Error('ENOTSUPPORTED');
  },
  
  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  row: function(i,asVector) {
    if (i >= this.data.length) { return null; }
    return asVector?Math.Vector.create(this.data[i]):this.data[i];
  },

  snapTo: function(x) {
    return this.map(function(p) {
      return (Math.abs(p - x) <= Math.precision) ? x : p;
    });
  },

  set: function (i,j,v) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j]=v;    
  },

  setData: function(els,ref) {
    var i, j, elements = els.data || els;
    this.datatype='number';
    this.dataspace=Math.dataspace(elements);
    if (ref) { this.data=els; return this};
    if (elements[0] && typeof(elements[0][0]) !== 'undefined') {
      i = elements.length;
      this.data = [];
      while (i--) { j = elements[i].length;
        this.data[i] = [];
        while (j--) {
          this.data[i][j] = elements[i][j];
        }
      }
      return this;
    }
    var n = elements.length;
    this.data = [];
    for (i = 0; i < n; i++) {
      this.data.push([elements[i]]);
    }
    return this;
  },
  
  // Slice of data in major dimension
  slice : function (a,b,inplace) {
    if (b==undefined) b=this.rows;
    return inplace?
            Matrix(this.data.slice(a,b))
            : Matrix(this.data.slice(a,b).map(function (row) { return row.slice() }));
  },
  
  subMatrix : function (startRow, endRow, startColumn, endColumn) {
    var data = [];
    switch (this.dataspace.length) {
      case 1:
        for(var i=startRow;i<=endRow;i++) {
          data.push(this.data[i]);
        }
        return Vector(data);
        break;
      case 2:
        for(var i=startRow;i<endRow;i++) {
          var row=[];
          for(var j=startColumn;j<=endColumn;j++) {
            row.push(this.data[i][j]);
          }
          data.push(row);
        }
        return Matrix(data);
        break;
    }
  },
  
  // rx:rows,ry:columns,rz:levels
  subMatrixRange : function (rx,ry,rz) {
    var data=[];
    function copy(x) { return x.slice() }
    if (this.dataspace.length!=2) throw "subMatrixRange: dim not supported"
    if (isNumber(rx) && isAll(ry)) {
      return Matrix([this.data[rx].slice()]);
    } else if (isRange(rx) && isAll(ry)) {
      return Matrix(this.data.slice(rx[0],rx[1]+1).map(copy)); 
    } else {
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    }
  },
  
  
  subtract: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x - M[i][j]; });
  },

  toArray : function () { return this.data },
  
  toRightTriangular: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var M = this.dup(), els;
    var n = this.data.length, i, j, np = this.data[0].length, p;
    for (i = 0; i < n; i++) {
      if (M.data[i][i] === 0) {
        for (j = i + 1; j < n; j++) {
          if (M.data[j][i] !== 0) {
            els = [];
            for (p = 0; p < np; p++) { els.push(M.data[i][p] + M.data[j][p]); }
            M.data[i] = els;
            break;
          }
        }
      }
      if (M.data[i][i] !== 0) {
        for (j = i + 1; j < n; j++) {
          var multiplier = M.data[j][i] / M.data[i][i];
          els = [];
          for (p = 0; p < np; p++) {
            // Elements with column numbers up to an including the number of the
            // row that we're subtracting can safely be set straight to zero,
            // since that's the point of this routine and it avoids having to
            // loop over and correct rounding errors later
            els.push(p <= i ? 0 : M.data[j][p] - M.data[i][p] * multiplier);
          }
          M.data[j] = els;
        }
      }
    }
    return M;
  },

  trace: function() {
    if (this.data.length === 0) { return 0; }
    if (!this.isSquare()) { return null; }
    var tr = this.data[0][0], n = this.data.length;
    for (var i = 1; i < n; i++) {
      tr += this.data[i][i];
    }
    return tr;
  },
  
  transpose: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var rows = this.data.length, i, cols = this.data[0].length, j;
    var elements = [], i = cols;
    while (i--) { j = rows;
      elements[i] = [];
      while (j--) {
        elements[i][j] = this.data[j][i];
      }
    }
    return Matrix.create(elements);
  },
};

Matrix.prototype.toUpperTriangular = Matrix.prototype.toRightTriangular;
Matrix.prototype.det = Matrix.prototype.determinant;
Matrix.prototype.tr = Matrix.prototype.trace;
Matrix.prototype.rk = Matrix.prototype.rank;
Matrix.prototype.inv = Matrix.prototype.inverse;
Matrix.prototype.x = Matrix.prototype.multiply;
Matrix.prototype.pluck = Matrix.prototype.col;

module.exports = Matrix;
};
BundleModuleCode['plugins/math/vector']=function (module,exports,global,process){
/*
** Vector array objects
**
** Ver. 1.4.1
*/
var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;
    
var Vector = function(elements,options) {
  if (!(this instanceof Vector)) return new Vector(elements,options);
  options=options||{};
  var space=[];
  this.tag='Vector';
  if (typeof elements == 'number') space.push(elements);
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.columns=space[0];
    this.data=Array(space[0]).fill(0);
  } else {
    this.columns=elements.length;
    this.setData(elements,options.reference);
  }
  this.__constructor__='Math.Vector';
};

Vector.isVector = function (o) {
  return o instanceof Vector
}

Vector.create = Vector

// var $V = Vector.create;
Vector.Init = function(n,valueOrCallback) {
  var elements = [],i=0;
  if (typeof valueOrCallback == 'function')
    while (i<n) { elements.push(valueOrCallback(i)); i++; }
  else
    while (i<n) { elements.push(valueOrCallback); i++; }
  return Vector.create(elements);
};

Vector.Random = function(n) {
  var elements = [];
  while (n--) { elements.push(Math.random()); }
  return Vector.create(elements);
};

Vector.Sequence = function(a,b,step) {
  if (!step) step=1;
  var elements = [];
  var i=a;
  while (i<b) { 
    elements.push(i);
    i += step; 
  }
  return Vector.create(elements);
};

Vector.Zero = function(n) {
  var elements = [];
  while (n--) { elements.push(0); }
  return Vector.create(elements);
};

Vector.prototype = {
  e: function(i) {
    return (i < 1 || i > this.data.length) ? null : this.data[i-1];
  },


  add: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x + V[i-1]; });
  },

  angleFrom: function(vector) {
    var V = vector.data || vector;
    var n = this.data.length, k = n, i;
    if (n !== V.length) { return null; }
    var dot = 0, mod1 = 0, mod2 = 0;
    // Work things out in parallel to save time
    this.each(function(x, i) {
      dot += x * V[i-1];
      mod1 += x * x;
      mod2 += V[i-1] * V[i-1];
    });
    mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
    if (mod1*mod2 === 0) { return null; }
    var theta = dot / (mod1*mod2);
    if (theta < -1) { theta = -1; }
    if (theta > 1) { theta = 1; }
    return Math.acos(theta);
  },

  cross: function(vector) {
    var B = vector.data || vector;
    if (this.data.length !== 3 || B.length !== 3) { return null; }
    var A = this.data;
    return Vector.create([
      (A[1] * B[2]) - (A[2] * B[1]),
      (A[2] * B[0]) - (A[0] * B[2]),
      (A[0] * B[1]) - (A[1] * B[0])
    ]);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b) {
    var i,p,v,m,ni,filter;

    if (isNumber(a)) i=a;
    if (isString(b)) filter=b;
    if (!filter) filter='mean';

    if (!i) throw "Vector.convert: no target size (number, first dim.)";

    m = Vector(i);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.columns/m.columns);
    for(i=0;i<m.columns;i++) {
        v=this.data[i*ni]; 
        for(p=1;p<ni;p++) {
          v=filter(v,this.data[i*ni+p],p,ni);
        }
        m.data[i]=v;
    }
    return m;
  },

  derivative : function (order,points,h) {
    return Vector.create(Math.derivative(this.data,order,points,h),{reference:true});
  },

  dimensions: function() {
    return this.data.length;
  },

  distanceFrom: function(obj) {
    if (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    var V = obj.data || obj;
    if (V.length !== this.data.length) { return null; }
    var sum = 0, part;
    this.each(function(x, i) {
      part = x - V[i-1];
      sum += part * part;
    });
    return Math.sqrt(sum);
  },

  dot: function(vector) {
    var V = vector.data || vector;
    var i, product = 0, n = this.data.length;
    if (n !== V.length) { return null; }
    while (n--) { product += this.data[n] * V[n]; }
    return product;
  },

  dup: function() {
    return Vector.create(this.data);
  },

  eql: function(vector) {
    var n = this.data.length;
    var V = vector.data || vector;
    if (n !== V.length) { return false; }
    while (n--) {
      if (Math.abs(this.data[n] - V[n]) > Math.precision) { return false; }
    }
    return true;
  },

  forEach: function(fn, context) {
    var n = this.data.length;
    for (var i = 0; i < n; i++) {
      fn.call(context, this.data[i], i+1);
    }
  },
  
  get : function (i) { return this.data[i] },

  indexOf: function(x) {
    var index = null, n = this.data.length;
    for (var i = 0; i < n; i++) {
      if (index === null && this.data[i] === x) {
        index = i + 1;
      }
    }
    return index;
  },

  inspect: function() {
    return '[' + this.data.join(', ') + ']';
  },

  // resize vector to any new size with interpolation
  interpolate : function (newpoints) {
    // http://hevi.info/do-it-yourself/interpolating-and-array-to-fit-another-size/
    function linearInterpolate(before, after, atPoint) {
	    return before + (after - before) * atPoint;
    };
    function interpolateArray(data, fitCount) {
	    var newData = new Array();
	    var springFactor = new Number((data.length - 1) / (fitCount - 1));
	    newData[0] = data[0]; // for new allocation
	    for ( var i = 1; i < fitCount - 1; i++) {
		    var tmp = i * springFactor;
		    var before = new Number(Math.floor(tmp)).toFixed();
		    var after = new Number(Math.ceil(tmp)).toFixed();
		    var atPoint = tmp - before;
		    newData[i] = linearInterpolate(data[before], data[after], atPoint);
		    }
	    newData[fitCount - 1] = data[data.length - 1]; // for new allocation
	    return newData;
    };
    return Vector(interpolateArray(this.data,newpoints));
  },
  
  isParallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (angle <= Math.precision);
  },

  isAntiparallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (Math.abs(angle - Math.PI) <= Math.precision);
  },

  isPerpendicularTo: function(vector) {
    var dot = this.dot(vector);
    return (dot === null) ? null : (Math.abs(dot) <= Math.precision);
  },

  liesOn: function(line) {
    return line.contains(this);
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  get length () {
    return this.data.length
  },
  
  map: function(fn, context) {
    var elements = [];
    this.each(function(x, i) {
      elements.push(fn.call(context, x, i));
    });
    return Vector.create(elements);
  },

  max: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] > m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) > Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  min: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] < m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    var m = 0, i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) < Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  modulus: function() {
    return Math.sqrt(this.dot(this));
  },

  multiply: function(k) {
    return this.map(function(x) { return x*k; });
  },

  pad : function (n,v,left) {
    return Vector(this.data.pad(n,v,left));
  },

  print : function () {
    return this.data.print()
  },

  reflectionIn: function(obj) {
    if (obj.anchor) {
      // obj is a plane or line
      var P = this.data.slice();
      var C = obj.pointClosestTo(P).data;
      return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
    } else {
      // obj is a point
      var Q = obj.data || obj;
      if (this.data.length !== Q.length) { return null; }
      return this.map(function(x, i) { return Q[i-1] + (Q[i-1] - x); });
    }
  },

  rotate: function(t, obj) {
    var V, R = null, x, y, z;
    if (t.determinant) { R = t.data; }
    switch (this.data.length) {
      case 2:
        V = obj.data || obj;
        if (V.length !== 2) { return null; }
        if (!R) { R = Math.Matrix.Rotation(t).data; }
        x = this.data[0] - V[0];
        y = this.data[1] - V[1];
        return Vector.create([
          V[0] + R[0][0] * x + R[0][1] * y,
          V[1] + R[1][0] * x + R[1][1] * y
        ]);
        break;
      case 3:
        if (!obj.direction) { return null; }
        var C = obj.pointClosestTo(this).data;
        if (!R) { R = Math.Matrix.Rotation(t, obj.direction).data; }
        x = this.data[0] - C[0];
        y = this.data[1] - C[1];
        z = this.data[2] - C[2];
        return Vector.create([
          C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
          C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
          C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
        ]);
        break;
      default:
        return null;
    }
  },

  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  set : function (i,v) { return this.data[i]=v },

  setData: function(els,ref) {
    this.datatype='number';
    this.dataspace=[els.length];
    if (ref) { this.data=(els.data || els); return this};
    this.data = (els.data || els).slice();
    return this;
  },
  
  snapTo: function(x) {
    return this.map(function(y) {
      return (Math.abs(y - x) <= Math.precision) ? x : y;
    });
  },

  subtract: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x - V[i-1]; });
  },

  toArray : function () { return this.data },

  to3D: function() {
    var V = this.dup();
    switch (V.data.length) {
      case 3: break;
      case 2: V.data.push(0); break;
      default: return null;
    }
    return V;
  },

  toDiagonalMatrix: function() {
    return Math.Matrix.Diagonal(this.data);
  },

  toUnitVector: function() {
    var r = this.modulus();
    if (r === 0) { return this.dup(); }
    return this.map(function(x) { return x/r; });
  },


};

Vector.prototype.x = Vector.prototype.multiply;
Vector.prototype.each = Vector.prototype.forEach;
Vector.prototype.sample = function (frag,filter) { return Vector(this.data.sample(frag,filter)) };

Vector.i = Vector.create([1,0,0]);
Vector.j = Vector.create([0,1,0]);
Vector.k = Vector.create([0,0,1]);

module.exports = Vector;
};
BundleModuleCode['plugins/math/line']=function (module,exports,global,process){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 

var Line = function(anchor, direction) {
  if (!(this instanceof Line)) return new Line(anchor, direction);
  this.setVectors(anchor, direction);
};

Line.prototype = {
  eql: function(line) {
    return (this.isParallelTo(line) && this.contains(line.anchor));
  },

  dup: function() {
    return Line.create(this.anchor, this.direction);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Line.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.direction);
  },

  isParallelTo: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }
    var theta = this.direction.angleFrom(obj.direction);
    return (Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    if (obj.direction) {
      // obj is a line
      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }
      var N = this.direction.cross(obj.direction).toUnitVector().data;
      var A = this.anchor.data, B = obj.anchor.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, D = this.direction.data;
      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
      if (modPA === 0) return 0;
      // Assumes direction vector is normalized
      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
      var sin2 = 1 - cosTheta*cosTheta;
      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
    }
  },

  contains: function(obj) {
    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }
    var dist = this.distanceFrom(obj);
    return (dist !== null && dist <= Math.precision);
  },

  positionOf: function(point) {
    if (!this.contains(point)) { return null; }
    var P = point.data || point;
    var A = this.anchor.data, D = this.direction.data;
    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  intersects: function(obj) {
    if (obj.normal) { return obj.intersects(this); }
    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Math.precision);
  },

  intersectionWith: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }
    if (!this.intersects(obj)) { return null; }
    var P = this.anchor.data, X = this.direction.data,
        Q = obj.anchor.data, Y = obj.direction.data;
    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
    var XdotX = X1*X1 + X2*X2 + X3*X3;
    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
  },

  pointClosestTo: function(obj) {
    if (obj.start && obj.end) {
      // obj is a line segment
      var P = obj.pointClosestTo(this);
      return (P === null) ? null : this.pointClosestTo(P);
    } else if (obj.direction) {
      // obj is a line
      if (this.intersects(obj)) { return this.intersectionWith(obj); }
      if (this.isParallelTo(obj)) { return null; }
      var D = this.direction.data, E = obj.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
      // Create plane containing obj and the shared normal and intersect this
      // with it Thank you:
      // http://www.cgafaq.info/wiki/Line-line_distance
      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];
      var P = Math.Plane.create(obj.anchor, N);
      return P.intersectionWith(this);
    } else {
      // obj is a point
      var P = obj.data || obj;
      if (this.contains(P)) { return Vector.create(P); }
      var A = this.anchor.data, D = this.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
      var k = this.distanceFrom(P) / V.modulus();
      return Vector.create([
        P[0] + V.data[0] * k,
        P[1] + V.data[1] * k,
        (P[2] || 0) + V.data[2] * k
      ]);
    }
  },

  // Returns a copy of the line rotated by t radians about the given line. Works
  // by finding the argument's closest point to this line's anchor point (call
  // this C) and rotating the anchor about C. Also rotates the line's direction
  // about the argument's. Be careful with this - the rotation axis' direction
  // affects the outcome!
  rotate: function(t, line) {
    // If we're working in 2D
    if (typeof(line.direction) === 'undefined') { line = Line.create(line.to3D(), Vector.k); }
    var R = Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, D = this.direction.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Line.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
    ]);
  },

  reverse: function() {
    return Line.create(this.anchor, this.direction.x(-1));
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, D = this.direction.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the line's direction vector to its anchor, then mirror that in the plane
      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
      var Q = obj.pointClosestTo([AD1, AD2, AD3]).data;
      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
      return Line.create(newA, newD);
    } else if (obj.direction) {
      // obj is a line - reflection obtained by rotating PI radians about obj
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point - just reflect the line's anchor in it
      var P = obj.data || obj;
      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
    }
  },

  setVectors: function(anchor, direction) {
    // Need to do this so that line's properties are not references to the
    // arguments passed in
    anchor = Vector.create(anchor);
    direction = Vector.create(direction);
    if (anchor.data.length === 2) {anchor.data.push(0); }
    if (direction.data.length === 2) { direction.data.push(0); }
    if (anchor.data.length > 3 || direction.data.length > 3) { return null; }
    var mod = direction.modulus();
    if (mod === 0) { return null; }
    this.anchor = anchor;
    this.direction = Vector.create([
      direction.data[0] / mod,
      direction.data[1] / mod,
      direction.data[2] / mod
    ]);
    return this;
  }
};

Line.create = Line;

Line.X = Line.create(Vector.Zero(3), Vector.i);
Line.Y = Line.create(Vector.Zero(3), Vector.j);
Line.Z = Line.create(Vector.Zero(3), Vector.k);


module.exports = Line;
};
BundleModuleCode['plugins/math/plane']=function (module,exports,global,process){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 
var Line   = Require('plugins/math/line') 

var Plane = function(anchor, v1, v2) {
  if (!(this instanceof Plane)) return  new Plane(anchor, v1, v2);
  this.setVectors(anchor, v1, v2);
};

Plane.prototype = {
  eql: function(plane) {
    return (this.contains(plane.anchor) && this.isParallelTo(plane));
  },

  dup: function() {
    return Plane.create(this.anchor, this.normal);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Plane.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.normal);
  },

  isParallelTo: function(obj) {
    var theta;
    if (obj.normal) {
      // obj is a plane
      theta = this.normal.angleFrom(obj.normal);
      return (Math.abs(theta) <= Math.precision || Math.abs(Math.PI - theta) <= Math.precision);
    } else if (obj.direction) {
      // obj is a line
      return this.normal.isPerpendicularTo(obj.direction);
    }
    return null;
  },

  isPerpendicularTo: function(plane) {
    var theta = this.normal.angleFrom(plane.normal);
    return (Math.abs(Math.PI/2 - theta) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (this.intersects(obj) || this.contains(obj)) { return 0; }
    if (obj.anchor) {
      // obj is a plane or line
      var A = this.anchor.data, B = obj.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
    }
  },

  contains: function(obj) {
    if (obj.normal) { return null; }
    if (obj.direction) {
      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));
    } else {
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
      return (diff <= Math.precision);
    }
  },

  intersects: function(obj) {
    if (typeof(obj.direction) === 'undefined' && typeof(obj.normal) === 'undefined') { return null; }
    return !this.isParallelTo(obj);
  },

  intersectionWith: function(obj) {
    if (!this.intersects(obj)) { return null; }
    if (obj.direction) {
      // obj is a line
      var A = obj.anchor.data, D = obj.direction.data,
          P = this.anchor.data, N = this.normal.data;
      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);
    } else if (obj.normal) {
      // obj is a plane
      var direction = this.normal.cross(obj.normal).toUnitVector();
      // To find an anchor point, we find one co-ordinate that has a value of
      // zero somewhere on the intersection, and remember which one we picked
      var N = this.normal.data, A = this.anchor.data,
          O = obj.normal.data, B = obj.anchor.data;
      var solver = Matrix.Zero(2,2), i = 0;
      while (solver.isSingular()) {
        i++;
        solver = Matrix.create([
          [ N[i%3], N[(i+1)%3] ],
          [ O[i%3], O[(i+1)%3]  ]
        ]);
      }
      // Then we solve the simultaneous equations in the remaining dimensions
      var inverse = solver.inverse().data;
      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
      var intersection = [
        inverse[0][0] * x + inverse[0][1] * y,
        inverse[1][0] * x + inverse[1][1] * y
      ];
      var anchor = [];
      for (var j = 1; j <= 3; j++) {
        // This formula picks the right element from intersection by cycling
        // depending on which element we set to zero above
        anchor.push((i === j) ? 0 : intersection[(j + (5 - i)%3)%3]);
      }
      return Line.create(anchor, direction);
    }
  },

  pointClosestTo: function(point) {
    var P = point.data || point;
    var A = this.anchor.data, N = this.normal.data;
    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
  },

  rotate: function(t, line) {
    var R = t.determinant ? t.data : Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, N = this.normal.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Plane.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
    ]);
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, N = this.normal.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the plane's normal to its anchor, then mirror that in the other plane
      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
      var Q = obj.pointClosestTo([AN1, AN2, AN3]).data;
      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
      return Plane.create(newA, newN);
    } else if (obj.direction) {
      // obj is a line
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point
      var P = obj.data || obj;
      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
    }
  },

  setVectors: function(anchor, v1, v2) {
    anchor = Vector.create(anchor);
    anchor = anchor.to3D(); if (anchor === null) { return null; }
    v1 = Vector.create(v1);
    v1 = v1.to3D(); if (v1 === null) { return null; }
    if (typeof(v2) === 'undefined') {
      v2 = null;
    } else {
      v2 = Vector.create(v2);
      v2 = v2.to3D(); if (v2 === null) { return null; }
    }
    var A1 = anchor.data[0], A2 = anchor.data[1], A3 = anchor.data[2];
    var v11 = v1.data[0], v12 = v1.data[1], v13 = v1.data[2];
    var normal, mod;
    if (v2 !== null) {
      var v21 = v2.data[0], v22 = v2.data[1], v23 = v2.data[2];
      normal = Vector.create([
        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
      ]);
      mod = normal.modulus();
      if (mod === 0) { return null; }
      normal = Vector.create([normal.data[0] / mod, normal.data[1] / mod, normal.data[2] / mod]);
    } else {
      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
      if (mod === 0) { return null; }
      normal = Vector.create([v1.data[0] / mod, v1.data[1] / mod, v1.data[2] / mod]);
    }
    this.anchor = anchor;
    this.normal = normal;
    return this;
  }
};

Plane.create = Plane


Plane.XY = Plane.create(Vector.Zero(3), Vector.k);
Plane.YZ = Plane.create(Vector.Zero(3), Vector.i);
Plane.ZX = Plane.create(Vector.Zero(3), Vector.j);
Plane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;

Plane.fromPoints = function(points) {
  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);
  for (i = 0; i < np; i++) {
    P = Vector.create(points[i]).to3D();
    if (P === null) { return null; }
    list.push(P);
    n = list.length;
    if (n > 2) {
      // Compute plane normal for the latest three points
      A = list[n-1].data; B = list[n-2].data; C = list[n-3].data;
      N = Vector.create([
        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
      ]).toUnitVector();
      if (n > 3) {
        // If the latest normal is not (anti)parallel to the previous one, we've
        // strayed off the plane. This might be a slightly long-winded way of
        // doing things, but we need the sum of all the normals to find which
        // way the plane normal should point so that the points form an
        // anticlockwise list.
        theta = N.angleFrom(prevN);
        if (theta !== null) {
          if (!(Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision)) { return null; }
        }
      }
      totalN = totalN.add(N);
      prevN = N;
    }
  }
  // We need to add in the normals at the start and end points, which the above
  // misses out
  A = list[1].data; B = list[0].data; C = list[n-1].data; D = list[n-2].data;
  totalN = totalN.add(Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).toUnitVector()).add(Vector.create([
    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),
    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),
    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])
  ]).toUnitVector());
  return Plane.create(list[0], totalN);
};
};
BundleModuleCode['plugins/math/stats']=function (module,exports,global,process){
// https://github.com/simple-statistics/simple-statistics
// Version 1.3.3

'use strict';

var exports = module.exports;
function log2(n) {
  return Math.log(n) / Math.log(2);
}

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0,
            sumY = 0,
            sumXX = 0,
            sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    } else if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0],
        // store the mode as we find new modes
        value = NaN,
        // store how many times we've seen the mode
        maxSeen = 0,
        // how many times the current candidate for the mode
        // has been seen
        seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(nlog(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, min is
        // undefined and is thus made the minimum element in the array
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, max is
        // undefined and is thus made the maximum element in the array
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    // The mad of nothing is null
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // chose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample.slice(), randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0,
        lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix.length - 1) {
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "geometricMean requires only positive numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.2174396181152126432e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Infinity;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    "1": {
        "0.995": 0,
        "0.99": 0,
        "0.975": 0,
        "0.95": 0,
        "0.9": 0.02,
        "0.5": 0.45,
        "0.1": 2.71,
        "0.05": 3.84,
        "0.025": 5.02,
        "0.01": 6.63,
        "0.005": 7.88
    },
    "2": {
        "0.995": 0.01,
        "0.99": 0.02,
        "0.975": 0.05,
        "0.95": 0.1,
        "0.9": 0.21,
        "0.5": 1.39,
        "0.1": 4.61,
        "0.05": 5.99,
        "0.025": 7.38,
        "0.01": 9.21,
        "0.005": 10.6
    },
    "3": {
        "0.995": 0.07,
        "0.99": 0.11,
        "0.975": 0.22,
        "0.95": 0.35,
        "0.9": 0.58,
        "0.5": 2.37,
        "0.1": 6.25,
        "0.05": 7.81,
        "0.025": 9.35,
        "0.01": 11.34,
        "0.005": 12.84
    },
    "4": {
        "0.995": 0.21,
        "0.99": 0.3,
        "0.975": 0.48,
        "0.95": 0.71,
        "0.9": 1.06,
        "0.5": 3.36,
        "0.1": 7.78,
        "0.05": 9.49,
        "0.025": 11.14,
        "0.01": 13.28,
        "0.005": 14.86
    },
    "5": {
        "0.995": 0.41,
        "0.99": 0.55,
        "0.975": 0.83,
        "0.95": 1.15,
        "0.9": 1.61,
        "0.5": 4.35,
        "0.1": 9.24,
        "0.05": 11.07,
        "0.025": 12.83,
        "0.01": 15.09,
        "0.005": 16.75
    },
    "6": {
        "0.995": 0.68,
        "0.99": 0.87,
        "0.975": 1.24,
        "0.95": 1.64,
        "0.9": 2.2,
        "0.5": 5.35,
        "0.1": 10.65,
        "0.05": 12.59,
        "0.025": 14.45,
        "0.01": 16.81,
        "0.005": 18.55
    },
    "7": {
        "0.995": 0.99,
        "0.99": 1.25,
        "0.975": 1.69,
        "0.95": 2.17,
        "0.9": 2.83,
        "0.5": 6.35,
        "0.1": 12.02,
        "0.05": 14.07,
        "0.025": 16.01,
        "0.01": 18.48,
        "0.005": 20.28
    },
    "8": {
        "0.995": 1.34,
        "0.99": 1.65,
        "0.975": 2.18,
        "0.95": 2.73,
        "0.9": 3.49,
        "0.5": 7.34,
        "0.1": 13.36,
        "0.05": 15.51,
        "0.025": 17.53,
        "0.01": 20.09,
        "0.005": 21.96
    },
    "9": {
        "0.995": 1.73,
        "0.99": 2.09,
        "0.975": 2.7,
        "0.95": 3.33,
        "0.9": 4.17,
        "0.5": 8.34,
        "0.1": 14.68,
        "0.05": 16.92,
        "0.025": 19.02,
        "0.01": 21.67,
        "0.005": 23.59
    },
    "10": {
        "0.995": 2.16,
        "0.99": 2.56,
        "0.975": 3.25,
        "0.95": 3.94,
        "0.9": 4.87,
        "0.5": 9.34,
        "0.1": 15.99,
        "0.05": 18.31,
        "0.025": 20.48,
        "0.01": 23.21,
        "0.005": 25.19
    },
    "11": {
        "0.995": 2.6,
        "0.99": 3.05,
        "0.975": 3.82,
        "0.95": 4.57,
        "0.9": 5.58,
        "0.5": 10.34,
        "0.1": 17.28,
        "0.05": 19.68,
        "0.025": 21.92,
        "0.01": 24.72,
        "0.005": 26.76
    },
    "12": {
        "0.995": 3.07,
        "0.99": 3.57,
        "0.975": 4.4,
        "0.95": 5.23,
        "0.9": 6.3,
        "0.5": 11.34,
        "0.1": 18.55,
        "0.05": 21.03,
        "0.025": 23.34,
        "0.01": 26.22,
        "0.005": 28.3
    },
    "13": {
        "0.995": 3.57,
        "0.99": 4.11,
        "0.975": 5.01,
        "0.95": 5.89,
        "0.9": 7.04,
        "0.5": 12.34,
        "0.1": 19.81,
        "0.05": 22.36,
        "0.025": 24.74,
        "0.01": 27.69,
        "0.005": 29.82
    },
    "14": {
        "0.995": 4.07,
        "0.99": 4.66,
        "0.975": 5.63,
        "0.95": 6.57,
        "0.9": 7.79,
        "0.5": 13.34,
        "0.1": 21.06,
        "0.05": 23.68,
        "0.025": 26.12,
        "0.01": 29.14,
        "0.005": 31.32
    },
    "15": {
        "0.995": 4.6,
        "0.99": 5.23,
        "0.975": 6.27,
        "0.95": 7.26,
        "0.9": 8.55,
        "0.5": 14.34,
        "0.1": 22.31,
        "0.05": 25,
        "0.025": 27.49,
        "0.01": 30.58,
        "0.005": 32.8
    },
    "16": {
        "0.995": 5.14,
        "0.99": 5.81,
        "0.975": 6.91,
        "0.95": 7.96,
        "0.9": 9.31,
        "0.5": 15.34,
        "0.1": 23.54,
        "0.05": 26.3,
        "0.025": 28.85,
        "0.01": 32,
        "0.005": 34.27
    },
    "17": {
        "0.995": 5.7,
        "0.99": 6.41,
        "0.975": 7.56,
        "0.95": 8.67,
        "0.9": 10.09,
        "0.5": 16.34,
        "0.1": 24.77,
        "0.05": 27.59,
        "0.025": 30.19,
        "0.01": 33.41,
        "0.005": 35.72
    },
    "18": {
        "0.995": 6.26,
        "0.99": 7.01,
        "0.975": 8.23,
        "0.95": 9.39,
        "0.9": 10.87,
        "0.5": 17.34,
        "0.1": 25.99,
        "0.05": 28.87,
        "0.025": 31.53,
        "0.01": 34.81,
        "0.005": 37.16
    },
    "19": {
        "0.995": 6.84,
        "0.99": 7.63,
        "0.975": 8.91,
        "0.95": 10.12,
        "0.9": 11.65,
        "0.5": 18.34,
        "0.1": 27.2,
        "0.05": 30.14,
        "0.025": 32.85,
        "0.01": 36.19,
        "0.005": 38.58
    },
    "20": {
        "0.995": 7.43,
        "0.99": 8.26,
        "0.975": 9.59,
        "0.95": 10.85,
        "0.9": 12.44,
        "0.5": 19.34,
        "0.1": 28.41,
        "0.05": 31.41,
        "0.025": 34.17,
        "0.01": 37.57,
        "0.005": 40
    },
    "21": {
        "0.995": 8.03,
        "0.99": 8.9,
        "0.975": 10.28,
        "0.95": 11.59,
        "0.9": 13.24,
        "0.5": 20.34,
        "0.1": 29.62,
        "0.05": 32.67,
        "0.025": 35.48,
        "0.01": 38.93,
        "0.005": 41.4
    },
    "22": {
        "0.995": 8.64,
        "0.99": 9.54,
        "0.975": 10.98,
        "0.95": 12.34,
        "0.9": 14.04,
        "0.5": 21.34,
        "0.1": 30.81,
        "0.05": 33.92,
        "0.025": 36.78,
        "0.01": 40.29,
        "0.005": 42.8
    },
    "23": {
        "0.995": 9.26,
        "0.99": 10.2,
        "0.975": 11.69,
        "0.95": 13.09,
        "0.9": 14.85,
        "0.5": 22.34,
        "0.1": 32.01,
        "0.05": 35.17,
        "0.025": 38.08,
        "0.01": 41.64,
        "0.005": 44.18
    },
    "24": {
        "0.995": 9.89,
        "0.99": 10.86,
        "0.975": 12.4,
        "0.95": 13.85,
        "0.9": 15.66,
        "0.5": 23.34,
        "0.1": 33.2,
        "0.05": 36.42,
        "0.025": 39.36,
        "0.01": 42.98,
        "0.005": 45.56
    },
    "25": {
        "0.995": 10.52,
        "0.99": 11.52,
        "0.975": 13.12,
        "0.95": 14.61,
        "0.9": 16.47,
        "0.5": 24.34,
        "0.1": 34.28,
        "0.05": 37.65,
        "0.025": 40.65,
        "0.01": 44.31,
        "0.005": 46.93
    },
    "26": {
        "0.995": 11.16,
        "0.99": 12.2,
        "0.975": 13.84,
        "0.95": 15.38,
        "0.9": 17.29,
        "0.5": 25.34,
        "0.1": 35.56,
        "0.05": 38.89,
        "0.025": 41.92,
        "0.01": 45.64,
        "0.005": 48.29
    },
    "27": {
        "0.995": 11.81,
        "0.99": 12.88,
        "0.975": 14.57,
        "0.95": 16.15,
        "0.9": 18.11,
        "0.5": 26.34,
        "0.1": 36.74,
        "0.05": 40.11,
        "0.025": 43.19,
        "0.01": 46.96,
        "0.005": 49.65
    },
    "28": {
        "0.995": 12.46,
        "0.99": 13.57,
        "0.975": 15.31,
        "0.95": 16.93,
        "0.9": 18.94,
        "0.5": 27.34,
        "0.1": 37.92,
        "0.05": 41.34,
        "0.025": 44.46,
        "0.01": 48.28,
        "0.005": 50.99
    },
    "29": {
        "0.995": 13.12,
        "0.99": 14.26,
        "0.975": 16.05,
        "0.95": 17.71,
        "0.9": 19.77,
        "0.5": 28.34,
        "0.1": 39.09,
        "0.05": 42.56,
        "0.025": 45.72,
        "0.01": 49.59,
        "0.005": 52.34
    },
    "30": {
        "0.995": 13.79,
        "0.99": 14.95,
        "0.975": 16.79,
        "0.95": 18.49,
        "0.9": 20.6,
        "0.5": 29.34,
        "0.1": 40.26,
        "0.05": 43.77,
        "0.025": 46.98,
        "0.01": 50.89,
        "0.005": 53.67
    },
    "40": {
        "0.995": 20.71,
        "0.99": 22.16,
        "0.975": 24.43,
        "0.95": 26.51,
        "0.9": 29.05,
        "0.5": 39.34,
        "0.1": 51.81,
        "0.05": 55.76,
        "0.025": 59.34,
        "0.01": 63.69,
        "0.005": 66.77
    },
    "50": {
        "0.995": 27.99,
        "0.99": 29.71,
        "0.975": 32.36,
        "0.95": 34.76,
        "0.9": 37.69,
        "0.5": 49.33,
        "0.1": 63.17,
        "0.05": 67.5,
        "0.025": 71.42,
        "0.01": 76.15,
        "0.005": 79.49
    },
    "60": {
        "0.995": 35.53,
        "0.99": 37.48,
        "0.975": 40.48,
        "0.95": 43.19,
        "0.9": 46.46,
        "0.5": 59.33,
        "0.1": 74.4,
        "0.05": 79.08,
        "0.025": 83.3,
        "0.01": 88.38,
        "0.005": 91.95
    },
    "70": {
        "0.995": 43.28,
        "0.99": 45.44,
        "0.975": 48.76,
        "0.95": 51.74,
        "0.9": 55.33,
        "0.5": 69.33,
        "0.1": 85.53,
        "0.05": 90.53,
        "0.025": 95.02,
        "0.01": 100.42,
        "0.005": 104.22
    },
    "80": {
        "0.995": 51.17,
        "0.99": 53.54,
        "0.975": 57.15,
        "0.95": 60.39,
        "0.9": 64.28,
        "0.5": 79.33,
        "0.1": 96.58,
        "0.05": 101.88,
        "0.025": 106.63,
        "0.01": 112.33,
        "0.005": 116.32
    },
    "90": {
        "0.995": 59.2,
        "0.99": 61.75,
        "0.975": 65.65,
        "0.95": 69.13,
        "0.9": 73.29,
        "0.5": 89.33,
        "0.1": 107.57,
        "0.05": 113.14,
        "0.025": 118.14,
        "0.01": 124.12,
        "0.005": 128.3
    },
    "100": {
        "0.995": 67.33,
        "0.99": 70.06,
        "0.975": 74.22,
        "0.95": 77.93,
        "0.9": 82.36,
        "0.5": 99.33,
        "0.1": 118.5,
        "0.05": 124.34,
        "0.025": 129.56,
        "0.01": 135.81,
        "0.005": 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z,
        tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI$1) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the cumulative distribution function of the normal distribution.
 * It is used to find the probability that a statistic is observed below,
 * above, or between values on the standard normal distribution, and by
 * extension, any normal distribution.
 *
 * The probabilities are calculated using the
 * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).
 * The table used is the cumulative, and not cumulative from 0 to mean
 * (even though the latter has 5 digits precision, instead of 4).
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return +(1 - standardNormalTable[index]).toFixed(4);
    }
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'"
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}


// More statistics: enrtopy ...

// Finds element with highest occurrence in a list
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;
  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}
exports.mostCommon = mostCommon;

// Probe for a value
function probe(value, list) {
  var occurrences = list.filter(function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probe = probe;
/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probeEps(value, list, eps) {
  var occurrences = list.filter(function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probeEps = probeEps;


exports.unique = function (list) { return list.unique() };
function uniqueSorted (array) {
  var set = array.unique().sort(function (a,b) { return a<b?-1:1 });
  return set;
}
function uniqueEps(array,eps) {
  var result=[];
  array.forEach(function (x) {
    var found;
    if (!result.length) result.push(x);
    else {
      result.forEach(function (y) {
        if (found) return;
        found = Math.abs(x-y)<=eps;
      }); 
      if (!found) result.push(x);
    }
  });
  return result;
}
exports.uniqueEps = uniqueEps;

// Entropy of data vectors
function entropy(vals) {
  var uniqueVals = vals.unique();
  var probs = uniqueVals.map(function(x) {
    return probe(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropy = entropy;

function entropyEps(vals,eps) {
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probeEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropyEps = entropyEps;

// Entropy of target variable partitioned feature vector
function entropyT(data,featureIndex,targetIndex,targets) {
  var en = 0;
  var col =  pluck(data,featureIndex);
  var uniqueVals = unique(col);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2==v) cn++,frac[targets.indexOf(data[row][targetIndex])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyT = entropyT;

function entropyTEps(data,feature,target,targets,eps) {
  var en = 0;
  var col =  pluck(data,feature);
  var uniqueVals = uniqueEps(col,eps);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2>=v-eps && v2<=v+eps) cn++,frac[targets.indexOf(data[row][target])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyTEps = entropyTEps;


function gainEps(data,feature,target,targets,eps) {
  var et = entropy(data.pluck(target));
  return et/entropyTEps(data,feature,target,targets,eps)
}


function maxGainEps(data,features,target,targets,eps) {
  var maxgain=max(features, function(feature,index) {
    var g = gainEps(data,feature,target,targets,selectEps(eps,index));
    return g;
  });
  return maxgain;
}

function distribution (table) {
  var d={};
  table.forEach(function (row) {
    if (Utils.isArray(row)) row.forEach(function (v) { 
      if (d[v]==undefined) d[v]=1; else d[v]++ });
    else { if (d[row]==undefined) d[row]=1; else d[row]++ };
  })
  return d;
}
function histogram (vector,delta,min,max) {
  if (vector instanceof Array) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.length;i++) {
      var chan=Math.floor((vector[i]-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h};
  }
  if (Utils.isVector(vector)) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.length;i++) {
      var chan=Math.floor((vector.get(i)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isMatrix(vector)) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.rows;i++) for(var j=0;j<vector.columns;j++) {
      var chan=Math.floor((vector.get(i,j)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isVectorTA(vector)) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var j=0;j<vector.columns;j++) {
      var chan=Math.floor((vector.get(j)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isMatrixTA(vector)) {
    var minmax = vector.minmax();
    if (min==undefined) min=minmax.min;
    if (max==undefined) max=minmax.max;
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.rows;i++) for(var j=0;j<vector.columns;j++) {
      var chan=Math.floor((vector.get(i,j)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isTypedArray(vector)) {
    var _min=vector[0],_max=vector[0];
    for(var i=0;i<vector.length;i++) {
      _min=Math.min(_min,vector[i]);
      _max=Math.max(_max,vector[i]);
    }
    if (min==undefined) min=_min;
    if (max==undefined) max=_max;
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var j=0;j<vector.length;j++) {
      var chan=Math.floor((vector[j]-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
}

function smN (vector,N) {
  var xm=vector.sum()/vector.length;
  return vector.map(function (x) { return Math.pow(x-xm,N) }).sum() 
}
function nans(vector) {
  var n=0; for(var i in vector) if (isNaN(vector[i])) n++;
  return n
}
function zeros(vector) {
  var n=0; for(var i in vector) if (vector[i]==0) n++;
  return n
}
exports.BayesianClassifier = BayesianClassifier;
exports.PerceptronModel = PerceptronModel;
exports.addToMean = addToMean;
exports.average = mean;
exports.averageSimple = meanSimple;
exports.bayesian = BayesianClassifier;
exports.bernoulliDistribution = bernoulliDistribution;
exports.binomialDistribution = binomialDistribution;
exports.bisect = bisect;
exports.chiSquaredDistributionTable = chiSquaredDistributionTable;
exports.chiSquaredGoodnessOfFit = chiSquaredGoodnessOfFit;
exports.chunk = chunk;
exports.ckmeans = ckmeans;
exports.combinations = combinations;
exports.combinationsReplacement = combinationsReplacement;
exports.combineMeans = combineMeans;
exports.combineVariances = combineVariances;
exports.cumulativeStdNormalProbability = cumulativeStdNormalProbability;
exports.distribution = distribution;
exports.epsilon = epsilon;
exports.equalIntervalBreaks = equalIntervalBreaks;
exports.erf = errorFunction;
exports.errorFunction = errorFunction;
exports.extent = extent;
exports.extentSorted = extentSorted;
exports.factorial = factorial;
exports.gamma = gamma;
exports.gammaln = gammaln;
exports.geometricMean = geometricMean;
exports.harmonicMean = harmonicMean;
exports.histogram = histogram;
exports.interquartileRange = interquartileRange;
exports.inverseErrorFunction = inverseErrorFunction;
exports.iqr = interquartileRange;
exports.kde = kernelDensityEstimation;
exports.kernelDensityEstimation = kernelDensityEstimation;
exports.linearRegression = linearRegression;
exports.linearRegressionLine = linearRegressionLine;
exports.mad = medianAbsoluteDeviation;
exports.max = max;
exports.maxSorted = maxSorted;
exports.mean = mean;
exports.meanSimple = meanSimple;
exports.median = median;
exports.medianAbsoluteDeviation = medianAbsoluteDeviation;
exports.medianSorted = medianSorted;
exports.min = min;
exports.minSorted = minSorted;
exports.mode = mode;
exports.modeFast = modeFast;
exports.modeSorted = modeSorted;
exports.nans = nans;
exports.numericSort = numericSort;
exports.perceptron = PerceptronModel;
exports.permutationTest = permutationTest;
exports.permutationsHeap = permutationsHeap;
exports.poissonDistribution = poissonDistribution;
exports.probit = probit;
exports.product = product;
exports.quantile = quantile;
exports.quantileRank = quantileRank;
exports.quantileRankSorted = quantileRankSorted;
exports.quantileSorted = quantileSorted;
exports.quickselect = quickselect;
exports.rSquared = rSquared;
exports.rms = rootMeanSquare;
exports.rootMeanSquare = rootMeanSquare;
exports.sample = sample;
exports.sampleCorrelation = sampleCorrelation;
exports.sampleCovariance = sampleCovariance;
exports.sampleKurtosis = sampleKurtosis;
exports.sampleSkewness = sampleSkewness;
exports.sampleStandardDeviation = sampleStandardDeviation;
exports.sampleVariance = sampleVariance;
exports.sampleWithReplacement = sampleWithReplacement;
exports.shuffle = shuffle;
exports.shuffleInPlace = shuffleInPlace;
exports.sign = sign;
exports.standardDeviation = standardDeviation;
exports.standardNormalTable = standardNormalTable;
exports.subtractFromMean = subtractFromMean;
exports.sm2 = function (v) { return smN(v,2) };
exports.sm3 = function (v) { return smN(v,3) };
exports.sm4 = function (v) { return smN(v,4) };
exports.sum = sum;
exports.sumNthPowerDeviations = sumNthPowerDeviations;
exports.sumSimple = sumSimple;
exports.tTest = tTest;
exports.tTestTwoSample = tTestTwoSample;
exports.uniqueCountSorted = uniqueCountSorted;
exports.uniqueSorted = uniqueSorted;
exports.variance = variance;
exports.zeros = zeros;
exports.zScore = zScore;


// Full statistical analysis of a data set
function analysis (data,options) {
  var i,numeric,column;
  options=options||{};
  function analize(column,options) {
    var numeric=options.numeric;
    if (numeric == undefined) {
        numeric = column.filter(function (row) {
        return isNaN(Number(row))
      }).length==0; 
    }
    if (numeric) {
      var sm2=smN(column,2),sm3=smN(column,3),
          sm4=smN(column,4),n = column.length;;
      return {
        covariance : sampleCovariance(column,column),
        kurtosis : n*sm4/(sm2*sm2),
        mean    : mean(column),
        median  : median(column),
        medianAbsoluteDeviation:medianAbsoluteDeviation(column),
        min     : min(column),
        max     : max(column),
        n       : n,
        nan     : nans(column),
        rootMeanSquare:rootMeanSquare(column),
        skewness : Math.sqrt(n)*sm3/(sm2*Math.sqrt(sm2)),
        sm2     : sm2,
        sm3     : sm3,
        sm4     : sm4,
        standardDeviation:standardDeviation(column),
        sum     : sum(column),
        uniqueCountSorted:uniqueCountSorted(column),
        variance:variance(column),
        zeros   : zeros(column),
      }
    } else {
      return {
        distribution:distribution(column),
        entropy:entropy(column),
        mostCommon:mostCommon(column),
        unique:uniqueSorted(column),
      }
    }
  }
  if (Utils.isMatrix(data)) {
    return data[0].map(function (x,i) {
      return analize(data.pluck(i),{
        numeric:typeof options.numeric == 'boolean'?options.numeric:
                (Utils.isArray(options.numeric)?options.numeric[i]:undefined)
      });
    })
  } else
    return analize(data,options); // todo: matrix
}
exports.analysis = analysis;

};
BundleModuleCode['plugins/math/dwt5']=function (module,exports,global,process){
/* https://github.com/Symmetronic/discrete-wavelets */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.wt = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /**
     * Antisymmetric padding.
     */
    var ANTISYMMETRIC_PADDING = 'antisymmetric';
    /**
     * Returns a single value of antisymmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function antisymmetricPadding$$1(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        var dirChanges = Math.floor(index / data.length);
        var sign = (dirChanges % 2 === 0) ? -1 : 1;
        return sign * symmetricPadding(data, index, inverse);
    }

    /**
     * Constant padding.
     */
    var CONSTANT_PADDING = 'constant';
    /**
     * Returns a single value of constant padding.
     * @param  data    Input values.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function constantPadding(data, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine constant padding for data of zero length.');
        }
        /* Determine constant padding. */
        return (!inverse)
            ? data[data.length - 1]
            : data[0];
    }

    /**
     * Periodic padding.
     */
    var PERIODIC_PADDING = 'periodic';
    /**
     * Returns a single value of periodic padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function periodicPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine periodic padding for data of zero length.');
        }
        /* Determine periodic padding. */
        return (!inverse)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Reflect padding.
     */
    var REFLECT_PADDING = 'reflect';
    /**
     * Returns a single value of reflect padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function reflectPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine reflect padding for data of zero length.');
        }
        /* Return constant value for data of length one. */
        if (data.length === 1)
            return data[0];
        /* Determine reflect padding. */
        var dirChanges = Math.floor(index / (data.length - 1));
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % (data.length - 1) + 1]
            : data[data.length - 2 - (index % (data.length - 1))];
    }

    /**
     * Smooth padding.
     */
    var SMOOTH_PADDING = 'smooth';
    /**
     * Returns a single value of smooth padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function smoothPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine smooth padding for data of zero length.');
        }
        /* Determine line equation. */
        var end = data.length - 1;
        var offset = (inverse) ? data[0] : data[end];
        var slope = (inverse)
            ? (data.length === 1) ? data[0] : data[0] - data[1]
            : (data.length === 1) ? -data[0] : data[end] - data[end - 1];
        return offset + (index + 1) * slope;
    }

    /**
     * Symmetric padding.
     */
    var SYMMETRIC_PADDING = 'symmetric';
    /**
     * Returns a single value of symmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function symmetricPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine symmetric padding for data of zero length.');
        }
        /* Determine symmetric padding. */
        var dirChanges = Math.floor(index / data.length);
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Zero padding.
     */
    var ZERO_PADDING = 'zero';
    /**
     * Returns a single value of zero padding.
     * @return         Single padding value.
     */
    function zeroPadding() {
        return 0;
    }

    /**
     * Supported signal extension modes.
     */
    var PADDING_MODES = {
        antisymmetric: ANTISYMMETRIC_PADDING,
        constant: CONSTANT_PADDING,
        periodic: PERIODIC_PADDING,
        reflect: REFLECT_PADDING,
        smooth: SMOOTH_PADDING,
        symmetric: SYMMETRIC_PADDING,
        zero: ZERO_PADDING,
        modes: [
            ZERO_PADDING,
            CONSTANT_PADDING,
            SYMMETRIC_PADDING,
            PERIODIC_PADDING,
            SMOOTH_PADDING,
            REFLECT_PADDING,
            ANTISYMMETRIC_PADDING,
        ],
    };

    // SOURCE: https://github.com/PyWavelets/pywt/blob/master/pywt/_extensions/c/wavelets_coeffs.template.h
    /**
     * Haar wavelet scaling numbers.
     */
    var HaarWavelet = [
        1 / Math.SQRT2,
        1 / Math.SQRT2
    ];
    /**
     * Daubechies 2 scaling numbers.
     */
    var Db2Wavelet = [
        (1 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 - Math.sqrt(3)) / (4 * Math.SQRT2),
        (1 - Math.sqrt(3)) / (4 * Math.SQRT2)
    ];
    /**
     * Daubechies 3 scaling numbers.
     */
    var Db3Wavelet = [
        3.326705529500826159985115891390056300129233992450683597084705e-01,
        8.068915093110925764944936040887134905192973949948236181650920e-01,
        4.598775021184915700951519421476167208081101774314923066433867e-01,
        -1.350110200102545886963899066993744805622198452237811919756862e-01,
        -8.544127388202666169281916918177331153619763898808662976351748e-02,
        3.522629188570953660274066471551002932775838791743161039893406e-02
    ];
    /**
     * Daubechies 4 scaling numbers.
     */
    var Db4Wavelet = [
        2.303778133088965008632911830440708500016152482483092977910968e-01,
        7.148465705529156470899219552739926037076084010993081758450110e-01,
        6.308807679298589078817163383006152202032229226771951174057473e-01,
        -2.798376941685985421141374718007538541198732022449175284003358e-02,
        -1.870348117190930840795706727890814195845441743745800912057770e-01,
        3.084138183556076362721936253495905017031482172003403341821219e-02,
        3.288301166688519973540751354924438866454194113754971259727278e-02,
        -1.059740178506903210488320852402722918109996490637641983484974e-02
    ];
    /**
     * Daubechies 5 scaling numbers.
     */
    var Db5Wavelet = [
        1.601023979741929144807237480204207336505441246250578327725699e-01,
        6.038292697971896705401193065250621075074221631016986987969283e-01,
        7.243085284377729277280712441022186407687562182320073725767335e-01,
        1.384281459013207315053971463390246973141057911739561022694652e-01,
        -2.422948870663820318625713794746163619914908080626185983913726e-01,
        -3.224486958463837464847975506213492831356498416379847225434268e-02,
        7.757149384004571352313048938860181980623099452012527983210146e-02,
        -6.241490212798274274190519112920192970763557165687607323417435e-03,
        -1.258075199908199946850973993177579294920459162609785020169232e-02,
        3.335725285473771277998183415817355747636524742305315099706428e-03
    ];
    /**
     * Daubechies 6 scaling numbers.
     */
    var Db6Wavelet = [
        1.115407433501094636213239172409234390425395919844216759082360e-01,
        4.946238903984530856772041768778555886377863828962743623531834e-01,
        7.511339080210953506789344984397316855802547833382612009730420e-01,
        3.152503517091976290859896548109263966495199235172945244404163e-01,
        -2.262646939654398200763145006609034656705401539728969940143487e-01,
        -1.297668675672619355622896058765854608452337492235814701599310e-01,
        9.750160558732304910234355253812534233983074749525514279893193e-02,
        2.752286553030572862554083950419321365738758783043454321494202e-02,
        -3.158203931748602956507908069984866905747953237314842337511464e-02,
        5.538422011614961392519183980465012206110262773864964295476524e-04,
        4.777257510945510639635975246820707050230501216581434297593254e-03,
        -1.077301085308479564852621609587200035235233609334419689818580e-03
    ];
    /**
     * Daubechies 7 scaling numbers.
     */
    var Db7Wavelet = [
        7.785205408500917901996352195789374837918305292795568438702937e-02,
        3.965393194819173065390003909368428563587151149333287401110499e-01,
        7.291320908462351199169430703392820517179660611901363782697715e-01,
        4.697822874051931224715911609744517386817913056787359532392529e-01,
        -1.439060039285649754050683622130460017952735705499084834401753e-01,
        -2.240361849938749826381404202332509644757830896773246552665095e-01,
        7.130921926683026475087657050112904822711327451412314659575113e-02,
        8.061260915108307191292248035938190585823820965629489058139218e-02,
        -3.802993693501441357959206160185803585446196938467869898283122e-02,
        -1.657454163066688065410767489170265479204504394820713705239272e-02,
        1.255099855609984061298988603418777957289474046048710038411818e-02,
        4.295779729213665211321291228197322228235350396942409742946366e-04,
        -1.801640704047490915268262912739550962585651469641090625323864e-03,
        3.537137999745202484462958363064254310959060059520040012524275e-04
    ];
    /**
     * Daubechies 8 scaling numbers.
     */
    var Db8Wavelet = [
        5.441584224310400995500940520299935503599554294733050397729280e-02,
        3.128715909142999706591623755057177219497319740370229185698712e-01,
        6.756307362972898068078007670471831499869115906336364227766759e-01,
        5.853546836542067127712655200450981944303266678053369055707175e-01,
        -1.582910525634930566738054787646630415774471154502826559735335e-02,
        -2.840155429615469265162031323741647324684350124871451793599204e-01,
        4.724845739132827703605900098258949861948011288770074644084096e-04,
        1.287474266204784588570292875097083843022601575556488795577000e-01,
        -1.736930100180754616961614886809598311413086529488394316977315e-02,
        -4.408825393079475150676372323896350189751839190110996472750391e-02,
        1.398102791739828164872293057263345144239559532934347169146368e-02,
        8.746094047405776716382743246475640180402147081140676742686747e-03,
        -4.870352993451574310422181557109824016634978512157003764736208e-03,
        -3.917403733769470462980803573237762675229350073890493724492694e-04,
        6.754494064505693663695475738792991218489630013558432103617077e-04,
        -1.174767841247695337306282316988909444086693950311503927620013e-04
    ];
    /**
     * Daubechies 9 scaling numbers.
     */
    var Db9Wavelet = [
        3.807794736387834658869765887955118448771714496278417476647192e-02,
        2.438346746125903537320415816492844155263611085609231361429088e-01,
        6.048231236901111119030768674342361708959562711896117565333713e-01,
        6.572880780513005380782126390451732140305858669245918854436034e-01,
        1.331973858250075761909549458997955536921780768433661136154346e-01,
        -2.932737832791749088064031952421987310438961628589906825725112e-01,
        -9.684078322297646051350813353769660224825458104599099679471267e-02,
        1.485407493381063801350727175060423024791258577280603060771649e-01,
        3.072568147933337921231740072037882714105805024670744781503060e-02,
        -6.763282906132997367564227482971901592578790871353739900748331e-02,
        2.509471148314519575871897499885543315176271993709633321834164e-04,
        2.236166212367909720537378270269095241855646688308853754721816e-02,
        -4.723204757751397277925707848242465405729514912627938018758526e-03,
        -4.281503682463429834496795002314531876481181811463288374860455e-03,
        1.847646883056226476619129491125677051121081359600318160732515e-03,
        2.303857635231959672052163928245421692940662052463711972260006e-04,
        -2.519631889427101369749886842878606607282181543478028214134265e-04,
        3.934732031627159948068988306589150707782477055517013507359938e-05
    ];
    /**
     * Daubechies 10 scaling numbers.
     */
    var Db10Wavelet = [
        2.667005790055555358661744877130858277192498290851289932779975e-02,
        1.881768000776914890208929736790939942702546758640393484348595e-01,
        5.272011889317255864817448279595081924981402680840223445318549e-01,
        6.884590394536035657418717825492358539771364042407339537279681e-01,
        2.811723436605774607487269984455892876243888859026150413831543e-01,
        -2.498464243273153794161018979207791000564669737132073715013121e-01,
        -1.959462743773770435042992543190981318766776476382778474396781e-01,
        1.273693403357932600826772332014009770786177480422245995563097e-01,
        9.305736460357235116035228983545273226942917998946925868063974e-02,
        -7.139414716639708714533609307605064767292611983702150917523756e-02,
        -2.945753682187581285828323760141839199388200516064948779769654e-02,
        3.321267405934100173976365318215912897978337413267096043323351e-02,
        3.606553566956169655423291417133403299517350518618994762730612e-03,
        -1.073317548333057504431811410651364448111548781143923213370333e-02,
        1.395351747052901165789318447957707567660542855688552426721117e-03,
        1.992405295185056117158742242640643211762555365514105280067936e-03,
        -6.858566949597116265613709819265714196625043336786920516211903e-04,
        -1.164668551292854509514809710258991891527461854347597362819235e-04,
        9.358867032006959133405013034222854399688456215297276443521873e-05,
        -1.326420289452124481243667531226683305749240960605829756400674e-05
    ];

    /**
     * Mapping of wavelet type keys to scaling numbers.
     */
    var ScalingNumbers = {
        'db1': HaarWavelet,
        'db2': Db2Wavelet,
        'db3': Db3Wavelet,
        'db4': Db4Wavelet,
        'db5': Db5Wavelet,
        'db6': Db6Wavelet,
        'db7': Db7Wavelet,
        'db8': Db8Wavelet,
        'db9': Db9Wavelet,
        'db10': Db10Wavelet,
        'D2': HaarWavelet,
        'D4': Db2Wavelet,
        'D6': Db3Wavelet,
        'D8': Db4Wavelet,
        'D10': Db5Wavelet,
        'D12': Db6Wavelet,
        'D14': Db7Wavelet,
        'D16': Db8Wavelet,
        'D18': Db9Wavelet,
        'D20': Db10Wavelet,
        'haar': HaarWavelet,
    };

    /**
     * Calculates the element-wise sum of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Element-wise sum.
     */
    function add(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate element-wise sum. */
        return a.map(function (value, index) { return value + b[index]; });
    }
    /**
     * Asserts if approximation and detail coefficients are valid or throws an
     * error if they are invalid.
     * @param  approx Approximation coefficients.
     * @param  detail Detail coefficients.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidApproxDetail(approx, detail) {
        /* Check if coefficients have equal length. */
        if (approx.length !== detail.length) {
            throw new Error('Approximation and detail coefficients must have equal length.');
        }
        /* Check for coefficients of zero length. */
        if (approx.length === 0) {
            throw new Error('Approximation and detail coefficients must not have zero length.');
        }
        return true;
    }
    /**
     * Asserts if coefficients are valid or throws an error if they are invalid.
     * @param  coeffs Coefficients to test.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidCoeffs(coeffs) {
        /* Check if at least an array of approximation coefficients is given. */
        if (coeffs.length < 1) {
            throw new Error('Invalid coefficients. Array length must not be zero.');
        }
        return true;
    }
    /**
     * Asserts if wavelet filters are valid or throws an error if they are invalid.
     * @param  filters Wavelet filters to test.
     * @return         True if the wavelet filters are valid, otherwise throws an error.
     */
    function assertValidFilters(filters) {
        /* Check if high-pass and low-pass filters have equal length. */
        if (filters.high.length !== filters.low.length) {
            throw new Error('High-pass and low-pass filters have to have equal length.');
        }
        /* Check if filter length is larger than or equal to two. */
        if (filters.low.length < 2) {
            throw new Error('Wavelet filter length has to be larger than or equal to two.');
        }
        return true;
    }
    /**
     * Determines a wavelet basis from a wavelet type or basis.
     * @param  wavelet Wavelet type or basis.
     * @return         Wavelet basis.
     */
    function basisFromWavelet(wavelet) {
        return (typeof wavelet !== 'string')
            ? wavelet
            : waveletFromScalingNumbers(ScalingNumbers[wavelet]);
    }
    /**
     * Creates an array and populates it.
     * @param  length   Length of the array.
     * @param  populate Function to populate the array.
     * @return          Populated array with specified length.
     */
    function createArray(length, populate) {
        if (populate === void 0) { populate = 0; }
        /* Check for non-integer length. */
        if (!Number.isInteger(length)) {
            throw new Error('Length has to be an integer.');
        }
        /* Check for length less than zero. */
        if (length < 0) {
            throw new Error('Length must not be smaller than zero.');
        }
        /* Create and populate array. */
        return Array.apply(null, Array(length)).map(function (_, index) {
            return (typeof populate === 'function')
                ? populate(index)
                : populate;
        });
    }
    /**
     * Calculates the dot product of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Dot product.
     */
    function dot(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate dot product. */
        return a.reduce(function (dot, value, index) { return dot + value * b[index]; }, 0);
    }
    /**
     * Multiplies an array with a scalar value.
     * @param  scalar Scalar value.
     * @param  array  Array of numbers.
     * @return        Array multiplied with scalar value.
     */
    function mulScalar(scalar, array) {
        return array.map(function (value) { return scalar * value; });
    }
    /**
     * Returns a single padding element.
     * @param  data    Input data.
     * @param  index   Index of padding element.
     * @param  inverse True if the padding direction is inversed.
     * @param  mode    Signal extension mode.
     * @return         Single padding element.
     */
    function padElement(data, index, inverse, mode) {
        switch (mode) {
            case PADDING_MODES.antisymmetric:
                return antisymmetricPadding$$1(data, index, inverse);
            case PADDING_MODES.constant:
                return constantPadding(data, inverse);
            case PADDING_MODES.periodic:
                return periodicPadding(data, index, inverse);
            case PADDING_MODES.reflect:
                return reflectPadding(data, index, inverse);
            case PADDING_MODES.smooth:
                return smoothPadding(data, index, inverse);
            case PADDING_MODES.symmetric:
                return symmetricPadding(data, index, inverse);
            case PADDING_MODES.zero:
                return zeroPadding();
            default:
                throw new Error('Unknown signal extension mode: "' + mode + '"');
        }
    }
    /**
     * Determines the padding widths.
     * @param  dataLength   Length of signal.
     * @param  filterLength Length of filter.
     * @return              Padding widths.
     */
    function padWidths(dataLength, filterLength) {
        /* Check for valid data length. */
        if (dataLength <= 0) {
            throw new Error('Cannot determine padding widths for data of length less than or equal to zero.');
        }
        /* Check for valid filter length. */
        if (filterLength < 2) {
            throw new Error('Cannot determine padding widths for filter of length less than two.');
        }
        /* Determine padding widths. */
        return [
            filterLength - 2,
            ((dataLength + filterLength) % 2 === 0)
                ? filterLength - 2
                : filterLength - 1
        ];
    }
    /**
     * Determines a wavelet basis from scaling numbers.
     * @param  scalingNumbers Wavelet scaling numbers.
     * @return                Wavelet basis.
     */
    function waveletFromScalingNumbers(scalingNumbers) {
        /* Check if length is larger than or equal to two. */
        if (scalingNumbers.length < 2) {
            throw new Error('Scaling numbers length has to be larger than or equal to two.');
        }
        /* Determine wavelet numbers. */
        var waveletNumbers = scalingNumbers.slice() // Copy array
            .reverse()
            .map(function (value, index) { return (index % 2 === 0) ? value : -value; });
        /* Determine wavelet basis. */
        return {
            dec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers
            },
            rec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers.slice()
            },
        };
    }

    /**
     * Default padding mode to use.
     */
    var DEFAULT_PADDING_MODE = PADDING_MODES.symmetric;
    /**
     * Collection of methods for Discrete Wavelet Transform (DWT).
     */
    var DiscreteWavelets = /** @class */ (function () {
        function DiscreteWavelets() {
        }
        /**
         * Single level Discrete Wavelet Transform.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @return         Approximation and detail coefficients as result of the transform.
         */
        DiscreteWavelets.dwt = function (data, wavelet, mode) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.dec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Add padding. */
            data = this.pad(data, padWidths(data.length, filterLength), mode);
            /* Initialize approximation and detail coefficients. */
            var approx = [];
            var detail = [];
            /* Calculate coefficients. */
            for (var offset = 0; offset + filterLength <= data.length; offset += 2) {
                /* Determine slice of values. */
                var values = data.slice(offset, offset + filterLength);
                /* Calculate approximation coefficients. */
                approx.push(dot(values, filters.low));
                /* Calculate detail coefficients. */
                detail.push(dot(values, filters.high));
            }
            /* Return approximation and detail coefficients. */
            return [approx, detail];
        };
        /**
         * Calculates the energy as sum of squares of an array of data or
         * coefficients.
         * @param  values Array of data or coefficients.
         * @return        Energy of values as the sum of squares.
         */
        DiscreteWavelets.energy = function (values) {
            var energy = 0;
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var value = values_1[_i];
                if (!Array.isArray(value))
                    energy += Math.pow(value, 2);
                else
                    energy += this.energy(value);
            }
            return energy;
        };
        /**
         * Single level inverse Discrete Wavelet Transform.
         * @param  approx  Approximation coefficients. If undefined, it will be set to an array of zeros with length equal to the detail coefficients.
         * @param  detail  Detail coefficients. If undefined, it will be set to an array of zeros with length equal to the approximation coefficients.
         * @param  wavelet Wavelet to use.
         * @return         Approximation coefficients of previous level of transform.
         */
        DiscreteWavelets.idwt = function (approx, detail, wavelet) {
            /* Fill empty array with zeros. */
            if (approx === undefined && detail !== undefined) {
                approx = createArray(detail.length, 0);
            }
            if (detail === undefined && approx !== undefined) {
                detail = createArray(approx.length, 0);
            }
            /* Check if some coefficients are undefined. */
            if (approx === undefined || detail === undefined) {
                throw new Error('Coefficients must not be undefined.');
            }
            assertValidApproxDetail(approx, detail);
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.rec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Initialize transform. */
            var coeffLength = approx.length;
            var pad = createArray(filterLength + (coeffLength - 1) * 2, 0);
            /* Perform inverse Discrete Wavelet Transform. */
            for (var i = 0; i < coeffLength; i++) {
                var offset = 2 * i;
                /* Calculate values. */
                var values = pad.slice(offset, offset + filterLength);
                values = add(values, mulScalar(approx[i], filters.low));
                values = add(values, mulScalar(detail[i], filters.high));
                /* Update values. */
                pad.splice.apply(pad, __spreadArrays([offset, filterLength], values));
            }
            /* Remove padding. */
            return pad.slice(filterLength - 2, pad.length - (filterLength - 2));
        };
        /**
         * Determines the maximum level of useful decomposition.
         * @param  dataLength Length of input data.
         * @param  wavelet    Wavelet to use.
         * @return            Maximum useful level of decomposition.
         */
        DiscreteWavelets.maxLevel = function (dataLength, wavelet) {
            /* Check for non-integer length. */
            if (!Number.isInteger(dataLength)) {
                throw new Error('Length of data is not an integer. This is not allowed.');
            }
            /* Check for invalid input. */
            if (dataLength < 0) {
                throw new Error('Data length cannot be less than zero.');
            }
            /* Return zero for data of zero length. */
            if (dataLength === 0)
                return 0;
            /* Determine wavelet basis. */
            var waveletBasis = basisFromWavelet(wavelet);
            /* Determine length of filter. */
            var filterLength = waveletBasis.dec.low.length;
            // SOURCE: https://pywavelets.readthedocs.io/en/latest/ref/dwt-discrete-wavelet-transform.html#maximum-decomposition-level-dwt-max-level-dwtn-max-level
            return Math.max(0, Math.floor(Math.log2(dataLength / (filterLength - 1))));
        };
        /**
         * Extends a signal with a given padding mode.
         * @param  data      Input data.
         * @param  padWidths Widths of padding at front and back.
         * @param  mode      Signal extension mode.
         * @return           Data with padding.
         */
        DiscreteWavelets.pad = function (data, padWidths$$1, mode) {
            /* Check for undefined data. */
            if (!data) {
                throw new Error('Cannot add padding to empty data.');
            }
            /* Initialize. */
            var front = padWidths$$1[0];
            var back = padWidths$$1[1];
            /* Add padding. */
            return createArray(front, function (index) {
                return padElement(data, (front - 1 - index), true, mode);
            })
                .concat(data)
                .concat(createArray(back, function (index) {
                return padElement(data, index, false, mode);
            }));
        };
        
        /**
         *  Expand each row of the data matrix (returned, e.g., by wavedec) with respect
         *  to the widest row. Mode specifies the interpolation function (default: 'step').
         */
        DiscreteWavelets.expand = function (data, mode) {
          var len=0,dataX=[];
          for(var row in data) len=Math.max(len,data[row].length); 
          switch (mode) {
            case 'step':
            default:
              // simple; extend each data point
              for(row in data) {
                if (data[row].length!=len) {
                  var frag=Math.floor(len/data[row].length);
                  dataX[row]=[];
                  for(var col=0; col < data[row].length; col++) {
                    dataX[row].push(Array.init(frag,data[row][col]));
                  }
                  dataX[row]=dataX[row].flat();
                } else dataX.push(data[row]);
              }
          }
          return dataX;
        };
        
        /**
         * 1D wavelet decomposition. Transforms data by calculating multi-level coefficients from
         * input data.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @param  level   Decomposition level. Defaults to level calculated by maxLevel function.
         * @return         Coefficients as result of the transform.
         */
        DiscreteWavelets.wavedec = function (data, wavelet, mode, level) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine decomposition level. */
            if (level === undefined)
                level = this.maxLevel(data.length, wavelet);
            if (level < 0) {
                throw new Error('Decomposition level must not be less than zero');
            }
            /*  Initialize transform. */
            var coeffs = [];
            var approx = data;
            /* Transform. */
            for (var l = 1; l <= level; l++) {
                /* Perform single level transform. */
                var approxDetail = this.dwt(approx, wavelet, mode);
                approx = approxDetail[0];
                var detail = approxDetail[1];
                /* Prepend detail coefficients. */
                coeffs.unshift(detail);
            }
            /* Prepend last approximation. */
            // coeffs.unshift(approx);
            /* Return coefficients. */
            return coeffs.reverse();
        };
        /**
         * 1D wavelet reconstruction. Inverses a transform by calculating input data
         * from coefficients.
         * @param  coeffs  Coefficients as result of a transform.
         * @param  wavelet Wavelet to use.
         * @return         Input data as result of the inverse transform.
         */
        DiscreteWavelets.waverec = function (coeffs, wavelet) {
            /* Check if coefficients are valid. */
            assertValidCoeffs(coeffs);
            /* Determine wavelet. */
            wavelet = basisFromWavelet(wavelet);
            /* Initialize transform. */
            var approx = coeffs[0];
            /* Transform. */
            for (var i = 1; i < coeffs.length; i++) {
                /* Initialize detail coefficients. */
                var detail = coeffs[i];
                // TODO: Check if problem of different coefficient lengths because of padding can be solved in a more elegant way.
                if (approx.length === detail.length + 1) {
                    approx = approx.slice(0, approx.length - 1);
                }
                /* Calculate previous level of approximation. */
                approx = this.idwt(approx, detail, wavelet);
            }
            /* Return data. */
            return approx;
        };
        /**
         * Contains static information about the signal extension modes.
         */
        DiscreteWavelets.Modes = PADDING_MODES;
        return DiscreteWavelets;
    }());

    return DiscreteWavelets;

})));
//# sourceMappingURL=discrete-wavelets.umd.js.map
};
BundleModuleCode['plugins/math/numeric']=function (module,exports,global,process){
// https://github.com/sloisel/numeric

"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
};
BundleModuleCode['plugins/math/regression']=function (module,exports,global,process){
// https://github.com/Tom-Alexander/regression-js
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.regression = mod.exports;
  }
})(this, function (module) {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

  /**
  * Determine the coefficient of determination (r^2) of a fit from the observations
  * and predictions.
  *
  * @param {Array<Array<number>>} data - Pairs of observed x-y values
  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
  *
  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
  */
  function determinationCoefficient(data, results) {
    var predictions = [];
    var observations = [];

    data.forEach(function (d, i) {
      if (d[1] !== null) {
        observations.push(d);
        predictions.push(results[i]);
      }
    });

    var sum = observations.reduce(function (a, observation) {
      return a + observation[1];
    }, 0);
    var mean = sum / observations.length;

    var ssyy = observations.reduce(function (a, observation) {
      var difference = observation[1] - mean;
      return a + difference * difference;
    }, 0);

    var sse = observations.reduce(function (accum, observation, index) {
      var prediction = predictions[index];
      var residual = observation[1] - prediction[1];
      return accum + residual * residual;
    }, 0);

    return 1 - sse / ssyy;
  }

  /**
  * Determine the solution of a system of linear equations A * x = b using
  * Gaussian elimination.
  *
  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
  * @param {number} order - How many degrees to solve for
  *
  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
  */
  function gaussianElimination(input, order) {
    var matrix = input;
    var n = input.length - 1;
    var coefficients = [order];

    for (var i = 0; i < n; i++) {
      var maxrow = i;
      for (var j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (var k = i; k < n + 1; k++) {
        var tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (var _j = i + 1; _j < n; _j++) {
        for (var _k = n; _k >= i; _k--) {
          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
        }
      }
    }

    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
      var total = 0;
      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
        total += matrix[_k2][_j2] * coefficients[_k2];
      }

      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
    }

    return coefficients;
  }

  /**
  * Round a number to a precision, specificed in number of decimal places
  *
  * @param {number} number - The number to round
  * @param {number} precision - The number of decimal places to round to:
  *                             > 0 means decimals, < 0 means powers of 10
  *
  *
  * @return {numbr} - The number, rounded
  */
  function round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
  * The set of all fitting methods
  *
  * @namespace
  */
  var methods = {
    linear: function linear(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = 0;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          len++;
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      var run = len * sum[2] - sum[0] * sum[0];
      var rise = len * sum[3] - sum[0] * sum[1];
      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [gradient, intercept],
        r2: round(determinationCoefficient(data, points), options.precision),
        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
      };
    },
    exponential: function exponential(data, options) {
      var sum = [0, 0, 0, 0, 0, 0];

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
      var coeffA = round(a, options.precision);
      var coeffB = round(b, options.precision);
      var predict = function predict(x) {
        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    logarithmic: function logarithmic(data, options) {
      var sum = [0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      var coeffB = round(a, options.precision);
      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    power: function power(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
      var a = (sum[2] - b * sum[0]) / len;
      var coeffA = round(Math.exp(a), options.precision);
      var coeffB = round(b, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'x^' + coeffB,
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    polynomial: function polynomial(data, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var len = data.length;
      var k = options.order + 1;

      for (var i = 0; i < k; i++) {
        for (var l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        var c = [];
        for (var j = 0; j < k; j++) {
          for (var _l = 0; _l < len; _l++) {
            if (data[_l][1] !== null) {
              b += Math.pow(data[_l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      var coefficients = gaussianElimination(rhs, k).map(function (v) {
        return round(v, options.precision);
      });

      var predict = function predict(x) {
        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      var string = [];
      for (var _i = 0; _i <coefficients.length; _i++) {
        if (_i > 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*Math.pow(x,' + _i + '))');
        } else if (_i === 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*x)');
        } else if (coefficients[_i] !== 0) {
          string.push('('+coefficients[_i]+')');
        }
      }
      string=string.join('+');

      return {
        string: string,
        points: points,
        predict: predict,
        equation: [].concat(_toConsumableArray(coefficients)),
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    }
  };

  function createWrapper() {
    var reduce = function reduce(accumulator, name) {
      return _extends({
        _round: round
      }, accumulator, _defineProperty({}, name, function (data, supplied) {
        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
      }));
    };

    return Object.keys(methods).reduce(reduce, {});
  }

  module.exports = createWrapper();
});
};
BundleModuleCode['plugins/math/polyfit']=function (module,exports,global,process){
// Requirement: https://github.com/sloisel/numeric/blob/master/src/numeric.js

var numeric = Require('plugins/math/numeric')

// Find the best-fit curve for an nth order polynomial.
function polyfit(xArray, yArray, order) {

  if (xArray.length <= order) console.warn("Warning: Polyfit may be poorly conditioned.")

  var xMatrix = []
  var yMatrix = numeric.transpose([yArray])

  for (var i = 0; i < xArray.length; i++) {

    var temp = []

    for (var j = 0; j <= order; j++) {

      temp.push(Math.pow(xArray[i], j))

    }

    xMatrix.push(temp)

  }

  var xMatrixT = numeric.transpose(xMatrix)

  var dot1 = numeric.dot(xMatrixT, xMatrix)
  var dot2 = numeric.dot(xMatrixT, yMatrix)

  var dotInv = numeric.inv(dot1)

  var coefficients = numeric.dot(dotInv, dot2)

  return coefficients.unwrap().reverse()

}

// Predict y given x.
function predict(x, coefficients) {

  var prediction = 0

  for (var i = 0; i < coefficients.length; i++) {

    prediction += coefficients[i] * Math.pow(x, i)

  }

  return prediction

}

// Evaluate model accuracy.
function rSquared(x, y, coefficients) {

  var regressionSquaredError = 0
  var totalSquaredError = 0

  var yMean = y.reduce((a, b) => a + b) / y.length

  for (var i = 0; i < x.length; i++) {

    regressionSquaredError += Math.pow(y[i] - predict(x[i], coefficients), 2)
    totalSquaredError += Math.pow(y[i] - yMean, 2)

  }

  return 1 - (regressionSquaredError / totalSquaredError)

}

module.exports = polyfit
};
BundleModuleCode['plugins/math/smoothers']=function (module,exports,global,process){
/*********************/
/* Helper Functions. */
/* http://madrury.github.io/smoothers */
/*********************/
var numeric = Require('plugins/math/numeric')

/* Compute the dot product of two vectors. */
var dot = function(v1, v2) {
    var s = 0;
    for(var i = 0; i < v1.length; i++) {
        s += v1[i] * v2[i];
    }
    return s
}

/* Construct a linear function given a slope and an intercept. */
var linear_function = function(m, b) {
    return function(x) {
        return b + m * x;
    }
}

/* Compute the weighted mean of x with weights w.  Weights may be
   un-normalized.
*/
var wmean = function(x, w) {
    var r = [];
    for(i = 0; i < x.length; i++) {
        r.push(x[i]*w[i]);
    }
    return r.sum() / w.sum();
}

/* The sum of squared errors of a data set when making a prediction equal
   to the mean.
*/
var sum_of_squared_errors = function(xs) {
    return xs.map(x => x - xs.mean()).map(x => x*x).reduce((a, b) => a + b, 0);
}

/* Fit a simple linear regression on data (ys, xs).

   This returns a linear function, i.e. the prediction function from the
   fit linear regression.
*/
var linear_regressor = function(xs, ys) {
    var xmean = xs.mean();
    var ymean = ys.mean();
    var xymean = (Math.zip(xs, ys).map(p => p[0]*p[1])).mean();
    var xsqmean = (Math.zip(xs, xs).map(p => p[0]*p[1])).mean();
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var intercept = ymean - beta * xmean;
    return linear_function(beta, intercept);
};

/* Simple linear regression with sample weights. */
var weighted_linear_regressor = function(xs, ys, ws) {
    var xmean = wmean(xs, ws);
    var ymean = wmean(ys, ws);
    var xymean = wmean(Math.zip(xs, ys).map(p => p[0]*p[1]), ws);
    var xsqmean = wmean(Math.zip(xs, xs).map(p => p[0]*p[1]), ws);
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var betaz = ymean - beta * xmean;
    return linear_function(beta, betaz)
};

/* Given a function from numbers to numbers, return one that maps arrays to
   arrays through mapping.
*/
var vectorize = function(f) {
    return function(arr) {
        return arr.map(f)
    }
}

/* Undo a zip operation */
var unzip = function(ps, i) {
    return ps.map(p => p[i]);
}

/* Sort ordered pairs of x, y data by x. */
var sort_data = function(xs, ys) {
    var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
    var xsort = unzip(psort, 0);
    var ysort = unzip(psort, 1);
    return [xsort, ysort];
}


/*******************************************/
/* Ridge Regression with Basis Expansions. */
/*******************************************/

/* Fit a ridge regression to data X and response ys with regularization
   strength lambda.

   This returns an object containing the data needed to score the fitted
   regression:
   
   {
       "betas": <array of standardized parameter estiamtes>,
       "Xsd": <standardizer data for X>,
       "ysd": <standardizer data for y>
   }
*/
var fit_ridge_regression = function(X, ys, lambda) {
    /* Construct a square matrix of size n with lambdas along the main
       diagonal, and a zero in the (0, 0) position.  This type of matrix is
       useful in ridge regression.
    */
    var make_ridge_shrinkage_matrix = function(n, lambda) {
        var shrink_matrix = numeric.diag(numeric.rep([n + 1], lambda));
        /* Dont shrink the linear term in basis expansion regressions. */
        shrink_matrix[0][0] = 0;
        return shrink_matrix
    }

    /* Compute the translation and scale factors necessary to standardize the
      columns of a matrix.

      This returns an object with two attributes:

      { "mean": [<array of translation factors>],
        "sd": [<array of scale factors>] }
    */
    var compute_matrix_standardization = function(X) {
        var standardization = {"mean": [], "sd": []};
        /* It is easier to iterate over the rows of a matrix than the columns. */
        var Xt = numeric.transpose(X);
        for(var i = 0; i < Xt.length; i++) {
            var standardized_row = compute_vector_standardization(Xt[i]);
            standardization.mean.push(standardized_row.mean);
            standardization.sd.push(standardized_row.sd);
        }
        return standardization;
    }

    /* Compute the translation and scale factor necessary to standardize a
      vector.

      This returns an object with two attributes:

      {"mean": <mean of vector>, "sd": <standard deviation of vector>}
    */
    var compute_vector_standardization = function(v) {
        var mean = v.mean();
        var sd = Math.deviation(v);
        return {'mean': mean, 'sd': sd}
    }

    var X_standardization = compute_matrix_standardization(X);
    var Xsd = standardize_matrix(X, X_standardization);
    var y_standardization = compute_vector_standardization(ys);
    var ysd = standardize_vector(ys, y_standardization);
    // Compute the regression.
    var Xsdt = numeric.transpose(Xsd);
    var XtX = numeric.dot(Xsdt, Xsd);
    var Xty = numeric.dot(Xsdt, ysd);
    var shrink_matrix = make_ridge_shrinkage_matrix(X[0].length, lambda);
    var betas = numeric.solve(numeric.add(XtX, shrink_matrix), Xty);

    return {
        "betas": betas,
        "Xsd": X_standardization,
        "ysd": y_standardization
    }
}

/* Apply standardization data to a matrix.  Returns a standardized version
   of the matrix, i.e. a matrix with standardized columns.
*/
var standardize_matrix = function(X, standardization) {
    /* It is easier to iterate over the rows of a matrix than the columns. */
    var Xt = numeric.transpose(X);
    var S = []
    for(var i = 0; i < Xt.length; i++) {
        var row_standardization = {
            "mean": standardization.mean[i],
            "sd": standardization.sd[i]
        };
        var standardized_row = standardize_vector(Xt[i], row_standardization);
        S.push(standardized_row);
    }
    return numeric.transpose(S);
}

/* Apply standardization data to a vector. */
var standardize_vector = function(v, standardization) {
    return v.map(x => (x - standardization.mean) / standardization.sd)
}


/* Basies for fitting basis expansion models. 

   A basis is a linearly independent sequence of functions [f_1, f_2, ..., f_k].
   A basis expansion is a transformation of a vector v into a matrix..  The
   columns of the basis expanded matrix are created by mapping each of the
   functions in the basis expansion over the vector in turn.
*/
var basies = {

    /* Polynomial basis expansion.

         x -> [1, x, x^2, ...]
    */
    polynomial_basis: function(d) {
        var basis = [];
        function push(i) {
          basis.push(function (x) { return  Math.pow(x, i) })
        }
        for(var i = 1; i <= d; i++) {
          push(i)
        }
        return basis;
    },

    /* Piecewise linear spline basis.

       This basis depends on a sequence of knots: k_1, k_2, ...
       The basis expansion is given by the sequence of functions
       x -> max(0, x - k_i).

       Models fit using a PL basis expansion as predictors result in piecewise
       linear prediction functions.
    */
    pl_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        function push(i) {
          basis.push(function (x) { return  Math.max(x - knots[i], 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis;
    },

    /* Quadratic spline basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a quadratic spline basis expansion as predictors reult
       in a peicewise quadratic prediction function.
    */ 
    quadratic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        function push(i) {
          basis.push(function (x) { return  Math.pow(x - knots[i], 2)*((x - knots[i]) >= 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a cubic spline basis expansion as predictors reult
       in a peicewise cubic prediction function.
    */ 
    cubic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        basis.push(x => x*x*x);
        function push(i) {
          basis.push(function (x) { return  Math.max(Math.pow(x - knots[i], 3), 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Natural cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a natural cubic spline basis expansion as predictors
       reult in a peicewise cubic prediction function, but with the extra
       feature that the function is linear outside of the leftmost and
       rightmost knots.
    */ 
    natural_cubic_spline_basis: function(knots) {
        n_knots = knots.length;
        var basis = [];
        basis.push(x => x);
        var ppart = (t => Math.max(t, 0))
        var cube = (t => t*t*t);
        var d = function(knot_idx) {
            return function(x) {
                return (
                    // Sure would be nice if this was scheme.
                    (cube(ppart(x - knots[knot_idx], 0)) 
                        - cube(ppart(x - knots[n_knots - 1], 0)))
                    / (knots[n_knots - 1] - knots[knot_idx]));
            };
        };
        function push(k) {
          basis.push(function (x) { return  d(k)(x) - d(n_knots - 2)(x) })
        }
        for(var k = 0; k < n_knots - 2; k++) {
          push(k)
        }
        return basis
    }
}

/* Construct a regression operator given a basis of functions, and a
   regularization strength.

   This constructs a function witht he following signature:
       (xs, ys) => (x => _)
   I.e. a function that consumes data, and returns a prediction function.
   The prediction function is constructed by fitting a ridge regression
   on the data (xs, ys) after applying the given basis expansion.
*/
var make_basis_expansion_regression = function(basis, lambda) {
    /* Map a basis expansion across a vector. The result is a vector. */
    var evaluate_basis_expansion = function(basis, xs) {
        return xs.map(x => basis.map(s => s(x)))
    }

    return function(xs, ys) {
        var X = evaluate_basis_expansion(basis, xs);
        var ridge = fit_ridge_regression(X, ys, lambda);
        var smooth_value = function(newx) {
            // There is a small hack here.  After getting the basis
            // expansion, we have a vector.  We immediately wrap this in a
            // list, creating a one row matrix.  This allows us to use
            // standardize_matrix, avoiding duplication of some logic.
            var basis_expansion = [basis.map(s => s(newx))]
            var standardized_basis_expansion = 
                standardize_matrix(basis_expansion, ridge.Xsd)[0];

            return (
                numeric.dot(ridge.betas, standardized_basis_expansion) * ridge.ysd.sd
                + ridge.ysd.mean); 
        }
        return Object.assign(vectorize(smooth_value),{parameter:ridge});
    };
}

/* Consume a basis expansion representing a spline basis, and return a function
   that consumes a object of parameters (the only parameter being the number of
   knots), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_spline_regression = function(spline_basis_function) {

    return function(parameters) {
        var n = Number(parameters["n"]);
        var knots = make_knots(n);
        var sp = spline_basis_function(knots);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(sp, lambda);
    }
}

/* Make a set of equally spaced knots in the interval [0, 1] */
var make_knots = function(n) {
    return numeric.linspace(0, 1, n + 2).slice(1, n + 1);
}

/* Consume a basis expansion representing a polynomial basis, and return a
   function that consumes a object of parameters (the only parameter being the
   degree), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_polynomial_regression = function(polynomial_basis_function) {
    return function(parameters) {
        var d = Number(parameters["degree"]);
        var p = polynomial_basis_function(d);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(p, lambda);
    }
}


/********************/
/* Regression Trees */
/********************/

/* Construct a function that fits regression trees of a specified depth.

   Returns a function ((xs, ys) => (x => _)) that fits a regression tree
   to the supplied xs, ys data.
*/
var make_regression_tree = function(parameters) {
    var depth = Number(parameters["depth"]);
    return function(xs, ys) {
        /* We sort the data once up front, it will stay sorted as we
           decend the tree.
        */
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var tree = fit_regression_tree(xsorted, ysorted, depth);
        var regression_tree_predict_pointwise = function(x) {
            return score_regression_tree(x, tree);
        }
        var fs = vectorize(regression_tree_predict_pointwise);
        fs.tree=tree;
        return fs;
    }
}

/* Fit a regression tree to data of a specified depth.

   Returns a simple object (informally of type tree) representing a fit
   regression tree.  A tree object has the following shape.

    {
        "is_leaf": <boolean: is this tree a lead node?>,
        "value": <float: The value to predict in this node, if a leaf>,
        "left_child_condition": <function: f(x) answers "is x in the reigon
                                 defined by the left child node>
        "left_child": <tree: A fit regression tree to those xs, ys in the left
                       child>,
        "right_child": <tree: A fit regression tree to those xs, ys in the
                        right child>,
    }

    The field "value" is only defined for leaf nodes.  The fields
    "left_child_condition", "left_child", and "right_child" are only defined if
    *not* a lead node.
*/
var fit_regression_tree = function(xs, ys, depth) {
    if(depth === 0 || ys.length <= 1) {
        /* Base case step. */
        var tree = make_tree_object();
        tree.is_leaf = true;
        tree.value = ys.mean();
        return tree;
    } else {
        /* Recursive step. */
        var split = compute_split_point(xs, ys);
        var condition = function(x) {return x <= split}
        var ps = Math.zip(xs, ys);
        var left_data = ps.filter(p => condition(p[0]));
        var right_data = ps.filter(p => !condition(p[0]));
        /* Construct and return the tree */
        var tree = make_tree_object();
        tree.left_child_condition = condition;
        tree.left_child = fit_regression_tree(
            unzip(left_data, 0), unzip(left_data, 1), depth - 1);
        tree.right_child = fit_regression_tree(
            unzip(right_data, 0), unzip(right_data, 1), depth - 1);
        return tree;
    }
}


/* Construct an empty tree object. */
var make_tree_object = function() {
    return {
        "is_leaf": false,
        "left_child_condition": null,
        "left_child": null,
        "right_child": null,
        "value": null
    }
}

/* Compute the optimal split point in data xs, ys.

   The split point is the midpoint between two data points, so that grouping
   the ys data into those left of and right of the split point produces the
   least total varaince.

   Note: This function assumes that the xs, ys data is sorted in increasing
         xs order.
*/
var compute_split_point = function(xs, ys) {
    var best_sosd = Infinity;
    var best_split = null;
    for(var i = 1; i <= ys.length - 1; i++) {
        var left_ys = ys.slice(0, i);
        var right_ys = ys.slice(i, ys.length);
        var this_sosd = sum_of_squared_errors(left_ys) + 
                        sum_of_squared_errors(right_ys);
        if(this_sosd <= best_sosd) {
            best_sosd  = this_sosd;
            best_split = (xs[i-1] + xs[i]) / 2;
        }
    }
    return best_split;
}

/* Generate a predictor from a regression tree at a point x */
var score_regression_tree = function(x, tree) {
    if(tree.is_leaf == true) {
        return tree.value;
    } else {
        if(tree.left_child_condition(x)) {
            return score_regression_tree(x, tree.left_child);
        } else {
            return score_regression_tree(x, tree.right_child);
        }
    }
}


/*********************/
/* Gradient Boosting */
/*********************/

/* Construct a function that fits a gradient boosted regression.

   Returns a function ((xs, ys) => (x => _)) that fits a gradient booster
   to the supplied xs, ys data.
*/
var make_boosted_model = function(parameters) {
    var learning_rate = Number(parameters["learning_rate"]);
    var n_trees = Number(parameters["n_trees"]);
    var tree_depth = Number(parameters["tree_depth"]);
    return function(xs, ys) {
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var booster = fit_boosted_model(xs, ys, n_trees, learning_rate, tree_depth);
        var boosted_model_predict_pointwise = function(x) {
            return score_boosted_model(x, booster);
        }
        return vectorize(boosted_model_predict_pointwise);
    }
}

/* Fit a gradient boosted regression to data of a specified depth.

   Returns a simple object (informally of type booster) representing a fit
   boosted model.  A booster object has the following shape.

   {
       "intercept": <The mean of the training data, used as the 0'th
                     boosting stage>,
       "trees": [<Array of tree objects, the boosting stages>],
       "learning_rate": <The learning rate of the boosted model>
   }
*/
var fit_boosted_model = function(xs, ys, n_trees, learning_rate, tree_depth) {
    var boosted_model = new_boosted_model();
    boosted_model.learning_rate = learning_rate;
    var working_ys = ys.slice(); // Copy.
    /* Fit the first stage */
    boosted_model.intercept = ys.mean();
    working_ys = working_ys.map(y => y - boosted_model.intercept);
    /* Boost */
    for(var i = 0; i <= n_trees; i++) {
        var tree = fit_regression_tree(xs, working_ys, tree_depth);
        working_ys = 
            Math.zip(xs, working_ys)
              .map(p => p[1] - learning_rate * score_regression_tree(p[0], tree));
        boosted_model.trees.push(tree);
    }
    return boosted_model;
}

/* Construct a booster object. */
var new_boosted_model = function() {
    return {"intercept": null, "trees": [], "learning_rate": null};
}

/* Make predictions on a new datapoint from a booster object. */
var score_boosted_model = function(x, booster) {
    var y_hat = booster.intercept;
    for(var i = 0; i < booster.trees.length; i++) {
        y_hat += booster.learning_rate * score_regression_tree(x, booster.trees[i]);
    }
    return y_hat;
}

/************************/
/* Smoothing Algorithms */
/************************/

/* A namespace for scatterplot smoother objects.

  Each smoother object has three attributes:

    - label: A short description of the smoother.  Appears in a select input
      field.
    - smoother: A smoother function.  Each smoother function has the form

          parameters => ((xs, ys) => (x => _))

      where parameters is a dictionary containing the values of huperparameters
      for the smoother, and xs, ys are equal length vectors of x-coordinates
      and y-coordinates of data points to be smoothed.
    - parameters: Configuration objects for hyperparameters.  These are used
      to populate input slider elements in the user interface.
*/
var smoothers = {

    /* Trivial global mean smoother.

    Simply return the mean of the y values as the smoothed data.

    Hyperparamters: None
    */
    "smooth-type-mean": {

        "label": "Constant Mean",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var mean = ys.mean();
                return vectorize(x => mean)
            }
        },

        "parameters": []
    },

    /* Running mean smoother. 

    The smoothed value y at a given x is the mean value of the y data for
    those data with the closest k x data.

    Hyperparameters:
        k: Number of data points included in each side of the symmetric nbhd.
    */
    "smooth-type-runmean": {

        "label": "Running Mean",
    
        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var xysorted = sort_data(xs, ys), xsort = xysorted[0], ysort = xysorted[1];
                var mean_of_symm_nbrd = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length - 1, pos_in_array + k)
                    ];
                    return (ysort.slice(cutoffs[0], cutoffs[1])).mean();
                };
                return vectorize(mean_of_symm_nbrd);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 1, "max": 20, "step": 1, "default": 2}
        ]
    },

    /* Simple linear regression smoother. 
    
    Hyperparameters:
        None.
    */
    "smooth-type-linreg": {

        "label": "Linear Regression",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var linreg = linear_regressor(xs, ys);
                return vectorize(linreg);
            };
        },

        "parameters": []

    },

    /* Gaussian kernel smoother.

    Hyperparmeters:
        lambda: Width of the gaussian kernel.
    */
    "smooth-type-gaussk": {

        "label": "Gaussian Kernel Smoother",

        "smoother": function(parameters) {
            var lambda = Number(parameters["lambda"]);
            return function(xs, ys) {
                var gauss_kern_smooth = function(x) {
                    var ds = xs.map(function(xi) {return x - xi;});
                    var ws = ds.map(function(di) {return Math.exp(-di*di/lambda);});
                    var normc = ws.sum(); 
                    var normws = ws.map(function(wi) {return wi / normc;});
                    return (Math.zip(normws, ys).map(function(p) {return p[0]*p[1]})).sum();
                };
                return vectorize(gauss_kern_smooth)
            };
        },

        "parameters": [
            {"label": "Width of Kernel", "name": "lambda",
             "min": .001, "max": .05, "step": .001, "default": .01}
        ]

    },

    /* Running line smoother.

       To calculate the smoothed value of y at a given x, we first take
       together the k data points closest to x.  Then fit a simple linear
       regression to these k data points.  The smoothed value of y is the value
       f(x), where f is the prediction function of this linear regression.

    Hyperparameters:
        k: The number of neighbours to consider when fitting the local linear
           regressions.
    */
    "smooth-type-runline": {

        "label": "Running Line",

        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
                var xsort = psort.map(function(p) {return p[0]});
                var ysort = psort.map(function(p) {return p[1]});
                var loc_lin_approx = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    // TODO: Check that you lined up the fenceposts.
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length, pos_in_array + k)
                    ];
                    var locx =  xsort.slice(cutoffs[0], cutoffs[1]);
                    var locy =  ysort.slice(cutoffs[0], cutoffs[1]);
                    return linear_regressor(locx, locy)(newx);
                }
                return vectorize(loc_lin_approx);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 2, "max": 20, "step": 1, "default": 2}
        ]

    },

    /* Ridge regression with a polynomial basis expansion.

    Hyperparameters:
        degree: The maximum degree of polynomial in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-polyreg": {
    
        "label": "Polynomial Ridge Regression",

        "smoother": make_polynomial_regression(basies.polynomial_basis),

        "parameters": [
            {"label": "Polynomial Degree", "name": "degree",
             "min": 1, "max": 20, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ]

    },

    /* Ridge regression with a piecewise linear basis expansion.

    Hyperparameters:
        n: The number of knots to use in the PL basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-pl": {

        "label": "Piecewise Linear Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.pl_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .1, "step": .0001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise quadratic basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
     */
    "smooth-type-quad": {

        "label": "Quadratic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.quadratic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise cubic (unrestricted) basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-spline": {

        "label": "Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a natural cubic spline basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-natural-spline": {

        "label": "Natural Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.natural_cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 3},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Regression tree smoother.

    Hyperparameters:
        depth: The maximum depth in the fit tree.  The final tree has 2**depth
               leaf nodes.
    */
    "smooth-type-regression-tree": {
    
        "label": "Regression Tree",

        "smoother": make_regression_tree,

        "parameters": [
            {"label": "Maximum Tree Depth", "name": "depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },

    /* Gradient boosting to minimize the sum of squared errors.

    Hyperparameters:
        n_trees: The number of boosting stages.
        learning_rate: Learning rate.
        tree_depth: The maximum depth of the individual trees.
    */
    "smooth-type-boosting": {
    
        "label": "Gradient Boosting Regression",

        "smoother": make_boosted_model,

        "parameters": [
            {"label": "Number of Boosting Stages", "name": "n_trees",
             "min": 0, "max": 250, "step": 1, "default": 5},
            {"label": "Learning Rate", "name": "learning_rate",
             "min": 0, "max": 1, "step": 0.01, "default": 0.05},
            {"label": "Maximum Tree Depth", "name": "tree_depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },
/*
    // Locally weighted linear regression smoother.
    "smooth-type-loess": function(xs, ys) {
        var k = 5
        var loess = function(x) {
            // Sort by increasing absolute distance from x.
            var psort = d3.zip(xs, ys).sort(function(a, b) {
                return Math.abs(x - a[0]) - Math.abs(x - b[0])}
            );
            var xsort = psort.map(function(p) {return p[0]}).slice(0, 7);
            var ysort = psort.map(function(p) {return p[1]}).slice(0, 7);
            var nearest_nbrs = psort.slice(0, 7);
            var ds = nearest_nbrs.map(function(p) {return Math.abs(p[0] - x)});
            var dsmax = d3.max(ds);
            var ws = ds.map(function(d) {
                return Math.pow(1 - d*d*d, 3) / (dsmax * dsmax * dsmax)
            });
            return weighted_linear_regressor(xsort, ysort, ws)(x);
        };
        return vectorize(loess)
    },
*/
};

// fourier-polynomial.js
//
// A class modeling a fourier polynomial (finite degree).

var FourierPolynomial = function(cs) {
  
  var _coefs = cs

  return {
  
    get degree() {
      return _coefs.length - 1
    },

    // The maximum possible value obtained by the polynomial
    get pmax() {
      var s, i
      s = 0
      for(i = 0; i < _coefs.length; i++) {
        s += Math.abs(_coefs[i])
      }
      return s
    },

    // Evaluate the polynomial at a number after shifting by a given 
    // phase.
    _eval: function(x, phase) {
      var acc, i
      phase = phase || 0
      acc = 0
      for(i = 0; i <= this.degree; i++) {
        acc += _coefs[i] * Math.sin(2 * i * Math.PI * (x - phase))
      }
      return acc
    },

    // Evaluate teh polynomial at an array after shifting a given 
    // pahse.
    eval: function(xs, phase) {
      that = this
      var ys = xs.map(function(x) {return that._eval(x, phase)})
      that = null // Destruct
      return ys
    },

  }
}

var _runif = function(low, high) {
    return (high - low) * Math.random() + low
}

var randomPolynomial = function(degree) {
    var coefs = []
    for(var i = 0; i <= degree; i++) {
        coefs.push(_runif(-1, 1))
    }
    //coefs = coefs.sort(function(a, b) {return b - a})
    console.log(coefs)
    return new FourierPolynomial(coefs)
}

module.exports = smoothers;

};
BundleModuleCode['plugins/ml/reg']=function (module,exports,global,process){
/* https://github.com/chen0040/js-regression */
var jsregression = jsregression || {};

(function (jsr) {
    'use strict';
	var LinearRegression = function (config) {
        config = config || {};
        
        if (!config.iterations) {
            config.iterations = 1000;
        }
        if (!config.alpha) {
            config.alpha = 0.001;
        }
        if (!config.lambda) {
            config.lambda = 0.0;
        }
        if(!config.trace) {
            config.trace = false;
        }
        
        this.iterations = config.iterations;
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.costThres = config.cost||0;
        this.errorThres = config.error||0;
        this.trace = config.trace;
        this.dynamic = config.dynamic;  // dynamic alpha rate
    };
    
    LinearRegression.prototype.fit = function (data) {
        var N = data.length, X = [], Y = [];
        this.dim = data[0].length;

    
        for (var i=0; i < N; ++i) {
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j) {
                x_i.push(row[j]);
            }
            Y.push(y_i);
            X.push(x_i);
        }
        
        this.theta = [];
        
        for (var d = 0; d < this.dim; ++d) {
            this.theta.push(0.0);
        }
        
        var cost,lastCost=0, lastVx, lastTheta, alpha=this.alpha;
        for (var k = 0; k < this.iterations; ++k) {
            var Vx = this.grad(X, Y, this.theta);
            
            for(var d = 0; d < this.dim; ++d) {
                this.theta[d] = this.theta[d] - alpha * Vx[d];
                if (isNaN(this.theta[d])) 
                 throw Error ('LinearRegression.fit: parameter overflow, probably alpha rate to high! (alpha:'+alpha+', step:'+k+')')
            }
            
            if (this.errorThres && this.error(X,Y,this.theta) < this.errorThres) break;
            if (this.costThres && this.cost(X,Y,this.theta) < this.costThres) break;
            if (this.dynamic) {
              // experimental dynamic aloha rate adaptation
              if (lastVx) {
                var gMax=0, gradVx = lastVx.map(function (vx,index) {
                  var g = Math.abs(Vx[index]/vx);
                  gMax = Math.max(gMax,g)
                  return g
                })
                // if some gradVx > XX then lower alpha
                if (gMax > 2) {
                  alpha /= 2;
                } else if (gMax < 1 && (1-gMax) < 0.01) alpha *= 2;
              }
              lastVx = Vx.slice();
              lastTheta = this.theta.slice();
              // console.log(alpha,Vx);
            }
            if(this.trace) {
                console.log('theta: ',this.theta)
                console.log('cost at iteration ' + k + ': ' + cost+' alpha:'+alpha);
            }
        }
        
        return {
            theta: this.theta,
            dim: this.dim,
            cost: this.cost(X, Y, this.theta),
            error: this.error(X, Y, this.theta),
            iterations : k,
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        };
    };
    
    LinearRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        
        var Vtheta = [];
        
        for(var d = 0; d < this.dim; ++d){
            var g = 0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var y_i = Y[i];
                
                var predicted = this.h(x_i, theta);
                
                g += (predicted - y_i) * x_i[d];  
            }
            
            g = (g + this.lambda * theta[d]) / N;
            
            Vtheta.push(g);
        }
        
        return Vtheta;
    };
    
    LinearRegression.prototype.h = function(x_i, theta) {
        var predicted = 0.0;
        for(var d = 0; d < this.dim; ++d) {
            predicted += x_i[d] * theta[d];
        }
        return predicted;
    }
    
    LinearRegression.prototype.cost = function(X, Y, theta) {
      
        var N = X.length;
        var cost = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            cost += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        for(var d = 0; d < this.dim; ++d) {
            cost += this.lambda * theta[d] * theta[d];
        }
        
        return cost / (2.0 * N);
    };

    LinearRegression.prototype.error = function(X, Y, theta) {
      
        var N = X.length;
        var err = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            err += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        
        return err / (N);
    };
    
    LinearRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        // x is a row vector
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    };

    LinearRegression.prototype.toFunction = function () {
      var self=this, foo;
      var fcode = 'foo=function (x) { return '
      fcode += (self.theta.map(function (p,index) {
        var xx=[]; for (var i=0;i<index;i++) xx.push('x');
        return self.theta[index]+(xx.length?'*'+xx.join('*'):'');
      }).join('+'))
      fcode += '}';
      eval(fcode);
      return foo
    }
    
    jsr.LinearRegression = LinearRegression;
    
    var LogisticRegression = function(config) {
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    }
    
    LogisticRegression.prototype.fit = function(data) {
        this.dim = data[0].length;
        var N = data.length;
        
        var X = [];
        var Y = [];
        for(var i=0; i < N; ++i){
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j){
                x_i.push(row[j]);
            }
            X.push(x_i);
            Y.push(y_i);
        }
        
        this.theta = [];
        for(var d = 0; d < this.dim; ++d){
            this.theta.push(0.0);
        }
        
        for(var iter = 0; iter < this.iterations; ++iter){
            var theta_delta = this.grad(X, Y, this.theta);
            for(var d = 0; d < this.dim; ++d){
                this.theta[d] = this.theta[d] - this.alpha * theta_delta[d];        
            }
        }
        
        this.threshold = this.computeThreshold(X, Y);
        
        return {
            theta: this.theta,
            threshold: this.threshold,
            cost: this.cost(X, Y, this.theta),
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        }
    };
    
    LogisticRegression.prototype.computeThreshold = function(X, Y){
        var threshold=1.0, N = X.length;
        
        for (var i = 0; i < N; ++i) {
            var prob = this.transform(X[i]);
            if(Y[i] == 1 && threshold > prob){
                threshold = prob;
            }
        }
        
        return threshold;
    }
    
    LogisticRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        var Vx = [];
        for(var d = 0; d < this.dim; ++d) {
            var sum = 0.0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var predicted = this.h(x_i, theta);
                sum += ((predicted - Y[i]) * x_i[d] + this.lambda * theta[d]) / N;
            }    
            Vx.push(sum);
        }
        
        return Vx;
        
    }
    
    LogisticRegression.prototype.h = function(x_i, theta) {
        var gx = 0.0;
        for(var d = 0; d < this.dim; ++d){
            gx += theta[d] * x_i[d];
        }
        return 1.0 / (1.0 + Math.exp(-gx));
    }
    
    LogisticRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    }
    
    LogisticRegression.prototype.cost = function(X, Y, theta) {
        var N = X.length;
        var sum = 0;
        for(var i = 0; i < N; ++i){
            var y_i = Y[i];
            var x_i = X[i];
            sum += - (y_i * Math.log(this.h(x_i, theta)) + (1-y_i) * Math.log(1 - this.h(x_i, theta))) / N;
        }
        
        for(var d = 0; d < this.dim; ++d) {
            sum += (this.lambda * theta[d] * theta[d]) / (2.0 * N);
        }
        return sum;
    };
    
    jsr.LogisticRegression = LogisticRegression;
    
    var MultiClassLogistic = function(config){
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    };
    
    MultiClassLogistic.prototype.fit = function(data, classes) {
        this.dim = data[0].length;
        var N = data.length;
        
        if(!classes){
            classes = [];
            for(var i=0; i < N; ++i){
                var found = false;
                var label = data[i][this.dim-1];
                for(var j=0; j < classes.length; ++j){
                    if(label == classes[j]){
                        found = true;
                        break;
                    }
                }
                if(!found){
                    classes.push(label);
                }
            }
        }
        
        this.classes = classes;
        
        this.logistics = {};
        var result = {};
        for(var k = 0; k < this.classes.length; ++k){
            var c = this.classes[k];
            this.logistics[c] = new jsr.LogisticRegression({
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations
            });
            var data_c = [];
            for(var i=0; i < N; ++i){
                var row = [];
                for(var j=0; j < this.dim-1; ++j){
                    row.push(data[i][j]);
                }
                row.push(data[i][this.dim-1] == c ? 1 : 0);
                data_c.push(row);
            }
            result[c] = this.logistics[c].fit(data_c);
        }
        return result;
    };
    
    MultiClassLogistic.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        
        
        var max_prob = 0.0;
        var best_c = '';
        for(var k = 0; k < this.classes.length; ++k) {
            var c = this.classes[k];
            var prob_c = this.logistics[c].transform(x);
            if(max_prob < prob_c){
                max_prob = prob_c;
                best_c = c;
            }
        }
        
        return best_c;
    }
    
    
    
    jsr.MultiClassLogistic = MultiClassLogistic;

})(jsregression);

var module = module || {};
if(module) {
	module.exports = jsregression;
}
};
BundleModuleCode['plugins/math/data-bin']=function (module,exports,global,process){
// https://github.com/mhyfritz/bin-data

// included from https://github.com/d3/d3-array/tree/main/src
var pickRepresentatives = {
  max:function max(values, valueof) {
    var max;
    if (valueof === undefined) {
      for (const value of values) {
        if (value != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    }
    return max;
  },
  mean:function mean(values, valueof) {
    var count = 0;
    var sum = 0;
    if (valueof === undefined) {
      for (var value of values) {
        if (value != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    }
    if (count) return sum / count;
  },
  min:function min(values, valueof) {
    var min;
    if (valueof === undefined) {
      for (var value of values) {
        if (value != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    }
    return min;
  }
}
function bin(data, numChunks, pickRepresentative ) {
  if (typeof pickRepresentative=='string') pickRepresentative=pickRepresentatives[pickRepresentative];
  pickRepresentative=pickRepresentative|| pickRepresentatives.max
  if (!Array.isArray(data)) {
    data = Array.from(data);
  }

  var chunks = chunk(data, numChunks);
  return chunks.map(chunk => pickRepresentative(chunk.data));
}

function chunk(data, numChunks) {
  var chunks = new Array(numChunks);
  var binSize = data.length / numChunks;

  for (var i = 0, start = 0, end = 0; i < numChunks; i += 1) {
    end = Math.round((i + 1) * binSize);
    var slice = data.slice(start, end);
    chunks[i] = {
      start,
      end: end - 1,
      data: slice
    };
    start = end;
  }

  return chunks;
}

module.exports = bin;
};
BundleModuleCode['plugins/math/matja']=function (module,exports,global,process){
// MatLab math compatibility and related extensions
Math.gaussian = function (x,pos,wid) {
  if(typeof(x)==='number' && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //numerator
    var num = Math.pow((x-pos),2)
    //Divison
    var res = num/den;
    //Exponent of total result
    var result = Math.exp(-res)
    return result;
  }
  else if(Utils.isArrayArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function (row) { return  row.map(function (element) { return  element - pos})});
    //numerator
     var num = sub.map(function (row) { return row.map(function (element) { return Math.pow(element,2) }) });
    //Division
    var res = num.map(function (row) { return row.map(function (element) { return element/den }) });
    //Exponent of result
    var result = res.map(function (row) { return row.map(function (element) { return Math.exp(-element) }) });
    return result;
  }
  else if(Utils.isArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function(value) {
      return value - pos;
    });
    //numerator
    var num = sub.map(function (num,i) { return Math.pow(num,2) });
    ////Division
    var res = num.map(function(value) {
      return value/den;
    });
    //Exponent of result
    var result = res.map(function(value) {
      return Math.exp(-value);
    });
    return result;
  }
  else {
    throw 'EINVALID'
  } 
}


Math.sign = function (x) { return x<0?-1:x>0?1:0 }

// Sequence of numbers (discrete number ranges)
// [first:increment:second]
$S = function (first,incrementOrSecond,second) {
  if (second==undefined) return Math.sequence(first,incrementOrSecond);
  else return Math.sequence(first,second,incrementOrSecond);
}

// Right-hand side array selector
// A(first:last)
$RS = function (A,first,last) {
  if (Utils.isArray(A)) return A.slice(first,last+1)
}
// Left-hand side array selector
// A(first:last) = B
$WS = function (A,first,last,B) {
  if (Utils.isArray(A) && Utils.isArray(B)) 
    for(var i=0;i<last-first+1;i++) A[first+i]=B[i];
}

};
BundleModuleCode['plugins/math/points']=function (module,exports,global,process){
var Hull = Require('plugins/math/hull');
function toArray(points) {
  if (points[0].x != undefined) points=points.map(function (p) {
    return [p.x,p.y]
  })
  return points  
}
function toPoints(points) {
  if (typeof points[0][0] == 'number') points=points.map(function (v) {
    return {x:v[0],y:v[1]}
  })
  return points  
}
function ConvexHull (points) {
  points=toArray(points);
  return Hull(points)
}
// mass of center of point cloud
function moc (points) {
  var n = points.length, pc={x:0,y:0};
  for(var i=0;i<n;i++) {
    pc.x += points[i].x;
    pc.y += points[i].y;
  }
  pc.x/=n; pc.y/=n;
  return pc
}
// mean bounding box of point cloud
function mbb (points) {
  var n = points.length,
      pc = moc(points),
      b = { x1:pc.x, y1:pc.y, x2: pc.x, y2:pc.y },
      c = { x1:1, y1:1, x2:1, y2:1 };
  for(var i=0;i<n;i++) {
    var p = points[i];
    if (p.x>pc.x) { c.x2++; b.x2 += p.x }
    if (p.x<pc.x) { c.x1++; b.x1 += p.x }
    if (p.y>pc.y) { c.y2++; b.y2 += p.y }
    if (p.y<pc.y) { c.y1++; b.y1 += p.y }
  }
  b.x1 /= c.x1; b.x2 /= c.x2;
  b.y1 /= c.y1; b.y2 /= c.y2;
  return b
}
// Expansion of boundaries with second averaging of outside points
function mbx (points,b) {
  var n = points.length,
      b2 = { x1:b.x1, y1:b.y1, x2: b.x2, y2:b.y2 },
      c  = { x1:1, y1:1, x2:1, y2:1 };
  for(var i=0;i<n;i++) {
    var p = points[i];
    if (p.x>b.x2) { c.x2++; b2.x2 += p.x }
    if (p.x<b.x1) { c.x1++; b2.x1 += p.x }
    if (p.y>b.y2) { c.y2++; b2.y2 += p.y }
    if (p.y<b.y1) { c.y1++; b2.y1 += p.y }
  }
  b2.x1 /= c.x1; b2.x2 /= c.x2;
  b2.y1 /= c.y1; b2.y2 /= c.y2;
  return b2
}
// Minimum bounding rectangle
function findMinBoundingRect (points) {
  // https://github.com/mahetoodang/minimum-bounding-rectangle
  function multiply (a,b) {
    return Math.Matrix(a).multiply(Math.Matrix(b))
  }
  function transpose (a) {
    return Math.Matrix(a).transpose()
  }
  function matrix (a) {
    return Math.Matrix(a)
  }
  // Convex hull for the points
  points=toArray(points);
  const hullPoints = ConvexHull(points);

  const edges = [];
  for (let i=0; i < hullPoints.length-1; i++) {
    edges.push([
      hullPoints[i+1][0] - hullPoints[i][0],
      hullPoints[i+1][1] - hullPoints[i][1]
    ]);
  }

  const angles = Array.from(new Set(
    edges.map(function (edge) {
      return Math.abs(
        Math.atan2(edge[1], edge[0]) % (Math.PI / 2)
      )
    })
  ));

  const rotations = angles.map(function (angle) {
    return [
      [ Math.cos(angle), Math.cos(angle - Math.PI/2) ],
      [ Math.cos(angle + Math.PI/2), Math.cos(angle) ]
    ]
  });

  // Apply rotations to the hull
  const rotPoints = rotations.map(function (rotation) {
    return multiply(
      matrix(rotation),
      transpose(matrix(hullPoints))
    ).toArray()
  });

  const minXY = rotPoints.map(function (pMat) {
    const minValues = pMat.map(function (row) { return row.min() })// mathjs.min(pMat, 1); // TODO
    return [minValues[0], minValues[1]];
  });
  const maxXY = rotPoints.map(function (pMat) {
    const maxValues = pMat.map(function (row) { return row.max() }) // mathjs.max(pMat, 1); // TODO
    return [maxValues[0], maxValues[1]];
  });

  const minX = minXY.map(function (m) { return m[0]});
  const minY = minXY.map(function (m) { return m[1]});
  const maxX = maxXY.map(function (m) { return m[0]});
  const maxY = maxXY.map(function (m) { return m[1]});

  // Find the box with the best area
  const areas = minX.map(function (v, i) {
    return (maxX[i] - minX[i]) * (maxY[i] - minY[i])
  });
  const bestIdx = areas.reduce(function (iMax, x, i, arr) { 
    return i==1?0:(x < arr[iMax] ? i : iMax)
    // ,0 // TODO
  });

  // Return the best box
  const x1 = maxX[bestIdx];
  const x2 = minX[bestIdx];
  const y1 = maxY[bestIdx];
  const y2 = minY[bestIdx];
  const r = rotations[bestIdx];
  const minRect = [];

  minRect.push(multiply([[x1, y2]], r).toArray().unwrap());
  minRect.push(multiply([[x2, y2]], r).toArray().unwrap());
  minRect.push(multiply([[x2, y1]], r).toArray().unwrap());
  minRect.push(multiply([[x1, y1]], r).toArray().unwrap());
  minRect.push(multiply([[x1, y2]], r).toArray().unwrap());
  
  return minRect;
}
module.exports = {
  Hull : Hull,
  ConvexHull : ConvexHull,
  findMinBoundingRect : findMinBoundingRect,
  massOfCenter : moc,
  meanBoundingBox : mbb,
  meanBoundingBoxExpand : mbx,
  toArray : toArray,
  toPoints : toPoints,
}

};
BundleModuleCode['plugins/math/hull']=function (module,exports,global,process){
/**
 * Computes hull curve (of n points) of point cloud
 * https://github.com/AndriiHeonia/hull
 * var points = [ [236, 126], [234, 115], [238, 109], [247, 102], ... ];
 * hull(points, 50); // returns points of the hull (in clockwise order)
 *
*/
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.hull = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _cross(o, a, b) {
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}

function _upperTangent(pointset) {
    const lower = [];
    for (let l = 0; l < pointset.length; l++) {
        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {
            lower.pop();
        }
        lower.push(pointset[l]);
    }
    lower.pop();
    return lower;
}

function _lowerTangent(pointset) {
    const reversed = pointset.reverse(),
        upper = [];
    for (let u = 0; u < reversed.length; u++) {
        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {
            upper.pop();
        }
        upper.push(reversed[u]);
    }
    upper.pop();
    return upper;
}

// pointset has to be sorted by X
function convex(pointset) {
    const upper = _upperTangent(pointset),
          lower = _lowerTangent(pointset);
    const convex = lower.concat(upper);
    convex.push(pointset[0]);  
    return convex;  
}

module.exports = convex;

},{}],2:[function(require,module,exports){
module.exports = {

    toXy: function(pointset, format) {
        if (format === undefined) {
            return pointset.slice();
        }
        return pointset.map(function(pt) {
            /*jslint evil: true */
            const _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');
            return _getXY(pt);
        });
    },

    fromXy: function(pointset, format) {
        if (format === undefined) {
            return pointset.slice();
        }
        return pointset.map(function(pt) {
            /*jslint evil: true */
            const _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');
            return _getObj(pt);
        });
    }

}
},{}],3:[function(require,module,exports){
function Grid(points, cellSize) {
    this._cells = [];
    this._cellSize = cellSize;
    this._reverseCellSize = 1 / cellSize;

    for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const x = this.coordToCellNum(point[0]);
        const y = this.coordToCellNum(point[1]);
        if (!this._cells[x]) {
            const array = [];
            array[y] = [point];
            this._cells[x] = array;
        } else if (!this._cells[x][y]) {
            this._cells[x][y] = [point];
        } else {
            this._cells[x][y].push(point);
        }
    }
}

Grid.prototype = {
    cellPoints: function(x, y) { // (Number, Number) -> Array
        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];
    },

    rangePoints: function(bbox) { // (Array) -> Array
        const tlCellX = this.coordToCellNum(bbox[0]);
        const tlCellY = this.coordToCellNum(bbox[1]);
        const brCellX = this.coordToCellNum(bbox[2]);
        const brCellY = this.coordToCellNum(bbox[3]);
        const points = [];

        for (let x = tlCellX; x <= brCellX; x++) {
            for (let y = tlCellY; y <= brCellY; y++) {
                Array.prototype.push.apply(points, this.cellPoints(x, y));
            }
        }

        return points;
    },

    removePoint: function(point) { // (Array) -> Array
        const cellX = this.coordToCellNum(point[0]);
        const cellY = this.coordToCellNum(point[1]);
        const cell = this._cells[cellX][cellY];
        let pointIdxInCell;
        
        for (let i = 0; i < cell.length; i++) {
            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {
                pointIdxInCell = i;
                break;
            }
        }

        cell.splice(pointIdxInCell, 1);

        return cell;
    },

    trunc: Math.trunc || function(val) { // (number) -> number
        return val - val % 1;
    },

    coordToCellNum: function(x) { // (number) -> number
        return this.trunc(x * this._reverseCellSize);
    },

    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array
        return [
            bbox[0] - (scaleFactor * this._cellSize),
            bbox[1] - (scaleFactor * this._cellSize),
            bbox[2] + (scaleFactor * this._cellSize),
            bbox[3] + (scaleFactor * this._cellSize)
        ];
    }
};

function grid(points, cellSize) {
    return new Grid(points, cellSize);
}

module.exports = grid;
},{}],4:[function(require,module,exports){
/*
 (c) 2014-2019, Andrii Heonia
 Hull.js, a JavaScript library for concave hull generation by set of points.
 https://github.com/AndriiHeonia/hull
*/

'use strict';

const intersect = require('./intersect.js');
const grid = require('./grid.js');
const formatUtil = require('./format.js');
const convexHull = require('./convex.js');

function _filterDuplicates(pointset) {
    const unique = [pointset[0]];
    let lastPoint = pointset[0];
    for (let i = 1; i < pointset.length; i++) {
        const currentPoint = pointset[i];
        if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
            unique.push(currentPoint);
        }
        lastPoint = currentPoint;
    }
    return unique;
}

function _sortByX(pointset) {
    return pointset.sort(function(a, b) {
        return (a[0] - b[0]) || (a[1] - b[1]);
    });
}

function _sqLength(a, b) {
    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);
}

function _cos(o, a, b) {
    const aShifted = [a[0] - o[0], a[1] - o[1]],
        bShifted = [b[0] - o[0], b[1] - o[1]],
        sqALen = _sqLength(o, a),
        sqBLen = _sqLength(o, b),
        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];

    return dot / Math.sqrt(sqALen * sqBLen);
}

function _intersect(segment, pointset) {
    for (let i = 0; i < pointset.length - 1; i++) {
        const seg = [pointset[i], pointset[i + 1]];
        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||
            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
            continue;
        }
        if (intersect(segment, seg)) {
            return true;
        }
    }
    return false;
}

function _occupiedArea(pointset) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    for (let i = pointset.length - 1; i >= 0; i--) {
        if (pointset[i][0] < minX) {
            minX = pointset[i][0];
        }
        if (pointset[i][1] < minY) {
            minY = pointset[i][1];
        }
        if (pointset[i][0] > maxX) {
            maxX = pointset[i][0];
        }
        if (pointset[i][1] > maxY) {
            maxY = pointset[i][1];
        }
    }

    return [
        maxX - minX, // width
        maxY - minY  // height
    ];
}

function _bBoxAround(edge) {
    return [
        Math.min(edge[0][0], edge[1][0]), // left
        Math.min(edge[0][1], edge[1][1]), // top
        Math.max(edge[0][0], edge[1][0]), // right
        Math.max(edge[0][1], edge[1][1])  // bottom
    ];
}

function _midPoint(edge, innerPoints, convex) {
    let point = null,
        angle1Cos = MAX_CONCAVE_ANGLE_COS,
        angle2Cos = MAX_CONCAVE_ANGLE_COS,
        a1Cos, a2Cos;

    for (let i = 0; i < innerPoints.length; i++) {
        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);
        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);

        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&
            !_intersect([edge[0], innerPoints[i]], convex) &&
            !_intersect([edge[1], innerPoints[i]], convex)) {

            angle1Cos = a1Cos;
            angle2Cos = a2Cos;
            point = innerPoints[i];
        }
    }

    return point;
}

function _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {
    let midPointInserted = false;

    for (let i = 0; i < convex.length - 1; i++) {
        const edge = [convex[i], convex[i + 1]];
        // generate a key in the format X0,Y0,X1,Y1
        const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];

        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||
            edgeSkipList.has(keyInSkipList)) { continue; }

        let scaleFactor = 0;
        let bBoxAround = _bBoxAround(edge);
        let bBoxWidth;
        let bBoxHeight;
        let midPoint;
        do {
            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);
            bBoxWidth = bBoxAround[2] - bBoxAround[0];
            bBoxHeight = bBoxAround[3] - bBoxAround[1];

            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);
            scaleFactor++;
        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));

        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
            edgeSkipList.add(keyInSkipList);
        }

        if (midPoint !== null) {
            convex.splice(i + 1, 0, midPoint);
            grid.removePoint(midPoint);
            midPointInserted = true;
        }
    }

    if (midPointInserted) {
        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);
    }

    return convex;
}

function hull(pointset, concavity, format) {
    let maxEdgeLen = concavity || 20;

    const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));

    if (points.length < 4) {
        return points.concat([points[0]]);
    }

    const occupiedArea = _occupiedArea(points);
    const maxSearchArea = [
        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,
        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT
    ];

    const convex = convexHull(points);
    const innerPoints = points.filter(function(pt) {
        return convex.indexOf(pt) < 0;
    });

    const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));

    const concave = _concave(
        convex, Math.pow(maxEdgeLen, 2),
        maxSearchArea, grid(innerPoints, cellSize), new Set());

    if (format) {
        return formatUtil.fromXy(concave, format);
    } else {
        return concave;
    }
}

const MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg
const MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;

module.exports = hull;

},{"./convex.js":1,"./format.js":2,"./grid.js":3,"./intersect.js":5}],5:[function(require,module,exports){
function ccw(x1, y1, x2, y2, x3, y3) {           
    const cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));
    return cw > 0 ? true : cw < 0 ? false : true; // colinear
}

function intersect(seg1, seg2) {
  const x1 = seg1[0][0], y1 = seg1[0][1],
      x2 = seg1[1][0], y2 = seg1[1][1],
      x3 = seg2[0][0], y3 = seg2[0][1],
      x4 = seg2[1][0], y4 = seg2[1][1];

    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);
}

module.exports = intersect;
},{}]},{},[4])(4)
});
};
BundleModuleCode['plugins/math/vol']=function (module,exports,global,process){
/*
  3D and 4D Data Volumes with typed arrays
  Linear array layout: xyz/xyza : 312/3124 (conforming to image RGBA)
  [ r0:c0:d0, d1, d2 ..,r0:c1:d0,d1,d2,..,..,r1:c0:d0,... ]   
*/
function isArray(o) {
  return (typeof o == 'object') && (o.buffer instanceof ArrayBuffer || o instanceof Array)
}
function isTypedArray(o) {
  return o && o.buffer instanceof ArrayBuffer
}
function size(interval) {
  return interval[1]-interval[0]+1;
}
// Default Vol3D
var Vol = function(sx, sy, depth, c, datatype) {
  if (!(this instanceof Vol)) return new Vol(sx, sy, depth, c, datatype);
  // this is how you check if a variable is an array. Oh, Javascript :)
  // if(Object.prototype.toString.call(sx) === '[object Array]') {
  if (isArray(sx)) {
    // we were given a list in sx, assume 1D volume and fill it up
    this.sx = 1;
    this.sy = 1;
    this.depth = sx.length;
    for(var i=0;i<this.depth;i++) {
      this.w[i] = sx[i];
    }
  } else if (typeof sx == 'object') {
    // fromJSON
    this.fromJSON(sx);
  } else {
    // we were given dimensions of the vol
    this.sx = sx;
    this.sy = sy;
    this.depth = depth;
    var n = sx*sy*depth;
    if (isArray(c)) {
      this.w  = isTypedArray(c)?c:Vol.data.from(c,datatype);
      return;
    } else if (typeof c == 'number') {
      this.w  = Vol.data.constant(n,c,datatype);
    } else {
      this.w  = Vol.data.zeros(n,datatype);
    }
  }
}

Vol.prototype = {
  add: function(x, y, d, v) {
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] += v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] += v; 
    }
    return this;
  },
  addVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] += V.w[k]; }},
  addFromScaled: function(V, a) { for(var k=0;k<this.w.length;k++) { this.w[k] += a*V.w[k]; }},
  apply : function (v) {
    if (typeof v == 'number')  for(var k=0;k<this.w.length;k++) this.w[k]=v;
    return this;   
  },
  checkIndex : function (x,y,z) {
    return !(x<0 || x>= this.sx) &&
           !(y<0 || y>= this.sy) &&
           !(z<0 || z>= this.depth);
  },
  cloneAndZero: function() { return new Vol(this.sx, this.sy, this.depth, 0.0)},
  clone: function(shared) {
    var V = new Vol(this.sx, this.sy, this.depth, 0.0, Utils.TypedArrayToName(this.w).replace('Array',''));
    var n = this.w.length;
    V.w=Vol.data.clone(this.w,shared)
    return V;
  },
  // kernel : [
  //  v, v, v,
  //  v, v, v,
  //  v, v, v,
  // ]
  convolution : function (kernel,z0,z1,divisor,offset) {
    // https://developpaper.com/image-processing-with-convolution-kernel-in-html5-canvas/
    let w = this.sx,
        h = this.sy,
        d = this.depth;
    divisor = divisor||1;
    offset=offset||0;
    if (z0==undefined) z0=0,z1=d-1;
    var V = Vol.create(this.sx,this.sy,this.depth,this.datatype()); 
    let iD = this.w,
        oD = V.w;
    for (let y = 1; y < h - 1; y += 1) {
      for (let x = 1; x < w - 1; x += 1) {
        for (let c = z0; c < z1; c += 1) {
          let i = (y * w + x) * d + c
          oD[i] =
            offset +
            (kernel[0] * iD[i - w * d - d] +
              kernel[1] * iD[i - w * d] +
              kernel[2] * iD[i - w * d + d] +
              kernel[3] * iD[i - d] +
              kernel[4] * iD[i] +
              kernel[5] * iD[i + d] +
              kernel[6] * iD[i + w * d - d] +
              kernel[7] * iD[i + w * d] +
              kernel[8] * iD[i + w * d + d]) /
              divisor
        }
      }
    }    
    // RGBA?
    if (z0 == 0 && z1==2 && d==4) {
      for (let y = 1; y < h - 1; y += 1) {
        for (let x = 1; x < w - 1; x += 1) {
          oD[(y * w + x) * d + 3] = 255;
        }
      }      
    }
    return V
  },
  copy : function (src,dx,dy,dz,plane) {
    plane=plane||'xyz';
    if (typeof dx == 'number') dx=[dx,dx+src.sx-1];
    if (typeof dy == 'number') dy=[dy,dy+src.sy-1];
    if (typeof dz == 'number') dz=[dz,dz+src.depth-1];
    if (dx.length==0) dx=[0,this.sx-1];
    if (dy.length==0) dy=[0,this.sy-1];
    if (dz.length==0) dz=[0,this.depth-1];
    switch (plane) {
      case 'xyz':
        for(var i=dx[0];i<=dx[1];i++)
          for(var j=dy[0];j<=dy[1];j++) 
            for(var k=dz[0];k<=dz[1];k++) {
              var ia = ((src.sx * (j-dy[0]))+(i-dx[0]))*src.depth+(k-dz[0]),
                  ib = ((this.sx * j)+i)*this.depth+k;
              this.w[ib]=src.w[ia];
            }
        break;
      default:
        throw 'Vol3.copy: supported planes ["xyz"]';
    }
  },
  datatype : function () { return Utils.TypedArrayToName(this.w).replace('Array','') },
  diag : function (v) {
    if (v!= undefined) {
      if (this.depth==1) {
        for(var i=0;i<this.sx;i++) 
          this.set(i,i,0,v);
      }
    }
    return this;
  },
  div: function(x, y, d, v) {
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] /= v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] /= v; 
    }
    return this;
  },
  divVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] /= V.w[k]; }},
  fromJSON: function(json) {
    this.sx = json.sx;
    this.sy = json.sy;
    this.depth = json.depth;
    var n = this.sx*this.sy*this.depth;
    this.w = Vol.data.from(json.w,json.dt,n);
  },
  get: function(x, y, d) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    return this.w[ix];
  },
  info : function () {
    return {
      sx:this.sx,
      sy:this.sy,
      depth:this.depth,
      datatype:this.datatype()
    }
  },
  max : function () {
    var v=this.w[0];
    for(var k=1;k<this.w.length;k++) { v=Math.max(v,this.w[k]) }
    return v
  },
  min : function () {
    var v=this.w[0];
    for(var k=1;k<this.w.length;k++) { v=Math.min(v,this.w[k]) }
    return v
  },
  minmax : function () {
    var min=this.w[0],max=this.w[0];
    for(var k=1;k<this.w.length;k++) { min=Math.min(min,this.w[k]);max=Math.max(max,this.w[k]); }
    return {min:min,max:max }
  },
  // Scalar multiplication
  mul: function(x, y, d, v) {
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] *= v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] *= v; 
    }
    return this;
  },
  // Element-wise volume multiplication
  mulVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] *= V.w[k]; }},
  print : function (format) {
    var s='';
    if (!format) format = '%4.2f';
    for(k=0;k<this.depth;k++) {
      if (k!=0) s = s + '\n\n';
      for(j=0;j<this.sy;j++) {
        sep = '';
        if (j!=0) s = s + '\n';
        for (i=0;i<this.sx;i++) {
          s = s + sep + sprintf(format,this.get(i,j,k)) ;
          sep = ' ';
        }
      }
    }
    return s;
  },
  random  : function(min,max,frac) { 
    if (min==undefined && max==undefined) for(var k=0;k<this.w.length;k++) { this.w[k] = Math.random() }
    else if (frac) for(var k=0;k<this.w.length;k++) { this.w[k] = Math.frac(min+Math.random()*(max-min),frac) }
    else for(var k=0;k<this.w.length;k++) { this.w[k] = min+Math.random()*(max-min) };
    return this;
  },
  // resize vol (simple pick and place algorithm)
  resize : function (sx,sy,depth,datatype,inplace) {
    var dx = this.sx/sx,
        dy = this.sy/sy,
        dz = this.depth/depth,
        V;
    if (typeof datatype == 'boolean') { inplace=datatype; datatype=null };
    if (!inplace) {
      V = Vol(sx,sy,depth,datatype||this.datatype());
      for (var i=0;i<sx;i++)
        for (var j=0;j<sy;j++) 
          for(var k=0;k<depth;k++) {
            var ia = (this.sx * Math.floor(j*dy)+Math.floor(i*dx))*this.depth+Math.floor(k*dz),
                ib = ((sx * j)+i)*depth+k;
            V.w[ib]=this.w[ia];
      }
    } else {
      // TODO
    }
    return V;
  },
  // rotate and opt. mirror a vol
  rotate : function (rot,inplace) {
    function xzy (direction,inplace) {
      if (!inplace) {
        var V = Vol(this.sx,this.depth,this.sy,this.datatype());
        for(var i=0;i<this.sx;i++)
          for(var j=0;j<this.sy;j++) {
            if (direction==1) for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+i)*this.depth+k,
                  b = ((V.sx * (V.sy-k-1))+i)*V.depth+j;
                  V.w[b]=this.w[a];
            } else for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * (this.sy-j-1))+i)*this.depth+k,
                  b = ((V.sx * k)+i)*V.depth+j;
                  V.w[b]=this.w[a];
            }
        }
        return V
      } else {
        // TODO
      }
    }
    function zyx (direction,inplace) {
      if (!inplace) {
        var V = Vol(this.depth,this.sy,this.sx,this.datatype());
        for(var i=0;i<this.sx;i++)
          for(var j=0;j<this.sy;j++) {
            if (direction==1) for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+i)*this.depth+k,
                  b = ((V.sx * j)+k)*V.depth+i;
                  V.w[b]=this.w[a];
            } else for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * (this.sy-j-1))+i)*this.depth+k,
                  b = ((V.sx * j)+k)*V.depth+i;
                  V.w[b]=this.w[a];
            }
        }
        return V
      } else {
        // TODO
      }
    }
    function yxz (direction,inplace) {
      if (!inplace) {
        var V = Vol(this.sy,this.sx,this.depth,this.datatype());
        for(var i=0;i<this.sx;i++)
          for(var j=0;j<this.sy;j++) {
            if (direction==1) for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+i)*this.depth+k,
                  b = ((V.sx * i)+(V.sx-j-1))*V.depth+k;
                  V.w[b]=this.w[a];
            } else for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+(this.sx-i-1))*this.depth+k,
                  b = ((V.sx * i)+j)*V.depth+k;
                  V.w[b]=this.w[a];
            }
        }
        return V
      } else {
        // TODO
      }
    }
    var dir=1;
    if (Utils.isArray(rot)) {
      switch(rot.join(',')) {
        case '1,0,0': rot='xzy'; break;
        case '-1,0,0': rot='-xzy'; break;
        case '0,1,0': rot='zyx'; break;
        case '0,-1,0': rot='-zyx'; break;
        case '0,0,1': rot='yxz'; break;
        case '0,0,-1': rot='-yxz'; break;
      }
    }
    if (rot[0]=='-') { rot=rot.slice(1); dir=-1 }; 
    if (rot=='xzy') return xzy.call(this,dir,inplace);
    if (rot=='zyx') return zyx.call(this,dir,inplace);
    if (rot=='yxz') return yxz.call(this,dir,inplace);
    throw 'Vol3.rotate: supported rotations ["(-)xzy","(-)yxz","(-)zyx","""(-)1,0,0","0,0,(-)1"]'
  },
  // kernel-based vol resizing (down- and up-sampling with interpolation/extrapolation)
  // filters: 'nearest', 'linear', 'min', 'max', 'peak'
  sample : function (sx,sy,depth,filter,datatype) {
    var dx = this.sx/sx,
        dy = this.sy/sy,
        dz = this.depth/depth,
        src = this,
        kernel;
    var V = Vol(sx,sy,depth,datatype||this.datatype()),
        dst = V;
    // TODO: inline .get/.set
    function kernelNearest(x,y,z) { return src.get(x,y,z) };
    // Down-sampling kernels
    function kernelMin(x,y,z,xR,yR,zR) {
      var q=src.get(x,y,z);
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q=Math.min(p,q)
      }
      return q;
    }
    function kernelMax(x,y,z,xR,yR,zR) {
      var q=src.get(x,y,z);
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q=Math.max(p,q) 
      }
      return q;
    }
    function kernelMean(x,y,z,xR,yR,zR) {
      var n=0,q=0;
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q+=p; n++;
      }
      return q/n;
    }    
    function kernelPeak(x,y,z,xR,yR,zR) {
      var q=src.get(x,y,z);
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q=Math.abs(p)>Math.abs(q)?p:q; 
      }
      return q;
    }
    function kernelLinearDown(x,y,z,xR,yR,zR) {
      var q=0,n=0;
      var xRn=Math.floor(xR),yRn=Math.floor(yR),zRn=Math.floor(zR);
      for(var j=y-yRn;j<=y+yRn;j++)
        for(var i=x-xRn;i<=x+xRn;i++) 
          for(var k=z-zRn;k<=z+zRn;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          var w = 1-Math.distance([i-x,j-y,k-z])/Math.distance([zR,yR,xR]);
          q+=(p*w); n++; /* padding with zeros? */
      }
      return q/n;
    }
    // Up-sampling
    function kernelLinearUp2D(x,y,z,xR,yR,zR) {
      var x_l = Math.floor(xR * x), y_l = Math.floor(yR * y),
          x_h = Math.ceil(xR * x),  y_h = Math.ceil(yR * y);
      var x_weight = (xR * x) - x_l,
          y_weight = (yR * y) - y_l;
      // TODO x,y,z boundary check
      // console.log(x,y,z,x_l,y_l,x_h,y_h);
      var a = src.get(x_l, y_l, z)||0,
          b = src.get(x_h, y_l, z)||0,
          c = src.get(x_l, y_h, z)||0,
          d = src.get(x_h, y_h, z)||0;
      return a * (1 - x_weight) * (1 - y_weight) + 
             b * x_weight * (1 - y_weight) + 
             c * y_weight * (1 - x_weight) + 
             d * x_weight * y_weight
    }
    function kernelLinearUp3D(x,y,z,xR,yR,zR) {
      var x_l = Math.floor(xR * x), y_l = Math.floor(yR * y), z_l = Math.floor(zR * z),
          x_h = Math.ceil(xR * x),  y_h = Math.ceil(yR * y), z_h = Math.floor(zR * z);
      var x_weight = (xR * x) - x_l,
          y_weight = (yR * y) - y_l,
          z_weight = (zR * z) - z_l;
      // TODO x,y,z boundary check
      var a = src.get(x_l, y_l, z_l)||0,
          b = src.get(x_h, y_l, z_l)||0,
          c = src.get(x_l, y_h, z_l)||0,
          d = src.get(x_h, y_h, z_l)||0,
          e = src.get(x_l, y_l, z_h)||0,
          f = src.get(x_h, y_l, z_h)||0,
          g = src.get(x_l, y_h, z_h)||0,
          h = src.get(x_h, y_h, z_h)||0;
          // TODO TBC
      return a * (1 - x_weight) * (1 - y_weight)  * (1 - z_weight)+ 
             b * x_weight * (1 - y_weight)  * (1 - z_weight)+ 
             c * y_weight * (1 - x_weight)   * (1 - z_weight)+ 
             d * x_weight * y_weight  * (1 - z_weight) +
             e * (1 - x_weight) * (1 - y_weight)  * z_weight+ 
             f * x_weight * (1 - y_weight)  * z_weight+ 
             g * y_weight * (1 - x_weight)   * z_weight+ 
             h * x_weight * y_weight  * z_weight;
             
    }
    if (dz==1 && this.depth==1) {
      // 2D Scaling
      if (dx>=1 && dy>=1) {
        // down-sampling
        switch (filter) {
          case 'nearest':
          case 'nn': kernel=kerneNearest; break;
          case 'mean': kernel=kernelMean; break;  
          case 'min': kernel=kernelMin; break;  
          case 'max': kernel=kernelMax; break;  
          case 'peak': kernel=kernelPeak; break;          
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearDown; break;          
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) {
          var ix = Math.floor(i*dx),
              iy = Math.floor(j*dy);
          V.set(i,j,0,kernel(ix,iy,0,dx,dy,1));
        }
      } else {
        // up-sampling
        switch (filter) {
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearUp2D; break;
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) {
            V.set(i,j,0,kernel(i,j,0,dx,dy,dz));
        }
      }
    } else {
      // 3D Scaling
      if (dx>=1 && dy>=1 && dz>=1) {
        switch (filter) {
          case 'nearest':
          case 'nn': kernel=kerneNearest; break;
          case 'mean': kernel=kernelMean; break;  
          case 'min': kernel=kernelMin; break;  
          case 'max': kernel=kernelMax; break;  
          case 'peak': kernel=kernelPeak; break;          
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearDown; break;          
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) 
            for (var k=0;k<V.depth;k++) {
          var ix = Math.floor(i*dx),
              iy = Math.floor(j*dy),
              iz = Math.floor(k*dz);
          V.set(i,j,k,kernel(ix,iy,iz,dx,dy,dz));
        }      
      } else {
        // up-sampling
        switch (filter) {
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearUp3D; break;
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) 
            for (var k=0;k<V.depth;k++) {
            V.set(i,j,k,kernel(i,j,k,dx,dy,dz));
        }      
      }
    }
    return V
  },
  // min:number||{ k, off, shift, min, max }
  scale : function (min,max,lower,upper,clip) {
    var scala;
    if (typeof min=='object') scala=min;
    else if (min==undefined && max==undefined) {
      scala=Math.scale0(this,0,1);
    } else {
      scala=Math.scale1(min,max,lower,upper);
    }
    if (!clip) for(var k=0;k<this.w.length;k++) { this.w[k] = ((this.w[k]-scala.off)*scala.k)+scala.shift; }
    else for(var k=0;k<this.w.length;k++) { 
      var v = Math.min(Math.max(this.w[k],scala.min),scala.max);
      this.w[k] = ((v-scala.off)*scala.k)+scala.shift; 
    }
    return this;
  },
  set: function(x, y, d, v) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    this.w[ix] = v; 
  },
  setConst: function(a) { for(var k=0;k<this.w.length;k++) { this.w[k] = a; }; return this},
  slice : function (dx,dy,dz,plane) {
    var V,data;
    plane=plane||'xyz'
    if (isArray(dz) && dz.length==0 && 
        isArray(dx) && dx.length==0) {
      // fast data slicing is possible
      var iy0,iy1;
      if (isArray(dy) && dy.length==0) dy=[0,this.sy-1];
      else if (typeof dy == 'number') dy=[dy,dy];
      iy0=dy[0]*this.sx*this.depth;
      iy1=(dy[1]+1)*this.sx*this.depth;
      data=this.w.slice(iy0,iy1);
      return Vol(this.sx,dy[1]-dy[0]+1,this.depth,data);
    } else {
      // data must be copied by hand
      if (isArray(dx) && dx.length==0) dx=[0,this.sx-1];
      else if (typeof dx == 'number') dx=[dx,dx];
      if (isArray(dy) && dy.length==0) dy=[0,this.sy-1];
      else if (typeof dy == 'number') dy=[dy,dy];
      if (isArray(dz) && dz.length==0) dz=[0,this.depth-1];
      else if (typeof dz == 'number') dz=[dz,dz];
      var sx = dx[1]-dx[0]+1,
          sy = dy[1]-dy[0]+1,
          sz = dz[1]-dz[0]+1;
      switch (plane) {
        case 'xyz':
          V=Vol(sx,sy,sz,this.datatype());
          data=V.w;
          for(var j=dy[0];j<=dy[1];j++)
            for(var i=dx[0];i<=dx[1];i++) 
              for(var k=dz[0];k<=dz[1];k++) {
            V.set(i-dx[0],j-dy[0],k-dz[0],this.get(i,j,k))   
          }
          return V
          break;
        case 'yzx':
          V=Vol(sy,sz,sx,this.datatype());
          data=V.w;
          for(var j=dy[0];j<=dy[1];j++)
            for(var i=dx[0];i<=dx[1];i++) 
              for(var k=dz[0];k<=dz[1];k++) {
            V.set(j-dy[0],k-dz[0],i-dx[0],this.get(i,j,k))   
          }
          return V
          break;
        default:
          throw ('Vol3.slice: supported planes ["xyz","yzx"]');
      }
    }
  },
  sub: function(x, y, d, v) { 
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] -= v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] -= v; 
    }
    return this;
  },
  subVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] -= V.w[k]; }},
  sum : function (norm) {
    var v=0;
    for(var k=0;k<this.w.length;k++) v += this.w[k];
    return norm?v/this.w.lengt:v;
  },
  to : function (datatype) {
    var V = new Vol(this.sx, this.sy, this.depth, 0, datatype);
    for(var k=0;k<this.w.length;k++) V.w[k]=this.w[k];
    return V;
  },
  toArray : function (linear) {
    if (linear) {
      return this.w.toArray()
    } else if (this.sx!=1 || this.sy!=1) {
      var ma=[],ix;
      for(var j=0;j<this.sy;j++) {
        var row = [];
        for(var i=0;i<this.sx;i++) {
          if (this.depth==1) {
            ix=((this.sx * j)+i);
            row.push(this.w[ix]);
          } else {
            var slice=[];
            for(var k=0;k<this.depth;k++) {
              ix=((this.sx * j)+i)*this.depth+k;
              slice.push(this.w[ix])
            }
            row.push(slice);
          }
        }
        ma.push(row);
      }
      return ma;
    } else {
      // Vector
      return this.w.toArray()
    }
  },
  toImage : function (scala) {
    var data,depth=this.depth;
    if (depth==4) data=this.w;
    else {
      // already layout 321
      var data=Vol.data.zeros(this.sx*this.sy*4,'Uint8');
      for(var k=0;k<this.sx*this.sy;k++) {
        var i=k*depth,j=k*4;
        data[j+3]=255;
        if (scala) for(var l=0;l<3;l++) data[j+l]=((this.w[i+(l%this.depth)]-scala.off)*scala.k)+scala.shift; 
        else for(var l=0;l<3;l++) data[j+l]=this.w[i+(l%this.depth)];
      }      
    } 
    return { width: this.sx, height: this.sy, depth:4, data:data }
  },

  toJSON: function() {
    // todo: we may want to only save d most significant digits to save space
    var json = {}
    json.sx = this.sx; 
    json.sy = this.sy;
    json.depth = this.depth;
    json.w = this.w;
    json.dt = Utils.TypedArrayToName(this.w).replace('Array','');
    return json;
  },
  toVTK : function (spacing) {
    // For VTK viewer
    var V=this;
    spacing=spacing||[1,1,1];
    var lines = [
    '<VTKFile type="ImageData" version="1.0" byte_order="LittleEndian" header_type="UInt64">',
    '<ImageData WholeExtent="0 '+(V.sx-1)+' 0 '+(V.sy-1)+' 0 '+(V.depth-1)+'" Origin="0 0 0" Spacing="'+spacing.join(' ')+'">',
    '<Piece Extent="0 '+(V.sx-1)+' 0 '+(V.sy-1)+' 0 '+(V.depth-1)+'">',
    '<PointData Scalars="Scalars_">',
    // TODO: Range
    '<DataArray type="'+V.datatype()+'" Name="Scalars_" format="ascii" RangeMin="0" RangeMax="4095">',
    ];
    var line = [];
    for(var k=0;k<V.depth;k++)  {
      for(var j=0;j<V.sy;j++) {
        for(var i=0;i<V.sx;i++) { 
          line.push(V.get(i,j,k));
        }
        lines.push('  '+line.join(' '))
        line=[]
      }
    }
    if (line.length) lines.push(line.join(' '));
    lines=lines.concat([
    '</DataArray>',
    '</PointData>',
    '<CellData>',
    '</CellData>',
    '</Piece>',
    '</ImageData>',
    '</VTKFile>',
    ]);
    return lines.join('\n');  
  }
}
// Core typed array Operations
Vol.data = {
  constant : function (n,c,datatype) {
    datatype=datatype||'Float32';
    var dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!dt) return;
    var ta = new dt(n);
    for (var k=0;k<ta.length;k++) ta[k]=c;
    return ta;
  },
  clone : function (ta,shared) {
    var datatype = Utils.TypedArrayToName(ta).replace('Array',''),
        dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!shared) return new dt(ta);
    else return new dt(ta.buffer);
  },
  from : function (a,datatype,n) {
    if (!datatype) {
      if (isTypedArray(a)) datatype=Utils.TypedArrayToName(ta).replace('Array','');
      else datatype='Float32';
    }
    var dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!dt) return;
    if (typeof a == 'string') a=Buffer.from(a);
    else if (Utils.isObject(a) && !Utils.isArray(a)) {
      // copy over the elements
      if (!n) n=Object.keys(a).length();
      var dst = new dt(n);
      for(var i=0;i<n;i++) {
        dst[i] = a[i];
      }
      return dst;
    }
    return new dt(a);  
  },
  slice : function (ta,offset,length,shared) {
    var datatype = Utils.TypedArrayToName(ta).replace('Array',''),
        dsize = Utils.DataSize[datatype],
        dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!shared) return new dt(ta.slice(offset,offset+length));
    else return new dt(ta.buffer,offset*dsize,(offset+length)*dsize);
  },
  zeros : function (n,datatype) {
    datatype=datatype||'Float32';
    var dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!dt) return;
    var ta = new dt(n);
    return ta;
  }
}
// aliases
Vol.prototype.reshape =  Vol.prototype.resize;

Vol.from = function (o,datatype) {
  var V;
  if (Math.MatrixTA.isMatrix(o)) {
    if (o.layout==21 || o.layout==321)
      V = Vol(o.columns,o.rows,o.levels||1,o.data);
    else {
      // have to copy
      V = Vol(o.columns,o.rows,o.level||1,o.datatype);
      for(var i=0;i<V.sx;i++)
        for(var j=0;j<V.sy;j++)
          for(var k=0;k<V.depth;k++) {
        V.set(i,j,k,o.get(j,i,k));   
      }
    }
    return V
  } else if (o.width && o.height && o.data) { // Image handler
    var data,depth=o.data.length/(o.width*o.height)
    if (depth==4) data=o.data;
    else {
      data=Vol.data.zeros(o.width*o.height*4,datatype);
      for(var k=0;k<o.width*o.height;k++) {
        var i=k*depth,j=k*4;
        data[j+3]=255;
        for(var l=0;l<3;l++) data[j+l]=o.data[i+(l%depth)]; 
      }
    }
    return Vol(o.width,o.height,4,data);
  } else if (o.sx && o.sy && o.depth && o.w) {
    return Vol(o.sx,o.sy,o.depth,o.w);
  }
  if (typeof o == 'string') return Vol(1,1,o.length,Vol.data.from(o,datatype));
  if (isTypedArray(o)) return Vol(1,1,o.length,o);
  if (isArray(o)) return Vol(1,1,o.length,Vol.data.from(o,datatype));
}
Vol.isVol = function (o) {
  return o instanceof Vol
}
Vol.version = '0.2.2';
module.exports = {
 Vol3:Vol
};

};
BundleModuleCode['plugins/math/fft']=function (module,exports,global,process){
/**
 * Fast Fourier Transform module
 * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)
 */
 
/* Version 1.3.1 */

(function() {
  var FFT= function (n,n2) { if (!(this instanceof FFT)) return new FFT(n,n2); this.init(n,n2) };           // top-level namespace
  var _root = this;  // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FFT=FFT;
  } else {
    window.FFT = FFT;
  }

  FFT.prototype = {
    init : function(n,n2) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        this._n = n;
        this._n2 = n2;
        this._initArray();
        this._makeBitReversalTable();
        this._makeCosSinTable();
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // 1D-FFT
    fft1d : function(re, im) {
      if (Utils.isArray(re))
        this.fft(re, im, 1);
      else if (Math.Vector.isVector(re)) 
        this.fft(re.data,im.data,1);
      else if (Math.VectorTA.isVector(re)) 
        this.fft(re.data,im.data,1);      
    },
    // 1D-IFFT
    ifft1d : function(re, im) {
      var k = 1/this._n;
      this.fft(re, im, -1);
      for(var i=0; i<this._n; i++) {
        re[i] *= k;
        im[i] *= k;
      }
    },
    // 2D-FFT
    fft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      if (Utils.isArray(re) && !Utils.isArrayArray(re)) {
        // x-axis
        for(var y=0; y<this._n; y++) {
          i = y*this._n;
          for(var x1=0; x1<this._n; x1++) {
            tre[x1] = re[x1 + i];
            tim[x1] = im[x1 + i];
          }
          this.fft1d(tre, tim);
          for(var x2=0; x2<this._n; x2++) {
            re[x2 + i] = tre[x2];
            im[x2 + i] = tim[x2];
          }
        }
        // y-axis
        for(var x=0; x<this._n; x++) {
          for(var y1=0; y1<this._n; y1++) {
            i = x + y1*this._n;
            tre[y1] = re[i];
            tim[y1] = im[i];
          }
          this.fft1d(tre, tim);
          for(var y2=0; y2<this._n; y2++) {
            i = x + y2*this._n;
            re[i] = tre[y2];
            im[i] = tim[y2];
          }
        }
      } else if (Utils.isArrayArray(re) || Math.Matrix.isMatrix(re)) {
        // TODO
      } else if (Math.MatrixTA.isMatrix(re)) {
        // TODO
      }
    },
    // 2D-IFFT
    ifft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<this._n; y++) {
        i = y*this._n;
        for(var x1=0; x1<this._n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        this.ifft1d(tre, tim);
        for(var x2=0; x2<this._n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<this._n; x++) {
        for(var y1=0; y1<this._n; y1++) {
          i = x + y1*this._n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        this.ifft1d(tre, tim);
        for(var y2=0; y2<this._n; y2++) {
          i = x + y2*this._n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // core operation of FFT
    fft : function(re, im, inv) {
      var d, h, ik, m, tmp, wr, wi, xr, xi,
          n4 = this._n >> 2;
      // bit reversal
      for(var l=0; l<this._n; l++) {
        m = this._bitrev[l];
        if(l < m) {
          tmp = re[l];
          re[l] = re[m];
          re[m] = tmp;
          tmp = im[l];
          im[l] = im[m];
          im[m] = tmp;
        }
      }
      // butterfly operation
      for(var k=1; k<this._n; k<<=1) {
        h = 0;
        d = this._n/(k << 1);
        for(var j=0; j<k; j++) {
          wr = this._cstb[h + n4];
          wi = inv*this._cstb[h];
          for(var i=j; i<this._n; i+=(k<<1)) {
            ik = i + k;
            xr = wr*re[ik] + wi*im[ik];
            xi = wr*im[ik] - wi*re[ik];
            re[ik] = re[i] - xr;
            re[i] += xr;
            im[ik] = im[i] - xi;
            im[i] += xi;
          }
          h += d;
        }
      }
    },
    // returns spectrum of signal array
    signalSpectrum : function (data,islog,norm,scale) {
      var re=data.slice(),
          im = data.map(function () { return 0 });
      this.fft1d(re,im);
      return this.spectrum(re,im,islog,norm,scale).slice(0,data.length/2);
    },
    // returns shifted spectrum array of signal input array
    signalSpectrumWindow : function (data,islog,norm,scale) {
      var res=[];
      for(var off=0;off<(data.length-this._n);off++) {
        var re = data.slice(off,off+this._n),
            im = re.map(function () { return 0 });
        this.fft1d(re,im);
        res.push(this.spectrum(re,im,islog,norm,scale).slice(0,this._n/2)); 
      }
      return res;
    },
    // returns amplitude spectrum array from re/im fft output
    spectrum : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
     // returns phase spectrum
    phase : function (re,im,islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          n2 = this._n*(this._n2||1),
          log = Math.log,
          atan = Math.atan;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(atan(im[i]/re[i]));
        } else {
          spectrum[i] = atan(im[i]/re[i]);
        }
      }
      return spectrum;
    },
    // returns power spectrum
    power : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log((re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = (re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
    // initialize the array (supports TypedArray)
    _initArray : function() {
      if(typeof Uint8Array !== 'undefined') {
				if(this._n<=256)
                                        this._bitrev = new Uint8Array(this._n);
				else if(this._n<=65536)
					this._bitrev = new Uint16Array(this._n);
				else
					this._bitrev = new Uint32Array(this._n);
      } else {
        this._bitrev = [];
      }
      if(typeof Float64Array !== 'undefined') {
        this._cstb = new Float64Array(this._n*1.25);
      } else {
        this._cstb = [];
      }
    },
    // zero padding
    _paddingZero : function() {
      // TODO
    },
    // makes bit reversal table
    _makeBitReversalTable : function() {
      var i = 0,
          j = 0,
          k = 0;
      this._bitrev[0] = 0;
      while(++i < this._n) {
        k = this._n >> 1;
        while(k <= j) {
          j -= k;
          k >>= 1;
        }
        j += k;
        this._bitrev[i] = j;
      }
    },
    // makes trigonometiric function table
    _makeCosSinTable : function() {
      var n2 = this._n >> 1,
          n4 = this._n >> 2,
          n8 = this._n >> 3,
          n2p4 = n2 + n4,
          t = Math.sin(Math.PI/this._n),
          dc = 2*t*t,
          ds = Math.sqrt(dc*(2 - dc)),
          c = this._cstb[n4] = 1,
          s = this._cstb[0] = 0;
      t = 2*dc;
      for(var i=1; i<n8; i++) {
        c -= dc;
        dc += t*c;
        s += ds;
        ds -= t*s;
        this._cstb[i] = s;
        this._cstb[n4 - i] = c;
      }
      if(n8 !== 0) {
        this._cstb[n8] = Math.sqrt(0.5);
      }
      for(var j=0; j<n4; j++) {
        this._cstb[n2 - j]  = this._cstb[j];
      }
      for(var k=0; k<n2p4; k++) {
        this._cstb[k + n2] = -this._cstb[k];
      }
    }
  };
}).call(this);

/**
 * Spatial Frequency Filtering
 * High-pass/Low-pass/Band-pass Filter
 * Windowing using hamming window
 */
(function() {
  var FrequencyFilter={};  // top-level namespace
  var _root = this;     // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FrequencyFilter=FrequencyFilter;
  } else if(typeof exports !== 'undefined') {
    FrequencyFilter = exports;   // for CommonJS
  } else {
    FrequencyFilter = _root.FrequencyFilter = {};
  }

  // core operations
  var _n = 0;
  var core = {
    init : function(n) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        _n = n;
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // swaps quadrant
    swap : function(re, im) {
      var xn, yn, i, j, k, l, tmp,
          len = _n >> 1;
      for(var y=0; y<len; y++) {
        yn = y + len;
        for(var x=0; x<len; x++) {
          xn = x + len;
          i = x + y*_n;
          j = xn + yn*_n;
          k = x + yn*_n;
          l = xn + y*_n;
          tmp = re[i];
          re[i] = re[j];
          re[j] = tmp;
          tmp = re[k];
          re[k] = re[l];
          re[l] = tmp;
          tmp = im[i];
          im[i] = im[j];
          im[j] = tmp;
          tmp = im[k];
          im[k] = im[l];
          im[l] = tmp;
        }
      }
    },
    // applies High-Pass Filter
    HPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Low-Pass Filter
    LPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r > radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Band-Pass Filter
    BPF : function(re, im, radius, bandwidth) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius || r > (radius + bandwidth)) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // windowing using hamming window
    windowing : function(data, inv) {
      var len = data.length,
          pi = Math.PI,
          cos = Math.cos;
      for(var i=0; i<len; i++) {
        if(inv === 1) {
          data[i] *= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        } else {
          data[i] /= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        }
      }
    }
  };
  // aliases (public APIs)
  var apis = ['init', 'swap', 'HPF', 'LPF', 'BPF', 'windowing'];
  for(var i=0; i<apis.length; i++) {
    FrequencyFilter[apis[i]] = core[apis[i]];
  }
}).call(this);

/**
 * FFT Power Spectrum Viewer
 */
(function() {
  var SpectrumViewer={};  // top-level namespace
  var _root = this;    // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.SpectrumViewer=SpectrumViewer;
  } else if(typeof exports !== 'undefined') {
    SpectrumViewer = exports;   // for CommonJS
  } else {
    SpectrumViewer = _root.SpectrumViewer = {};
  }

  // core operations
  var _context = null,
      _n = 0,
      _img = null,
      _data = null;
  var core = {
    init : function(context) {
      _context = context;
      _n = context.canvas.width,
      _img = context.getImageData(0, 0, _n, _n);
      _data = _img.data;
    },
    // renders FFT power spectrum on the canvas
    render : function(re, im, islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = _n*_n,
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(Math.sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      for(var j=0; j<n2; j++) {
        spectrum[j] = spectrum[j]*255*imax;
      }
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x=0; x<_n; x++) {
          val = spectrum[i + x];
          p = (i << 2) + (x << 2);
          _data[p] = 0;
          _data[p + 1] = val;
          _data[p + 2] = val >> 1;
        }
      }
      _context.putImageData(_img, 0, 0);
    }
  };
  // aliases (public APIs)
  SpectrumViewer.init = core.init;
  SpectrumViewer.render = core.render;
}).call(this);
};
BundleModuleCode['plugins/math/conv']=function (module,exports,global,process){
/*
** Convolution and correlation of vectors and matrix objects
** using FFT
*/
function setup(a,b) {
  var N = a.length,
      M = Math.pow(2,Math.ceil(Math.log2(N))),
      N2  = M*2;
  var data1 = a.data?a.toArray():a,
      data2 = b.data?b.toArray():b;
  if (N!=M) {
    data1=data1.pad(M);
    data2=data2.pad(M);
  }
  var fft   = Math.FFT.FFT(N2);
  var re1   = data1.pad(N2,0);
  var im1   = Array.init(re1.length);
  fft.fft1d(re1,im1);
  var re2   = data2.pad(N2,0);
  var im2   = Array.init(re2.length);
  fft.fft1d(re2,im2);
  return {
    fft:fft,
    reA:re1,
    imA:im2,
    reB:re2,
    imB:im2
  }
}
Convolution = {
  convolute1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('convolute: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB);
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.add(im).slice(0,N),
          ca = Convolution.correlate1d(a,a), // ??
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.add(im).slice(0,N)
  },
  correlate1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('correlate: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB.mul(-1));
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.sub(im).slice(0,N),
          ca = Convolution.correlate1d(a,a),
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.sub(im).slice(0,N)
  }
}

module.exports = Convolution;
};
FilesEmbedded['plugins/math/help.md']=function (format){return Base64.decode('JTIzJTIwTWF0aCUwQSUwQSUyMyUyMyUyMFV0aWxzJTBBJTBBTWF0aC5hdmVyYWdlJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBFbGVtZW50LXdpc2UlMjBtZWFuJTIwdmFsdWVzJTBBJTIwJTIwYXJndW1lbnRzJTIwJTNBJTIwJTI4bnVtYmVyJTdDJTdCJTdEJTdDJTVCJTVEJTI5JTIwJTVCJTVEJTBBJTIwJTIwcmV0dXJuJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTdDJTdCJTdEJTdDJTVCJTVEJTBBJTBBJTIzJTIzJTIwR2VvbWV0cnklMEElMEFNYXRoLmRlbHRhJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBEZWx0YSUyMHZlY3RvciUwQSUyMCUyMHBvaW50MSUyMCUzQSUyMCU1QnglMkN5JTJDLi4lNUQlMEElMjAlMjBwb2ludDElMjAlM0ElMjAlN0J4JTJDeSUyQy4uJTdEJTBBJTIwJTIwcG9pbnQyJTIwJTNBJTIwJTVCeCUyQ3klMkMuLiU1RCUwQSUyMCUyMHBvaW50MiUyMCUzQSUyMCU3QnglMkN5JTJDLi4lN0QlMEElMjAlMjByZXR1cm4lMjAlM0ElMjAlNUIlNUQlMEElMjAlMjByZXR1cm4lMjAlM0ElMjAlN0IlN0QlMEElMEFNYXRoLmRpc3RhbmNlJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBFdWNsaWRpYW4lMjBkaXN0YW5jZSUwQSUyMCUyMHBvaW50MSUyMCUzQSUyMCU1QnglMkN5JTJDLi4lNUQlMEElMjAlMjBwb2ludDElMjAlM0ElMjAlN0J4JTJDeSUyQy4uJTdEJTBBJTIwJTIwcG9pbnQyJTNGJTIwJTNBJTIwJTVCeCUyQ3klMkMuLiU1RCUwQSUyMCUyMHBvaW50MiUzRiUyMCUzQSUyMCU3QnglMkN5JTJDLi4lN0QlMEElMjAlMjByZXR1cm4lMjAlM0ElMjBudW1iZXIlMEElMEFNYXRoLm5lYXJlc3QlMjAlM0ElMjBmdW5jdGlvbiUyMCUyMyUyMEZpbmQlMjBuZWFyZXN0JTIwcG9pbnQlMjBpbiUyMG51bWJlciUyMHNlcmllcyUwQSUyMCUyMHBvaW50cyUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUyMCUyMHZhbHUlMjAlMjAlMjAlM0ElMjBudW1iZXIlMEElMjAlMjBlcHNpbG9uJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwJTdCJTIweCUzQWluZGV4JTIwbnVtYmVyJTJDJTIweSUzQW51bWJlciUyMCU3RCUwQSUwQSUyMyUyMyUyMFJhbmRvbSUwQSUwQU1hdGgucmFuZG9tJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBSYW5kb20lMjBudW1iZXIlMjAlNUIwJTJDMSUyOSUwQSUyMCUyMHJldHVybiUyMCUzQSUyMG51bWJlciUwQSUwQU1hdGgucmFuZG9tLnNlbGVjdCUyMCUzQSUyMGZ1bmN0aW9uJTIwJTIzJTIwUmFuZG9tJTIwc2VsZWN0aW9uJTBBJTIwJTIwY2hvaWNlcyUyMCUzQSUyMCUyN2ElMjAlNUIlNUQlMjAlMEElMjAlMjByZXR1cm4lMjAlM0ElMjAlMjdhJTBBJTBBJTIwJTIwJTBBJTIwJTIwJTBB')};

Base64=Require('os/base64');
//Buffer=Require('os/buffer').Buffer;
window.MATH=MATH = Require('plugins/math/math.js');
</script>
    <script>var CoreModule = {};
CoreModule['com/io']='com/io.browser';
CoreModule['crypto']='os/crypto';
CoreModule['util']='os/util';
CoreModule['http']='os/http.browser';
CoreModule['url']='os/url';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['fs']='';
CoreModule['stream']='';
CoreModule['zlib']='';
CoreModule['dgram']='';
CoreModule['net']='';
CoreModule['child_process']='';
CoreModule['dns']='';
CoreModule['buffer']='os/buffer';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
// PATH=[".","/home/sbosse/proj/workbook/src"];
if (typeof global == "undefined")  global=(typeof window != "undefined"?window:{})
if (typeof process == "undefined") var process={browser:true};
Require=function(modupath) {
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}, module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,window,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,window,process);
  else return undefined;
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
var FilesEmbedded = {};
var FileEmbedd = function (path,format) {};
var FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='browser';
Script=function(){};

BundleModuleCode['os/buffer']=function (module,exports,global,process){
var Ieee754 = Require('os/buffer_ieee754');

/* ------- base64-js -------- */
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}
/* ------- base64-js -------- */

var assert;

exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= {
    ok : function(cond,msg) {
      if (cond != true) {
        console.log('** Assertion failed: '+msg+' **');
        throw Error(msg);
      }
    }
  };
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new TypeError('First argument needs to be a number, ' +
                            'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          // Round-up subject[i] to a UInt8.
          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
          //                                  = 80
          this[i] = ((subject[i] % 256) + 256) % 256;
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var b = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(b)) throw new Error('Invalid hex string');
    this[offset + i] = b;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }
  // TODO
  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
};
BundleModuleCode['os/buffer_ieee754']=function (module,exports,global,process){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};
};
BundleModuleCode['com/io.browser']=function (module,exports,global,process){
    /*
    ************
    ** Browser
    ************
    */

    var tracing = true;
    var stderr_fun = function (str) { console.log(str); };
    var stdout_fun = function (str) { console.log(str); };
    var args=[];

    module.exports = {
        checkOptions : function(options,defaultOptions) {
          return Object.assign({}, defaultOptions||{}, options) },

        checkOption : function (option,defaultOption) { 
          return option==undefined? defaultOption:option },

        config: {
            columns:undefined,
            rows:undefined
        },
        /*
         ** FILE IO
         * TODO WebStorage
         */
        close: function (fd) {
            return;
        },
        exists: function (path) {
            return false;
        },
        open: function (path, mode) {
            var fd = Fs.openSync(path, mode);
            return fd;
        },

        read: function (fd, len, foff) {
            // TODO
        },
        read_file: function (path) {
            return '';
        },

        read_line: function (fd) {
            // TODO
        },
        /**
         *
         * @param fd
         * @param buf
         * @param boff
         * @param len
         * @param [foff]
         * @returns {*}
         */
        read_buf: function (fd, buf, boff, len, foff) {
            return -1;
        },
        sync: function (fd) {
            return;
        },
        
        /**
         *
         * @param fd
         * @param data
         * @param [foff]
         * @returns {*}
         */
        write: function (fd, data, foff) {
            return -1;
        },
        /**
         *
         * @param fd
         * @param buf
         * @param bpos
         * @param blen
         * @param [foff]
         * @returns {*}
         */
        write_buf: function (fd, buf, bpos, blen, foff) {
            return -1;
        },

        /*
         ** CONSOLE IO
         */
        debug: function (msg) {
            stderr_fun('Debug: ' + msg);
        },
        err: function (msg) {
            stderr_fun('Error: ' + msg);
            throw Error(msg);
        },
        fail: function (msg) {
            stderr_fun('Fatal Error: ' + msg);
        },
        inspect: function (obj) {
            return;
        },
        stacktrace: function () {
            var e = new Error('dummy');
            var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                .split('\n');
            stderr_fun('Stack Trace');
            stderr_fun('--------------------------------');
            for(var i in stack) {
                if (i>0) {
                    var line = stack[i];
                    if(line.indexOf('Module.',0)>=0) break;
                    stderr_fun(line);
                }
            }
            stderr_fun('--------------------------------');
        },
        time : function () {
          return Date.now()
        },
        /**
         *
         * @param e
         * @param where
         */
        printstack: function (e,where) {
            if (where==undefined) stderr_fun(e);
            else stderr_fun(where+': '+e);
        },
        /**
         *
         * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
         */
        log: function (condmsg) {
            if (condmsg != true) console.warn(condmsg);
        },
        out: function (msg) {
            stdout_fun(msg)
        },
        warn: function (msg) {
            stderr_fun('Warning: ' + msg);
        },


        set_stderr: function(fun) {
            stderr_fun=fun;
        },
        set_stdout: function(fun) {
            stdout_fun=fun;
        },

        stderr: function (msg) {
            stderr_fun(msg);
        },
        stdout: function (msg) {
            stdout_fun(msg);
        },

        /** Write a message with a time stamp written to the trace file.
         *
         * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
         */
        trace: function (condmsg) {
            if (condmsg != true && tracefile != undefined) {
                var date = new Date();
                var time = date.getTime();
                this.log('[' + time + '] ' + condmsg + '\n');
            }
        },
        tracing: tracing,
        /**
         *
         * @param {string} path
         */
        trace_open: function (path) {
            return undefined;
        },

        exit: function (n) {
            return;
        },
        /**
         *
         * @returns {*} RSS HEAP in kBytes {data,heap}
         */
        mem: function () {
            return {data:0,heap:0};
        },

        getenv: function (name, def) {
            return def;
        },
        workdir: function () {
            return '';
        },
        /**
         *  @return {string []}
         */
        getargs: function () {
            return args;
        },
        set_args: function (argv) {
            args=argv;
        }
    };
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['os/util']=function (module,exports,global,process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = function isBuffer(arg) {
  return arg && typeof arg === 'object'
             && typeof arg.copy === 'function'
             && typeof arg.fill === 'function'
             && typeof arg.readUInt8 === 'function';
};

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */

exports.inherits = Require('os/inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
};
BundleModuleCode['os/inherits']=function (module,exports,global,process){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['plugins/ml/ml.js']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     8-2-16 by sbosse.
 **    $VERSION:     1.31.1X
 **
 **    $INFO:
 **
 **  JavaScript Machine Learning API
 **
 ** type algorithm = {'dti','dt','id3','c45','kmeans','knn','knn2','mlp','slp','rl','svm','txt','cnn'}
 **
 **
 ** id3: Symbolic Decision Tree algorithm
 ** -------------------------------------
 **
 ** typeof @options = {
 **   algorithm='id3',
 **   data:{x1:number,x2:number,..,y:*} []
 **   target:string is e.g. 'y'
 **   features: string [] is e.g. ['x1','x2',..]
 ** }
 **
 ** ice: decision tree algorithm supporting numbers with eps intervals (hybrid C45/ID3)
 ** -------------------------------------
 **
 ** General feature variable set:
 **
 ** typeof @options = {
 **   algorithm='dt',
 **   data:{x1:number,x2:number,..,y:*} [],
 **   target:string is e.g. 'y',
 **   features: string [] is e.g. ['x1','x2',..],
 **   eps:number is e.g. '5',
 ** }
 ** 
 ** dti: interval decision tree algorithm
 ** -------------------------------------
 **
 ** General feature variable set:
 **
 ** typeof @options = {
 **   algorithm='dti',
 **   data:{x1:number,x2:number,..,y:*} []
 **   target:string is e.g. 'y'
 **   features: string [] is e.g. ['x1','x2',..]
 **   eps:number is e.g. '5',
 **   maxdepth:number,
 ** }
 ** 
 ** Or vector feature variables (i.e., features=[0,1,2,...n-1], target=n):
 **
 ** typeof @options = {
 **   algorithm='dti',
 **   x:* [] [],
 **   y:* [],
 **   eps:number is e.g. '5',
 **   maxdepth:number,
 ** }
 **
 ** knn: k-Nearest-Neighbour Algorithm
 ** ----------------------------------
 **
 ** typeof @options = {
 **   algorithm='knn',
 **   x: number [][], 
 **   y: * []
 ** }
 **
 ** mlp: single/multi layer perceptron Algorithm
 ** ----------------------------------
 **
 ** typeof @options = {
 **   algorithm='mlp',
 **   x: number [][], 
 **   y: number [] [] | * [],
 **   hidden_layers?:number [],
 **   lr?:number,
 **   epochs?:number,
 **   labels?:string [], 
 **   features?: string [], 
 **   normalize?, 
 **   verbose?:number
 ** }
 **
 ** ann: Universal ANN (neataptic)
 ** ----------------------------------
 **
 ** typeof @learner.options = {
 **   algorithm='ann',
 **   layers:number [],
 **   architecture : archtyp string [],
 **   activation? : actfun string | actfun string [] 
 ** }
 ** with actfun = 'RELU'|'LOGISTC'|'IDENTITY'|'STEP'|'TANH'|.. and
         acttyp = 'LSTM'|'GRU'|'Dense'|
 ** typeof @train.options = {
 **   alpah?: number,
 **   gamma?: number,
 **   iterations? : number,
 **   error?: number,
 ** }
 **
 ** cnn: Convolutional Neural Network for numerial (2D) data
 ** -------------------------------------
 **
 ** General feature variable set:
 **
 ** typeof @options = {
 **   algorithm='cnn',
 **   data:{x:[]|[][],y:'a} []
 **   layers: layer [],
 **   trainer:trainer,
 ** }
 ** type layer = 
 **  {type:'input', out_sx:number, out_sy:number, out_depth:number} | // Input Layer
 **  {type:'conv', sx:number, filters:number, stride:number, pad:number, activation:string} | // Convolution Layer
 **  {type:'pool', sx:number, stride:number} | // Pooling Layer
 **  {type:'softmax', num_classes:number} | // Classifier Layers
 **  {type:'svm', num_classes:number| // Classifier Layers
 **  {type:'fc', num_neurons:number, activation:string} // Fully Connected Layer
 **
 ** typeof activation = 'relu'| 'maxout' | 'sigmoid' | 'tanh' ..
 **
 ** type trainer = 
 **  {method: 'sgd', learning_rate:number,  momentum: number, batch_size:number, l2_decay:number} |
 **  {method: 'adadelta', learning_rate:number,  eps: number, ro:number, batch_size:number, l2_decay:number} |
 **  {method: 'adam', learning_rate:number, eps: number, beta1: number, beta2: number, batch_size: number, l2_decay:number} |
 **  ..
 **
 ** text: text analysis (similarity checking)
 ** -----------------------------------------
 **   classify(model,string) -> {match:number [0..1],string:string }
 **   learn({algorithm:ML.TXT, data:string []]) -> model
 **   test({algorithm:ML.TXT,string:string}|model,string) -> number [0..1]
 **   similarity(string,string) -> number [0..1]
 ** 
 **
 ** simulated annealing
 ** -------------------
 **
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var _ = undefined;
var none = null;


var ICE = Require('plugins/ml/ice'); // ICE ID3/C45 eps
var DTI = Require('plugins/ml/dti');
var KNN = Require('plugins/ml/knn');
var KMN = Require('plugins/ml/kmeans');
var SVM = Require('plugins/ml/svm');
var MLP = Require('plugins/ml/mlp');
var ID3 = Require('plugins/ml/id3');
var C45 = Require('plugins/ml/C45');
var TXT = Require('plugins/ml/text');
var RF  = Require('plugins/ml/rf');
var RL  = Require('plugins/ml/rl');
var RT  = Require('plugins/ml/rt');
var STAT= Require('plugins/ml/stats');
var CNN = Require('plugins/ml/cnn');
var ANN = Require('plugins/ml/ann');
var PCA = Require('plugins/ml/pca');
var DBCLUST = Require('plugins/ml/dbclust');
var REG = Require('plugins/ml/reg');
var MATH    = Require('plugins/ml/math');
var PRE = Require('plugins/ml/pre');
var SA  = Require('plugins/ml/sa');
var DR  = Require('plugins/math/druid');
var SOM = Require('plugins/ml/som');
var HELP  = Require('plugins/ml/helpers');

var MAN  = FileEmbedded('plugins/ml/help.md','utf8');

var array2Object = PRE.array2Object,
    autoScale = PRE.autoScale,
    getOptions = HELP.getOptions,
    obj2Array = PRE.obj2Array,
    objSlice = PRE.objSlice,
    preprocess = PRE.preprocess,
    relax=PRE.relax,
    _scale = PRE.scale,
    split=PRE.split,
    toScale=PRE.toScale,
    unscale = PRE.unscale,
    updateOptions=HELP.updateOptions,
    wrap=PRE.wrap;
function scale (data, scales) {
  if (Utils.isMatrix(data)) {
    return data.map(function (row) {
      return _scale(row,scales)
    })
  } else if (Utils.isObject(data[0])) {
    return data.map(function (obj) {
      var objS = {}
      for(var key in obj) {
        objS[key]=_scale(obj[key],scales[key]||scales);
      }
      return objS
    })
  } return _scale(data,scales)
}
function scale0 (data,lower,upper) {
  if (Utils.isMatrix(data)) {
    return Object.keys(data[0]).map(function (attr) {
      var min,max;
      for(var i in data) {
        if (i==0) { min=max=data[i][attr] }
        else { 
          min=Math.min(min,data[i][attr]); 
          max=Math.max(max,data[i][attr]); 
        }
      }
      return toScale(min,max,lower,upper);
    })
  } else if (Utils.isObject(data[0])) {
    var scales=[]
    Object.keys(data[0]).map(function (attr) {
      var min,max;
      for(var i in data) {
        if (i==0) { min=max=data[i][attr] }
        else { 
          min=Math.min(min,data[i][attr]); 
          max=Math.max(max,data[i][attr]); 
        }
      }
      scales[attr]=toScale(min,max,lower,upper);
    })
    return scales;
  }
}
var current=none;
var Aios=none;

var options = {
  version: '1.31.1X'
}

// Some definitions
var ML = {
  // Algorithms
  ANN   : 'ann',    // neataptic NN 
  C45   : 'c45',
  CNN   : 'cnn',
  ICE   : 'ice',   // ICE ID3/C45 eps
  DT    : 'ice',   // ICE ID3/C45 eps
  DTI   : 'dti',
  ID3   : 'id3',
  KMN   : 'kmeans',
  KNN   : 'knn',
  KNN2  :'knn2',
  MLP   : 'mlp',
  REG   : 'reg',   // Function Rregression
  RF    : 'rf',    // Random Forest
  RL    : 'rl',    // Reinforcement Leerner
  RT    : 'rt',    // Regression Tree
  SLP   : 'slp',  // Synonym for MLP (but single layer)
  SVM   : 'svm',
  TXT   : 'txt',
  SA    : 'simuan', // Simulated Annelaing optimisation
  SOM   : 'som',  // Self-orga. maps, Kohonen network
  // Some Functions
  EUCL  : 'euclidean',
  PEAR  : 'pearson',
  
  // loaded on demand (wasm)
  XGBOOST : 'xgboost',
  
  // RL agents
  DPAgent   : 'DPAgent',
  TDAgent   : 'TDAgent',
  DQNAgent  : 'DQNAgent',
};


// API
var  ml = {
  // only RL
  action : function (model,arg) {
    switch (model.algorithm) {
      // Selects and returns next action from set of actions
      case ML.RL:
        switch (model.kind) {
          case ML.DQNAgent:
            // arg == state array
            return model.actions[RL.DQNAgent.code.act(model,arg)];   
            break;
          case ML.DPAgent:
            // arg == state (integer number)
            return model.actions[RL.DPAgent.code.act(model,arg)];   
            break;
          case ML.TDAgent:
            // arg == state (integer number)
            return model.actions[RL.TDAgent.code.act(model,arg)];   
            break;
        }
        break;   
    }
  },
  
  compact: function (model) {
    switch (model.algorithm) {
      case ML.DTI:
      default:
        return DTI.compactTree(model);
    }
  },
  
  depth: function (model) {
    switch (model.algorithm) {
      case ML.DTI:
        return DTI.depth(model);
      case ML.DT:
      case ML.ICE:
        return ICE.depth(model);
      case ML.C45:
        return C45.depth(model);
      case ML.ID3:
        return ID3.depth(model);
    }
  },
  
  
  evaluate: function (model,target,samples) {
    switch (model.algorithm) {
      case ML.DTI:
      default:
        return DTI.evaluate(model,target,samples);
    }
  },

  
  info: function (model) {
    switch (model.algorithm) {
      case ML.C45:
        return C45.info(model);
      case ML.DT:
      case ML.ICE:
        return ICE.info(model);
      case ML.ID3:
        return ID3.info(model);
    }
  },
  
  help : function (topic) {
    var i,j,Models = Object.keys(ML),
        models = Models.map(function(k) { return ML[k] });
    if ((i=Models.indexOf(topic))!=-1 || (j=models.indexOf(topic))!=-1) {
      if (j!=undefined && j!=-1) topic=Models[j]
      var result=[],start=MAN.indexOf('\n## '+topic),stop=MAN.indexOf('\n##',start+3);
      if (start!=-1 && stop!=-1) return MAN.slice(start+1,stop-1);
      else if (start!=-1) return MAN.slice(start+1);
    }
    return MAN
  },
  /** Learning: Create a learner instance and a classification model from training data (or an empty model that can be updated/trained later)
   *
   */
  learner: function (options) {
    var model,data,data2,x,y,features,featureTypes,test,target,more,
        result,cols,n_ins,n_outs,x,y,xscale,xoffset,xshift,yscale,yoffset,yshift,key,err,
        t0=Io.time();
    if (!options.algorithm || typeof options.algorithm != 'string') throw 'ML.learner: Invalid options (algorithm is missing)';
    switch (options.algorithm) {
    
      case ML.ANN:
        // Neataptic ANN Framework
        // typeof options = { x,y,features?,target?, 
        //                    equal?, iterations?:number, error?:number, rate?:number, clear?:boolean,  
        //                    layers:number [], architect?:string|string []}
        if (options.x && options.y) data = preprocess(options,'io',options);
        model={};
        model.algorithm=options.algorithm
        if (!options.layers && !options.network) throw 'ML.learn.ANN: Invalid options';
        if (options.architect) {
          // Special MLP
          if (options.architect instanceof Array) {
            // Different architectures in each layer
            if (options.architect.length != options.layers.length) throw "ML.trainer.ANN: layers & architect array must have same size";
            var layers = ANN.architect.Layers(options);
            model.network = ANN.architect.Construct(layers);
          } else {
            switch (options.architect) {
              case 'LSTM':
                more={}; // memoryToMemory, outputToMemory, outputToGates, inputToOutput, inputToDeep
                // model.network = new (Constructor(ANN.architect.LSTM,options.layers.concat(more)));
                model.network = ANN.architect.LSTM.apply(null,options.layers.concat(options));
                if (data) model.network.train(data,options);
                break;
              case 'GRU':
                more={}; // memoryToMemory, outputToMemory, outputToGates, inputToOutput, inputToDeep
                // model.network = new (Constructor(ANN.architect.LSTM,options.layers.concat(more)));
                model.network = ANN.architect.GRU.apply(null,options.layers);
                if (data) model.network.train(data,options);
                break;
            }
          }
        } else {
          // SLP/MLP
          if (options.network)
            model.network = new ANN.Network.fromJSON(options.network);
          else {
            model.network = ANN.architect.Network.apply(null,options.layers);
            model.network.configure({
              activation:options.activation,  // act. function
            });
          }
          if (data) model.network.train(data,options);
        }
        model.options=options;
        model.time=Io.time()-t0;
        return model;
        break;      
        

      case ML.CNN:
        // typeof options = {x:[][],y:[],targets?:[],..}
        model = CNN.create(options);
        model.algorithm=options.algorithm;
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.C45:
        // typeof options = {data: {}[], target:string, features: string []} |
        //                  {data: [][], target?:string, features?: string []} |
        //                  {x: number [][], y:[]} |
        //                  {data: {x,y}[] }
        var model = C45.create();
        if (options.x && options.y) {
          features=options.x[0].map(function (col,i) { return String(i) }); 
          featureTypes=options.x[0].map(function (col,i) { return 'number' });
          data=options.x.map(function (row,i) { row=row.slice(); row.push(options.y[i]); return row});
          target='y';
        } else if (options.data && Comp.obj.isMatrix(options.data)) {
          data=options.data;
          features=options.features||options.data[0].slice(0,-1).map(function (col,i) { return String(i) });
          featureTypes=options.data[0].slice(0,-1).map(function (col,i) { return typeof col == 'number'?'number':'category' });
          target=options.target||'y';
        } else if (options.data && Comp.obj.isObj(options.data[0]) && options.data[0].x && options.data[0].y!=undefined) {
          data=options.data.map(function (row) { return row.x.concat(row.y) });
          features=options.features||options.data[0].x.slice(0,-1).map(function (col,i) { return String(i) });
          featureTypes=options.data[0].x.slice(0,-1).map(function (col,i) { return typeof col == 'number'?'number':'category' });
          target=options.target||'y';
        } else if (options.data && Comp.obj.isArray(options.data) && Comp.obj.isObj(options.data[0]) && 
                   options.target && options.features) {
          rowNames=Comp.obj.isArray(options.target)?options.features.concat(options.target):
                                                    options.features.concat([options.target]);
          data=options.data.map(function (row) { return obj2Array(row,rowNames) })
          features=options.features;
          featureTypes=data[0].slice(0,-1).map(function (col,i) { return typeof col == 'number'?'number':'category' });
          target=options.target;
        } else throw 'ML.learn.C45: Invalid options';

        C45.train(model,{
          data: data,
          target: target,
          features: features,
          featureTypes: featureTypes
        });
        model.algorithm=options.algorithm
        model.time=Io.time()-t0;
        return model;
        break;


      case ML.DTI:
        // typeof options = {data: {}[], target:string, features: string [], eps;number, maxdepth} |
        //                   {x: number [][], y:[], eps;number, maxdepth}
        if (options.eps==_) options.eps=0;
        if (options.maxdepth==_) options.maxdepth=20;
        if (options.data && options.target && options.features)
          model = DTI.create(options);
        else if (options.x && options.y) {
          if (options.x.length != options.y.length) throw 'ML.learn.DTI: X and Y vector have different length';
          data=options.x.map(function (row,i) { row=row.slice(); row.push(options.y[i]); return row});
          features=Comp.array.init(data[0].length-1,function (i) { return String(i)});
          target=String(data[0].length-1);
          // console.log(data,features,target)
          model = DTI.create({
            data:data,
            features:features,
            target:target,
            eps:options.eps,
            maxdepth:options.maxdepth
          });
        } else throw 'ML.learn.DTI: Invalid options';
        model.algorithm=options.algorithm;
        model.time=Io.time()-t0;
        return model;


      case ML.ICE:
      case ML.DT:
        if (options.eps==_) options.eps=0;
        if (options.data && options.target && options.features)
          model = ICE.create(options);                  
        else if (options.x && options.y) {
          if (options.x.length != options.y.length) throw 'ML.learn.ICE: X and Y vector have different length';
          data=options.x.map(function (row,i) { row=row.slice(); row.push(options.y[i]); return row});
          features=Comp.array.init(data[0].length-1,function (i) { return String(i)});
          target=String(data[0].length-1);
          model = ICE.create({
            data:data,
            features:features,
            target:target,
            eps:options.eps,
          });
        } else throw 'ML.learn.ICE: Invalid options';
        model.algorithm=options.algorithm;
        model.eps=options.eps;
        model.time=Io.time()-t0;
        return model;
        break;      

      case ML.ID3:
        if (options.data && options.target && options.features)
          model = ID3.createTree(options.data,options.target,
                                 options.features);
        else throw 'ML.learn.ID3: Invalid options';
        model.algorithm=options.algorithm
        model.time=Io.time()-t0;
        return model;
        break;      
          
      case ML.KNN:
        // typeof @options = {data: {}[]|[][], distance?:function|string,k?:number}
        // typeof @options = {x:number [][], y:number [], 
        //                    distance?:function|string,k?:number}
        if (options.features && options.target) target=options.target,features = options.features;
        else {
          features = [];
          if (options.data) {
            for(key in options.data[0]) features.push(key);
            target = features.pop()
          } else if (options.x) {
            for(key in options.x[0]) features.push('x'+key);
            target='y';
          }
        }
        if (options.data && Comp.obj.isObj(options.data[0])) {
          x = options.data.map(function (row) { return obj2Array(row,features) });
          y = options.data.map(function (row) { return row[target] })
        } else if (options.data && Comp.obj.isMatrix(options.data)) {
          x = options.data,map(function (row) { return row.slice(0,row.length-1) });
          y = options.data,map(function (row) { return row[row.length-1] });
        } else if (options.x && options.y) {
          x = options.x;
          y = options.y;
        }
        model = KNN.create(
          x,
          y,
          {
            distance:options.distance,
            k:options.k
          });
        model.algorithm = options.algorithm
        model.features  = features
        model.target    = target
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.KNN2:
        // typeof @options = {data: {}[]|[][], distance?:function|string,k?:number}
        // typeof @options = {x:number [][], y:number [], 
        //                    distance?:function|string,k?:number}
        if (options.features && options.target) target=options.target,features = options.features;
        else {
          features = [];
          if (options.data) {
            for(key in options.data[0]) features.push(key);
            target = features.pop()
          } else if (options.x) {
            for(key in options.x[0]) features.push('x'+key);
            target='y';
          }
        }
        if (options.data && Comp.obj.isObj(options.data[0])) {
          x = options.data.map(function (row) { return obj2Array(row,features) });
          y = options.data.map(function (row) { return row[target] })
        } else if (options.data && Comp.obj.isMatrix(options.data)) {
          x = options.data,map(function (row) { return row.slice(0,row.length-1) });
          y = options.data,map(function (row) { return row[row.length-1] });
        } else if (options.x && options.y) {
          x = options.x;
          y = options.y;
        }
        model = KNN.create2(
          {
            x : x,
            y : y,
            distance:options.distance,
            k:options.k
          });
        model.algorithm=options.algorithm
        model.features = features
        model.target = target
        model.time=Io.time()-t0;
        return model;
        break;
        
      case ML.KMN:
        if (options.data && Comp.obj.isMatrix(options.data)) {
          data=options.data;
        } 
        model = KMN.cluster({
          data:data,
          k:options.k,
          distance:options.distance,
          epochs:options.epochs,
        })
        model.algorithm=options.algorithm
        model.data = data
        model.time=Io.time()-t0;
        return model;
        break;
                
      // Function Regression
      case ML.REG:
        /* typeof @options = {
          alpha : number is paramter change rate,
          lambda,
          iterations,
          dynamic?: boolean,
          cost? number,  
          error?:number,
          order : number,
          trace?: boolean.
        }
        */
        model={}
        options.alpha   = options.alpha||0.001;
        options.lambda  = options.lambda||0;
        options.iterations = options.iterations||1000;
        options.order = options.order||1;
        options.algorithm2 = options.algorithm2||'LinearRegression';
        model.regression = new REG[options.algorithm2]({
            alpha               : options.alpha,
            lambda              : options.lambda,
            iterations          : options.iterations,
            cost                : options.cost,
            error               : options.error,
            trace               : options.verbose||options.trace,
            dynamic             : options.dynamic,
          });
        model.algorithm=options.algorithm;
        model.options=options;
        return model;
        break;

      case ML.RF:
        var model={};
        // Single Binary RF (y={-1,1}) or Multi-RF (y:string is in labels)
        // typeof options = {data: {}[], target:string, features: string []} |
        //                  {data: [][], target?:string, features?: string []} |
        //                  {x: number [][], y: {-1,1} []} |
        //                  {data: {x,y}[] }
        //                  {data: {x,y}[], labels: string [] }
        if (!options.x || !options.y) throw 'ML.learn.RF: Invalid options';
        // data=preprocess(data,'xmy',{features:features,target:target})
        data={x:options.x,y:options.y}; // TODO 
        if (options.labels) {
          // multi-RF
          model.labels = options.labels;
          model.rfs = model.labels.map (function (label) { return RF() });
          model.rfs.forEach (function (rf,i) {
            var y = data.y.map(function (label) { return label==model.labels[i]?1:-1} );
            RF.code.train(rf,options.x,y,{
              numTrees:options.numTrees,
              maxDepth:options.maxDepth,
              numTries:options.numTries,
              type:options.weakType,
            });
          });
        } else {
          model = RF();
          features=options.x[0].map(function (col,i) { return String(i) }); 
          target='y';
        
          RF.code.train(model,
            options.x,
            options.y,
            {
              numTrees:options.numTrees,
              maxDepth:options.maxDepth,
              numTries:options.numTries,
              type:options.weakType,
            });    
        }
        model.algorithm=options.algorithm
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.RL:
        // Create learner instance
        model = {}
        if (!options.actions || !options.states) throw 'ML.learn.RL: Invalid options';
        options.environment=Io.checkOptions(options.environment,{});
        options.environment.getMaxNumActions=
          Io.checkOption(options.environment.getMaxNumActions,
                      function () { return options.actions.length })
        options.environment.getNumStates=
          Io.checkOption(options.environment.getNumStates,
                      function () { return options.states.length })
        var allowedActions=Io.checkOption(options.environment.allowedActions, function () { return options.actions });
        options.environment.allowedActions=
          // Ensure that allowedActions return number array!
          function (state) { 
            return allowedActions(state).map(function (a) {
              return options.actions.indexOf(a)
            })
          }  
        var nextState = options.environment.nextState;
        if (nextState) {
          options.environment.nextState = function (state,action) {
            return nextState(state,options.actions[action])
          }
        }
        switch (options.kind) {
          case ML.DQNAgent:                          
            model = RL.DQNAgent(
              options.environment,  
              {
                alpha:options.alpha,gamma:options.gamma,epsilon:options.epsilon,
                experience_add_every:options.experience_add_every,
                experience_size:options.experience_size,
                learning_steps_per_iteration:options.learning_steps_per_iteration,
                tderror_clamp:options.tderror_clamp,
                num_hidden_units:options.num_hidden_units,
                update:options.update,
               }
            )
            break;
          case ML.DPAgent:
            model = RL.DPAgent(
              options.environment,  
              {alpha:options.alpha,beta:options.beta,gamma:options.gamma,
               epsilon:options.epsilon,lambda:options.lambda}
            )
            break;
          case ML.TDAgent:
            model = RL.TDAgent(
              options.environment,  
              // specs
              {alpha:options.alpha,beta:options.beta,gamma:options.gamma,
               epsilon:options.epsilon,lambda:options.lambda,
               replacing_traces:options.replacing_traces,
               smooth_policy_update:options.smooth_policy_update,
               update:options.update,
               planN:options.planN}
            )
            break;
        }
        model.algorithm = options.algorithm;
        model.kind      = options.kind;
        if (options.actions)  model.actions   = options.actions;
        if (options.states)   model.states    = options.states;
        if (options.rewards)  model.rewards   = options.rewards;
        model.options   = options;
        return model;
        break;


      // typeof @options = { features : {name,categorical?:boolean,exclude?:boolean} [],
      //                     target   : {name,categorical?:boolean},
      //                     minPercentVarianceReduction?: number ?= 0.5,
      //                     minLeafNodeItems?: number ?= 10,
      //                     minSplitCandidateItems?: number ?= 30,
      //                     minAvgChildrenItems?: number ?= 2,
      //                     data?: {$attr:number|string} []
      case ML.RT:
        if (options.target && options.features) {
          if (!options.target.target) options.target.target=true;
          var columns = options.features.slice(),
              parameter = updateOptions({
                minPercentVarianceReduction:0.5,
                minLeafNodeItems:10,
                minSplitCandidateItems:30,
                minAvgChildrenItems:2,
              },options);
          model = RT();
          columns.push(options.target);
          model.defineConfig( columns, parameter );
          if (!options.featuresList) {
            options.featuresList=options.features.map(function (desc) { return desc.name });
          }
        } else throw 'ML.learn.RT: Invalid options';
        model.algorithm=options.algorithm;
        if (options.data) {
          // TODO
        }
        options.columns=columns;
        model.options=options;
        model.time=Io.time()-t0;
        return model;
        break;      

      case ML.SLP:
      case ML.MLP:
        // typeof options = {x?: number [][], 
        //                   y?: number number [][] | string [],
        //                   data?: number number [], features: number [], target: number [],
        //                   epochs?:number,
        //                   layers?:number [], 
        //                   hidden_layers?: number[],
        //                   verbose?:number,
        //                   labels?:string [], features?: string [], 
        //                   regression?,
        //                   normalize?, bipolar?, eps?:number | number [], verbose?}
        //
        // y and MLP(learn) require [[p1,p2,..],[p1,p2,..],..] with 0>=p>=1
        //                                                           p:label probability
        if (!options.x && !options.y && !options.data && options.layers){
          // create model only; layres must be defined!
          model = MLP({
            n_ins   : options.layers[0],
            n_outs  : options.layers[options.layers.length-1],
            hidden_layer_sizes  : options.layers.slice(1,options.layers.length-1),
            verbose : options.verbose||0,
          });
          model.algorithm = options.algorithm;
          return model;
        }
        if (options.data && options.features && options.target) {
          data=preprocess(options.data,'xmy',options);
          x=data.x;
          y=data.y;
        } else if (options.x && options.y) {
          x=options.x;
          y=options.y;
        } else if (options.data && options.data.x && options.data.y) {
          x=data.x;
          y=data.y;        
        } else throw 'ML.learn.MLP: invalid options';
        if (Comp.obj.isArray(options.x) && typeof options.x[0] == 'number') 
          x=wrap(options.x);   
        if (Comp.obj.isMatrix(options.y)) 
          y=options.y;
        else if (Comp.obj.isArray(options.y) && typeof options.y[0] == 'number') 
          y=wrap(options.y);        
        else if (Comp.obj.isArray(options.y) && options.labels) {
          y=options.y.map(function (l1) {
            return options.labels.map(function (l2) {
              return l1==l2?1:0;
            });
          });
        } else throw 'ML.learn.MLP: invalid options';
        if (options.normalize) {
          // normalize each variable independently!?
          var max=x[0].map(function (col) { return col}),
              min=x[0].map(function (col) { return col});
          x.forEach(function (row) { row.forEach(function (col,i) { 
            max[i]=Math.max(max[i],col);
            min[i]=Math.min(min[i],col) }) });
          xshift=options.bipolar?-1:0;
          xscale=max.map(function (x,i) { return (xshift?2:1)/((x-min[i])==0?1:x-min[i])});
          xoffset=min;
          x=x.map(function (row) { return row.map(function (col,i) { return xshift+(col-xoffset[i])*xscale[i] }) });
          if (options.regression) {
            // scale y, too, [0,1]
            max=y[0].map(function (col) { return col});
            min=y[0].map(function (col) { return col});
            y.forEach(function (row) { row.forEach(function (col,i) { 
              max[i]=Math.max(max[i],col);
              min[i]=Math.min(min[i],col) }) });
          
            yshift=options.bipolar?-1:0;
            yscale=max.map(function (x,i) { return (yshift?2:1)/((x-min[i])==0?1:x-min[i])});
            yoffset=min;
            y=y.map(function (row) { return row.map(function (col,i) { return yshift+(col-yoffset[i])*yscale[i] }) });
          }
        }
        model = MLP({
          input   : x,
          output  : y,
          n_ins   : x[0].length,
          n_outs  : y[0].length,
          hidden_layer_sizes:options.algorithm==ML.SLP?[]:(options.hidden_layers||[]),
          verbose:options.verbose||0,
        });
        model.algorithm=options.algorithm;
        model.labels=options.labels;
        model.features=options.features;
        model.xscale=options.normalize?{k:xscale,off:xoffset,shift:xshift}:undefined;
        model.yscale=options.normalize&&options.regression?{k:yscale,off:yoffset,shift:yshift}:undefined;
        model.nOutputs=y[0].length;
        
        MLP.code.train(model,{
          epochs : options.epochs||20000
        });
        model.time=Io.time()-t0;
        return model;
        break;


      // Simulated Annealing (final solution in model.state)
      case ML.SA:
        /* typeof @options = {
                coolingFactor: number =? 0.09,
		stabilizingFactor: number =? 1.005,
		freezingTemperature: number =? 0.001,
		initialTemperature: number =? 15,
		initialStabilizer: number =? 30,
                generateNewSolution : function () -> current:'a,
                generateNeighbor : function (current) -> current:'a,
                getCost : function (current:'a) -> cost:number
        }
        */
        var state = {
          final:null,
          current:null,
        }
        model = SA.SimulatedAnnealing({
            coolingFactor       : options.coolingFactor||0.09,
            stabilizingFactor   : options.stabilizingFactor||1.005,
            freezingTemperature : options.freezingTemperature||0.001,
            initialTemperature  : options.initialTemperature||15,
            initialStabilizer   : options.initialStabilizer||30,
          },
          /* */ function generateNewSolution () {
            state.current=state.final=options.generateNewSolution();
            return options.getCost(state.current)
          },
          /* */    function generateNeighbor () {
            state.current=options.generateNeighbor(state.final);
            return options.getCost(state.current)
          },
          /*  */     function acceptNeighbor () {
            state.final=state.current;
          }
        );
        model.current = null;
        model.state = state;
        model.algorithm=options.algorithm;
        return model;
        break;

      case ML.SOM:
        // typeof options = {x:nzumber,y:number,fields:{name:string,range:[]}[]..}
        model = {
         network : options.network?SOM.load(options.network):new SOM(options.x,options.y,options)
        }
        model.algorithm=options.algorithm;
        model.options=options;
        model.time=Io.time()-t0;
        return model;
        break;
        
      case ML.SVM:
        // typeof options = {x: number [][], 
        //                   y: ({-1,1}|string) [],
        //                   labels?:string|number [],
        //                   threshold?:number|false,
        //                   C?:numer,tol?:number,max_passes?:number,alpha_tol?:number,kernel?:{}}
        
        // If classes then multi-SVM (one for each class to be separated)!
        if (!options.labels) {
          model = SVM({
            x:options.x,
            y:options.y,
            threshold:options.threshold,
          });
          model.algorithm=options.algorithm
          SVM.code.train(model,{
            C:options.C||1.0,
            tol:options.tol||1e-4,
            max_passes:options.max_passes||20,
            alpha_tol:options.alpha_tol||1e-5,
            kernel:options.kernel
          });
        } else {
          model={};
          model.algorithm=options.algorithm;
          model._labels=options.labels;
          model.svms=options.labels.map(function (cl) {
            return SVM({
              x:options.x,
              y:options.y.map(function (y) { return y==cl?1:-1 }),
              threshold:options.threshold,
            });
          });
          
          model.svms.forEach(function (svm) {
            SVM.code.train(svm,{
              C:options.C||1.0,
              tol:options.tol||1e-4,
              max_passes:options.max_passes||20,
              alpha_tol:options.alpha_tol||1e-5,
              kernel:options.kernel
            });
          });
          // Create one SVM for each class
          // Transform y vector          
        }
        model.time=Io.time()-t0;
        return model;
        break;

      case ML.TXT:
        // typeof options = {data: string []}
        model = TXT.create(options.data,{
        });
        model.algorithm=options.algorithm
        return model;
        break;
    }
  },

  // add gaussian (!!) absolute or relative noise (0,1] to numerical data to create synthetic data
  // v + [-noise,+noise] | v + [-noise*v,noise*v]
  noise: function (data,noise,uniform,relative) {
    var rnd = uniform?
      function () {
        return Math.random()*2-1  
      }:function () {
        return STAT.utils.gaussian(-1,1)
      };
    function noisy(v,noise) {
      if (!relative) return v+rnd()*noise;
      else return v+rnd()*noise*v;
    }
    if (Comp.obj.isMatrix(data)) {
      return data.map(function (row) {
        return row.map(function (v,i) {
          if (typeof noise == 'number')
            return noisy(v,noise);
          else return noise[i]?noisy(v,noise[i]):v;
        })
      })
    } else if (Comp.obj.isArray(data) && Comp.obj.isObject(data[0])) {
      return data.map(function (row) {
        var o={};
        if (row.input && row.output) 
          return { input:row.input.map(function (col,index) { 
                      if (typeof noise.input == 'number') return noisy(col,noise.input);
                      else if (noise.input!=undefined) return noise.input[index]?noisy(col,noise.input[index]):col;
                      else return col;
                   }),
                   output:row.output.map(function (col,index) { 
                      if (typeof noise.output == 'number') return noisy(col,noise.output);
                      else if (noise.output!=undefined) return noise.output[index]?noisy(col,noise.output[index]):col;          
                      else return col;
                   })
                 };
        for (var p in row) {
          if (typeof noise == 'number')
            o[p] = noisy(row[p],noise);
          else o[p] = noise[p]?noisy(row[p],noise[p]):row[p];
        }
        return o;
      })      
    } else if (Comp.obj.isArray(data)) {
        return data.map(function (v,i) {
          if (typeof noise == 'number')
            return noisy(v,noise);
          else return noise[i]?noisy(v,noise[i]):v;
        })    
    } else if (typeof data == 'number') {
      return noisy(data,noise);
    }
  },

  /** Classification (prediction): Apply sample data to learned model.
   *  Returns prediction result.
   *
   */ 
  predict: function (model,samples,options) {
    var x,y,solutions,result,data;
    switch (model.algorithm) {
    
      case ML.ANN:
        if (Comp.obj.isMatrix(samples)) 
          return samples.map(function (sample) { 
            x=sample;          
            if (model.options.xscale) 
              x=x.map(function (row) { return scale(row,model.options.xscale) });
            y=model.network.activate(x);
            if (model.options.yscale)
              y=unscale(y,model.options.yscale);
            if (model.options.labels) // categorical classifier
            return y.map(function (v,i) { return { value:model.options.labels[i], prob:v } });
            return y;
          });
        else {
          x=samples;          
          if (model.options.xscale) 
            x=x.map(function (row) { return scale(row,model.options.xscale) });
          y=model.network.activate(x);
          if (model.options.labels) // categorical classifier
            return y.map(function (v,i) { return { value:model.options.labels[i], prob:v } });
          else 
            return y
        }
      case ML.CNN:
        if (Comp.obj.isMatrix(samples))
          return samples.map(function (sample) {
            return CNN.predict(model,sample);
          });
        else
          return CNN.predict(model,samples);
        break;

      case ML.C45:
        // Sample row format: [x1,x2,..,xn]
        if (Comp.obj.isMatrix(samples)) {
          return samples.map(function (sample) {
            return C45.classify(model,sample);
          });
        } else if (Comp.obj.isArray(samples) && !Comp.obj.isObj(samples[0])) {
          return C45.classify(model,samples);
        } else if (Comp.obj.isArray(samples) &&  Comp.obj.isObj(samples[0])) {
          return samples.map(function (sample) {
            return C45.classify(model,sample); 
          });
        } else if (Comp.obj.isObj(samples)) {
          return C45.classify(model,samples);
        }
        break;

      case ML.DT:
      case ML.ICE:
        if (Comp.obj.isMatrix(samples) ||
            Comp.obj.isArray(samples) && Comp.obj.isObj(samples[0])) 
          return samples.map(function (sample) { 
            return ICE.predict(model,sample) 
          });
        else 
          return ICE.predict(model,samples);

      case ML.DTI:
        if (Comp.obj.isMatrix(samples)) 
          return samples.map(function (sample) { 
            return DTI.predict(model,sample) 
          });
        else
          return DTI.predict(model,samples);

      case ML.ID3:
        if (Comp.obj.isArray(samples)) 
          return samples.map(function (sample) { 
            return ID3.predict(model,sample) 
          });
        else
          return ID3.predict(model,samples);

      case ML.KNN:
        if (Comp.obj.isMatrix(samples))
          return KNN.predict(model,samples);        
        else if (Comp.obj.isArray(samples) && Comp.obj.isObj(samples[0]))
          return KNN.predict(model,samples.map(function (sample) { 
            return obj2Array(sample,model.features)}));
        else if (Comp.obj.isObj(samples))
          return KNN.predict(model,obj2Array(samples,model.features));
        else
          return KNN.predict(model,samples);
        break;

      case ML.KNN2:
        if (Comp.obj.isMatrix(samples))
          return samples.map(function (sample) {
            return KNN.predict2(model,sample);
          });
        else if (Comp.obj.isArray(samples) && Comp.obj.isObj(samples[0]))
          return samples.map(function (sample) {
             return KNN.predict2(model,obj2Array(sample,model.features))
            })
        else if (Comp.obj.isObj(samples))
          return KNN.predict2(model,obj2Array(samples,model.features));
        else
          return KNN.predict2(model,samples);
        break;

      case ML.KMN:
        return model.clusters
        break;

      // Function Regression
      case ML.REG:
        // requires [x,x*x,x*x*x,..,y] [] data
        if (typeof samples == 'number') samples=[samples];
        if (model.options.order) {
          data=samples.map(function (xx) {
            if (typeof xx=='number') xx=[xx];
            var x=xx[0];
            for (var i=2;i<=model.options.order;i++)
              xx.push(Math.pow(x,i));
            return xx
          })
        }
          else data=samples;

        return model.regression.transform(data);
        break;

      case ML.RF:
        if (model.labels) {
          if (Comp.obj.isMatrix(samples)) {
            return samples.map(function (sample) {
              return model.rfs.map(function (rf) {
                return RF.code.predictOne(rf,sample);
              }).map(function (v,i) {
                return { value:model.labels[i], prob:v }
              })
            });
          } else if (Comp.obj.isArray(samples) && typeof samples[0] == 'number') {
            return model.rfs.map(function (rf) {
              return RF.code.predictOne(rf,samples);
            }).map(function (v,i) {
                return { value:model.labels[i], prob:v }
            })
          } // TODO
        } else {
          // Sample row format: [x1,x2,..,xn]
          if (Comp.obj.isMatrix(samples)) {
            return samples.map(function (sample) {
              return RF.code.predictOne(model,sample);
            });
          } else if (Comp.obj.isArray(samples) && typeof samples[0] == 'number') {
            return RF.predictOne(model,samples);
          } // TODO
        }
        // preprocess(samples,'m')
        break;
                
      case ML.RT:
        if (Comp.obj.isArray(samples)) {
          return samples.map(function (sample) { 
            if (!Comp.obj.isArray(sample))
              return model.predict(sample);
            else {
              // map to object
              data = array2Object(sample,model.options.featuresList);
              return model.predict(data);
            }
          });
        } else {
          if (!Comp.obj.isArray(samples))
            return model.predict(samples);
          else {
            // map to object
            data = array2Object(samples,model.options.featuresList);
            return model.predict(data);
          }
        }
        break;

      case ML.SOM:
          return model.network.predict(samples,options);
        break;
        
      case ML.SVM:
        if (!model._labels) {
          // Single SVM 
          if (Comp.obj.isMatrix(samples))
            return samples.map(function (sample) {
              return SVM.code.predict(model,sample);
            });
          else
            return SVM.code.predict(model,samples);
        } else {
          // Multi SVM
          if (Comp.obj.isMatrix(samples))
            return samples.map(function (sample) {
              solutions=model.svms.map(function (svm,index) { 
                if (svm.threshold==false)
                  return SVM.code.predict(svm,sample)
                else
                  return SVM.code.predict(svm,sample); 
              });
              return solutions.map(function (v,i) { return { value:model._labels[i], prob:v } });
            });
          else {
            solutions=model.svms.map(function (svm,index) { 
                if (svm.threshold==false)
                  return SVM.code.predict(svm,samples)
                else
                  return SVM.code.predict(svm,samples)==1; 
            })
            return solutions.map(function (v,i) { return { value:model._labels[i], prob:v } });
          }
        }
        break;
        
      case ML.SLP:
      case ML.MLP:
        // returns always [y1,y2,..][] w/o label coding and even if |y|=1
        if (Comp.obj.isMatrix(samples)) {
          x=samples;          
          if (model.xscale) 
            x=x.map(function (row) { return scale(row,model.xscale) });
          result = model.labels?MLP.code.predict(model,x).map(function (r) {
            var o={};
            r.forEach(function (v,i) { o[model.labels[i]]=v });
            return o;
          }):/*relax*/(MLP.code.predict(model,x));
        } else if (Comp.obj.isArray(samples)) {
          x=samples;
          if (model.xscale) 
            x=scale(x,model.xscale);
          result = model.labels?MLP.code.predict(model,[x]).map(function (r) {
            var o={};
            r.forEach(function (v,i) { o[model.labels[i]]=v });
            return o;
          })[0]:/*relax*/(MLP.code.predict(model,[x])[0]);
        } else if (Comp.obj.isObj(samples) && model.features) {
          x=model.features.map(function (f) { return samples[f] });
          if (model.xscale) 
            x=scale(x,model.xscale);
          result = model.labels?MLP.code.predict(model,[x]).map(function (r) {
            var o={};
            r.forEach(function (v,i) { o[model.labels[i]]=v });
            return o;
          })[0]:/*relax*/(MLP.code.predict(model,[x])[0]); 
        }
        if (Comp.obj.isArray(result)) {
          return model.yscale?result.map(function (y) { return unscale(y,model.yscale) }):result;
        } else {
          // TODO??
        }
        break;
        
       case ML.TXT:
        // typeof options = {data: string []}
        if (Comp.obj.isArray(samples))
          return samples.map(function (sample) { return TXT.classify(model,sample) });
        else
          return TXT.classify(model,samples);
        break;

   }
  },

  preprocess:preprocess,

  print: function (model,indent,compact) {
    switch (model.algorithm) {
      case ML.DTI:
        return DTI.print(model,indent,compact);
      case ML.DT:
      case ML.ICE:
        return ICE.print(model,indent);
      case ML.C45:
        return C45.print(model,indent);
      case ML.ID3:
        return ID3.print(model,indent);
    }
  },
  
  // Only text module
  similarity : TXT.similarity,
  
  stats : STAT,
  
  // Check model consistency with training or test data (input: x/y data table!)
  test: function (model,samples,options) {
    var x,y,data,res,p=0.0,error;
    switch (model.algorithm) {
    
      case ML.ANN:
        if (Comp.obj.isArray(samples)) {
          data=preprocess(samples,'xy',model.options); // data.x/data.y
          result=ml.predict(model,data.x);
          if (!options)
            return result.map(function (row,i) {
              return {y0:data.y[i],y:row};
            }); 
          else if (options.error) {
            
            error=result.map(function (row,i) {
              return options.error(data.y[i],row);
            }); 
            if (options.finally) return options.finally(error);
            else return error;
          }
        } else {
          data={x:samples.input,y:samples.output };
        }
        break;
        
      case ML.C45:
        // Sample row format: [x1,x2,..,y]
        if (Comp.obj.isMatrix(samples)) {
          samples.forEach(function (sample) {
            x=sample.slice(0,sample.length-1);
            y=sample[sample.length-1];
            res= C45.classify(model,x);
            if (res==y) p += 1;
          });
          return p/samples.length;
        } else if (Comp.obj.isArray(samples)  && !Comp.obj.isObject(samples[0])) {
          x=samples.slice(0,samples.length-1);
          y=samples[samples.length-1];
          res = C45.classify(model,x);
          return res==y?1.0:0.0
        } else if (Comp.obj.isObj(samples) && model.features) {
        }
        break;

      case ML.ICE:
        data=preprocess(samples,'xy',{features:model.features,target:model.target});
        data.x.forEach(function (sample,index) {
          res= ML.classify(model,sample);
          if (res==data.y[index]) p += 1;
        });
        return p/data.x.length;
        break;
        
      case ML.TXT:
        var model = model.string?{ data : [model.string] }:model;
        if (Comp.obj.isArray(samples))
          return samples.map(function (sample) { 
            return TXT.classify(model,sample).match
          });
        else
          return TXT.classify(model,samples).match;
        break;

        
    }
  },
  

  /** Update an already learned or train a new model
   *
   */
  train: function (model,options,more) {
    var data,t0;
    // if (!options) return ml.learn(options); // backward comp.
    switch (model.algorithm||options.algorithm) {
    
      case ML.ANN:
        Object.assign(model.options,more||{})
        data = preprocess(options,'io',model.options);
        if (!data) throw "ML.train.ANN: invalid data (not convertable to io format)";
        t0=Io.time();
        result=model.network.train(data,model.options);
        model.time=Io.time()-t0;
        return result;
        break;
        
      case ML.CNN:
        // typeof @options = { x,y,.. }
        return CNN.train(model,options);
        break;

      case ML.DTI:
        // typeof @options = {data: number [][], target:string, features: string [], eps?:number, maxdepth?:number} |
        //                   {x: number [][], y:[], eps?:number, maxdepth?:number}
        t0=Io.time();
        if (options.eps==_) options.eps=0;
        if (options.maxdepth==_) options.maxdepth=20;
        if (options.data && options.target && options.features)
          model = DTI.update(model,options);
        else if (options.x && options.y) {
          if (options.x.length != options.y.length) throw 'ML.update.DTI: X and Y vector have different length';
          data=options.x.slice();
          data=data.map(function (row,i) {row.push(options.y[i]); return row});
          features=Comp.array.init(data[0].length-1,function (i) { return String(i)});
          target=String(data[0].length-1);
          // console.log(data,features,target)
          model = DTI.update(model,{
            data:data,
            features:features,
            target:target,
            eps:options.eps,
            maxdepth:options.maxdepth
          });
        } else throw 'ML.update.DTI: Invalid options';
          
        model.time=Io.time()-t0;
        model.algorithm=options.algorithm;
        return model;

      // Function Regression
      case ML.REG:
        // requires [x,x*x,x*x*x,..,y] [] data
        if (model.options.order) {
          data=options.map(function (xy) {
            var x=xy[0],y=xy.pop();
            for (var i=2;i<=model.options.order;i++)
              xy.push(Math.pow(x,i));
            xy.push(y);
            return xy
          })
        }
          else data=options;
        return model.regression.fit(data);
        break;
            
      case ML.RL:
        switch (model.kind) {
          case ML.DQNAgent:
            return RL.DQNAgent.code.learn(model,options);
            break;
          case ML.DPAgent:  
            return RL.DPAgent.code.learn(model,options);
            break;
          case ML.TDAgent:
            return RL.TDAgent.code.learn(model,options);
            break;
        }
        break;

      case ML.RT:
        data=options;
        // data must be [][] with exact column order features@target!
        // if {}[], convert
        if (data[0] && !Comp.obj.isArray(data[0])) {
          data = data = ml.preprocess(data,'m',{
            features  : model.options.columns.pluck('name') 
          }).data;
        } 
        // console.log(data)
        for(var i in data) model.ingest(data[i]);
        
        return model.learn();
        break;
        
      case ML.SLP:
      case ML.MLP:
        // typoeof options = { x:[][],y:[][],data: number [][],features: number [], target:number [], epochs:number }
        // TODO scale/normalize/convert
        t0=Io.time();
        if (options.x && options.y) {
          MLP.code.train(model,{
            x      : options.x,
            y      : options.y,
            epochs : options.epochs||20000
          });
        } else if (options.data && options.features && options.target) {
          data = preprocess(options.data,'xmy',options);
          MLP.code.train(model,{
            x      : data.x,
            y      : data.y,
            epochs : options.epochs||20000
          });
        } else if (options.data && options.data.x && options.data.y) {
          data = preprocess(options.data,'xmy',options);
          MLP.code.train(model,{
            x      : data.x,
            y      : data.y,
            epochs : options.epochs||20000
          });
        } else throw "ML.MLP.train: Invalid options";
        model.time=Io.time()-t0;
        return { time:model.time, error:model.error, crossEntropy:model.crossEntropy };
        break;
        
        
      case ML.SA:
        var more=true,n=1E6,i=0;
        t0=Io.time();
        if (typeof options == 'number') n=options;
        while (more && i<n) {
          more = model.Do();
          if (!more) break;
          i++;
        }
        model.time=Io.time()-t0;
        return {
          temperature : model.GetCurrentTemperature(),
          energy      : model.GetCurrentEnergy(),   // last cost
          final       : model.state.final,
          more        : more,
          steps       : i,
          time        : model.time,
        }
        break;
        
      case ML.SOM:
        data=options;
        model.network.train(data,more);
        return model.network.getQuantizationError();
        break;
    }
  },
  // Returns an unified JSON-like representation of the core model, e.g., for graph drawing
  // Types: Node or graoh function structure, parametrised function, tables
  toGraph: function (model,options) {
    var j,nodes,connections,map;
    options=options||{};
    switch (model.algorithm||options.algorithm) {
      case ML.ANN:
        // nodes, connections, input, output
        var ir = model.network.toJSON();
        if (options.native) return ir;
        nodes = ir.nodes.map(function (node) {
          return {
            type    : node.type,
            index   : node.index,
            bias    : node.bias,
            eval    : ['SUM',node.squash],
            attributes : {
              layerid : node.layerid,
              groupid : node.groupid,
              mask    : node.mask,
            }
          }
        })
        //
        j = {
          type      : 'graph',
          attributes  : ['directed','ANN'],
          nodes       : nodes,
          connections : ir.connections, // TODO: unification
          parameter : {
            layers    : model.options.layers,
            algorithm : model.algorithm,
            functions : {
              SUM: 'function (node,connections) { return node.bias+connections.sum(function (c) { return c.from.y*c.weight })',
              LOGISTIC:'function (x) { return 1 / (1 + Math.exp(-x)) }',
            }
          }
        };   
        break;
      case ML.ID3:
        nodes=[];
        results=[];
        resultsMap=[];
        connections=[];
        map=[];
        function iter1(node) {
          if (node.type=='feature') {
            var index=nodes.length;
            var _node = {
              type  : 'feature',
              name  : node.name, 
              index : index
            }
            map[index]=node
            nodes.push(_node);
            node.vals.forEach(function (e) {
              iter1(e.child)
            })
          }
        }
        function iter2(node) {
          if (node.type=='feature') {
            node.vals.forEach(function (e) {
              iter2(e.child)
            })
          } else if (node.type=='result') {
            var index=nodes.length;
            if (results.indexOf(node.name)!=-1) return;
            var _node = {
              type  : 'result',
              name  : node.name,
              value : node.value, 
              index : index
            }
            map[index]=node;
            results.push(node.name);
            resultsMap.push(_node);
            nodes.push(_node);              
          }
        }
        function iter3(node) {
          if (node.type=='feature') {
            var from = map.indexOf(node);
            node.vals.forEach(function (e) {
              if (e.child.type=='feature') connections.push({
                from  : from,
                to    : map.indexOf(e.child),
                value : e.value
              }); else if (e.child.type=='result') connections.push({
                from  : from,
                to    : resultsMap[results.indexOf(e.child.name)].index,
                value : e.value
              })
            })
            node.vals.forEach(function (e) {
              iter3(e.child)
            })           
          } 
        }
        iter1(model)
        iter2(model)
        iter3(model)
        j = {
          type        : 'graph',
          attributes  : ['directed','DT'],
          nodes       : nodes,
          connections : connections,
        }
        break;
      case ML.MLP:
        map=[];
        nodes=[];
        connections=[];
        var input = model.sigmoidLayers[0].W;
        map[0]=[];
        input = input.map(function (v,i) {
          var index=nodes.length;
          var node = {
            type : 'input',
            eval : ['ID'],
            index : index,
            attributes : {
              layreid : 0,
            }
          };
          nodes.push(node);
          map[0].push(node);
          return node;
        });
        model.sigmoidLayers.forEach(function (layer,layerIndex) {
          map[layerIndex+1]=[];
          layer.b.forEach(function (b,bi) {
            var index=nodes.length;
            var node = {
              type : layerIndex==model.sigmoidLayers.length-1?'output':'hidden',
              bias : b,
              eval : ['SUM','SIGMOID'],
              index : index,
              attributes : {
                layreid : layerIndex+1
              }
            };
            nodes.push(node);
            map[layerIndex+1].push(node);
          });        
        });
        model.sigmoidLayers.forEach(function (layer,layerIndex) {  
          input = layer.b.map(function (b,bi) {
            layer.W.forEach(function (w,wi) {
              connections.push({
                from : input[wi].index,
                to   : map[layerIndex+1][bi].index,
                weight : w[bi]
              });
            })
            return map[layerIndex+1][bi]
          });        
        });
        j = {
          type        : 'graph',
          attributes  : ['directed','ANN'],
          nodes       : nodes,
          connections : connections,
          functions : {
            ID:'function (x) { return x }',
            SUM: 'function (node,connections) { return node.bias+connections.sum(function (c) { return c.from.y*c.weight })',
            SIGMOID:'function (x) { return 1 / (1 + Math.exp(-x)) }',
          }
        }
        break;
      case ML.RT:
        j=model.exportJSON();
        break;
    }  
    return j;
  },
  // Create a model JSON data object that can be saved and restored! Not supported by all algorithms!
  // !!! NEW unified JSON format: { algorith, network, options } // breaks old code!
  toJSON : function (model,options) {
    options=options||{};
    switch (model.algorithm||options.algorithm) {
      case ML.ANN:
        // nodes, connections, input, output
        return {
          algorithm : ML.ANN, 
          network   : model.network.toJSON(),
          options   : model.options,
        }
      case ML.CNN:
        return {
          algorithm : ML.CNN, 
          network   : model.network.toJSON(),
          options   : getOptions(model.options,['width','height','depth','layers','targets','normalize','trainer']),
        };
        break;
      case ML.SOM:
        return {
          algorithm : ML.SOM, 
          network   : model.network.export(),
          // TODO incomplete
          options   : getOptions(model.options,['x','y','fields','iterations','learningRate']),
        };
        break;
      case ML.MLP:
        return model; 
      default:
        // TODO
        return 'Not supported';
    }    
  },
  // restore a model from JSON
  fromJSON : function (model) {
    if (typeof model=='string') model=JSON.parse(model);
    switch (model.algorithm) {
      case ML.ANN:
        return ml.learner({
          algorithm : ML.ANN,
          network   : model.network
        })
      case ML.CNN:
        return ml.learner(Object.assign(model.options,{
          algorithm : ML.CNN,
          network   : model.network
        }))
        break;
      case ML.SOM:
        return ml.learner(Object.assign(model.options,{
          algorithm : ML.SOM,
          network   : model.network
        }))
        break;
      default:
        // TODO
        throw 'ML.fromJSON: Algorithm not supproted';
    }
  },
  
  utils : {
    scale:scale,
    toScale:toScale,
  },
  
  ML:ML,
};
  
ICE.ml=ml;
CNN.ml=ml;
ml.classify=ml.predict;
ml.update=ml.train;
ml.best=ml.stats.utils.best;
ml.learn=ml.learner;
// loaded on demand
ml.xgboost = null;

module.exports = {
  action:ml.action,
  best:STAT.utils.best,
  classify:ml.classify,
  column:ml.column,
  convert : function (data,format,options) {
    // simplified {}[] <-> [][] data table conversion
    options=options||{};
    if (Comp.obj.isObject(format)) options=format,format=undefined;
    if (!format) {
      if (Comp.obj.isArray(data) && !Comp.obj.isArray(data[0]) && Comp.obj.isObject(data[0])) format='m';
      if (Comp.obj.isArray(data) && Comp.obj.isArray(data[0])) format='r';
    }
    if (format.toLowerCase()=='record') format='r';
    if (format.toLowerCase()=='array') format='m';
    if (format.toLowerCase()=='matrix') format='m';
    var result = preprocess(data,format,options);
    if (result && result.data) return result.data;
    else return result;
  },
  compact:ml.compact,
  depth:ml.depth,
  entropy:STAT.entropy,
  entropyN:STAT.entropyN,
  entropyDep:STAT.entropyDep,
  evaluate:ml.evaluate,
  fromJSON:ml.fromJSON,
  help:ml.help,
  info:ml.info,
  learn:ml.learn,
  learner:ml.learner,
  noise:ml.noise,
  options:options,
  pca:PCA,
  predict:ml.predict,
  preprocess:preprocess,
  print:ml.print,
  scale:scale,
  scale0:scale0,
  split:split,
  statistics:STAT,
  test:ml.test,
  toScale:toScale,
  train:ml.train,
  toJSON:ml.toJSON,
  unique:ml.stats.unique,
  unscale:unscale,
  update:ml.update,
  ANN:ANN,
  CNN:CNN,
  // set logging function
  log:function (f) {
    MLP.code.log=f;
  },
  ML:ML,
  DBCLUST:DBCLUST,
  DR:DR,
  math:MATH,
  version : options.version
}

if (typeof window != 'undefined') console.log('ML '+options.version+' loaded.');

};
BundleModuleCode['com/compat']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     30-3-15 by sbosse.
 **    $VERSION:     1.23.6X
 **
 **    $INFO:
 **
 **  JavaScript-OCaML Compatibility Module
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Path = Require('com/path');
var Sprintf = Require('com/sprintf');

/*******************************
** Some global special "values"
********************************/

/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var any = undefined;
/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var _ = undefined;

/**
 *
 * @type {null}
 */
var none = null;
/**
 *
 * @type {null}
 */
var empty = null;

var NL = '\n';

global.int = function (v) {return v|0};
global.div = function (a,b) {return a/b|0};

if (!Object.prototype.forEach) {
	Object.defineProperties(Object.prototype, {
		'forEach': {
			value: function (callback) {
				if (this == null) {
					throw new TypeError('Not an object');
				}
				var obj = this;
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						callback.call(obj, obj[key], key, obj);
					}
				}
			},
			writable: true
		}
	});
}
/** Just transfer parent prototypes to child
 *
 */
function inherit(child,parent) {
  for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}

/** Portable class inheritance and instanceOf polyfill
 *
 */
// SomeObject.prototype.__proto__=SomeObject2.prototype;
// Child class inherits prototype from parent using __proto__
function inheritPrototype(child,parent) {
  var __proto__=child.__proto__;
  child.prototype.__proto__=parent.prototype;
  if (!__proto__) for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}
// Polyfill fir o instanceof c with inheritance check (checking __proto__)
function instanceOf(obj,cla) {
  var p=obj.__proto__;
  if (obj instanceof cla) return true;
  while (p) {
    if (p === cla.prototype) return true;
    p=p.__proto__
  }
  return false;
}
// Polyfill for __defineGetter__ / __defineSetter__
function defineGetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    get:fun
  });
}
function defineSetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    set:fun
  });

}

var inherit = inherit;
var inheritPrototype = inheritPrototype;
var instanceOf = instanceOf;
var defineGetter = defineGetter;
var defineSetter = defineSetter;

/**
 *
 */
var assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
};
global.assert=assert;

function forof(obj,f) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = obj[Symbol.iterator](), _step; 
         !(_iteratorNormalCompletion = (_step = _iterator.next()).done); 
         _iteratorNormalCompletion = true) {
      element = _step.value;

      f(element);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}


global.forof=forof;

/** OBJ
 *
 */
var obj = {
    /** Compact an object:
     * [{a:b},[c:d},..] -> {a:b,c:d,..}
     * {a:[b]} -> {a:b}
     *
     */
    compact: function (o) {
      var a;
      if (obj.isArray(o)) {
        if (o.length==1 && obj.isObject(o[0])) return obj.compact(o[0]);
        else return o;
      } else if (obj.isObject(o)) for (a in o) {
          var elem=o[a];
          o[a]=obj.compact(elem);
      }
      return o;
    },
    copy: function (o) {
      if (o === null || typeof o !== 'object') {
        return o;
      }
 
      var temp = (o instanceof Array) ? [] : {};
      for (var key in o) {
        temp[key] = obj.copy(o[key]);
      }
 
      return temp;    
    },
    equal: function (o1,o2) {
      if (!o1 || !o2) return false;
      for(var i in o1) if (o1[i]!=o2[i]) return false;
      for(var i in o2) if (o1[i]!=o2[i]) return false;
      return true;
    },
    extend: function (o1,o2) {
      for(var i in o2) o1[i]=o2[i];
      return o1;
    },
    find: function(obj,fun) {
      var p;
      for(p in obj) {
          if (fun(obj[p],p)) return obj[p];
      }
    },

    hasProperty: function (o,p) {
      return o[p]!=undefined || (p in o);
    },
    head:function(o) {
      for (var p in o) return p;
      return undefined;
    },
    // transfer src attributes to dst recusively (no object overwrite)
    inherit: function (dst,src) {
      for(var i in src) {
        if (typeof dst[i] == 'object' && typeof src[i] == 'object')
          inherit(dst[i],src[i]);
        else if (typeof dst[i] == 'undefined')
          dst[i]=src[i];
      }
      return dst;
    },
    isArray:function (o) {
      if (o==_ || o ==null) return false;
      else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
    },
    isMatrix:function (o) {
      if (o==_ || o ==null) return false;
      else return obj.isArray(o) &&
                  obj.isArray(o[0]);
    },
    isEmpty: function (o) {
      for(var prop in o) {
         if (o[prop]!=undefined) return false;
      }
      return true;  
    },
    isFunction: function (o) {
        return typeof o == "function";
    },
    isObj:function (o) {
        return typeof o == "object";
    },
    isObject:function (o) {
        return typeof o == "object";
    },
    isRegex: function (o) {
        return o instanceof RegExp;
    },
    isString: function (o) {
        return typeof o == "string" || (typeof o == "object" && o.constructor === String);
    },
    isNumber: function (o) {
        return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
    },


    iter: function(obj,fun) {
      var p;
      for(p in obj) {
        fun(obj[p],p)
      }
    }
};

/** ARRAY
 *
 */
var array = {
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean conjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    and: function(array,fun) {
        var res=true;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res&&fun(element,i)
        }
        return res;
    },
    /** Append one element at the end of the array.
     *
     * @param {* []} array
     * @param {*} element
     * @returns {* []}
     */
    append : function(array,element) {
        array.push(element);
        return array;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    call: function(array,args) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            element()
        }
    },
    /** Check for an elenment in the array by using a check function.
     *
     * @param array
     * @param fun
     * @returns {boolean}
     */
    check: function(array,fun) {
        var i,exist;
        exist=false;
        loop: for(i in array) {
            var element=array[i];
            if (fun(element,i)) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Append array2 at the end of array inplace. The extended array is returned.
     *  Source array (1) will be modified.
     *
     * @param {*[]} array
     * @param {*[]} array2
     * @returns {*[]}
     */
    concat : function(array,array2) {
        for(var i in array2) {
            array.push(array2[i]);
        }
        return array;
    },
    /** Create the conjunction set of two arrays
     *
     */
    conjunction :function (set1,set2,fun) {
      return array.union(set1,set2,fun);
    },
    /**
     *
     * @param {*[]} array
     * @param {number|string|*|*[]} elements
     * @param {function} [fun] Optional equality test function
     * @returns {boolean}
     */
    contains : function(array,elements,fun) {
        var i = array.length;
        if (!fun) fun=function(o1,o2) {return o1===o2};
        if (obj.isArray(elements)) {
          while (i--) {
            var j = elements.length;
            while (j--) {
              if (fun(array[i],elements[j])) {
                  return true;
              }          
            }
          }
        }
        else while (i--) {
            if (fun(array[i],elements)) {
                return true;
            }
        }
        return false;
    },
    /** Return a fresh copy of the source array or copy src array to dst.
     *
     * @param array
     * @returns {Array.<T>|string|Blob|ArrayBuffer}
     */
    copy: function(src,dst) {
        var i;
        if (dst) {
          for(i in src) dst[i]=src[i];  
        } else return src.slice();
    },
    /** Create a new array with initial element values.
     *
     * @param length
     * @param init
     * @returns {Array}
     */
    create : function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    },
    /** Create a matrix (array of array) with initial element values.
     *
     */
    create_matrix : function(rows,cols,init) {
        var m = [];
        var r = [];
        var i,j;
        for (i = 0; i < rows; i++) {
            r=[];
            for(j=0;j<cols;j++) r.push(init);
            m.push(r);
        }
        return m;
    },
    /** Create the (inclusive) disjunction set of two arrays.
     *  Source arrays will not be modified.
     *
     */
    disjunction :function (set1,set2,fun) {
      return array.merge(set1,set2);
    },
    /**
     *
     * @param array
     * @returns {boolean}
     */
    empty : function (array) {
      return (array==undefined ||
              array.length==0)
    },
    
    /** Test for equality
    */
    equal: function (a1,a2) {
      if (a1.length != a2.length) return false;
      for(var i in a1) if (a1[i]!=a2[i]) return false;
      return true;
    },
    
    /** Create the (exclusive) disjunction set of two arrays. 
     *  Source arrays will not be modified.
     *
     */
    exclusive :function (set1,set2,fun) {
        var i,j,found,res = [];
        for (i in set1) {
          found=false;
          loop1: for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) {found=true; break loop1;}
            else if (fun == undefined && set1[i]==set2[j]) {found=true; break loop1;};
          }
          if (!found) res.push(set1[i]);
        }
        for (i in set2) {
          found=false;
          loop2: for (j in set1) {
            if (fun != undefined && fun(set2[i],set1[j])) {found=true; break loop2;}
            else if (fun == undefined && set2[i]==set1[j]) {found=true; break loop2;};
          }
          if (!found) res.push(set2[i]);
        }
        return res;
    },
    /** Find an element in an array and return it (or none);
     *
     * @param array
     * @param fun
     * @returns {undefined|*}
     */
    find: function(array,fun) {
        var i;
        for(i in array) {
          if (fun(array[i],i)) return array[i];
        }
        return none;
    },
    /** Search and map an element of an array using a test&map function.
     *
     * @param array
     * @param {function(*,number):*} fun
     * @returns {undefined|*}
     */
    findmap: function(array,fun) {
        var i,found;
        for(i in array) {
          found=fun(array[i],i);
          if (found) return found;
        }
        return none;
    },
    /** Filter out elements using a test function.
     *
     * @param {* []} array
     * @param {function(*,number):boolean} fun
     * @returns {* []}
     */
    filter: function(array,fun) {
      if (array.filter) return array.filter(fun);
      else {
        var res=[],
            len=array.length,
            element,i;
        for(i=0;i<len;i++) {
            element=array[i];
            if (fun(element,i)) res.push(element);
        }
        return res;
      }
    },
    /** Filter out and map elements using a test&map function.
     *
     * @param {* []} array
     * @param {function(*,number):*|undefined} fun
     * @returns {* []}
     */
    filtermap: function(array,fun) {
        var res=[],
            len=array.length,
            element,mapped,i;
        for(i=0;i<len;i++) {
            element=array[i];
            mapped=fun(element,i);
            if (mapped!=undefined) res.push(mapped);
        }
        return res;
    },
    /** Flattens an array consting of arrays (and elements)
     *
     * @param array
     * @returns {Array}
     */
    flatten: function (array) {
        var res=[];
        var len=array.length;
        var i;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (!obj.isArray(element)) res.push(element);
            else {
                var j;
                var len2=element.length;
                for(j=0;j<len2;j++) {
                    var element2=element[j];
                    res.push(element2);
                }
            }
        }
        return res;

    },
    /**
     *
     * @param array
     * @returns {*}
     */
    head : function(array) {
        return array[0];
    },
    /**
     *
     * @param length
     * @param fun
     * @returns {Array}
     */
    init : function(length,fun) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = fun(i);
        }
        return arr;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter: function(array,fun) {
      /*
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            fun(array[i],i)
        }
      */
      array.forEach(fun);
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     */
    iter2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.iter2: arrays of different lengths'));
        /*
        var len=array1.length;
        for(i=0;i<len;i++) {
            fun(array1[i],array2[i],i)
        }
        */
        array1.forEach(function (e1,i) { fun(e1,array2[i],i) });
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun Returning a true value leaves iteration loop
     */
    iter_break: function(array,fun) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (fun(element,i)) return;
        }
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter_rev: function(array,fun) {
        var i;
        var len=array.length;
        for(i=len-1;i>=0;i--) {
            fun(array[i],i)
        }
    },
    /** Return last element of array.
     *
     */
    last : function(array) {
      var len=array.length;
      if (len==0) return none;
      else return array[len-1];
    },
    
    length : function(array) {
        return array.length;
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     * @returns {* []}
     */
    map2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.map2: arrays of different lengths'));
        var len=array1.length;
        var res=[];
        for(i=0;i<len;i++) {
            res.push(fun(array1[i],array2[i],i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     * @returns {* []}
     */
    map: function(array,fun) {
        var i=0;
        var len=array.length;
        var res=[];
        for(i=0;i<len;i++) {
            var element=array[i];
            res.push(fun(element,i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hdtl  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match: function(array,fun_hdtl,fun_empty) {
        if (array.length == 0) {
            if (fun_empty) fun_empty();
        } else if (array.length>1) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else fun_hdtl(this.head(array),[]);
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hd1hd2  - function(hd1,hd2)
     * @param {Function} [fun_hdtl]  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match2: function(array,fun_hd1hd2,fun_hdtl,fun_empty) {
        if (array.length == 0 && fun_empty)
            fun_empty();
        else if (array.length == 2) {
            var hd1 = this.head(array);
            var hd2 = this.second(array);
            fun_hd1hd2(hd1,hd2);
        }
        else if (array.length>1 && fun_hdtl) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else if (fun_hdtl) fun_hdtl(this.head(array),[]);
    },
    /** Return the maximum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    max : function (array,fun) {        
        var res,max,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (max==undefined) { max=num; res=array[i] } 
            else if (num > max) { max=num; res=array[i] }
        }
        return res;
    },
    /** Return the minimum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    min : function (array,fun) {        
        var res,min,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (min==undefined) { min=num; res=array[i] }
            else if (num < min) { min=num; res=array[i] }
        }
        return res;
    },
    /** Check for an element in the array.
     *
     * @param {(number|string|boolean) []} array
     * @param {number|string|boolean} element
     * @returns {boolean}
     */
    member: function(array,element) {
        var i,exist;
        var len=array.length;
        exist=false;
        loop: for(i=0;i<len;i++) {
            var _element=array[i];
            if (_element==element) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Merge all arrays and return a new array.
     *
     * @param {Array} array1
     * @param {Array} array2
     * @param {Array} [array3]
     * @param {Array} [array4]
     * @returns {Array}
     */
    merge: function(array1,array2,array3,array4) {
        var arraynew=array1.slice();
        arraynew=arraynew.concat(array2);
        if (array3!=undefined) arraynew=arraynew.concat(array3);
        if (array4!=undefined) arraynew=arraynew.concat(array4);
        return arraynew;
    },
    /** Return the next element from array after val (next element after last is first!)
     * @param {Array} array
     * @param {number|string} val
     * @returns {number|string}
     */
    next: function(array,val) {
        var i;
        var len=array.length;
        if (obj.isString(val))
          for(i=0;i<len;i++) {
            if (string.equal(array[i],val)) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
        else
          for(i=0;i<len;i++) {
            if (array[i]==val) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
          
        return none;
    },
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean disjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    or: function(array,fun) {
        var res=false;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res||fun(element,i)
        }
        return res;
    },
    
   /**
     * Gets the property value of `key` from all elements in `collection`.
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * pluck(users, 'user');
     * // => ['barney', 'fred']
     */
    pluck: function(collection, key) {
      return collection.map(function(object) {
          return object == null ? undefined : object[key];
        });
    },
    /*
     ** Push/pop head elements (Stack behaviour)
     */
    /** Remove and return top element of array.
     *
     * @param array
     * @returns {*}
     */
    pop : function(array) {
        var element=array[0];
        array.shift();
        return element;
    },
    print: function(array) {
        var i;
        var len=array.length;
        var str='[';
        for(i=0;i<len;i++) {
            var cell=array[i];
            str=str+cell;
        }
        return str+']';
    },
    /** Add new element at top of array.
     *
     * @param array
     * @param element
     */
    push : function(array,element) {
        array.unshift(element);
    },
    /** Create an ordered array of numbers {a,a+1,..b}
     *
     * @param a
     * @param b
     * @returns {Array}
     */
    range : function(a,b) {
        var i;
        var array=[];
        for(i=a;i<=b;i++) array.push(i);
        return array;
    },
    /** Remove elements from an array.
     *  [1,2,3,4,5,6] (begin=2,end=4) => [1,2,6]
     * @param {* []} array
     * @returns {* []}
     */
    remove: function(array,begin,end) {
      var i,a;
      if (end==undefined) end=begin+1;
      if (begin<0 || end >= array.length) return [];
      a=array.slice(0,begin);
      for(i=end;i<array.length;i++) a.push(array[i]);
      return a;
    },
    
    second : function(array) {
        return array[1];
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,*):number} fun   (1:a gt. b by the ordering criterion,-1: a lt. b, 0: a eq. b)
     * @returns {* []}
     */
    sort: function(array,fun) {
        var array2=array.slice();
        array2.sort(fun);
        return array2;
    },
    /** Split an array at position 'pos', i.e., remove 'len' (1) elements starting at 
     *  position 'pos'.
     *  ==> use remove!!! split should return two arrays!!
     *
     * @param array
     * @param pos
     * @param [len]
     * @param element
     */    
    split: function(array,pos,len) {
      if (pos==0) return array.slice((len||1));
      else {
        var a1=array.slice(0,pos);
        var a2=array.slice(pos+(len||1));
        return a1.concat(a2);
      }
    },
    /** Return the sum number of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    sum : function (array,fun) {        
        var res=0;
        for(var i in array) {
            var num=0;
            if (fun) num=fun(array[i]); else num=array[i];
            if (!obj.isNumber(num)) return undefined;
            res += num;
        }
        return res;
    },
    /** Return a new array w/o the head element (or optional 
     *  w/o the first top elements).
     *
     */
    tail : function(array,top) {
        var array2=array.slice();
        array2.shift();
        if (top) for(;top>1;top--) array2.shift();
        return array2;
    },
    /** Return union of two sets (== conjunction set)
     *
     * @param {* []} set1 
     * @param {* []} set2
     * @param {function} [fun]  Equality test
     * @returns {* []}
     */
    union : function(set1,set2,fun) {
        var i,j,res = [];
        for (i in set1) {
          for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) res.push(set1[i]);
            else if (fun == undefined && set1[i]==set2[j]) res.push(set1[i]);
          }
        }
        return res;
    },
    
    /**
     * Creates a duplicate-free version of an array
     */
    unique: function(array) {
      var length = array ? array.length : 0;
      function baseUniq(array) {
        var index = -1,
            length = array.length,
            seen,
            result = [];

        seen = result;
        outer:
        while (++index < length) {
          var value = array[index];
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        return result;
      }
      if (!length) {
        return [];
      }
      return baseUniq(array);
    },
    
    /**
     * Creates an array excluding all provided values
     * without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    without: function () {
      var array,
          values=[];
      for(var i in arguments) {
        if (i==0) array=arguments[0];
        else values.push(arguments[i]);
      }
      return array.filter(function (e) {
        return values.indexOf(e) == -1;
      });
    },
    /** Test for zero elements {0, '', false, undefined, ..}
    */
    zero: function (array) {
      for(var i in array) if (!!array[i]) return false;
      return true;
    },
};

/** STRING
 *
 */
var string = {
    /** Is pattern conatined in template?
     *
     */
    contains: function (template,pattern) {
      return template.indexOf(pattern)>-1;
    },
    copy: function(src) {
        var i;
        var dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
    },
    /**
     *
     * @param {number} size
     * @returns {string} filled with spaces
     */
    create: function(size)
    {
        var i;
        var s='';
        var init=' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    endsWith : function (str,tail) {
        return str.indexOf(tail)==(str.length-tail.length);
    },
    empty: function (str) {
      return this.equal(str,'');
    },
    equal:  function(str1,str2) {
        var i;
        var eq=true;
        if (str1.length != str2.length) return false;
        for(i=0;i<str1.length;i++) { if (string.get(str1,i)!=string.get(str2,i)) eq=false;}
        return eq;
    },
    find: function (search,str) {
        return str.indexOf(search);
    },
    format_hex: function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
    },
    /**
     *
     * @param {string} str
     * @param {number} index
     * @returns {string}
     */
    get: function (str,index) {
        assert((str != undefined && index < str.length && index >= 0)||('string.get ('+str.length+')'));
        return str.charAt(index);
    },
    isBoolean: function (str) {
        return (str=='true' || str=='false')
    },
    isNumeric: function (str) {
        return !isNaN(parseFloat(str)) && isFinite(str);
    },
    isText: function (s) {
      var is_text=true;
      string.iter(s,function (ch,i) {
        string.match(ch,[
          ['a','z',function () {}],
          ['A','Z',function () {}],
          ['0','9',function () {if (i==0) is_text=false;}],
          function () {is_text=false;}
        ]);
      });
      return is_text;
    },
    /**
     *
     * @param {string} str
     * @param {function(string,number)} fun
     */
    iter: function(str,fun) {
        var i;
        var len=str.length;
        for (i = 0; i < len; i++)  {
            var c = str.charAt(i);
            fun(c,i);
        }
    },
    /**
     *
     * @param str
     * @returns {*}
     */
    length: function(str) {
        if (str!=undefined) return str.length;
        else return 0;
    },
    /**
     *
     * @param str
     * @returns {string}
     */
    lowercase : function (str) {
        return str.toLowerCase();
    },
    /**
     *
     * @param {number} size
     * @param {string} init
     * @returns {string}
     */
    make: function(size,init)
    {
        var i;
        var s='';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    /** Map a string with a set of (test,reuslt) transformation rules.
     * 
     * @param {string} str
     * @param {* [] []} case - ([string,string] | fun) []
     */
    map: function(str,mapping) {
        var i;
        var map;
        for(i in mapping) {
            map=mapping[i];
            if (obj.isFunction(map)) return map(str);
            else if (this.equal(str,map[0])) return map[1];
        }          
    },
    /** Match a string with different patterns and apply a matching function.
     *
     * @param {string} str
     * @param {* [] []} cases - ([string,fun] | [string [<case1>,<case2>,..],fun] | [<range1>:string,<range2>:string,fun] | fun) []
     */
    match: function(str,cases) {
        var i,j;
        var cas,cex,cv;
        for(i in cases) {
            cas=cases[i];
            if (obj.isArray(cas)) {
              switch (cas.length) {
                case 2:
                  // Multi-value-case
                  cex=cas[0];
                  if (!obj.isArray(cex)) {
                      if (this.equal(str,cex)) {
                          cas[1]();
                          return;
                      }
                  } else {
                      for(j in cex) {
                          cv=cex[j];
                          if (this.equal(str,cv)) {
                              cas[1]();
                              return;
                          }
                      }
                  }
                  break;
                case 3:
                  // Character range check
                  try {
                    j=pervasives.int_of_char(str);
                    if (j>= pervasives.int_of_char(cas[0]) && j<=pervasives.int_of_char(cas[1])) {
                      cas[2](str);
                      return;
                    }
                  } catch(e) {
                    return
                  };
                  break;
                case 1:
                  cas[0](str); // Default case - obsolete
                  return;
                default: 
                  throw 'String.match #args';
              }
            } else if (obj.isFunction(cas)) {
                // Default case
                cas(str);
                return;
            }
        }
    },
    /** Pad a string on the left (pre-str.length) if pre>0,
     *  right (post-str.length) if post>0, or centered (pre>0&post>0).
     *
     */
     
    pad: function (str,pre,post,char) {
      var len = str.length;
      if (pre>0 && post==0) return string.make(len-pre,char||' ')+str;
      else if (post>0 && pre==0) return str+string.make(post-len,char||' ');
      else return string.make(len-pre/2,char||' ')+str+string.make(len-post/2,char||' ');
    },
    /**
     *
     * @param str
     * @param pos
     * @param len
     * @returns {Number}
     */
    parse_hex: function (str,pos,len) {
        // parse a hexadecimal number in string 'str' starting at position 'pos' with 'len' figures.
        return parseInt(this.sub(str,pos,len),16);
    },
    /** Return the sub-string after a point in the source string ('.' or optional point string).
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    postfix: function (str,point) {
      var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(n+1);
    },
    /** Return the sub-string before a point in the source string ('.' or optional point string)
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    prefix: function (str,point) {
        var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(0,n);
    },
    replace_first: function (pat,repl,str) {
        return str.replace(pat,repl);
    },
    replace_all: function (pat,repl,str) {
        return str.replace('/'+pat+'/g',repl);
    },
    /**
     *
     * @param str
     * @param index
     * @param char
     * @returns {string}
     */
    set: function (str,index,char) {
        assert((str != undefined && index < str.length && index >= 0)||'string.get');
        return str.substr(0, index) + char + str.substr(index+1)
    },
    /**
     *
     * @param delim
     * @param str
     * @returns {*|Array}
     */
    split: function (delim,str) {
        return str.split(delim);
    },
    startsWith : function (str,head) {
        return !str.indexOf(head);
    },
    /** Return a sub-string.
     * 
     * @param str
     * @param off
     * @param [len] If not give, return a sub-string from off to end
     * @returns {string}
     */
    sub: function (str,off,len) {
        if (len)
            return str.substr(off,len);
        else
            return str.substr(off);
    },
    /** Remove leading and trailing characters from string
     *
     * @param str
     * @param {number} pref number of head characters to remove
     * @param {number} post number of tail characters to remove
     * @returns {*}
     */
    trim: function (str,pref,post) {
        if (str.length==0 ||
            pref>str.length ||
            post>str.length ||
            pref < 0 || post < 0 ||
            (pref==0 && post==0)
        ) return str;
        return str.substr(pref,str.length-pref-post);
    },
    /** Return a string with all characters converted to uppercase letters.
     *
     * @param str
     * @returns {string}
     */
    uppercase : function (str) {
        return str.toUpperCase();
    },
    /** Return a string with first character converted to uppercase letter.
     *
     * @param str
     * @returns {string}
     */
    Uppercase : function (str) {
        var len = str.length;
        if (len > 1) {
            var head = str.substr(0,1);
            var tail = str.substr(1,len-1);
            return head.toUpperCase()+tail.toLowerCase()
        } if (len==1) return str.toUpperCase();
        else return '';
    }
};

/** RANDOM
 *
 */
var rnd = Math.random;
/* Antti Syk�ri's algorithm adapted from Wikipedia MWC
** Returns a random generator function [0.0,1.0| with seed initialization
*/
var seeder = function(s) {
    var m_w  = s;
    var m_z  = 987654321;
    var mask = 0xffffffff;

    return function() {
      m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
      m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;

      var result = ((m_z << 16) + m_w) & mask;
      result /= 4294967296;

      return result + 0.5;
    }
}
 
var random = {
    float: function(max) {
        return rnd()*max
    }, 
    int: function(max) {
        return Math.floor(rnd()*max+0)
    },
    // integer
    interval: function(min,max) {
        return Math.round(min+rnd()*(max-min))
    },
    // float
    range: function(min,max) {
        return min+rnd()*(max-min)
    },
    seed: function (s) {
      // Create a new initialized random generator
      rnd=seeder(s);
    }
};

/** PRINTF
 *
 */
var printf = {
    /** Trim string(s).
     *
     * @param str
     * @param indent
     * @param [width]
     * @param {string} [tab]
     * @returns {string}
     */
    align: function (str,indent,width,tab) {
        var lines = string.split('\n',str);
        var form = '';
        var sp = printf.spaces(indent);
        var spbreak = sp;

        array.iter(lines,function(line){
            var rest;
            function breakit(spbreak,str) {
                if (width < (str.length + spbreak.length)) {
                    return spbreak+string.sub(str,0,width-spbreak.length)+'\n'+
                           breakit(spbreak,string.sub(str,width-spbreak.length,str.length-width+spbreak.length));
                } else return spbreak+str+'\n';
            }
            if (width && width < (line.length + indent)) {
                if (tab) {
                    var pos = string.find(tab,line);
                    if (pos > 0 && pos < width) spbreak=printf.spaces(pos+indent+1);
                    else spbreak=sp;
                }
                form=form+sp+string.sub(line,0,width-indent)+'\n';
                rest=string.sub(line,width-indent,line.length-width+indent);
                form=form+breakit(spbreak,rest);
            }
            else
                form=form+sp+line+'\n';
        });
        return form;
    },
    /** Format a list of array elements using the (optional) mapping
     *  function <fun> and the separator <sep> (optional, too, default is ',').
     * 
     */
    list: function (array,fun,sep) {
      var i, str='';
      if (sep==undefined) sep=',';
      if (fun==undefined) fun=function (s) {return s;};
      if (!obj.isArray(array)) array=[array];
      for (i in array) {
        if (str==='') str=fun(array[i]);
        else str=str+sep+fun(array[i]);
      }
      return str;
    },
    /**
     *
     * @param n
     * @returns {string}
     */
    spaces: function (n){
        return string.make(n,' ');
    },
    /** Formatted printer (simplified)
     *
     * @param {* []} args (['%format',arg]|string) []  format=%s,%d,%f,%c,%x,%#d,%#s,..
     * @returns {string}
     */
    sprintf2: function(args) {
        var str='';
        array.iter(args,function(fmtarg) {
            var len, n,fs;
            if (obj.isArray(fmtarg)) {
                if (fmtarg.length==2) {
                    var fmt=fmtarg[0];
                    var arg=fmtarg[1];
                    var fc='';
                    var fn=0;
                    string.iter(fmt,function(c) {
                        if (c=='s' || c=='d' || c=='f' || c=='x') {
                            fc=c;
                        } else if (c!='%') {
                            fn=fn*10;
                            n=parseInt(c);
                            if (!isNaN(n)) fn=fn+n;
                        }
                    });
                    if (fc=='s' && obj.isString(arg)) {
                        str=str+arg;
                        if (fn!=0) {
                            len=arg.length;
                            if (len<fn) str=str+string.create(fn-len);
                        }
                    } else if (fc=='d' && obj.isNumber(arg)) {
                        fs = pervasives.string_of_int(arg);
                        if (fn!=0) {
                            len = fs.length;
                            if (len < fn) {
                                str=str+string.create(fn-len);
                            }
                        }
                        str=str+fs;
                    } else if (fc=='x' && obj.isNumber(arg)) {
                        fs = string.format_hex(arg,fn||8);
                        str=str+fs;
                    }
                }
            } else if (obj.isString(fmtarg)) {
                str = str + fmtarg;
            }
        });
        return str;
    },
    sprintf:Sprintf.sprintf
};

/** FILENAME
 *
 */
var filename = {
    /**
     *
     * @param path
     * @returns {string}
     */
    basename : function (path) {
        return Path.basename(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    dirname : function (path) {
        return Path.dirname(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    extname : function (path) {
        return Path.extname(path)
    },
    /**
     *
     * @param path
     * @returns {boolean}
     */
    is_relative: function(path) {
        return !(path.length > 0 && path[0] == '/');
    },
    /**
     *
     * @param pathl
     * @param absolute
     * @returns {string}
     */
    join: function (pathl,absolute) {
        var path=(absolute?'/':'');
        array.iter(pathl,function (name,index) {
            if (index>0) {
                path=path+'/'+name;
            }
            else {
                path=path+name;
            }
        });
        return path;
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    normalize : function (path) {
        return Path.normalize(path)
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    path_absolute: function (path) {
        if (this.is_relative(path)) {
            var workdir = Io.workdir();
            return this.path_normalize(workdir + '/' + path);
        } else return this.path_normalize(path);
    },
    /** Duplicate of Path.normalize!?
     *
     * @param path
     * @returns {string}
     */
    path_normalize: function (path) {
        var i;
        if (string.equal(path, '')) path = '/';
        var relpath = !(string.get(path, 0) == '/');
        var pathlist = path.split('/');
        var pathlist2 = pathlist.filter(function (s) {
            return (!string.equal(s, '') && !string.equal(s, '.'))
        });
        var pathlist3 = [];
        array.iter(pathlist2, function (pe) {
            if (!string.equal(pe, '..')) {
                array.push(pathlist3, pe)
            } else {
                if (pathlist3.length == 0) return '';
                else
                    pathlist3 = array.tail(pathlist3);
            }
        });
        var path2 = '';
        i = 0;
        array.iter(pathlist3, function (pe) {
            var sep;
            if (i == 0) sep = ''; else sep = '/';
            path2 = pe + sep + path2;
            i++;
        });
        if (relpath) return path2; else return '/' + path2;
    },
    removeext: function (path) {
      return path.substr(0, path.lastIndexOf('.'));
    }
};

/** PERVASIVES
 *
 *
 */
var pervasives = {
    assert:assert,
    char_of_int: function (i) {return String.fromCharCode(i)},
    div: function(a,b) {return a/b|0;},
    failwith: function(msg) {Io.err(msg);},
    float_of_string: function(s) {var num=parseFloat(s); if (isNaN(num)) throw 'NaN'; else return num;},
    int_of_char: function(c) {return c.charCodeAt()},
    int_of_float: function(f) {return f|0;},
    int_of_string: function(s) {      
      var num=parseInt(s); if (isNaN(num)) throw 'NaN'; else return num;
    },

    /** Try to find a value in a search list and return a mapping value.
     *
     * @param {*} value
     * @param {* []} mapping [testval,mapval] []
     * @returns {*}
     */
    map: function(value,mapping) {
        function eq(v1,v2) {
            if (v1==v2) return true;
            if (obj.isString(v1) && obj.isString(v2)) return string.equal(v1,v2);
            return false;
        }
        if (!array.empty(mapping)) {
          var hd=array.head(mapping);
          var tl=array.tail(mapping);
          if (eq(hd[0],value)) return hd[1];
          else return pervasives.map(value,tl);
        }  else return undefined;
    },
    /** Apply a matcher function to a list of cases with case handler functions.
     * A case is matched if the matcher function returns a value/object.
     *
     * The result of the matcher function is passed as an argument ot the case handler function.
     * The return value of the case handler fucntion is finally returned by this match function
     * or undefined if there was no matching case.
     *
     * @param {function(*,*):*} matcher function(expr,pat)
     * @param {*} expr
     * @param {*[]} cases (pattern,handler function | handler function) []
     * @returns {*|undefined}
     */
    match: function (matcher,expr,cases) {
        var ret = undefined;
        array.iter_break(cases, function (match) {
            var quit, succ, pat, fun;

            if (match.length == 2) {
                /*
                 ** Pattern, Function
                 */
                pat = match[0];
                fun = match[1];
                succ = matcher(expr, pat);
                if (succ) ret = fun(succ);
                quit = succ!=undefined;
            } else if (match.length == 1) {
                /*
                 ** Default case, Function
                 */
                fun = match[0];
                ret = fun();
                quit= true;
            }
            return quit;
        });
        return ret;
    },
    mtime: function () {var time = new Date(); return time.getTime();},
    min: function(a,b) { return (a<b)?a:b},
    max: function(a,b) { return (a>b)?a:b},
    string_of_float: function(f) {return f.toString()},
    string_of_int: function(i) {return i.toString()},
    string_of_int64: function(i) {return i.toString()},
    time: function () {var time = new Date(); return (time.getTime()/1000)|0;}
};

/** BIT
 *
 */
var bit = {
    get: function (v,b) {return (v >> b) && 1;},
    isSet: function (v,b) {return ((v >> b) && 1)==1;},
    set: function (v,b) {return v & (1 << b);}
};

/** ARGS
 *
 */
var args = {
    /** Parse process or command line arguments (array argv). The first offset [1] arguments are
     ** ignored. The numarg pattern '*' consumes all remaining arguments.
     *
     * @param {string []} argv
     * @param {*[]} map  [<argname>,<numargs:0..3|'*'>,<handler(up to 3 arguments|[])>]|[<defhandler(val)>] []
     * @param {number} [offset]
     */
    parse: function(argv,map,offset) {
        var shift=undefined,
            in_shift=0,
            shift_args=[],
            names,
            mapfun,
            numarg,
            len=argv.length;

        if (offset==undefined) offset=1;

        argv.forEach(function (val, index) {
            var last=index==(len-1);
            if(index>=offset) {
                if (in_shift==0) {
                    array.check(map,function (onemap) {
                        assert(onemap!=undefined||'map');
                        if (onemap.length==3) {
                            names  = onemap[0];
                            numarg = onemap[1];
                            mapfun = onemap[2];
                            if (!obj.isArray(names)) names=[names];
                            var found = array.find(names,function (name) {
                                if (string.equal(val, name)) return name; else _;
                            });
                            if (found) {
                                if (numarg==0) mapfun(found);
                                else {
                                    in_shift=numarg;
                                    shift_args=[];
                                    shift=mapfun;
                                }
                                return true;
                            }
                        } else if (obj.isFunction(onemap)) {
                          onemap(val);
                          return true;                        
                        } else if (onemap.length==1) {
                            mapfun = onemap[0];
                            mapfun(val);
                            return true;
                        }
                        return false;
                    });
                } else {
                    shift_args.push(val);
                    if (in_shift!='*') in_shift--;
                    if (in_shift==0 && shift!=undefined) {
                        numarg=shift_args.length;
                        switch (numarg) {
                            case 0: shift(val);break;
                            case 1: shift(shift_args[0],val); break;
                            case 2: shift(shift_args[0],shift_args[1],val); break;
                            case 3: shift(shift_args[0],shift_args[1],shift_args[2],val); break;
                            default: break;
                        }
                        shift=undefined;
                    } else if (in_shift=='*' && last) shift(shift_args);
                }
            }
        });
    }

};

/** HASHTBL
 *
 */
var hashtbl = {
    add: function(hash,key,data) {
        hash[key]=data;
    },
    create: function(initial) {
        return [];
    },
    empty: function(hash) {
        for (var key in hash) return false;
        return true;
    },
    find: function(hash,key) {
        return hash[key];
    },
    invalidate: function(hash,key) {
        hash[key]=undefined;
    },
    iter: function(hash,fun) {
        for (var key in hash) {
            if (hash[key]!=undefined) fun(key,hash[key]);
        }
    },
    mem: function(hash,key) {
        return hash[key] != undefined;
    },
    remove: function(hash,key) {
        // TODO: check, its wrong!
        if (!hash.hasOwnProperty(key))
            return;
        if (isNaN(parseInt(key)) || !(hash instanceof Array))
            delete hash[key];
        else
            hash.splice(key, 1)
    }
};

var types = [];
/**
 * 
 * @param name
 * @returns {number}
 */
function register_type(name) {
    var typoff = 1000+types.length*1000;
    if (array.member(types,name)) throw('[COMP] register_type: type '+name+' exists already.');
    types.push(name);
    return typoff;
}

/**
 *
 * @typedef {{v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tuple
 */
/**
 *
 * @typedef {{t:number, v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tagged_tuple
 */

module.exports = {
    args:args,
    assert: assert,
    array:array,
    bit:bit,
    defineGetter : defineGetter,
    defineSetter : defineSetter,
    div:pervasives.div,
    filename:filename,
    hashtbl:hashtbl,
    inherit : inherit,
    inheritPrototype : inheritPrototype,
    instanceOf : instanceOf,
    isNodeJS: function () {
        return (typeof global !== "undefined" &&
                {}.toString.call(global) == '[object global]');
    },
    obj:obj,
    pervasives:pervasives,
    printf:printf,
    random:random,
    string:string,
    isArray: obj.isArray,
    isString: obj.isString,
    isNumber: obj.isNumber,

    register_type:register_type,
    /**
     *
     * @param tag
     * @param [val1]
     * @param [val2]
     * @param [val3]
     * @returns {(tagged_tuple)}
     */
    Tuple: function (tag,val1,val2,val3) {
        if(val3) return {t:tag,v1:val1,v2:val2,v3:val3};
        else if (val2) return {t:tag,v1:val1,v2:val2};
        else if (val1) return {t:tag,v1:val1};
        else return {t:tag};
    }
};
};
BundleModuleCode['plugins/ml/ice']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2014, Ankit Kuwadekar
 **    $MODIFIED:    (C) 2006-2018 bLAB by sbosse
 **    $VERSION:     1.3.2X
 **
 **    $INFO:
 **
 ** ICE: C45/ID3 Decision Tree Algorithm supporting feature variables with eps intervals
 **
 ** Portable model
 **
 ** New:
 **        typeof eps = number | [epsx1:number,epsx2:number,..]
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var that;
var _ = undefined;
var none = null;

/**
 * Map of valid tree node types
 * @constant
 * @static
 */
var NODE_TYPES = {
  RESULT: 'result',
  FEATURE: 'feature',
  FEATURE_VALUE: 'feature_value'
};

var NL ='\n'

/**
 * Creates a new tree
 */
function createTree(data, target, features, eps) {
  var ml = that.ml;

  var targets = ml.stats.unique(ml.stats.utils.column(data, target));
  if (targets.length == 1) {
    return {
      type: NODE_TYPES.RESULT,
      name: targets[0],
    };
  }

  if (features.length == 0) {
    var topTarget = ml.stats.mostCommon(targets);
    return {
      type: NODE_TYPES.RESULT,
      name: topTarget,
    };
  }

  
  var split = ml.stats.splitEps(data,features,target,targets,eps);
  var bestFeature = split.feature;
  var index = features.indexOf(bestFeature);
  var remainingFeatures = split.remainingFeatures;
  var remainingEps = 
    typeof eps == 'number'?eps:remainingFeatures.map(function (v) { return eps[features.indexOf(v)] });
  var possibleValues = split.possibleValues;

  var node = {
    type: NODE_TYPES.FEATURE,
    name: bestFeature,
    index: index,
    eps: that.ml.stats.utils.selectEps(eps,index)
  };

  node.vals = split.choices.map(function (c) {
    var child_node = {
      val : c.val,
      eps : that.ml.stats.utils.selectEps(eps,index),
      type: NODE_TYPES.FEATURE_VALUE
    };

    child_node.child = createTree(c.data, target, remainingFeatures, remainingEps);
    return child_node;
    
  })
  return node;
}


function depth(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return 1;
    case NODE_TYPES.FEATURE: 
      return 1+Comp.array.max(model.vals.map(function (val) {
        return depth(val);
      }));
    case NODE_TYPES.FEATURE_VALUE: 
      return 1+depth(model.child);   
  }
  return 0;
}

function info(model) {
  var vl = vars(model);
  return {
    depth:depth(model),
    nodes:vl.length,
    vars:vl.unique(),
  }
}

function predictEps(model,sample,prob,eps) {
  var root = model;
  if (!prob) prob=1;
  while (root.type !== NODE_TYPES.RESULT) {
    var attr = root.name;
    var sampleVal = sample[attr];
    // kNN approximation
    var childNode = null;
    root.vals.forEach(function(node) {
      var fit=Math.abs(node.val-sampleVal);
      if (!childNode || fit < childNode.fit) childNode={fit:fit,node:node};
    });
    if (childNode){
      // with fit quality propagation
      prob = prob * (1-Math.abs(childNode.fit/that.ml.stats.utils.selectEps(eps,root.index))/4) 
      root = childNode.node.child;
    } else {
      root = root.vals[0].child;
    }
  }
  return {value:root.name,prob:prob};
};


function printModel(model,indent) {
  var line='',sep;
  if (indent==undefined) indent=0;
  if (!model) return '';
  var sp = function () {var s=''; for(var i=0;i<indent;i++) s+=' '; return s};
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return sp()+'-> '+model.name+NL;
    case NODE_TYPES.FEATURE:
      line=sp()+'$'+model.name+'?'+NL;
      model.vals.forEach(function (v) {
        line += printModel(v,indent+2);
      }); 
      return line;
    case NODE_TYPES.FEATURE_VALUE: 
      line=sp()+'=['+(model.val-model.eps)+','+(model.val+model.eps)+']'+NL;
      return line+printModel(model.child,indent+2); 
  }
  return 'model?';
}

function vars(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return [];
    case NODE_TYPES.FEATURE: 
      return [model.name].concat(Comp.array.flatten(model.vals.map(vars)));
    case NODE_TYPES.FEATURE_VALUE: 
      return vars(model.child);   
  }
  return [];
}

that = module.exports = {
  create: function (options) {
    return createTree(options.data,
                      options.target,
                      options.features,
                      options.eps)
  },
  depth:depth,
  info:info,
  ml:{},
  predict:function (model,sample) {
    return predictEps(model,sample,1,model.eps)
  },
  print:printModel,
}
};
BundleModuleCode['plugins/ml/dti']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2018 bLAB
 **    $CREATED:     03-03-16 by sbosse.
 **    $VERSION:     1.4.2X
 **
 **    $INFO:
 **
 ** Interval Decision Tree Learner
 **
 ** Modified ID3-based Decision Tree Algorithm that wraps all data with 2-eps intervals and uses
 ** interval instead single value arithmetic for entropy calculation and feature selection.
 ** The classification bases on a nearest-neighbourhood look-up of best matching results.
 **
 ** Two different algorithms are supported:
 **
 **   1. Static (using learn), the DTI learner using attribute selection based on entropy.
 **      The training data must be available in advance.
 **   2. Dynamic (using update), the DTI learrner using attribute selection based on significance.
 **      The training data is applied sequentielly (stream learning) updating the model.
 **
 **   Though in principle the both algrotihms can be mixed (first static, then dynamic updating), 
 **   the resulting model will have poor classification quality. Either use static or only dynamic
 **   (stream) learning.
 **   
 ** Portable model
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var min = Comp.pervasives.min;
var max = Comp.pervasives.max;
var _ = undefined;
var none = null;

/**
 * Map of valid tree node types
 * @constant
 * @static
 */
var NODE_TYPES = {
  RESULT: 'result',
  FEATURE: 'feature',
  FEATURE_VALUE: 'feature_value'
};


function Result(key) {
  return {
    type:NODE_TYPES.RESULT,
    name:key
  }
}

function Feature(name,vals) {
  return {
    type:NODE_TYPES.FEATURE,
    name:name,
    vals:vals
  }
}

// A value can be a scalar or a range {a,b} object
function Value(val,child) {
  return {
    type:NODE_TYPES.FEATURE_VALUE,
    val:val,
    child:child
  }
}

/** Add a new training set with optional data set merging and value interval expansion.
 * 
 */
function add_training_set(data,set,merge) {
  if (merge) {
    // Merge a data set with an existing for a specific key; create value ranges
  } else
    data.push(set);  
} 


/**
 * Computes Log with base-2
 * @private
 */
function log2(n) {
  return Math.log(n) / Math.log(2);
}




function results(model) {
  var line='',sep;
  if (!model) return '';
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return model.name;
    case NODE_TYPES.FEATURE:
      sep='';
      line='';
      Comp.array.iter(model.vals,function (v) {
        line += sep+results(v);
        sep=',';
      }); 
      return line;
    case NODE_TYPES.FEATURE_VALUE: 
      return results(model.child);   
  }
  return 'result?';
}


/**
 * Finds element with highest occurrence in a list
 * @private
 */
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;

  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}

function addVal(v1,v2) {
  if (v1.a!=undefined) {
    if (v2.a!=undefined) return {a:v1.a+v2.a,b:v1.b+v2.b};
    else return {a:v1.a+v2,b:v2.b+v2};
  } else if (v2.a!=undefined) return {a:v2.a+v1,b:v2.b+v1};
  else return v1+v2;
}

function lowerBound(v) {
  if (v.a==undefined) return v; else return v.a;
}

function upperBound(v) {
  if (v.b==undefined) return v; else return v.b;
}

function equal(v1,v2) {
  return (v1==v2 ||
          (upperBound(v1) == upperBound(v2) &&
          (lowerBound(v1) == lowerBound(v2))))
}

function overlap(v1,v2) {
  return (upperBound(v1) >= lowerBound(v2) && upperBound(v1) <= upperBound(v2)) ||
         (upperBound(v2) >= lowerBound(v1) && upperBound(v2) <= upperBound(v1))
}

function containsVal(vl,v) {
  for (var i in vl) {
    var v2=vl[i];
    if (overlap(v,v2)) return true;
  }
  return false;
}

function centerVal(v) {
  if (v.a==undefined) return v; else return (v.a+v.b)/2;
}

function distanceVal (v1,v2) {
  return Math.abs(centerVal(v1)-centerVal(v2));
}

function Bounds(vl,v) {
  if (vl.length==0) return {a:v,b:v};
  else if (v==undefined) return {a:Min(vl),b:Max(vl)};
  else return {a:Min([Min(vl),v]),b:Max([Max(vl),v])};
}

function Min(vals) {
  var min=none;
  Comp.array.iter(vals, function (val) {
    if (min==none) min=(val.a==undefined?val:val.a);
    else min=val.a==undefined?(val<min?val:min):(val.a<min?val.a:min);
  });
  return min;
}

function Max(vals) {
  var max=none;
  Comp.array.iter(vals,function (val) {
    if (max==none) max=(val.b==undefined?val:val.b);
    else max=(val.b==undefined?(val>max?val:max):(val.b>max?val.a:max));
  });
  return max;
}

// Return interval of a value x with a<=x_center-eps, b>=x_center+eps
function epsVal(x,eps) {
  if (x.a == undefined) return {a:x-eps,b:x+eps};
  else if ((x.b-x.a) < 2*eps) return {a:centerVal(x)-eps,b:centerVal(x)+eps}; 
  else return x;
}
/** Filter out unique values that are spaced at least by eps
 *
 */
function uniqueEps(data,eps) {
  var results=[];
  Comp.array.iter(data,function (x) {
    var found;
    if (!results.length) results.push(x);
    else {
      Comp.array.iter(results,function (y,i) {
        if (found) return;
        found = Math.abs(centerVal(x)-centerVal(y))<eps;
        if (found) // create new overlapping value with +-eps extensions 
          results[i]={a:Min([x,y])-eps,b:Max([x,y])+eps}
      }); 
      if (!found) results.push(x);
    }
  });
  return results;
}

/** Compact tree, merge nodes and intervals.
 ** adjust=true: Adjust overlapping feature variable value intervals!!!
 */

function compactTree(model,adjust) {
  var i,j,vi,vj,_vals,merged;
  function target(model) {
    var line;
    switch (model.type) {
      case NODE_TYPES.RESULT: 
        return model.name;
      case NODE_TYPES.FEATURE:      
        line = model.name+'?'+target;
        Comp.array.iter(model.vals,function (v) {
          line += target(v);
        }); 
        return line;  
      case NODE_TYPES.FEATURE_VALUE: 
        line='='+(model.val.a==undefined?model.val:'['+model.val.a+','+model.val.b+']')+NL;
        return line+target(model.child); 
    }
  }
  if (!model) return model;
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return model;
      break;
    case NODE_TYPES.FEATURE:
      _vals=[];
      // 1. Merge
      for (i in model.vals) {
        vi=model.vals[i];
        assert((vi.type==NODE_TYPES.FEATURE_VALUE)||'vi.type==NODE_TYPES.FEATURE_VALUE');
        merged=false;
        loopj: for(j in _vals) {
          vj=_vals[j];
          if (target(vi.child)==target(vj.child)) {
            merged=true;
            vj.val={a:Min([vi.val,vj.val]),b:Max([vi.val,vj.val])}
            break loopj;
          }
        }
        if (!merged) {
          _vals.push(vi);
          vi.child=compactTree(vi.child);
        }
      }
      // 2. Adjust overlapping value intervals!
      if (adjust) {
        // TODO: approach too simple!!!! 
        for (i in _vals) {
          i=Comp.pervasives.int_of_string(i);
          if (_vals[i+1]) {
            if (upperBound(_vals[i].val) > lowerBound(_vals[i+1].val)) {
              if (_vals[i].val.b) _vals[i].val.b=lowerBound(_vals[i+1].val)-1;
              else _vals[i+1].val.a=upperBound(_vals[i].val)+1;
            }
          }
        }
      }
      
      model.vals=_vals;
      return model;
      break;
    case NODE_TYPES.FEATURE_VALUE:
      return model;
      break;
  }
}



/** Creates a new tree from training data (data)
 *
 *  data is {x1:v1,x2:v2,..,y:vn} []
 *  target is classification key name
 *  features is ['x1','x2,',..]  w/o target variable
 *  eps is interval applied to all data values
 *
 */
function createTree(data, target, features, options) {
  var _newS,child_node,bounds;
      
  var targets = Comp.array.unique(Comp.array.pluck(data, target));
  // console.log(targets)  
  if (options.maxdepth==undefined) options.maxdepth=1;
  if (options.maxdepth==0) return Result('-');
  // console.log(data);
  // console.log(features);

  //Aios.aios.log('createTree:'+targets.length);
  //try {Aios.aios.CP();} catch (e) {throw 'DTI.createTree: '+options.maxdepth };
  if (Aios) Aios.aios.CP();
  if (targets.length == 1) return Result(targets[0]);

  if (features.length == 0) {
    var topTarget = mostCommon(targets);
    return Result(topTarget)
  }
  var bestFeatures = getBestFeatures(data, target, features, options.eps);
  var bestFeature = bestFeatures[0];

  var remainingFeatures = Comp.array.filtermap(bestFeatures,function (feat) {
    if (feat.name!=bestFeature.name) return feat.name;
    else return none;
  });
/*  
  var possibleValues = Comp.array.sort(Comp.array.pluck(data, bestFeature.name), function (x,y) {
    if (upperBound(x) < lowerBound(y)) return -1; else return 1; // increasing value order
  });
*/
  var possibleValues = getPossibleVals(data,bestFeature.name);
  
  var vals=[];
  
  //console.log(bestFeatures);
  //console.log(possibleValues);
  var partitions=partitionVals(possibleValues,options.eps);
  // Aios.aios.log(partitions);
  //console.log(bestFeatures);
  //console.log(possibleValues);
  if (partitions.length==1) {
    // no further 2*eps separation possible, find best feature by largest distance
    // resort best feature list with respect to value deviation
    bestFeatures.sort(function (ef1,ef2) {
      if (ef1.d > ef2.d) return -1; else return 1;
    });
    bestFeature = bestFeatures[0];
    possibleValues = getPossibleVals(data,bestFeature.name);
    Comp.array.iter(mergeVals(possibleValues),function (val,i) {

      _newS = data.filter(function(x) {
        // console.log(x[bestFeature.name],val,overlap(val,x[bestFeature.name]))
        
        return overlap(val,x[bestFeature.name]);
      });
      child_node = Value(val);
      options.maxdepth--;
      child_node.child = createTree(_newS, target, remainingFeatures, options);
      //console.log(_newS);
      vals.push(child_node);
    })    
    
  } else Comp.array.iter(partitions,function (partition,i) {
    
    _newS = data.filter(function(x) {
      // console.log(x[bestFeature.name],v,overlap(x[bestFeature.name],v))
      return containsVal(partition,x[bestFeature.name]);
    });
    bounds = Bounds(partition);
    child_node = Value(options.eps==0?{a:bounds.a,b:bounds.b}:{a:bounds.a-options.eps,b:bounds.b+options.eps});
      options.maxdepth--;
    child_node.child = createTree(_newS, target, remainingFeatures, options);
    //console.log(_newS);
    vals.push(child_node);
  });
  
  return Feature(bestFeature.name,vals);
}

/** Return the depth of the tree
 *
 */
function depth(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return 0;
    case NODE_TYPES.FEATURE: 
      return 1+Comp.array.max(model.vals,function (val) {
        return depth(val);
      });
    case NODE_TYPES.FEATURE_VALUE: 
      return depth(model.child);   
  }
  return 0;
}

/** Computes entropy of a list with 2-epsilon intervals
 *
 */

function entropyEps(vals,eps) {
  // TODO: overlapping value intervals
  var uniqueVals = Comp.array.unique(vals);
  var probs = uniqueVals.map(function(x) {
    return probEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(function(a, b) {
    return a + b
  }, 0);
}

function entropyEps2(vals,eps) {
  // TODO: overlapping value intervals
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probEps2(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(function(a, b) {
    return a + b
  }, 0);
}


function getBestFeatures(data,target,features,eps) {
  var bestfeatures=[];
  function deviation(vals) {
    var n = vals.length;
    var mu=Comp.array.sum(vals,function (val) {
      return (lowerBound(val)+upperBound(val))/2;
    })/n;
    var dev=Comp.array.sum(vals,function (val) {
      return Math.pow(((lowerBound(val)+upperBound(val))/2)-mu,2);
    })/n;
    return dev;
  }
  for (var feature in features) {
    if (features[feature]==undefined) throw 'DTI.getBestFeatures: invalid feature vector';
    var vals=Comp.array.pluck(data, features[feature]).map(function (val) {return val==undefined?0:val});
    var e = entropyEps(vals,eps);
    var d = deviation(vals);
    var min = Min(vals);
    var max = Max(vals);
    bestfeatures.push({e:e,d:d,range:{a:min,b:max},name:features[feature]});
  }
  bestfeatures.sort(function (ef1,ef2) {
    if (ef1.e > ef2.e) return -1; else return 1;
  });
  return bestfeatures;
}

/** Find in one data set the most significant feature variable (i.e., with highest value)
 */
function getSignificantFeature(data,features) {
  var f,sig;
  for (f in features) {
    if (sig==undefined || sig.val < data[features[f]]) sig={name:features[f],val:data[features[f]]};
  }
  return sig;
}

function getPossibleVals(data,feature) {
  return Comp.array.sort(Comp.array.pluck(data, feature), function (x,y) {
    if (upperBound(x) < lowerBound(y)) return -1; else return 1; // increasing value order
  });
}

/** Merge values and intervals
 */
function mergeVals(vals) {
  var _vals,
      merged,i,j;
  for (i in vals) {
    var vi = vals[i];
    if (!_vals) _vals=[vi];
    else {
      // Find overlapping values and merge
      merged=false;
      loopj: for (j in _vals) {
        var vj = _vals[j];
        if (equal(vi,vj)) {
          merged=true;
          break loopj;          
        }
        else if (overlap(vi,vj)) {
          merged=true;
          _vals[j]={a:Min([vi,vj]),b:Max([vi,vj])};
          break loopj;
        }
      }
      if (!merged) _vals.push(vi);
    }
  }
  //Aios.aios.log(_vals);
  return _vals||[];
}

/**
 * Predicts class for sample
 */
function nearestVal(vals,sample,fun) {
  var best=none;
  for (var v in vals) {
    var d=fun?distanceVal(fun(vals[v]),sample):distanceVal(vals[v],sample);
    if (best==none) 
      best={v:vals[v],d:d};
    else if (best.d > d)
      best={v:vals[v],d:d};    
  }
  if (best) return best.v;
  else return none;
}


/** Parttition an ordered set of values
 *  Each partition of values has at least 2*eps distance to the next partition.
 *
 */
function partitionVals(vals,eps) {
  var last=none;
  var partitions=[];
  var partition=[];
  for(var i in vals) {
    var val0=vals[i];
    var val1=vals[i-1];

    if (val1==undefined) partition.push(val0);
    else if ( upperBound(val0) < upperBound(addVal(val1,2*eps))) partition.push(val0);    
    else {
      partitions.push(partition);
      partition=[val0];
    }
  }
  if (partition.length>0) partitions.push(partition);
  return partitions;
}

/** Make a predicition with sample data
 *
 */
function predict(model,sample) {
  var root = model;
  while (root && root.type !== NODE_TYPES.RESULT) {
    var attr = root.name;
    var sampleVal = sample[attr];
    var childNode = nearestVal(root.vals,sampleVal,function (node) {
      return node.val;
    });

    if (childNode){
      root = childNode.child;
    } else {
      root = none;
    }
  }
  if (root) return root.name||root.val;
  else return none;
};

/** Print the tree
 *
 */
function print(model,indent, compact) {
  var line='',sep;
  if (compact) return results(model);
  if (indent==undefined) indent=0;
  if (!model) return '';
  var sp = function () {return Comp.string.create(indent);};
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return sp()+'-> '+model.name+NL;
    case NODE_TYPES.FEATURE:
      line=sp()+'$'+model.name+'?'+NL;
      Comp.array.iter(model.vals,function (v) {
        line += print(v,indent+2);
      }); 
      return line;
    case NODE_TYPES.FEATURE_VALUE: 
      line=sp()+'='+(model.val.a==undefined?model.val:'['+model.val.a+','+model.val.b+']')+NL;
      return line+print(model.child,indent+2); 
  }
  return 'model?';
}

/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probEps(value, list, eps) {
  // TODO: ranges
  var occurrences = Comp.array.filter(list, function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

function probEps2(value, list, eps) {
  // TODO: ranges
  var occurrences = Comp.array.filter(list, function(element) {
    return overlap(epsVal(value), epsVal(element));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

/** Incremental update of the model with new training set(s). Can be executed with an empty model.
 *  The current tree can be week for a new training set (new target).
 *  This can result in a classification of the new target with insignificant variables.
 *  Therefore, the last tree node must be exapnded with an additional strong (most significant)
 *  variable of the new data set (but it is still a heuristic for future updates). 
 */
function updateTree(model,data, target, features, options) {
  var eps = options.eps,
      maxdepth = options.maxdepth,
      verbose = options.verbose;
  var featuresINm={},   // All current tree feature variables and their value interval
      results=[],       // All current tree result leafs
      set,i,v,feature,remainingFeatures,exists,sigFeature;
  // 1. Analysis of existing model
 
  var analyze = function (model,feature) {
    var feature2;
    if (!model) return;
    switch (model.type) {
      case NODE_TYPES.RESULT:
        if (!Comp.array.contains(results,model.name)) results.push(model.name); 
        break;
      case NODE_TYPES.FEATURE:
        feature2={name:model.name};
        if (!featuresINm[model.name]) featuresINm[model.name]=feature2;
        Comp.array.iter(model.vals,function (v) { analyze(v,featuresINm[model.name]) });
        break;
      case NODE_TYPES.FEATURE_VALUE:
        if (!feature.val) feature.val={
          a:(model.val.a==undefined?model.val:model.val.a),
          b:(model.val.a==undefined?model.val:model.val.b)
        }; else {
          feature.val.a=min(feature.val.a,
                            (model.val.a==undefined?model.val:model.val.a));
          feature.val.b=max(feature.val.b,
                            (model.val.a==undefined?model.val:model.val.b));
        }                  
        analyze(model.child);
        break; 
    }   
  }

  
  analyze(model);
  // console.log(featuresINm);
  // console.log(results);
  
  exists=Comp.array.contains(results,data[target]);

  
  // 2a. Empty model, add first training set with two significant feature variable nodes
  function init(set) {
    set=data[i];
      sigFeature1=getSignificantFeature(set,features);
      remainingFeatures=Comp.array.filter(features,function (feat) {
        return sigFeature1.name!=feat;
      });
      sigFeature2=getSignificantFeature(set,remainingFeatures);

      featuresINm[sigFeature1.name]={name:sigFeature1.name,
                                    val:{a:sigFeature1.val-eps,b:sigFeature1.val+eps}};
      featuresINm[sigFeature2.name]={name:sigFeature2.name,
                                    val:{a:sigFeature2.val-eps,b:sigFeature2.val+eps}};
      results.push(set[target]);
      model=Feature(sigFeature1.name,[
                    Value({a:set[sigFeature1.name]-eps,b:set[sigFeature1.name]+eps},
                          Feature(sigFeature2.name,[
                                 Value({a:sigFeature2.val-eps,b:sigFeature2.val+eps},
                                       Result(set[target])) 
                                  ]))]);
      return model;
  }
  
  remainingFeatures=Comp.array.filter(features,function (feat) {
    return !featuresINm[feat];
  });
  
  // 2b. Update the tree with the new training set
  var update = function (model,set,feature) {
    var feature2,p;
    if (!model) return;
    switch (model.type) {
    
      case NODE_TYPES.RESULT:
        if (model.name != set[target] && verbose)
          console.log('Cannot insert new training set '+set[target]+' in tree. No more separating variables!');
        break;
        
      case NODE_TYPES.FEATURE:
        // console.log(set[target]+': '+ model.name+'='+set[model.name]);
        if (set[model.name]<(featuresINm[model.name].val.a-eps) ||
            set[model.name]>(featuresINm[model.name].val.b+eps)) {
          // add new training set; done
          // the current decision tree can  be week, thus add another strong variable node, too! 
          sigFeature=getSignificantFeature(set,remainingFeatures);
          featuresINm[sigFeature.name]={name:sigFeature.name,
                                        val:{a:sigFeature.val-eps,b:sigFeature.val+eps}};
          featuresINm[model.name].val.a=min(featuresINm[model.name].val.a,set[model.name]-eps);
          featuresINm[model.name].val.b=max(featuresINm[model.name].val.b,set[model.name]+eps);
          if (!Comp.array.contains(results,set[target])) results.push(set[target]);

          model.vals.push(Value({a:set[model.name]-eps,b:set[model.name]+eps},
                          Feature(sigFeature.name,[
                            Value({a:sigFeature.val-eps,b:sigFeature.val+eps},
                                  Result(set[target]))
                          ])));
          model.vals=Comp.array.sort(model.vals,function (v1,v2) {return (lowerBound(v1.val)<lowerBound(v2.val))?-1:1});  
        } else {
          // go deeper, but extend the interval of the best matching child node with new data variable
          Comp.array.iter_break(model.vals,function (fv) {
            // console.log(model.name,fv.val,overlap(fv.val,{a:set[model.name]-eps,b:set[model.name]+eps})) 
            if (overlap(fv.val,{a:set[model.name]-eps,b:set[model.name]+eps})) {
              fv.val.a=min(lowerBound(fv.val),set[model.name]-eps);
              fv.val.b=max(upperBound(fv.val),set[model.name]+eps);
              update(fv,set,model.name);
              return true;
            } else return false;
          });
        }
        break;
        
      case NODE_TYPES.FEATURE_VALUE:
        update(model.child,set);
        break; 
    }   
  }

  for (i in data) {
    set=data[i];
    if (model==undefined || model.type==undefined)
      model=init(set);
    else
      update(model,set);
  }
  return model;
}

module.exports =  {
  NODE_TYPES:NODE_TYPES,
  compactTree:compactTree,
  create:function (options) {
    // type options = {data number [][], target:string, features: string [], eps;number, maxdepth}
    return createTree(options.data,options.target,options.features,options)
  },
  depth:depth,
  entropy:entropyEps,
  evaluate:function evaluate(model,target,samples){},
  predict:predict,
  print:print,
  results:results,
  update:function (model,options) {
    // type options = {data number [][], target:string, features: string [], eps:number, maxdepth}
    return updateTree(model,options.data,options.target,options.features,options)
  },
  current:function (module) { current=module.current; Aios=module;}
};


};
BundleModuleCode['plugins/ml/knn']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2014, Ankit Kuwadekar
 **    $MODIFIED:    (C) 2006-2019 bLAB by sbosse
 **    $VERSION:     1.2.1
 **
 **    $INFO:
 **
 ** KNN: k-nearest-neighbour Algorithm
 ** A General purpose k-nearest neighbor classifier algorithm based on the 
 ** k-d tree Javascript library develop by Ubilabs.
 **
 ** Portable models (KNN/KNN2)
 **
 **    $ENDOFINFO
 */
var options = {
  version:'1.2.1'
}
var Comp = Require('com/compat');
var math = Require('plugins/ml/math');
var euclideanDistance = math.euclidean;

/*
 * Original code from:
 *
 * k-d Tree JavaScript - V 1.01
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */

function Node(obj, dimension, parent) {
    var N = {}
    N.obj = obj;
    N.left = null;
    N.right = null;
    N.parent = parent;
    N.dimension = dimension;
    return N;
}

/* KDTree
 *
 */

function KDTree(points, metric) {
    // if (!(this instanceof KDTree)) return new KDTree(points, metric);
    // If points is not an array, assume we're loading a pre-built tree
    var K ={}
    if (!Array.isArray(points)) {
        K.dimensions = points.dimensions;
        K.root = points;
        restoreParent(K.root);
    } else {
        K.dimensions = new Array(points[0].length);
        for (var i = 0; i < K.dimensions.length; i++) {
            K.dimensions[i] = i;
        }
        K.root = buildTree(points, 0, null, K.dimensions);
    }
    K.metric = metric;
    return K;
}

// Convert to a JSON serializable structure; this just requires removing
// the `parent` property
KDTree.code = {
  nearest : function(K, point, maxNodes, maxDistance) {
    var metric = K.metric;
    var dimensions = K.dimensions;
    var i;

    var bestNodes = BinaryHeap(
        function (e) {
            return -e[1];
        }
    );

    function nearestSearch(node) {
        var dimension   = dimensions[node.dimension];
        var ownDistance = metric(point, node.obj);
        var linearPoint = {};
        var bestChild,
            linearDistance,
            otherChild,
            i;
        function saveNode(node, distance) {
            BinaryHeap.code.push(bestNodes,[node, distance]);
            if (BinaryHeap.code.size(bestNodes) > maxNodes) {
                BinaryHeap.code.pop(bestNodes);
            }
        }

        for (i = 0; i < dimensions.length; i += 1) {
            if (i === node.dimension) {
                linearPoint[dimensions[i]] = point[dimensions[i]];
            } else {
                linearPoint[dimensions[i]] = node.obj[dimensions[i]];
            }
        }

        linearDistance = metric(linearPoint, node.obj);
        if (node.right === null && node.left === null) {
            if (BinaryHeap.code.size(bestNodes) < maxNodes || ownDistance < BinaryHeap.code.peek(bestNodes)[1]) {
                saveNode(node, ownDistance);
            }
            return;
        }

        if (node.right === null) {
            bestChild = node.left;
        } else if (node.left === null) {
            bestChild = node.right;
        } else {
            if (point[dimension] < node.obj[dimension]) {
                bestChild = node.left;
            } else {
                bestChild = node.right;
            }
        }

        nearestSearch(bestChild);

        if (BinaryHeap.code.size(bestNodes) < maxNodes || ownDistance < BinaryHeap.code.peek(bestNodes)[1]) {
            saveNode(node, ownDistance);
        }

        if (BinaryHeap.code.size(bestNodes) < maxNodes || Math.abs(linearDistance) < BinaryHeap.code.peek(bestNodes)[1]) {
            if (bestChild === node.left) {
                otherChild = node.right;
            } else {
                otherChild = node.left;
            }
            if (otherChild !== null) {
                nearestSearch(otherChild);
            }
        }
    }

    if (maxDistance) {
        for (i = 0; i < maxNodes; i += 1) {
            BinaryHeap.code.push(bestNodes,[null, maxDistance]);
        }
    }

    if (K.root) {
        nearestSearch(K.root);
    }

    var result = [];
    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
        if (bestNodes.content[i][0]) {
            result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);
        }
    }
    return result;
  }
}

function buildTree(points, depth, parent, dimensions) {
    var dim = depth % dimensions.length;

    if (points.length === 0) {
        return null;
    }
    if (points.length === 1) {
        return Node(points[0], dim, parent);
    }

    points.sort(function (a, b) { a[dimensions[dim]] - b[dimensions[dim]]});

    var median  = Math.floor(points.length / 2);
    var node    = Node(points[median], dim, parent);
    node.left   = buildTree(points.slice(0, median), depth + 1, node, dimensions);
    node.right  = buildTree(points.slice(median + 1), depth + 1, node, dimensions);

    return node;
}

function restoreParent(root) {
    if (root.left) {
        root.left.parent = root;
        restoreParent(root.left);
    }

    if (root.right) {
        root.right.parent = root;
        restoreParent(root.right);
    }
}
/** BinaryHeap
 *
 */
 
// Binary heap implementation from:
// http://eloquentjavascript.net/appendix2.html
function BinaryHeap (scoreFunction) {
  var B={}
    //if (!(this instanceof BinaryHeap)) return new BinaryHeap (scoreFunction);
  B.content = [];
  B.scoreFunction = scoreFunction;
  return B;
}


BinaryHeap.code = {
  push : function(B,element) {
    // Add the new element to the end of the array.
    B.content.push(element);
    // Allow it to bubble up.
    BinaryHeap.code.bubbleUp(B,B.content.length - 1);
  },
  pop : function(B) {
    // Store the first element so we can return it later.
    var result = B.content[0];
    // Get the element at the end of the array.
    var end = B.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it sink down.
    if (B.content.length > 0) {
        B.content[0] = end;
        BinaryHeap.code.sinkDown(B,0);
    }
    return result;
  },
  peek : function(B) {
    return B.content[0];
  },
  size : function(B) {
    return B.content.length;
  },
  bubbleUp : function(B,n) {
    // Fetch the element that has to be moved.
    var element = B.content[n];
    // When at 0, an element can not go up any further.
    while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = Math.floor((n + 1) / 2) - 1;
        var parent = B.content[parentN];
        // Swap the elements if the parent is greater.
        if (B.scoreFunction(element) < B.scoreFunction(parent)) {
            B.content[parentN] = element;
            B.content[n] = parent;
            // Update 'n' to continue at the new position.
            n = parentN;
        } else { // Found a parent that is less, no need to move it further.
            break;
        }
    }
  },
  sinkDown : function(B,n) {
    // Look up the target element and its score.
    var length = B.content.length;
    var element = B.content[n];
    var elemScore = B.scoreFunction(element);

    while (true) {
        // Compute the indices of the child elements.
        var child2N = (n + 1) * 2;
        var child1N = child2N - 1;
        // This is used to store the new position of the element,
        // if any.
        var swap = null;
        // If the first child exists (is inside the array)...
        if (child1N < length) {
            // Look it up and compute its score.
            var child1 = B.content[child1N];
            var child1Score = B.scoreFunction(child1);
            // If the score is less than our element's, we need to swap.
            if (child1Score < elemScore) {
                swap = child1N;
            }
        }
        // Do the same checks for the other child.
        if (child2N < length) {
            var child2 = B.content[child2N];
            var child2Score = B.scoreFunction(child2);
            if (child2Score < (swap === null ? elemScore : child1Score)) {
                swap = child2N;
            }
        }

        // If the element needs to be moved, swap it, and continue.
        if (swap !== null) {
            B.content[n] = B.content[swap];
            B.content[swap] = element;
            n = swap;
        } else {
            // Otherwise, we are done.
            break;
        }
    }
  }
}

/** KNN
 *
 */

/**
 ** typeof @dataset = number [] []
 ** typeof @labels  = number []
 ** typeof @options = { distance?:function, k?:number }
 */
function KNN(dataset, labels, options) {
    var L = {}
    if (!options) options={};
    if (dataset === true) {
        var model = labels;
        L.kdTree = KDTree(model.kdTree, options);
        L.k = model.k;
        L.classes = new Set(model.classes);
        L.isEuclidean = model.isEuclidean;
        return L;
    }
    var classes = new Set(labels);

    var distance = getDistanceFunction(options.distance),
        k = options.k||classes.size + 1;

    var points = new Array(dataset.length);
    for (var i = 0; i < points.length; ++i) {
        points[i] = dataset[i].slice();
    }

    for (i = 0; i < labels.length; ++i) {
        points[i].push(labels[i]);
    }

    L.kdTree = KDTree(points, distance);
    L.k = k;
    L.distance = distance;
    L.classes = classes;
    L.isEuclidean = distance === euclideanDistance;
    return L;
}


/**
 * Predicts the output given the matrix to predict.
 * @param {Array} dataset
 * @return {Array} predictions
 */
KNN.code = {
  predict : function(L,dataset) {
    if (Array.isArray(dataset)) {
        if (typeof dataset[0] === 'number') {
            return getSinglePrediction(L, dataset);
        } else if (Array.isArray(dataset[0]) && typeof dataset[0][0] === 'number') {
            var predictions = new Array(dataset.length);
            for (var i = 0; i < dataset.length; i++) {
                predictions[i] = getSinglePrediction(L, dataset[i]);
            }
            return predictions;
        }
    }
    throw new TypeError('dataset to predict must be an array or a matrix');
  }
}

function getSinglePrediction(knn, currentCase) {
    var nearestPoints = KDTree.code.nearest(knn.kdTree, currentCase, knn.k);
    var pointsPerClass = {};
    var predictedClassMin = null;
    var predictedClassMax = null;
    var predictedClassDistance = 0;
    var maxPoints = -1;
    var minDistance = 1E30;
    
    var lastElement = nearestPoints[0][0].length - 1;
    //for (var element of knn.classes) {
    //    pointsPerClass[element] = 0;
    //}
    forof(knn.classes,function (element) {
      pointsPerClass[element] = 0;
    });
    for (var i = 0; i < nearestPoints.length; ++i) {
        var currentClass = nearestPoints[i][0][lastElement];
        var currentPoints = ++pointsPerClass[currentClass];
        // Either use majority of points matching a class or the nearest points
        if (currentPoints > maxPoints) {
            predictedClassMax = currentClass;
            predictedClassDistance = predictedClassDistance+nearestPoints[i][1];
            maxPoints = currentPoints;
        }
        if (nearestPoints[i][1] < minDistance) {
            predictedClassMin = currentClass;
            minDistance = nearestPoints[i][1];
        }
    }
    predictedClassDistance /= maxPoints;
    return maxPoints>2?predictedClassMax:predictedClassMin;
}



/** Create a simple KNN (2)
 *
 * typeof @options = {x:number [] [],y: number []}
 *
 */
var KNN2 = function (options) {
  var model={}
  // if (!(this instanceof KNN2)) return new KNN2(options);
  model.x       = options.x;
  model.y       = options.y;
  model.target  = options.y;
  model.k       = options.k || 3
  model.distance = getDistanceFunction(options.distance);
  model.weightf =  getWeightedFunction(options.weightf);
  return model
}

/** Make a prediction
 *  
 */
KNN2.code = {
  predict : function (model,data) {
    var x = data;
    var k = model.k;
    var weightf = model.weightf;
    var distance = model.distance;
    var distanceList = [];
    var i;
    for(i=0; i<model.x.length; i++)
        distanceList.push([distance(x,model.x[i]),i]);
    distanceList.sort(function(a,b) {return a[0]-b[0];});
    var avg = 0.0;
    var totalWeight = 0, weight;
    for(i=0; i<k; i++) {
        var dist = distanceList[i][0];
        var idx = distanceList[i][1];
        weight = weightf(dist);
        avg += weight * model.y[idx];
        totalWeight += weight;
    }

    avg /= totalWeight;
    return avg;
  }
}

function getWeightedFunction(options) {
    if(typeof options === 'undefined') {
        return function(x) {
            var sigma = 10.0;
            return Math.exp(-1.*x*x/(2*sigma*sigma));
        }
    } else if(typeof options === 'function') {
        return options;
    } else if(options === 'gaussian') {
        return function(x) {
            var sigma = options.sigma;
            return Math.exp(-1.*x*x/(2*sigma*sigma));
        }
    } else if(options === 'none') {
        return function(dist) {
            return 1.0;
        }
    }
}

function getDistanceFunction(options) {
    if(typeof options === 'undefined') {
        return math.euclidean;
    } else if (typeof options === 'function') {
        return options;
    } else if (options === 'euclidean') {
        return math.euclidean;
    } else if (options === 'pearson') {
        return math.pearson;
    } else 
        throw new TypeError('distance opions invalid: '+options);;      
}

module.exports={
  create    : KNN,
  predict   : KNN.code.predict,
  create2   : KNN2,
  predict2  : KNN2.code.predict,
}
};
BundleModuleCode['plugins/ml/math']=function (module,exports,global,process){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
var m = module.exports;

m.randn = function() {
    // generate random guassian distribution number. (mean : 0, standard deviation : 1)
    var v1, v2, s;

    do {
        v1 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값
        v2 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 까지의 값
        s = v1 * v1 + v2 * v2;
    } while (s >= 1 || s == 0);

    s = Math.sqrt( (-2 * Math.log(s)) / s );
    return v1 * s;
}

m.shape = function(mat) {
    var row = mat.length;
    var col = mat[0].length;
    return [row,col];
};

m.addVec = function(vec1, vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i<vec1.length;i++)
            result.push(vec1[i]+vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.minusVec = function(vec1,vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i<vec1.length;i++)
            result.push(vec1[i]-vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
};

m.addMatScalar = function(mat,scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i<row ; i++) {
        var rowVec = [];
        for(j=0 ; j<col ; j++) {
            rowVec.push(mat[i][j] + scalar);
        }
        result.push(rowVec);
    }
    return result;
}

m.addMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i<mat.length;i++)
            result.push(m.addVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.minusMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i<mat.length;i++)
            result.push(m.minusVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.addMat = function (mat1, mat2) {
    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i < mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j < mat1[i].length; j++) {
                result[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
};

m.minusMat = function(mat1, mat2) {
    if ((mat1.length === mat2.length) && (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i < mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j < mat1[i].length; j++) {
                result[i][j] = mat1[i][j] - mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
}

m.transpose = function (mat) {
    var result = new Array(mat[0].length);
    for (var i = 0; i < mat[0].length; i++) {
        result[i] = new Array(mat.length);
        for (var j = 0; j < mat.length; j++) {
            result[i][j] = mat[j][i];
        }
    }
    return result;
};

m.dotVec = function (vec1, vec2) {
    if (vec1.length === vec2.length) {
        var result = 0;
        for (var i = 0; i < vec1.length; i++) {
            result += vec1[i] * vec2[i];
        }
        return result;
    } else {
        throw new Error("Vector mismatch");
    }
};

m.outerVec = function (vec1,vec2) {
    var mat1 = m.transpose([vec1]);
    var mat2 = [vec2];
    return m.mulMat(mat1,mat2);
};

m.mulVecScalar = function(vec,scalar) {
    var i, result = [];
    for(i=0;i<vec.length;i++)
        result.push(vec[i]*scalar);
    return result;
};

m.mulMatScalar = function(mat,scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i<row ; i++) {
        var rowVec = [];
        for(j=0 ; j<col ; j++) {
            rowVec.push(mat[i][j] * scalar);
        }
        result.push(rowVec);
    }
    return result;
};

m.mulMatElementWise = function(mat1, mat2) {
    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = mat1[i][j] * mat2[i][j]
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.mulMat = function (mat1, mat2) {
    if (mat1[0].length === mat2.length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat2[0].length);
        }


        var mat2_T = m.transpose(mat2);
        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = m.dotVec(mat1[i],mat2_T[j]);
            }
        }
        return result;
    } else {
        throw new Error("Array mismatch");
    }
};

m.sumVec = function(vec) {
    var sum = 0;
    var i = vec.length;
    while (i--) {
        sum += vec[i];
    }
    return sum;
};

m.sumMat = function(mat) {
    var sum = 0;
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++)
          sum += mat[i][j];
    }
    return sum;
};

m.sumMatAxis = function(mat,axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i<row; i++)
            result.push(m.sumVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.sumMatAxis(mat_T,1);
    }
};

m.meanVec = function(vec) {
    return 1. * m.sumVec(vec) / vec.length;
};

m.meanMat = function(mat) {
    var row = mat.length;
    var col = mat[0].length;
    return 1. * m.sumMat(mat) / (row * col);
};

m.meanMatAxis = function(mat,axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i<row; i++)
            result.push(m.meanVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.meanMatAxis(mat_T,1);
    }
};

m.squareVec = function(vec) {
    var squareVec = [];
    var i;
    for(i=0;i<vec.length;i++) {
        squareVec.push(vec[i]*vec[i]);
    }
    return squareVec;
};

m.squareMat = function(mat) {
    var squareMat = [];
    var i;
    for(i=0;i<mat.length;i++) {
        squareMat.push(m.squareVec(mat[i]));
    }
    return squareMat;
};

m.minVec = function(vec) {
    var min = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] < min)
            min = vec[i];
    }
    return min;
};

m.maxVec = function(vec) {
    var max = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] > max)
            max = vec[i];
    }
    return max;
}

m.minMat = function(mat) {
    var min = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++) {
            if(mat[i][j] < min)
                min = mat[i][j];
        }
    }
    return min;
};

m.maxMat = function(mat) {
    var max = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j<mat[0].length;j++) {
            if(mat[i][j] < max)
                max = mat[i][j];
        }
    }
    return max;
};

m.zeroVec = function(n) {
    var vec = [];
    while(vec.length < n)
        vec.push(0);
    return vec;
};

m.zeroMat = function(row,col) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.zeroVec(col));
    return mat;
};

m.oneVec = function(n) {
    var vec = [];
    while(vec.length < n)
        vec.push(1);
    return vec;
};

m.oneMat = function(row,col) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.oneVec(col));
    return mat;
};

m.randVec = function(n,lower,upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var vec = [];
    while(vec.length < n)
        vec.push(lower + (upper-lower) * Math.random());
    return vec;
};

m.randMat = function(row,col,lower,upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var mat = [];
    while(mat.length < row)
        mat.push(m.randVec(col,lower,upper));
    return mat;
};

m.randnVec = function(n,mean,sigma) {
    var vec = [];
    while(vec.length < n)
        vec.push(mean+sigma* m.randn());
    return vec;
};

m.randnMat = function(row,col,mean,sigma) {
    var mat = [];
    while(mat.length < row)
        mat.push(m.randnVec(col,mean,sigma));
    return mat;
};

m.identity = function (n) {
    var result = new Array(n);

    for (var i = 0; i < n ; i++) {
        result[i] = new Array(n);
        for (var j = 0; j < n; j++) {
            result[i][j] = (i === j) ? 1 : 0;
        }
    }

    return result;
};

m.sigmoid = function(x) {
    var sigmoid = (1. / (1 + Math.exp(-x)))
    if(sigmoid ==1) {
     //   console.warn("Something Wrong!! Sigmoid Function returns 1. Probably javascript float precision problem?\nSlightly Controlled value to 1 - 1e-14")
        sigmoid = 0.99999999999999; // Javascript Float Precision Problem.. This is a limit of javascript.
    } else if(sigmoid ==0) {
      //  console.warn("Something Wrong!! Sigmoid Function returns 0. Probably javascript float precision problem?\nSlightly Controlled value to 1e-14")
        sigmoid = 1e-14;
    }
    return sigmoid; // sigmoid cannot be 0 or 1;;
};

m.dSigmoid = function(x){
    a = m.sigmoid(x);
    return a * (1. - a);
};

m.probToBinaryMat = function(mat) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i,j;
    var result = [];

    for(i=0;i<row;i++) {
        var rowVec = [];
        for(j=0;j<col;j++) {
            if(Math.random() < mat[i][j])
                rowVec.push(1);
            else
                rowVec.push(0);
        }
        result.push(rowVec);
    }
    return result;
};

m.activateVec = function(vec,activation) {
    var i, result = [];
    for(i=0;i<vec.length;i++)
        result.push(activation(vec[i]));
    return result;
};

m.activateMat = function(mat,activation) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i, j,result = [];
    for(i=0;i<row;i++) {
        var rowVec = [];
        for(j=0;j<col;j++)
            rowVec.push(activation(mat[i][j]));
        result.push(rowVec);
    }
    return result;
};

m.activateTwoVec = function(vec1, vec2,activation) {
    if (vec1.length === vec2.length) {
        var result = new Array(vec1.length);
        for (var i = 0; i < result.length; i++) {
            result[i] = activation(vec1[i],vec2[i]);
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.activateTwoMat = function(mat1, mat2,activation) {
    if (mat1.length === mat2.length && mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x < mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < result[i].length; j++) {
                result[i][j] = activation(mat1[i][j],mat2[i][j]);
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
};

m.fillVec = function(n,value) {
    var vec = [];
    while(vec.length < n)
        vec.push(value);
    return vec;
};

m.fillMat = function(row,col,value) {
    var mat = [];
    while(mat.length < row) {
        var rowVec = [];
        while(rowVec.length < col)
            rowVec.push(value);
        mat.push(rowVec);
    }
    return mat;
};

m.softmaxVec = function(vec) {
    var max = m.maxVec(vec);
    var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})
    return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
};

m.softmaxMat = function(mat) {
    var result=[], i;
    for(i=0 ; i<mat.length ; i++)
        result.push(m.softmaxVec(mat[i]));
    return result;
};

m.randInt = function(min,max) {
  var rand = Math.random() * (max - min + 0.9999) + min
  return Math.floor(rand);
}

m.normalizeVec = function(vec) {
    var i;
    var newVec = [],tot = 0;
    for(i=0; i<vec.length; i++)
        tot += vec[i];
    for(i=0; i<vec.length;i++)
        newVec.push(1.*vec[i]/tot);
    return newVec;
};

m.euclidean = function(x1,x2) {
    var i;
    var distance = 0;
    for(i=0 ; i<x1.length; i++) {
        var dx = x1[i] - x2[i];
        distance += dx * dx;
    }
    return Math.sqrt(distance);
};

m.pearson = function(x, y)
{
    var xy = [];
    var x2 = [];
    var y2 = [];

    for(var i=0; i<x.length; i++)
    {
        xy.push(x[i] * y[i]);
        x2.push(x[i] * x[i]);
        y2.push(y[i] * y[i]);
    }

    var sum_x = 0;
    var sum_y = 0;
    var sum_xy = 0;
    var sum_x2 = 0;
    var sum_y2 = 0;

    for(var i=0; i<x.length; i++)
    {
        sum_x += x[i];
        sum_y += y[i];
        sum_xy += xy[i];
        sum_x2 += x2[i];
        sum_y2 += y2[i];
    }

    var step1 = (x.length * sum_xy) - (sum_x * sum_y);
    var step2 = (x.length * sum_x2) - (sum_x * sum_x);
    var step3 = (x.length * sum_y2) - (sum_y * sum_y);
    var step4 = Math.sqrt(step2 * step3);
    var answer = step1 / step4;

    return answer;
};

m.getNormVec = function(vec) {
    var i;
    var sqsum = 0;
    for(i=0; i<vec.length; i++)
        sqsum += vec[i] * vec[i];
    return Math.sqrt(sqsum);
}

m.gaussian = function(x, sigma) {
    sigma = sigma || 10.0;
    return Math.exp(-1.*x*x/(2*sigma*sigma));
}

m.meanVecs = function(vecs) {
    var sum = m.zeroVec(vecs[0].length);
    var i;
    for(i=0; i<vecs.length; i++)
        sum = m.addVec(sum,vecs[i]);
    return m.activateVec(sum,function(x) {return 1.*x/vecs.length;});
};

m.covarianceVecs = function(vecs) {
    var mat = m.zeroMat(vecs[0].length,vecs[0].length);
    var meanVec = m.meanVecs(vecs);
    var i;
    for(i=0; i<vecs.length; i++) {
        var a = m.minusVec(vecs[i],meanVec);
        mat = m.addMat(mat, m.mulMat(m.transpose([a]),[a]));
    }
    return m.activateMat(mat,function(x) { return 1.*x/(vecs.length-1);});
};

m.shuffle = function(arr){
    var o = [];
    for(var i=0;i<arr.length;i++)
        o.push(arr[i]); // deep copy
    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
};

m.range = function(start, end, step) {
    var ret = [];
    if(typeof step === "undefined")
        step = 1;
    if(typeof end === "undefined") {
        end = start;
        start = 0;
    }
    for(var i=start;i<end;i+=step)
        ret.push(i);
    return ret;
};

m.vec2Mat = function (vec) {
  return vec.map(function (v) { return [v] });
}
// For CRBM
/*
m.phi = function(mat,vec,low,high) {
    var i;
    var result = [];
    for(i=0;i<mat.length;i++) {
        result.push(m.activateTwoVec(mat[i],vec,function(x,y){return low+(high-low)* m.sigmoid(x*y);}))
    }
    return result;
}
*/
};
BundleModuleCode['plugins/ml/kmeans']=function (module,exports,global,process){
/**
 * Created by joonkukang on 2014. 1. 16..
 */
var math = Require('plugins/ml/math')
var Kmeans = module.exports;

Kmeans.cluster = function(options) {
    var data = options['data'];
    var k = options['k'];
    var distance = getDistanceFunction(options['distance']);
    var epochs = options['epochs'];
    var init_using_data = options['init_using_data'];
    if(typeof init_using_data === "undefined");
        init_using_data = true;
    var means = getRandomMeans(data,k, init_using_data);

    var epoch, i, j, l;
    var clusters = [];
    for(i=0 ; i<k ; i++)
        clusters.push([]);

    for(epoch=0 ; epoch<epochs ; epoch++) {
        clusters = [];
        for(i=0 ; i<k ; i++)
            clusters.push([]);

        // Find which centroid is the closest for each row
        for(i=0 ; i<data.length ; i++) {
            var bestmatch = 0;
            for(j=0 ; j<k ; j++) {
                if(distance(means[j],data[i]) < distance(means[bestmatch],data[i])) bestmatch = j;
            }
            clusters[bestmatch].push(i);
        }

        // Move the centroids to the average of their members
        for(i=0 ; i<k ; i++) {
            var avgs = [];
            for(j=0 ; j<data[0].length ; j++)
                avgs.push(0.0);
            if(clusters[i].length > 0) {
                for(j=0 ; j<clusters[i].length ; j++) {
                    for(l=0 ; l<data[0].length ; l++) {
                        avgs[l] += data[clusters[i][j]][l];
                    }
                }
                for(j=0 ; j<data[0].length ; j++) {
                    avgs[j] /= clusters[i].length;
                }
                means[i] = avgs;
            }
        }
    }
    return {
        clusters : clusters,
        means : means
    };
}

var getRandomMeans = function(data,k, init_using_data) {
    var clusters = [];
    if(init_using_data) {
        var cluster_index = math.range(data.length);
        cluster_index = math.shuffle(cluster_index);
        for(i=0 ; i<k ; i++) {
            clusters.push(data[cluster_index[i]]);
        }
    } else {
        var i,j;
        var ranges = [];
        for(i=0 ; i<data[0].length ; i++) {
            var min = data[0][i] , max = data[0][i];
            for(j=0 ; j<data.length ; j++) {
                if(data[j][i] < min) min = data[j][i];
                if(data[j][i] > max) max = data[j][i];
            }
            ranges.push([min,max]);
        }
        for(i=0 ; i<k ; i++) {
            var cluster = [];
            for(j=0 ; j<data[0].length;j++) {
                cluster.push(Math.random() * (ranges[j][1] - ranges[j][0]) + ranges[j][0]);
            }
            clusters.push(cluster);
        }
    }
    return clusters;
}


function getDistanceFunction(options) {
    if(typeof options === 'undefined') {
        return math.euclidean;
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'euclidean') {
        return math.euclidean;
    } else if (options['type'] === 'pearson') {
        return math.pearson;
    }
}
};
BundleModuleCode['plugins/ml/svm']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     joonkukang, Stefan Bosse
 **    $INITIAL:     (C) 2014, joonkukang
 **    $MODIFIED:    (C) 2006-2018 bLAB by sbosse
 **    $VERSION:     1.1.3
 **
 **    $INFO:
 **
 ** Support Vector Machine Algrotihm
 **
 ** 1. References : http://cs229.stanford.edu/materials/smo.pdf . simplified smo algorithm 
 ** 2. https://github.com/karpathy/svmjs
 ** 
 ** Portable model
 **
 **    $ENDOFINFO
 */

var math = Require('plugins/ml/math');
var Io = Require('com/io');

/**
 * type options = {x: number [] [], y: number []}
 */
var SVM = function (options) {
    var L = {};
    L.x = options.x;
    L.y = options.y;
    return L
};

SVM.code = {
  train : function (L,options) {
    var self = L;
    var C = options.C || 1.0;
    var tol = options.tol || 1e-4;
    var maxPasses = options.max_passes || 20;
    var alphatol = options.alpha_tol || 1e-5;

    L.options={kernel:options.kernel,iterations:maxPasses,alpha_tol:alphatol, C:C, tol:tol };
    self.kernel = getKernel(options.kernel);
    self.alphas = math.zeroVec(self.x.length);
    self.b = 0;
    var passes = 0, i;
    var count=0;
    while(passes < maxPasses) {
        var numChangedAlphas = 0;

        for(i=0; i<self.x.length; i++) {

            var E_i = SVM.code.f(self,self.x[i]) - self.y[i];

            if((self.y[i] * E_i < -tol && self.alphas[i] < C) || (self.y[i] * E_i > tol && self.alphas[i] >0)) {

                // Randomly selects j (i != j)
                var j = math.randInt(0,self.x.length-1);
                if(i==j) j = (j+1) % self.x.length;

                var E_j = SVM.code.f(self,self.x[j]) - self.y[j];
                var alpha_i_old = self.alphas[i], alpha_j_old = self.alphas[j];

                // Compute L,H
                var L,H;
                if(self.y[i] !== self.y[j]) {
                    L = Math.max(0, self.alphas[j] - self.alphas[i]);
                    H = Math.min(C, C + self.alphas[j] - self.alphas[i]);
                } else {
                    L = Math.max(0, self.alphas[j] + self.alphas[i] - C);
                    H = Math.min(C, self.alphas[j] + self.alphas[i]);
                }

                if(L === H)
                    continue;

                // Compute ETA
                var ETA = 2 * self.kernel(self.x[i],self.x[j]) - self.kernel(self.x[i],self.x[i]) - self.kernel(self.x[j],self.x[j]);
                if(ETA >= 0)
                    continue;

                // Clip new value to alpha_j
                self.alphas[j] -= 1.*self.y[j] * (E_i - E_j) / ETA;
                if(self.alphas[j] > H)
                    self.alphas[j] = H;
                else if(self.alphas[j] < L)
                    self.alphas[j] = L;

                if(Math.abs(self.alphas[j] - alpha_j_old) < alphatol)
                    continue;

                // Clip new value to alpha_i
                self.alphas[i] += self.y[i] * self.y[j] * (alpha_j_old - self.alphas[j]);

                // update b
                var b1 = self.b - E_i - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[i])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[i],self.x[j]);
                var b2 = self.b - E_j - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[j])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[j],self.x[j]);

                if(0 < self.alphas[i] && self.alphas[i] < C)
                    self.b = b1;
                else if(0 < self.alphas[j] && self.alphas[j] < C)
                    self.b = b2;
                else
                    self.b = (b1+b2)/2.0;

                numChangedAlphas ++ ;
            } // end-if
        } // end-for
        if(numChangedAlphas == 0)
            passes++;
        else
            passes = 0;
    }
  },
  
  predict : function(L,x) {
    var self = L;
    this.kernel = getKernel(L.options.kernel); // update kernel
    if(SVM.code.f(L,x) >= 0)
        return 1;
    else
        return -1;
  },

  f : function(L,x) {
    var self = L;
    var f = 0, j;
    for(j=0; j<self.x.length; j++)
        f += self.alphas[j] * self.y[j] * self.kernel(self.x[j],x);
    f += self.b;
    return f;
  }
}

function getKernel (options) {
    if(typeof options === 'undefined') {
        return function(x,y) {
            var sigma = 1.0;
            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
        }
    } else if (typeof options === 'function') {
        return options;
    } else if (options['type'] === 'gaussian') {
        return function(x,y) {
            var sigma = options['sigma'];
            return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
        }
    } else if (options['type'] === 'linear') {
        return function(x,y) {
            return math.dotVec(x,y);
        }
    } else if (options['type'] === 'polynomial') {
        return function(x,y) {
            var c = options['c'];
            var d = options['d'];
            return Math.pow(math.dotVec(x,y) + c, d);
        }
    } else if (options['type'] === 'rbf') {
        return function(v1, v2) {
          var s=0;
          var sigma = options.sigma||options.rbfsigma || 0.5;
          for(var q=0;q<v1.length;q++) { s += (v1[q] - v2[q])*(v1[q] - v2[q]); } 
          return Math.exp(-s/(2.0*sigma*sigma));
        }
    }
}


var SVM2 = function (options) {
    var L = {};
    L.data = options.x;
    L.labels = options.y;
    L.threshold=Io.checkOption(options.threshold,0);
    return L
};

SVM2.code = {

  // data is NxD array of floats. labels are 1 or -1.
  train: function(L, options) {
    var data = L.data,labels=L.labels;

    // parameters
    options = options || {};
    var C = options.C || 1.0; // C value. Decrease for more regularization
    var tol = options.tol || 1e-4; // numerical tolerance. Don't touch unless you're pro
    var alphatol = options.alphatol || options.alpha_tol || 1e-7; // non-support vectors for space and time efficiency are truncated. To guarantee correct result set this to 0 to do no truncating. If you want to increase efficiency, experiment with setting this little higher, up to maybe 1e-4 or so.
    var maxiter = options.maxiter || 10000; // max number of iterations
    var numpasses = options.numpasses || options.max_passes || 10; // how many passes over data with no change before we halt? Increase for more precision.

    // instantiate kernel according to options. kernel can be given as string or as a custom function
    var kernel = linearKernel;
    L.kernelType = "linear";
    L.options={kernel:options.kernel};
    if("kernel" in options) {
      if  (typeof options.kernel == 'object') {
        kernel = getKernel(options.kernel);
        L.kernelType=options.kernel.type;
        L.rbfSigma = options.kernel.sigma || options.kernel.rbfsigma;
      } else if (typeof options.kernel == 'function') {
        // assume kernel was specified as a function. Let's just use it
        L.kernelType = "custom";
        kernel = options.kernel;
      }
    }
    L.options.C=C;
    L.options.tol=tol;
    L.options.alphatol=alphatol;
    L.options.iterations=numpasses;
    
    // initializations
    L.kernel = kernel;
    L.N = data.length; var N = L.N;
    L.D = data[0].length; var D = L.D;
    L.alpha = zeros(N);
    L.b = 0.0;
    L.usew_ = false; // internal efficiency flag

    // Cache kernel computations to avoid expensive recomputation.
    // This could use too much memory if N is large.
    if (options.memoize) {
      L.kernelResults = new Array(N);
      for (var i=0;i<N;i++) {
        L.kernelResults[i] = new Array(N);
        for (var j=0;j<N;j++) {
          L.kernelResults[i][j] = kernel(data[i],data[j]);
        }
      }
    }

    // run SMO algorithm
    var iter = 0;
    var passes = 0;
    while(passes < numpasses && iter < maxiter) {

      var alphaChanged = 0;
      for(var i=0;i<N;i++) {

        var Ei= SVM2.code.marginOne(L, data[i]) - labels[i];
        if( (labels[i]*Ei < -tol && L.alpha[i] < C)
         || (labels[i]*Ei > tol && L.alpha[i] > 0) ){

          // alpha_i needs updating! Pick a j to update it with
          var j = i;
          while(j === i) j= randi(0, L.N);
          var Ej= SVM2.code.marginOne(L, data[j]) - labels[j];

          // calculate L and H bounds for j to ensure we're in [0 C]x[0 C] box
          ai= L.alpha[i];
          aj= L.alpha[j];
          var Lb = 0; var Hb = C;
          if(labels[i] === labels[j]) {
            Lb = Math.max(0, ai+aj-C);
            Hb = Math.min(C, ai+aj);
          } else {
            Lb = Math.max(0, aj-ai);
            Hb = Math.min(C, C+aj-ai);
          }

          if(Math.abs(Lb - Hb) < 1e-4) continue;

          var eta = 2*SVM2.code.kernelResult(L, i,j) - SVM2.code.kernelResult(L, i,i) - SVM2.code.kernelResult(L, j,j);
          if(eta >= 0) continue;

          // compute new alpha_j and clip it inside [0 C]x[0 C] box
          // then compute alpha_i based on it.
          var newaj = aj - labels[j]*(Ei-Ej) / eta;
          if(newaj>Hb) newaj = Hb;
          if(newaj<Lb) newaj = Lb;
          if(Math.abs(aj - newaj) < 1e-4) continue; 
          L.alpha[j] = newaj;
          var newai = ai + labels[i]*labels[j]*(aj - newaj);
          L.alpha[i] = newai;

          // update the bias term
          var b1 = L.b - Ei - labels[i]*(newai-ai)*SVM2.code.kernelResult(L, i,i)
                   - labels[j]*(newaj-aj)*SVM2.code.kernelResult(L, i,j);
          var b2 = L.b - Ej - labels[i]*(newai-ai)*SVM2.code.kernelResult(L, i,j)
                   - labels[j]*(newaj-aj)*SVM2.code.kernelResult(L, j,j);
          L.b = 0.5*(b1+b2);
          if(newai > 0 && newai < C) L.b= b1;
          if(newaj > 0 && newaj < C) L.b= b2;

          alphaChanged++;

        } // end alpha_i needed updating
      } // end for i=1..N

      iter++;
      //console.log("iter number %d, alphaChanged = %d", iter, alphaChanged);
      if(alphaChanged == 0) passes++;
      else passes= 0;

    } // end outer loop

    // if the user was using a linear kernel, lets also compute and store the
    // weights. This will speed up evaluations during testing time
    if(L.kernelType === "linear") {

      // compute weights and store them
      L.w = new Array(L.D);
      for(var j=0;j<L.D;j++) {
        var s= 0.0;
        for(var i=0;i<L.N;i++) {
          s+= L.alpha[i] * labels[i] * data[i][j];
        }
        L.w[j] = s;
        L.usew_ = true;
      }
    } else {

      // okay, we need to retain all the support vectors in the training data,
      // we can't just get away with computing the weights and throwing it out

      // But! We only need to store the support vectors for evaluation of testing
      // instances. So filter here based on L.alpha[i]. The training data
      // for which L.alpha[i] = 0 is irrelevant for future. 
      var newdata = [];
      var newlabels = [];
      var newalpha = [];
      for(var i=0;i<L.N;i++) {
        //console.log("alpha=%f", L.alpha[i]);
        if(L.alpha[i] > alphatol) {
          newdata.push(L.data[i]);
          newlabels.push(L.labels[i]);
          newalpha.push(L.alpha[i]);
        }
      }

      // store data and labels
      L.data = newdata;
      L.labels = newlabels;
      L.alpha = newalpha;
      L.N = L.data.length;
      // console.log("filtered training data from %d to %d support vectors.", data.length, L.data.length);
    }

    var trainstats = {};
    trainstats.iters= iter;
    trainstats.passes= passes;
    return trainstats;
  }, 

  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne: function(L,inst) {

    var f = L.b;
    // if the linear kernel was used and w was computed and stored,
    // (i.e. the svm has fully finished training)
    // the internal class variable usew_ will be set to true.
    if(L.usew_) {

      // we can speed this up a lot by using the computed weights
      // we computed these during train(). This is significantly faster
      // than the version below
      for(var j=0;j<L.D;j++) {
        f += inst[j] * L.w[j];
      }

    } else {

      for(var i=0;i<L.N;i++) {
        f += L.alpha[i] * L.labels[i] * L.kernel(inst, L.data[i]);
      }
    }
    return f;
  },

  predict: function(L,inst) { 
    L.kernel=getKernel(L.options.kernel); // update kernel
    var result = SVM2.code.marginOne(L,inst);
    if (L.threshold===false) return result;
    else return  result > L.threshold ? 1 : -1; 
  },

  // data is an NxD array. Returns array of margins.
  margins: function(L,data) {

    // go over support vectors and accumulate the prediction. 
    var N = data.length;
    var margins = new Array(N);
    for(var i=0;i<N;i++) {
      margins[i] = SVM2.code.marginOne(L,data[i]);
    }
    return margins;

  },

  kernelResult: function(L, i, j) {
    if (L.kernelResults) {
      return L.kernelResults[i][j];
    }
    return L.kernel(L.data[i], L.data[j]);
  },

  // data is NxD array. Returns array of 1 or -1, predictions
  predictN: function(L,data) {
    L.kernel=getKernel(L.options.kernel); // update kernel
    var margs = SVM2.code.margins(L, data);
    for(var i=0;i<margs.length;i++) {
      if (L.threshold!=false)
        margs[i] = margs[i] > L.threshold ? 1 : -1;
    }
    return margs;
  },

  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights: function(L) {

    // DEPRECATED
    var w= new Array(L.D);
    for(var j=0;j<L.D;j++) {
      var s= 0.0;
      for(var i=0;i<L.N;i++) {
        s+= L.alpha[i] * L.labels[i] * L.data[i][j];
      }
      w[j]= s;
    }
    return {w: w, b: L.b};
  },

  toJSON: function(L) {

    if(L.kernelType === "custom") {
      console.log("Can't save this SVM because it's using custom, unsupported kernel...");
      return {};
    }

    json = {}
    json.N = L.N;
    json.D = L.D;
    json.b = L.b;

    json.kernelType = L.kernelType;
    if(L.kernelType === "linear") { 
      // just back up the weights
      json.w = L.w; 
    }
    if(L.kernelType === "rbf") { 
      // we need to store the support vectors and the sigma
      json.rbfSigma = L.rbfSigma; 
      json.data = L.data;
      json.labels = L.labels;
      json.alpha = L.alpha;
    }

    return json;
  },

  fromJSON: function(L,json) {

    this.N = json.N;
    this.D = json.D;
    this.b = json.b;

    this.kernelType = json.kernelType;
    if(this.kernelType === "linear") { 

      // load the weights! 
      this.w = json.w; 
      this.usew_ = true; 
      this.kernel = linearKernel; // this shouldn't be necessary
    }
    else if(this.kernelType == "rbf") {

      // initialize the kernel
      this.rbfSigma = json.rbfSigma; 
      this.kernel = makeRbfKernel(this.rbfSigma);

      // load the support vectors
      this.data = json.data;
      this.labels = json.labels;
      this.alpha = json.alpha;
    } else {
      console.log("ERROR! unrecognized kernel type." + this.kernelType);
    }
  }
}

// Kernels
function makeRbfKernel(sigma) {
  return function(v1, v2) {
    var s=0;
    for(var q=0;q<v1.length;q++) { s += (v1[q] - v2[q])*(v1[q] - v2[q]); } 
    return Math.exp(-s/(2.0*sigma*sigma));
  }
}

function linearKernel(v1, v2) {
  var s=0; 
  for(var q=0;q<v1.length;q++) { s += v1[q] * v2[q]; } 
  return s;
}

// Misc utility functions
// generate random floating point number between a and b
function randf(a, b) {
  return Math.random()*(b-a)+a;
}

// generate random integer between a and b (b excluded)
function randi(a, b) {
   return Math.floor(Math.random()*(b-a)+a);
}

// create vector of zeros of length n
function zeros(n) {
  var arr= new Array(n);
  for(var i=0;i<n;i++) { arr[i]= 0; }
  return arr;
}

module.exports = SVM2
};
BundleModuleCode['plugins/ml/mlp']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     joonkukang, Stefan Bosse
 **    $INITIAL:     (C) 2014, joonkukang
 **    $MODIFIED:    (C) 2006-2021 bLAB by sbosse
 **    $VERSION:     1.3.5
 **
 **    $INFO:
 **
 ** Multilayer Perceptron Artificial Neural Network
 **
 ** References : http://cs229.stanford.edu/materials/smo.pdf . simplified smo algorithm 
 **
 ** Portable model
 **
 **    $ENDOFINFO
 */
/**
 */
var math = Require('plugins/ml/math');
var HiddenLayer = Require('plugins/ml/HiddenLayer');

var MLP = function (settings) {
    var L = {}
    var self = L;
    self.x = settings.input||settings.x;
    self.y = settings.output||settings.y;
    self.sigmoidLayers = [];
    self.nLayers = settings.hidden_layer_sizes.length;
    self.settings = {
        verbose : settings.verbose || 0, // 0 : nothing, 1 : info, 2: warn
        hidden_layers : settings.hidden_layer_sizes
    };
    var i;
    for(i=0 ; i<self.nLayers+1 ; i++) {
        var inputSize, layerInput;
        if(i == 0)
            inputSize = settings.n_ins;
        else
            inputSize = settings.hidden_layer_sizes[i-1];

        if(i == 0)
            layerInput = self.x||math.oneMat(1,inputSize);
        else
            layerInput = HiddenLayer.code.sampleHgivenV(self.sigmoidLayers[self.sigmoidLayers.length-1]);

        var sigmoidLayer;
        if(i == self.nLayers) {
            sigmoidLayer = HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings.n_outs,
                'activation' : math.sigmoid,
                'W' : (typeof settings.w_array === 'undefined')? undefined : settings.w_array[i],
                'b' : (typeof settings.b_array === 'undefined')? undefined : settings.b_array[i]
            });
        } else {
            sigmoidLayer = HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings.hidden_layer_sizes[i],
                'activation' : math.sigmoid,
                'W' : (typeof settings.w_array === 'undefined')? undefined : settings.w_array[i],
                'b' : (typeof settings.b_array === 'undefined')? undefined : settings.b_array[i]
            });
        }
        self.sigmoidLayers.push(sigmoidLayer);
    }
    return L
};

MLP.code = {
  train : function(L,settings,data) {
    var self = L;
    var epochs = 1000;
    if(typeof settings.epochs !== 'undefined')
        epochs = settings.epochs;
    if (typeof data != 'undefined') {
      self.x=data.x;
      self.y=data.y;
    }
    if (typeof settings.x != 'undefined') {
      self.x=settings.x;
      self.y=settings.y;
    }
    self.settings.iterations=epochs;
    
    // calculate mean square error
    function error(output,target) {
      var e=0;
      for(var i=0;i<output.length;i++) {
        for(var j=0;j<output[i].length;j++) {
          e+=Math.pow(output[i][j]-target[i][j],2);
        }
      }
      return e/target.length;
    }
    var epoch;
    var currentProgress = 1;
    for(epoch=0 ; epoch < epochs ; epoch++) {

        // Feed Forward
        var i;
        var layerInput = [];
        layerInput.push(self.x);
        for(i=0; i<self.nLayers+1 ; i++) {
            layerInput.push(HiddenLayer.code.output(self.sigmoidLayers[i],layerInput[i]));
        }
        var output = layerInput[self.nLayers+1];
        // Back Propagation
        var delta = new Array(self.nLayers + 1);
        delta[self.nLayers] = math.mulMatElementWise(math.minusMat(self.y, output),
            math.activateMat(HiddenLayer.code.linearOutput(self.sigmoidLayers[self.nLayers],layerInput[self.nLayers]), math.dSigmoid));
        if (L.settings.verbose > 2) MLP.code.log('MLP',epoch,'delta[output]: ',math.shape(delta[self.nLayers]),'=',delta[self.nLayers],error(output,self.y));
        /*
         self.nLayers = 3 (3 hidden layers)
         delta[3] : ouput layer
         delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer
         */
        for(i = self.nLayers - 1; i>=0 ; i--) {
            delta[i] = math.mulMatElementWise(HiddenLayer.code.backPropagate(self.sigmoidLayers[i+1],delta[i+1]),
                math.activateMat(HiddenLayer.code.linearOutput(self.sigmoidLayers[i],layerInput[i]), math.dSigmoid));
        }
        // Update Weight, Bias
        for(var i=0; i<self.nLayers+1 ; i++) {
            var deltaW = math.activateMat(math.mulMat(math.transpose(layerInput[i]),delta[i]),function(x){return 1. * x / self.x.length;})
            if (L.settings.verbose > 2) 
              MLP.code.log(i,math.shape(delta[i]),math.shape(deltaW),math.shape(layerInput[i]),math.shape(math.mulMat(math.transpose(layerInput[i]),delta[i])));
            var deltaB = math.meanMatAxis(delta[i],0);
            self.sigmoidLayers[i].W = math.addMat(self.sigmoidLayers[i].W,deltaW);
            self.sigmoidLayers[i].b = math.addVec(self.sigmoidLayers[i].b,deltaB);
        }

        if(self.settings.verbose > 0) {
            var progress = (1.*epoch/epochs)*100;
            if(progress > currentProgress) {
                MLP.code.log("MLP "+progress.toFixed(0)+"% Completed ("+epoch+" epochs). Mean Squared Error="+error(output,self.y));
                currentProgress+=8;
            }
        }
    }
    var ce = MLP.code.getReconstructionCrossEntropy(L);
    if(self.settings.verbose > 0)
        MLP.code.log("MLP Final Cross Entropy : ",ce);
    L.error=error(output,self.y);
    L.crossEntropy=ce;
    return {crossEntropy:ce, Error:L.error}
  },
  getReconstructionCrossEntropy : function(L) {
    var self = L;
    var reconstructedOutput = MLP.code.predict(L, self.x);
    var a = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return x*Math.log(Math.max(1E-6,y));
    });
    var b = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return (1-x)*Math.log(1-Math.min(0.9999999999,y));
    });

    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy
  },
  predict : function(L,x) {
    var self = L;
    var output = x;
    for(i=0; i<self.nLayers+1 ; i++) {
        output = HiddenLayer.code.output(self.sigmoidLayers[i],output);
    }
    return output;
  },
  set : function(L,property,value) {
    var self = L;
    self.settings[property] = value;
  },
  log : function () {
    console.log.bind(console).apply(this,arguments)
  },
  version : '1.3.5',
}
module.exports = MLP
};
BundleModuleCode['plugins/ml/HiddenLayer']=function (module,exports,global,process){
/**
 * Created by joonkukang on 2014. 1. 12..
 */
var math = Require('plugins/ml/math');
var HiddenLayer = module.exports = function (settings) {
    var L = {}
    var self = L;
    self.input = settings['input'];

    if(typeof settings['W'] === 'undefined') {
        var a = 1. / settings['n_in'];
        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);
    }
    if(typeof settings['b'] === 'undefined')
        settings['b'] = math.zeroVec(settings['n_out']);
    if(typeof settings['activation'] === 'undefined')
        settings['activation'] = math.sigmoid;

    self.W = settings['W'];
    self.b = settings['b'];
    self.activation = settings['activation'];
    return L;
}

HiddenLayer.code = {
  output : function(L,input) {
    var self = L;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return math.activateMat(linearOutput,self.activation);
  },
  linearOutput : function(L,input) { // returns the value before activation.
    var self = L;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return linearOutput;
  },
  backPropagate : function (L,input) { // example+num * n_out matrix
    var self = L;
    if(typeof input === 'undefined')
        throw new Error("No BackPropagation Input.")

    var linearOutput = math.mulMat(input, math.transpose(self.W));
    return linearOutput;
  },
  sampleHgivenV : function(L,input) {
    var self = L;
    if(typeof input !== 'undefined')
        self.input = input;

    var hMean = HiddenLayer.code.output(self);
    var hSample = math.probToBinaryMat(hMean);
    return hSample;
  }
}
};
BundleModuleCode['plugins/ml/id3']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2014, Ankit Kuwadekar
 **    $MODIFIED:    (C) 2006-2018 bLAB by sbosse
 **    $VERSION:     1.3.1X
 **
 **    $INFO:
 **
 ** ID3 Decision Tree Algorithm supporting categorical values only
 ** Portable model
 **
 ** New
 **   predict with nn selection
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;


/**
 * Map of valid tree node types
 * @constant
 * @static
 */
var NODE_TYPES = {
  RESULT: 'result',
  FEATURE: 'feature',
  FEATURE_VALUE: 'feature_value'
};

function isEqual(a,b) { return a==b }

/**
 * Predicts class for sample
 */
function predict(model,sample) {
  var root = model;
  while (root.type !== NODE_TYPES.RESULT) {
    var attr = root.name;
    var sampleVal = sample[attr];
    var childNode = Comp.array.min(root.vals, function(node) {
      if (typeof node.value == 'number' && typeof sampleVal == 'number')  
        return Math.pow(node.value - sampleVal,2);
      else
        return node.value == sampleVal? 0:1;
    });
    if (childNode){
      root = childNode.child;
    } else {
      root = root.vals[0].child;
    }
  }
  return root.value;
};

/**
 * Evalutes prediction accuracy on samples
 */
function evaluate(model,target,samples) {
   var total = 0;
   var correct = 0;

   Comp.array.iter(samples, function(s) {
     total++;
     var pred = predict(model,s);
     var actual = s[target];
     if (isEqual(pred,actual)) {
       correct++;
     }
   });
   return correct / total;
};

/**
 * Creates a new tree
 */
function createTree(data, target, features) {
  var targets = Comp.array.unique(Comp.array.pluck(data, target));
  
  if (targets.length == 1) {
    return {
      type:   NODE_TYPES.RESULT,
      value:  targets[0],
      name:   targets[0],
      // alias: targets[0] + randomUUID()
    };
  }

  if (features.length == 0) {
    var topTarget = mostCommon(targets);
    return {
      type:   NODE_TYPES.RESULT,
      value:  topTarget,
      name:   topTarget,
      // alias: topTarget + randomUUID()
    };
  }

  var bestFeature = maxGain(data, target, features);
  var remainingFeatures = Comp.array.without(features, bestFeature);
  var possibleValues = Comp.array.unique(Comp.array.pluck(data, bestFeature));

  var node = {
    name: bestFeature,
    // alias: bestFeature + randomUUID()
  };

  node.type = NODE_TYPES.FEATURE;
  node.vals = Comp.array.map(possibleValues, function(v) {
    var _newS = data.filter(function(x) {
      return x[bestFeature] == v
    });

    var child_node = {
      value: v,
      // alias: v + randomUUID(),
      type: NODE_TYPES.FEATURE_VALUE
    };

    child_node.child = createTree(_newS, target, remainingFeatures);
    return child_node;
  });

  return node;
}

/**
 * Computes Max gain across features to determine best split
 * @private
 */
function maxGain(data, target, features) {
  var gains=[];
  var maxgain= Comp.array.max(features, function(element) {
    var g = gain(data, target, element);
    gains.push(element+':'+g);
    return g;
  });
  return maxgain;
}

/**
 * Computes entropy of a list
 * @private
 */
function entropy(vals) {
  var uniqueVals = Comp.array.unique(vals);
  var probs = uniqueVals.map(function(x) {
    return prob(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(function(a, b) {
    return a + b
  }, 0);
}

/**
 * Computes gain
 * @private
 */
function gain(data, target, feature) {
  var attrVals = Comp.array.unique(Comp.array.pluck(data, feature));
  var setEntropy = entropy(Comp.array.pluck(data, target));
  var setSize = data.length;

  var entropies = attrVals.map(function(n) {
    var subset = data.filter(function(x) {
      return x[feature] === n
    });

    return (subset.length / setSize) * entropy(Comp.array.pluck(subset, target));
  });

  // var entropyData = entropyV(Comp.array.pluck(data, feature),eps);
  // console.log('Feat '+feature+':'+entropyData);
  var sumOfEntropies = entropies.reduce(function(a, b) {
    return a + b
  }, 0);
  return setEntropy - sumOfEntropies;
}

/**
 * Computes probability of of a given value existing in a given list
 * @private
 */
function prob(value, list) {
  var occurrences = Comp.array.filter(list, function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

/**
 * Computes Log with base-2
 * @private
 */
function log2(n) {
  return Math.log(n) / Math.log(2);
}

/**
 * Finds element with highest occurrence in a list
 * @private
 */
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;

  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}

/**
 * Generates random UUID
 * @private
 */
function randomUUID() {
  return "_r" + Math.random().toString(32).slice(2);
}

function depth(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return 1;
    case NODE_TYPES.FEATURE: 
      return 1+Comp.array.max(model.vals.map(function (val) {
        return depth(val);
      }));
    case NODE_TYPES.FEATURE_VALUE: 
      return 1+depth(model.child);   
  }
  return 0;
}


function info(model) {
  var vl = vars(model);
  return {
    depth:depth(model),
    nodes:vl.length,
    vars:vl.unique(),
  }
}


function print(model,indent) {
  var NL = '\n',
      line='',sep,
      sp = function () {return Comp.string.create(indent);};
  if (indent==undefined) indent=0;
  switch (model.type) {
    case NODE_TYPES.RESULT: 
      return ' -> '+model.name;
    case NODE_TYPES.FEATURE:
      line=NL+sp()+'($'+model.name+'?'+NL;
      sep='';
      Comp.array.iter(model.vals,function (v) {
        line += sep+print(v,indent+2)+NL;
        sep='';
      }); 
      return line+sp()+')';
    case NODE_TYPES.FEATURE_VALUE: 
      return sp()+model.value+':'+print(model.child,indent+2);   
  }
  return 0;
}

function vars(model) {
  switch (model.type) {
    case NODE_TYPES.RESULT: return [];
    case NODE_TYPES.FEATURE: 
      return [model.name].concat(Comp.array.flatten(model.vals.map(vars)));
    case NODE_TYPES.FEATURE_VALUE: 
      return vars(model.child);   
  }
  return [];
}

module.exports =  {
  NODE_TYPES:NODE_TYPES,
  createTree:createTree,
  depth:depth,
  entropy:entropy,
  evaluate:evaluate,
  info:info,
  predict:predict,
  print:print,
  current:function (module) { current=module.current; Aios=module;}
};

};
BundleModuleCode['plugins/ml/C45']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     ?, Stefan Bosse
 **    $INITIAL:     (C) ?
 **    $MODIFIED:    (C) 2006-2020 bLAB by sbosse
 **    $VERSION:     1.1.8X
 **
 **    $INFO:
 **
 ** C45 Decision Tree ML Algorithm
 **
 ** Portable model
 **
 **    $ENDOFINFO
 */
'use strict';
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;

var NODE_TYPES = {
  RESULT: 'result',
  FEATURE_NUMBER: 'feature_number',     // Number value node (cut split)
  FEATURE_VALUE: 'feature_value',       // Category value
  FEATURE_CATEGORY: 'feature_category'  // Symbolic variable node (split)
};

function unique(col) {
  var u = {}, a = [];
  for(var i = 0, l = col.length; i < l; ++i){
    if(u.hasOwnProperty(col[i])) {
      continue;
    }
    a.push(col[i]);
    u[col[i]] = 1;
  }
  return a;
}

function find(col, pred) {
  var value;
  col.forEach(function(item) {
    var result = pred(item);
    if (result) {
      value = item;
    }
  });
  return value;
}

function max(array, fn) {
  var max = -Infinity;
  var index;
  for (var i = 0; i < array.length; i++) {
    var result = fn(array[i]);
    if (result >= max) {
      max = result;
      index = i;
    }
  }
  return typeof index !== 'undefined' ? array[index] : max;
}

function sortBy(col, fn) {
 col = [].slice.call(col);
 return col.sort(fn);
}

var C45 = {
  create: function () {
    return {
      features : [],
      targets: [],
      model: null
    }
  },
  /**
   * train
   *
   * @param {object} options
   * @param {array} options.data - training data
   * @param {string} options.target - class label
   * @param {array} options.features - features names
   * @param {array} options.featureTypes - features type (ie 'category', 'number')
   */
  train: function(model,options) {
    var data = options.data,
        target = options.target,
        features = options.features,
        featureTypes = options.featureTypes;
    featureTypes.forEach(function(f) {
      if (['number','category'].indexOf(f) === -1) {
        throw new Error('C4.5: Unrecognized option!');
      }
    });

    var targets = unique(data.map(function(d) {
      return d[d.length-1];
    }));
    
    model.features = features;
    model.targets = targets;
    // model is the generated tree structure
    model.model = C45._c45(model, data, target, features, featureTypes, 0);
  },

  _c45: function(model, data, target, features, featureTypes, depth) {
    var targets = unique(data.map(function(d) {
      return d[d.length-1];
    }));

    if (!targets.length) {
      // console.log(data,features,featureTypes,depth);
      return {
        type: 'result',
        value: '?',
        name: '?'
      };
    }

    if (targets.length === 1) {
      return {
        type: 'result',
        value: targets[0],
        name: targets[0]
      };
    }

    if (!features.length) {
      var topTarget = C45.mostCommon(targets);
      return {
        type: 'result',
        value: topTarget,
        name: topTarget
      };
    }

    var bestFeatureData = C45.maxGain(model, data, target, features, featureTypes);
    var bestFeature = bestFeatureData.feature;

    var remainingFeatures = features.slice(0);
    remainingFeatures.splice(features.indexOf(bestFeature), 1);

    if (featureTypes[model.features.indexOf(bestFeature)] === 'category') {
      var possibleValues = unique(data.map(function(d) {
        return d[model.features.indexOf(bestFeature)];
      }));
      var node = {
        name: bestFeature,
        type: 'feature_category',
        values: possibleValues.map(function(v) {
          var newData = data.filter(function(x) {
            return x[model.features.indexOf(bestFeature)] === v;
          });
          var childNode = {
            name: v,
            type: 'feature_value',
            child: C45._c45(model, newData, target, remainingFeatures, featureTypes, depth+1)
          };
          return childNode;
        })
      };
    } else if (featureTypes[model.features.indexOf(bestFeature)] === 'number') {
      var possibleValues = unique(data.map(function(d) {
        return d[model.features.indexOf(bestFeature)];
      }));
      var node = {
        name: bestFeature,
        type: 'feature_number',
        cut: bestFeatureData.cut,
        values: []
      };

      var newDataRight = data.filter(function(x) {
        return parseFloat(x[model.features.indexOf(bestFeature)]) > bestFeatureData.cut;
      });
      var childNodeRight = {
        name: bestFeatureData.cut.toString(),
        type: 'feature_value',
        child: C45._c45(model, newDataRight, target, remainingFeatures, featureTypes, depth+1)
      };
      node.values.push(childNodeRight);

      var newDataLeft = data.filter(function(x) {
        return parseFloat(x[model.features.indexOf(bestFeature)]) <= bestFeatureData.cut;
      });
      var childNodeLeft = {
        name: bestFeatureData.cut.toString(),
        type: 'feature_value',
        child: C45._c45(model, newDataLeft, target, remainingFeatures, featureTypes, depth+1),
      };
      node.values.push(childNodeLeft);
    }
    return node;
  },


  classify: function (model,sample) {
    // root is feature (attribute) containing all sub values
    var childNode, featureName, sampleVal;
    var root = model.model;

    if (typeof root === 'undefined') {
      callback(new Error('model is undefined'));
    }

    while (root.type != NODE_TYPES.RESULT) {

      if (root.type == NODE_TYPES.FEATURE_NUMBER) {
        // feature number attribute
        featureName = root.name;
        sampleVal = parseFloat(sample[featureName]);
        if (sampleVal <= root.cut) {
          childNode = root.values[1];
        } else {
          childNode = root.values[0];
        }
      } else if (root.type == NODE_TYPES.FEATURE_CATEGORY) {
        // feature category attribute
        featureName = root.name;
        sampleVal = sample[featureName];

        // sub value , containing n childs
        childNode = find(root.values, function(x) {
          return x.name === sampleVal;
        });
      }

      // non trained feature
      if (typeof childNode === 'undefined') {
        return 'unknown';
      }
      root = childNode.child;
    }
    return root.value;
  },

  conditionalEntropy: function(model, data, feature, cut, target) {
    var subset1 = data.filter(function(x) {
      return parseFloat(x[model.features.indexOf(feature)]) <= cut;
    });
    var subset2 = data.filter(function(x) {
      return parseFloat(x[model.features.indexOf(feature)]) > cut;
    });
    var setSize = data.length;
    return subset1.length/setSize * C45.entropy(model,
      subset1.map(function(d) {
        return d[d.length-1];
      })
    ) + subset2.length/setSize*C45.entropy(model,
      subset2.map(function(d) {
        return d[d.length-1];
      })
    );
  },

  count: function(target, targets) {
    return targets.filter(function(t) {
      return t === target;
    }).length;
  },

  depth : function (model) {
    switch (model.type) {
      case NODE_TYPES.RESULT: 
        return 1;
      case NODE_TYPES.FEATURE_NUMBER:
      case NODE_TYPES.FEATURE_CATEGORY:
        return 1+Comp.array.max(model.values.map(function (v) {
          return C45.depth(v)
        })); 
      case NODE_TYPES.FEATURE_VALUE:
        return 1+C45.depth(model.child);
    }
    return 0; 
  },
  
  entropy: function(model, vals) {
    var uniqueVals = unique(vals);
    var probs = uniqueVals.map(function(x) {
      return C45.prob(x, vals);
    });
    var logVals = probs.map(function(p) {
      return -p * C45.log2(p);
    });
    return logVals.reduce(function(a, b) {
      return a + b;
    }, 0);
  },

  gain: function(model, data, target, features, feature, featureTypes) {
    var setEntropy = C45.entropy(model, data.map(function(d) {
      return d[d.length-1];
    }));
    if (featureTypes[model.features.indexOf(feature)] === 'category') {
      var attrVals = unique(data.map(function(d) {
        return d[model.features.indexOf(feature)];
      }));
      var setSize = data.length;
      var entropies = attrVals.map(function(n) {
        var subset = data.filter(function(x) {
          return x[feature] === n;
        });
        return (subset.length/setSize) * C45.entropy(model,
          subset.map(function(d) {
            return d[d.length-1];
          })
        );
      });
      var sumOfEntropies = entropies.reduce(function(a, b) {
        return a + b;
      }, 0);
      return {
        feature: feature,
        gain: setEntropy - sumOfEntropies,
        cut: 0
      };
    } else if (featureTypes[model.features.indexOf(feature)] === 'number') {
      var attrVals = unique(data.map(function(d) {
        return d[model.features.indexOf(feature)];
      }));
      var gainVals = attrVals.map(function(cut) {
        var cutf = parseFloat(cut);
        var gain = setEntropy - C45.conditionalEntropy(model, data, feature, cutf, target);
        return {
            feature: feature,
            gain: gain,
            cut: cutf
        };
      });
      var maxgain = max(gainVals, function(e) {
        return e.gain;
      });
      return maxgain;
    }
  },
  
  info : function (model) {
    var vl = C45.vars(model);
    return {
      depth:C45.depth(model),
      nodes:vl.length,
      vars:vl.unique(),
    }
  },

  
  log2: function(n) {
    return Math.log(n) / Math.log(2);
  },
  
  maxGain: function(model, data, target, features, featureTypes) {
    var g45 = features.map(function(feature) {
      return C45.gain(model, data, target, features, feature, featureTypes);
    });
    return max(g45, function(e) {
      return e.gain;
    });
  },


  mostCommon: function(targets) {
    return sortBy(targets, function(target) {
      return C45.count(target, targets);
    }).reverse()[0];
  },

  /** Print the tree
  *
  */
  print: function (model,indent) {
    var NL = '\n',
        line='',sep;
    if (indent==undefined) indent=0;
    if (!model) return '';
    var sp = function () {return Comp.string.create(indent);};
    switch (model.type) {
      case NODE_TYPES.RESULT: 
        return sp()+'-> '+model.name+NL;
      case NODE_TYPES.FEATURE_CATEGORY:
        line=sp()+'$'+model.name+'?'+NL;
        Comp.array.iter(model.values,function (v) {
          line += C45.print(v,indent+2);
        }); 
        return line;
      case NODE_TYPES.FEATURE_NUMBER:
        line = sp()+'$'+model.name+'>'+model.cut+'?'+NL;
        if (model.values[0].type==NODE_TYPES.FEATURE_VALUE)
          line = line+C45.print(model.values[0].child,indent+2);
        else
          line = line+C45.print(model.values[0],indent+2);
        line = line+sp()+'$'+model.name+'<='+model.cut+'?'+NL;
        if (model.values[0].type==NODE_TYPES.FEATURE_VALUE)
          line = line+C45.print(model.values[1].child,indent+2);
        else
          line = line+C45.print(model.values[1],indent+2);
        return line;
      case NODE_TYPES.FEATURE_VALUE:
        line=sp()+''+model.name+NL;
        line += C45.print(model.child,indent+2);
        return line;
    }
    return 'model?';
  },

  prob: function(target, targets) {
    return C45.count(target,targets)/targets.length;
  },

  vars : function (model) {
    switch (model.type) {
      case NODE_TYPES.RESULT: return [];
      case NODE_TYPES.FEATURE_NUMBER: 
      case NODE_TYPES.FEATURE_CATEGORY: 
        return [model.name].concat(Comp.array.flatten(model.values.map(C45.vars)));
      case NODE_TYPES.FEATURE_VALUE: 
        return C45.vars(model.child);   
    }
    return [];
  },

};

module.exports = {
  classify: C45.classify,
  create:   C45.create,
  depth:    function (model) { return C45.depth(model.model) },
  entropy:  C45.entropy,
  info:     function (model) { return C45.info(model.model) },
  log2:     C45.log2,
  print:    function (model,indent) { return C45.print(model.model,indent) },
  unique:   unique,
  train:    C45.train,
  current:  function (module) { current=module.current; Aios=module;}  
}
};
BundleModuleCode['plugins/ml/text']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 BSSLAB
 **    $CREATED:     5-3-19 by sbosse.
 **    $VERSION:     1.1.1X
 **
 **    $INFO:
 **
 **  JavaScript AIOS Machine Learning API: Text analysis
 **
 ** Portable model
 **
 **    $ENDOFINFO
 */
'use strict';
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;

function similarity(s1, s2) {
  var longer = s1;
  var shorter = s2;
  if (s1.length < s2.length) {
    longer = s2;
    shorter = s1;
  }
  var longerLength = longer.length;
  if (longerLength == 0) {
    return 1.0;
  }
  return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
}
function editDistance(s1, s2) {
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();

  var costs = new Array();
  for (var i = 0; i <= s1.length; i++) {
    var lastValue = i;
    for (var j = 0; j <= s2.length; j++) {
      if (i == 0)
        costs[j] = j;
      else {
        if (j > 0) {
          var newValue = costs[j - 1];
          if (s1.charAt(i - 1) != s2.charAt(j - 1))
            newValue = Math.min(Math.min(newValue, lastValue),
              costs[j]) + 1;
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
    }
    if (i > 0)
      costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}


// Create a model
function create(strings,options) {
  return {
    data:strings
  }
}

// Classify one sample; return best matching string
function classify(model,sample) {
  var matches = model.data.map(function (h) {
    return {
      match:similarity(h,sample),
      string:h
    }
  }).sort(function (a,b) {
    if (a.match < b.match) return 1; else return -1;
  });
  return matches[0];
}

module.exports = {
  classify:classify,
  create:create,
  similarity:similarity,
  current:function (module) { current=module.current; Aios=module;}  
}
};
BundleModuleCode['plugins/ml/rf']=function (module,exports,global,process){
// MIT License
// Random Forest Trees (only binary classifier)
// Andrej Karpathy
// @blab+ 
// https://github.com/karpathy/forestjs


var RandomForest = function(options) {
  var L = {};
  return L
}

RandomForest.code = {

  /*
  data is 2D array of size N x D of examples
  labels is a 1D array of labels (only -1 or 1 for now). In future will support multiclass or maybe even regression
  options.numTrees can be used to customize number of trees to train (default = 100)
  options.maxDepth is the maximum depth of each tree in the forest (default = 4)
  options.numTries is the number of random hypotheses generated at each node during training (default = 10)
  options.trainFun is a function with signature "function myWeakTrain(data, labels, ix, options)". Here, ix is a list of 
                   indeces into data of the instances that should be payed attention to. Everything not in the list 
                   should be ignored. This is done for efficiency. The function should return a model where you store 
                   variables. (i.e. model = {}; model.myvar = 5;) This will be passed to testFun.
  options.testFun is a function with signature "funtion myWeakTest(inst, model)" where inst is 1D array specifying an example,
                   and model will be the same model that you return in options.trainFun. For example, model.myvar will be 5.
                   see decisionStumpTrain() and decisionStumpTest() downstairs for example.
  */
  train: function(L, data, labels, options) {
    options = options || {};
    L.options = options;
    
    L.numTrees = options.numTrees || 100;

    // initialize many trees and train them all independently
    L.trees= new Array(L.numTrees);
    for(var i=0;i<L.numTrees;i++) {
      L.trees[i] = DecisionTree();
      DecisionTree.code.train(L.trees[i],data, labels, options);
    }
  },

  /*
  inst is a 1D array of length D of an example. 
  returns the probability of label 1, i.e. a number in range [0, 1]
  */
  predictOne: function(L, inst) {

    // have each tree predict and average out all votes
    var dec=0;
    for(var i=0;i<L.numTrees;i++) {
      dec += DecisionTree.code.predictOne(L.trees[i],inst);
    }
    dec /= L.numTrees;
    return dec;
  },

  // convenience function. Here, data is NxD array. 
  // returns probabilities of being 1 for all data in an array.
  predict: function(L, data) {

    var probabilities= new Array(data.length);
    for(var i=0;i<data.length;i++) {
      probabilities[i]= RandomForest.code.predictOne(L,data[i]);
    }
    return probabilities;

  }

}

// represents a single decision tree
var DecisionTree = function(options) {
  var L = {};
  return L
}

DecisionTree.code = {

  train: function(L, data, labels, options) {

    options = options || {};
    var maxDepth = options.maxDepth || 4;
    var weakType = options.type || 0;

    
    var trainFun= decisionStumpTrain;
    var testFun= decisionStumpTest;

    if(options.trainFun) trainFun = options.trainFun;
    if(options.testFun) testFun = options.testFun;

    if(weakType == 0) {
      // Default
      trainFun  = decisionStumpTrain;
      testFun   = decisionStumpTest;
    }
    if(weakType) {
      trainFun  = decision2DStumpTrain;
      L.testFun = testFun = decision2DStumpTest;
    }

    // initialize various helper variables
    var numInternals= Math.pow(2, maxDepth)-1;
    var numNodes= Math.pow(2, maxDepth + 1)-1;
    var ixs= new Array(numNodes);
    for(var i=1;i<ixs.length;i++) ixs[i]=[];
    ixs[0]= new Array(labels.length);
    for(var i=0;i<labels.length;i++) ixs[0][i]= i; // root node starts out with all nodes as relevant
    var models = new Array(numInternals);

    // train
    for(var n=0; n < numInternals; n++) {

      // few base cases
      var ixhere= ixs[n];
      if(ixhere.length == 0) { continue; }
      if(ixhere.length == 1) { ixs[n*2+1] = [ixhere[0]]; continue; } // arbitrary send it down left

      // learn a weak model on relevant data for this node
      var model= trainFun(data, labels, ixhere);
      models[n]= model; // back it up model

      // split the data according to the learned model
      var ixleft=[];
      var ixright=[];
      for(var i=0; i<ixhere.length;i++) {
          var label= testFun(data[ixhere[i]], model);
          if(label === 1) ixleft.push(ixhere[i]);
          else ixright.push(ixhere[i]);
      }
      ixs[n*2+1]= ixleft;
      ixs[n*2+2]= ixright;
    }

    // compute data distributions at the leafs
    var leafPositives = new Array(numNodes);
    var leafNegatives = new Array(numNodes);
    for(var n=numInternals; n < numNodes; n++) {
      var numones= 0;
      for(var i=0;i<ixs[n].length;i++) {
          if(labels[ixs[n][i]] === 1) numones+=1;
      }
      leafPositives[n]= numones;
      leafNegatives[n]= ixs[n].length-numones;
    }

    // back up important prediction variables for predicting later
    L.models= models;
    L.leafPositives = leafPositives;
    L.leafNegatives = leafNegatives;
    L.maxDepth= maxDepth;
    // L.trainFun= trainFun;
    // L.testFun= testFun;
  }, 

  // returns probability that example inst is 1.
  predictOne: function(L, inst) { 
      var testFun = L.testFun||decisionStumpTest;
      var n=0;
      for(var i=0;i<L.maxDepth;i++) {
          var dir= testFun(inst, L.models[n]);
          if(dir === 1) n= n*2+1; // descend left
          else n= n*2+2; // descend right
      }

      return (L.leafPositives[n] + 0.5) / (L.leafNegatives[n] + 1.0); // bayesian smoothing!
  }
}

// returns model
function decisionStumpTrain(data, labels, ix, options) {

  options = options || {};
  var numtries = options.numTries || 10;

  // choose a dimension at random and pick a best split
  var ri= randi(0, data[0].length);
  var N= ix.length;

  // evaluate class entropy of incoming data
  var H= entropy(labels, ix);
  var bestGain=0; 
  var bestThr= 0;
  for(var i=0;i<numtries;i++) {

      // pick a random splitting threshold
      var ix1= ix[randi(0, N)];
      var ix2= ix[randi(0, N)];
      while(ix2==ix1) ix2= ix[randi(0, N)]; // enforce distinctness of ix2

      var a= Math.random();
      var thr= data[ix1][ri]*a + data[ix2][ri]*(1-a);

      // measure information gain we'd get from split with thr
      var l1=1, r1=1, lm1=1, rm1=1; //counts for Left and label 1, right and label 1, left and minus 1, right and minus 1
      for(var j=0;j<ix.length;j++) {
          if(data[ix[j]][ri] < thr) {
            if(labels[ix[j]]==1) l1++;
            else lm1++;
          } else {
            if(labels[ix[j]]==1) r1++;
            else rm1++;
          }
      }
      var t= l1+lm1;  // normalize the counts to obtain probability estimates
      l1=l1/t;
      lm1=lm1/t;
      t= r1+rm1;
      r1=r1/t;
      rm1= rm1/t;

      var LH= -l1*Math.log(l1) -lm1*Math.log(lm1); // left and right entropy
      var RH= -r1*Math.log(r1) -rm1*Math.log(rm1);

      var informationGain= H - LH - RH;
      //console.log("Considering split %f, entropy %f -> %f, %f. Gain %f", thr, H, LH, RH, informationGain);
      if(informationGain > bestGain || i === 0) {
          bestGain= informationGain;
          bestThr= thr;
      }
  }

  model= {};
  model.thr= bestThr;
  model.ri= ri;
  return model;
}

// returns a decision for a single data instance
function decisionStumpTest(inst, model) {
  if(!model) {
      // this is a leaf that never received any data... 
      return 1;
  }
  return inst[model.ri] < model.thr ? 1 : -1;

}

// returns model. Code duplication with decisionStumpTrain :(
function decision2DStumpTrain(data, labels, ix, options) {

  options = options || {};
  var numtries = options.numTries || 10;

  // choose a dimension at random and pick a best split
  var N= ix.length;

  var ri1= 0;
  var ri2= 1;
  if(data[0].length > 2) {
    // more than 2D data. Pick 2 random dimensions
    ri1= randi(0, data[0].length);
    ri2= randi(0, data[0].length);
    while(ri2 == ri1) ri2= randi(0, data[0].length); // must be distinct!
  }

  // evaluate class entropy of incoming data
  var H= entropy(labels, ix);
  var bestGain=0; 
  var bestw1, bestw2, bestthr;
  var dots= new Array(ix.length);
  for(var i=0;i<numtries;i++) {

      // pick random line parameters
      var alpha= randf(0, 2*Math.PI);
      var w1= Math.cos(alpha);
      var w2= Math.sin(alpha);

      // project data on this line and get the dot products
      for(var j=0;j<ix.length;j++) {
        dots[j]= w1*data[ix[j]][ri1] + w2*data[ix[j]][ri2];
      }

      // we are in a tricky situation because data dot product distribution
      // can be skewed. So we don't want to select just randomly between
      // min and max. But we also don't want to sort as that is too expensive
      // let's pick two random points and make the threshold be somewhere between them.
      // for skewed datasets, the selected points will with relatively high likelihood
      // be in the high-desnity regions, so the thresholds will make sense
      var ix1= ix[randi(0, N)];
      var ix2= ix[randi(0, N)];
      while(ix2==ix1) ix2= ix[randi(0, N)]; // enforce distinctness of ix2
      var a= Math.random();
      var dotthr= dots[ix1]*a + dots[ix2]*(1-a);

      // measure information gain we'd get from split with thr
      var l1=1, r1=1, lm1=1, rm1=1; //counts for Left and label 1, right and label 1, left and minus 1, right and minus 1
      for(var j=0;j<ix.length;j++) {
          if(dots[j] < dotthr) {
            if(labels[ix[j]]==1) l1++;
            else lm1++;
          } else {
            if(labels[ix[j]]==1) r1++;
            else rm1++;
          }
      }
      var t= l1+lm1; 
      l1=l1/t;
      lm1=lm1/t;
      t= r1+rm1;
      r1=r1/t;
      rm1= rm1/t;

      var LH= -l1*Math.log(l1) -lm1*Math.log(lm1); // left and right entropy
      var RH= -r1*Math.log(r1) -rm1*Math.log(rm1);

      var informationGain= H - LH - RH;
      //console.log("Considering split %f, entropy %f -> %f, %f. Gain %f", thr, H, LH, RH, informationGain);
      if(informationGain > bestGain || i === 0) {
          bestGain= informationGain;
          bestw1= w1;
          bestw2= w2;
          bestthr= dotthr;
      }
  }

  model= {};
  model.w1= bestw1;
  model.w2= bestw2;
  model.dotthr= bestthr;
  return model;
}

// returns label for a single data instance
function decision2DStumpTest(inst, model) {
  if(!model) {
      // this is a leaf that never received any data... 
      return 1;
  }
  return inst[0]*model.w1 + inst[1]*model.w2 < model.dotthr ? 1 : -1;

}

// Misc utility functions
function entropy(labels, ix) {
  var N= ix.length;
  var p=0.0;
  for(var i=0;i<N;i++) {
      if(labels[ix[i]]==1) p+=1;
  }
  p=(1+p)/(N+2); // let's be bayesian about this
  q=(1+N-p)/(N+2);
  return (-p*Math.log(p) -q*Math.log(q));
}

// generate random floating point number between a and b
function randf(a, b) {
  return Math.random()*(b-a)+a;
}

// generate random integer between a and b (b excluded)
function randi(a, b) {
   return Math.floor(Math.random()*(b-a)+a);
}

module.exports = RandomForest
};
BundleModuleCode['plugins/ml/rl']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Ankit Kuwadekar, Stefan Bosse
 **    $INITIAL:     (C) 2015, Andrej Karpathy
 **    $MODIFIED:    (C) 2006-2019 bLAB by sbosse
 **    $VERSION:     1.1.2
 **
 **    $INFO:
 **
 ** Reinforcement Learning module that implements several common RL algorithms.
 ** Portable models (TDAgent/DPAgent/DQNAgent)
 **
 **    $ENDOFINFO
 */
"use strict";

var options = {
  version:'1.1.2'
}
var Io = Require('com/io')
var R = module.exports; // the Recurrent library


// Utility fun
function assert(condition, message) {
  // from http://stackoverflow.com/questions/15313418/javascript-assert
  if (!condition) {
    message = message || "Assertion failed";
    if (typeof Error !== "undefined") {
      throw new Error(message);
    }
    throw message; // Fallback
  }
}

// Random numbers utils
var return_v = false;
var v_val = 0.0;
var gaussRandom = function() {
  if(return_v) { 
    return_v = false;
    return v_val; 
  }
  var u = 2*Math.random()-1;
  var v = 2*Math.random()-1;
  var r = u*u + v*v;
  if(r == 0 || r > 1) return gaussRandom();
  var c = Math.sqrt(-2*Math.log(r)/r);
  v_val = v*c; // cache this
  return_v = true;
  return u*c;
}
var randf = function(a, b) { return Math.random()*(b-a)+a; }
var randi = function(a, b) { return Math.floor(Math.random()*(b-a)+a); }
var randn = function(mu, std){ return mu+gaussRandom()*std; }

// helper function returns array of zeros of length n
// and uses typed arrays if available
var zeros = function(n) {
  if(typeof(n)==='undefined' || isNaN(n)) { return []; }
  if(typeof ArrayBuffer === 'undefined') {
    // lacking browser support
    var arr = new Array(n);
    for(var i=0;i<n;i++) { arr[i] = 0; }
    return arr;
  } else {
    return new Float64Array(n);
  }
}

// Mat holds a matrix
var Mat = function(n,d) {
  var M = {}
  // n is number of rows d is number of columns
  M.n = n;
  M.d = d;
  M.w = zeros(n * d);
  M.dw = zeros(n * d);
  return M;
}

Mat.code = {
  get: function(M,row, col) { 
    // slow but careful accessor function
    // we want row-major order
    var ix = (M.d * row) + col;
    assert(ix >= 0 && ix < M.w.length);
    return M.w[ix];
  },
  set: function(M, row, col, v) {
    // slow but careful accessor function
    var ix = (M.d * row) + col;
    assert(ix >= 0 && ix < M.w.length);
    M.w[ix] = v; 
  },
  setFrom: function(M, arr) {
    for(var i=0,n=arr.length;i<n;i++) {
      M.w[i] = arr[i]; 
    }
  },
  setColumn: function(M, m, i) {
    for(var q=0,n=m.w.length;q<n;q++) {
      M.w[(M.d * q) + i] = m.w[q];
    }
  },
  toJSON: function(M) {
    var json = {};
    json['n'] = M.n;
    json['d'] = M.d;
    json['w'] = M.w;
    return json;
  },
  fromJSON: function(M, json) {
    M.n = json.n;
    M.d = json.d;
    M.w = zeros(M.n * M.d);
    M.dw = zeros(M.n * M.d);
    for(var i=0,n=M.n * M.d;i<n;i++) {
      M.w[i] = json.w[i]; // copy over weights
    }
  }
}

var copyMat = function(b) {
  var a = Mat(b.n, b.d);
  Mat.code.setFrom(a, b.w);
  return a;
}

var copyNet = function(net) {
  // nets are (k,v) pairs with k = string key, v = Mat()
  var new_net = {};
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      new_net[p] = copyMat(net[p]);
    }
  }
  return new_net;
}

var updateMat = function(m, alpha) {
  // updates in place
  for(var i=0,n=m.n*m.d;i<n;i++) {
    if(m.dw[i] !== 0) {
      m.w[i] += - alpha * m.dw[i];
      m.dw[i] = 0;
    }
  }
}

var updateNet = function(net, alpha) {
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      updateMat(net[p], alpha);
    }
  }
}

var netToJSON = function(net) {
  var j = {};
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      j[p] = Mat.code.toJSON(net[p]);
    }
  }
  return j;
}
var netFromJSON = function(j) {
  var net = {};
  for(var p in j) {
    if(j.hasOwnProperty(p)){
      net[p] = Mat(1,1); // not proud of this
      Mat.code.fromJSON(net[p],j[p]);
    }
  }
  return net;
}
var netZeroGrads = function(net) {
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      var mat = net[p];
      gradFillConst(mat, 0);
    }
  }
}
var netFlattenGrads = function(net) {
  var n = 0;
  for(var p in net) { 
   if(net.hasOwnProperty(p)) { 
    var mat = net[p]; n += mat.dw.length; 
  }}
  var g = Mat(n, 1);
  var ix = 0;
  for(var p in net) {
    if(net.hasOwnProperty(p)){
      var mat = net[p];
      for(var i=0,m=mat.dw.length;i<m;i++) {
        g.w[ix] = mat.dw[i];
        ix++;
      }
    }
  }
  return g;
}

// return Mat but filled with random numbers from gaussian
var RandMat = function(n,d,mu,std) {
  var m = Mat(n, d);
  fillRandn(m,mu,std);
  //fillRand(m,-std,std); // kind of :P
  return m;
}

// Mat utils
// fill matrix with random gaussian numbers
var fillRandn = function(m, mu, std) { for(var i=0,n=m.w.length;i<n;i++) { m.w[i] = randn(mu, std); } }
var fillRand = function(m, lo, hi) { for(var i=0,n=m.w.length;i<n;i++) { m.w[i] = randf(lo, hi); } }
var gradFillConst = function(m, c) { for(var i=0,n=m.dw.length;i<n;i++) { m.dw[i] = c } }



// Transformer definitions
var Graph = function(needs_backprop) {
  var G = {}
  if(typeof needs_backprop === 'undefined') { needs_backprop = true; }
  G.needs_backprop = needs_backprop;

  // this will store a list of functions that perform backprop,
  // in their forward pass order. So in backprop we will go
  // backwards and evoke each one
  G.backprop = [];
  return G
}
Graph.code = {
  backward: function(G) {
    for(var i=G.backprop.length-1;i>=0;i--) {
      G.backprop[i](); // tick!
    }
  },
  rowPluck: function(G, m, ix) {
    // pluck a row of m with index ix and return it as col vector
    assert(ix >= 0 && ix < m.n);
    var d = m.d;
    var out = Mat(d, 1);
    for(var i=0,n=d;i<n;i++){ out.w[i] = m.w[d * ix + i]; } // copy over the data

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=d;i<n;i++){ m.dw[d * ix + i] += out.dw[i]; }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  tanh: function(G, m) {
    // tanh nonlinearity
    var out = Mat(m.n, m.d);
    var n = m.w.length;
    for(var i=0;i<n;i++) { 
      out.w[i] = Math.tanh(m.w[i]);
    }

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<n;i++) {
          // grad for z = tanh(x) is (1 - z^2)
          var mwi = out.w[i];
          m.dw[i] += (1.0 - mwi * mwi) * out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  sigmoid: function(G, m) {
    // sigmoid nonlinearity
    var out = Mat(m.n, m.d);
    var n = m.w.length;
    for(var i=0;i<n;i++) { 
      out.w[i] = sig(m.w[i]);
    }

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<n;i++) {
          // grad for z = tanh(x) is (1 - z^2)
          var mwi = out.w[i];
          m.dw[i] += mwi * (1.0 - mwi) * out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  relu: function(G, m) {
    var out = Mat(m.n, m.d);
    var n = m.w.length;
    for(var i=0;i<n;i++) { 
      out.w[i] = Math.max(0, m.w[i]); // relu
    }
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<n;i++) {
          m.dw[i] += m.w[i] > 0 ? out.dw[i] : 0.0;
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  mul: function(G, m1, m2) {
    // multiply matrices m1 * m2
    assert(m1.d === m2.n, 'matmul dimensions misaligned');

    var n = m1.n;
    var d = m2.d;
    var out = Mat(n,d);
    for(var i=0;i<m1.n;i++) { // loop over rows of m1
      for(var j=0;j<m2.d;j++) { // loop over cols of m2
        var dot = 0.0;
        for(var k=0;k<m1.d;k++) { // dot product loop
          dot += m1.w[m1.d*i+k] * m2.w[m2.d*k+j];
        }
        out.w[d*i+j] = dot;
      }
    }

    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0;i<m1.n;i++) { // loop over rows of m1
          for(var j=0;j<m2.d;j++) { // loop over cols of m2
            for(var k=0;k<m1.d;k++) { // dot product loop
              var b = out.dw[d*i+j];
              m1.dw[m1.d*i+k] += m2.w[m2.d*k+j] * b;
              m2.dw[m2.d*k+j] += m1.w[m1.d*i+k] * b;
            }
          }
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  add: function(G, m1, m2) {
    assert(m1.w.length === m2.w.length);

    var out = Mat(m1.n, m1.d);
    for(var i=0,n=m1.w.length;i<n;i++) {
      out.w[i] = m1.w[i] + m2.w[i];
    }
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=m1.w.length;i<n;i++) {
          m1.dw[i] += out.dw[i];
          m2.dw[i] += out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  dot: function(G, m1, m2) {
    // m1 m2 are both column vectors
    assert(m1.w.length === m2.w.length);
    var out = Mat(1,1);
    var dot = 0.0;
    for(var i=0,n=m1.w.length;i<n;i++) {
      dot += m1.w[i] * m2.w[i];
    }
    out.w[0] = dot;
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=m1.w.length;i<n;i++) {
          m1.dw[i] += m2.w[i] * out.dw[0];
          m2.dw[i] += m1.w[i] * out.dw[0];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
  eltmul: function(G, m1, m2) {
    assert(m1.w.length === m2.w.length);

    var out = Mat(m1.n, m1.d);
    for(var i=0,n=m1.w.length;i<n;i++) {
      out.w[i] = m1.w[i] * m2.w[i];
    }
    if(G.needs_backprop) {
      var backward = function() {
        for(var i=0,n=m1.w.length;i<n;i++) {
          m1.dw[i] += m2.w[i] * out.dw[i];
          m2.dw[i] += m1.w[i] * out.dw[i];
        }
      }
      G.backprop.push(backward);
    }
    return out;
  },
}


var softmax = function(m) {
    var out = Mat(m.n, m.d); // probability volume
    var maxval = -999999;
    for(var i=0,n=m.w.length;i<n;i++) { if(m.w[i] > maxval) maxval = m.w[i]; }

    var s = 0.0;
    for(var i=0,n=m.w.length;i<n;i++) { 
      out.w[i] = Math.exp(m.w[i] - maxval);
      s += out.w[i];
    }
    for(var i=0,n=m.w.length;i<n;i++) { out.w[i] /= s; }

    // no backward pass here needed
    // since we will use the computed probabilities outside
    // to set gradients directly on m
    return out;
  }


var Solver = function() {
  var S = {}
  S.decay_rate = 0.999;
  S.smooth_eps = 1e-8;
  S.step_cache = {};
  return S
}
Solver.code = {
  step: function(S, model, step_size, regc, clipval) {
    // perform parameter update
    var solver_stats = {};
    var num_clipped = 0;
    var num_tot = 0;
    for(var k in model) {
      if(model.hasOwnProperty(k)) {
        var m = model[k]; // mat ref
        if(!(k in S.step_cache)) { S.step_cache[k] = Mat(m.n, m.d); }
        var s = S.step_cache[k];
        for(var i=0,n=m.w.length;i<n;i++) {

          // rmsprop adaptive learning rate
          var mdwi = m.dw[i];
          s.w[i] = s.w[i] * S.decay_rate + (1.0 - S.decay_rate) * mdwi * mdwi;

          // gradient clip
          if(mdwi > clipval) {
            mdwi = clipval;
            num_clipped++;
          }
          if(mdwi < -clipval) {
            mdwi = -clipval;
            num_clipped++;
          }
          num_tot++;

          // update (and regularize)
          m.w[i] += - step_size * mdwi / Math.sqrt(s.w[i] + S.smooth_eps) - regc * m.w[i];
          m.dw[i] = 0; // reset gradients for next iteration
        }
      }
    }
    solver_stats['ratio_clipped'] = num_clipped*1.0/num_tot;
    return solver_stats;
  }
}

var initLSTM = function(input_size, hidden_sizes, output_size) {
  // hidden size should be a list

  var model = {};
  for(var d=0;d<hidden_sizes.length;d++) { // loop over depths
    var prev_size = d === 0 ? input_size : hidden_sizes[d - 1];
    var hidden_size = hidden_sizes[d];

    // gates parameters
    model['Wix'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Wih'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bi'+d]   = Mat(hidden_size, 1);
    model['Wfx'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Wfh'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bf'+d]   = Mat(hidden_size, 1);
    model['Wox'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Woh'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bo'+d]   = Mat(hidden_size, 1);
    // cell write params
    model['Wcx'+d]  = RandMat(hidden_size, prev_size , 0, 0.08);  
    model['Wch'+d]  = RandMat(hidden_size, hidden_size , 0, 0.08);
    model['bc'+d]   = Mat(hidden_size, 1);
  }
  // decoder params
  model['Whd']  = RandMat(output_size, hidden_size, 0, 0.08);
  model['bd']   = Mat(output_size, 1);
  return model;
}

var forwardLSTM = function(G, model, hidden_sizes, x, prev) {
  // forward prop for a single tick of LSTM
  // G is graph to append ops to
  // model contains LSTM parameters
  // x is 1D column vector with observation
  // prev is a struct containing hidden and cell
  // from previous iteration

  if(prev == null || typeof prev.h === 'undefined') {
    var hidden_prevs = [];
    var cell_prevs = [];
    for(var d=0;d<hidden_sizes.length;d++) {
      hidden_prevs.push(R.Mat(hidden_sizes[d],1)); 
      cell_prevs.push(R.Mat(hidden_sizes[d],1)); 
    }
  } else {
    var hidden_prevs = prev.h;
    var cell_prevs = prev.c;
  }

  var hidden = [];
  var cell = [];
  for(var d=0;d<hidden_sizes.length;d++) {

    var input_vector = d === 0 ? x : hidden[d-1];
    var hidden_prev = hidden_prevs[d];
    var cell_prev = cell_prevs[d];

    // input gate
    var h0 = Graph.code.mul(G,model['Wix'+d], input_vector);
    var h1 = Graph.code.mul(G,model['Wih'+d], hidden_prev);
    var input_gate = Graph.code.sigmoid(G,Graph.code.add(G,Graph.code.add(G,h0,h1),
                                        model['bi'+d]));

    // forget gate
    var h2 = Graph.code.mul(G,model['Wfx'+d], input_vector);
    var h3 = Graph.code.mul(G,model['Wfh'+d], hidden_prev);
    var forget_gate = Graph.code.sigmoid(
                        G,Graph.code.add(G,Graph.code.add(G,h2, h3),
                        model['bf'+d]));

    // output gate
    var h4 = Graph.code.mul(G,model['Wox'+d], input_vector);
    var h5 = Graph.code.mul(G,model['Woh'+d], hidden_prev);
    var output_gate = Graph.code.sigmoid(G,Graph.code.add(G,Graph.code.add(G,h4, h5),
                                                          model['bo'+d]));

    // write operation on cells
    var h6 = Graph.code.mul(G,model['Wcx'+d], input_vector);
    var h7 = Graph.code.mul(G,model['Wch'+d], hidden_prev);
    var cell_write = Graph.code.tanh(G,Graph.code.add(
                                         G,Graph.code.add(G,h6, h7),
                                         model['bc'+d]));

    // compute new cell activation
    var retain_cell = Graph.code.eltmul(G,forget_gate, cell_prev); // what do we keep from cell
    var write_cell = Graph.code.eltmul(G,input_gate, cell_write); // what do we write to cell
    var cell_d = Graph.code.add(G,retain_cell, write_cell); // new cell contents

    // compute hidden state as gated, saturated cell activations
    var hidden_d = Graph.code.eltmul(G, output_gate, Graph.code.tanh(G,cell_d));

    hidden.push(hidden_d);
    cell.push(cell_d);
  }

  // one decoder to outputs at end
  var output = Graph.code.add(G,Graph.code.mul(G,model['Whd'], hidden[hidden.length - 1]),model['bd']);

  // return cell memory, hidden representation and output
  return {'h':hidden, 'c':cell, 'o' : output};
}

var sig = function(x) {
  // helper function for computing sigmoid
  return 1.0/(1+Math.exp(-x));
}

var maxi = function(w) {
  // argmax of array w
  var maxv = w[0];
  var maxix = 0;
  for(var i=1,n=w.length;i<n;i++) {
    var v = w[i];
    if(v > maxv) {
      maxix = i;
      maxv = v;
    }
  }
  return maxix;
}

var samplei = function(w) {
  // sample argmax from w, assuming w are 
  // probabilities that sum to one
  var r = randf(0,1);
  var x = 0.0;
  var i = 0;
  while(true) {
    x += w[i];
    if(x > r) { return i; }
    i++;
  }
  return w.length - 1; // pretty sure we should never get here?
}

// various utils
module.exports.assert = assert;
module.exports.zeros = zeros;
module.exports.maxi = maxi;
module.exports.samplei = samplei;
module.exports.randi = randi;
module.exports.randn = randn;
module.exports.softmax = softmax;
// classes
module.exports.Mat = Mat;
module.exports.RandMat = RandMat;
module.exports.forwardLSTM = forwardLSTM;
module.exports.initLSTM = initLSTM;
// more utils
module.exports.updateMat = updateMat;
module.exports.updateNet = updateNet;
module.exports.copyMat = copyMat;
module.exports.copyNet = copyNet;
module.exports.netToJSON = netToJSON;
module.exports.netFromJSON = netFromJSON;
module.exports.netZeroGrads = netZeroGrads;
module.exports.netFlattenGrads = netFlattenGrads;
// optimization
module.exports.Solver = Solver;
module.exports.Graph = Graph;

// END OF RECURRENTJS

var RL = module.exports;

// syntactic sugar function for getting default parameter values
var getopt = function(opt, field_name, default_value) {
  if(typeof opt === 'undefined') { return default_value; }
  return (typeof opt[field_name] !== 'undefined') ? opt[field_name] : default_value;
}

var zeros = R.zeros; // inherit these
var assert = R.assert;
var randi = R.randi;
var randf = R.randf;

var setConst = function(arr, c) {
  for(var i=0,n=arr.length;i<n;i++) {
    arr[i] = c;
  }
}

var sampleWeighted = function(p) {
  var r = Math.random();
  var c = 0.0;
  for(var i=0,n=p.length;i<n;i++) {
    c += p[i];
    if(c >= r) { return i; }
  }
  // assert(false, 'sampleWeighted: Invalid samples '+Io.inspect(p));
  return 0
}

// ------
// AGENTS
// ------

// DPAgent performs Value Iteration
// - can also be used for Policy Iteration if you really wanted to
// - requires model of the environment :(
// - does not learn from experience :(
// - assumes finite MDP :(
var DPAgent = function(env, opt) {
  var L={};
  L.V = null; // state value function
  L.P = null; // policy distribution \pi(s,a)
  L.env = env; // store pointer to environment
  L.gamma = getopt(opt, 'gamma', 0.75); // future reward discount factor
  DPAgent.code.reset(L);
  return L;
}
DPAgent.code = {
  reset: function(L) {
    // reset the agent's policy and value function
    L.ns = L.env.getNumStates();
    L.na = L.env.getMaxNumActions();
    L.V = zeros(L.ns);
    L.P = zeros(L.ns * L.na);
    // initialize uniform random policy
    for(var s=0;s<L.ns;s++) {
      var poss = L.env.allowedActions(s);
      for(var i=0,n=poss.length;i<n;i++) {
        L.P[poss[i]*L.ns+s] = 1.0 / poss.length;
      }
    }
  },
  act: function(L,s) {
    // behave according to the learned policy
    var poss = L.env.allowedActions(s);
    var ps = [];
    for(var i=0,n=poss.length;i<n;i++) {
      var a = poss[i];
      var prob = L.P[a*L.ns+s];
      ps.push(prob);
    }
    var maxi = sampleWeighted(ps);
    return poss[maxi];
  },
  learn: function(L) {
    // perform a single round of value iteration
    DPAgent.code.evaluatePolicy(L); // writes this.V
    DPAgent.code.updatePolicy(L); // writes this.P
  },
  evaluatePolicy: function(L) {
    // perform a synchronous update of the value function
    var Vnew = zeros(L.ns);
    for(var s=0;s<L.ns;s++) {
      // integrate over actions in a stochastic policy
      // note that we assume that policy probability mass over allowed actions sums to one
      var v = 0.0;
      var poss = L.env.allowedActions(s);
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        var prob = L.P[a*L.ns+s]; // probability of taking action under policy
        if(prob === 0) { continue; } // no contribution, skip for speed
        var ns = L.env.nextState(s,a);
        var rs = L.env.reward(s,a,ns); // reward for s->a->ns transition
        v += prob * (rs + L.gamma * L.V[ns]);
      }
      Vnew[s] = v;
    }
    L.V = Vnew; // swap
  },
  updatePolicy: function(L) {
    // update policy to be greedy w.r.t. learned Value function
    for(var s=0;s<L.ns;s++) {
      var poss = L.env.allowedActions(s);
      // compute value of taking each allowed action
      var vmax, nmax;
      var vs = [];
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        var ns = L.env.nextState(s,a);
        var rs = L.env.reward(s,a,ns);
        var v = rs + L.gamma * L.V[ns];
        vs.push(v);
        if(i === 0 || v > vmax) { vmax = v; nmax = 1; }
        else if(v === vmax) { nmax += 1; }
      }
      // update policy smoothly across all argmaxy actions
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        L.P[a*L.ns+s] = (vs[i] === vmax) ? 1.0/nmax : 0.0;
      }
    }
  },
}

// QAgent uses TD (Q-Learning, SARSA)
// - does not require environment model :)
// - learns from experience :)
var TDAgent = function(env, opt) {
  var L={}
  L.update = getopt(opt, 'update', 'qlearn'); // qlearn | sarsa
  L.gamma = getopt(opt, 'gamma', 0.75); // future reward discount factor
  L.epsilon = getopt(opt, 'epsilon', 0.1); // for epsilon-greedy policy
  L.alpha = getopt(opt, 'alpha', 0.01); // value function learning rate

  // class allows non-deterministic policy, and smoothly regressing towards the optimal policy based on Q
  L.smooth_policy_update = getopt(opt, 'smooth_policy_update', false);
  L.beta = getopt(opt, 'beta', 0.01); // learning rate for policy, if smooth updates are on

  // eligibility traces
  L.lambda = getopt(opt, 'lambda', 0); // eligibility trace decay. 0 = no eligibility traces used
  L.replacing_traces = getopt(opt, 'replacing_traces', true);

  // optional optimistic initial values
  L.q_init_val = getopt(opt, 'q_init_val', 0);

  L.planN = getopt(opt, 'planN', 0); // number of planning steps per learning iteration (0 = no planning)

  L.Q = null; // state action value function
  L.P = null; // policy distribution \pi(s,a)
  L.e = null; // eligibility trace
  L.env_model_s = null;; // environment model (s,a) -> (s',r)
  L.env_model_r = null;; // environment model (s,a) -> (s',r)
  L.env = env; // store pointer to environment
  TDAgent.code.reset(L);
  return L;
}
TDAgent.code = {
  reset: function(L){
    // reset the agent's policy and value function
    L.ns = L.env.getNumStates();
    L.na = L.env.getMaxNumActions();
    L.Q = zeros(L.ns * L.na);
    if(L.q_init_val !== 0) { setConst(L.Q, L.q_init_val); }
    L.P = zeros(L.ns * L.na);
    L.e = zeros(L.ns * L.na);

    // model/planning vars
    L.env_model_s = zeros(L.ns * L.na);
    setConst(L.env_model_s, -1); // init to -1 so we can test if we saw the state before
    L.env_model_r = zeros(L.ns * L.na);
    L.sa_seen = [];
    L.pq = zeros(L.ns * L.na);

    // initialize uniform random policy
    for(var s=0;s<L.ns;s++) {
      var poss = L.env.allowedActions(s);
      for(var i=0,n=poss.length;i<n;i++) {
        L.P[poss[i]*L.ns+s] = 1.0 / poss.length;
      }
    }
    // agent memory, needed for streaming updates
    // (s0,a0,r0,s1,a1,r1,...)
    L.r0 = null;
    L.s0 = null;
    L.s1 = null;
    L.a0 = null;
    L.a1 = null;
  },
  resetEpisode: function(L) {
    // an episode finished
  },
  act: function(L,s){
    // act according to epsilon greedy policy
    var poss = L.env.allowedActions(s);
    var probs = [];
    for(var i=0,n=poss.length;i<n;i++) {
      probs.push(L.P[poss[i]*L.ns+s]);
    }
    // epsilon greedy policy
    if(Math.random() < L.epsilon) {
      var a = poss[randi(0,poss.length)]; // random available action
      L.explored = true;
    } else {
      var a = poss[sampleWeighted(probs)];
      L.explored = false;
    }
    // shift state memory
    L.s0 = L.s1;
    L.a0 = L.a1;
    L.s1 = s;
    L.a1 = a;
    return a;
  },
  learn: function(L,r1){
    // takes reward for previous action, which came from a call to act()
    if(!(L.r0 == null)) {
      TDAgent.code.learnFromTuple(L, L.s0, L.a0, L.r0, L.s1, L.a1, L.lambda);
      if(L.planN > 0) {
        TDAgent.code.updateModel(L, L.s0, L.a0, L.r0, L.s1);
        TDAgent.code.plan(L);
      }
    }
    L.r0 = r1; // store this for next update
  },
  updateModel: function(L, s0, a0, r0, s1) {
    // transition (s0,a0) -> (r0,s1) was observed. Update environment model
    var sa = a0 * L.ns + s0;
    if(L.env_model_s[sa] === -1) {
      // first time we see this state action
      L.sa_seen.push(a0 * L.ns + s0); // add as seen state
    }
    L.env_model_s[sa] = s1;
    L.env_model_r[sa] = r0;
  },
  plan: function(L) {

    // order the states based on current priority queue information
    var spq = [];
    for(var i=0,n=L.sa_seen.length;i<n;i++) {
      var sa = L.sa_seen[i];
      var sap = L.pq[sa];
      if(sap > 1e-5) { // gain a bit of efficiency
        spq.push({sa:sa, p:sap});
      }
    }
    spq.sort(function(a,b){ return a.p < b.p ? 1 : -1});

    // perform the updates
    var nsteps = Math.min(L.planN, spq.length);
    for(var k=0;k<nsteps;k++) {
      // random exploration
      //var i = randi(0, this.sa_seen.length); // pick random prev seen state action
      //var s0a0 = this.sa_seen[i];
      var s0a0 = spq[k].sa;
      L.pq[s0a0] = 0; // erase priority, since we're backing up this state
      var s0 = s0a0 % L.ns;
      var a0 = Math.floor(s0a0 / L.ns);
      var r0 = L.env_model_r[s0a0];
      var s1 = L.env_model_s[s0a0];
      var a1 = -1; // not used for Q learning
      if(L.update === 'sarsa') {
        // generate random action?...
        var poss = L.env.allowedActions(s1);
        var a1 = poss[randi(0,poss.length)];
      }
      TDAgent.code.learnFromTuple(L, s0, a0, r0, s1, a1, 0); // note lambda = 0 - shouldnt use eligibility trace here
    }
  },
  learnFromTuple: function(L, s0, a0, r0, s1, a1, lambda) {
    var sa = a0 * L.ns + s0;

    // calculate the target for Q(s,a)
    if(L.update === 'qlearn') {
      // Q learning target is Q(s0,a0) = r0 + gamma * max_a Q[s1,a]
      var poss = L.env.allowedActions(s1);
      var qmax = 0;
      for(var i=0,n=poss.length;i<n;i++) {
        var s1a = poss[i] * L.ns + s1;
        var qval = L.Q[s1a];
        if(i === 0 || qval > qmax) { qmax = qval; }
      }
      var target = r0 + L.gamma * qmax;
    } else if(L.update === 'sarsa') {
      // SARSA target is Q(s0,a0) = r0 + gamma * Q[s1,a1]
      var s1a1 = a1 * L.ns + s1;
      var target = r0 + L.gamma * L.Q[s1a1];
    }

    if(lambda > 0) {
      // perform an eligibility trace update
      if(L.replacing_traces) {
        L.e[sa] = 1;
      } else {
        L.e[sa] += 1;
      }
      var edecay = lambda * L.gamma;
      var state_update = zeros(L.ns);
      for(var s=0;s<L.ns;s++) {
        var poss = L.env.allowedActions(s);
        for(var i=0;i<poss.length;i++) {
          var a = poss[i];
          var saloop = a * L.ns + s;
          var esa = L.e[saloop];
          var update = L.alpha * esa * (target - L.Q[saloop]);
          L.Q[saloop] += update;
          L.updatePriority(s, a, update);
          L.e[saloop] *= edecay;
          var u = Math.abs(update);
          if(u > state_update[s]) { state_update[s] = u; }
        }
      }
      for(var s=0;s<L.ns;s++) {
        if(state_update[s] > 1e-5) { // save efficiency here
          TDAgent.code.updatePolicy(L,s);
        }
      }
      if(L.explored && L.update === 'qlearn') {
        // have to wipe the trace since q learning is off-policy :(
        L.e = zeros(L.ns * L.na);
      }
    } else {
      // simpler and faster update without eligibility trace
      // update Q[sa] towards it with some step size
      var update = L.alpha * (target - L.Q[sa]);
      L.Q[sa] += update;
      TDAgent.code.updatePriority(L,s0, a0, update);
      // update the policy to reflect the change (if appropriate)
      TDAgent.code.updatePolicy(L,s0);
    }
  },
  updatePriority: function(L,s,a,u) {
    // used in planning. Invoked when Q[sa] += update
    // we should find all states that lead to (s,a) and upgrade their priority
    // of being update in the next planning step
    u = Math.abs(u);
    if(u < 1e-5) { return; } // for efficiency skip small updates
    if(L.planN === 0) { return; } // there is no planning to be done, skip.
    for(var si=0;si<L.ns;si++) {
      // note we are also iterating over impossible actions at all states,
      // but this should be okay because their env_model_s should simply be -1
      // as initialized, so they will never be predicted to point to any state
      // because they will never be observed, and hence never be added to the model
      for(var ai=0;ai<L.na;ai++) {
        var siai = ai * L.ns + si;
        if(L.env_model_s[siai] === s) {
          // this state leads to s, add it to priority queue
          L.pq[siai] += u;
        }
      }
    }
  },
  updatePolicy: function(L,s) {
    var poss = L.env.allowedActions(s);
    // set policy at s to be the action that achieves max_a Q(s,a)
    // first find the maxy Q values
    var qmax, nmax;
    var qs = [];
    for(var i=0,n=poss.length;i<n;i++) {
      var a = poss[i];
      var qval = L.Q[a*L.ns+s];
      qs.push(qval);
      if(i === 0 || qval > qmax) { qmax = qval; nmax = 1; }
      else if(qval === qmax) { nmax += 1; }
    }
    // now update the policy smoothly towards the argmaxy actions
    var psum = 0.0;
    for(var i=0,n=poss.length;i<n;i++) {
      var a = poss[i];
      var target = (qs[i] === qmax) ? 1.0/nmax : 0.0;
      var ix = a*L.ns+s;
      if(L.smooth_policy_update) {
        // slightly hacky :p
        L.P[ix] += L.beta * (target - L.P[ix]);
        psum += L.P[ix];
      } else {
        // set hard target
        L.P[ix] = target;
      }
    }
    if(L.smooth_policy_update) {
      // renomalize P if we're using smooth policy updates
      for(var i=0,n=poss.length;i<n;i++) {
        var a = poss[i];
        L.P[a*L.ns+s] /= psum;
      }
    }
  }
}


var DQNAgent = function(env, opt) {
  var L = {}
  L.gamma = getopt(opt, 'gamma', 0.75); // future reward discount factor
  L.epsilon = getopt(opt, 'epsilon', 0.1); // for epsilon-greedy policy
  L.alpha = getopt(opt, 'alpha', 0.01); // value function learning rate

  L.experience_add_every = getopt(opt, 'experience_add_every', 25); // number of time steps before we add another experience to replay memory
  L.experience_size = getopt(opt, 'experience_size', 5000); // size of experience replay
  L.learning_steps_per_iteration = getopt(opt, 'learning_steps_per_iteration', 10);
  L.tderror_clamp = getopt(opt, 'tderror_clamp', 1.0); 

  L.num_hidden_units =  getopt(opt, 'num_hidden_units', 100); 

  L.env = env;
  DQNAgent.code.reset(L);
  return L
}
DQNAgent.code = {
  reset: function(L) {
    L.nh = L.num_hidden_units; // number of hidden units
    L.ns = L.env.getNumStates();
    L.na = L.env.getMaxNumActions();

    // nets are hardcoded for now as key (str) -> Mat
    // not proud of this. better solution is to have a whole Net object
    // on top of Mats, but for now sticking with this
    L.net = {};
    L.net.W1 = R.RandMat(L.nh, L.ns, 0, 0.01);
    L.net.b1 = R.Mat(L.nh, 1, 0, 0.01);
    L.net.W2 = R.RandMat(L.na, L.nh, 0, 0.01);
    L.net.b2 = R.Mat(L.na, 1, 0, 0.01);

    L.exp = []; // experience
    L.expi = 0; // where to insert

    L.t = 0;

    L.r0 = null;
    L.s0 = null;
    L.s1 = null;
    L.a0 = null;
    L.a1 = null;

    L.tderror = 0; // for visualization only...
  },
  toJSON: function(L) {
    // save function
    var j = {};
    j.nh = L.nh;
    j.ns = L.ns;
    j.na = L.na;
    j.net = R.netToJSON(L.net);
    return j;
  },
  fromJSON: function(L,j) {
    // load function
    L.nh = j.nh;
    L.ns = j.ns;
    L.na = j.na;
    L.net = R.netFromJSON(j.net);
  },
  forwardQ: function(L, net, s, needs_backprop) {
    var G = R.Graph(needs_backprop);
    var a1mat = Graph.code.add(G,Graph.code.mul(G,net.W1, s), net.b1);
    var h1mat = Graph.code.tanh(G,a1mat);
    var a2mat = Graph.code.add(G,Graph.code.mul(G,net.W2, h1mat), net.b2);
    L.lastG = G; // back this up. Kind of hacky isn't it
    return a2mat;
  },
  act: function(L,slist) {
    // convert to a Mat column vector
    var s = R.Mat(L.ns, 1);
    Mat.code.setFrom(s,slist);

    // epsilon greedy policy
    if(Math.random() < L.epsilon) {
      var a = randi(0, L.na);
    } else {
      // greedy wrt Q function
      var amat = DQNAgent.code.forwardQ(L,L.net, s, false);
      var a = R.maxi(amat.w); // returns index of argmax action
    }

    // shift state memory
    L.s0 = L.s1;
    L.a0 = L.a1;
    L.s1 = s;
    L.a1 = a;

    return a;
  },
  learn: function(L,r1) {
    // perform an update on Q function
    if(!(L.r0 == null) && L.alpha > 0) {

      // learn from this tuple to get a sense of how "surprising" it is to the agent
      var tderror = DQNAgent.code.learnFromTuple(L, L.s0, L.a0, L.r0, L.s1, L.a1);
      L.tderror = tderror; // a measure of surprise
      // decide if we should keep this experience in the replay
      if(L.t % L.experience_add_every === 0) {
        L.exp[L.expi] = [L.s0, L.a0, L.r0, L.s1, L.a1];
        L.expi += 1;
        if(L.expi > L.experience_size) { L.expi = 0; } // roll over when we run out
      }
      L.t += 1;

      // sample some additional experience from replay memory and learn from it
      for(var k=0;k<L.learning_steps_per_iteration;k++) {
        var ri = randi(0, L.exp.length); // todo: priority sweeps?
        var e = L.exp[ri];
        DQNAgent.code.learnFromTuple(L, e[0], e[1], e[2], e[3], e[4])
      }
    }
    L.r0 = r1; // store for next update
  },
  learnFromTuple: function(L, s0, a0, r0, s1, a1) {
    // want: Q(s,a) = r + gamma * max_a' Q(s',a')

    // compute the target Q value
    var tmat = DQNAgent.code.forwardQ(L, L.net, s1, false);
    var qmax = r0 + L.gamma * tmat.w[R.maxi(tmat.w)];

    // now predict
    var pred = DQNAgent.code.forwardQ(L, L.net, s0, true);

    var tderror = pred.w[a0] - qmax;
    var clamp = L.tderror_clamp;
    if(Math.abs(tderror) > clamp) {  // huber loss to robustify
      if(tderror > clamp) tderror = clamp;
      if(tderror < -clamp) tderror = -clamp;
    }
    pred.dw[a0] = tderror;

    Graph.code.backward( L.lastG); // compute gradients on net params

    // update net
    R.updateNet(L.net, L.alpha);
    return tderror;
  }
}



// exports
module.exports.DPAgent = DPAgent;
module.exports.TDAgent = TDAgent;
module.exports.DQNAgent = DQNAgent;
//module.exports.SimpleReinforceAgent = SimpleReinforceAgent;
//module.exports.RecurrentReinforceAgent = RecurrentReinforceAgent;
//module.exports.DeterministPG = DeterministPG;


};
BundleModuleCode['plugins/ml/rt']=function (module,exports,global,process){
//     wink-regression-tree
//     Decision Tree to predict the value of a continuous
//     target variable
//
//     https://github.com/winkjs/wink-regression-tree
//
//     Copyright (C) 2017-18  GRAYPE Systems Private Limited
//
//     This file is part of “wink-regression-tree”.
//
//     Permission is hereby granted, free of charge, to any person obtaining a
//     copy of this software and associated documentation files (the "Software"),
//     to deal in the Software without restriction, including without limitation
//     and/or sell copies of the Software, and to permit persons to whom the
//     Software is furnished to do so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included
//     in all copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//     DEALINGS IN THE SOFTWARE.

/* eslint no-continue: 0 */

var helpers = Require( 'ml/helpers' );
var stdevEPSILON = Math.pow( 2, -48 );

// ### regressionTree
/**
 *
 * Creates an instance of a {@link RegressionTree}.
 *
 * @return {RegressionTree} object conatining set of API methods for tasks like configuration,
 * data ingestion, learning, and prediction etc.
 * @example
 * // Load wink regression tree.
 * var regressionTree = require( 'wink-regression-tree' );
 * // Create your instance of regression tree.
 * var myRT = regressionTree();
*/
var regressionTree = function () {
  // Columns configuration supplied to the `defineConfig()` function.
  var columnsConfig;
  // Columns definition created from the `columnsConfig` supplied to the `defineConfig()`
  // method.
  var columnsDefn;
  // Create configuration object.
  var config = Object.create( null );
  // The **w**ink **r**egression tree.
  var wrTree = Object.create( null );
  // Xformed Column id to input column id map.
  var xc2cMap = [];
  // Xformed data, where categorical variables are encoded by a numeric code. Useful
  // in reduction of memory load.
  var xdata = [];
  // Parameters used for evaluation.
  var evalParams = Object.create( null );
  // Remember the target column name in this.
  var target;
  // Current rules tree object version.
  var winkRulesTreeVersion = 'WRT 1.0.0';

  /**
   * @classdesc Regression tree class
   * @class RegressionTree
   * @hideconstructor
   */
  var methods = Object.create( null );

  // ### initEvalParams
  /**
   *
   * Initializes all the properties of `evalParams`.
   *
   * @return {undefined} nothing!
   * @private
  */
  var initEvalParams = function () {
    // Setup evaluation parameters.
    evalParams.size = 0;
    evalParams.mean = 0;
    evalParams.prevMean = 0;
    // Grand Sum of Squared Deviations from the Mean, prior to prediction.
    evalParams.gssdm = 0;
    // Sum of Squared Deviations from the Mean, post prediction
    evalParams.ssdm = 0;
  }; // initEvalParams()

  // ### initColsDefn
  /**
   *
   * Initializes the columns' definition by cloning the input `cols` and by adding
   * a struncture containing `map` and `nextCode` (next unique value's code)
   * for every categorical column that is not excluded fom processing.
   *
   * @param {object[]} cols — each object specifies 4 properties viz. (a) `name`;
   * (b) type in terms of `categorical` as `true or false`, where `false` indicates a
   * continuous variable; (c) `exclude`, which is set to true if the column
   * has to be excluded from training; and (d) `target`, which is set to true for
   * the column whose value is to be predicted.
   * @return {object[]} cloned `cols`, where each element gets 2 addtitional
   * properties viz. `map` and the `nextCode` that is initialized to **0**.
   * @private
  */
  var initColsDefn = function ( cols ) {
    // Clone the incoming `cols`
    var cc = JSON.parse( JSON.stringify( cols ) );
    // Intialize the included categorical columns with empty `map` object
    // and `nextCode` that will be assigned to the next unique value encountered.
    for ( var i = 0, imax = cc.length; i < imax; i += 1 ) {
      if ( cc[ i ].categorical && !cc[ i ].exclude ) {
        cc[ i ].nextCode = 0;
        cc[ i ].map = Object.create( null );
        cc[ i ].invertedMap = [];
      }
      // Remember the target column name.
      if ( cc[ i ].target ) {
        target = cc[ i ].name;
      }
    }
    // Return the cloned & initialized collumns — `cc`.
    return cc;
  }; // initColsDefn()

  // ### transformRow
  /**
   *
   * It transforms the **included categorical** column's data of `row` into coded
   * values using `colsDefn`. This encoding reduces the memory space requirements.
   * If a new unique value is encountered, the `colsDefn.map` & `colsDefn.nextCode`
   *  values are accordingly updated.
   *
   * @param {array} row — contains data i.e. column values for a single row.
   * @param {object} colsDefn — columns' definition data structure.
   * @return {array} transformed row with encoded categorical column values.
   * @private
  */
  var transformRow = function ( row, colsDefn ) {
    // Transformed row builds up in this variable.
    var xRow = [ ];
    // Map, inverted Map and target value.
    var invertedMap, map, tv;

    for ( var i = 0, imax = row.length; i < imax; i += 1 ) {
      // Categorical and Included?
      if ( colsDefn[ i ].categorical && !colsDefn[ i ].exclude ) {
        map = colsDefn[ i ].map;
        invertedMap = colsDefn[ i ].invertedMap;
        // Map defined for row's element in question?
        if ( map[ row[ i ] ] === undefined ) {
          // Not! Update the `map` & the `invertedMap`.
          map[ row[ i ] ] = colsDefn[ i ].nextCode;
          invertedMap.push( row[ i ] );
          colsDefn[ i ].nextCode += 1;
        }
      }
      // Transform value.
      if ( colsDefn[ i ].target ) {
        // Remember target's transformed value, it will be pushed as the last
        // element in the `xRow`.
        tv = ( colsDefn[ i ].categorical ) ? map[ row[ i ] ] : row[ i ];
      } else if ( !colsDefn[ i ].exclude ) {
        // Ensure exclusion.
        if (map)
          xRow.push( map[ row[ i ] ] );
        else // @blab+ non-catergorical variables
          xRow.push( row[ i ] );
      }
    }
    // Target's value is always the last element in `xRow`.
    xRow.push( tv );
    return xRow;
  }; // transformRow()

  // ### createCandidates
  /**
   *
   * It creates empty data structure for each potential candidate column.
   *
   * @param {array} cols2p — array of indexes of columns to be processed.
   * @return {object} containing further empty objects indexed by each columns
   * specified in the `cols2p` array.
   * @private
  */
  var createCandidates = function ( cols2p ) {
    // Create `candidates` object.
    var candidates = Object.create( null );
    var ci;
    // Each Column specific data structure pertaining to every unique value goes here.
    candidates.columns = Object.create( null );
    // List of indexes of columns, to avoid calls to `Object.keys()` on candidate columns.
    candidates.list = [];
    for ( var i = 0, imax = cols2p.length; i < imax; i += 1 ) {
      ci = cols2p[ i ];
      // Push this index in to the list.
      candidates.list.push( ci );
      // Create an empty structure for this column by its index.
      candidates.columns[ ci ] = Object.create( null );
    }
    return candidates;
  }; // createCandidates()

  // ### computeMeanDelta
  /**
   *
   * Computes the delta mean value from the next `data`; this delta may be used to
   * update mean by additing it to the current mean.
   *
   * @param {number} data — data used to compute the delta.
   * @param {number} currMean — current value of mean from which delta is computed
   * using the `data`.
   * @param {number} size — the number of `data` items encountered so far.
   * @return {number} the delta mean.
   * @private
  */
  var computeMeanDelta = function ( data, currMean, size ) {
    return ( data - currMean ) / ( size );
  }; // computeMeanDelta()

  // ### computeVarianceXnDelta
  /**
   *
   * Computes the delta varianceXn value from the next `data`; this delta may be
   * used to update varianceXn by additing it to the current varianceXn. Note,
   * varianceXn is nothing but *sum of squared devaitions from the mean*.
   *
   * @param {number} data — data used to compute the delta.
   * @param {number} currMean — current value of mean and
   * @param {number} prevMean — the previous value of mean; using these delta is
   * computed using the `data`.
   * @return {number} the delta varianceXn.
   * @private
  */
  var computeVarianceXnDelta = function ( data, currMean, prevMean ) {
    return ( data - prevMean ) * ( data - currMean );
  }; // computeVarianceXnDelta()

  // ### computeStdev
  /**
   *
   * Computes the standard deviation from `varianceXn` and `size` after applying
   * Bessel's correction.
   *
   * @param {number} varianceXn — the sum of squared devaitions from the mean.
   * @param {number} size — the number of items.
   * @return {number} the standard deviation.
   * @private
  */
  var computeStdev = function ( varianceXn, size ) {
    // Apply Bessel's correction for a better estimate of population standard
    // deviation.
    return ( size > 1 ) ? Math.sqrt( varianceXn / ( size - 1 ) ) : 0;
  }; // computeStdev()

  // ### computePercentageVarianceReduction
  /**
   *
   * Computes percentage reduction in variance in split children from the parent.
   *
   * @param {number} varianceXn — the sum of squared devaitions from the mean.
   * @param {number} size — the number of items.
   * @param {number} weightedSumOfVar — weighted sum of variance of every child node.
   * @return {number} the percentage reduction in variance.
   * @private
  */
  var computePercentageVarianceReduction = function ( varianceXn, size, weightedSumOfVar ) {
    return ( ( ( varianceXn / size ) - weightedSumOfVar ) * 100 / ( varianceXn / size ) );
  }; // computePercentageVarianceReduction()

  // ### updateVarianceXn
  /**
   *
   * Incrementally updates the varianceXn of `targetsValue`  for the `c2psValue` of column to
   * process — `c2p` in `candidates` for the row pointed by `rowsIndex`.
   *
   * @param {object} candidates — data structure containing varianceXn for every
   * column's applicable unique values.
   * @param {number} c2p — the column to be processed.
   * @param {string} c2psValue — the column to be processed's value.
   * @param {number} rowsIndex — index of the data row to be used.
   * @param {number} targetsValue — target's value to be used for updating varianceXn.
   * @return {boolean} always true.
   * @private
  */
  var updateVarianceXn = function ( candidates, c2p, c2psValue, rowsIndex, targetsValue ) {
    // The candidates' colums where varianceXn will be updated.
    var cc2p = candidates.columns[ c2p ];
    // Create a place holder for `c2psValue`, provided it is being encountered
    // for the first time.
    if ( cc2p[ c2psValue ] === undefined ) {
      cc2p[ c2psValue ] = Object.create( null );
      // Mean of `targetsValue` encountered so far.
      cc2p[ c2psValue ].mean = 0;
      // The variance multiplied by `n or size`.
      cc2p[ c2psValue ].varianceXn = 0;
      // The count or size of values processed so far; will match with `index`
      // array size.
      cc2p[ c2psValue ].size = 0;
      // INdex of rows containing this specific value i.e. `c2psValue`.
      cc2p[ c2psValue ].index = [];
    }
    // Update varianceXn, etc.
    var prevMean = cc2p[ c2psValue ].mean;
    cc2p[ c2psValue ].size += 1;
    cc2p[ c2psValue ].mean += computeMeanDelta( targetsValue, cc2p[ c2psValue ].mean, cc2p[ c2psValue ].size );
    // ( targetsValue - cc2p[ c2psValue ].mean ) / ( cc2p[ c2psValue ].size );
    cc2p[ c2psValue ].varianceXn += computeVarianceXnDelta( targetsValue, cc2p[ c2psValue ].mean, prevMean );
    // ( targetsValue - prevMean ) * ( targetsValue - cc2p[ c2psValue ].mean );
    cc2p[ c2psValue ].index.push( rowsIndex );
    return true;
  }; // updateVarianceXn()

  // ### processRow
  /**
   *
   * It requires a `row` of data, columns to be processed —`c2p`, the `colsDefn`,
   * and a `node` that captures the column-wise varianceXn & mean for every unique
   * of the a column.
   *
   * @param {array} row — single row of transformed data that needs to be processed.
   * @param {number} rowsIndex — index of the row being passed.
   * @param {object} candidates — for split, contains all the statistic.
   * @param {function} updateFn — updates the statistic in `candidates`.
   * @return {object[]} ???
   * @private
  */
  var processRow = function ( row, rowsIndex, candidates, updateFn ) {
    // Single column to process from the array `cols2p`.
    var c2p;
    var indexOfTarget = row.length - 1;
    for ( var i = 0, imax = candidates.list.length; i < imax; i += 1 ) {
      c2p = candidates.list[ i ];
      updateFn( candidates, c2p, row[ c2p ], rowsIndex, row[ indexOfTarget ] );
    }
  }; // processRow()

  // ### selectBestSplit
  /**
   *
   * Finds the best candidate column for split on the basis of maximum reduction
   * in variance (impurity or maximum gain).
   *
   * @param {object} candidates — columns from where the best candidate for split
   * is selected.
   * @return {object} containing the best `col` and the corresponding wieghted
   * `sum` of squared deviation from mean for each unique value.
   * @private
  */
  var selectBestSplit = function ( candidates ) {
    // Used in for-in loop: unique values (`uvs`) in a `col`.
    var col, uvs;
    // Sum of `varianceXn * size` for each `uvs` in a `col`; and its size.
    var size, sum;
    // Used to compute average children item for minAvgChildrenItems config.
    var counter, meanSize;
    // Minimum Sum and the Best Column.
    var bestCol, minSum;

    minSum = Infinity;
    bestCol = -1;
    for ( col in candidates.columns ) { // eslint-disable-line guard-for-in
      // Initialize `sum` and `size` for this `col`.
      sum = 0;
      size = 0;
      // And also counter & meanSize.
      counter = 0;
      meanSize = 0;
      for ( uvs in candidates.columns[ col ] ) { // eslint-disable-line guard-for-in
        size += candidates.columns[ col ][ uvs ].size;
        // Compute average (mean) children items.
        counter += 1;
        meanSize += computeMeanDelta( candidates.columns[ col ][ uvs ].size, meanSize, counter );
        // Compute weighted sum; will divide by sum after the loop finishes to normalize.
        // Recall, `varianceXn` is variance multiplied by items.
        sum += ( candidates.columns[ col ][ uvs ].varianceXn /* candidates.columns[ col ][ uvs ].size */ );
      }
      // Normalize - this will yield weighted sum of variances.
      sum /= size;
      // Update minumum only if `meanSize` is above the defined threshold.
      if ( ( sum < minSum ) && ( meanSize > config.minAvgChildrenItems ) ) {
        minSum = sum;
        bestCol = col;
      }
    }
    // If the best column is not found, return `undefined`.
    return ( bestCol === -1 ) ? undefined : { col: +bestCol, sum: minSum };
  }; // selectBestSplit()

  // ### reducer
  /**
   *
   * Helper function for `JS array reduce`; used to merge two arrays.
   *
   * @param {object} acc — accumulator i.e. the array containing the merged values.
   * @param {object} cv — current value i.e. one array element to be pushed.
   * @return {object} collapsed column.
   * @private
  */
  var reducer = function ( acc, cv ) {
    acc.push( cv );
    return ( acc );
  }; // reducer();

  // ### collapseNodesInCol
  /**
   *
   * Iterates through every candidate column in `cc`. For each candidate column,
   * it collapses all nodes with `size < config.minLeafNodeItems` into a single
   * node referred to as `$$other_values`.
   *
   * @param {object} col — candidate columns that are iterated through for a
   * possible collapse.
   * @return {object} collapsed column.
   * @private
  */
  var collapseNodesInCol = function ( col ) {
    // Collapsed column
    var collapsedCol = Object.create( null );
    // All `nodes < config.minLeafNodeItems` will be collapsed into this.
    var others = Object.create( null );
    // Unique Value in `col`
    var uv;
    // Helpers!
    var collapsedOccurred = false;
    // Combined mean, temp object holder.
    var meanc, obj;

    others.size = 0;
    others.mean = 0;
    others.varianceXn = 0;
    others.index = [];
    others.collapsedNodes = 0;
    // Iterate through every unique value in the `col` object.
    for ( uv in col ) { // eslint-disable-line guard-for-in
      obj = col[ uv ];
      if ( obj.size < config.minLeafNodeItems ) {
        collapsedOccurred = true;
        others.collapsedNodes += 1;
        // Combine means and remember it for a while before updating.
        meanc = ( ( others.mean * others.size ) + ( obj.mean * obj.size ) ) / ( others.size + obj.size );
        // Combine `variances * size` i.e. `varianceXn`.
        others.varianceXn = others.varianceXn +
                            obj.varianceXn +
                            ( others.size * ( others.mean - meanc ) * ( others.mean - meanc ) ) +
                            ( obj.size * ( obj.mean - meanc ) * ( obj.mean - meanc ) );
        // Now update combined means!
        others.mean = meanc;
        // Update size.
        others.size += obj.size;
        // Finally merge both indexes.
        others.index = obj.index.reduce( reducer, others.index );
      } else {
        collapsedCol[ uv ] = col[ uv ];
      }
    }
    // If collapse has occurred then include `$$other_values` in `collapsedCol`.
    if ( collapsedOccurred ) collapsedCol.$$other_values = others; // eslint-disable-line camelcase
    return collapsedCol;
  }; // collapseNodesInCol()

  // ### collapseNodesInCC
  /**
   *
   * Iterates through every candidate column in `cc`. For each candidate column,
   * it collapses all nodes with `size < config.minLeafNodeItems` into a single
   * node referred to as `$$other_values`.
   *
   * @param {object} cc — candidate columns that are iterated through for a
   * possible collapse.
   * @return {undefined} the void!
   * @private
  */
  var collapseNodesInCC = function ( cc ) {
    // Column Id in Candidate Columns (cc).
    var cid;
    for ( cid in cc ) { // eslint-disable-line guard-for-in
      cc[ cid ] = collapseNodesInCol( cc[ cid ] );
    }
  }; // collapseNodesInCC()


  // ### growTree
  /**
   *
   * Builds the tree recursively by maximaizing the variance reduction on each
   * split.
   *
   * @param {object} cc — candidate columns to consider for further growing the
   * tree.
   * @param {number} splitData — columns on which split occurred.
   * @param {number} colUsed4Split — column used for creating the `splitData`.
   * @param {object} node — node of the tree, from where tree may be grown further.
   * @param {number} depth — of the tree so far.
   * @return {object} the tree!
   * @private
  */
  var growTree = function ( cc, splitData, colUsed4Split, node, depth ) {
    // Maximum defined depth reached?
    if ( depth > config.maxDepth ) {
      // Yes, return.
      return;
    }

    var cCols;
    var colsLeft;
    var bs, uniqVal;
    var varianceReduction;
    var child;
    // Helper variables
    var actualValue, index, j, k, kmax;
    node.branches = Object.create( null );
    for ( uniqVal in splitData ) { // eslint-disable-line guard-for-in
      // Node always has enough items as collapse would have already occurred.
      // @blab+ address non-categorical values, too
      var candidate = columnsDefn[ xc2cMap[ colUsed4Split ] ];
      if (uniqVal === '$$other_values' || !candidate.invertedMap) actualValue = uniqVal;
      else actualValue =  candidate.invertedMap[ +uniqVal ];
      // actualValue = ( uniqVal === '$$other_values' ) ? uniqVal : columnsDefn[ xc2cMap[ colUsed4Split ] ].invertedMap[ +uniqVal ];
      child = node.branches[ actualValue ] = Object.create( null );
      child.size = splitData[ uniqVal ].size;
      child.mean = splitData[ uniqVal ].mean;
      child.stdev = computeStdev( splitData[ uniqVal ].varianceXn, splitData[ uniqVal ].size );
      // Add collapsed node count, if collapsed had occurred: more for reference only.
      // It has no predictionn value.
      if ( splitData[ uniqVal ].collapsedNodes !== undefined ) child.collapsedNodes = splitData[ uniqVal ].collapsedNodes;
      // Create candidate colums for this node. These will be used to obtain bestCol
      // split as per the `config`.
      cCols = createCandidates( cc );
      index = splitData[ uniqVal ].index;
      // Does it have enough items to proceed with split?
      if ( index.length <= config.minSplitCandidateItems || child.stdev < stdevEPSILON ) {
        // No! continue with the iteration with the next `uniqVal`.
        continue;
      }
      // Attempt split.
      for ( k = 0, kmax = index.length; k < kmax; k += 1 ) {
        processRow( xdata[ index[ k ] ], index[ k ], cCols, updateVarianceXn );
      }
      // Node that contain less than `config.minLeafNodeItems` are collapsed here.
      collapseNodesInCC(cCols.columns);
      bs = selectBestSplit( cCols );
      if ( bs === undefined ) {
        // No best column found, coninue with the next one!
        continue;
      }
      varianceReduction = computePercentageVarianceReduction( splitData[ uniqVal ].varianceXn, splitData[ uniqVal ].size, bs.sum );
      // Reasonable variance reduction?
      if ( varianceReduction < config.minPercentVarianceReduction ) {
        // No! continue with the iteration with the next `uniqVal`.
        continue;
      }
      // Yes, split possible! Make a list of left columns by removing the columns
      // found for splitting.
      colsLeft = [];
      for ( j = 0; j < cc.length; j += 1 ) {
        if ( cc[ j ] !== bs.col ) colsLeft.push( cc[ j ] );
      }
      // Recurse!
      child.colUsed4Split = columnsDefn[xc2cMap[bs.col]].name;
      child.varianceReduction = varianceReduction;
      growTree( colsLeft, cCols.columns[ bs.col ], bs.col, child, ( depth + 1 ) );
    }
  }; // growTree()

  // ### countRules
  /**
   *
   * Counts the number of rules generated from a rules tree and updates the final
   * number in the root node of the tree.
   *
   * @param {object} tree — the rules tree.
   * @return {undefined} or void!
   * @private
  */
  var countRules = function ( tree ) {
    var subTree = tree.branches;
    for ( var node in subTree ) {
      if ( subTree[ node ].branches !== undefined && Object.keys( subTree[ node ].branches ).length > 0 ) {
        countRules( subTree[ node ] );
      } else wrTree.rulesLearned += 1;
    }
  }; // countRules()

  // ### defineConfig
  /**
   *
   * Defines the configuration required to read the input data and to generates
   * the regression tree.
   *
   * @method RegressionTree#defineConfig
   * @param {object[]} inputDataCols each object in this array defines a column of input
   * data in the same sequence in which data will be supplied to `ingest().` It is
   * defined in terms of the following details:
   * @param {string} inputDataCols[].name of the column.
   * @param {boolean} inputDataCols[].categorical defines column's data type — `true` indicating categorical
   * **or** `false` indicating numeric; currently numeric data type is not supported.
   * @param {boolean} [inputDataCols[].exclude=false] used to exclude a column during tree building.
   * @param {boolean} [inputDataCols[].target=false] is set to `true` only for the target column, whose
   * value needs to be predicted. Note this column must be a numeric column.
   * @param {object} tree contains key value pairs of the following regression
   * tree's parameters:
   * @param {number} [tree.maxDepth=20] is the maximum depth of the tree after which
   * learning stops.
   * @param {number} [tree.minPercentVarianceReduction=10] is the minmum variance reduction
   * required for a split to occur.
   * @param {number} [tree.minSplitCandidateItems=50] the minimum items that must be present
   * at a node for it to be split further, even after the `minPercentVarianceReduction`
   * target has been achieved.
   * @param {number} [tree.minLeafNodeItems=10] is the minimum number of items that
   * must be present at a leaf node to be retained as an independent node. Nodes with
   * less than this value size are merged together.
   * @param {number} [tree.minAvgChildrenItems=2] the average number of items
   * across children must be greater than this number, for a column to become a candidate
   * for split. A higher number will discourage splits that creates many branches
   * with each child node containing fewer items.
   * @return {number} number of columns defined.
   * @example
   * // Define each column.
   * var columns = [
   *   { name: 'model', categorical: true, exclude: true },
   *   { name: 'mpg', categorical: false, target: true },
   *   { name: 'cylinders', categorical: true },
   *   { name: 'displacement', categorical: true, exclude: false },
   *   { name: 'horsepower', categorical: true, exclude: false },
   *   { name: 'weight', categorical: true, exclude: false },
   *   { name: 'acceleration', categorical: true, exclude: false },
   *   { name: 'year', categorical: true, exclude: true },
   *   { name: 'origin', categorical: true, exclude: false  }
   * ];
   * // Define parameters to grow the tree.
   * var treeParams = {
   *   minPercentVarianceReduction: 2.5,
   *   minLeafNodeItems: 10,
   *   minSplitCandidateItems: 30,
   *   minAvgChildrenItems: 3
   * };
   * // Define the configuration using above 2 variables.
   * myRT.defineConfig( columns, treeParams );
   * // -> 8
  */
  var defineConfig = function ( inputDataCols, tree ) {
    config.maxDepth = tree.maxDepth || config.maxDepth;
    config.minPercentVarianceReduction = tree.minPercentVarianceReduction || config.minPercentVarianceReduction;
    config.minSplitCandidateItems = tree.minSplitCandidateItems || config.minSplitCandidateItems;
    config.minLeafNodeItems = tree.minLeafNodeItems || config.minLeafNodeItems;
    config.minAvgChildrenItems = tree.minAvgChildrenItems || config.minAvgChildrenItems;
    columnsConfig = inputDataCols;
    columnsDefn = initColsDefn( columnsConfig );
    return inputDataCols.length;
  }; // defineConfig();

  // ### ingest
  /**
   *
   * Ingests one row of the data at a time. It is specially useful for reading
   * data in an asynchronus manner, where this may be used as a call back function
   * on every row read event.
   *
   * @method RegressionTree#ingest
   * @param {array} row one row of the data to be ingested; column values
   * should be in the same sequence in which they are defined in data configuration
   * via `defineConfig()`.
   * @return {boolean} always `true`.
   * @throws {error} if number of elements in `row` don't match with the
   * number of columns defined.
   * @example
   * // Load cars training data set.
   * var cars = require( 'wink-regression-tree/sample-data/cars.json' );
   * // Ingest the data.
   * cars.forEach( function ( row ) {
   *   myRT.ingest( row );
   * } );
  */
  var ingest = function ( row ) {
    if ( row.length === columnsConfig.length ) {
      xdata.push( transformRow( row, columnsDefn ) );
    } else {
      throw Error( 'winkRT: ingest is expecting ' + columnsConfig.length + ' elements instead found: ' + row.length );
    }

    return true;
  }; // ingest()

  // ### learn
  /**
   *
   * Learns from the ingested data and generates the rule tree that is used to
   * `predict()` the value of target variable from the input. It requires at least
   * 60 data rows to initiate meaningful learning.
   *
   * @method RegressionTree#learn
   * @return {number} number of rules learned from the input data.
   * @throws {error} if number of rows in the ingested data are <60.
   * @example
   * myRT.learn();
   * // -> Number of rules learned
  */
  var learn = function ( ) {
    if ( xdata.length < 60 ) {
      throw Error( 'winkRT: learn is expecting at least 60 rows of data, instead found: ' + xdata.length );
    }
    // Candidate columns list
    var candidateCols = [];
    // Candidate columns created using above list.
    var cndts;
    // Required for the root node.
    var rootsMean = 0;
    var rootsVarianceXn = 0;
    var prevRootsMean;
    // Index of the target variable (Y).
    var indexOfTarget;
    // Object containing best split info in terms of the column and the
    // weighted `sum` of variance.
    var bestSplit;
    // Updated candidate columns list after split.
    var updatedCandidateCols = [];
    // Helper variables
    var i, imax;
    var k = 0;

    // Create candidate columns list & `xc2cMap`.
    for ( i = 0, imax = columnsConfig.length; i < imax; i += 1 ) {
      if ( !columnsConfig[ i ].exclude ) {
        if ( !columnsConfig[ i ].target ) {
          xc2cMap.push( i );
          candidateCols.push( k );
          k += 1;
        }
      }
    }

    cndts = createCandidates( candidateCols );

    indexOfTarget = xdata[ 0 ].length - 1;
    // Process every row as this is the root level.
    for ( i = 0; i < xdata.length; i += 1 ) {
      processRow( xdata[ i ], i, cndts, updateVarianceXn );
      prevRootsMean = rootsMean;
      rootsMean += computeMeanDelta( xdata[ i ][ indexOfTarget ], rootsMean, ( i + 1 ) );
      rootsVarianceXn += computeVarianceXnDelta( xdata[ i ][ indexOfTarget ], rootsMean, prevRootsMean );
    }
    // Node that contain less than `config.minLeafNodeItems` are collapsed here.
    collapseNodesInCC(cndts.columns);
    // Define minimal root node stuff here itself.
    wrTree.version = winkRulesTreeVersion;
    wrTree.size = xdata.length;
    wrTree.mean = rootsMean;
    wrTree.stdev = computeStdev( rootsVarianceXn, wrTree.size );
    // Attempt to grow tree if standard deviation is large enough!
    if ( wrTree.stdev > stdevEPSILON ) {
      bestSplit = selectBestSplit( cndts );
      if ( bestSplit === undefined ) {
        // Opps, no worthy column available - return the root!
        wrTree.rulesLearned = 0;
        countRules( wrTree );
        return wrTree.rulesLearned;
      }
      // Find the updated list of candidate columsn after the split.
      for ( i = 0; i < candidateCols.length; i += 1 ) {
        if ( candidateCols[ i ] !== bestSplit.col ) updatedCandidateCols.push( candidateCols[ i ] );
      }
      // Define the balance stuff as a split has been found!
      wrTree.colUsed4Split = columnsDefn[xc2cMap[bestSplit.col]].name;
      wrTree.varianceReduction = computePercentageVarianceReduction( rootsVarianceXn, wrTree.size, bestSplit.sum );
      // Call recursive function, `growTree()`.
      growTree( updatedCandidateCols, cndts.columns[ bestSplit.col ], bestSplit.col, wrTree, 1 );
    }
    wrTree.rulesLearned = 0;
    countRules( wrTree );
    return wrTree.rulesLearned;
  }; // learn()

  // ### navigateRules
  /**
   *
   * Recursively navigaes the rule tree to arrive at a prediction for the
   * `input` data. If the value of a columm in the input data, required during
   * the prediction is missing, it throws an error provided the function
   * `f` is not defined. Otherwise the name of column is passed to this function;
   * and the function is expected to handle the same.
   *
   * @param {object} input — data containing column name/value pairs; the column
   * names must the same as defined via `defineConfig()`.
   * @param {object} rules — the rules tree generated during `learn()`; on every
   * recursion a branch of tree is passed.
   * @param {function} [f=undefined] — is called once
   * a leaf node is reached during prediction with the following 4 parameters: **size,**
   * **mean** and **stdev** values at the node; an **array** of column names
   * navigated to reach the leaf and **column name** for which value is missing
   * in the input (if found). The value returned from this function becomes  the prediction.
   * @param {array} colsUsed4Prediction — columns used for prediction are pushed into this array; if
   * this is empty then it means no rules matched and prediction occurred using
   * the root node.
   * @return {number} `mean` value or whatever is returned by the `fn` function, if defined.
   * @private
  */
  var navigateRules = function ( input, rules, f, colsUsed4Prediction ) {
    // Sub-tree is present if # of branches > 0.
    var hasSubTree = helpers.object.isObject( rules.branches ) &&
                        ( ( Object.keys( rules.branches ) ).length > 0 );


    var inputHasReqdValue = false;
    var stopNavigation = true;
    var column;
    var reqdValue;

    if ( !hasSubTree ) {
      // No subTree, return!
      return (
        ( typeof f === 'function' ) ?
          f( rules.size, rules.mean, rules.stdev, colsUsed4Prediction ) :
          rules.mean
      );
    }
    // Sub-tree is present, check if the input has a value for `colUsed4Split`.
    column = rules.colUsed4Split;

    inputHasReqdValue = ( ( input[ column ] !== undefined ) &&
      ( input[ column ] !== null ) );

    if ( inputHasReqdValue ) {
      // Lookup `reqdValue` from the input.
      reqdValue = input[ column ];
      // If there is no branch corresponding to the `reqdValue` then instead of stopping
      // navigation and returning the parent's node stuff, also check if there exist
      // `$$other_values`. If such a node exist, **assume** that this `reqdValue` belongs
      // to the `$$other_values` set. The intuition is that typically other values are
      // those that have very few instances (i.e. frequency of occurrance) and
      // therefore this `reqdValue` will share characterstics with `$$other_values`.
      // However, if there is no `$$other_values` set at this level then simply return
      // parent's node stuff.
      stopNavigation = !helpers.object.isObject( rules.branches[ reqdValue ] || rules.branches.$$other_values );
    } else {
      // Input does not have the value for column.
      if ( typeof f !== 'function' ) {
        // No `f` defined, throw error.
        throw Error( 'winkRT: missing column value for the column found during prediction: ' + JSON.stringify( column ) );
      }
      // The `f` is defined, let it handle.
      return f( rules.size, rules.mean, rules.stdev, colsUsed4Prediction, column );
    }

    if ( stopNavigation ) {
      return (
        ( typeof f === 'function' ) ?
          f( rules.size, rules.mean, rules.stdev, colsUsed4Prediction, column ) :
          rules.mean
      );
    }
    // Continue navigation!
    colsUsed4Prediction.push( rules.colUsed4Split );
    return navigateRules( input, rules.branches[ reqdValue ] || rules.branches.$$other_values, f, colsUsed4Prediction );
  }; // navigateRules()

  // ### predict
  /**
   *
   * Predicts the value of target variable from the `input` using the rules tree generated by
   * `learn()`. If the value of a columm in the input data, required for
   * the prediction is missing, by defualt it throws an error. If the function
   * `fn` is defined then no error is thrown, instead the name of missing column is passed
   * to this function; and the function is expected to handle the same.
   *
   * @method RegressionTree#predict
   * @param {object} input data containing column name/value pairs; the column
   * names must the same as defined via `defineConfig()`.
   * @param {function} [modifier=undefined] is called once
   * a leaf node is reached during prediction with the following 5 parameters: **size,**
   * **mean** and **stdev** values at the node; an **array** of column names
   * navigated to reach the leaf and **column name** for which value is missing
   * in the input (`default=undefined`). The value returned from this function becomes  the prediction.
   * @return {number} `mean` value or whatever is returned by the `modifier` function, if defined.
   * @throws {error} if the `input` is not a javascript object.
   * @throws {error} if a value of a column required for prediction is missing in `input`,
   * provided `modifier` has not been defined.
   * @example
   * // Populate sample input
   * var input = {
   *   model: 'Ford Gran Torino',
   *   weight: 'very high weight',
   *   displacement: 'very large displacement',
   *   horsepower: 'extremely high power',
   *   origin: 'US',
   *   acceleration: 'slow'
   * };
   * // Attempt prediction.
   * myRT.predict( input );
   * // -> 14.3
  */
  var predict = function ( input, modifier ) {
    if ( !helpers.object.isObject( input ) ) {
      throw Error( 'winkRT: input for prediction must be an object, instead found: ' + ( typeof input ) );
    }
    var colsUsed4Prediction = [];
    return navigateRules( input, wrTree, modifier, colsUsed4Prediction );
  }; // predict()

  // ### navigateRules4Stats
  /**
   *
   * Recursively navigaes the rule tree to generate the summary by extracting the
   * level wise column hierarchy, nodes that were split on this hierarchy, min &
   * max variance reduction, etc.
   *
   * @param {object} subTree — the rules tree generated during `learn()`; on every
   * recursion a branch of tree is passed.
   * @param {object} stats — summary of min/max means and their corresponding stdevs
   * along with the overall `minSD` — minimum stdev.
   * @param {stats} colImp — contains depth wise column hierarchy, number of nodesSplit
   * and the min/max varaiance reduction at that level.
   * @param {number} depth — the current depth of the tree.
   * @param {string} ch — column's hierarchy in the unix file/folder naming style.
   * @return {undefined} nothing!
   * @private
  */
  var navigateRules4Stats = function ( subTree, stats, colImp, depth, ch ) {
    var chVal = ch;
    if ( subTree.branches && ( Object.keys( subTree.branches ) ).length > 0 ) {
      // Update column's hierarchy in unix styled path names.
      chVal += '/' + subTree.colUsed4Split;
      // Initialize stats at the current `depth` and `ch` level.
      colImp[ depth ] = colImp[ depth ] || Object.create( null );
      if ( colImp[ depth ][ chVal ] === undefined ) {
        colImp[ depth ][ chVal ] = Object.create( null );
        colImp[ depth ][ chVal ].nodesSplit = 0;
        colImp[ depth ][ chVal ].minVR = Infinity;
        colImp[ depth ][ chVal ].maxVR = -Infinity;
      }
      // Update stats.
      colImp[ depth ][ chVal ].nodesSplit += 1;
      // Update min/max varaiance reductions.
      colImp[ depth ][ chVal ].minVR = Math.min( colImp[ depth ][ chVal ].minVR, +subTree.varianceReduction.toFixed( 4 ) );
      colImp[ depth ][ chVal ].maxVR = Math.max( colImp[ depth ][ chVal ].maxVR, +subTree.varianceReduction.toFixed( 4 ) );

      for ( var key in subTree.branches ) { // eslint-disable-line guard-for-in
        // Update summary!
        if ( stats.min.mean > subTree.branches[ key ].mean ) {
          stats.min.mean = subTree.branches[ key ].mean;
          stats.min.itsSD = subTree.branches[ key ].stdev;
        }
        if ( stats.max.mean < subTree.branches[ key ].mean ) {
          stats.max.mean = subTree.branches[ key ].mean;
          stats.max.itsSD = subTree.branches[ key ].stdev;
        }
        stats.minSD = Math.min( stats.minSD, subTree.branches[ key ].stdev );
        // Time to dig deeper!!
        navigateRules4Stats( subTree.branches[ key ], stats, colImp, ( depth + 1 ), chVal );
      }
    }
  }; // navigateRules4Stats()

  // ### summary
  /**
   *
   * Generates summary of the learnings in terms of the following:<ol>
   * <li>Relative importance of columns along with the corresponding min/max
   * variance reductions (VR).</li>
   * <li>The min/max mean values along with the corresponding standard
   * deviations (SD).</li>
   * <li>The minumum standard deviation (SD) discovered during the learning.</li></ol>
   *
   * @method RegressionTree#summary
   * @return {object} containing the following:<ol>
   * <li><code>table</code> — array of objects, where each object defines <code>level</code>, <code>columnHierarchy</code>,
   * <code>nodesSplit</code>, <code>minVR</code> and <code>maxVR</code>. A lower value of <code>level</code>
   * indicates higher importance; similarly more nodes at a level split on a columnHierarchy
   * is an indication of importance. Therefore, it is sorted in ascending order of <code>level</code>
   * followed by in descending order of <code>nodesSplit</code>.</li>
   * <li><code>stats</code> — object containing <code>min.mean</code>, <code>min.itsSD</code>, <code>max.mean</code>, <code>max.itsSD</code>,
   * and <code>minSD</code>.</li></ol>
   * @example
   * myRT.summary();
   * // -> returns the summary object.
  */
  var summary = function () {
    // Column imporatnce is captured first in an object to ease hashing and later
    // converted to a table.
    var columnsImportance = Object.create( null );
    var table = [];
    // Current depth of the tree.
    var depth = 1;
    // In unix style file paths.
    var columnHierarchy = '';
    // To capture min/max means and their stdevs, etc.
    var stats = Object.create( null );
    // Helper variables.
    var ch, level;

    // Initialize.
    stats.min = Object.create( null );
    stats.max = Object.create( null );
    stats.minSD = Infinity;
    stats.min.mean = Infinity;
    stats.min.itsSD = 0;
    stats.max.mean = -Infinity;
    stats.max.itsSD = 0;
    // Buld summary recursively.
    navigateRules4Stats( wrTree, stats, columnsImportance, depth, columnHierarchy );
    // Convert to `table`.
    for ( level in columnsImportance ) { // eslint-disable-line guard-for-in
      for ( ch in columnsImportance[ level ] ) { // eslint-disable-line guard-for-in
        table.push( {
          level: +level,
          columnHierarchy: ch,
          nodesSplit: columnsImportance[ level ][ ch ].nodesSplit,
          minVR: columnsImportance[ level ][ ch ].minVR,
          maxVR: columnsImportance[ level ][ ch ].maxVR,
        } );
      }
    }
    // Sort on level (asc) and then on nodesSplit(dsc).
    table.sort( function ( a, b ) {
      return (
        ( a.level > b.level ) ? 1 :
          ( a.level < b.level ) ? -1 :
            ( a.nodesSplit < b.nodesSplit ) ? 1 : -1
      );
    } );
    // Return summary!
    return { columnsImportance: table, stats: stats };
  }; // summary()

  // ### evaluate
  /**
   *
   * Incrementally evalutes variance reduction for one data row at a time.
   *
   * @method RegressionTree#evaluate
   * @param {object} rowObject contains column name/value pairs including the target column
   * name/value pair as well, which is used in evaluating the variance reduction.
   * @return {boolean} always `true`.
   * @example
   * myRT.evaluate( input );
  */
  var evaluate = function ( rowObject ) {
    var pv = predict( rowObject );
    evalParams.prevMean = evalParams.mean;
    evalParams.size += 1;
    evalParams.mean += computeMeanDelta( rowObject[ target ], evalParams.mean, evalParams.size );
    evalParams.gssdm += computeVarianceXnDelta( rowObject[ target ], evalParams.mean, evalParams.prevMean );
    evalParams.ssdm += ( ( rowObject[ target ] - pv ) * ( rowObject[ target ] - pv ) );
    return true;
  }; // evaluate()

  // ### metrics
  /**
   *
   * Computes the variance reduction observed in the validation data passed to
   * `evaluate()`.
   *
   * @method RegressionTree#metrics
   * @return {object} containing the `varianceReduction` in percentage and data `size`.
   * @example
   * myRT.metrics();
   * // -> object containing varianceReduction and data size.
  */
  var metrics = function ( ) {
    return (
      {
        size: evalParams.size,
        varianceReduction: +( ( evalParams.gssdm - evalParams.ssdm ) * 100 / evalParams.gssdm ).toFixed( 4 ),
      }
    );
  }; // metrics()

  // ### exportJSON
  /**
   *
   * Exports the JSON of the rule tree generated by `learn()`, which may be
   * saved in a file for later predictions.
   *
   * @method RegressionTree#exportJSON
   * @return {json} of the rule tree.
   * @example
   * var rules = myRT.exportJSON();
  */
  var exportJSON = function () {
    return JSON.stringify( wrTree );
  }; // exportJSON()

  // ### importJSON
  /**
   *
   * Imports the rule tree from the input `rulesTree` for subsequent use by `predict()`.
   * Note after a successful import, this can be used ONLY for prediction purpose
   * and not for further ingestion and/or learning.
   *
   * @method RegressionTree#importJSON
   * @param {json} rulesTree containg an earlier exported rule tree in JSON format.
   * @return {boolean} always `true`.
   * @throws {error} if `rulesTree` is `null`.
   * @throws {error} if `rulesTree` can not be parsed as a valid JSON.
   * @throws {error} if `rulesTree` is of incorrect version or incorrect format.
   * @example
   * var anRT = regressionTree();
   * // Assuming that json has a valid rule tree.
   * anRT.importJSON( rules );
  */
  var importJSON = function ( rulesTree ) {
    if ( !rulesTree ) {
      throw Error( 'winkRT: undefined or null JSON encountered, import failed!' );
    }
    try {
      wrTree = JSON.parse( rulesTree );
    } catch ( ex ) {
      throw Error( 'winkRT: JSON parsing error during import:\n\t' + ex.message );
    }
    if ( wrTree.version !== winkRulesTreeVersion ) {
      throw Error( 'winkRT: incorrect json format or tree version, import failed!' );
    }
    return true;
  }; // importJSON()

  // ### reset
  /**
   *
   * It completely resets the tree by re-initializing all the learning
   * related variables, except it's configuration. It is useful during
   * cross fold-validation.
   *
   * @method RegressionTree#reset
   * @return {undefined} nothing!
   * @example
   * var myRT.reset();
  */
  var reset = function () {
    // Do not reset variables pertaining to *configuration*:<br/>
    // 1. `columnsConfig`
    // 2. `columnsDefn`
    // 3. `config`
    // 4. `target`

    // All other variables are reset/re-initialized.

    // Re-initialize the **w**ink **r**egression tree.
    wrTree = Object.create( null );
    // Re-initialize Xformed Column id to input column id map.
    xc2cMap = [];
    // Re-initialize Xformed data, where categorical variables are encoded by a numeric code. Useful
    // in reduction of memory load.
    xdata = [];
    // Re-initialize parameters used for evaluation.
    evalParams = Object.create( null );
    initEvalParams();
  }; // reset();

  // Set default configuration;
  config.maxDepth = 20;
  config.minPercentVarianceReduction = 10;
  config.minSplitCandidateItems = 50;
  config.minLeafNodeItems = 10;
  // This will ensure that split will never occurr on uniq id like columns!
  config.minAvgChildrenItems = 2;
  // Initialize the number of rules learned.
  wrTree.rulesLearned = 0;

  // Initialize evaluation parameters.
  initEvalParams();

  methods.defineConfig = defineConfig;
  methods.ingest = ingest;
  methods.learn = learn;
  methods.predict = predict;
  methods.evaluate = evaluate;
  methods.metrics = metrics;
  // Setup an alias `stats()` to maintain similarity with other ML packages
  // such as naive bayes, etc.
  methods.stats = methods.summary = summary;
  methods.exportJSON = exportJSON;
  methods.importJSON = importJSON;
  methods.reset = reset;

  methods.info = function () {
    return {
      columnsConfig : columnsConfig,
      columnsDefn : columnsDefn,
    }
  }
  return methods;
}; // regressionTree()

// Export
module.exports = regressionTree;
};
BundleModuleCode['ml/helpers']=function (module,exports,global,process){
//     wink-helpers
//     Functions for cross validation, shuffle, cartesian product and more
//
//     https://github.com/winkjs/wink-helpers
//
//     Copyright (C) 2017-18  GRAYPE Systems Private Limited
//
//     This file is part of “wink-helpers”.
//
//     Permission is hereby granted, free of charge, to any person obtaining a
//     copy of this software and associated documentation files (the "Software"),
//     to deal in the Software without restriction, including without limitation
//     the rights to use, copy, modify, merge, publish, distribute, sublicense,
//     and/or sell copies of the Software, and to permit persons to whom the
//     Software is furnished to do so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included
//     in all copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//     DEALINGS IN THE SOFTWARE.

//
var helpers = Object.create( null );

// ### Private Functions

// #### Product Reducer (Callback)

// Callback function used by `reduce` inside the `product()` function.
// Follows the standard guidelines of `reduce()` callback function.
var productReducer = function ( prev, curr ) {
  var c,
      cmax = curr.length;
  var p,
      pmax = prev.length;
  var result = [];

  for ( p = 0; p < pmax; p += 1 ) {
    for ( c = 0; c < cmax; c += 1 ) {
      result.push( prev[ p ].concat( curr[ c ] ) );
    }
  }
  return ( result );
}; // productReducer()

// ### Public Function

// ### Array Helpers

helpers.array = Object.create( null);

// #### is Array

// Tests if argument `v` is a JS array; returns `true` if it is, otherwise returns `false`.
helpers.array.isArray = function ( v ) {
  return ( ( v !== undefined ) && ( v !== null ) && ( Object.prototype.toString.call( v ) === '[object Array]' ) );
}; // isArray()


// #### sorting helpers

// Set of helpers to sort either numbers or strings. For key/value pairs,
// the format for each element must be `[ key, value ]`.
// Sort helper to sort an array in ascending order.
helpers.array.ascending = function ( a, b ) {
  return ( a > b ) ? 1 :
            ( a === b ) ? 0 : -1;
}; // ascending()

// Sort helper to sort an array in descending order.
helpers.array.descending = function ( a, b ) {
  return ( b > a ) ? 1 :
            ( b === a ) ? 0 : -1;
}; // descending()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **key**.
helpers.array.ascendingOnKey = function ( a, b ) {
  return ( a[ 0 ] > b[ 0 ] ) ? 1 :
            ( a[ 0 ] === b[ 0 ] ) ? 0 : -1;
}; // ascendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in descending order by **key**.
helpers.array.descendingOnKey = function ( a, b ) {
  return ( b[ 0 ] > a[ 0 ] ) ? 1 :
            ( b[ 0 ] === a[ 0 ] ) ? 0 : -1;
}; // descendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **value**.
helpers.array.ascendingOnValue = function ( a, b ) {
  return ( a[ 1 ] > b[ 1 ] ) ? 1 :
            ( a[ 1 ] === b[ 1 ] ) ? 0 : -1;
}; // ascendingOnValue()

// Sort helper to sort an array of `[ key, value ]` in descending order by **value**.
helpers.array.descendingOnValue = function ( a, b ) {
  return ( b[ 1 ] > a[ 1 ] ) ? 1 :
            ( b[ 1 ] === a[ 1 ] ) ? 0 : -1;
}; // descendingOnValue()

// The following two functions generate a suitable function for sorting on a single
// key or on a composite keys (max 2 only). Just a remider, the generated function
// does not sort on two keys; instead it will sort on a key composed of the two
// accessors.
// Sorts in ascending order on `accessor1` & `accessor2` (optional).
helpers.array.ascendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( a[ accessor1 ][ accessor2 ] > b[ accessor1 ][ accessor2 ] ) ? 1 :
              ( a[ accessor1 ][ accessor2 ] === b[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( a[ accessor1 ] > b[ accessor1 ] ) ? 1 :
            ( a[ accessor1 ] === b[ accessor1 ] ) ? 0 : -1;
  } );
}; // ascendingOn()

// Sorts in descending order on `accessor1` & `accessor2` (optional).
helpers.array.descendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( b[ accessor1 ][ accessor2 ] > a[ accessor1 ][ accessor2 ] ) ? 1 :
              ( b[ accessor1 ][ accessor2 ] === a[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( b[ accessor1 ] > a[ accessor1 ] ) ? 1 :
            ( b[ accessor1 ] === a[ accessor1 ] ) ? 0 : -1;
  } );
}; // descendingOn()

// #### pluck

// Plucks specified element from each element of an **array of array**, and
// returns the resultant array. The element is specified by `i` (default `0`) and
// number of elements to pluck are defined by `limit` (default `a.length`).
helpers.array.pluck = function ( a, key, limit ) {
  var k, plucked;
  k = a.length;
  var i = key || 0;
  var lim = limit || k;
  if ( lim > k ) lim = k;
  plucked = new Array( lim );
  for ( k = 0; k < lim; k += 1 ) plucked[ k ] = a[ k ][ i ];
  return plucked;
}; // pluck()

// #### product

// Finds the Cartesian Product of arrays present inside the array `a`. Therefore
// the array `a` must be an array of 1-dimensional arrays. For example,
// `product( [ [ 9, 8 ], [ 1, 2 ] ] )`
// will produce `[ [ 9, 1 ], [ 9, 2 ], [ 8, 1 ], [ 8, 2 ] ]`.
helpers.array.product = function ( a ) {
  return (
    a.reduce( productReducer, [ [] ] )
  );
};

// #### shuffle

// Randomly shuffles the elements of an array and returns the same.
// Reference: Chapter on Random Numbers/Shuffling in Seminumerical algorithms.
// The Art of Computer Programming Volume II by Donald E Kunth
helpers.array.shuffle = function ( array ) {
  var a = array;
  var balance = a.length;
  var candidate;
  var temp;

  while ( balance ) {
    candidate = Math.floor( Math.random() * balance );
    balance -= 1;

    temp = a[ balance ];
    a[ balance ] = a[ candidate ];
    a[ candidate ] = temp;
  }

  return ( a );
};


// ### Object Helpers

var objectKeys = Object.keys;
var objectCreate = Object.create;

helpers.object = Object.create( null );

// #### is Object

// Tests if argument `v` is a JS object; returns `true` if it is, otherwise returns `false`.
helpers.object.isObject = function ( v ) {
  return ( v && ( Object.prototype.toString.call( v ) === '[object Object]' ) ) ? true : false; // eslint-disable-line no-unneeded-ternary

}; // isObject()

// #### keys

// Returns keys of the `obj` in an array.
helpers.object.keys = function ( obj ) {
  return ( objectKeys( obj ) );
}; // keys()

// #### size

// Returns the number of keys of the `obj`.
helpers.object.size = function ( obj ) {
  return ( ( objectKeys( obj ) ).length );
}; // size()

// #### values

// Returns all values from each key/value pair of the `obj` in an array.
helpers.object.values = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var values = new Array( length );
  for ( var i = 0; i < length; i += 1 ) {
    values[ i ] = obj[ keys[ i ] ];
  }
  return values;
}; // values()

// #### value Freq

// Returns the frequency of each unique value present in the `obj`, where the
// **key** is the *value* and **value** is the *frequency*.
helpers.object.valueFreq = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var val;
  var vf = objectCreate( null );
  for ( var i = 0; i < length; i += 1 ) {
    val = obj[ keys[ i ] ];
    vf[ val ] = 1 + ( vf[ val ] || 0 );
  }
  return vf;
}; // valueFreq()

// #### table

// Converts the `obj` in to an array of `[ key, value ]` pairs in form of a table.
// Second argument - `f` is optional and it is a function, which is called with
// each `value`.
helpers.object.table = function ( obj, f ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var pairs = new Array( length );
  var ak, av;
  for ( var i = 0; i < length; i += 1 ) {
    ak = keys[ i ];
    av = obj[ ak ];
    if ( typeof f === 'function' ) f( av );
    pairs[ i ] = [ ak, av ];
  }
  return pairs;
}; // table()

// ### Validation Helpers

helpers.validate = Object.create( null );

// Create aliases for isObject and isArray.
helpers.validate.isObject = helpers.object.isObject;
helpers.validate.isArray = helpers.array.isArray;

// #### isFiniteInteger

// Validates if `n` is a finite integer.
helpers.validate.isFiniteInteger = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n ) &&
    ( n === Math.round( n ) )
  );
}; // isFiniteInteger()

// #### isFiniteNumber

// Validates if `n` is a valid number.
helpers.validate.isFiniteNumber = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n )
  );
}; // isFiniteNumber()

// ### cross validation
/**
 *
 * Creates an instance of cross validator useful for machine learning tasks.
 *
 * @param {string[]} classLabels - array containing all the class labels.
 * @return {methods} object conatining set of API methods for tasks like evalutaion,
 * reset and metrics generation.
*/
helpers.validate.cross = function ( classLabels ) {
  // wink's const for unknown predictions!
  const unknown = 'unknown';
  // To ensure that metrics is not computed prior to evaluation.
  var evaluated = false;
  // The confusion matrix.
  var cm;
  var precision;
  var recall;
  var fmeasure;

  // The class labels is assigned to this variable.
  var labels;
  // The length of `labels` array.
  var labelCount;
  var labelsObj = Object.create( null );

  // Returned!
  var methods = Object.create( null );


  /**
   *
   * Resets the current instance for another round of evaluation; the class
   * labels defined at instance creation time are not touched.
   *
   * @return {undefined} nothing!
  */
  var reset = function ( ) {
    evaluated = false;
    cm = Object.create( null );
    precision = Object.create( null );
    recall = Object.create( null );
    fmeasure = Object.create( null );

    // Initialize confusion matrix and metrics.
    for ( var i = 0; i < labelCount; i += 1 ) {
      const row = labels[ i ];
      labelsObj[ row ] = true;
      cm[ row ] = Object.create( null );
      precision[ row ] = 0;
      recall[ row ] = 0;
      fmeasure[ row ] = 0;
      for ( var j = 0; j < labelCount; j += 1 ) {
        const col = labels[ j ];
        cm[ row ][ col ] = 0;
      }
    }
  }; // reset()

  /**
   *
   * Creates an instance of cross validator useful for machine learning tasks.
   *
   * @param {string} truth - the actual class label.
   * @param {string} guess - the predicted class label.
   * @return {boolean} returns true if the evaluation is successful. The evaluation
   * may fail if `truth` or `guess` is not in the array `classLabels` provided at
   * instance creation time; or if guess is equal to `unknown`.
  */
  var evaluate = function ( truth, guess ) {
    // If prediction failed then return false!
    if ( guess === unknown || !labelsObj[ truth ] || !labelsObj[ guess ] ) return false;
    // Update confusion matrix.
    if ( guess === truth ) {
      cm[ truth ][ guess ] += 1;
    } else {
      cm[ guess ][ truth ] += 1;
    }
    evaluated = true;
    return true;
  }; // evaluate()

  /**
   *
   * It computes a detailed metrics consisting of macro-averaged precision,
   * recall and f-measure along with their label-wise values and the confusion
   * matrix.
   *
   * @return {object} object containing macro-averaged `avgPrecision`, `avgRecall`,
   * `avgFMeasure` values along with other details such as label-wise values
   * and the confusion matrix. A value of `null` is returned if no evaluate()
   * has been called before.
  */
  var metrics = function ( ) {
    if ( !evaluated ) return null;
    // Numerators for every label; they are same for precision & recall both.
    var n = Object.create( null );
    // Only denominators differs for precision & recall
    var pd = Object.create( null );
    var rd = Object.create( null );
    // `row` and `col` of confusion matrix.
    var col, row;
    var i, j;
    // Macro average values for metrics.
    var avgPrecision = 0;
    var avgRecall = 0;
    var avgFMeasure = 0;

    // Compute label-wise numerators & denominators!
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      for ( j = 0; j < labelCount; j += 1 ) {
        col = labels[ j ];
        if ( row === col ) {
          n[ row ] = cm[ row ][ col ];
        }
        pd[ row ] = cm[ row ][ col ] + ( pd[ row ] || 0 );
        rd[ row ] = cm[ col ][ row ] + ( rd[ row ] || 0 );
      }
    }
    // Ready to compute metrics.
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      precision[ row ] = +( n[ row ] / pd[ row ] ).toFixed( 4 );
      // NaN can occur if a label has not been encountered.
      if ( isNaN( precision[ row ] ) ) precision[ row ] = 0;

      recall[ row ] = +( n[ row ] / rd[ row ] ).toFixed( 4 );
      if ( isNaN( recall[ row ] ) ) recall[ row ] = 0;

      fmeasure[ row ] = +( 2 * precision[ row ] * recall[ row ] / ( precision[ row ] + recall[ row ] ) ).toFixed( 4 );
      if ( isNaN( fmeasure[ row ] ) ) fmeasure[ row ] = 0;
    }
    // Compute thier averages, note they will be macro avegages.
    for ( i = 0; i < labelCount; i += 1 ) {
      avgPrecision += ( precision[ labels[ i ] ] / labelCount );
      avgRecall += ( recall[ labels[ i ] ] / labelCount );
      avgFMeasure += ( fmeasure[ labels[ i ] ] / labelCount );
    }
    // Return metrics.
    return (
      {
        // Macro-averaged metrics.
        avgPrecision: +avgPrecision.toFixed( 4 ),
        avgRecall: +avgRecall.toFixed( 4 ),
        avgFMeasure: +avgFMeasure.toFixed( 4 ),
        details: {
          // Confusion Matrix.
          confusionMatrix: cm,
          // Label wise metrics details, from those averages were computed.
          precision: precision,
          recall: recall,
          fmeasure: fmeasure
        }
      }
    );
  }; // metrics()

  if ( !helpers.validate.isArray( classLabels ) ) {
    throw Error( 'cross validate: class labels must be an array.' );
  }
  if ( classLabels.length < 2 ) {
    throw Error( 'cross validate: at least 2 class labels are required.' );
  }
  labels = classLabels;
  labelCount = labels.length;

  reset();

  methods.reset = reset;
  methods.evaluate = evaluate;
  methods.metrics = metrics;

  return methods;
}; // cross()

// ### Object Helpers

helpers.string = Object.create( null );

// Regex for [diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) removal.
var rgxDiacritical = /[\u0300-\u036f]/g;

/**
 *
 * Normalizes the token's value by converting it to lower case and stripping
 * the diacritical marks (if any).
 *
 * @param {string} str — that needs to be normalized.
 * @return {string} the normalized value.
 * @example
 * normalize( 'Nestlé' );
 * // -> nestle
*/
helpers.string.normalize = function ( str ) {
  return (
    str.toLowerCase().normalize( 'NFD' ).replace( rgxDiacritical, '' )
  );
}; // normalize()

helpers.getOptions = function (options,selected) {
  var options2 = {}
  selected.forEach(function (opt) { options2[opt]=options[opt] })
  return options2;
}
helpers.updateOptions = function (options,update) {
  for(var p in options) if (update[p]!=undefined) options[p]=update[p];
  return options;
}
module.exports = helpers;
};
BundleModuleCode['plugins/ml/stats']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $CREATED:     (C) 2006-2021 bLAB by sbosse
 **    $VERSION:     1.3.1X
 **
 **    $INFO:
 **
 **  ML Data Statistics and Utils 
 **
 **  New:
 **    type eps = number | number []
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Comp = Require('com/compat');
var math = Require('plugins/ml/math');

///////// UTILS ////////////
var stat = {
	max: function(array) {
		return Math.max.apply(null, array);
	},
	
	min: function(array) {
		return Math.min.apply(null, array);
	},
	
	range: function(array) {
		return stat.max(array) - stat.min(array);
	},
	
	midrange: function(array) {
		return stat.range(array) / 2;
	},

	sum: function(array) {
		var num = 0;
		for (var i = 0, l = array.length; i < l; i++) num += array[i];
		return num;
	},
	
	mean: function(array) {
		return stat.sum(array) / array.length;
	},
	
	median: function(array) {
		array.sort(function(a, b) {
			return a - b;
		});
		var mid = array.length / 2;
		return mid % 1 ? array[mid - 0.5] : (array[mid - 1] + array[mid]) / 2;
	},
	
	modes: function(array) {
		if (!array.length) return [];
		var modeMap = {},
			maxCount = 0,
			modes = [];

		array.forEach(function(val) {
			if (!modeMap[val]) modeMap[val] = 1;
			else modeMap[val]++;

			if (modeMap[val] > maxCount) {
				modes = [val];
				maxCount = modeMap[val];
			}
			else if (modeMap[val] === maxCount) {
				modes.push(val);
				maxCount = modeMap[val];
			}
		});
		return modes;
	},
	
	variance: function(array) {
		var mean = stat.mean(array);
		return stat.mean(array.map(function(num) {
			return Math.pow(num - mean, 2);
		}));
	},
	
	standardDeviation: function(array) {
		return Math.sqrt(stat.variance(array));
	},
	
	meanAbsoluteDeviation: function(array) {
		var mean = stat.mean(array);
		return stat.mean(array.map(function(num) {
			return Math.abs(num - mean);
		}));
	},
  
  nans: function nans(vector) {
    var n=0; for(var i in vector) if (isNaN(vector[i])) n++;
    return n
  },

  zeros : function zeros(vector) {
    var n=0; for(var i in vector) if (vector[i]==0) n++;
    return n
  },
	
	zScores: function(array) {
		var mean = stat.mean(array);
		var standardDeviation = stat.standardDeviation(array);
		return array.map(function(num) {
			return (num - mean) / standardDeviation;
		});
	}
};

// Function aliases:
stat.average = stat.mean;

// generate gaussian noise (Standard Normal variate using Box-Muller transform)
function gaussian(min,max,skew) {
    min=min||0;
    max=max||1;
    skew=skew||1;
    var u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    var num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) num = gaussian(min, max, skew); // resample between 0 and 1 if out of range
    num = Math.pow(num, skew); // Skew
    num *= max - min; // Stretch to fill range
    num += min; // offset to min
    return num;
}

// function ({$x:number}|{value:*,prob;number}[]|number [],boolean) 
// -> {value:*,prob:number}|{index:number, prob:number}
// normalize=1: scale output max=[0,1]
// normalize=2: scale and weight output max*[0,1]

function best(o,normalize) {
  var p,max,pos=0,sum=0,res;
  if (Comp.obj.isArray(o) && typeof o[0]=='number')  {
    max=-Infinity;
    for(p in o) {
      sum += o[p];       
      if (o[p] > max) max=o[p],pos=p;
    }  
    res = {index:pos,prob:max}   
  } else if (Comp.obj.isArray(o) && typeof o[0]=='object')  {
    for(p in o) {
      sum += o[p].prob; 
      if (!max || o[p].prob>max.prob) max=o[p];
    }
    res = {value:max.value,prob:max.prob}
  } else if (Comp.obj.isObj(o)) {
    max=-Infinity;
    for(p in o) {
      sum += o[p];
      if (o[p]>max) max=o[p],pos=p;
    }
    res = {value:pos,prob:max}      
  }
  if (!res) return;
  switch (normalize) {
    case 1: res.prob=res.prob/sum; break;
    case 2: res.prob=res.prob*(res.prob/sum); break;
    default: 
  }
  return res;
}
function bestNormalize(o) { return best(o,1) }


function log2(n) {
  return Math.log(n) / Math.log(2);
}

// Select maximal value of an array by values 
// retuned by optional function applied to array values
function max(array,fun) {        
    var res,max,num;
    for(var i in array) {
        if (fun) num=fun(array[i],i); else num=array[i];
        if (max==undefined) { max=num; res=array[i] } 
        else if (num > max) { max=num; res=array[i] }
    }
    return res;
}

/**
 * Finds element with highest occurrence in a list
 * @private
 */
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;
  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}


function pluck(collection, key) {
  return collection.map(function(object) {
    return object == null ? undefined : object[key];
  });
}

function prob(value, list) {
  var occurrences = list.filter(function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}


function sort(array) {
  return array.sort(function (a,b) { return a<b?-1:1 });
}

function sum (a,b) { return a+b }

function unique(array) {
  var length = array ? array.length : 0;
  function baseUniq(array) {
    var index = -1,
        length = array.length,
        seen,
        result = [];

    seen = result;
    outer:
    while (++index < length) {
      var value = array[index];
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === value) {
          continue outer;
        }
      }
      result.push(value);
    }
    return result;
  }
  if (!length) {
    return [];
  }
  return baseUniq(array);
}

function without () {
  var array,
      values=[];
  for(var i in arguments) {
    if (i==0) array=arguments[0];
    else values.push(arguments[i]);
  }
  return array.filter(function (e) {
    return values.indexOf(e) == -1;
  });
}


////////////////////////////////////////

// Entropy of data vectors
function entropy(vals) {
  var uniqueVals = unique(vals);
  var probs = uniqueVals.map(function(x) {
    return prob(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(sum,0);
}

function entropyN(dist,N) {
  var p, probs=[];
  for(p in dist) probs.push(dist[p]/N);
  var logVals = probs.map(function(p) {
    return p==0?0:-p * log2(p)
  });
  return logVals.reduce(sum, 0);
  
}

function entropyEps(vals,eps) {
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.reduce(sum, 0);
}
// Binray Crossentropy! y0: labelled output, y1: predicted output in [0,1]
function crossEntropy (y0,y1) {
    var reconstructedOutput = y1;
    var a = math.activateTwoMat(y0,reconstructedOutput,function(x,y){
        return x*Math.log(Math.max(1E-6,y));
    });
    var b = math.activateTwoMat(y0,reconstructedOutput,function(x,y){
        return (1-x)*Math.log(1-Math.min(0.9999999999,y));
    });

    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy
}

/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probEps(value, list, eps) {
  // TODO: ranges
  var occurrences = list.filter(function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

function probEps2(value, list, eps) {
  // TODO: ranges
  var occurrences = list.filter( function(element) {
    return overlap(epsVal(value), epsVal(element));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}

// Entropy of target variable partitioned feature vector
function entropyT(data,featureIndex,targetIndex,targets) {
  var en = 0;
  var col =  pluck(data,featureIndex);
  var uniqueVals = unique(col);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2==v) cn++,frac[targets.indexOf(data[row][targetIndex])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.reduce(sum)))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}

function entropyTEps(data,feature,target,targets,eps) {
  var en = 0;
  var col =  pluck(data,feature);
  var uniqueVals = uniqueEps(col,eps);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2>=v-eps && v2<=v+eps) cn++,frac[targets.indexOf(data[row][target])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.reduce(sum)))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}

function features (data,target) {
  var f;
  if (Comp.obj.isObj(data[0])) 
    f=Object.keys(data[0]);
  else if (Comp.obj.isArray(data[0]))
    f=data[0].map(function (x,i) { return String(i) });
  if (f && target != undefined) {
    if (typeof target == 'string')
      f=f.filter(function (a) { return a!=target  });
    else 
      f=f.filter(function (a,i) { return i!=target  });
  }
  return f;
}

// Commonly used formula= et-etn
function gain (data,feature,target,targets) {
  var et = entropy(pluck(data,target));
  return et-entropyT(data,feature,target,targets)
}

function gainEps(data,feature,target,targets,eps) {
  var et = entropy(pluck(data,target));
  return et/entropyTEps(data,feature,target,targets,eps)
}


function maxGainEps(data,features,target,targets,eps) {
  var maxgain=max(features, function(feature,index) {
    var g = gainEps(data,feature,target,targets,selectEps(eps,index));
    return g;
  });
  return maxgain;
}

function partition(data,feature,target,targets) {
  var parts={};
  targets.forEach(function (t) {parts[t]=[]});
  data.forEach(function (row) {
    parts[row[target]].push(row[feature]);
  })
  return parts
}

function partitionEps(data,feature,target,targets,eps) {
  var p,parts={}
  targets.forEach(function (t) {parts[t]={range:[Number.MAX_VALUE,-Number.MAX_VALUE],values:[]}});
  data.forEach(function (row) {
    parts[row[target]].values.push(row[feature]);
    parts[row[target]].range[0]=Math.min(parts[row[target]].range[0],row[feature]);
    parts[row[target]].range[1]=Math.max(parts[row[target]].range[1],row[feature]);
  })
  for(p in parts) {
    parts[p].unique=uniqueEps(parts[p].values,eps)
    parts[p].noise=2*stat.standardDeviation(parts[p].values);
  }
  return parts
}

// Return only eps-not-overlapping parititions - the most significant are selected 
// (with the lowest unique column values) 
function partitionUniqueEps(data,feature,target,targets,eps) {
  var p, q, parts={}
  // 1. Create all partitions 
  targets.forEach(function (t) {parts[t]={range:[Number.MAX_VALUE,-Number.MAX_VALUE],values:[]}});
  data.forEach(function (row) {
    parts[row[target]].values.push(row[feature]);
    parts[row[target]].range[0]=Math.min(parts[row[target]].range[0],row[feature]);
    parts[row[target]].range[1]=Math.max(parts[row[target]].range[1],row[feature]);
  })
  for(p in parts) {
    parts[p].unique=uniqueEps(parts[p].values,eps)
  }
  // 2. Remove overlapping partitions
  for(p in parts) {
    if (!parts[p]) continue;
    for (q in parts) {
      if (!parts[p]) break;
      if (p==q || !parts[q]) continue;
      if ((parts[p].range[0]-eps)<parts[q].range[1] ||
          (parts[p].range[1]+eps)>parts[q].range[0]) {
        // overlapping, select the part with best unique column values
        if ((parts[p].unique.length/parts[p].values.length)<
            (parts[q].unique.length/parts[q].values.length)) {
          //print('delete '+q)
          delete parts[q];
        } else {
          //print('delete '+p)
          delete parts[p];
        }
      }
    }
  }  
  return parts
}

function select (data,what) {
  if (Comp.obj.isArray(what) && what.length==2) {
    var c0=what[0],c1=what[1];
    return data.map(function (row) {
      return row.slice(c0,c1+1);
    })
  } 
}

function selectEps (eps,index) {
  if (typeof eps == 'number') return eps;
  else return eps[index]
}

/** Split a data set by finding the best feature (column) 
 *  based on maximal gain/entropy calculation of columns. 
 *  type eps = number | number []
 */

function splitEps (data,features,target,targets,eps) {
  var bestFeature = maxGainEps(data,features,target,targets,eps);
  var index = features.indexOf(bestFeature);
  eps = selectEps(eps,index);
  var remainingFeatures = without(features, bestFeature);
  var possibleValues = sort(uniqueEps(pluck(data, bestFeature),eps));
  var choices = possibleValues.map( function(v) {
    var dataS = data.filter(function(x) {
      return Math.abs(x[bestFeature] - v) <= eps
    });
    return {
      val:v,
      data:dataS,
    }
  });
  return {
    feature:bestFeature,
    choices:choices,
    possibleValues:possibleValues,
    remainingFeatures:remainingFeatures
  };
}

function uniqueEps(array,eps) {
  var result=[];
  array.forEach(function (x) {
    var found;
    if (!result.length) result.push(x);
    else {
      result.forEach(function (y) {
        if (found) return;
        found = Math.abs(x-y)<=eps;
      }); 
      if (!found) result.push(x);
    }
  });
  return result;
}



module.exports =  {
  analyze : function (data,features,target,eps) {
    var noise=[];
    if (!eps) eps=0;
    var targets = unique(pluck(data,target));
    var parts = {}, partsUnique = {},diversity={}
    features.forEach(function (feature) {
      partsUnique[feature]=partitionUniqueEps(data,feature,target,targets,eps);
      parts[feature]=partitionEps(data,feature,target,targets,eps);
      for(var p in parts[feature]) noise.push(parts[feature][p].noise);
    })
    features.forEach(function (feature) {
      diversity[feature]=Object.keys(partsUnique[feature]).length;
    })
   
    return {
      features:features,
      partitions:parts, // for each data column
      diversity:diversity,
      noise:stat.mean(noise)
    }
  },
  crossEntropy: crossEntropy,
  entropy:entropy,
  entropyN:entropyN,
  entropyEps:entropyEps,
  entropyTEps:entropyTEps,
  entropyT:entropyT,
  features:features,
  gain:gain,
  gainEps:gainEps,
  maxGainEps:maxGainEps,
  mostCommon:mostCommon,
  partition:partition,
  partitionEps:partitionEps,
  partitionUniqueEps:partitionUniqueEps,
  splitEps:splitEps,
  unique:unique,
  uniqueEps:uniqueEps,
  utils : {
    // return column by key of a matrix (array array|record array) 
    best:best,
    bestNormalize:bestNormalize,
    column:pluck,
    gaussian:gaussian,
    log2:log2,
    prob:prob,
    // transform [v][] -> v[]
    relax: function (mat) {
      if (Comp.obj.isMatrix(mat) && mat[0].length==1) return mat.map(function (row) { return row[0]})
      else return mat;
    },
    select:select,
    selectEps:selectEps,
    sort:sort,
    stat:stat,
    without:without,
    // transform v[] -> [v][]
    wrap: function (mat) {
      if (!Comp.obj.isMatrix(mat)) return mat.map(function (v) { return [v]})
      else return mat
    },
  },
  version:'1.2.4X',
};

};
BundleModuleCode['plugins/ml/cnn']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $CREATED:     (C) 2006-2022 bLAB by sbosse
 **    $VERSION:     1.3.2X
 **
 **    $INFO:
 **
 ** Convolutional neural network ML Algorithm Wrapper
 **
 ** Incremental learner using ml.update! Initial training data via ml.learn (or empty data set, just using ml.learner) 
 **
 ** Not portable!
 ** 
 **    $ENDOFINFO
 */
'use strict';
var Io = Require('com/io');
var Comp = Require('com/compat');
var current=none;
var Aios=none;
var _ = undefined;
var none = null;

var convnetjs = Require('plugins/ml/convnet')
var that;

function isTypedArray(o) {
  return typeof o == 'object' && o.buffer && Utils.isBufferArray(o.buffer)
}
function isLinearArray (row0) {
  if (row0.data) row0=row0.data;
  return Utils.isBufferArray(row0) || 
         isTypedArray(row0) ||
         (row0 instanceof Array && typeof row0[0]=='number')
}
that = module.exports =  {
  stats : {
    convFloat : 0,
    scale : 0,
    volRef : 0,
    volCopy : 0,
  },
  // typeof options = {x:[][],y:[],width,height,depth,normalize?:[a,b],layers:{}[]..}
  // format x = [ [row1=[col1=[z1,z2,..],col2,..],row2,..] ]
  create : function (options) {
    if (options.datatype) convnetjs.datatype=options.datatype;
    var net = new convnetjs.Net();
    if (options.network)
      // restore network from JSON model
      net.fromJSON(options.network);
    else if (options.layers)
      net.makeLayers(options.layers);
    options.trainer=options.trainer||
    {
      method: 'adadelta', 
      l2_decay: 0.001, 
      batch_size: 1
    }
    var trainer = new convnetjs.SGDTrainer(net, 
                                           options.trainer);
    trainer.options= {
      width     : options.width,
      height    : options.height,
      depth     : options.depth,
      targets   : options.targets,
      normalize : options.normalize,
      layers    : options.layers,
      trainer   : options.trainer,
    };
    return { trainer:trainer, network:net, options:trainer.options };
  },
  
  // convert data to volumes
  convert : function (x,options) {
    function toFloat32(o) {
      if (o.__constructor__=='Math.VectorTA') return Math.VectorTA(o,{datatype:'Float32'});
      if (o.__constructor__=='Math.MatrixTA') return Math.MatrixTA(o,{datatype:'Float32'});
      if (isTypedArray(o)) return new Float32Array(o);
    }
    if (options.depth==undefined) throw ('ML.CNN: no data vol depth specified!');
    switch (options.depth) {
      case 1: // GREY8 []/ number [][]
        var row0=x[0];
        if (isLinearArray(row0)) {
          if ((options.scale || options.normalize) && !Math.isFloat(row0)) {
            // need to convert to Float32
            x=x.map(function (row) { return toFloat32(row) })
            that.stats.convFloat += x.length;
          }
          if (options.scale) {
            x=x.map(function (row) {
              return that.ml.utils.scale(row,options.scale);
            })
            that.stats.scale += x.length;
          } else if (options.normalize) {
            var a,b,
                c=options.normalize[0],
                d=options.normalize[1];
            x.forEach(function (row) {
              var min=Math.min.apply(null,row),
                  max=Math.max.apply(null,row);
              if (a==undefined) a=min; else a=Math.min(a,min);
              if (b==undefined) b=max; else b=Math.max(b,max);        
            })
            options.scale = that.ml.utils.toScale(a,b,c,d);
            x=x.map(function (row) {
              return that.ml.utils.scale(row,options.scale);
            })
            that.stats.scale += x.length;
          }
          x=x.map(function (row) {
            var vol = new convnetjs.Vol(options.width, options.height, options.depth, row.data?row.data:row); //input volume (image)
            // console.log(vol)
            return vol;
          });
          that.stats.volRef += x.length;
        } else if (row0 instanceof Array && row0[0] instanceof Array) {
            // assuming image number [][][] layout
            var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
            var i=0;
            for (var yc=0;yc<options.height;yc++) {
              for (var xc=0;xc<options.width;xx++) {
                var v = row[yc][xc];
                if (options.scale) v=that.ml.utils.scale(v,options.scale);
                vol.set(xc,yc,zc,v);
              }
            }
            that.stats.volCopy += (options.height*options.width);
            return vol;        
        };
        break;
      case 3:   // RGB []/RGBA [] /number [][][] image data
        // options.scale should be provided
        var row0=x[0];
        if (isLinearArray(row0)) {
          if ((options.scale || options.normalize) && !Math.isFloat(row0)) {
            // need to convert to Float32
            x=x.map(function (row) { return toFloat32(row) })
            that.stats.convFloat += x.length;
          }
          var channels = (row0.data||row0).length/(options.width*options.height);
          if (channels==options.depth) {
            // TODO scale, normalize?
            if (options.scale || options.normalize) throw "ML.CNN: scale or normalize not supported for this data";
            x=x.map(function (row) {
              var vol = new convnetjs.Vol(options.width, options.height, options.depth, row.data?row.data:row); //input volume (image)
              return vol;            
            })
            that.stats.volRef += x.length;
          } else {
            x=x.map(function (row) {
              // assuming image RGB/RGBA layout
              var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
              var i=0;
              for (var yc=0;yc<options.height;yc++) {
                for (var xc=0;xc<options.width;xc++) {
                  for (var zc=0;zc<options.depth;zc++) {
                    var v = row[i * channels + zc]; // alpha channel is ignored!?
                    if (options.scale) v=that.ml.utils.scale(v,options.scale);
                    vol.set(xc,yc,zc,v);
                  }
                  i++;
                }
              }
              that.stats.volCopy += (options.height*options.width*options.depth);
              return vol;
            })
          }
        } else if (row0 instanceof Array && row0[0] instanceof Array) {
            // assuming image number [][][] layout
            var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
            var i=0;
            for (var yc=0;yc<options.height;yc++) {
              for (var xc=0;xc<options.width;cx++) {
                for (var zc=0;zc<options.depth;zc++) {
                  var v = row[yc][xc][zc];
                  if (options.scale) v=that.ml.utils.scale(v,options.scale);
                  vol.set(xc,yc,zc,v);
                }
                i++;
              }
            }
            that.stats.volCopy += (options.height*options.width*options.depth);
            return vol;        
        };      
        break;
      default:
        var row0=x[0];
        if (isLinearArray(row0)) {
          if ((options.scale || options.normalize) && !Math.isFloat(row0)) {
            // need to convert to Float32
            x=x.map(function (row) { return toFloat32(row) })
            that.stats.convFloat += x.length;
          }
          var channels = (row0.data||row0).length/(options.width*options.height);
          if (channels==options.depth) {
            // TODO scale, normalize?
            if (options.scale || options.normalize) throw "ML.CNN: scale or normalize not supported for this data";
            x=x.map(function (row) {
              var vol = new convnetjs.Vol(options.width, options.height, options.depth, row.data?row.data:row); //input volume (image)
              return vol;            
            })
            that.stats.volRef += x.length;
          } else {
            x=x.map(function (row) {
              // assuming image RGB/RGBA layout
              var vol = new convnetjs.Vol(options.width, options.height, options.depth, 0.0); //input volume (image)
              var i=0;
              for (var yc=0;yc<options.height;yc++) {
                for (var xc=0;xc<options.width;xc++) {
                  for (var zc=0;zc<options.depth;zc++) {
                    var v = row[i * channels + zc]; 
                    if (options.scale) v=that.ml.utils.scale(v,options.scale);
                    vol.set(xc,yc,zc,v);
                  }
                  i++;
                }
              }
              that.stats.volCopy += (options.height*options.width*options.depth);
              return vol;
            })
          }
        } else throw "ML.CNN: no way to convert non-linear data";
        break;
    }
    return x;
  },

  // ML module back reference
  ml:{},
  
  predict: function (model,sample) {
    var trainer = model.trainer, options = trainer.options;
    if (Utils.isArray(sample[0])) {
      var vols = that.convert(sample,options);
      return vols.map(function (vol) {
        return trainer.net.forward(vol);      
      })
    } else {
      var vol = that.convert([sample],options)[0];
      return trainer.net.forward(vol);
    }
  },
  
  print: function () {
  },
  
  // !!! updates model parameters (depth, width, height) if not already set on model creation
  train : function (model, options) {
    var trainer = model.trainer, result,
        row0 = options.x && options.x[0];
    if (!options.iterations)  options.iterations=10;
    // Inherit from model.trainer instance
    if (trainer.options.width) options.width=trainer.options.width;
    if (trainer.options.height) options.height=trainer.options.height;
    if (trainer.options.depth) options.depth=trainer.options.depth;
    if (trainer.options.targets) options.targets=trainer.options.targets;
    if (!options.width) {
      if (isLinearArray(row0)) {
        options.width=row0.length;
        options.height=1;
      } else if (row0[0] instanceof Array) {
        options.height=row0.length;
        options.width=row0[0].length;
      }
    }
    if (!options.depth) {
      if (isLinearArray(row0)) {
        options.depth=1;
      } else if (row0[0] instanceof Array) {
        if (row0[0][0] instanceof Array) 
          options.depth=row0[0][0].length;
        else options.depth=1;
      }
    }
    // convert matrix (2dim/3dim) to volume elements
    var x = options.x;
    var y = options.y;
    delete options.x;
    delete options.y;
    x = that.convert(x,options);

    if (!options.targets && !Utils.isArray(y[0]) && typeof y[0] != 'number') {
      // classification: get class label array
      options.targets=that.ml.stats.unique(y).sort(function (a,b) { return a<b?-1:1 });;
    }
    Object.assign(trainer.options,options);
    var stop=false;
    function train (iterations,run) {
      for(var iters=0;iters<iterations;iters++) {
        var t1,t0,lossAvg=0;
        t0=Date.now();
        if (options.targets) {
          // classification
          var stats = options.targets.slice().map(function() { return 0 });
          y.forEach(function (v,i) {
            stats[options.targets.indexOf(v)]++;
            // provide index of class in targets array
            result=trainer.train(x[i],options.targets.indexOf(v));
            lossAvg+=result.loss;
          })
        } else {
          // regression or generic network
          y.forEach(function (v,i) {
            result=trainer.train(x[i],v);
            lossAvg+=result.loss;
          })
        }
        t1=Date.now();
        result.time=trainer.time=(t1-t0);
        result.iteration=run+iters;
        if (options.targets) result.ydist=stats;
        result.lossAvg=lossAvg/y.length;
        trainer.result=result;
        if (options.verbose) Code.print('Iteration #'+result.iteration+' '+inspect(result));
        if (options.callback) {
          var more=options.callback(result,run);
          if (more===false) stop=true;
        }
      }
    }
    if (!options.async) train(options.iterations,0);
    else {
      var runs = 0;
      return Code.loop(function () {
        train(1,runs);
        runs++;
        return !stop && runs < options.iterations;
      },true);
    }
    return result;  
  },
  
  update: function (data) {
  },
  
  current:function (module) { current=module.current; Aios=module;},
  
  version : '1.4.2X',
};
};
BundleModuleCode['plugins/ml/convnet']=function (module,exports,global,process){

/*** https://github.com/karpathy/convnetjs ***/
/*** @blab+ Ver. 1.2.1 ***/

var convnet={
  REVISION: 'ALPHA',
  datatype:'Float64'    // @blab+
}
module.exports=convnet;
"use strict";

/*** convnet_util ***/
// Random number utilities
var return_v = false;
var v_val = 0.0;
var gaussRandom = function() {
  if(return_v) { 
    return_v = false;
    return v_val; 
  }
  var u = 2*Math.random()-1;
  var v = 2*Math.random()-1;
  var r = u*u + v*v;
  if(r == 0 || r > 1) return gaussRandom();
  var c = Math.sqrt(-2*Math.log(r)/r);
  v_val = v*c; // cache this
  return_v = true;
  return u*c;
}
var randf = function(a, b) { return Math.random()*(b-a)+a; }
var randi = function(a, b) { return Math.floor(Math.random()*(b-a)+a); }
var randn = function(mu, std){ return mu+gaussRandom()*std; }

// Array utilities
var zeros = function(n) {
  if(typeof(n)==='undefined' || isNaN(n)) { return []; }
  if(typeof ArrayBuffer === 'undefined') {
    // lacking browser support
    var arr = new Array(n);
    for(var i=0;i<n;i++) { arr[i]= 0; }
    return arr;
  } else {
    return new (convnet.datatype=='Float32'?Float32Array:Float64Array)(n);
  }
}

var arrContains = function(arr, elt) {
  for(var i=0,n=arr.length;i<n;i++) {
    if(arr[i]===elt) return true;
  }
  return false;
}

var arrUnique = function(arr) {
  var b = [];
  for(var i=0,n=arr.length;i<n;i++) {
    if(!arrContains(b, arr[i])) {
      b.push(arr[i]);
    }
  }
  return b;
}

// return max and min of a given non-empty array.
var maxmin = function(w) {
  if(w.length === 0) { return {}; } // ... ;s
  var maxv = w[0];
  var minv = w[0];
  var maxi = 0;
  var mini = 0;
  var n = w.length;
  for(var i=1;i<n;i++) {
    if(w[i] > maxv) { maxv = w[i]; maxi = i; } 
    if(w[i] < minv) { minv = w[i]; mini = i; } 
  }
  return {maxi: maxi, maxv: maxv, mini: mini, minv: minv, dv:maxv-minv};
}

// create random permutation of numbers, in range [0...n-1]
var randperm = function(n) {
  var i = n,
      j = 0,
      temp;
  var array = [];
  for(var q=0;q<n;q++)array[q]=q;
  while (i--) {
      j = Math.floor(Math.random() * (i+1));
      temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;
}

// sample from list lst according to probabilities in list probs
// the two lists are of same size, and probs adds up to 1
var weightedSample = function(lst, probs) {
  var p = randf(0, 1.0);
  var cumprob = 0.0;
  for(var k=0,n=lst.length;k<n;k++) {
    cumprob += probs[k];
    if(p < cumprob) { return lst[k]; }
  }
}

// syntactic sugar function for getting default parameter values
var getopt = function(opt, field_name, default_value) {
  if(typeof field_name === 'string') {
    // case of single string
    return (typeof opt[field_name] !== 'undefined') ? opt[field_name] : default_value;
  } else {
    // assume we are given a list of string instead
    var ret = default_value;
    for(var i=0;i<field_name.length;i++) {
      var f = field_name[i];
      if (typeof opt[f] !== 'undefined') {
        ret = opt[f]; // overwrite return value
      }
    }
    return ret;
  }
}

function assert(condition, message) {
  if (!condition) {
    message = message || "Assertion failed";
    if (typeof Error !== "undefined") {
      throw new Error(message);
    }
    throw message; // Fallback
  }
}
// @blab+
function isArray(o) {
  return (typeof o == 'object') && (o.buffer instanceof ArrayBuffer || o instanceof Array)
}
function isTypedArray(o) {
  return o && o.buffer instanceof ArrayBuffer
}

convnet.randf = randf;
convnet.randi = randi;
convnet.randn = randn;
convnet.zeros = zeros;
convnet.maxmin = maxmin;
convnet.randperm = randperm;
convnet.weightedSample = weightedSample;
convnet.arrUnique = arrUnique;
convnet.arrContains = arrContains;
convnet.getopt = getopt;
convnet.assert = assert;

/*** convnet_vol ***/
// Vol is the basic building block of all data in a net.
// it is essentially just a 3D volume of numbers, with a
// width (sx), height (sy), and depth (depth).
// it is used to hold data for all filters, all volumes,
// all weights, and also stores all gradients w.r.t. 
// the data. c is optionally a value to initialize the volume
// with. If c is missing, fills the Vol with random numbers.
var Vol = function(sx, sy, depth, c) {
  // this is how you check if a variable is an array. Oh, Javascript :)
  // if(Object.prototype.toString.call(sx) === '[object Array]') {
  if (isArray(sx)) {
    // we were given a list in sx, assume 1D volume and fill it up
    this.sx = 1;
    this.sy = 1;
    this.depth = sx.length;
    // we have to do the following copy because we want to use
    // fast typed arrays, not an ordinary javascript array
    this.w = convnet.zeros(this.depth);
    this.dw = convnet.zeros(this.depth);
    for(var i=0;i<this.depth;i++) {
      this.w[i] = sx[i];
    }
  } else {
    // we were given dimensions of the vol
    this.sx = sx;
    this.sy = sy;
    this.depth = depth;
    var n = sx*sy*depth;
    // @blab+
    if (isArray(c)) {
      this.w  = c;
      this.dw = convnet.zeros(n);
      return;
    } else {
      this.w  = convnet.zeros(n);
      this.dw = convnet.zeros(n);
    }
    if(typeof c === 'undefined') {
      // weight normalization is done to equalize the output
      // variance of every neuron, otherwise neurons with a lot
      // of incoming connections have outputs of larger variance
      var scale = Math.sqrt(1.0/(sx*sy*depth));
      for(var i=0;i<n;i++) { 
        this.w[i] = convnet.randn(0.0, scale);
      }
    } else if (c!=0) {
      for(var i=0;i<n;i++) { 
        this.w[i] = c;
      }
    }
  }
}

Vol.prototype = {
  get: function(x, y, d) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    return this.w[ix];
  },
  set: function(x, y, d, v) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    this.w[ix] = v; 
  },
  add: function(x, y, d, v) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    this.w[ix] += v; 
  },
  get_grad: function(x, y, d) { 
    var ix = ((this.sx * y)+x)*this.depth+d;
    return this.dw[ix]; 
  },
  set_grad: function(x, y, d, v) { 
    var ix = ((this.sx * y)+x)*this.depth+d;
    this.dw[ix] = v; 
  },
  add_grad: function(x, y, d, v) { 
    var ix = ((this.sx * y)+x)*this.depth+d;
    this.dw[ix] += v; 
  },
  cloneAndZero: function() { return new Vol(this.sx, this.sy, this.depth, 0.0)},
  clone: function() {
    var V = new Vol(this.sx, this.sy, this.depth, 0.0);
    var n = this.w.length;
    for(var i=0;i<n;i++) { V.w[i] = this.w[i]; }
    return V;
  },
  addFrom: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] += V.w[k]; }},
  addFromScaled: function(V, a) { for(var k=0;k<this.w.length;k++) { this.w[k] += a*V.w[k]; }},
  setConst: function(a) { for(var k=0;k<this.w.length;k++) { this.w[k] = a; }},

  toJSON: function() {
    // todo: we may want to only save d most significant digits to save space
    var json = {}
    json.sx = this.sx; 
    json.sy = this.sy;
    json.depth = this.depth;
    json.w = this.w;
    return json;
    // we wont back up gradients to save space
  },
  fromJSON: function(json) {
    this.sx = json.sx;
    this.sy = json.sy;
    this.depth = json.depth;

    var n = this.sx*this.sy*this.depth;
    this.w = convnet.zeros(n);
    this.dw = convnet.zeros(n);
    // copy over the elements.
    for(var i=0;i<n;i++) {
      this.w[i] = json.w[i];
    }
  }
}

convnet.Vol = Vol;

/*** convnet_vol_util ***/
var Vol = convnet.Vol; // convenience

// Volume utilities
// intended for use with data augmentation
// crop is the size of output
// dx,dy are offset wrt incoming volume, of the shift
// fliplr is boolean on whether we also want to flip left<->right
var augment = function(V, crop, dx, dy, fliplr) {
  // note assumes square outputs of size crop x crop
  if(typeof(fliplr)==='undefined') var fliplr = false;
  if(typeof(dx)==='undefined') var dx = convnet.randi(0, V.sx - crop);
  if(typeof(dy)==='undefined') var dy = convnet.randi(0, V.sy - crop);
  
  // randomly sample a crop in the input volume
  var W;
  if(crop !== V.sx || dx!==0 || dy!==0) {
    W = new Vol(crop, crop, V.depth, 0.0);
    for(var x=0;x<crop;x++) {
      for(var y=0;y<crop;y++) {
        if(x+dx<0 || x+dx>=V.sx || y+dy<0 || y+dy>=V.sy) continue; // oob
        for(var d=0;d<V.depth;d++) {
         W.set(x,y,d,V.get(x+dx,y+dy,d)); // copy data over
        }
      }
    }
  } else {
    W = V;
  }

  if(fliplr) {
    // flip volume horziontally
    var W2 = W.cloneAndZero();
    for(var x=0;x<W.sx;x++) {
      for(var y=0;y<W.sy;y++) {
        for(var d=0;d<W.depth;d++) {
         W2.set(x,y,d,W.get(W.sx - x - 1,y,d)); // copy data over
        }
      }
    }
    W = W2; //swap
  }
  return W;
}

// img is a DOM element that contains a loaded image
// returns a Vol of size (W, H, 4). 4 is for RGBA
var img_to_vol = function(img, convert_grayscale) {

  if(typeof(convert_grayscale)==='undefined') var convert_grayscale = false;

  var canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  var ctx = canvas.getContext("2d");

  // due to a Firefox bug
  try {
    ctx.drawImage(img, 0, 0);
  } catch (e) {
    if (e.name === "NS_ERROR_NOT_AVAILABLE") {
      // sometimes happens, lets just abort
      return false;
    } else {
      throw e;
    }
  }

  try {
    var img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
  } catch (e) {
    if(e.name === 'IndexSizeError') {
      return false; // not sure what causes this sometimes but okay abort
    } else {
      throw e;
    }
  }

  // prepare the input: get pixels and normalize them
  var p = img_data.data;
  var W = img.width;
  var H = img.height;
  var pv = []
  for(var i=0;i<p.length;i++) {
    pv.push(p[i]/255.0-0.5); // normalize image pixels to [-0.5, 0.5]
  }
  var x = new Vol(W, H, 4, 0.0); //input volume (image)
  x.w = pv;

  if(convert_grayscale) {
    // flatten into depth=1 array
    var x1 = new Vol(W, H, 1, 0.0);
    for(var i=0;i<W;i++) {
      for(var j=0;j<H;j++) {
        x1.set(i,j,0,x.get(i,j,0));
      }
    }
    x = x1;
  }

  return x;
}

convnet.augment = augment;
convnet.img_to_vol = img_to_vol;


/*** convnet_layers_dotproducts ***/
// This file contains all layers that do dot products with input,
// but usually in a different connectivity pattern and weight sharing
// schemes: 
// - FullyConn is fully connected dot products 
// - ConvLayer does convolutions (so weight sharing spatially)
// putting them together in one file because they are very similar
var ConvLayer = function(opt) {
  var opt = opt || {};

  // required
  this.out_depth = opt.filters;
  this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;
  
  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input
  // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed
  // final application.
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'conv';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i<this.out_depth;i++) { this.filters.push(new Vol(this.sx, this.sy, this.in_depth)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}
ConvLayer.prototype = {
  forward: function(V, is_training) {
    // optimized code by @mdda that achieves 2x speedup over previous version

    this.in_act = V;
    var A = new Vol(this.out_sx |0, this.out_sy |0, this.out_depth |0, 0.0);
    
    var V_sx = V.sx |0;
    var V_sy = V.sy |0;
    var xy_stride = this.stride |0;

    for(var d=0;d<this.out_depth;d++) {
      var f = this.filters[d];
      var x = -this.pad |0;
      var y = -this.pad |0;
      for(var ay=0; ay<this.out_sy; y+=xy_stride,ay++) {  // xy_stride
        x = -this.pad |0;
        for(var ax=0; ax<this.out_sx; x+=xy_stride,ax++) {  // xy_stride

          // convolve centered at this particular location
          var a = 0.0;
          for(var fy=0;fy<f.sy;fy++) {
            var oy = y+fy; // coordinates in the original input array coordinates
            for(var fx=0;fx<f.sx;fx++) {
              var ox = x+fx;
              if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {
                for(var fd=0;fd<f.depth;fd++) {
                  // avoid function call overhead (x2) for efficiency, compromise modularity :(
                  a += f.w[((f.sx * fy)+fx)*f.depth+fd] * V.w[((V_sx * oy)+ox)*V.depth+fd];
                }
              }
            }
          }
          a += this.biases.w[d];
          A.set(ax, ay, d, a);
        }
      }
    }
    this.out_act = A;
    return this.out_act;
  },
  backward: function() {

    var V = this.in_act;
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it

    var V_sx = V.sx |0;
    var V_sy = V.sy |0;
    var xy_stride = this.stride |0;

    for(var d=0;d<this.out_depth;d++) {
      var f = this.filters[d];
      var x = -this.pad |0;
      var y = -this.pad |0;
      for(var ay=0; ay<this.out_sy; y+=xy_stride,ay++) {  // xy_stride
        x = -this.pad |0;
        for(var ax=0; ax<this.out_sx; x+=xy_stride,ax++) {  // xy_stride

          // convolve centered at this particular location
          var chain_grad = this.out_act.get_grad(ax,ay,d); // gradient from above, from chain rule
          for(var fy=0;fy<f.sy;fy++) {
            var oy = y+fy; // coordinates in the original input array coordinates
            for(var fx=0;fx<f.sx;fx++) {
              var ox = x+fx;
              if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {
                for(var fd=0;fd<f.depth;fd++) {
                  // avoid function call overhead (x2) for efficiency, compromise modularity :(
                  var ix1 = ((V_sx * oy)+ox)*V.depth+fd;
                  var ix2 = ((f.sx * fy)+fx)*f.depth+fd;
                  f.dw[ix2] += V.w[ix1]*chain_grad;
                  V.dw[ix1] += f.w[ix2]*chain_grad;
                }
              }
            }
          }
          this.biases.dw[d] += chain_grad;
        }
      }
    }
  },
  getParamsAndGrads: function() {
    var response = [];
    for(var i=0;i<this.out_depth;i++) {
      response.push({params: this.filters[i].w, grads: this.filters[i].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul});
    }
    response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
    return response;
  },
  toJSON: function() {
    var json = {};
    json.sx = this.sx; // filter size in x, y dims
    json.sy = this.sy;
    json.stride = this.stride;
    json.in_depth = this.in_depth;
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.l1_decay_mul = this.l1_decay_mul;
    json.l2_decay_mul = this.l2_decay_mul;
    json.pad = this.pad;
    json.filters = [];
    for(var i=0;i<this.filters.length;i++) {
      json.filters.push(this.filters[i].toJSON());
    }
    json.biases = this.biases.toJSON();
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.sx = json.sx; // filter size in x, y dims
    this.sy = json.sy;
    this.stride = json.stride;
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i<json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.fromJSON(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}

var FullyConnLayer = function(opt) {
  var opt = opt || {};

  // required
  // ok fine we will allow 'filters' as the word as well
  this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters;

  // optional 
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'fc';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i<this.out_depth ;i++) { this.filters.push(new Vol(1, 1, this.num_inputs)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}

FullyConnLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var A = new Vol(1, 1, this.out_depth, 0.0);
    var Vw = V.w;
    for(var i=0;i<this.out_depth;i++) {
      var a = 0.0;
      var wi = this.filters[i].w;
      for(var d=0;d<this.num_inputs;d++) {
        a += Vw[d] * wi[d]; // for efficiency use Vols directly for now
      }
      a += this.biases.w[i];
      A.w[i] = a;
    }
    this.out_act = A;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act;
    V.dw = convnet.zeros(V.w.length); // zero out the gradient in input Vol
    
    // compute gradient wrt weights and data
    for(var i=0;i<this.out_depth;i++) {
      var tfi = this.filters[i];
      var chain_grad = this.out_act.dw[i];
      for(var d=0;d<this.num_inputs;d++) {
        V.dw[d] += tfi.w[d]*chain_grad; // grad wrt input data
        tfi.dw[d] += V.w[d]*chain_grad; // grad wrt params
      }
      this.biases.dw[i] += chain_grad;
    }
  },
  getParamsAndGrads: function() {
    var response = [];
    for(var i=0;i<this.out_depth;i++) {
      response.push({params: this.filters[i].w, grads: this.filters[i].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul});
    }
    response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
    return response;
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    json.l1_decay_mul = this.l1_decay_mul;
    json.l2_decay_mul = this.l2_decay_mul;
    json.filters = [];
    for(var i=0;i<this.filters.length;i++) {
      json.filters.push(this.filters[i].toJSON());
    }
    json.biases = this.biases.toJSON();
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.filters = [];
    for(var i=0;i<json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.fromJSON(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}

convnet.ConvLayer = ConvLayer;
convnet.FullyConnLayer = FullyConnLayer;


/*** convnet_layers_pool ***/
var PoolLayer = function(opt) {

  var opt = opt || {};

  // required
  this.sx = opt.sx; // filter size
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;

  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume

  // computed
  this.out_depth = this.in_depth;
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'pool';
  // store switches for x,y coordinates for where the max comes from, for each output neuron
  this.switchx = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
  this.switchy = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
}

PoolLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;

    var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
    
    var n=0; // a counter for switches
    for(var d=0;d<this.out_depth;d++) {
      var x = -this.pad;
      var y = -this.pad;
      for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
        y = -this.pad;
        for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

          // convolve centered at this particular location
          var a = -99999; // hopefully small enough ;\
          var winx=-1,winy=-1;
          for(var fx=0;fx<this.sx;fx++) {
            for(var fy=0;fy<this.sy;fy++) {
              var oy = y+fy;
              var ox = x+fx;
              if(oy>=0 && oy<V.sy && ox>=0 && ox<V.sx) {
                var v = V.get(ox, oy, d);
                // perform max pooling and store pointers to where
                // the max came from. This will speed up backprop 
                // and can help make nice visualizations in future
                if(v > a) { a = v; winx=ox; winy=oy;}
              }
            }
          }
          this.switchx[n] = winx;
          this.switchy[n] = winy;
          n++;
          A.set(ax, ay, d, a);
        }
      }
    }
    this.out_act = A;
    return this.out_act;
  },
  backward: function() { 
    // pooling layers have no parameters, so simply compute 
    // gradient wrt data here
    var V = this.in_act;
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt data
    var A = this.out_act; // computed in forward pass 

    var n = 0;
    for(var d=0;d<this.out_depth;d++) {
      var x = -this.pad;
      var y = -this.pad;
      for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
        y = -this.pad;
        for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

          var chain_grad = this.out_act.get_grad(ax,ay,d);
          V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);
          n++;

        }
      }
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.sx = this.sx;
    json.sy = this.sy;
    json.stride = this.stride;
    json.in_depth = this.in_depth;
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.pad = this.pad;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.sx = json.sx;
    this.sy = json.sy;
    this.stride = json.stride;
    this.in_depth = json.in_depth;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0; // backwards compatibility
    this.switchx = convnet.zeros(this.out_sx*this.out_sy*this.out_depth); // need to re-init these appropriately
    this.switchy = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
  }
}

convnet.PoolLayer = PoolLayer;


/*** convnet_layers_input ***/
var getopt = convnet.getopt;

var InputLayer = function(opt) {
  var opt = opt || {};

  // required: depth
  this.out_depth = getopt(opt, ['out_depth', 'depth'], 0);

  // optional: default these dimensions to 1
  this.out_sx = getopt(opt, ['out_sx', 'sx', 'width'], 1);
  this.out_sy = getopt(opt, ['out_sy', 'sy', 'height'], 1);
  
  // computed
  this.layer_type = 'input';
}
InputLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    this.out_act = V;
    return this.out_act; // simply identity function for now
  },
  backward: function() { },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

convnet.InputLayer = InputLayer;


/*** convnet_layers_loss ***/
// Layers that implement a loss. Currently these are the layers that 
// can initiate a backward() pass. In future we probably want a more 
// flexible system that can accomodate multiple losses to do multi-task
// learning, and stuff like that. But for now, one of the layers in this
// file must be the final layer in a Net.

// This is a classifier, with N discrete classes from 0 to N-1
// it gets a stream of N incoming numbers and computes the softmax
// function (exponentiate and normalize to sum to 1 as probabilities should)
var SoftmaxLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'softmax';
}

SoftmaxLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;

    var A = new Vol(1, 1, this.out_depth, 0.0);

    // compute max activation
    var as = V.w;
    var amax = V.w[0];
    for(var i=1;i<this.out_depth;i++) {
      if(as[i] > amax) amax = as[i];
    }

    // compute exponentials (carefully to not blow up)
    var es = convnet.zeros(this.out_depth);
    var esum = 0.0;
    for(var i=0;i<this.out_depth;i++) {
      var e = Math.exp(as[i] - amax);
      esum += e;
      es[i] = e;
    }

    // normalize and output to sum to one
    for(var i=0;i<this.out_depth;i++) {
      es[i] /= esum;
      A.w[i] = es[i];
    }

    this.es = es; // save these for backprop
    this.out_act = A;
    return this.out_act;
  },
  backward: function(y) {

    // compute and accumulate gradient wrt weights and bias of this layer
    var x = this.in_act;
    x.dw = convnet.zeros(x.w.length); // zero out the gradient of input Vol

    for(var i=0;i<this.out_depth;i++) {
      var indicator = i === y ? 1.0 : 0.0;
      var mul = -(indicator - this.es[i]);
      x.dw[i] = mul;
    }

    // loss is the class negative log likelihood
    return -Math.log(this.es[y]);
  },
  getParamsAndGrads: function() { 
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
  }
}

// implements an L2 regression cost layer,
// so penalizes \sum_i(||x_i - y_i||^2), where x is its input
// and y is the user-provided array of "correct" values.
var RegressionLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'regression';
}

RegressionLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    this.out_act = V;
    return V; // identity function
  },
  // y is a list here of size num_inputs
  // or it can be a number if only one value is regressed
  // or it can be a struct {dim: i, val: x} where we only want to 
  // regress on dimension i and asking it to have value x
  backward: function(y) { 

    // compute and accumulate gradient wrt weights and bias of this layer
    var x = this.in_act;
    x.dw = convnet.zeros(x.w.length); // zero out the gradient of input Vol
    var loss = 0.0;
    if(y instanceof Array || y instanceof Float64Array || y instanceof Float32Array) {
      for(var i=0;i<this.out_depth;i++) {
        var dy = x.w[i] - y[i];
        x.dw[i] = dy;
        loss += 0.5*dy*dy;
      }
    } else if(typeof y === 'number') {
      // lets hope that only one number is being regressed
      var dy = x.w[0] - y;
      x.dw[0] = dy;
      loss += 0.5*dy*dy;
    } else {
      // assume it is a struct with entries .dim and .val
      // and we pass gradient only along dimension dim to be equal to val
      var i = y.dim;
      var yi = y.val;
      var dy = x.w[i] - yi;
      x.dw[i] = dy;
      loss += 0.5*dy*dy;
    }
    return loss;
  },
  getParamsAndGrads: function() { 
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
  }
}

var SVMLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'svm';
}

SVMLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    this.out_act = V; // nothing to do, output raw scores
    return V;
  },
  backward: function(y) {

    // compute and accumulate gradient wrt weights and bias of this layer
    var x = this.in_act;
    x.dw = convnet.zeros(x.w.length); // zero out the gradient of input Vol

    // we're using structured loss here, which means that the score
    // of the ground truth should be higher than the score of any other 
    // class, by a margin
    var yscore = x.w[y]; // score of ground truth
    var margin = 1.0;
    var loss = 0.0;
    for(var i=0;i<this.out_depth;i++) {
      if(y === i) { continue; }
      var ydiff = -yscore + x.w[i] + margin;
      if(ydiff > 0) {
        // violating dimension, apply loss
        x.dw[i] += 1;
        x.dw[y] -= 1;
        loss += ydiff;
      }
    }

    return loss;
  },
  getParamsAndGrads: function() { 
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.num_inputs = this.num_inputs;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type;
    this.num_inputs = json.num_inputs;
  }
}

convnet.RegressionLayer = RegressionLayer;
convnet.SoftmaxLayer = SoftmaxLayer;
convnet.SVMLayer = SVMLayer;


/*** convnet_layers_nonlinearities ***/
// Implements ReLU nonlinearity elementwise
// x -> max(0, x)
// the output is in [0, inf)
var ReluLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'relu';
}
ReluLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.clone();
    var N = V.w.length;
    var V2w = V2.w;
    for(var i=0;i<N;i++) { 
      if(V2w[i] < 0) V2w[i] = 0; // threshold at 0
    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      if(V2.w[i] <= 0) V.dw[i] = 0; // threshold
      else V.dw[i] = V2.dw[i];
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

// Implements Sigmoid nnonlinearity elementwise
// x -> 1/(1+e^(-x))
// so the output is between 0 and 1.
var SigmoidLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'sigmoid';
}
SigmoidLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.cloneAndZero();
    var N = V.w.length;
    var V2w = V2.w;
    var Vw = V.w;
    for(var i=0;i<N;i++) { 
      V2w[i] = 1.0/(1.0+Math.exp(-Vw[i]));
    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      var v2wi = V2.w[i];
      V.dw[i] =  v2wi * (1.0 - v2wi) * V2.dw[i];
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

// Implements Maxout nnonlinearity that computes
// x -> max(x)
// where x is a vector of size group_size. Ideally of course,
// the input size should be exactly divisible by group_size
var MaxoutLayer = function(opt) {
  var opt = opt || {};

  // required
  this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = Math.floor(opt.in_depth / this.group_size);
  this.layer_type = 'maxout';

  this.switches = convnet.zeros(this.out_sx*this.out_sy*this.out_depth); // useful for backprop
}
MaxoutLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var N = this.out_depth; 
    var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);

    // optimization branch. If we're operating on 1D arrays we dont have
    // to worry about keeping track of x,y,d coordinates inside
    // input volumes. In convnets we do :(
    if(this.out_sx === 1 && this.out_sy === 1) {
      for(var i=0;i<N;i++) {
        var ix = i * this.group_size; // base index offset
        var a = V.w[ix];
        var ai = 0;
        for(var j=1;j<this.group_size;j++) {
          var a2 = V.w[ix+j];
          if(a2 > a) {
            a = a2;
            ai = j;
          }
        }
        V2.w[i] = a;
        this.switches[i] = ix + ai;
      }
    } else {
      var n=0; // counter for switches
      for(var x=0;x<V.sx;x++) {
        for(var y=0;y<V.sy;y++) {
          for(var i=0;i<N;i++) {
            var ix = i * this.group_size;
            var a = V.get(x, y, ix);
            var ai = 0;
            for(var j=1;j<this.group_size;j++) {
              var a2 = V.get(x, y, ix+j);
              if(a2 > a) {
                a = a2;
                ai = j;
              }
            }
            V2.set(x,y,i,a);
            this.switches[n] = ix + ai;
            n++;
          }
        }
      }

    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = this.out_depth;
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt data

    // pass the gradient through the appropriate switch
    if(this.out_sx === 1 && this.out_sy === 1) {
      for(var i=0;i<N;i++) {
        var chain_grad = V2.dw[i];
        V.dw[this.switches[i]] = chain_grad;
      }
    } else {
      // bleh okay, lets do this the hard way
      var n=0; // counter for switches
      for(var x=0;x<V2.sx;x++) {
        for(var y=0;y<V2.sy;y++) {
          for(var i=0;i<N;i++) {
            var chain_grad = V2.get_grad(x,y,i);
            V.set_grad(x,y,this.switches[n],chain_grad);
            n++;
          }
        }
      }
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.group_size = this.group_size;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
    this.group_size = json.group_size;
    this.switches = convnet.zeros(this.group_size);
  }
}

// a helper function, since tanh is not yet part of ECMAScript. Will be in v6.
function tanh(x) {
  var y = Math.exp(2 * x);
  return (y - 1) / (y + 1);
}
// Implements Tanh nnonlinearity elementwise
// x -> tanh(x) 
// so the output is between -1 and 1.
var TanhLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'tanh';
}
TanhLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.cloneAndZero();
    var N = V.w.length;
    for(var i=0;i<N;i++) { 
      V2.w[i] = tanh(V.w[i]);
    }
    this.out_act = V2;
    return this.out_act;
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var V2 = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      var v2wi = V2.w[i];
      V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
  }
}

convnet.TanhLayer = TanhLayer;
convnet.MaxoutLayer = MaxoutLayer;
convnet.ReluLayer = ReluLayer;
convnet.SigmoidLayer = SigmoidLayer;




/*** convnet_layers_dropout ***/
// An inefficient dropout layer
// Note this is not most efficient implementation since the layer before
// computed all these activations and now we're just going to drop them :(
// same goes for backward pass. Also, if we wanted to be efficient at test time
// we could equivalently be clever and upscale during train and copy pointers during test
// todo: make more efficient.
var DropoutLayer = function(opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'dropout';
  this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;
  this.dropped = convnet.zeros(this.out_sx*this.out_sy*this.out_depth);
}
DropoutLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    if(typeof(is_training)==='undefined') { is_training = false; } // default is prediction mode
    var V2 = V.clone();
    var N = V.w.length;
    if(is_training) {
      // do dropout
      for(var i=0;i<N;i++) {
        if(Math.random()<this.drop_prob) { V2.w[i]=0; this.dropped[i] = true; } // drop!
        else {this.dropped[i] = false;}
      }
    } else {
      // scale the activations during prediction
      for(var i=0;i<N;i++) { V2.w[i]*=this.drop_prob; }
    }
    this.out_act = V2;
    return this.out_act; // dummy identity function for now
  },
  backward: function() {
    var V = this.in_act; // we need to set dw of this
    var chain_grad = this.out_act;
    var N = V.w.length;
    V.dw = convnet.zeros(N); // zero out gradient wrt data
    for(var i=0;i<N;i++) {
      if(!(this.dropped[i])) { 
        V.dw[i] = chain_grad.dw[i]; // copy over the gradient
      }
    }
  },
  getParamsAndGrads: function() {
    return [];
  },
  toJSON: function() {
    var json = {};
    json.out_depth = this.out_depth;
    json.out_sx = this.out_sx;
    json.out_sy = this.out_sy;
    json.layer_type = this.layer_type;
    json.drop_prob = this.drop_prob;
    return json;
  },
  fromJSON: function(json) {
    this.out_depth = json.out_depth;
    this.out_sx = json.out_sx;
    this.out_sy = json.out_sy;
    this.layer_type = json.layer_type; 
    this.drop_prob = json.drop_prob;
  }
}

convnet.DropoutLayer = DropoutLayer;

/*** convnet_layers_normailzation ***/
// a bit experimental layer for now. I think it works but I'm not 100%
// the gradient check is a bit funky. I'll look into this a bit later.
// Local Response Normalization in window, along depths of volumes
var LocalResponseNormalizationLayer = function(opt) {
  var opt = opt || {};

  // required
  this.k = opt.k;
  this.n = opt.n;
  this.alpha = opt.alpha;
  this.beta = opt.beta;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'lrn';

  // checks
  if(this.n%2 === 0) { console.log('WARNING n should be odd for LRN layer'); }
}
LocalResponseNormalizationLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;

    var A = V.cloneAndZero();
    this.S_cache_ = V.cloneAndZero();
    var n2 = Math.floor(this.n/2);
    for(var x=0;x<V.sx;x++) {
      for(var y=0;y<V.sy;y++) {
        for(var i=0;i<V.depth;i++) {

          var ai = V.get(x,y,i);

          // normalize in a window of size n
          var den = 0.0;
          for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {
            var aa = V.get(x,y,j);
            den += aa*aa;
          }
          den *= this.alpha / this.n;
          den += this.k;
          this.S_cache_.set(x,y,i,den); // will be useful for backprop
          den = Math.pow(den, this.beta);
          A.set(x,y,i,ai/den);
        }
      }
    }

    this.out_act = A;
    return this.out_act; // dummy identity function for now
  },
  backward: function() { 
    // evaluate gradient wrt data
    var V = this.in_act; // we need to set dw of this
    V.dw = convnet.zeros(V.w.length); // zero out gradient wrt data
    var A = this.out_act; // computed in forward pass 

    var n2 = Math.floor(this.n/2);
    for(var x=0;x<V.sx;x++) {
      for(var y=0;y<V.sy;y++) {
        for(var i=0;i<V.depth;i++) {

          var chain_grad = this.out_act.get_grad(x,y,i);
          var S = this.S_cache_.get(x,y,i);
          var SB = Math.pow(S, this.beta);
          var SB2 = SB*SB;

          // normalize in a window of size n
          for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {              
            var aj = V.get(x,y,j); 
            var g = -aj*this.beta*Math.pow(S,this.beta-1)*this.alpha/this.n*2*aj;
            if(j===i) g+= SB;
            g /= SB2;
            g *= chain_grad;
            V.add_grad(x,y,j,g);
          }

        }
      }
    }
  },
  getParamsAndGrads: function() { return []; },
  toJSON: function() {
    var json = {};
    json.k = this.k;
    json.n = this.n;
    json.alpha = this.alpha; // normalize by size
    json.beta = this.beta;
    json.out_sx = this.out_sx; 
    json.out_sy = this.out_sy;
    json.out_depth = this.out_depth;
    json.layer_type = this.layer_type;
    return json;
  },
  fromJSON: function(json) {
    this.k = json.k;
    this.n = json.n;
    this.alpha = json.alpha; // normalize by size
    this.beta = json.beta;
    this.out_sx = json.out_sx; 
    this.out_sy = json.out_sy;
    this.out_depth = json.out_depth;
    this.layer_type = json.layer_type;
  }
}

convnet.LocalResponseNormalizationLayer = LocalResponseNormalizationLayer;



/*** convnet_net ***/
var assert = convnet.assert;

// Net manages a set of layers
// For now constraints: Simple linear order of layers, first layer input last layer a cost layer
var Net = function(options) {
  this.layers = [];
}

Net.prototype = {
  
  // takes a list of layer definitions and creates the network layer objects
  makeLayers: function(defs) {

    // few checks
    assert(defs.length >= 2, 'Error! At least one input layer and one loss layer are required.');
    assert(defs[0].type === 'input', 'Error! First layer must be the input layer, to declare size of inputs');

    // desugar layer_defs for adding activation, dropout layers etc
    var desugar = function() {
      var new_defs = [];
      for(var i=0;i<defs.length;i++) {
        var def = defs[i];
        
        if(def.type==='softmax' || def.type==='svm') {
          // add an fc layer here, there is no reason the user should
          // have to worry about this and we almost always want to
          new_defs.push({type:'fc', num_neurons: def.num_classes});
        }

        if(def.type==='regression') {
          // add an fc layer here, there is no reason the user should
          // have to worry about this and we almost always want to
          new_defs.push({type:'fc', num_neurons: def.num_neurons});
        }

        if((def.type==='fc' || def.type==='conv') 
            && typeof(def.bias_pref) === 'undefined'){
          def.bias_pref = 0.0;
          if(typeof def.activation !== 'undefined' && def.activation === 'relu') {
            def.bias_pref = 0.1; // relus like a bit of positive bias to get gradients early
            // otherwise it's technically possible that a relu unit will never turn on (by chance)
            // and will never get any gradient and never contribute any computation. Dead relu.
          }
        }

        new_defs.push(def);

        if(typeof def.activation !== 'undefined') {
          if(def.activation==='relu') { new_defs.push({type:'relu'}); }
          else if (def.activation==='sigmoid') { new_defs.push({type:'sigmoid'}); }
          else if (def.activation==='tanh') { new_defs.push({type:'tanh'}); }
          else if (def.activation==='maxout') {
            // create maxout activation, and pass along group size, if provided
            var gs = def.group_size !== 'undefined' ? def.group_size : 2;
            new_defs.push({type:'maxout', group_size:gs});
          }
          else { console.log('ERROR unsupported activation ' + def.activation); }
        }
        if(typeof def.drop_prob !== 'undefined' && def.type !== 'dropout') {
          new_defs.push({type:'dropout', drop_prob: def.drop_prob});
        }

      }
      return new_defs;
    }
    defs = desugar(defs);

    // create the layers
    this.layers = [];
    for(var i=0;i<defs.length;i++) {
      var def = defs[i];
      if(i>0) {
        var prev = this.layers[i-1];
        def.in_sx = prev.out_sx;
        def.in_sy = prev.out_sy;
        def.in_depth = prev.out_depth;
      }

      switch(def.type) {
        case 'fc': this.layers.push(new convnet.FullyConnLayer(def)); break;
        case 'lrn': this.layers.push(new convnet.LocalResponseNormalizationLayer(def)); break;
        case 'dropout': this.layers.push(new convnet.DropoutLayer(def)); break;
        case 'input': this.layers.push(new convnet.InputLayer(def)); break;
        case 'softmax': this.layers.push(new convnet.SoftmaxLayer(def)); break;
        case 'regression': this.layers.push(new convnet.RegressionLayer(def)); break;
        case 'conv': this.layers.push(new convnet.ConvLayer(def)); break;
        case 'pool': this.layers.push(new convnet.PoolLayer(def)); break;
        case 'relu': this.layers.push(new convnet.ReluLayer(def)); break;
        case 'sigmoid': this.layers.push(new convnet.SigmoidLayer(def)); break;
        case 'tanh': this.layers.push(new convnet.TanhLayer(def)); break;
        case 'maxout': this.layers.push(new convnet.MaxoutLayer(def)); break;
        case 'svm': this.layers.push(new convnet.SVMLayer(def)); break;
        default: console.log('ERROR: UNRECOGNIZED LAYER TYPE: ' + def.type);
      }
    }
  },

  // forward prop the network. 
  // The trainer class passes is_training = true, but when this function is
  // called from outside (not from the trainer), it defaults to prediction mode
  forward: function(V, is_training) {
    if(typeof(is_training) === 'undefined') is_training = false;
    var act = this.layers[0].forward(V, is_training);
    for(var i=1;i<this.layers.length;i++) {
      act = this.layers[i].forward(act, is_training);
    }
    return act;
  },

  getCostLoss: function(V, y) {
    this.forward(V, false);
    var N = this.layers.length;
    var loss = this.layers[N-1].backward(y);
    return loss;
  },
  
  // backprop: compute gradients wrt all parameters
  backward: function(y) {
    var N = this.layers.length;
    var loss = this.layers[N-1].backward(y); // last layer assumed to be loss layer
    for(var i=N-2;i>=0;i--) { // first layer assumed input
      this.layers[i].backward();
    }
    return loss;
  },
  getParamsAndGrads: function() {
    // accumulate parameters and gradients for the entire network
    var response = [];
    for(var i=0;i<this.layers.length;i++) {
      var layer_reponse = this.layers[i].getParamsAndGrads();
      for(var j=0;j<layer_reponse.length;j++) {
        response.push(layer_reponse[j]);
      }
    }
    return response;
  },
  getPrediction: function() {
    // this is a convenience function for returning the argmax
    // prediction, assuming the last layer of the net is a softmax
    var S = this.layers[this.layers.length-1];
    assert(S.layer_type === 'softmax', 'getPrediction function assumes softmax as last layer of the net!');

    var p = S.out_act.w;
    var maxv = p[0];
    var maxi = 0;
    for(var i=1;i<p.length;i++) {
      if(p[i] > maxv) { maxv = p[i]; maxi = i;}
    }
    return maxi; // return index of the class with highest class probability
  },
  toJSON: function() {
    var json = {};
    json.layers = [];
    for(var i=0;i<this.layers.length;i++) {
      json.layers.push(this.layers[i].toJSON());
    }
    return json;
  },
  fromJSON: function(json) {
    this.layers = [];
    for(var i=0;i<json.layers.length;i++) {
      var Lj = json.layers[i]
      var t = Lj.layer_type;
      var L;
      if(t==='input') { L = new convnet.InputLayer(); }
      if(t==='relu') { L = new convnet.ReluLayer(); }
      if(t==='sigmoid') { L = new convnet.SigmoidLayer(); }
      if(t==='tanh') { L = new convnet.TanhLayer(); }
      if(t==='dropout') { L = new convnet.DropoutLayer(); }
      if(t==='conv') { L = new convnet.ConvLayer(); }
      if(t==='pool') { L = new convnet.PoolLayer(); }
      if(t==='lrn') { L = new convnet.LocalResponseNormalizationLayer(); }
      if(t==='softmax') { L = new convnet.SoftmaxLayer(); }
      if(t==='regression') { L = new convnet.RegressionLayer(); }
      if(t==='fc') { L = new convnet.FullyConnLayer(); }
      if(t==='maxout') { L = new convnet.MaxoutLayer(); }
      if(t==='svm') { L = new convnet.SVMLayer(); }
      L.fromJSON(Lj);
      this.layers.push(L);
    }
  }
}

convnet.Net = Net;


/*** convnet_trainers ***/
var Trainer = function(net, options) {

  this.net = net;

  var options = options || {};
  this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
  this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
  this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
  this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
  this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adam/adagrad/adadelta/windowgrad/netsterov

  this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
  this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
  this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-8; // used in adam or adadelta
  this.beta1 = typeof options.beta1 !== 'undefined' ? options.beta1 : 0.9; // used in adam
  this.beta2 = typeof options.beta2 !== 'undefined' ? options.beta2 : 0.999; // used in adam

  this.k = 0; // iteration counter
  this.gsum = []; // last iteration gradients (used for momentum calculations)
  this.xsum = []; // used in adam or adadelta

  // check if regression is expected 
  if(this.net.layers[this.net.layers.length - 1].layer_type === "regression")
    this.regression = true;
  else
    this.regression = false;
}

Trainer.prototype = {
  train: function(x, y) {

    var start = new Date().getTime();
    this.net.forward(x, true); // also set the flag that lets the net know we're just training
    var end = new Date().getTime();
    var fwd_time = end - start;

    var start = new Date().getTime();
    var cost_loss = this.net.backward(y);
    var l2_decay_loss = 0.0;
    var l1_decay_loss = 0.0;
    var end = new Date().getTime();
    var bwd_time = end - start;

    if(this.regression && y.constructor !== Array)
      console.log("Warning: a regression net requires an array as training output vector.");
    
    this.k++;
    if(this.k % this.batch_size === 0) {

      var pglist = this.net.getParamsAndGrads();

      // initialize lists for accumulators. Will only be done once on first iteration
      if(this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {
        // only vanilla sgd doesnt need either lists
        // momentum needs gsum
        // adagrad needs gsum
        // adam and adadelta needs gsum and xsum
        for(var i=0;i<pglist.length;i++) {
          this.gsum.push(convnet.zeros(pglist[i].params.length));
          if(this.method === 'adam' || this.method === 'adadelta') {
            this.xsum.push(convnet.zeros(pglist[i].params.length));
          } else {
            this.xsum.push([]); // conserve memory
          }
        }
      }

      // perform an update for all sets of weights
      for(var i=0;i<pglist.length;i++) {
        var pg = pglist[i]; // param, gradient, other options in future (custom learning rate etc)
        var p = pg.params;
        var g = pg.grads;

        // learning rate for some parameters.
        var l2_decay_mul = typeof pg.l2_decay_mul !== 'undefined' ? pg.l2_decay_mul : 1.0;
        var l1_decay_mul = typeof pg.l1_decay_mul !== 'undefined' ? pg.l1_decay_mul : 1.0;
        var l2_decay = this.l2_decay * l2_decay_mul;
        var l1_decay = this.l1_decay * l1_decay_mul;

        var plen = p.length;
        for(var j=0;j<plen;j++) {
          l2_decay_loss += l2_decay*p[j]*p[j]/2; // accumulate weight decay loss
          l1_decay_loss += l1_decay*Math.abs(p[j]);
          var l1grad = l1_decay * (p[j] > 0 ? 1 : -1);
          var l2grad = l2_decay * (p[j]);

          var gij = (l2grad + l1grad + g[j]) / this.batch_size; // raw batch gradient

          var gsumi = this.gsum[i];
          var xsumi = this.xsum[i];
          if(this.method === 'adam') {
            // adam update
            gsumi[j] = gsumi[j] * this.beta1 + (1- this.beta1) * gij; // update biased first moment estimate
            xsumi[j] = xsumi[j] * this.beta2 + (1-this.beta2) * gij * gij; // update biased second moment estimate
            var biasCorr1 = gsumi[j] * (1 - Math.pow(this.beta1, this.k)); // correct bias first moment estimate
            var biasCorr2 = xsumi[j] * (1 - Math.pow(this.beta2, this.k)); // correct bias second moment estimate
            var dx =  - this.learning_rate * biasCorr1 / (Math.sqrt(biasCorr2) + this.eps);
            p[j] += dx;
          } else if(this.method === 'adagrad') {
            // adagrad update
            gsumi[j] = gsumi[j] + gij * gij;
            var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij;
            p[j] += dx;
          } else if(this.method === 'windowgrad') {
            // this is adagrad but with a moving window weighted average
            // so the gradient is not accumulated over the entire history of the run. 
            // it's also referred to as Idea #1 in Zeiler paper on Adadelta. Seems reasonable to me!
            gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
            var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij; // eps added for better conditioning
            p[j] += dx;
          } else if(this.method === 'adadelta') {
            gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
            var dx = - Math.sqrt((xsumi[j] + this.eps)/(gsumi[j] + this.eps)) * gij;
            xsumi[j] = this.ro * xsumi[j] + (1-this.ro) * dx * dx; // yes, xsum lags behind gsum by 1.
            p[j] += dx;
          } else if(this.method === 'nesterov') {
          	var dx = gsumi[j];
          	gsumi[j] = gsumi[j] * this.momentum + this.learning_rate * gij;
              dx = this.momentum * dx - (1.0 + this.momentum) * gsumi[j];
              p[j] += dx;
          } else {
            // assume SGD
            if(this.momentum > 0.0) {
              // momentum update
              var dx = this.momentum * gsumi[j] - this.learning_rate * gij; // step
              gsumi[j] = dx; // back this up for next iteration of momentum
              p[j] += dx; // apply corrected gradient
            } else {
              // vanilla sgd
              p[j] +=  - this.learning_rate * gij;
            }
          }
          g[j] = 0.0; // zero out gradient so that we can begin accumulating anew
        }
      }
    }

    // appending softmax_loss for backwards compatibility, but from now on we will always use cost_loss
    // in future, TODO: have to completely redo the way loss is done around the network as currently 
    // loss is a bit of a hack. Ideally, user should specify arbitrary number of loss functions on any layer
    // and it should all be computed correctly and automatically. 
    return {fwd_time: fwd_time, bwd_time: bwd_time, 
            l2_decay_loss: l2_decay_loss, l1_decay_loss: l1_decay_loss,
            cost_loss: cost_loss, softmax_loss: cost_loss, 
            loss: cost_loss + l1_decay_loss + l2_decay_loss}
  }
}

convnet.Trainer = Trainer;
convnet.SGDTrainer = Trainer; // backwards compatibility


/*** convnet_magicnets ***/
// used utilities, make explicit local references
var randf = convnet.randf;
var randi = convnet.randi;
var Net = convnet.Net;
var Trainer = convnet.Trainer;
var maxmin = convnet.maxmin;
var randperm = convnet.randperm;
var weightedSample = convnet.weightedSample;
var getopt = convnet.getopt;
var arrUnique = convnet.arrUnique;

/*
A MagicNet takes data: a list of convnetjs.Vol(), and labels
which for now are assumed to be class indeces 0..K. MagicNet then:
- creates data folds for cross-validation
- samples candidate networks
- evaluates candidate networks on all data folds
- produces predictions by model-averaging the best networks
*/
var MagicNet = function(data, labels, opt) {
  var opt = opt || {};
  if(typeof data === 'undefined') { data = []; }
  if(typeof labels === 'undefined') { labels = []; }

  // required inputs
  this.data = data; // store these pointers to data
  this.labels = labels;

  // optional inputs
  this.train_ratio = getopt(opt, 'train_ratio', 0.7);
  this.num_folds = getopt(opt, 'num_folds', 10);
  this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel
  // how many epochs of data to train every network? for every fold?
  // higher values mean higher accuracy in final results, but more expensive
  this.num_epochs = getopt(opt, 'num_epochs', 50); 
  // number of best models to average during prediction. Usually higher = better
  this.ensemble_size = getopt(opt, 'ensemble_size', 10);

  // candidate parameters
  this.batch_size_min = getopt(opt, 'batch_size_min', 10);
  this.batch_size_max = getopt(opt, 'batch_size_max', 300);
  this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);
  this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);
  this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);
  this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);
  this.momentum_min = getopt(opt, 'momentum_min', 0.9);
  this.momentum_max = getopt(opt, 'momentum_max', 0.9);
  this.neurons_min = getopt(opt, 'neurons_min', 5);
  this.neurons_max = getopt(opt, 'neurons_max', 30);

  // computed
  this.folds = []; // data fold indices, gets filled by sampleFolds()
  this.candidates = []; // candidate networks that are being currently evaluated
  this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds
  this.unique_labels = arrUnique(labels);
  this.iter = 0; // iteration counter, goes from 0 -> num_epochs * num_training_data
  this.foldix = 0; // index of active fold

  // callbacks
  this.finish_fold_callback = null;
  this.finish_batch_callback = null;

  // initializations
  if(this.data.length > 0) {
    this.sampleFolds();
    this.sampleCandidates();
  }
};

MagicNet.prototype = {

  // sets this.folds to a sampling of this.num_folds folds
  sampleFolds: function() {
    var N = this.data.length;
    var num_train = Math.floor(this.train_ratio * N);
    this.folds = []; // flush folds, if any
    for(var i=0;i<this.num_folds;i++) {
      var p = randperm(N);
      this.folds.push({train_ix: p.slice(0, num_train), test_ix: p.slice(num_train, N)});
    }
  },

  // returns a random candidate network
  sampleCandidate: function() {
    var input_depth = this.data[0].w.length;
    var num_classes = this.unique_labels.length;

    // sample network topology and hyperparameters
    var layer_defs = [];
    layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth: input_depth});
    var nl = weightedSample([0,1,2,3], [0.2, 0.3, 0.3, 0.2]); // prefer nets with 1,2 hidden layers
    for(var q=0;q<nl;q++) {
      var ni = randi(this.neurons_min, this.neurons_max);
      var act = ['tanh','maxout','relu'][randi(0,3)];
      if(randf(0,1)<0.5) {
        var dp = Math.random();
        layer_defs.push({type:'fc', num_neurons: ni, activation: act, drop_prob: dp});
      } else {
        layer_defs.push({type:'fc', num_neurons: ni, activation: act});
      }
    }
    layer_defs.push({type:'softmax', num_classes: num_classes});
    var net = new Net();
    net.makeLayers(layer_defs);

    // sample training hyperparameters
    var bs = randi(this.batch_size_min, this.batch_size_max); // batch size
    var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay
    var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate
    var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p
    var tp = randf(0,1); // trainer type
    var trainer_def;
    if(tp<0.33) {
      trainer_def = {method:'adadelta', batch_size:bs, l2_decay:l2};
    } else if(tp<0.66) {
      trainer_def = {method:'adagrad', learning_rate: lr, batch_size:bs, l2_decay:l2};
    } else {
      trainer_def = {method:'sgd', learning_rate: lr, momentum: mom, batch_size:bs, l2_decay:l2};
    }
    
    var trainer = new Trainer(net, trainer_def);

    var cand = {};
    cand.acc = [];
    cand.accv = 0; // this will maintained as sum(acc) for convenience
    cand.layer_defs = layer_defs;
    cand.trainer_def = trainer_def;
    cand.net = net;
    cand.trainer = trainer;
    return cand;
  },

  // sets this.candidates with this.num_candidates candidate nets
  sampleCandidates: function() {
    this.candidates = []; // flush, if any
    for(var i=0;i<this.num_candidates;i++) {
      var cand = this.sampleCandidate();
      this.candidates.push(cand);
    }
  },

  step: function() {
    
    // run an example through current candidate
    this.iter++;

    // step all candidates on a random data point
    var fold = this.folds[this.foldix]; // active fold
    var dataix = fold.train_ix[randi(0, fold.train_ix.length)];
    for(var k=0;k<this.candidates.length;k++) {
      var x = this.data[dataix];
      var l = this.labels[dataix];
      this.candidates[k].trainer.train(x, l);
    }

    // process consequences: sample new folds, or candidates
    var lastiter = this.num_epochs * fold.train_ix.length;
    if(this.iter >= lastiter) {
      // finished evaluation of this fold. Get final validation
      // accuracies, record them, and go on to next fold.
      var val_acc = this.evalValErrors();
      for(var k=0;k<this.candidates.length;k++) {
        var c = this.candidates[k];
        c.acc.push(val_acc[k]);
        c.accv += val_acc[k];
      }
      this.iter = 0; // reset step number
      this.foldix++; // increment fold

      if(this.finish_fold_callback !== null) {
        this.finish_fold_callback();
      }

      if(this.foldix >= this.folds.length) {
        // we finished all folds as well! Record these candidates
        // and sample new ones to evaluate.
        for(var k=0;k<this.candidates.length;k++) {
          this.evaluated_candidates.push(this.candidates[k]);
        }
        // sort evaluated candidates according to accuracy achieved
        this.evaluated_candidates.sort(function(a, b) { 
          return (a.accv / a.acc.length) 
               > (b.accv / b.acc.length) 
               ? -1 : 1;
        });
        // and clip only to the top few ones (lets place limit at 3*ensemble_size)
        // otherwise there are concerns with keeping these all in memory 
        // if MagicNet is being evaluated for a very long time
        if(this.evaluated_candidates.length > 3 * this.ensemble_size) {
          this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size);
        }
        if(this.finish_batch_callback !== null) {
          this.finish_batch_callback();
        }
        this.sampleCandidates(); // begin with new candidates
        this.foldix = 0; // reset this
      } else {
        // we will go on to another fold. reset all candidates nets
        for(var k=0;k<this.candidates.length;k++) {
          var c = this.candidates[k];
          var net = new Net();
          net.makeLayers(c.layer_defs);
          var trainer = new Trainer(net, c.trainer_def);
          c.net = net;
          c.trainer = trainer;
        }
      }
    }
  },

  evalValErrors: function() {
    // evaluate candidates on validation data and return performance of current networks
    // as simple list
    var vals = [];
    var fold = this.folds[this.foldix]; // active fold
    for(var k=0;k<this.candidates.length;k++) {
      var net = this.candidates[k].net;
      var v = 0.0;
      for(var q=0;q<fold.test_ix.length;q++) {
        var x = this.data[fold.test_ix[q]];
        var l = this.labels[fold.test_ix[q]];
        net.forward(x);
        var yhat = net.getPrediction();
        v += (yhat === l ? 1.0 : 0.0); // 0 1 loss
      }
      v /= fold.test_ix.length; // normalize
      vals.push(v);
    }
    return vals;
  },

  // returns prediction scores for given test data point, as Vol
  // uses an averaged prediction from the best ensemble_size models
  // x is a Vol.
  predict_soft: function(data) {
    // forward prop the best networks
    // and accumulate probabilities at last layer into a an output Vol

    var eval_candidates = [];
    var nv = 0;
    if(this.evaluated_candidates.length === 0) {
      // not sure what to do here, first batch of nets hasnt evaluated yet
      // lets just predict with current candidates.
      nv = this.candidates.length;
      eval_candidates = this.candidates;
    } else {
      // forward prop the best networks from evaluated_candidates
      nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
      eval_candidates = this.evaluated_candidates
    }

    // forward nets of all candidates and average the predictions
    var xout, n;
    for(var j=0;j<nv;j++) {
      var net = eval_candidates[j].net;
      var x = net.forward(data);
      if(j===0) { 
        xout = x; 
        n = x.w.length; 
      } else {
        // add it on
        for(var d=0;d<n;d++) {
          xout.w[d] += x.w[d];
        }
      }
    }
    // produce average
    for(var d=0;d<n;d++) {
      xout.w[d] /= nv;
    }
    return xout;
  },

  predict: function(data) {
    var xout = this.predict_soft(data);
    if(xout.w.length !== 0) {
      var stats = maxmin(xout.w);
      var predicted_label = stats.maxi; 
    } else {
      var predicted_label = -1; // error out
    }
    return predicted_label;

  },

  toJSON: function() {
    // dump the top ensemble_size networks as a list
    var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
    var json = {};
    json.nets = [];
    for(var i=0;i<nv;i++) {
      json.nets.push(this.evaluated_candidates[i].net.toJSON());
    }
    return json;
  },

  fromJSON: function(json) {
    this.ensemble_size = json.nets.length;
    this.evaluated_candidates = [];
    for(var i=0;i<this.ensemble_size;i++) {
      var net = new Net();
      net.fromJSON(json.nets[i]);
      var dummy_candidate = {};
      dummy_candidate.net = net;
      this.evaluated_candidates.push(dummy_candidate);
    }
  },

  // callback functions
  // called when a fold is finished, while evaluating a batch
  onFinishFold: function(f) { this.finish_fold_callback = f; },
  // called when a batch of candidates has finished evaluating
  onFinishBatch: function(f) { this.finish_batch_callback = f; }
  
};

convnet.MagicNet = MagicNet;


};
BundleModuleCode['plugins/ml/ann']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Thomas Wagenaar, Stefan Bosse, 
 **    $VERSION:     1.8.1X
 **
 **    $INFO:
 **
 ** https://github.com/wagenaartje/neataptic
 ** Not portable!
 **
 **    $ENDOFINFO
 **
*/

/*******************************************************************************
                                      CONFIG
*******************************************************************************/

// Config
var config = {
  groupId   : 0,
  warnings  : false,
  version   : '1.8.1X',
};

/*******************************************************************************
                                  ACTIVATION FUNCTIONS
*******************************************************************************/

// https://en.wikipedia.org/wiki/Activation_function
// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons
var activation = {
  LOGISTIC: function LOGISTIC (x, derivate) {
    var fx = 1 / (1 + Math.exp(-x));
    if (!derivate) return fx;
    return fx * (1 - fx);
  },
  TANH: function TANH (x, derivate) {
    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);
    return Math.tanh(x);
  },
  IDENTITY: function IDENTITY (x, derivate) {
    return derivate ? 1 : x;
  },
  STEP: function STEP (x, derivate) {
    return derivate ? 0 : x > 0 ? 1 : 0;
  },
  RELU: function RELU (x, derivate) {
    if (derivate) return x > 0 ? 1 : 0;
    return x > 0 ? x : 0;
  },
  SOFTSIGN: function SOFTSIGN (x, derivate) {
    var d = 1 + Math.abs(x);
    if (derivate) return x / Math.pow(d, 2);
    return x / d;
  },
  // Group activation
  SOFTMAX: function SOFTMAX (x, derivate, group) {
    var self=this;
    /* softmax function requires states of group members */
    /* group members can be already updated! */
    if (!derivate) {
      var sum = 0;
      group.nodes.forEach(function (node) {
        if (node.update>self.update) sum += Math.exp(node.state); // already computed x==state
        else sum +=  Math.exp(node.preactivate());
      });
      return Math.exp(x)/sum;
    } else {
      // https://stackoverflow.com/questions/55788902/clear-implementation-of-softmax-and-its-derivative
      var factor=0,
          denom = 0;
      group.nodes.forEach(function (node) {
            var part;
            if (node.update>self.update) {
              part = Math.exp(node.state); // already computed x==state
            } else {
              part = Math.exp(node.preactivate());
            }
            if (node != self) factor += part;
            sum += part;
          })
      var comm = -Math.pow(Math.exp(x),2);
    }
  },
  SINUSOID: function SINUSOID (x, derivate) {
    if (derivate) return Math.cos(x);
    return Math.sin(x);
  },
  GAUSSIAN: function GAUSSIAN (x, derivate) {
    var d = Math.exp(-Math.pow(x, 2));
    if (derivate) return -2 * x * d;
    return d;
  },
  BENT_IDENTITY: function BENT_IDENTITY (x, derivate) {
    var d = Math.sqrt(Math.pow(x, 2) + 1);
    if (derivate) return x / (2 * d) + 1;
    return (d - 1) / 2 + x;
  },
  BIPOLAR: function BIPOLAR (x, derivate) {
    return derivate ? 0 : x > 0 ? 1 : -1;
  },
  BIPOLAR_SIGMOID: function BIPOLAR_SIGMOID (x, derivate) {
    var d = 2 / (1 + Math.exp(-x)) - 1;
    if (derivate) return 1 / 2 * (1 + d) * (1 - d);
    return d;
  },
  HARD_TANH: function HARD_TANH (x, derivate) {
    if (derivate) return x > -1 && x < 1 ? 1 : 0;
    return Math.max(-1, Math.min(1, x));
  },
  ABSOLUTE: function ABSOLUTE (x, derivate) {
    if (derivate) return x < 0 ? -1 : 1;
    return Math.abs(x);
  },
  INVERSE: function INVERSE (x, derivate) {
    if (derivate) return -1;
    return 1 - x;
  },
  // https://arxiv.org/pdf/1706.02515.pdf
  SELU: function SELU (x, derivate) {
    var alpha = 1.6732632423543772848170429916717;
    var scale = 1.0507009873554804934193349852946;
    var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;
    if (derivate) { return x > 0 ? scale : (fx + alpha) * scale; }
    return fx * scale;
  }
};

/*******************************************************************************
                                      MUTATION
*******************************************************************************/

// https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)
var mutation = {
  ADD_NODE: {
    name: 'ADD_NODE'
  },
  SUB_NODE: {
    name: 'SUB_NODE',
    keep_gates: true
  },
  ADD_CONN: {
    name: 'ADD_CONN'
  },
  SUB_CONN: {
    name: 'REMOVE_CONN'
  },
  MOD_WEIGHT: {
    name: 'MOD_WEIGHT',
    min: -1,
    max: 1
  },
  MOD_BIAS: {
    name: 'MOD_BIAS',
    min: -1,
    max: 1
  },
  MOD_ACTIVATION: {
    name: 'MOD_ACTIVATION',
    mutateOutput: true,
    allowed: [
      activation.LOGISTIC,
      activation.TANH,
      activation.RELU,
      activation.IDENTITY,
      activation.STEP,
      activation.SOFTSIGN,
      activation.SINUSOID,
      activation.GAUSSIAN,
      activation.BENT_IDENTITY,
      activation.BIPOLAR,
      activation.BIPOLAR_SIGMOID,
      activation.HARD_TANH,
      activation.ABSOLUTE,
      activation.INVERSE,
      activation.SELU
    ]
  },
  ADD_SELF_CONN: {
    name: 'ADD_SELF_CONN'
  },
  SUB_SELF_CONN: {
    name: 'SUB_SELF_CONN'
  },
  ADD_GATE: {
    name: 'ADD_GATE'
  },
  SUB_GATE: {
    name: 'SUB_GATE'
  },
  ADD_BACK_CONN: {
    name: 'ADD_BACK_CONN'
  },
  SUB_BACK_CONN: {
    name: 'SUB_BACK_CONN'
  },
  SWAP_NODES: {
    name: 'SWAP_NODES',
    mutateOutput: true
  }
};

mutation.ALL = [
  mutation.ADD_NODE,
  mutation.SUB_NODE,
  mutation.ADD_CONN,
  mutation.SUB_CONN,
  mutation.MOD_WEIGHT,
  mutation.MOD_BIAS,
  mutation.MOD_ACTIVATION,
  mutation.ADD_GATE,
  mutation.SUB_GATE,
  mutation.ADD_SELF_CONN,
  mutation.SUB_SELF_CONN,
  mutation.ADD_BACK_CONN,
  mutation.SUB_BACK_CONN,
  mutation.SWAP_NODES
];

mutation.FFW = [
  mutation.ADD_NODE,
  mutation.SUB_NODE,
  mutation.ADD_CONN,
  mutation.SUB_CONN,
  mutation.MOD_WEIGHT,
  mutation.MOD_BIAS,
  mutation.MOD_ACTIVATION,
  mutation.SWAP_NODES
];

/*******************************************************************************
                                      SELECTION
*******************************************************************************/

// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)

var selection = {
  FITNESS_PROPORTIONATE: {
    name: 'FITNESS_PROPORTIONATE'
  },
  POWER: {
    name: 'POWER',
    power: 4
  },
  TOURNAMENT: {
    name: 'TOURNAMENT',
    size: 5,
    probability: 0.5
  }
};

/*******************************************************************************
                                      CROSSOVER
*******************************************************************************/

// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)
var crossover = {
  SINGLE_POINT: {
    name: 'SINGLE_POINT',
    config: [0.4]
  },
  TWO_POINT: {
    name: 'TWO_POINT',
    config: [0.4, 0.9]
  },
  UNIFORM: {
    name: 'UNIFORM'
  },
  AVERAGE: {
    name: 'AVERAGE'
  }
};

/*******************************************************************************
                                    COST FUNCTIONS
*******************************************************************************/

// https://en.wikipedia.org/wiki/Loss_function
var cost = {
  // Cross entropy error
  CROSS_ENTROPY: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A
      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));
    }
    return error / output.length;
  },
  // Mean Squared Error
  MSE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.pow(target[i] - output[i], 2);
    }

    return error / output.length;
  },
  // Binary error
  BINARY: function (target, output) {
    var misses = 0;
    for (var i = 0; i < output.length; i++) {
      misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);
    }

    return misses;
  },
  // Mean Absolute Error
  MAE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.abs(target[i] - output[i]);
    }

    return error / output.length;
  },
  // Mean Absolute Percentage Error
  MAPE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));
    }

    return error / output.length;
  },
  // Mean Squared Logarithmic Error
  MSLE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));
    }

    return error;
  },
  // Hinge loss, for classifiers
  HINGE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.max(0, 1 - target[i] * output[i]);
    }

    return error;
  }
};


/*******************************************************************************
                                    GATING
*******************************************************************************/

// Specifies how to gate a connection between two groups of multiple neurons
var gating = {
  OUTPUT: {
    name: 'OUTPUT'
  },
  INPUT: {
    name: 'INPUT'
  },
  SELF: {
    name: 'SELF'
  }
};


/*******************************************************************************
                                    CONNECTION
*******************************************************************************/

// Specifies in what manner two groups are connected
var connection = {
  ALL_TO_ALL: {
    name: 'OUTPUT'
  },
  ALL_TO_ELSE: {
    name: 'INPUT'
  },
  ONE_TO_ONE: {
    name: 'SELF'
  }
};


/*******************************************************************************
                                      RATE
*******************************************************************************/

// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244
var rate = {
  FIXED: function () {
    var func = function (baseRate, iteration) { return baseRate; };
    return func;
  },
  STEP: function (gamma, stepSize) {
    gamma = gamma || 0.9;
    stepSize = stepSize || 100;

    var func = function (baseRate, iteration) {
      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));
    };

    return func;
  },
  EXP: function (gamma) {
    gamma = gamma || 0.999;

    var func = function (baseRate, iteration) {
      return baseRate * Math.pow(gamma, iteration);
    };

    return func;
  },
  INV: function (gamma, power) {
    gamma = gamma || 0.001;
    power = power || 2;

    var func = function (baseRate, iteration) {
      return baseRate * Math.pow(1 + gamma * iteration, -power);
    };

    return func;
  }
};

/*******************************************************************************
                                  METHODS
*******************************************************************************/

var methods = {
  activation: activation,
  mutation: mutation,
  selection: selection,
  crossover: crossover,
  cost: cost,
  gating: gating,
  connection: connection,
  rate: rate
};

/*******************************************************************************
                                      CONNECTION
*******************************************************************************/

function Connection (from, to, weight) {
  this.from = from;
  this.to = to;
  this.gain = 1;

  this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;

  this.gater = null;
  this.elegibility = 0;

  // For tracking momentum
  this.previousDeltaWeight = 0;

  // Batch training
  this.totalDeltaWeight = 0;

  this.xtrace = {
    nodes: [],
    values: []
  };
}

Connection.prototype = {
  /**
   * Converts the connection to a json object
   */
  toJSON: function () {
    var json = {
      weight: this.weight
    };

    return json;
  }
};

/**
 * Returns an innovation ID
 * https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)
 */
Connection.innovationID = function (a, b) {
  return 1 / 2 * (a + b) * (a + b + 1) + b;
};

/*******************************************************************************
                                 NETWORK
*******************************************************************************/


/* Easier variable naming */
var mutation = methods.mutation;

function Network (input, output) {
  if (typeof input === 'undefined' || typeof output === 'undefined') {
    throw new Error('No input or output size given');
  }

  this.input = input;
  this.output = output;

  // Store all the node and connection genes
  this.nodes = []; // Stored in activation order
  this.connections = [];
  this.gates = [];
  this.selfconns = [];

  // Regularization
  this.dropout = 0;

  // Create input and output nodes
  var i;
  for (i = 0; i < this.input + this.output; i++) {
    var type = i < this.input ? 'input' : 'output';
    this.nodes.push(new Node(type,{layerid:type=='input'?0:1}));
  }

  // Connect input nodes with output nodes directly
  for (i = 0; i < this.input; i++) {
    for (var j = this.input; j < this.output + this.input; j++) {
      // https://stats.stackexchange.com/a/248040/147931
      var weight = Math.random() * this.input * Math.sqrt(2 / this.input);
      this.connect(this.nodes[i], this.nodes[j], weight);
    }
  }
}

Network.prototype = {
  /**
   * Activates the network
   */
  activate: function (input, training) {
    var output = [];

    // Activate nodes chronologically
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].type === 'input') {
        this.nodes[i].activate(input[i]);
      } else if (this.nodes[i].type === 'output') {
        var activation = this.nodes[i].activate();
        output.push(activation);
      } else {
        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;
        this.nodes[i].activate();
      }
    }

    return output;
  },

  // make a snapshot of the network (weights, biases)
  // add snapshot to this object
  backup : function () {
    if (!this.snapshots) this.snapshots=[];
    this.snapshots.push(
      { 
       nodes : this.nodes.map(function (node) {
          return {
            bias        : node.bias,
            activation  : node.activation,
            state       : node.state,
            mask        : node.mask,
            previousDeltaBias: node.previousDeltaBias,
            totalDeltaBias: node.totalDeltaBias,
            derivative: node.derivative,
          }}),
        connections : this.connections.map(function (conn) {
          return {
            gain    : conn.gain,
            weight  : conn.weight,
            elegibility : conn.elegibility,
            previousDeltaWeight : conn.previousDeltaWeight,
          }}),
    });
  },
  
  /**
   * Clear the context of the network
   */
  clear: function () {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  },

  /**
   * Connects the from node to the to node
   */
  connect: function (from, to, weight) {
    var connections = from.connect(to, weight);

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (from !== to) {
        this.connections.push(connection);
      } else {
        this.selfconns.push(connection);
      }
    }

    return connections;
  },

  /*
  *  Post configure network after construction (e.g., by assigning activation/squash functions)
  */
  configure : function (options) {
    if (options.activation && typeof options.activation == 'string') { // apply to all nodes
      this.nodes.forEach(function (node) {
        if (!methods.activation[options.activation]) throw "Network.configure: EINVALID (activation)";
        node.squash=methods.activation[options.activation];
      });
    }
    if (options.activation && typeof options.activation == 'function') { // apply to all nodes
      this.nodes.forEach(function (node) {
        node.squash=options.activation;
      });
    }
    if (options.activation && typeof options.activation == 'object') { // each for one layer
      this.groups.forEach(function (group,index) {
        group.nodes.forEach(function (node) {
          var f = typeof options.activation[index] == 'function'?
                   options.activation[index]: methods.activation[options.activation[index]];
          if (!f) throw "Network.configure: EINVALID (activation)";
          node.squash=f;
        })
      });
    }
  },
  
  /**
   * Disconnects the from node from the to node
   */
  disconnect: function (from, to) {
    // Delete the connection in the network's connection array
    var connections = from === to ? this.selfconns : this.connections;

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (connection.from === from && connection.to === to) {
        if (connection.gater !== null) this.ungate(connection);
        connections.splice(i, 1);
        break;
      }
    }

    // Delete the connection at the sending and receiving neuron
    from.disconnect(to);
  },

  /**
   * Evolves the network to reach a lower error on a dataset
   */
  evolve: function (set, options) {
    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
      throw new Error('Dataset input/output size should be same as network input/output size!');
    }

    // Read the options
    options = options || {};
    var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;
    var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;
    var cost = options.cost || methods.cost.MSE;
    var amount = options.amount || 1;


    var start = Date.now();

    if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {
      throw new Error('At least one of the following options must be specified: error, iterations');
    } else if (typeof options.error === 'undefined') {
      targetError = -1; // run until iterations
    } else if (typeof options.iterations === 'undefined') {
      options.iterations = 0; // run until target error
    }

    var fitnessFunction;
    {
      // Create the fitness function
      fitnessFunction = function (genome) {
        var score = 0;
        for (var i = 0; i < amount; i++) {
          score -= genome.test(set, cost).error;
        }

        score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;
        score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection

        return score / amount;
      };
    } 

    // Intialise the NEAT instance
    options.network = this;
    var neat = new Neat(this.input, this.output, fitnessFunction, options);

    var error = -Infinity;
    var bestFitness = -Infinity;
    var bestGenome;

    while (error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {
      var fittest = neat.evolve();
      var fitness = fittest.score;
      error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;

      if (fitness > bestFitness) {
        bestFitness = fitness;
        bestGenome = fittest;
      }

      if (options.log && neat.generation % options.log === 0) {
        console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);
      }

      if (options.schedule && neat.generation % options.schedule.iterations === 0) {
        options.schedule.function({ fitness: fitness, error: -error, iteration: neat.generation });
      }
    }


    if (typeof bestGenome !== 'undefined') {
      this.nodes = bestGenome.nodes;
      this.connections = bestGenome.connections;
      this.selfconns = bestGenome.selfconns;
      this.gates = bestGenome.gates;

      if (options.clear) this.clear();
    }

    return {
      error: -error,
      iterations: neat.generation,
      time: Date.now() - start
    };
  },

  /**
   * Gate a connection with a node
   */
  gate: function (node, connection) {
    if (this.nodes.indexOf(node) === -1) {
      throw new Error('This node is not part of the network!');
    } else if (connection.gater != null) {
      if (config.warnings) console.warn('This connection is already gated!');
      return;
    }
    node.gate(connection);
    this.gates.push(connection);
  },

  /**
   * Creates a json that can be used to create a graph with d3 and webcola
   */
  graph: function (width, height) {
    var input = 0;
    var output = 0;

    var json = {
      nodes: [],
      links: [],
      constraints: [{
        type: 'alignment',
        axis: 'x',
        offsets: []
      }, {
        type: 'alignment',
        axis: 'y',
        offsets: []
      }]
    };

    var i;
    for (i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];

      if (node.type === 'input') {
        if (this.input === 1) {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0
          });
        } else {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0.8 * width / (this.input - 1) * input++
          });
        }
        json.constraints[1].offsets.push({
          node: i,
          offset: 0
        });
      } else if (node.type === 'output') {
        if (this.output === 1) {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0
          });
        } else {
          json.constraints[0].offsets.push({
            node: i,
            offset: 0.8 * width / (this.output - 1) * output++
          });
        }
        json.constraints[1].offsets.push({
          node: i,
          offset: -0.8 * height
        });
      }

      json.nodes.push({
        id: i,
        name: node.type === 'hidden' ? node.squash.name : node.type.toUpperCase(),
        activation: node.activation,
        bias: node.bias
      });
    }

    var connections = this.connections.concat(this.selfconns);
    for (i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (connection.gater == null) {
        json.links.push({
          source: this.nodes.indexOf(connection.from),
          target: this.nodes.indexOf(connection.to),
          weight: connection.weight
        });
      } else {
        // Add a gater 'node'
        var index = json.nodes.length;
        json.nodes.push({
          id: index,
          activation: connection.gater.activation,
          name: 'GATE'
        });
        json.links.push({
          source: this.nodes.indexOf(connection.from),
          target: index,
          weight: 1 / 2 * connection.weight
        });
        json.links.push({
          source: index,
          target: this.nodes.indexOf(connection.to),
          weight: 1 / 2 * connection.weight
        });
        json.links.push({
          source: this.nodes.indexOf(connection.gater),
          target: index,
          weight: connection.gater.activation,
          gate: true
        });
      }
    }

    return json;
  },

  // return node arrays of layer array with status information (nodes)
  // optional with activation data (number [])
  monitor : function (what,data) {
    what=what||'activation';
    function collect(node) {
      switch (what) {
        case 'node': return node;
        case 'weights':
          return node.connections.in.map(function (c) {
            return c.weight;
          })
        case 'sum':
          var result=node.connections.in.map(function (c) {
            return c.weight*c.from.activation;
          })
          if (result.length) return result.reduce(function (a,b) { return a+b });
          else return node.activation;
        default:
          return node[what]
      }    
    }
    if (data) this.activate(data);
    if (this.groups && this.groups.length)
      return this.groups.map(function (layer) {
         return layer.nodes.map(collect);
      });
    else if (this.layers && this.layers.length)     
      return this.layers.map(function (layer) {
        return layer.output.nodes.map(collect);
      });
  },
  
  /**
   * Mutates the network with the given method
   */
  mutate: function (method) {
    if (typeof method === 'undefined') {
      throw new Error('No (correct) mutate method given!');
    }

    var i, j;
    switch (method) {
      case mutation.ADD_NODE:
        // Look for an existing connection and place a node in between
        var connection = this.connections[Math.floor(Math.random() * this.connections.length)];
        var gater = connection.gater;
        this.disconnect(connection.from, connection.to);

        // Insert the new node right before the old connection.to
        var toIndex = this.nodes.indexOf(connection.to);
        var node = new Node('hidden');

        // Random squash function
        node.mutate(mutation.MOD_ACTIVATION);

        // Place it in this.nodes
        var minBound = Math.min(toIndex, this.nodes.length - this.output);
        this.nodes.splice(minBound, 0, node);

        // Now create two new connections
        var newConn1 = this.connect(connection.from, node)[0];
        var newConn2 = this.connect(node, connection.to)[0];

        // Check if the original connection was gated
        if (gater != null) {
          this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);
        }
        break;
      case mutation.SUB_NODE:
        // Check if there are nodes left to remove
        if (this.nodes.length === this.input + this.output) {
          if (config.warnings) console.warn('No more nodes left to remove!');
          break;
        }

        // Select a node which isn't an input or output node
        var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);
        this.remove(this.nodes[index]);
        break;
      case mutation.ADD_CONN:
        // Create an array of all uncreated (feedforward) connections
        var available = [];
        for (i = 0; i < this.nodes.length - this.output; i++) {
          var node1 = this.nodes[i];
          for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {
            var node2 = this.nodes[j];
            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);
          }
        }

        if (available.length === 0) {
          if (config.warnings) console.warn('No more connections to be made!');
          break;
        }

        var pair = available[Math.floor(Math.random() * available.length)];
        this.connect(pair[0], pair[1]);
        break;
      case mutation.SUB_CONN:
        // List of possible connections that can be removed
        var possible = [];

        for (i = 0; i < this.connections.length; i++) {
          var conn = this.connections[i];
          // Check if it is not disabling a node
          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.to) > this.nodes.indexOf(conn.from)) {
            possible.push(conn);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No connections to remove!');
          break;
        }

        var randomConn = possible[Math.floor(Math.random() * possible.length)];
        this.disconnect(randomConn.from, randomConn.to);
        break;
      case mutation.MOD_WEIGHT:
        var allconnections = this.connections.concat(this.selfconns);

        var connection = allconnections[Math.floor(Math.random() * allconnections.length)];
        var modification = Math.random() * (method.max - method.min) + method.min;
        connection.weight += modification;
        break;
      case mutation.MOD_BIAS:
        // Has no effect on input node, so they are excluded
        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);
        var node = this.nodes[index];
        node.mutate(method);
        break;
      case mutation.MOD_ACTIVATION:
        // Has no effect on input node, so they are excluded
        if (!method.mutateOutput && this.input + this.output === this.nodes.length) {
          if (config.warnings) console.warn('No nodes that allow mutation of activation function');
          break;
        }

        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
        var node = this.nodes[index];

        node.mutate(method);
        break;
      case mutation.ADD_SELF_CONN:
        // Check which nodes aren't selfconnected yet
        var possible = [];
        for (i = this.input; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (node.connections.self.weight === 0) {
            possible.push(node);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No more self-connections to add!');
          break;
        }

        // Select a random node
        var node = possible[Math.floor(Math.random() * possible.length)];

        // Connect it to himself
        this.connect(node, node);
        break;
      case mutation.SUB_SELF_CONN:
        if (this.selfconns.length === 0) {
          if (config.warnings) console.warn('No more self-connections to remove!');
          break;
        }
        var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];
        this.disconnect(conn.from, conn.to);
        break;
      case mutation.ADD_GATE:
        var allconnections = this.connections.concat(this.selfconns);

        // Create a list of all non-gated connections
        var possible = [];
        for (i = 0; i < allconnections.length; i++) {
          var conn = allconnections[i];
          if (conn.gater === null) {
            possible.push(conn);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No more connections to gate!');
          break;
        }

        // Select a random gater node and connection, can't be gated by input
        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);
        var node = this.nodes[index];
        var conn = possible[Math.floor(Math.random() * possible.length)];

        // Gate the connection with the node
        this.gate(node, conn);
        break;
      case mutation.SUB_GATE:
        // Select a random gated connection
        if (this.gates.length === 0) {
          if (config.warnings) console.warn('No more connections to ungate!');
          break;
        }

        var index = Math.floor(Math.random() * this.gates.length);
        var gatedconn = this.gates[index];

        this.ungate(gatedconn);
        break;
      case mutation.ADD_BACK_CONN:
        // Create an array of all uncreated (backfed) connections
        var available = [];
        for (i = this.input; i < this.nodes.length; i++) {
          var node1 = this.nodes[i];
          for (j = this.input; j < i; j++) {
            var node2 = this.nodes[j];
            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);
          }
        }

        if (available.length === 0) {
          if (config.warnings) console.warn('No more connections to be made!');
          break;
        }

        var pair = available[Math.floor(Math.random() * available.length)];
        this.connect(pair[0], pair[1]);
        break;
      case mutation.SUB_BACK_CONN:
        // List of possible connections that can be removed
        var possible = [];

        for (i = 0; i < this.connections.length; i++) {
          var conn = this.connections[i];
          // Check if it is not disabling a node
          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.from) > this.nodes.indexOf(conn.to)) {
            possible.push(conn);
          }
        }

        if (possible.length === 0) {
          if (config.warnings) console.warn('No connections to remove!');
          break;
        }

        var randomConn = possible[Math.floor(Math.random() * possible.length)];
        this.disconnect(randomConn.from, randomConn.to);
        break;
      case mutation.SWAP_NODES:
        // Has no effect on input node, so they are excluded
        if ((method.mutateOutput && this.nodes.length - this.input < 2) ||
          (!method.mutateOutput && this.nodes.length - this.input - this.output < 2)) {
          if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');
          break;
        }

        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
        var node1 = this.nodes[index];
        index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
        var node2 = this.nodes[index];

        var biasTemp = node1.bias;
        var squashTemp = node1.squash;

        node1.bias = node2.bias;
        node1.squash = node2.squash;
        node2.bias = biasTemp;
        node2.squash = squashTemp;
        break;
    }
  },

  // apply uniformly distributed noise to bias of nodes and weights of connections (perc=[0,1])
  // supported layers: 'hidden'|'output'
  noise : function (perc,layers) {
    layers=layers||['hidden'];
    this.nodes.forEach(function (node) {
      if (layers.indexOf(node.type)!=-1) {
        node.bias += ((Math.random()-0.5)*perc*node.bias);
      }
    });
    this.connections.forEach(function (conn) {
      if (layers.indexOf(conn.to.type)!=-1) {
        conn.weight += ((Math.random()-0.5)*perc*conn.weight);
      }
    });
  },
  
  /**
   * Activates the network without calculating elegibility traces and such
   */
  noTraceActivate: function (input) {
    var output = [];

    // Activate nodes chronologically
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].type === 'input') {
        this.nodes[i].noTraceActivate(input[i]);
      } else if (this.nodes[i].type === 'output') {
        var activation = this.nodes[i].noTraceActivate();
        output.push(activation);
      } else {
        this.nodes[i].noTraceActivate();
      }
    }

    return output;
  },

  /**
   * Backpropagate the network
   */
  propagate: function (rate, momentum, update, target) {
    if (typeof target === 'undefined' || target.length !== this.output) {
      throw new Error('Output target length should match network output length');
    }

    var targetIndex = target.length;

    // Propagate output nodes
    var i;
    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {
      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);
    }

    // Propagate hidden and input nodes
    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {
      this.nodes[i].propagate(rate, momentum, update);
    }
  },
  
  // Experimental
  // Naive regularization of saturated nodes by adjusting the node bias to the negative 
  // weighted input summation (resulting value sum0) if the activation output of a node is
  // outside the interval [low,high] and (if there is optional activation by
  // data series data) the saturation occures more than threshold (0,1] times scaled
  // to the number of data points (or 1).
  // For a data series (|data|>1) the mean summation output is used for bias adjustment.
  regularizeBias : function (data,low,high,sum0,threshold) {
    var network = this;
    data=data||[null]
    if (low==undefined)       low=0.02; // assuming logistic/sigmoid transfer function
    if (high==undefined)      high=0.98;
    if (sum0==undefined)      sum0=0;
    if (threshold==undefined) threshold=1;
    
    var biasmap    = network.monitor('bias'),
        nodes      = network.monitor('node'),
        candimap   = [],
        sumaccumap = [];
    data.forEach(function (sample) {
      if (sample) network.activate(sample,false);
      var actmap = network.monitor('activation'),
          summap = network.monitor('sum');
      var satN=0;
      actmap.forEach(function (actlayer,layeri) {
        if (!candimap[layeri])   candimap[layeri]=Array.init(actlayer.length);
        if (!sumaccumap[layeri]) sumaccumap[layeri]=Array.init(actlayer.length);      
        actlayer.forEach(function (act,nodej) {
          sumaccumap[layeri][nodej] += summap[layeri][nodej];
          if (act<low ||
              act>high) {
            // saturated node  
            satN++;
            var node = nodes[layeri][nodej],
                sum  = summap[layeri][nodej];
            // node.bias=-sum+sum0;
            candimap[layeri][nodej]++;
          }
        });
      });
    })
    var satN=0;
    candimap.forEach(function (layer,layeri) {
      layer.forEach(function (count,nodej) {
        if (count/data.length>=threshold) {
          satN++;
          var node = nodes[layeri][nodej],
              sum  = sumaccumap[layeri][nodej]/data.length;
          node.bias=-sum+sum0;
        }
      });
    });
    return { adjusted:satN, candidates: candimap, summap : sumaccumap }
  },

  /**
   *  Removes a node from the network
   */
  remove: function (node) {
    var index = this.nodes.indexOf(node);

    if (index === -1) {
      throw new Error('This node does not exist in the network!');
    }

    // Keep track of gaters
    var gaters = [];

    // Remove selfconnections from this.selfconns
    this.disconnect(node, node);

    // Get all its inputting nodes
    var inputs = [];
    for (var i = node.connections.in.length - 1; i >= 0; i--) {
      var connection = node.connections.in[i];
      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {
        gaters.push(connection.gater);
      }
      inputs.push(connection.from);
      this.disconnect(connection.from, node);
    }

    // Get all its outputing nodes
    var outputs = [];
    for (i = node.connections.out.length - 1; i >= 0; i--) {
      var connection = node.connections.out[i];
      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {
        gaters.push(connection.gater);
      }
      outputs.push(connection.to);
      this.disconnect(node, connection.to);
    }

    // Connect the input nodes to the output nodes (if not already connected)
    var connections = [];
    for (i = 0; i < inputs.length; i++) {
      var input = inputs[i];
      for (var j = 0; j < outputs.length; j++) {
        var output = outputs[j];
        if (!input.isProjectingTo(output)) {
          var conn = this.connect(input, output);
          connections.push(conn[0]);
        }
      }
    }

    // Gate random connections with gaters
    for (i = 0; i < gaters.length; i++) {
      if (connections.length === 0) break;

      var gater = gaters[i];
      var connIndex = Math.floor(Math.random() * connections.length);

      this.gate(gater, connections[connIndex]);
      connections.splice(connIndex, 1);
    }

    // Remove gated connections gated by this node
    for (i = node.connections.gated.length - 1; i >= 0; i--) {
      var conn = node.connections.gated[i];
      this.ungate(conn);
    }

    // Remove selfconnection
    this.disconnect(node, node);

    // Remove the node from this.nodes
    this.nodes.splice(index, 1);
  },

  // restore network from a snapshot from the past
  // options parameter back specifies the n oldest snapshot in the range {1,..,#snaps}
  // otherwise the last (newest) snapshot is removed and restored (default behaviour)
  restore : function (back) {
    var self=this;
    if (!this.snapshots || this.snapshots.length==0) return;
    var snapshot = back==undefined?this.snapshots.pop():this.snapshots[this.snapshots.length-back];
    snapshot.nodes.forEach(function (nodeS,index) {
      var node = self.nodes[index];
      Object.assign(node,nodeS);
    })
    snapshot.connections.forEach(function (connS,index) {
      var conn = self.connections[index];
      Object.assign(conn,connS);
    })  
  },
  



  /**
   * Sets the value of a property for every node in this network
   */
  set: function (values) {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].bias = values.bias || this.nodes[i].bias;
      this.nodes[i].squash = values.squash || this.nodes[i].squash;
    }
  },
  /**
   * Serialize to send to workers efficiently
   */
  serialize: function () {
    var activations = [];
    var states = [];
    var conns = [];
    var squashes = [
      'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',
      'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',
      'ABSOLUTE', 'INVERSE', 'SELU'
    ];

    conns.push(this.input);
    conns.push(this.output);

    var i;
    for (i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      node.index = i;
      activations.push(node.activation);
      states.push(node.state);
    }

    for (i = this.input; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      conns.push(node.index);
      conns.push(node.bias);
      conns.push(squashes.indexOf(node.squash.name));

      conns.push(node.connections.self.weight);
      conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);

      for (var j = 0; j < node.connections.in.length; j++) {
        var conn = node.connections.in[j];

        conns.push(conn.from.index);
        conns.push(conn.weight);
        conns.push(conn.gater == null ? -1 : conn.gater.index);
      }

      conns.push(-2); // stop token -> next node
    }

    return [activations, states, conns];
  },

  /**
   * Creates a standalone function of the network which can be run without the
   * need of a library
   */
  standalone: function () {
    var present = [];
    var activations = [];
    var states = [];
    var lines = [];
    var functions = [];

    var i;
    for (i = 0; i < this.input; i++) {
      var node = this.nodes[i];
      activations.push(node.activation);
      states.push(node.state);
    }

    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');

    // So we don't have to use expensive .indexOf()
    for (i = 0; i < this.nodes.length; i++) {
      this.nodes[i].index = i;
    }

    for (i = this.input; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      activations.push(node.activation);
      states.push(node.state);

      var functionIndex = present.indexOf(node.squash.name);

      if (functionIndex === -1) {
        functionIndex = present.length;
        present.push(node.squash.name);
        functions.push(node.squash.toString());
      }

      var incoming = [];
      for (var j = 0; j < node.connections.in.length; j++) {
        var conn = node.connections.in[j];
        var computation = "A[" + conn.from.index + "] * " + conn.weight;
        
        if (conn.gater != null) {
          computation += " * A[" + conn.gater.index + "]";
        }

        incoming.push(computation);
      }

      if (node.connections.self.weight) {
        var conn = node.connections.self;
        var computation = "S[" + i + "] * " + conn.weight;

        if (conn.gater != null) {
          computation += " * A[" + conn.gater.index + "]";
        }

        incoming.push(computation);
      }

      var line1 = "S[" + i + "] = " + incoming.join(' + ') + " + " + node.bias + ";";
      var line2 = "A[" + i + "] = F[" + functionIndex + "](S[" + i + "])" + (!node.mask ? ' * ' + node.mask : '') + ";";
      lines.push(line1);
      lines.push(line2);
    }

    var output = [];
    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {
      output.push("A[" + i + "]");
    }

    output = "return [" + output.join(',') + "];";
    lines.push(output);

    var total = '';
    
    total += "var F = [" + functions.toString() + "];\r\n"; 
    total += "var A = [" + activations.toString() + "];\r\n";
    total += "var S = [" + states.toString() + "];\r\n";
    total += "function activate(input){\r\n" + lines.join('\r\n') + "\r\n}";
    return total;
  },

  /**
   * Tests a set and returns the error and elapsed time
   */
  test: function (set, cost) {
    if (cost == undefined) cost = methods.cost.MSE;
    // Check if dropout is enabled, set correct mask
    var i;
    if (this.dropout) {
      for (i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {
          this.nodes[i].mask = 1 - this.dropout;
        }
      }
    }

    var error = 0;
    var start = Date.now();

    for (i = 0; i < set.length; i++) {
      var input = set[i].input;
      var target = set[i].output;
      var output = this.noTraceActivate(input);
      error += cost(target, output);
    }

    error /= set.length;

    var results = {
      error: error,
      time: Date.now() - start
    };

    return results;
  },

  /**
   * Train the given set to this network
   */
  train: function (set, options) {
    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
      throw new Error('Dataset input/output size should be same as network input/output size!');
    }

    options = options || {};

    // Warning messages
    if (typeof options.rate === 'undefined') {
      if (config.warnings) console.warn('Using default learning rate, please define a rate!');
    }
    if (typeof options.iterations === 'undefined') {
      if (config.warnings) console.warn('No target iterations given, running until error is reached!');
    }

    // Read the options
    var targetError = options.error || 0.05;
    var cost = options.cost || methods.cost.MSE;
    var baseRate = options.rate || 0.3;
    var dropout = options.dropout || 0;
    var momentum = options.momentum || 0;
    var batchSize = options.batchSize || 1; // online learning
    var ratePolicy = options.ratePolicy || methods.rate.FIXED();

    var start = Date.now();

    if (batchSize > set.length) {
      throw new Error('Batch size must be smaller or equal to dataset length!');
    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {
      throw new Error('At least one of the following options must be specified: error, iterations');
    } else if (typeof options.error === 'undefined') {
      targetError = -1; // run until iterations
    } else if (typeof options.iterations === 'undefined') {
      options.iterations = 0; // run until target error
    }

    // Save to network
    this.dropout = dropout;

    if (options.crossValidate) {
      var numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);
      var trainSet = set.slice(0, numTrain);
      var testSet = set.slice(numTrain);
    }

    // Loops the training process
    var currentRate = baseRate;
    var iteration = 0;
    var error = 1;

    var i, j, x;
    while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {
      if (options.crossValidate && error <= options.crossValidate.testError) break;

      iteration++;

      // Update the rate
      currentRate = ratePolicy(baseRate, iteration);

      // Checks if cross validation is enabled
      if (options.crossValidate) {
        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);
        if (options.clear) this.clear();
        error = this.test(testSet, cost).error;
        if (options.clear) this.clear();
      } else {
        error = this._trainSet(set, batchSize, currentRate, momentum, cost);
        if (options.clear) this.clear();
      }

      // Checks for options such as scheduled logs and shuffling
      if (options.shuffle) {
        for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x);
      }

      if (options.log && iteration % options.log === 0) {
        console.log('iteration', iteration, 'error', error, 'rate', currentRate);
      }

      if (options.schedule && iteration % options.schedule.iterations === 0) {
        options.schedule.function({ error: error, iteration: iteration });
      }
    }

    if (options.clear) this.clear();

    if (dropout) {
      for (i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {
          this.nodes[i].mask = 1 - this.dropout;
        }
      }
    }

    return {
      error: error,
      iterations: iteration,
      time: Date.now() - start
    };
  },

  /**
   * Performs one training epoch and returns the error
   * private function used in this.train
   */
  _trainSet: function (set, batchSize, currentRate, momentum, costFunction) {
    var errorSum = 0;
    for (var i = 0; i < set.length; i++) {
      var input = set[i].input;
      var target = set[i].output;

      var update = !!((i + 1) % batchSize === 0 || (i + 1) === set.length);

      var output = this.activate(input, true);
      this.propagate(currentRate, momentum, update, target);
      errorSum += costFunction(target, output);
    }
    return errorSum / set.length;
  },



 /**
   * Convert the network to a json object
   */
  toJSON: function () {
    var json = {
      nodes: [],
      connections: [],
      input: this.input,
      output: this.output,
      dropout: this.dropout
    };

    // So we don't have to use expensive .indexOf()
    var i;
    for (i = 0; i < this.nodes.length; i++) {
      this.nodes[i].index = i;
    }

    for (i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      var tojson = node.toJSON();
      tojson.index = i;
      json.nodes.push(tojson);

      if (node.connections.self.weight !== 0) {
        var tojson = node.connections.self.toJSON();
        tojson.from = i;
        tojson.to = i;

        tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;
        json.connections.push(tojson);
      }
    }

    for (i = 0; i < this.connections.length; i++) {
      var conn = this.connections[i];
      var tojson = conn.toJSON();
      tojson.from = conn.from.index;
      tojson.to = conn.to.index;

      tojson.gater = conn.gater != null ? conn.gater.index : null;

      json.connections.push(tojson);
    }

    return json;
  },

  /**
   *  Remove the gate of a connection
   */
  ungate: function (connection) {
    var index = this.gates.indexOf(connection);
    if (index === -1) {
      throw new Error('This connection is not gated!');
    }

    this.gates.splice(index, 1);
    connection.gater.ungate(connection);
  },


};

/**
 * Convert a json object to a network
 */
Network.fromJSON = function (json) {
  var network = new Network(json.input, json.output);
  network.dropout = json.dropout;
  network.nodes = [];
  network.connections = [];
  network.groups = [];
  network.layers = [];
  var i;
  for (i = 0; i < json.nodes.length; i++) {
    var node = Node.fromJSON(json.nodes[i]);
    // reconstrct layers and groups
    network.nodes.push(node);
    if (!network.layers[node.layerid]) network.layers[node.layerid]={
      nodes       : [],
      connections : {in:[],out:[]},  // TODO
      input       : [],  // TODO
      output      : {nodes:[],connections:[]},  // TODO
    };
    network.layers[node.layerid].nodes.push(node);
    if (!network.groups[node.layerid]) network.groups[node.layerid]={
      nodes:[],
      connections:[] // TODO
    };
    network.groups[node.layerid].nodes.push(node);
  }

  for (i = 0; i < json.connections.length; i++) {
    var conn = json.connections[i];
    var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];
    connection.weight = conn.weight;
    if (conn.gater != null) {
      network.gate(network.nodes[conn.gater], connection);
    }
    network.connections.push(connection);
  }
  return network;
};

/**
 * Merge two networks into one
 */
Network.merge = function (network1, network2) {
  // Create a copy of the networks
  network1 = Network.fromJSON(network1.toJSON());
  network2 = Network.fromJSON(network2.toJSON());

  // Check if output and input size are the same
  if (network1.output !== network2.input) {
    throw new Error('Output size of network1 should be the same as the input size of network2!');
  }

  // Redirect all connections from network2 input from network1 output
  var i;
  for (i = 0; i < network2.connections.length; i++) {
    var conn = network2.connections[i];
    if (conn.from.type === 'input') {
      var index = network2.nodes.indexOf(conn.from);

      // redirect
      conn.from = network1.nodes[network1.nodes.length - 1 - index];
    }
  }

  // Delete input nodes of network2
  for (i = network2.input - 1; i >= 0; i--) {
    network2.nodes.splice(i, 1);
  }

  // Change the node type of network1's output nodes (now hidden)
  for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {
    network1.nodes[i].type = 'hidden';
  }

  // Create one network from both networks
  network1.connections = network1.connections.concat(network2.connections);
  network1.nodes = network1.nodes.concat(network2.nodes);

  return network1;
};

/**
 * Create an offspring from two parent networks
 */
Network.crossOver = function (network1, network2, equal) {
  if (network1.input !== network2.input || network1.output !== network2.output) {
    throw new Error("Networks don't have the same input/output size!");
  }

  // Initialise offspring
  var offspring = new Network(network1.input, network1.output);
  offspring.connections = [];
  offspring.nodes = [];

  // Save scores and create a copy
  var score1 = network1.score || 0;
  var score2 = network2.score || 0;

  // Determine offspring node size
  var size;
  if (equal || score1 === score2) {
    var max = Math.max(network1.nodes.length, network2.nodes.length);
    var min = Math.min(network1.nodes.length, network2.nodes.length);
    size = Math.floor(Math.random() * (max - min + 1) + min);
  } else if (score1 > score2) {
    size = network1.nodes.length;
  } else {
    size = network2.nodes.length;
  }

  // Rename some variables for easier reading
  var outputSize = network1.output;

  // Set indexes so we don't need indexOf
  var i;
  for (i = 0; i < network1.nodes.length; i++) {
    network1.nodes[i].index = i;
  }

  for (i = 0; i < network2.nodes.length; i++) {
    network2.nodes[i].index = i;
  }

  // Assign nodes from parents to offspring
  for (i = 0; i < size; i++) {
    // Determine if an output node is needed
    var node;
    if (i < size - outputSize) {
      var random = Math.random();
      node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];
      var other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];

      if (typeof node === 'undefined' || node.type === 'output') {
        node = other;
      }
    } else {
      if (Math.random() >= 0.5) {
        node = network1.nodes[network1.nodes.length + i - size];
      } else {
        node = network2.nodes[network2.nodes.length + i - size];
      }
    }

    var newNode = new Node();
    newNode.bias = node.bias;
    newNode.squash = node.squash;
    newNode.type = node.type;

    offspring.nodes.push(newNode);
  }

  // Create arrays of connection genes
  var n1conns = {};
  var n2conns = {};

  // Normal connections
  for (i = 0; i < network1.connections.length; i++) {
    var conn = network1.connections[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n1conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Selfconnections
  for (i = 0; i < network1.selfconns.length; i++) {
    var conn = network1.selfconns[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n1conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Normal connections
  for (i = 0; i < network2.connections.length; i++) {
    var conn = network2.connections[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n2conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Selfconnections
  for (i = 0; i < network2.selfconns.length; i++) {
    var conn = network2.selfconns[i];
    var data = {
      weight: conn.weight,
      from: conn.from.index,
      to: conn.to.index,
      gater: conn.gater != null ? conn.gater.index : -1
    };
    n2conns[Connection.innovationID(data.from, data.to)] = data;
  }

  // Split common conn genes from disjoint or excess conn genes
  var connections = [];
  var keys1 = Object.keys(n1conns);
  var keys2 = Object.keys(n2conns);
  for (i = keys1.length - 1; i >= 0; i--) {
    // Common gene
    if (typeof n2conns[keys1[i]] !== 'undefined') {
      var conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];
      connections.push(conn);

      // Because deleting is expensive, just set it to some value
      n2conns[keys1[i]] = undefined;
    } else if (score1 >= score2 || equal) {
      connections.push(n1conns[keys1[i]]);
    }
  }

  // Excess/disjoint gene
  if (score2 >= score1 || equal) {
    for (i = 0; i < keys2.length; i++) {
      if (typeof n2conns[keys2[i]] !== 'undefined') {
        connections.push(n2conns[keys2[i]]);
      }
    }
  }

  // Add common conn genes uniformly
  for (i = 0; i < connections.length; i++) {
    var connData = connections[i];
    if (connData.to < size && connData.from < size) {
      var from = offspring.nodes[connData.from];
      var to = offspring.nodes[connData.to];
      var conn = offspring.connect(from, to)[0];

      conn.weight = connData.weight;

      if (connData.gater !== -1 && connData.gater < size) {
        offspring.gate(offspring.nodes[connData.gater], conn);
      }
    }
  }

  return offspring;
};

/*******************************************************************************
                                        architect
*******************************************************************************/


var architect = {
  /**
   * Constructs a network from a given array of connected nodes
   */
  Construct: function (list) {
    // Create a network
    var network = new Network(0, 0),
        layers=[],
        groups=[];

    // Transform all groups into nodes
    var nodes = [];

    var i;
    for (i = 0; i < list.length; i++) {
      var j;
      if (list[i] instanceof Group) {
        groups.push(list[i]);
        for (j = 0; j < list[i].nodes.length; j++) {
          nodes.push(list[i].nodes[j]);
        }
      } else if (list[i] instanceof Layer) {
        layers.push(list[i]);
        for (j = 0; j < list[i].nodes.length; j++) {
          for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {
            nodes.push(list[i].nodes[j].nodes[k]);
          }
        }
      } else if (list[i] instanceof Node) {
        nodes.push(list[i]);
      }
    }

    // Determine input and output nodes
    var inputs = [];
    var outputs = [];
    for (i = nodes.length - 1; i >= 0; i--) {
      if (nodes[i].type === 'output' || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {
        nodes[i].type = 'output';
        network.output++;
        outputs.push(nodes[i]);
        nodes.splice(i, 1);
      } else if (nodes[i].type === 'input' || !nodes[i].connections.in.length) {
        nodes[i].type = 'input';
        network.input++;
        inputs.push(nodes[i]);
        nodes.splice(i, 1);
      }
    }

    // Input nodes are always first, output nodes are always last
    nodes = inputs.concat(nodes).concat(outputs);

    if (network.input === 0 || network.output === 0) {
      throw new Error('Given nodes have no clear input/output node!');
    }

    for (i = 0; i < nodes.length; i++) {
      var j;
      for (j = 0; j < nodes[i].connections.out.length; j++) {
        network.connections.push(nodes[i].connections.out[j]);
      }
      for (j = 0; j < nodes[i].connections.gated.length; j++) {
        network.gates.push(nodes[i].connections.gated[j]);
      }
      if (nodes[i].connections.self.weight !== 0) {
        network.selfconns.push(nodes[i].connections.self);
      }
    }

    network.nodes   = nodes;
    network.layers  = layers;
    network.groups  = groups.map(function (layer) {
      // reverse node order 
      return {nodes:layer.nodes.reverse(),connections:layer.connections,layerid:layer.layerid} 
    });
    return network;
  },

  /**
   * Creates a multilayer perceptron (MLP)
   */
  Perceptron: function () {
    // Convert arguments to Array
    var layers = Array.prototype.slice.call(arguments).filter(function (e) { return e!=null });
    if (layers.length < 3) {
      throw new Error('You have to specify at least 3 layers');
    }

    // Create a list of nodes/groups
    var nodes = [];
    nodes.push(new Group(layers[0],{layerid:0}));
    for (var i = 1; i < layers.length; i++) {
      var layer = layers[i];
      layer = new Group(layer,{layerid:i});
      nodes.push(layer);
      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);
    }

    // Construct the network
    return architect.Construct(nodes);
  },

  /**
   * Creates a randomly connected network
   */
  Random: function (input, hidden, output, options) {
    options = options || {};

    var connections = options.connections || hidden * 2;
    var backconnections = options.backconnections || 0;
    var selfconnections = options.selfconnections || 0;
    var gates = options.gates || 0;

    var network = new Network(input, output);

    var i;
    for (i = 0; i < hidden; i++) {
      network.mutate(methods.mutation.ADD_NODE);
    }

    for (i = 0; i < connections - hidden; i++) {
      network.mutate(methods.mutation.ADD_CONN);
    }

    for (i = 0; i < backconnections; i++) {
      network.mutate(methods.mutation.ADD_BACK_CONN);
    }

    for (i = 0; i < selfconnections; i++) {
      network.mutate(methods.mutation.ADD_SELF_CONN);
    }

    for (i = 0; i < gates; i++) {
      network.mutate(methods.mutation.ADD_GATE);
    }

    return network;
  },

  /**
   * Creates a long short-term memory network
   */
  LSTM: function () {
    var args = Array.prototype.slice.call(arguments);
    if (args.length < 3) {
      throw new Error('You have to specify at least 3 layers');
    }

    var last = args.pop();

    var outputLayer;
    if (typeof last === 'number') {
      outputLayer = new Group(last,{layerid:args.length});
      last = {};
    } else {
      outputLayer = new Group(args.pop(),{layerid:args.length}); // last argument
    }

    outputLayer.set({
      type: 'output'
    });

    var options = {};
    options.memoryToMemory = last.memoryToMemory || false;
    options.outputToMemory = last.outputToMemory || false;
    options.outputToGates = last.outputToGates || false;
    options.inputToOutput = last.inputToOutput === undefined ? true : last.inputToOutput;
    options.inputToDeep = last.inputToDeep === undefined ? true : last.inputToDeep;
    // set all conenction weights to this default value - otherwise a random value is chosen
    options.weight = last.weight;

    var inputLayer = new Group(args.shift(),{layerid:0}); // first argument
    inputLayer.set({
      type: 'input'
    });

    var blocks = args; // all the arguments in the middle

    var nodes = [];
    nodes.push(inputLayer);

    var previous = inputLayer;
    for (var i = 0; i < blocks.length; i++) {
      var block = blocks[i];

      // Init required nodes (in activation order)
      var inputGate = new Group(block,{layerid:i+1});
      var forgetGate = new Group(block,{layerid:i+1});
      var memoryCell = new Group(block,{layerid:i+1});
      var outputGate = new Group(block,{layerid:i+1});
      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block,{layerid:i+1});

      inputGate.set({
        bias: 1
      });
      forgetGate.set({
        bias: 1
      });
      outputGate.set({
        bias: 1
      });

      // Connect the input with all the nodes
      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
      previous.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
      previous.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
      previous.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);

      // Set up internal connections
      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);
      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE,options.weight);
      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL,options.weight);

      // Set up gates
      inputGate.gate(input, methods.gating.INPUT);
      forgetGate.gate(forget, methods.gating.SELF);
      outputGate.gate(output, methods.gating.OUTPUT);

      // Input to all memory cells
      if (options.inputToDeep && i > 0) {
        var input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
        inputGate.gate(input, methods.gating.INPUT);
      }

      // Optional connections
      if (options.memoryToMemory) {
        var input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE,options.weight);
        inputGate.gate(input, methods.gating.INPUT);
      }

      if (options.outputToMemory) {
        var input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
        inputGate.gate(input, methods.gating.INPUT);
      }

      if (options.outputToGates) {
        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);
        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
      }

      // Add to array
      nodes.push(inputGate);
      nodes.push(forgetGate);
      nodes.push(memoryCell);
      nodes.push(outputGate);
      if (i !== blocks.length - 1) nodes.push(outputBlock);

      previous = outputBlock;
    }

    // input to output direct connection
    if (options.inputToOutput) {
      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL,options.weight);
    }

    nodes.push(outputLayer);
    return architect.Construct(nodes);
  },

  /**
   * Creates a gated recurrent unit network
   */
  GRU: function () {
    var args = Array.prototype.slice.call(arguments);
    if (args.length < 3) {
      throw new Error('not enough layers (minimum 3) !!');
    }

    var inputLayer = new Group(args.shift(),{layerid:0}); // first argument
    var outputLayer = new Group(args.pop(),{layerid:args.length}); // last argument
    var blocks = args; // all the arguments in the middle

    var nodes = [];
    nodes.push(inputLayer);

    var previous = inputLayer;
    for (var i = 0; i < blocks.length; i++) {
      var layer = new Layer.GRU(blocks[i],{layerid:i+1});
      previous.connect(layer);
      previous = layer;
      nodes.push(layer);
    }

    previous.connect(outputLayer);
    nodes.push(outputLayer);

    return architect.Construct(nodes);
  },

  /**
   * Creates a hopfield network of the given size
   */
  Hopfield: function (size) {
    var input = new Group(size);
    var output = new Group(size);

    input.connect(output, methods.connection.ALL_TO_ALL);

    input.set({
      type: 'input'
    });
    output.set({
      squash: methods.activation.STEP,
      type: 'output'
    });

    var network = new architect.Construct([input, output]);

    return network;
  },

  /**
   * Creates a NARX network (remember previous inputs/outputs)
   */
  NARX: function (inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {
    if (!Array.isArray(hiddenLayers)) {
      hiddenLayers = [hiddenLayers];
    }

    var nodes = [];

    var input = new Layer.Dense(inputSize);
    var inputMemory = new Layer.Memory(inputSize, previousInput);
    var hidden = [];
    var output = new Layer.Dense(outputSize);
    var outputMemory = new Layer.Memory(outputSize, previousOutput);

    nodes.push(input);
    nodes.push(outputMemory);

    for (var i = 0; i < hiddenLayers.length; i++) {
      var hiddenLayer = new Layer.Dense(hiddenLayers[i]);
      hidden.push(hiddenLayer);
      nodes.push(hiddenLayer);
      if (typeof hidden[i - 1] !== 'undefined') {
        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);
      }
    }

    nodes.push(inputMemory);
    nodes.push(output);

    input.connect(hidden[0], methods.connection.ALL_TO_ALL);
    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);
    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);
    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);
    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);
    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);

    input.set({
      type: 'input'
    });
    output.set({
      type: 'output'
    });

    return architect.Construct(nodes);
  },
  
  // Generic forward ANN
  Network : function () {
    config.groupid=0;
    var args = Array.prototype.slice.call(arguments);
    if (args.length < 2) {
      throw new Error('You have to specify at least 2 layers');
    }
    if (args.length==2) {
      // SLP
      var net = new Network(args[0],args[1]),
          groups = [{nodes:[]},{nodes:[]}];
      net.nodes.forEach(function (node) {
        if (node.type=='input') {
          node.layerid=0;
          groups[0].nodes.push(node);
        } else {
          node.layerid=1;
          groups[1].nodes.push(node);
        }
      });
      net.groups=groups;
      return net;
    } else return new architect.Perceptron(args[0],args[1],args[2],args[3],args[4],args[5],
                                           args[6],args[7],args[8],args[9]);
  },
  /*
    Construct mixed layer network:  
    typeof @options = {
       architect : string [] // Dense LSTM ...
       layers : number []  // number of nodes
       .. more options
     }
  */
  Layers : function (options) {
    var layers = [];
    var inputLayer,prevLay;
    for(var i in options.architect) {
      var layA=options.architect[i],
          layN=options.layers[i];
      if (!Layer[layA]) throw "ANN.Layer: invalid layer architect "+layA;
      var lay;
      if (layA=='LSTM') 
        lay = new Layer[layA](layN,
                              options,
                              inputLayer && inputLayer!=prevLay?inputLayer:null /* for inputToDeep*/,
                              null /* outputLayer ?*/);
      else
        lay = new Layer[layA](layN,options);
      if (layA=='Dense') inputLayer=lay;
      prevLay=lay;
      layers.push(lay);
    }
    for(var i in options.architect) {
      i=Number(i);
      var layA=options.architect[i],
          layN=options.layers[i],
          lay=layers[i];
      // handle some layer-to-layer connect options
      if (layA=='LSTM') {
        // input to output direct connection
        if (options.inputToOutput) { 
          var inputLayer=null,
              outputLayer=null;
          // search dense layers backward and forward
          if (options.architect[i-1]=='Dense') inputLayer=layers[i-1];
          if (inputLayer) for(var j=i+1;j<options.architect.length;j++) {
            if (options.architect[j]=='Dense') {
              outputLayer=layers[j];
              break;
            }
          }
          if (inputLayer && outputLayer) {
            console.log('inputToOutput')
            inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL,options.weight);
          }
        }
      }
    }
    prevLay=null;
    for(var i in options.architect) {
      var layA=options.architect[i],
          layN=options.layers[i],
          lay=layers[i];
      if (prevLay) prevLay.connect(lay); 
      prevLay=lay;
    }
    return layers;  
  }
  
};




/*******************************************************************************
                                         NODE
*******************************************************************************/

function Node (type,options) {
  this.bias = (type === 'input') ? 0 : Math.random() * 0.2 - 0.1;
  this.squash = methods.activation.LOGISTIC;
  this.type = type || 'hidden';

  this.activation = 0;
  this.state = 0;
  this.old = 0;
  this.update = 0; // activation update cpunter / time stamp
  if (options && options.layerid != undefined) this.layerid=options.layerid;
  if (options && options.group) this.group=options.group;
  // For dropout
  this.mask = 1;

  // For tracking momentum
  this.previousDeltaBias = 0;

  // Batch training
  this.totalDeltaBias = 0;

  this.connections = {
    in: [],
    out: [],
    gated: [],
    self: new Connection(this, this, 0)
  };

  // Data for backpropagation
  this.error = {
    responsibility: 0,
    projected: 0,
    gated: 0
  };
}

Node.prototype = {
  /**
   * Activates the node
   */
  preactivate : function () {
    // Precompute the activation state without changing the state of the node actually!
    // required for group activation (softmax)
    // All activation sources coming from the node itself
    var state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    var i;
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];
      state += connection.from.activation * connection.weight * connection.gain;
    }

    return state;
  },
  
  activate: function (input) {
    // Check if an input is given
    if (typeof input !== 'undefined') {
      this.activation = input;
      return this.activation;
    }

    this.old = this.state;

    var newstate = this.preactivate();
    
    // All activation sources coming from the node itself
    //this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    //var i;
    //for (i = 0; i < this.connections.in.length; i++) {
    //  var connection = this.connections.in[i];
    //  this.state += connection.from.activation * connection.weight * connection.gain;
    //}

    // Squash the values received
    // The softmax function (group function) reqires entire layer group access to computer this activation!
    this.activation = this.squash(newstate, false, this.group) * this.mask;
    this.derivative = this.squash(newstate, true,  this.group);

    this.state = newstate;
    this.update++;
    
    // Update traces
    var nodes = [];
    var influences = [];

    for (i = 0; i < this.connections.gated.length; i++) {
      var conn = this.connections.gated[i];
      var node = conn.to;

      var index = nodes.indexOf(node);
      if (index > -1) {
        influences[index] += conn.weight * conn.from.activation;
      } else {
        nodes.push(node);
        influences.push(conn.weight * conn.from.activation +
          (node.connections.self.gater === this ? node.old : 0));
      }

      // Adjust the gain to this nodes' activation
      conn.gain = this.activation;
    }

    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      // Elegibility trace
      connection.elegibility = this.connections.self.gain * this.connections.self.weight *
        connection.elegibility + connection.from.activation * connection.gain;

      // Extended trace
      for (var j = 0; j < nodes.length; j++) {
        var node = nodes[j];
        var influence = influences[j];

        var index = connection.xtrace.nodes.indexOf(node);

        if (index > -1) {
          connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *
            connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;
        } else {
          // Does not exist there yet, might be through mutation
          connection.xtrace.nodes.push(node);
          connection.xtrace.values.push(this.derivative * connection.elegibility * influence);
        }
      }
    }

    return this.activation;
  },

  /**
   * Activates the node without calculating elegibility traces and such
   */
  noTraceActivate: function (input) {
    // Check if an input is given
    if (typeof input !== 'undefined') {
      this.activation = input;
      return this.activation;
    }

    // All activation sources coming from the node itself
    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    var i;
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];
      this.state += connection.from.activation * connection.weight * connection.gain;
    }

    // Squash the values received
    this.activation = this.squash(this.state);

    for (i = 0; i < this.connections.gated.length; i++) {
      this.connections.gated[i].gain = this.activation;
    }

    return this.activation;
  },

  /**
   * Back-propagate the error, aka learn
   */
  propagate: function (rate, momentum, update, target) {
    momentum = momentum || 0;
    rate = rate || 0.3;

    // Error accumulator
    var error = 0;

    // Output nodes get their error from the enviroment
    if (this.type === 'output') {
      this.error.responsibility = this.error.projected = target - this.activation;
    } else { // the rest of the nodes compute their error responsibilities by backpropagation
      // error responsibilities from all the connections projected from this node
      var i;
      for (i = 0; i < this.connections.out.length; i++) {
        var connection = this.connections.out[i];
        var node = connection.to;
        // Eq. 21
        error += node.error.responsibility * connection.weight * connection.gain;
      }

      // Projected error responsibility
      this.error.projected = this.derivative * error;

      // Error responsibilities from all connections gated by this neuron
      error = 0;

      for (i = 0; i < this.connections.gated.length; i++) {
        var conn = this.connections.gated[i];
        var node = conn.to;
        var influence = node.connections.self.gater === this ? node.old : 0;

        influence += conn.weight * conn.from.activation;
        error += node.error.responsibility * influence;
      }

      // Gated error responsibility
      this.error.gated = this.derivative * error;

      // Error responsibility
      this.error.responsibility = this.error.projected + this.error.gated;
    }

    if (this.type === 'constant') return;

    // Adjust all the node's incoming connections
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      var gradient = this.error.projected * connection.elegibility;

      for (var j = 0; j < connection.xtrace.nodes.length; j++) {
        var node = connection.xtrace.nodes[j];
        var value = connection.xtrace.values[j];
        gradient += node.error.responsibility * value;
      }

      // Adjust weight
      var deltaWeight = rate * gradient * this.mask;
      connection.totalDeltaWeight += deltaWeight;
      if (update) {
        connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;
        connection.weight += connection.totalDeltaWeight;
        connection.previousDeltaWeight = connection.totalDeltaWeight;
        connection.totalDeltaWeight = 0;
      }
    }

    // Adjust bias
    var deltaBias = rate * this.error.responsibility;
    this.totalDeltaBias += deltaBias;
    if (update) {
      this.totalDeltaBias += momentum * this.previousDeltaBias;
      this.bias += this.totalDeltaBias;
      this.previousDeltaBias = this.totalDeltaBias;
      this.totalDeltaBias = 0;
    }
  },

  /**
   * Creates a connection from this node to the given node
   */
  connect: function (target, weight) {
    var connections = [];
    if (typeof target.bias !== 'undefined') { // must be a node!
      if (target === this) {
        // Turn on the self connection by setting the weight
        if (this.connections.self.weight !== 0) {
          if (config.warnings) console.warn('This connection already exists!');
        } else {
          this.connections.self.weight = weight || 1;
        }
        connections.push(this.connections.self);
      } else if (this.isProjectingTo(target)) {
        throw new Error('Already projecting a connection to this node!');
      } else {
        var connection = new Connection(this, target, weight);
        target.connections.in.push(connection);
        this.connections.out.push(connection);

        connections.push(connection);
      }
    } else { // should be a group
      for (var i = 0; i < target.nodes.length; i++) {
        var connection = new Connection(this, target.nodes[i], weight);
        target.nodes[i].connections.in.push(connection);
        this.connections.out.push(connection);
        target.connections.in.push(connection);

        connections.push(connection);
      }
    }
    return connections;
  },

  /**
   * Disconnects this node from the other node
   */
  disconnect: function (node, twosided) {
    if (this === node) {
      this.connections.self.weight = 0;
      return;
    }

    for (var i = 0; i < this.connections.out.length; i++) {
      var conn = this.connections.out[i];
      if (conn.to === node) {
        this.connections.out.splice(i, 1);
        var j = conn.to.connections.in.indexOf(conn);
        conn.to.connections.in.splice(j, 1);
        if (conn.gater !== null) conn.gater.ungate(conn);
        break;
      }
    }

    if (twosided) {
      node.disconnect(this);
    }
  },

  /**
   * Make this node gate a connection
   */
  gate: function (connections) {
    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];

      this.connections.gated.push(connection);
      connection.gater = this;
    }
  },

  /**
   * Removes the gates from this node from the given connection(s)
   */
  ungate: function (connections) {
    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    for (var i = connections.length - 1; i >= 0; i--) {
      var connection = connections[i];

      var index = this.connections.gated.indexOf(connection);
      this.connections.gated.splice(index, 1);
      connection.gater = null;
      connection.gain = 1;
    }
  },

  /**
   * Clear the context of the node
   */
  clear: function () {
    for (var i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      connection.elegibility = 0;
      connection.xtrace = {
        nodes: [],
        values: []
      };
    }

    for (i = 0; i < this.connections.gated.length; i++) {
      var conn = this.connections.gated[i];
      conn.gain = 0;
    }

    this.error.responsibility = this.error.projected = this.error.gated = 0;
    this.old = this.state = this.activation = 0;
  },

  /**
   * Mutates the node with the given method
   */
  mutate: function (method) {
    if (typeof method === 'undefined') {
      throw new Error('No mutate method given!');
    } else if (!(method.name in methods.mutation)) {
      throw new Error('This method does not exist!');
    }

    switch (method) {
      case methods.mutation.MOD_ACTIVATION:
        // Can't be the same squash
        var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];
        this.squash = squash;
        break;
      case methods.mutation.MOD_BIAS:
        var modification = Math.random() * (method.max - method.min) + method.min;
        this.bias += modification;
        break;
    }
  },

  /**
   * Checks if this node is projecting to the given node
   */
  isProjectingTo: function (node) {
    if (node === this && this.connections.self.weight !== 0) return true;

    for (var i = 0; i < this.connections.out.length; i++) {
      var conn = this.connections.out[i];
      if (conn.to === node) {
        return true;
      }
    }
    return false;
  },

  /**
   * Checks if the given node is projecting to this node
   */
  isProjectedBy: function (node) {
    if (node === this && this.connections.self.weight !== 0) return true;

    for (var i = 0; i < this.connections.in.length; i++) {
      var conn = this.connections.in[i];
      if (conn.from === node) {
        return true;
      }
    }

    return false;
  },

  /**
   * Converts the node to a json object
   */
  toJSON: function () {
    var json = {
      bias: this.bias,
      type: this.type,
      squash: this.squash.name,
      layerid : this.layerid,
      groupid : this.group && this.group.id,
      mask: this.mask
    };

    return json;
  }
};

/**
 * Convert a json object to a node
 */
Node.fromJSON = function (json) {
  var node = new Node();
  node.bias = json.bias;
  node.type = json.type;
  node.mask = json.mask;
  node.layerid = json.layerid;
  node.squash = methods.activation[json.squash];
  node.groupid = json.groupid; // TODO recreate node.group=Group() for all nodes with groupid
  return node;
};

/*******************************************************************************
                                         Group
*******************************************************************************/

function Layer () {
  this.output = null;

  this.nodes = [];
  this.connections = { in: [],
    out: [],
    self: []
  };
}

Layer.prototype = {
  /**
   * Activates all the nodes in the group
   */
  activate: function (value) {
    var values = [];

    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = 0; i < this.nodes.length; i++) {
      var activation;
      if (typeof value === 'undefined') {
        activation = this.nodes[i].activate();
      } else {
        activation = this.nodes[i].activate(value[i]);
      }

      values.push(activation);
    }

    return values;
  },

  /**
   * Propagates all the node in the group
   */
  propagate: function (rate, momentum, target) {
    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (typeof target === 'undefined') {
        this.nodes[i].propagate(rate, momentum, true);
      } else {
        this.nodes[i].propagate(rate, momentum, true, target[i]);
      }
    }
  },

  /**
   * Connects the nodes in this group to nodes in another group or just a node
   */
  connect: function (target, method, weight) {
    var connections;
    if (target instanceof Group || target instanceof Node) {
      connections = this.output.connect(target, method, weight);
    } else if (target instanceof Layer) {
      connections = target.input(this, method, weight);
    }

    return connections;
  },

  /**
   * Make nodes from this group gate the given connection(s)
   */
  gate: function (connections, method) {
    this.output.gate(connections, method);
  },

  /**
   * Sets the value of a property for every node
   */
  set: function (values) {
    for (var i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];

      if (node instanceof Node) {
        if (typeof values.bias !== 'undefined') {
          node.bias = values.bias;
        }

        node.squash = values.squash || node.squash;
        node.type = values.type || node.type;
      } else if (node instanceof Group) {
        node.set(values);
      }
    }
  },

  /**
   * Disconnects all nodes from this group from another given group/node
   */
  disconnect: function (target, twosided) {
    twosided = twosided || false;

    // In the future, disconnect will return a connection so indexOf can be used
    var i, j, k;
    if (target instanceof Group) {
      for (i = 0; i < this.nodes.length; i++) {
        for (j = 0; j < target.nodes.length; j++) {
          this.nodes[i].disconnect(target.nodes[j], twosided);

          for (k = this.connections.out.length - 1; k >= 0; k--) {
            var conn = this.connections.out[k];

            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
              this.connections.out.splice(k, 1);
              break;
            }
          }

          if (twosided) {
            for (k = this.connections.in.length - 1; k >= 0; k--) {
              var conn = this.connections.in[k];

              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                this.connections.in.splice(k, 1);
                break;
              }
            }
          }
        }
      }
    } else if (target instanceof Node) {
      for (i = 0; i < this.nodes.length; i++) {
        this.nodes[i].disconnect(target, twosided);

        for (j = this.connections.out.length - 1; j >= 0; j--) {
          var conn = this.connections.out[j];

          if (conn.from === this.nodes[i] && conn.to === target) {
            this.connections.out.splice(j, 1);
            break;
          }
        }

        if (twosided) {
          for (k = this.connections.in.length - 1; k >= 0; k--) {
            var conn = this.connections.in[k];

            if (conn.from === target && conn.to === this.nodes[i]) {
              this.connections.in.splice(k, 1);
              break;
            }
          }
        }
      }
    }
  },

  /**
   * Clear the context of this group
   */
  clear: function () {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }
};

Layer.Dense = function (size) {
  // Create the layer
  var layer = new Layer();

  // Init required nodes (in activation order)
  var block = new Group(size);

  layer.nodes.push(block);
  layer.output = block;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;
    return from.connect(block, method, weight);
  };

  return layer;
};

Layer.LSTM = function (size,options,inputLayer,outputLayer) {
  options=options||{}
  // Create the layer
  var layer = new Layer();

  // Init required nodes (in activation order)
  var inputGate = new Group(size);
  var forgetGate = new Group(size);
  var memoryCell = new Group(size);
  var outputGate = new Group(size);
  var outputBlock = new Group(size);

  inputGate.set({
    bias: 1
  });
  forgetGate.set({
    bias: 1
  });
  outputGate.set({
    bias: 1
  });

  // Set up internal connections
  memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);
  memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);
  memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);
  var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);
  var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);

  // Set up gates
  forgetGate.gate(forget, methods.gating.SELF);
  outputGate.gate(output, methods.gating.OUTPUT);

  // Add to nodes array
  layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];

  // Define output
  layer.output = outputBlock;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;
    var connections = [];

    var input = from.connect(memoryCell, method, weight);
    connections = connections.concat(input);

    connections = connections.concat(from.connect(inputGate, method, weight));
    connections = connections.concat(from.connect(outputGate, method, weight));
    connections = connections.concat(from.connect(forgetGate, method, weight));

    inputGate.gate(input, methods.gating.INPUT);

    return connections;
  };

  // @blab TODO TBC Optional connections
  // Input to all memory cells
  if (inputLayer && options.inputToDeep) {
    console.log('inputToDeep')
    var input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
    inputGate.gate(input, methods.gating.INPUT);
  }
  // Optional connections
  if (options.memoryToMemory) {
    console.log('memoryToMemory')
    var input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE,options.weight);
    inputGate.gate(input, methods.gating.INPUT);
  }
  if (options.outputToMemory) {
    console.log('outputToMemory')
    var input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL,options.weight);
    inputGate.gate(input, methods.gating.INPUT);
  }
  if (outputLayer && options.outputToGates) {
    console.log('outputToGates')
    outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL,options.weight);
    outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL,options.weight);
    outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL,options.weight);
  }

  return layer;
};

Layer.GRU = function (size,options) {
  // Create the layer
  var layer = new Layer();
  var layerid = options && options.layerid;
  var updateGate = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var inverseUpdateGate = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var resetGate = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var memoryCell = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var output = new Group(size,layerid!=undefined?{layerid:layerid}:{});
  var previousOutput = new Group(size,layerid!=undefined?{layerid:layerid}:{});

  previousOutput.set({
    bias: 0,
    squash: methods.activation.IDENTITY,
    type: 'constant'
  });
  memoryCell.set({
    squash: methods.activation.TANH
  });
  inverseUpdateGate.set({
    bias: 0,
    squash: methods.activation.INVERSE,
    type: 'constant'
  });
  updateGate.set({
    bias: 1
  });
  resetGate.set({
    bias: 0
  });

  // Update gate calculation
  previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);

  // Inverse update gate calculation
  updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);

  // Reset gate calculation
  previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);

  // Memory calculation
  var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);

  resetGate.gate(reset, methods.gating.OUTPUT); // gate

  // Output calculation
  var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);
  var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);

  updateGate.gate(update1, methods.gating.OUTPUT);
  inverseUpdateGate.gate(update2, methods.gating.OUTPUT);

  // Previous output calculation
  output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);

  // Add to nodes array
  layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];

  layer.output = output;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;
    var connections = [];

    connections = connections.concat(from.connect(updateGate, method, weight));
    connections = connections.concat(from.connect(resetGate, method, weight));
    connections = connections.concat(from.connect(memoryCell, method, weight));

    return connections;
  };

  return layer;
};

Layer.Memory = function (size, memory) {
  // Create the layer
  var layer = new Layer();
  // Because the output can only be one group, we have to put the nodes all in óne group

  var previous = null;
  var i;
  for (i = 0; i < memory; i++) {
    var block = new Group(size);

    block.set({
      squash: methods.activation.IDENTITY,
      bias: 0,
      type: 'constant'
    });

    if (previous != null) {
      previous.connect(block, methods.connection.ONE_TO_ONE, 1);
    }

    layer.nodes.push(block);
    previous = block;
  }

  layer.nodes.reverse();

  for (i = 0; i < layer.nodes.length; i++) {
    layer.nodes[i].nodes.reverse();
  }

  // Because output can only be óne group, fit all memory nodes in óne group
  var outputGroup = new Group(0);
  for (var group in layer.nodes) {
    outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);
  }
  layer.output = outputGroup;

  layer.input = function (from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;

    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {
      throw new Error('Previous layer size must be same as memory size');
    }

    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);
  };

  return layer;
};


/*******************************************************************************
                                         Group
*******************************************************************************/

function Group (size,options) {
  this.nodes = [];
  this.connections = {
    in: [],
    out: [],
    self: []
  };
  this.id=config.groupId++;
  if (options && options.layerid!=undefined) this.layerid=options.layerid;
  for (var i = 0; i < size; i++) {
    var node = new Node(null,this.layerid!=undefined?{layerid:this.layerid,group:this}:{group:this});
    this.nodes.push(node);
  }
}

Group.prototype = {
  /**
   * Activates all the nodes in the group
   */
  activate: function (value) {
    var values = [];

    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = 0; i < this.nodes.length; i++) {
      var activation;
      if (typeof value === 'undefined') {
        activation = this.nodes[i].activate();
      } else {
        activation = this.nodes[i].activate(value[i]);
      }

      values.push(activation);
    }

    return values;
  },

  /**
   * Propagates all the node in the group
   */
  propagate: function (rate, momentum, target) {
    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (typeof target === 'undefined') {
        this.nodes[i].propagate(rate, momentum, true);
      } else {
        this.nodes[i].propagate(rate, momentum, true, target[i]);
      }
    }
  },

  /**
   * Connects the nodes in this group to nodes in another group or just a node
   */
  connect: function (target, method, weight) {
    var connections = [];
    var i, j;
    if (target instanceof Group) {
      if (typeof method === 'undefined') {
        if (this !== target) {
          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');
          method = methods.connection.ALL_TO_ALL;
        } else {
          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');
          method = methods.connection.ONE_TO_ONE;
        }
      }
      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {
        for (i = 0; i < this.nodes.length; i++) {
          for (j = 0; j < target.nodes.length; j++) {
            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;
            var connection = this.nodes[i].connect(target.nodes[j], weight);
            this.connections.out.push(connection[0]);
            target.connections.in.push(connection[0]);
            connections.push(connection[0]);
          }
        }
      } else if (method === methods.connection.ONE_TO_ONE) {
        if (this.nodes.length !== target.nodes.length) {
          throw new Error('From and To group must be the same size!');
        }

        for (i = 0; i < this.nodes.length; i++) {
          var connection = this.nodes[i].connect(target.nodes[i], weight);
          this.connections.self.push(connection[0]);
          connections.push(connection[0]);
        }
      }
    } else if (target instanceof Layer) {
      connections = target.input(this, method, weight);
    } else if (target instanceof Node) {
      for (i = 0; i < this.nodes.length; i++) {
        var connection = this.nodes[i].connect(target, weight);
        this.connections.out.push(connection[0]);
        connections.push(connection[0]);
      }
    }

    return connections;
  },

  /**
   * Make nodes from this group gate the given connection(s)
   */
  gate: function (connections, method) {
    if (typeof method === 'undefined') {
      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');
    }

    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    var nodes1 = [];
    var nodes2 = [];

    var i, j;
    for (i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);
      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);
    }

    switch (method) {
      case methods.gating.INPUT:
        for (i = 0; i < nodes2.length; i++) {
          var node = nodes2[i];
          var gater = this.nodes[i % this.nodes.length];

          for (j = 0; j < node.connections.in.length; j++) {
            var conn = node.connections.in[j];
            if (connections.includes(conn)) {
              gater.gate(conn);
            }
          }
        }
        break;
      case methods.gating.OUTPUT:
        for (i = 0; i < nodes1.length; i++) {
          var node = nodes1[i];
          var gater = this.nodes[i % this.nodes.length];

          for (j = 0; j < node.connections.out.length; j++) {
            var conn = node.connections.out[j];
            if (connections.includes(conn)) {
              gater.gate(conn);
            }
          }
        }
        break;
      case methods.gating.SELF:
        for (i = 0; i < nodes1.length; i++) {
          var node = nodes1[i];
          var gater = this.nodes[i % this.nodes.length];

          if (connections.includes(node.connections.self)) {
            gater.gate(node.connections.self);
          }
        }
    }
  },

  /**
   * Sets the value of a property for every node
   */
  set: function (values) {
    for (var i = 0; i < this.nodes.length; i++) {
      if (typeof values.bias !== 'undefined') {
        this.nodes[i].bias = values.bias;
      }

      this.nodes[i].squash = values.squash || this.nodes[i].squash;
      this.nodes[i].type = values.type || this.nodes[i].type;
    }
  },

  /**
   * Disconnects all nodes from this group from another given group/node
   */
  disconnect: function (target, twosided) {
    twosided = twosided || false;

    // In the future, disconnect will return a connection so indexOf can be used
    var i, j, k;
    if (target instanceof Group) {
      for (i = 0; i < this.nodes.length; i++) {
        for (j = 0; j < target.nodes.length; j++) {
          this.nodes[i].disconnect(target.nodes[j], twosided);

          for (k = this.connections.out.length - 1; k >= 0; k--) {
            var conn = this.connections.out[k];

            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
              this.connections.out.splice(k, 1);
              break;
            }
          }

          if (twosided) {
            for (k = this.connections.in.length - 1; k >= 0; k--) {
              var conn = this.connections.in[k];

              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                this.connections.in.splice(k, 1);
                break;
              }
            }
          }
        }
      }
    } else if (target instanceof Node) {
      for (i = 0; i < this.nodes.length; i++) {
        this.nodes[i].disconnect(target, twosided);

        for (j = this.connections.out.length - 1; j >= 0; j--) {
          var conn = this.connections.out[j];

          if (conn.from === this.nodes[i] && conn.to === target) {
            this.connections.out.splice(j, 1);
            break;
          }
        }

        if (twosided) {
          for (j = this.connections.in.length - 1; j >= 0; j--) {
            var conn = this.connections.in[j];

            if (conn.from === target && conn.to === this.nodes[i]) {
              this.connections.in.splice(j, 1);
              break;
            }
          }
        }
      }
    }
  },

  /**
   * Clear the context of this group
   */
  clear: function () {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }
};

/* Easier variable naming */
var selection = methods.selection;

/*******************************************************************************
                                         NEAT
*******************************************************************************/

function Neat (input, output, fitness, options) {
  this.input = input; // The input size of the networks
  this.output = output; // The output size of the networks
  this.fitness = fitness; // The fitness function to evaluate the networks

  // Configure options
  options = options || {};
  this.equal = options.equal || false;
  this.clear = options.clear || false;
  this.popsize = options.popsize || 50;
  this.elitism = options.elitism || 0;
  this.provenance = options.provenance || 0;
  this.mutationRate = options.mutationRate || 0.3;
  this.mutationAmount = options.mutationAmount || 1;

  this.fitnessPopulation = options.fitnessPopulation || false;

  this.selection = options.selection || methods.selection.POWER;
  this.crossover = options.crossover || [
    methods.crossover.SINGLE_POINT,
    methods.crossover.TWO_POINT,
    methods.crossover.UNIFORM,
    methods.crossover.AVERAGE
  ];
  this.mutation = options.mutation || methods.mutation.FFW;

  this.template = options.network || false;

  this.maxNodes = options.maxNodes || Infinity;
  this.maxConns = options.maxConns || Infinity;
  this.maxGates = options.maxGates || Infinity;

  // Custom mutation selection function if given
  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;

  // Generation counter
  this.generation = 0;

  // Initialise the genomes
  this.createPool(this.template);
}

Neat.prototype = {
  /**
   * Create the initial pool of genomes
   */
  createPool: function (network) {
    this.population = [];

    for (var i = 0; i < this.popsize; i++) {
      var copy;
      if (this.template) {
        copy = Network.fromJSON(network.toJSON());
      } else {
        copy = new Network(this.input, this.output);
      }
      copy.score = undefined;
      this.population.push(copy);
    }
  },

  /**
   * Evaluates, selects, breeds and mutates population
   */
  evolve: function () {
    // Check if evaluated, sort the population
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }
    this.sort();

    var fittest = Network.fromJSON(this.population[0].toJSON());
    fittest.score = this.population[0].score;

    var newPopulation = [];

    // Elitism
    var elitists = [];
    for (var i = 0; i < this.elitism; i++) {
      elitists.push(this.population[i]);
    }

    // Provenance
    for (i = 0; i < this.provenance; i++) {
      newPopulation.push(Network.fromJSON(this.template.toJSON()));
    }

    // Breed the next individuals
    for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {
      newPopulation.push(this.getOffspring());
    }

    // Replace the old population with the new population
    this.population = newPopulation;
    this.mutate();

    // this.population.push(...elitists);
    var _this$population;
    (_this$population = this.population).push.apply(_this$population, elitists); 

    // Reset the scores
    for (i = 0; i < this.population.length; i++) {
      this.population[i].score = undefined;
    }

    this.generation++;

    return fittest;
  },

  /**
   * Breeds two parents into an offspring, population MUST be surted
   */
  getOffspring: function () {
    var parent1 = this.getParent();
    var parent2 = this.getParent();

    return Network.crossOver(parent1, parent2, this.equal);
  },

  /**
   * Selects a random mutation method for a genome according to the parameters
   */
  selectMutationMethod: function (genome) {
    var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];

    if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {
      if (config.warnings) console.warn('maxNodes exceeded!');
      return;
    }

    if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {
      if (config.warnings) console.warn('maxConns exceeded!');
      return;
    }

    if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {
      if (config.warnings) console.warn('maxGates exceeded!');
      return;
    }

    return mutationMethod;
  },

  /**
   * Mutates the given (or current) population
   */
  mutate: function () {
    // Elitist genomes should not be included
    for (var i = 0; i < this.population.length; i++) {
      if (Math.random() <= this.mutationRate) {
        for (var j = 0; j < this.mutationAmount; j++) {
          var mutationMethod = this.selectMutationMethod(this.population[i]);
          this.population[i].mutate(mutationMethod);
        }
      }
    }
  },

  /**
   * Evaluates the current population
   */
  evaluate: function () {
    var i;
    if (this.fitnessPopulation) {
      if (this.clear) {
        for (i = 0; i < this.population.length; i++) {
          this.population[i].clear();
        }
      }
      this.fitness(this.population);
    } else {
      for (i = 0; i < this.population.length; i++) {
        var genome = this.population[i];
        if (this.clear) genome.clear();
        genome.score = this.fitness(genome);
      }
    }
  },

  /**
   * Sorts the population by score
   */
  sort: function () {
    this.population.sort(function (a, b) {
      return b.score - a.score;
    });
  },

  /**
   * Returns the fittest genome of the current population
   */
  getFittest: function () {
    // Check if evaluated
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }
    if (this.population[0].score < this.population[1].score) {
      this.sort();
    }

    return this.population[0];
  },

  /**
   * Returns the average fitness of the current population
   */
  getAverage: function () {
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }

    var score = 0;
    for (var i = 0; i < this.population.length; i++) {
      score += this.population[i].score;
    }

    return score / this.population.length;
  },

  /**
   * Gets a genome based on the selection function
   * @return {Network} genome
   */
  getParent: function () {
    var i;
    switch (this.selection) {
      case selection.POWER:
        if (this.population[0].score < this.population[1].score) this.sort();

        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);
        return this.population[index];
      case selection.FITNESS_PROPORTIONATE:
        // As negative fitnesses are possible
        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values
        // this is unnecessarily run for every individual, should be changed

        var totalFitness = 0;
        var minimalFitness = 0;
        for (i = 0; i < this.population.length; i++) {
          var score = this.population[i].score;
          minimalFitness = score < minimalFitness ? score : minimalFitness;
          totalFitness += score;
        }

        minimalFitness = Math.abs(minimalFitness);
        totalFitness += minimalFitness * this.population.length;

        var random = Math.random() * totalFitness;
        var value = 0;

        for (i = 0; i < this.population.length; i++) {
          var genome = this.population[i];
          value += genome.score + minimalFitness;
          if (random < value) return genome;
        }

        // if all scores equal, return random genome
        return this.population[Math.floor(Math.random() * this.population.length)];
      case selection.TOURNAMENT:
        if (this.selection.size > this.popsize) {
          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');
        }

        // Create a tournament
        var individuals = [];
        for (i = 0; i < this.selection.size; i++) {
          var random = this.population[Math.floor(Math.random() * this.population.length)];
          individuals.push(random);
        }

        // Sort the tournament individuals by score
        individuals.sort(function (a, b) {
          return b.score - a.score;
        });

        // Select an individual
        for (i = 0; i < this.selection.size; i++) {
          if (Math.random() < this.selection.probability || i === this.selection.size - 1) {
            return individuals[i];
          }
        }
    }
  },
  
  
  test: function (L,data) {
    
  },

  /**
   * Export the current population to a json object
   */
  export: function () {
    var json = [];
    for (var i = 0; i < this.population.length; i++) {
      var genome = this.population[i];
      json.push(genome.toJSON());
    }

    return json;
  },

  /**
   * Import population from a json object
   */
  import: function (json) {
    var population = [];
    for (var i = 0; i < json.length; i++) {
      var genome = json[i];
      population.push(Network.fromJSON(genome));
    }
    this.population = population;
    this.popsize = population.length;
  }
};


var Neataptic = {
  methods: methods,
  Connection: Connection,
  architect: architect,
  Network: Network,
  config: config,
  Group: Group,
  Layer: Layer,
  Node: Node,
  Neat: Neat
};

module.exports = Neataptic
};
BundleModuleCode['plugins/ml/pca']=function (module,exports,global,process){
// https://github.com/bitanath/pca
var PCA = (function () {
    var options = {};
    /**
     * The first step is to subtract the mean and center data
     * 
     * @param {Array} matrix - data in an mXn matrix format
     * @returns 
     */
    function computeDeviationMatrix(matrix) {
        var unit = unitSquareMatrix(matrix.length);
        return subtract(matrix, scale(multiply(unit, matrix), 1 / matrix.length));
    }
    /**
     * Computes variance from deviation
     * 
     * @param {Array} deviation - data minus mean as calculated from computeDeviationMatrix
     * @returns 
     */
    function computeDeviationScores(deviation) {
        var devSumOfSquares = multiply(transpose(deviation), deviation);
        return devSumOfSquares;
    }
    /**
     * Calculates the var covar square matrix using either population or sample
     * 
     * @param {Array} devSumOfSquares 
     * @param {boolean} sample - true/false whether data is from sample or not
     * @returns 
     */
    function computeVarianceCovariance(devSumOfSquares, sample) {
        var varianceCovariance;
        if (sample)
            varianceCovariance = scale(devSumOfSquares, 1 / (devSumOfSquares.length - 1));
        else
            varianceCovariance = scale(devSumOfSquares, 1 / (devSumOfSquares.length));
        return varianceCovariance;
    }
    /**
     * Matrix is the deviation sum of squares as computed earlier
     * 
     * @param {Array} matrix - output of computeDeviationScores
     * @returns 
     */
    function computeSVD(matrix) {
        var result = svd(matrix);
        if (options.verbose) console.log(result)
        var eigenvectors = result.U;
        var eigenvalues = result.S;
        var results = eigenvalues.map(function (value, i) {
            var obj = {};
            obj.eigenvalue = value;
            obj.vector = eigenvectors.map(function (vector, j) {
                return -1 * vector[i]; //HACK prevent completely negative vectors
            });
            return obj;
        });
        return results;
    }
    /**
     * Get reduced dataset after removing some dimensions
     * 
     * @param {Array} data - initial matrix started out with
     * @param {rest} vectors - eigenvectors selected as part of process
     * @returns 
     */
    function computeAdjustedData(data) {
        for (var _len = arguments.length, vectorObjs = new Array(_len > 1 ? _len - 1 : 0), 
            _key = 1; _key < _len; _key++) {
            vectorObjs[_key - 1] = arguments[_key];
        }
        //FIXME no need to transpose vectors since they're already in row normal form
        var vectors = vectorObjs.map(function(v){return v.vector});
        var matrixMinusMean = computeDeviationMatrix(data);
        var adjustedData = multiply(vectors, transpose(matrixMinusMean));
        var unit = unitSquareMatrix(data.length);
        var avgData = scale(multiply(unit, data), -1 / data.length); //NOTE get the averages to add back

        var formattedAdjustData = formatData(adjustedData, 2);
        return {
            adjustedData: adjustedData,
            formattedAdjustedData: formattedAdjustData,
            avgData: avgData,
            selectedVectors: vectors
        };
    }

    /**
     * Get original data set from reduced data set (decompress)
     * @param {*} adjustedData = formatted or unformatted adjusted data
     * @param {*} vectors = selectedVectors
     * @param {*} avgData = avgData
     */
    function computeOriginalData(adjustedData, vectors, avgData) {
        var originalWithoutMean = transpose(multiply(transpose(vectors), adjustedData));
        var originalWithMean = subtract(originalWithoutMean, avgData);
        var formattedData = formatData(originalWithMean, 2);
        return {
            originalData: originalWithMean,
            formattedOriginalData: formattedData
        }
    }

    /**
     * Get percentage explained, or loss
     * @param {*} vectors 
     * @param {*} selected 
     */
    function computePercentageExplained(vectors) {
        for (var _len = arguments.length, selected = new Array(_len > 1 ? _len - 1 : 0),
             _key = 1; _key < _len; _key++) {
            selected[_key - 1] = arguments[_key];
        }
        var total = vectors.map(function (v) {
            return v.eigenvalue
        }).reduce(function (a, b) {
            return a + b;
        });
        var explained = selected.map(function (v) {
            return v.eigenvalue
        }).reduce(function (a, b) {
            return a + b;
        });
        return (explained / total);
    }

    function getEigenVectors(data) {
        return computeSVD(computeVarianceCovariance(computeDeviationScores(computeDeviationMatrix(data)), false));
    }

    function analyseTopResult(data) {
        var eigenVectors = getEigenVectors(data);
        var sorted = eigenVectors.sort(function (a, b) {
            return b.eigenvalue - a.eigenvalue;
        });
        console.log('Sorted Vectors', sorted);
        var selected = sorted[0].vector;
        return computeAdjustedData(data, selected);
    }

    function formatData(data, precision) {
        var TEN = Math.pow(10, precision || 2);
        return data.map(function (d, i) {
            return d.map(function (n) {
                return Math.round(n * TEN) / TEN;
            })
        })
    }
    /**
     * Multiplies AxB, where A and B are matrices of nXm and mXn dimensions
     * @param {} a 
     * @param {*} b 
     */
    function multiply(a, b) {
        if (!a[0] || !b[0] || !a.length || !b.length) {
            throw new Error('Both A and B should be matrices');
        }

        if (b.length !== a[0].length) {
            throw new Error('Columns in A should be the same as the number of rows in B');
        }
        var product = [];

        for (var i = 0; i < a.length; i++) {
            product[i] = []; //initialize a new row
            for (var j = 0; j < b[0].length; j++) {
                for (var k = 0; k < a[0].length; k++) {
                    (product[i])[j] = !!(product[i])[j] ? (product[i])[j] + (a[i])[k] * (b[k])[j] : (a[i])[k] * (b[k])[j];
                }
            }
        }
        return product;
    }
    /**
     * Utility function to subtract matrix b from a
     * 
     * @param {any} a 
     * @param {any} b 
     * @returns 
     */
    function subtract(a, b) {
        if (!(a.length === b.length && a[0].length === b[0].length))
            throw new Error('Both A and B should have the same dimensions');
        var result = [];
        for (var i = 0; i < a.length; i++) {
            result[i] = [];
            for (var j = 0; j < b[0].length; j++) {
                (result[i])[j] = (a[i])[j] - (b[i])[j];
            }
        }
        return result;
    }
    /**
     * Multiplies a matrix into a factor
     * 
     * @param {any} matrix 
     * @param {any} factor 
     * @returns 
     */
    function scale(matrix, factor) {
        var result = [];
        for (var i = 0; i < matrix.length; i++) {
            result[i] = [];
            for (var j = 0; j < matrix[0].length; j++) {
                (result[i])[j] = (matrix[i])[j] * factor;
            }
        }
        return result;
    }

    /**
     * Generates a unit square matrix
     * @param {*} rows = number of rows to fill
     */
    function unitSquareMatrix(rows) {
        var result = [];
        for (var i = 0; i < rows; i++) {
            result[i] = [];
            for (var j = 0; j < rows; j++) {
                (result[i])[j] = 1;
            }
        }
        return result;
    }
    /**
     * Transposes a matrix, converts rows to columns
     * @param {*} matrix 
     */
    function transpose(matrix) {
        var operated = clone(matrix);
        return operated[0].map(function (m, c) {
            return matrix.map(function (r) {
                return r[c];
            });
        });
    }
    /**
     * Deep Clones a matrix
     * @param {*} arr 
     */
    function clone(arr) {
        var string = JSON.stringify(arr);
        var result = JSON.parse(string);
        return result;
    }

    /**
     * Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
     * From the Numeric JS Implementation Copyright (C) 2011 by Sébastien Loisel
     * The C implementation from which this has been taken may be found here: http://www.public.iastate.edu/~dicook/JSS/paper/code/svd.c
     * @param {*} A = m*n matrix
     */
    function svd(A) {
        var temp;
        var prec = Math.pow(2, -52) // assumes double prec
        var tolerance = 1.e-64 / prec;
        var itmax = 50;
        var c = 0;
        var i = 0;
        var j = 0;
        var k = 0;
        var l = 0;
        var u = clone(A);
        var m = u.length;
        var n = u[0].length;

        if (m < n) throw "Need more rows than columns"

        var e = new Array(n); //vector1
        var q = new Array(n); //vector2
        for (i = 0; i < n; i++) e[i] = q[i] = 0.0;
        var v = rep([n, n], 0);

        function pythag(a, b) {
            a = Math.abs(a)
            b = Math.abs(b)
            if (a > b)
                return a * Math.sqrt(1.0 + (b * b / a / a))
            else if (b == 0.0)
                return a
            return b * Math.sqrt(1.0 + (a * a / b / b))
        }

        //rep function
        function rep(s, v, k) {
            if (typeof k === "undefined") {
                k = 0;
            }
            var n = s[k],
                ret = Array(n),
                i;
            if (k === s.length - 1) {
                for (i = n - 2; i >= 0; i -= 2) {
                    ret[i + 1] = v;
                    ret[i] = v;
                }
                if (i === -1) {
                    ret[0] = v;
                }
                return ret;
            }
            for (i = n - 1; i >= 0; i--) {
                ret[i] = rep(s, v, k + 1);
            }
            return ret;
        }

        //Householder's reduction to bidiagonal form

        var f = 0.0;
        var g = 0.0;
        var h = 0.0;
        var x = 0.0;
        var y = 0.0;
        var z = 0.0;
        var s = 0.0;

        for (i = 0; i < n; i++) {
            e[i] = g; //vector
            s = 0.0; //sum
            l = i + 1; //stays i+1
            for (j = i; j < m; j++)
                s += (u[j][i] * u[j][i]);
            if (s <= tolerance)
                g = 0.0;
            else {
                f = u[i][i];
                g = Math.sqrt(s);
                if (f >= 0.0) g = -g;
                h = f * g - s
                u[i][i] = f - g;
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = i; k < m; k++)
                        s += u[k][i] * u[k][j]
                    f = s / h
                    for (k = i; k < m; k++)
                        u[k][j] += f * u[k][i]
                }
            }
            q[i] = g
            s = 0.0
            for (j = l; j < n; j++)
                s = s + u[i][j] * u[i][j]
            if (s <= tolerance)
                g = 0.0
            else {
                f = u[i][i + 1]
                g = Math.sqrt(s)
                if (f >= 0.0) g = -g
                h = f * g - s
                u[i][i + 1] = f - g;
                for (j = l; j < n; j++) e[j] = u[i][j] / h
                for (j = l; j < m; j++) {
                    s = 0.0
                    for (k = l; k < n; k++)
                        s += (u[j][k] * u[i][k])
                    for (k = l; k < n; k++)
                        u[j][k] += s * e[k]
                }
            }
            y = Math.abs(q[i]) + Math.abs(e[i])
            if (y > x)
                x = y
        }

        // accumulation of right hand transformations
        for (i = n - 1; i != -1; i += -1) {
            if (g != 0.0) {
                h = g * u[i][i + 1]
                for (j = l; j < n; j++)
                    v[j][i] = u[i][j] / h //u is array, v is square of columns
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = l; k < n; k++)
                        s += u[i][k] * v[k][j]
                    for (k = l; k < n; k++)
                        v[k][j] += (s * v[k][i])
                }
            }
            for (j = l; j < n; j++) {
                v[i][j] = 0;
                v[j][i] = 0;
            }
            v[i][i] = 1;
            g = e[i]
            l = i
        }

        // accumulation of left hand transformations
        for (i = n - 1; i != -1; i += -1) {
            l = i + 1
            g = q[i]
            for (j = l; j < n; j++)
                u[i][j] = 0;
            if (g != 0.0) {
                h = u[i][i] * g
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = l; k < m; k++) s += u[k][i] * u[k][j];
                    f = s / h
                    for (k = i; k < m; k++) u[k][j] += f * u[k][i];
                }
                for (j = i; j < m; j++) u[j][i] = u[j][i] / g;
            } else
                for (j = i; j < m; j++) u[j][i] = 0;
            u[i][i] += 1;
        }

        // diagonalization of the bidiagonal form
        prec = prec * x
        for (k = n - 1; k != -1; k += -1) {
            for (var iteration = 0; iteration < itmax; iteration++) { // test f splitting
                var test_convergence = false
                for (l = k; l != -1; l += -1) {
                    if (Math.abs(e[l]) <= prec) {
                        test_convergence = true
                        break
                    }
                    if (Math.abs(q[l - 1]) <= prec)
                        break
                }
                if (!test_convergence) { // cancellation of e[l] if l>0
                    c = 0.0
                    s = 1.0
                    var l1 = l - 1
                    for (i = l; i < k + 1; i++) {
                        f = s * e[i]
                        e[i] = c * e[i]
                        if (Math.abs(f) <= prec)
                            break
                        g = q[i]
                        h = pythag(f, g)
                        q[i] = h
                        c = g / h
                        s = -f / h
                        for (j = 0; j < m; j++) {
                            y = u[j][l1]
                            z = u[j][i]
                            u[j][l1] = y * c + (z * s)
                            u[j][i] = -y * s + (z * c)
                        }
                    }
                }
                // test f convergence
                z = q[k]
                if (l == k) { //convergence
                    if (z < 0.0) { //q[k] is made non-negative
                        q[k] = -z
                        for (j = 0; j < n; j++)
                            v[j][k] = -v[j][k]
                    }
                    break //break out of iteration loop and move on to next k value
                }
                if (iteration >= itmax - 1)
                    throw 'Error: no convergence.'
                // shift from bottom 2x2 minor
                x = q[l]
                y = q[k - 1]
                g = e[k - 1]
                h = e[k]
                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y)
                g = pythag(f, 1.0)
                if (f < 0.0)
                    f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x
                else
                    f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x
                // next QR transformation
                c = 1.0
                s = 1.0
                for (i = l + 1; i < k + 1; i++) {
                    g = e[i]
                    y = q[i]
                    h = s * g
                    g = c * g
                    z = pythag(f, h)
                    e[i - 1] = z
                    c = f / z
                    s = h / z
                    f = x * c + g * s
                    g = -x * s + g * c
                    h = y * s
                    y = y * c
                    for (j = 0; j < n; j++) {
                        x = v[j][i - 1]
                        z = v[j][i]
                        v[j][i - 1] = x * c + z * s
                        v[j][i] = -x * s + z * c
                    }
                    z = pythag(f, h)
                    q[i - 1] = z
                    c = f / z
                    s = h / z
                    f = c * g + s * y
                    x = -s * g + c * y
                    for (j = 0; j < m; j++) {
                        y = u[j][i - 1]
                        z = u[j][i]
                        u[j][i - 1] = y * c + z * s
                        u[j][i] = -y * s + z * c
                    }
                }
                e[l] = 0.0
                e[k] = f
                q[k] = x
            }
        }

        for (i = 0; i < q.length; i++)
            if (q[i] < prec) q[i] = 0

        //sort eigenvalues	
        for (i = 0; i < n; i++) {
            for (j = i - 1; j >= 0; j--) {
                if (q[j] < q[i]) {
                    c = q[j]
                    q[j] = q[i]
                    q[i] = c
                    for (k = 0; k < u.length; k++) {
                        temp = u[k][i];
                        u[k][i] = u[k][j];
                        u[k][j] = temp;
                    }
                    for (k = 0; k < v.length; k++) {
                        temp = v[k][i];
                        v[k][i] = v[k][j];
                        v[k][j] = temp;
                    }
                    i = j
                }
            }
        }

        return {
            U: u,
            S: q,
            V: v
        }
    }

    return {
        computeDeviationScores: computeDeviationScores,
        computeDeviationMatrix: computeDeviationMatrix,
        computeSVD: computeSVD,
        computePercentageExplained: computePercentageExplained,
        computeOriginalData: computeOriginalData,
        computeVarianceCovariance: computeVarianceCovariance,
        computeAdjustedData: computeAdjustedData,
        getEigenVectors: getEigenVectors,
        analyseTopResult: analyseTopResult,
        transpose: transpose,
        multiply: multiply,
        clone: clone,
        scale: scale,
        options:options
    }
})();

if(typeof module !== 'undefined')
module.exports = PCA;
};
BundleModuleCode['plugins/ml/dbclust']=function (module,exports,global,process){
/**
 * DBSCAN - Density based clustering
 *
 * https://github.com/uhho/density-clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * DBSCAN class construcotr
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {DBSCAN}
 */
function DBSCAN(dataset, epsilon, minPts, distanceFunction) {
  if (!(this instanceof DBSCAN)) return new DBSCAN(dataset, epsilon, minPts, distanceFunction);
  /** @type {Array} */
  this.dataset = [];
  /** @type {number} */
  this.epsilon = 1;
  /** @type {number} */
  this.minPts = 2;
  /** @type {function} */
  this.distance = this._euclideanDistance;
  /** @type {Array} */
  this.clusters = [];
  /** @type {Array} */
  this.noise = [];

  // temporary variables used during computation

  /** @type {Array} */
  this._visited = [];
  /** @type {Array} */
  this._assigned = [];
  /** @type {number} */
  this._datasetLength = 0;

  this._init(dataset, epsilon, minPts, distanceFunction);
};

/******************************************************************************/
// public functions

/**
 * Start clustering
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {undefined}
 * @access public
 */
DBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
  this._init(dataset, epsilon, minPts, distanceFunction);

  for (var pointId = 0; pointId < this._datasetLength; pointId++) {
    // if point is not visited, check if it forms a cluster
    if (this._visited[pointId] !== 1) {
      this._visited[pointId] = 1;

      // if closest neighborhood is too small to form a cluster, mark as noise
      var neighbors = this._regionQuery(pointId);

      if (neighbors.length < this.minPts) {
        this.noise.push(pointId);
      } else {
        // create new cluster and add point
        var clusterId = this.clusters.length;
        this.clusters.push([]);
        this._addToCluster(pointId, clusterId);

        this._expandCluster(clusterId, neighbors);
      }
    }
  }

  return this.clusters;
};

/******************************************************************************/
// protected functions

/**
 * Set object properties
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distance
 * @returns {undefined}
 * @access protected
 */
DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {

  if (dataset) {

    if (!(dataset instanceof Array)) {
      throw Error('Dataset must be of type array, ' +
        typeof dataset + ' given');
    }

    this.dataset = dataset;
    this.clusters = [];
    this.noise = [];

    this._datasetLength = dataset.length;
    this._visited = new Array(this._datasetLength);
    this._assigned = new Array(this._datasetLength);
  }

  if (epsilon) {
    this.epsilon = epsilon;
  }

  if (minPts) {
    this.minPts = minPts;
  }

  if (distance) {
    this.distance = distance;
  }
};

/**
 * Expand cluster to closest points of given neighborhood
 *
 * @param {number} clusterId
 * @param {Array} neighbors
 * @returns {undefined}
 * @access protected
 */
DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {

  /**
   * It's very important to calculate length of neighbors array each time,
   * as the number of elements changes over time
   */
  for (var i = 0; i < neighbors.length; i++) {
    var pointId2 = neighbors[i];

    if (this._visited[pointId2] !== 1) {
      this._visited[pointId2] = 1;
      var neighbors2 = this._regionQuery(pointId2);

      if (neighbors2.length >= this.minPts) {
        neighbors = this._mergeArrays(neighbors, neighbors2);
      }
    }

    // add to cluster
    if (this._assigned[pointId2] !== 1) {
      this._addToCluster(pointId2, clusterId);
    }
  }
};

/**
 * Add new point to cluster
 *
 * @param {number} pointId
 * @param {number} clusterId
 */
DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
  this.clusters[clusterId].push(pointId);
  this._assigned[pointId] = 1;
};

/**
 * Find all neighbors around given point
 *
 * @param {number} pointId,
 * @param {number} epsilon
 * @returns {Array}
 * @access protected
 */
DBSCAN.prototype._regionQuery = function(pointId) {
  var neighbors = [];

  for (var id = 0; id < this._datasetLength; id++) {
    var dist = this.distance(this.dataset[pointId], this.dataset[id]);
    if (dist < this.epsilon) {
      neighbors.push(id);
    }
  }

  return neighbors;
};

/******************************************************************************/
// helpers

/**
 * @param {Array} a
 * @param {Array} b
 * @returns {Array}
 * @access protected
 */
DBSCAN.prototype._mergeArrays = function(a, b) {
  var len = b.length;

  for (var i = 0; i < len; i++) {
    var P = b[i];
    if (a.indexOf(P) < 0) {
      a.push(P);
    }
  }

  return a;
};

/**
 * Calculate euclidean distance in multidimensional space
 *
 * @param {Array} p
 * @param {Array} q
 * @returns {number}
 * @access protected
 */
DBSCAN.prototype._euclideanDistance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    sum += (p[i] - q[i]) * (p[i] - q[i]);
  }

  return Math.sqrt(sum);
};


/**
 * KMEANS clustering
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * KMEANS class constructor
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} k - number of clusters
 * @param {function} distance - distance function
 * @returns {KMEANS}
 */
 function KMEANS(dataset, k, distance) {
  this.k = 3; // number of clusters
  this.dataset = []; // set of feature vectors
  this.assignments = []; // set of associated clusters for each feature vector
  this.centroids = []; // vectors for our clusters

  this.init(dataset, k, distance);
}

/**
 * @returns {undefined}
 */
KMEANS.prototype.init = function(dataset, k, distance) {
  this.assignments = [];
  this.centroids = [];

  if (typeof dataset !== 'undefined') {
    this.dataset = dataset;
  }

  if (typeof k !== 'undefined') {
    this.k = k;
  }

  if (typeof distance !== 'undefined') {
    this.distance = distance;
  }
};

/**
 * @returns {undefined}
 */
KMEANS.prototype.run = function(dataset, k) {
  this.init(dataset, k);

  var len = this.dataset.length;

  // initialize centroids
  for (var i = 0; i < this.k; i++) {
    this.centroids[i] = this.randomCentroid();
	}

  var change = true;
  while(change) {

    // assign feature vectors to clusters
    change = this.assign();

    // adjust location of centroids
    for (var centroidId = 0; centroidId < this.k; centroidId++) {
      var mean = new Array(maxDim);
      var count = 0;

      // init mean vector
      for (var dim = 0; dim < maxDim; dim++) {
        mean[dim] = 0;
      }

      for (var j = 0; j < len; j++) {
        var maxDim = this.dataset[j].length;

        // if current cluster id is assigned to point
        if (centroidId === this.assignments[j]) {
          for (var dim = 0; dim < maxDim; dim++) {
            mean[dim] += this.dataset[j][dim];
          }
          count++;
        }
      }

      if (count > 0) {
        // if cluster contain points, adjust centroid position
        for (var dim = 0; dim < maxDim; dim++) {
          mean[dim] /= count;
        }
        this.centroids[centroidId] = mean;
      } else {
        // if cluster is empty, generate new random centroid
        this.centroids[centroidId] = this.randomCentroid();
        change = true;
      }
    }
  }

  return this.getClusters();
};

/**
 * Generate random centroid
 *
 * @returns {Array}
 */
KMEANS.prototype.randomCentroid = function() {
  var maxId = this.dataset.length -1;
  var centroid;
  var id;

  do {
    id = Math.round(Math.random() * maxId);
    centroid = this.dataset[id];
  } while (this.centroids.indexOf(centroid) >= 0);

  return centroid;
}

/**
 * Assign points to clusters
 *
 * @returns {boolean}
 */
KMEANS.prototype.assign = function() {
  var change = false;
  var len = this.dataset.length;
  var closestCentroid;

  for (var i = 0; i < len; i++) {
    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);

    if (closestCentroid != this.assignments[i]) {
      this.assignments[i] = closestCentroid;
      change = true;
    }
  }

  return change;
}

/**
 * Extract information about clusters
 *
 * @returns {undefined}
 */
KMEANS.prototype.getClusters = function() {
  var clusters = new Array(this.k);
  var centroidId;

  for (var pointId = 0; pointId < this.assignments.length; pointId++) {
    centroidId = this.assignments[pointId];

    // init empty cluster
    if (typeof clusters[centroidId] === 'undefined') {
      clusters[centroidId] = [];
    }

    clusters[centroidId].push(pointId);
  }

  return clusters;
};

// utils

/**
 * @params {Array} point
 * @params {Array.<Array>} set
 * @params {Function} f
 * @returns {number}
 */
KMEANS.prototype.argmin = function(point, set, f) {
  var min = Number.MAX_VALUE;
  var arg = 0;
  var len = set.length;
  var d;

  for (var i = 0; i < len; i++) {
    d = f(point, set[i]);
    if (d < min) {
      min = d;
      arg = i;
    }
  }

  return arg;
};

/**
 * Euclidean distance
 *
 * @params {number} p
 * @params {number} q
 * @returns {number}
 */
KMEANS.prototype.distance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    var diff = p[i] - q[i];
    sum += diff * diff;
  }

  return Math.sqrt(sum);
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = KMEANS;
}

/**
 * PriorityQueue
 * Elements in this queue are sorted according to their value
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * PriorityQueue class construcotr
 * @constructor
 *
 * @example
 * queue: [1,2,3,4]
 * priorities: [4,1,2,3]
 * > result = [1,4,2,3]
 *
 * @param {Array} elements
 * @param {Array} priorities
 * @param {string} sorting - asc / desc
 * @returns {PriorityQueue}
 */
function PriorityQueue(elements, priorities, sorting) {
  /** @type {Array} */
  this._queue = [];
  /** @type {Array} */
  this._priorities = [];
  /** @type {string} */
  this._sorting = 'desc';

  this._init(elements, priorities, sorting);
};

/**
 * Insert element
 *
 * @param {Object} ele
 * @param {Object} priority
 * @returns {undefined}
 * @access public
 */
PriorityQueue.prototype.insert = function(ele, priority) {
  var indexToInsert = this._queue.length;
  var index = indexToInsert;

  while (index--) {
    var priority2 = this._priorities[index];
    if (this._sorting === 'desc') {
      if (priority > priority2) {
        indexToInsert = index;
      }
    } else {
      if (priority < priority2) {
        indexToInsert = index;
      }
    }
  }

  this._insertAt(ele, priority, indexToInsert);
};

/**
 * Remove element
 *
 * @param {Object} ele
 * @returns {undefined}
 * @access public
 */
PriorityQueue.prototype.remove = function(ele) {
  var index = this._queue.length;

  while (index--) {
    var ele2 = this._queue[index];
    if (ele === ele2) {
      this._queue.splice(index, 1);
      this._priorities.splice(index, 1);
      break;
    }
  }
};

/**
 * For each loop wrapper
 *
 * @param {function} func
 * @returs {undefined}
 * @access public
 */
PriorityQueue.prototype.forEach = function(func) {
  this._queue.forEach(func);
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getElements = function() {
  return this._queue;
};

/**
 * @param {number} index
 * @returns {Object}
 * @access public
 */
PriorityQueue.prototype.getElementPriority = function(index) {
  return this._priorities[index];
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getPriorities = function() {
  return this._priorities;
};

/**
 * @returns {Array}
 * @access public
 */
PriorityQueue.prototype.getElementsWithPriorities = function() {
  var result = [];

  for (var i = 0, l = this._queue.length; i < l; i++) {
    result.push([this._queue[i], this._priorities[i]]);
  }

  return result;
};

/**
 * Set object properties
 *
 * @param {Array} elements
 * @param {Array} priorities
 * @returns {undefined}
 * @access protected
 */
PriorityQueue.prototype._init = function(elements, priorities, sorting) {

  if (elements && priorities) {
    this._queue = [];
    this._priorities = [];

    if (elements.length !== priorities.length) {
      throw new Error('Arrays must have the same length');
    }

    for (var i = 0; i < elements.length; i++) {
      this.insert(elements[i], priorities[i]);
    }
  }

  if (sorting) {
    this._sorting = sorting;
  }
};

/**
 * Insert element at given position
 *
 * @param {Object} ele
 * @param {number} index
 * @returns {undefined}
 * @access protected
 */
PriorityQueue.prototype._insertAt = function(ele, priority, index) {
  if (this._queue.length === index) {
    this._queue.push(ele);
    this._priorities.push(priority);
  } else {
    this._queue.splice(index, 0, ele);
    this._priorities.splice(index, 0, priority);
  }
};



/**
 * OPTICS - Ordering points to identify the clustering structure
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */

/**
 * OPTICS class constructor
 * @constructor
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distanceFunction
 * @returns {OPTICS}
 */
function OPTICS(dataset, epsilon, minPts, distanceFunction) {
  /** @type {number} */
  this.epsilon = 1;
  /** @type {number} */
  this.minPts = 1;
  /** @type {function} */
  this.distance = this._euclideanDistance;

  // temporary variables used during computation

  /** @type {Array} */
  this._reachability = [];
  /** @type {Array} */
  this._processed = [];
  /** @type {number} */
  this._coreDistance = 0;
  /** @type {Array} */
  this._orderedList = [];

  this._init(dataset, epsilon, minPts, distanceFunction);
}

/******************************************************************************/
// pulic functions

/**
 * Start clustering
 *
 * @param {Array} dataset
 * @returns {undefined}
 * @access public
 */
OPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
  this._init(dataset, epsilon, minPts, distanceFunction);

  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
    if (this._processed[pointId] !== 1) {
      this._processed[pointId] = 1;
      this.clusters.push([pointId]);
      var clusterId = this.clusters.length - 1;

      this._orderedList.push(pointId);
      var priorityQueue = new PriorityQueue(null, null, 'asc');
      var neighbors = this._regionQuery(pointId);

      // using priority queue assign elements to new cluster
      if (this._distanceToCore(pointId) !== undefined) {
        this._updateQueue(pointId, neighbors, priorityQueue);
        this._expandCluster(clusterId, priorityQueue);
      }
    }
  }

  return this.clusters;
};

/**
 * Generate reachability plot for all points
 *
 * @returns {array}
 * @access public
 */
OPTICS.prototype.getReachabilityPlot = function() {
  var reachabilityPlot = [];

  for (var i = 0, l = this._orderedList.length; i < l; i++) {
    var pointId = this._orderedList[i];
    var distance = this._reachability[pointId];

    reachabilityPlot.push([pointId, distance]);
  }

  return reachabilityPlot;
};

/******************************************************************************/
// protected functions

/**
 * Set object properties
 *
 * @param {Array} dataset
 * @param {number} epsilon
 * @param {number} minPts
 * @param {function} distance
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {

  if (dataset) {

    if (!(dataset instanceof Array)) {
      throw Error('Dataset must be of type array, ' +
        typeof dataset + ' given');
    }

    this.dataset = dataset;
    this.clusters = [];
    this._reachability = new Array(this.dataset.length);
    this._processed = new Array(this.dataset.length);
    this._coreDistance = 0;
    this._orderedList = [];
  }

  if (epsilon) {
    this.epsilon = epsilon;
  }

  if (minPts) {
    this.minPts = minPts;
  }

  if (distance) {
    this.distance = distance;
  }
};

/**
 * Update information in queue
 *
 * @param {number} pointId
 * @param {Array} neighbors
 * @param {PriorityQueue} queue
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
  var self = this;

  this._coreDistance = this._distanceToCore(pointId);
  neighbors.forEach(function(pointId2) {
    if (self._processed[pointId2] === undefined) {
      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);
      var newReachableDistance = Math.max(self._coreDistance, dist);

      if (self._reachability[pointId2] === undefined) {
        self._reachability[pointId2] = newReachableDistance;
        queue.insert(pointId2, newReachableDistance);
      } else {
        if (newReachableDistance < self._reachability[pointId2]) {
          self._reachability[pointId2] = newReachableDistance;
          queue.remove(pointId2);
          queue.insert(pointId2, newReachableDistance);
        }
      }
    }
  });
};

/**
 * Expand cluster
 *
 * @param {number} clusterId
 * @param {PriorityQueue} queue
 * @returns {undefined}
 * @access protected
 */
OPTICS.prototype._expandCluster = function(clusterId, queue) {
  var queueElements = queue.getElements();

  for (var p = 0, l = queueElements.length; p < l; p++) {
    var pointId = queueElements[p];
    if (this._processed[pointId] === undefined) {
      var neighbors = this._regionQuery(pointId);
      this._processed[pointId] = 1;

      this.clusters[clusterId].push(pointId);
      this._orderedList.push(pointId);

      if (this._distanceToCore(pointId) !== undefined) {
        this._updateQueue(pointId, neighbors, queue);
        this._expandCluster(clusterId, queue);
      }
    }
  }
};

/**
 * Calculating distance to cluster core
 *
 * @param {number} pointId
 * @returns {number}
 * @access protected
 */
OPTICS.prototype._distanceToCore = function(pointId) {
  var l = this.epsilon;
  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
    var neighbors = this._regionQuery(pointId, coreDistCand);
    if (neighbors.length >= this.minPts) {
      return coreDistCand;
    }
  }

  return;
};

/**
 * Find all neighbors around given point
 *
 * @param {number} pointId
 * @param {number} epsilon
 * @returns {Array}
 * @access protected
 */
OPTICS.prototype._regionQuery = function(pointId, epsilon) {
  epsilon = epsilon || this.epsilon;
  var neighbors = [];

  for (var id = 0, l = this.dataset.length; id < l; id++) {
    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {
      neighbors.push(id);
    }
  }

  return neighbors;
};

/******************************************************************************/
// helpers

/**
 * Calculate euclidean distance in multidimensional space
 *
 * @param {Array} p
 * @param {Array} q
 * @returns {number}
 * @access protected
 */
OPTICS.prototype._euclideanDistance = function(p, q) {
  var sum = 0;
  var i = Math.min(p.length, q.length);

  while (i--) {
    sum += (p[i] - q[i]) * (p[i] - q[i]);
  }

  return Math.sqrt(sum);
};

function Utils() {

}


KMEANS.prototype.getRandomVector = function(extremes) {
  var maxDim = extremes.length;
  var x = [];
  var r = 0;
  
  // calculate radius of n-sphere which covers all points in dataset
  var nSphereRadius = 0;
  for (var i = 0; i < maxDim; i++) {
    var extreme = extremes[i];
    var er = Math.max(extreme.center - extreme.min, extreme.center - extreme.max);
    if (er > nSphereRadius)
      nSphereRadius = er;
  }
  
  for (var i = 0; i < maxDim; i++) {
    var val = (Math.random() * 2) - 1;
    // adjust to radius of n-sphere
    x.push(val);
    r += val * val;
  }
      
  r = Math.sqrt(r);
  
  for (var i = 0; i < maxDim; i++) {
    x[i] /= r;
    // resize to fit n-sphere
    x[i] *= nSphereRadius;
    x[i] += extremes[i].center;
  }
  
  return x;
}


module.exports = {
      DBSCAN: DBSCAN,
      KMEANS: KMEANS,
      OPTICS: OPTICS,
      PriorityQueue: PriorityQueue
};
};
BundleModuleCode['plugins/ml/reg']=function (module,exports,global,process){
/* https://github.com/chen0040/js-regression */
var jsregression = jsregression || {};

(function (jsr) {
    'use strict';
	var LinearRegression = function (config) {
        config = config || {};
        
        if (!config.iterations) {
            config.iterations = 1000;
        }
        if (!config.alpha) {
            config.alpha = 0.001;
        }
        if (!config.lambda) {
            config.lambda = 0.0;
        }
        if(!config.trace) {
            config.trace = false;
        }
        
        this.iterations = config.iterations;
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.costThres = config.cost||0;
        this.errorThres = config.error||0;
        this.trace = config.trace;
        this.dynamic = config.dynamic;  // dynamic alpha rate
    };
    
    LinearRegression.prototype.fit = function (data) {
        var N = data.length, X = [], Y = [];
        this.dim = data[0].length;

    
        for (var i=0; i < N; ++i) {
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j) {
                x_i.push(row[j]);
            }
            Y.push(y_i);
            X.push(x_i);
        }
        
        this.theta = [];
        
        for (var d = 0; d < this.dim; ++d) {
            this.theta.push(0.0);
        }
        
        var cost,lastCost=0, lastVx, lastTheta, alpha=this.alpha;
        for (var k = 0; k < this.iterations; ++k) {
            var Vx = this.grad(X, Y, this.theta);
            
            for(var d = 0; d < this.dim; ++d) {
                this.theta[d] = this.theta[d] - alpha * Vx[d];
                if (isNaN(this.theta[d])) 
                 throw Error ('LinearRegression.fit: parameter overflow, probably alpha rate to high! (alpha:'+alpha+', step:'+k+')')
            }
            
            if (this.errorThres && this.error(X,Y,this.theta) < this.errorThres) break;
            if (this.costThres && this.cost(X,Y,this.theta) < this.costThres) break;
            if (this.dynamic) {
              // experimental dynamic aloha rate adaptation
              if (lastVx) {
                var gMax=0, gradVx = lastVx.map(function (vx,index) {
                  var g = Math.abs(Vx[index]/vx);
                  gMax = Math.max(gMax,g)
                  return g
                })
                // if some gradVx > XX then lower alpha
                if (gMax > 2) {
                  alpha /= 2;
                } else if (gMax < 1 && (1-gMax) < 0.01) alpha *= 2;
              }
              lastVx = Vx.slice();
              lastTheta = this.theta.slice();
              // console.log(alpha,Vx);
            }
            if(this.trace) {
                console.log('theta: ',this.theta)
                console.log('cost at iteration ' + k + ': ' + cost+' alpha:'+alpha);
            }
        }
        
        return {
            theta: this.theta,
            dim: this.dim,
            cost: this.cost(X, Y, this.theta),
            error: this.error(X, Y, this.theta),
            iterations : k,
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        };
    };
    
    LinearRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        
        var Vtheta = [];
        
        for(var d = 0; d < this.dim; ++d){
            var g = 0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var y_i = Y[i];
                
                var predicted = this.h(x_i, theta);
                
                g += (predicted - y_i) * x_i[d];  
            }
            
            g = (g + this.lambda * theta[d]) / N;
            
            Vtheta.push(g);
        }
        
        return Vtheta;
    };
    
    LinearRegression.prototype.h = function(x_i, theta) {
        var predicted = 0.0;
        for(var d = 0; d < this.dim; ++d) {
            predicted += x_i[d] * theta[d];
        }
        return predicted;
    }
    
    LinearRegression.prototype.cost = function(X, Y, theta) {
      
        var N = X.length;
        var cost = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            cost += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        for(var d = 0; d < this.dim; ++d) {
            cost += this.lambda * theta[d] * theta[d];
        }
        
        return cost / (2.0 * N);
    };

    LinearRegression.prototype.error = function(X, Y, theta) {
      
        var N = X.length;
        var err = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            err += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        
        return err / (N);
    };
    
    LinearRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        // x is a row vector
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    };

    LinearRegression.prototype.toFunction = function () {
      var self=this, foo;
      var fcode = 'foo=function (x) { return '
      fcode += (self.theta.map(function (p,index) {
        var xx=[]; for (var i=0;i<index;i++) xx.push('x');
        return self.theta[index]+(xx.length?'*'+xx.join('*'):'');
      }).join('+'))
      fcode += '}';
      eval(fcode);
      return foo
    }
    
    jsr.LinearRegression = LinearRegression;
    
    var LogisticRegression = function(config) {
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    }
    
    LogisticRegression.prototype.fit = function(data) {
        this.dim = data[0].length;
        var N = data.length;
        
        var X = [];
        var Y = [];
        for(var i=0; i < N; ++i){
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j){
                x_i.push(row[j]);
            }
            X.push(x_i);
            Y.push(y_i);
        }
        
        this.theta = [];
        for(var d = 0; d < this.dim; ++d){
            this.theta.push(0.0);
        }
        
        for(var iter = 0; iter < this.iterations; ++iter){
            var theta_delta = this.grad(X, Y, this.theta);
            for(var d = 0; d < this.dim; ++d){
                this.theta[d] = this.theta[d] - this.alpha * theta_delta[d];        
            }
        }
        
        this.threshold = this.computeThreshold(X, Y);
        
        return {
            theta: this.theta,
            threshold: this.threshold,
            cost: this.cost(X, Y, this.theta),
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        }
    };
    
    LogisticRegression.prototype.computeThreshold = function(X, Y){
        var threshold=1.0, N = X.length;
        
        for (var i = 0; i < N; ++i) {
            var prob = this.transform(X[i]);
            if(Y[i] == 1 && threshold > prob){
                threshold = prob;
            }
        }
        
        return threshold;
    }
    
    LogisticRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        var Vx = [];
        for(var d = 0; d < this.dim; ++d) {
            var sum = 0.0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var predicted = this.h(x_i, theta);
                sum += ((predicted - Y[i]) * x_i[d] + this.lambda * theta[d]) / N;
            }    
            Vx.push(sum);
        }
        
        return Vx;
        
    }
    
    LogisticRegression.prototype.h = function(x_i, theta) {
        var gx = 0.0;
        for(var d = 0; d < this.dim; ++d){
            gx += theta[d] * x_i[d];
        }
        return 1.0 / (1.0 + Math.exp(-gx));
    }
    
    LogisticRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    }
    
    LogisticRegression.prototype.cost = function(X, Y, theta) {
        var N = X.length;
        var sum = 0;
        for(var i = 0; i < N; ++i){
            var y_i = Y[i];
            var x_i = X[i];
            sum += - (y_i * Math.log(this.h(x_i, theta)) + (1-y_i) * Math.log(1 - this.h(x_i, theta))) / N;
        }
        
        for(var d = 0; d < this.dim; ++d) {
            sum += (this.lambda * theta[d] * theta[d]) / (2.0 * N);
        }
        return sum;
    };
    
    jsr.LogisticRegression = LogisticRegression;
    
    var MultiClassLogistic = function(config){
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    };
    
    MultiClassLogistic.prototype.fit = function(data, classes) {
        this.dim = data[0].length;
        var N = data.length;
        
        if(!classes){
            classes = [];
            for(var i=0; i < N; ++i){
                var found = false;
                var label = data[i][this.dim-1];
                for(var j=0; j < classes.length; ++j){
                    if(label == classes[j]){
                        found = true;
                        break;
                    }
                }
                if(!found){
                    classes.push(label);
                }
            }
        }
        
        this.classes = classes;
        
        this.logistics = {};
        var result = {};
        for(var k = 0; k < this.classes.length; ++k){
            var c = this.classes[k];
            this.logistics[c] = new jsr.LogisticRegression({
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations
            });
            var data_c = [];
            for(var i=0; i < N; ++i){
                var row = [];
                for(var j=0; j < this.dim-1; ++j){
                    row.push(data[i][j]);
                }
                row.push(data[i][this.dim-1] == c ? 1 : 0);
                data_c.push(row);
            }
            result[c] = this.logistics[c].fit(data_c);
        }
        return result;
    };
    
    MultiClassLogistic.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        
        
        var max_prob = 0.0;
        var best_c = '';
        for(var k = 0; k < this.classes.length; ++k) {
            var c = this.classes[k];
            var prob_c = this.logistics[c].transform(x);
            if(max_prob < prob_c){
                max_prob = prob_c;
                best_c = c;
            }
        }
        
        return best_c;
    }
    
    
    
    jsr.MultiClassLogistic = MultiClassLogistic;

})(jsregression);

var module = module || {};
if(module) {
	module.exports = jsregression;
}
};
BundleModuleCode['plugins/ml/pre']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     8-2-16 by sbosse.
 **    $VERSION:     1.20.1X
 **
 **    $INFO:
 **
 **  JavaScript Machine Learning API: Data Preprocessing
 **
 **    $ENDOFINFO
 */

var Io = Require('com/io');
var Comp = Require('com/compat');
var _ = undefined;
var none = null;

var isArray   = Comp.obj.isArray,
    isNumber  = Comp.obj.isNumber,
    isObject  = Comp.obj.isObject,
    isMatrix  = Comp.obj.isMatrix;
/**
 * Computes Log with base-2
 * @private
 */
function log2(n) {
  return Math.log(n) / Math.log(2);
}

function obj2Array(row,features) {
  return features.map(function (attr) { return row[attr] });
}
function objSlice(row,features) {
  var o = {};
  features.forEach(function (attr) { o[attr]=row[attr] });
  return o;
}
function array2Object(row,features) {
  var result={};
  row.forEach(function (x,index) { result[features[index]]=x });
  return result;
}

// transform [v][] -> v[]
function relax(mat) {
  if (isMatrix(mat) && mat[0].length==1) return mat.map(function (row) { return row[0]})
  else return mat;
}

// transform v[] -> [v][]
function wrap(mat) {
  if (!isMatrix(mat)) return mat.map(function (v) { return [v]})
  else return mat
}

function Constructor(f, args) {
    return function() {
        f.apply(this, args);
    };
};

/* Common data transformation between different formats (X)
**
** 1a. need='xy':   data={$x:'a,$y:'b}[]    -> {x:{$x} [], y:'b[]}
** 1b. need='xy':   data=('a|'b)[][]        -> {x:'a [][], y:'b[]}
** 1b. need='xy':   data={input:[],output:[]}[]    -> {x:'a [][], y:'b[]}
** 1c. need='xry':  data=('a|'b)[][]        -> {x:{$x} [], y:'b[]}
** 1c. need='io':   data=number[][]         -> {input:number, output:number} []
** 1d. need='io':   data={$x:number,$y:number}[] -> {input:number [], output:number []} []
** 2. need='xmy':   data=number [][]    -> {x:'a [][], y:'b[]}
** 2b. need='xmy':   data={$x:'a,$y:'b}[]    -> {x:'a [][], y:'b[]}
** 3. need='d':     data={x:'a[][],y:'b[]}} -> {$x:'a,$y:'b}[]
** 4. need='dm':    data={x:'a[][],y;'b[]}  -> ('a|'b)[][]
** 5. need='m':     data={$x:'a}[]          -> 'a [][]
** 5b. need='m':     data={x:'a [],y:'a[]}[]          -> 'a [][]
** 6. need='a':     data={$x:'a}            -> 'a []
** 7. need='scale'  data='a []              -> 'a [] (features)
** 8. need='r':     data='a [][]            -> {$x:'a}[]
**
** typeof options = {
**   scale:   {k:number|number[], off:number|number[], shift:number|number[]} is transformation of input data,
**            | {}[] | [min,max] | 'auto',
**   xscale:  {k:number|number[], off:number|number[], shift:number|number[]} is transformation of input data,
**            | {}[] 
**   yscale:  {k:number|number[], off:number|number[], shift:number|number[]} is transformation of output data,
**            | {}[]
**   features : string [] | number [] is feature variable list,
**   target: string | number is output variable,
**   targets : number [] is output variables list,
**   labels: string [] // ANN: y-vector output mapping (one label == one y[0,1] vector //
**
**/

// Scale (compress) data
function scale(vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return scala.shift+(vrow-scala.off)*scala.k
    else if (scala.length)
      return scala[0].shift+(vrow-scala[0].off)*scala[0].k;
    else
      return scala.shift+(vrow-scala.off[0])*scala.k[0];
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off)*scala.k })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return scala[i].shift+(col-scala[i].off)*scala[i].k })
  else
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off[i])*scala.k[i] })
}
// Unscale (decompress) data
function unscale(vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return (vrow-scala.shift)/scala.k+scala.off
    else if (scala.length)
      return (vrow-scala[0].shift)/scala[0].k+scala[0].off
    else
      return (vrow-scala.shift)/scala.k[0]+scala.off[0]
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return (col-scala.shift)/scala.k+scala.off })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return (col-scala[i].shift)/scala[i].k+scala[i].off })  
  else
    return vrow.map(function (col,i) { 
      return (vrow-scala.shift)/scala.k[i]+scala.off[i] })  
}

// [a,b] auto scaler of data tables
function autoScale(data,features,shift) {
  var min=[],
      max=[],
      row=data[0];
  if (Comp.obj.isArray(row)) {
    for(var i=0;i<data.length;i++) {
      row=data[i];
      for(var j=0;j<row.length;j++) {
        if (min[j]==undefined) min[j]=row[j]; else min[j]=Math.min(row[j],min[j]);
        if (max[j]==undefined) max[j]=row[j]; else max[j]=Math.max(row[j],max[j]);
      }  
    }
  } else if (Comp.obj.isObj(row)) {
    if (!features) features=Object.keys(row);
    for(var i=0;i<data.length;i++) {
      row=data[i];
      for(var j=0;j<features.length;j++) {
        if (min[j]==undefined) min[j]=row[features[j]]; else min[j]=Math.min(row[features[j]],min[j]);
        if (max[j]==undefined) max[j]=row[features[j]]; else max[j]=Math.max(row[features[j]],max[j]);
      }  
    }    
  } 
  
  shift=shift||0;
  if (min.length==1)
  return {
      k:(1-shift)/(max[0]-min[0]),
      off:min[0],
      shift:shift,
      min:min[0],
      max:max[0]
  }
  else
  return {
      k:min.map(function (a,i) { var b=max[i]; return (1-shift)/(b-a)}),
      off:min,
      shift:shift,
      min:min,
      max:max
  }
}

function toScale(min,max,lower,upper) {
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  if (typeof min == 'number')
  return {
      k:(upper-lower)/(max-min),
      off:min,
      shift:lower,
      min:min,
      max:max
  }
  else if (min.length==1)
  return {
      k:(upper-lower)/(max[0]-min[0]),
      off:min[0],
      shift:lower,
      min:min[0],
      max:max[0]
  }
  else
  return {
      k:min.map(function (a,i) { var b=max[i]; return (upper-lower)/(b-a)}),
      off:min,
      shift:lower,
      min:min,
      max:max
  }
}
function preprocess(data,need,options) {
  var row,x,y,_data;
  options=options||{};
  var scala=options.scale || options.xscale, scalaY;
  // wrap array
  function array(data) {
    return isArray(data)?data:[data]
  } 
  // map categorical variable on numeric vector (one element for each label)  
  function map(data,labels,bipolar) {
    return labels.map(function (x) {
      if (data==x) return 1;
      else return bipolar?-1:0;
    })
  }
  function scalemat(mat,scala) {
    if (!scala) return mat;
    return mat.map(function (row) { return scale(row,scala) });
  }
  // TODO: options.targets
  
  if (isArray(data)) {
    row=data[0];
    switch (need) {
      case 'xy':
      case 'xry':
        if ((options.target||options.targets)!=undefined && options.features!=undefined) {
          if (isArray(row) && need=='xy') {
            if (Number(options.target)==row.length-1) {
              x=data.map(function (row) { return scale(row.slice(0,options.target),scala) });
              y=data.map(function (row) { return row[options.target] })
            }
          } else  if (isObject(row)) {
            if (typeof options.target == 'string') {
              x=data.map(function (row) { return scale(objSlice(row,options.features),scala) });
              y=data.map(function (row) { return row[options.target] });
            }
          }
        } else if (row.input && row.output) {
          x=data.map(function (row) { return row.input });
          y=data.map(function (row) { return row.output });
        }
        if (x && y) return {x:x,y:y}
        break;
      case 'a':
        if (isArray(data) && typeof data[0] != 'object') return {data:data};  
        if (isObject(data) && options.features!=undefined) {
          return { data:data.map(function (row) { 
                    return scale(objSlice(row,options.features),scala) })};
        }
        break;
      case 'm':
        if (isArray(row.x) && isArry(row.y)) {
          return { data:data.map(function (row) { 
                    return scale(row.x,scala).concat(scale(row.y,options.yscale)) })};                  
        }
        if (isMatrix(data) && !scala) return {data:data};
        else if (isMatrix(data) && !options.features) {
          // just scale data
          return { data:data.map(function (row) { 
                    return scale(row,scala) })};        
        } 
        if (isObject(row)) {
          if (!options.features) options.features=Object.keys(data[0]);
          return { data:data.map(function (row) { 
                    return scale(obj2Array(row,options.features),scala) })};
        }
       break;  
      case 'r':
       if (!isArray(row) && isObject(row)) return {data:data};
        if (isArray(row)) {
          if (!options.features) options.features=row.map(function (x,i) { return String(i) });
          return { data:data.map(function (row) { 
                    return scale(array2Object(row,options.features),scala) })};
        }
       break;  
      case 'xmy':
        if (isObject(row) && options.features!=undefined && (options.target||options.targets)!=undefined) {
          return isObject(options.target)?
                 { x:data.map(function (row) { 
                      return scale(obj2Array(row,options.features),scala) }),
                   y:data.map(function (row) { return scale(obj2Array(row,options.target),options.yscale)})}:
                 { x:data.map(function (row) { 
                      return scale(obj2Array(row,options.features),scala) }),
                   y:data.map(function (row) { return scale(row[options.target],options.yscale)})};
       }
       break;  
      case 'io':
        if (isArray(row) && (options.target||options.targets)!=undefined) {
          // number [][] 
          if (scala=='auto') scala=autoScale(data,null);
          if (Number(options.target)==row.length-1) {
            _data=data.map(function (row) { return { input :scale(row.slice(0,options.target),scala),
                                                     output:scale(array(row[options.target]),options.yscale) }});
            return _data
          } else {
            _data=data.map(function (row) { return { input :scale(obj2Array(row,options.features),scala),
                                                     output:options.targets?
                                                            scale(array(obj2Array(row,options.targets)),options.yscale) 
                                                            :
                                                            scale(array(row[options.target]),options.yscale) }});
            return _data          
          }
        } else if (isArray(row.x) && isArray(row.y)) {
          return data.map(function (row) {
                  return { input:scale(row.x,scala),
                           output:scale(row.y,options.yscale) }});       
        } else if (isObject(row) && !row.input && (options.target||options.targets)!=undefined && options.features!=undefined) {
          if (scala=='auto') scala=autoScale(data,options.features);
          _data=data.map(function (row) { return { input :scale(obj2Array(row,options.features),scala),
                                                   output:options.labels?
                                                          map(array(row[options.target]),options.labels)
                                                          :
                                                          options.targets?
                                                          scale(array(obj2Array(row,options.targets)),options.yscale) 
                                                          :
                                                          scale(array(row[options.target]),options.yscale) }});
          return _data
        } else if (row.input && row.output) {
          if (scala) {
            if (scala=='auto') scala=autoScale(data.input,null);
            _data=data.map(function (row) { return { input :scale(row.input,scala),
                                                   output:scale(row.output,options.yscale) }});
            return _data          
          } else return data;  // { input:number [], output: number [] } []
        } 
        break;
      case 'scale':
        if (isArray(row) && options.scale!=undefined) {
          if (options.features)
            return data.map(function (row) { return scale(obj2Array(row,options.features),options.scale) })
          else      
            return data.map(function (row) { return scale(row,options.scale) })
        }
    }
  } else if (data.x && data.y) {
    if (isArray(data.x) && isArray(data.y)) {
      row=data.x[0];
      if (scala=='auto') {
        scala=autoScale(data.x,null);
        scalaY=autoScale(data.y,null);
      } else scalaY=options.yscale;
      switch (need) {
        case 'io':
        if (isArray(row)) {
          // x:number [][] 
          _data=data.x.map(function (row, rowi) { return { input:scale(row,scala),
                                                           output:array(data.y[rowi]) }});
          return _data          
        } else if (isNumber(row)) {
          // x: number []
          _data=data.x.map(function (row, rowi) { return { input:scale(array(row),scala),
                                                           output:array(data.y[rowi]) }});        
          return _data          
        }
        if (isObject(row) && options.features!=undefined) {
          // x: {}

          _data=data.x.map(function (row, rowi) { return { input:scale(obj2Array(row,options.features),scala),
                                                           output:array(data.y[rowi]) }});
          return _data          
        }
        break;
        case 'xm':
          if (isArray(row)) return data.x;
          break;
        case 'xmy':
          if (isArray(row)) return { x:scalemat(data.x,scala), y:scalemat(data.y,scalaY||options.yscale||scala)};
          break;
        case 'xmya':
          if (isArray(row)) return { x:data.x, y:data.y.map(array)};
          break;
        case 'd':
          return data.x.map(function (row,rowi) {
            var newrow={};
            if (options.features && options.target) {
              options.features.forEach(function (f,coli) {
                newrow[f]=row[coli];
              });
              newrow[options.target]=data.y[rowi];
            } else {
              row.forEach(function (col,f) {
                newrow[String(f)]=col;                
              });
              newrow[String(row.length)]=data.y[rowi];
            }
            return newrow;
          })
          break;
      } 
    }   
  }
}

// randomly split data table in two paritions (e.g., training/test)
// function ([],nuµber,number) -> [partA [],partB [],?indexmapA [],?indexmapB []]
function split (data,partA,partB,withmap) {
  var A=[],B=[],mapA=[],mapB=[],index;
  if (partA==undefined) throw "ML.split: missing partA size";
  if (partB==undefined) { partB=data.length-partA };
  if (data.length < (partA+partB)) throw new Error('EINVALID');
  function shuffle(array) {
    var m = array.length, t, i;
    // While there remain elements to shuffle\u2026
    while (m) {
      // Pick a remaining element\u2026
      i = Math.floor(Math.random() * m--);
      // And swap it with the current element.
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }
    return array;
  }
  index=Array(data.length).fill().map(function (x,i) { return i });
  index=shuffle(index);
  for(var i=0;i<partA;i++) {
    A.push(data[index[i]]);
    mapA.push(index[i]);
  }
  for(var j=0;j<partB;j++) {
    B.push(data[index[i+j]]);
    mapB.push(index[i+j]);
  }
  return withmap?[A,B,mapA,mapB]:[A,B]
}

module.exports = {
  array2Object:array2Object,
  autoScale:autoScale,
  obj2Array:obj2Array,
  objSlice:objSlice,
  preprocess:preprocess,
  relax:relax,
  scale:scale,
  split:split,
  toScale:toScale,
  unscale:unscale,
  wrap:wrap,
}
};
BundleModuleCode['plugins/ml/sa']=function (module,exports,global,process){
// @justyy
// https://github.com/DoctorLai/simulated_annealling

var SimulatedAnnealing = function (options, generateNewSolution, generateNeighbor, acceptNeighbor) {
	// Set Parameters
    var coolingFactor            = options.coolingFactor || 0.05;
    var stabilizingFactor        = options.stabilizingFactor || 1.005;
    var freezingTemperature      = options.freezingTemperature || 0.001;
    var currentSystemTemperature = options.initialTemperature || 20;
    var curStabilizor            = options.initialStabilizer || 35;    

    // Init solution
    var currentSysEnergy         = generateNewSolution();

    // Probability Function
    // Higher Temperature means more likely to accept worse solutions, and vice versa
    var Prob = function (t, d) {
	    if (d < 0) {
	        return true;
	    }
	    var C = Math.exp(-d / t);
	    var R = Math.random();
	    return (R < C);
    }

    // One Iteration of Process and Return: Should we Continue?
    var _Do = function ()  {
	    if (currentSystemTemperature > freezingTemperature) {
	        for (var i = 0; i < curStabilizor; ++ i) {
	            var newEnergy = generateNeighbor(),
	                energyDelta = newEnergy - currentSysEnergy;

	            if (Prob(currentSystemTemperature, energyDelta)) {
	                // accept this neighbour 
	                acceptNeighbor();
	                // update energey
	                currentSysEnergy = newEnergy;
	            }
	        }
	        // temperature is cooling down
	        currentSystemTemperature = currentSystemTemperature - coolingFactor;
	        // so it is less likely to accept worse solutions
	        curStabilizor = curStabilizor * stabilizingFactor;
	        return true;
	    }
    	currentSystemTemperature = freezingTemperature;
    	return false;	    
	}

	// Get Current System Energy
	var _GetCurrentEnergy = function () {
		return currentSysEnergy;
	}

	// Get Current Temperature
	var _GetCurrentTemperature = () => {
		return currentSystemTemperature;
	}

	// Export Methods
	return {
		Do: function() {
			return _Do();
		},

		GetCurrentEnergy: function() {
			return _GetCurrentEnergy();
		},

		GetCurrentTemperature: function() {
			return _GetCurrentTemperature();
		}
	}
}

// module exports the Simulated Annealing Object
module.exports = { 
	SimulatedAnnealing : SimulatedAnnealing
} 
};
BundleModuleCode['plugins/math/druid']=function (module,exports,global,process){
// https://renecutura.eu v0.6.0 Copyright 2022 Rene Cutura
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.druid = global.druid || {}));
})(this, (function (exports) { 'use strict';

// polyfill a ?? b
function LOR (a,b) { return a==undefined?b:a }

/**
 * Computes the euclidean distance (<code>l<sub>2</sub></code>) between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias euclidean
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} the euclidean distance between <code>a</code> and <code>b</code>.
 */
function euclidean (a, b) {
    return Math.sqrt(euclidean_squared(a, b));
}

/**
 * Numerical stable summation with the Kahan summation algorithm.
 * @memberof module:numerical
 * @alias kahan_sum
 * @param {Array} summands - Array of values to sum up.
 * @returns {number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}
 */
function kahan_sum (summands) {
    let n = summands.length;
    let sum = 0;
    let compensation = 0;
    let y, t;

    for (let i = 0; i < n; ++i) {
        y = summands[i] - compensation;
        t = sum + y;
        compensation = t - sum - y;
        sum = t;
    }
    return sum;
}

/**
 * Numerical stable summation with the Neumair summation algorithm.
 * @memberof module:numerical
 * @alias neumair_sum
 * @param {Number[]} summands - Array of values to sum up.
 * @returns {Number} The sum.
 * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}
 */
function neumair_sum (summands) {
    const n = summands.length;
    let sum = 0;
    let compensation = 0;

    for (let i = 0; i < n; ++i) {
        const summand = summands[i];
        const t = sum + summand;
        if (Math.abs(sum) >= Math.abs(summand)) {
            compensation += sum - t + summand;
        } else {
            compensation += summand - t + sum;
        }
        sum = t;
    }
    return sum + compensation;
}

/**
 * Computes the squared euclidean distance (l<sub>2</sub><sup>2</sup>) between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias euclidean_squared
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} the squared euclidean distance between <code>a</code> and <code>b</code>.
 */
function euclidean_squared (a, b) {
    if (a.length != b.length) return undefined;
    const n = a.length;
    const s = new Float64Array(n);
    for (let i = 0; i < n; ++i) {
        const x = a[i];
        const y = b[i];
        const x_y = x - y;
        s[i] = x_y * x_y;
    }
    return neumair_sum(s);
}

/**
 * Computes the cosine distance (not similarity) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias cosine
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} The cosine distance between {@link a} and {@link b}.
 * 
 * @example
 * import * as druid from "@saehrimnir/druidjs";
 * 
 * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == π/4;
 * 
 */
function cosine (a, b) {
    if (a.length !== b.length) return undefined;
    let n = a.length;
    let sum = 0;
    let sum_a = 0;
    let sum_b = 0;
    for (let i = 0; i < n; ++i) {
        sum += a[i] * b[i];
        sum_a += a[i] * a[i];
        sum_b += b[i] * b[i];
    }
    return Math.acos(sum / (Math.sqrt(sum_a) * Math.sqrt(sum_b)));
}

/**
 * Computes the manhattan distance (<code>l<sub>1</sub></code>) between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias manhattan
 * @param {Array<Number>} a
 * @param {Array<Number>} b
 * @returns {Number} the manhattan distance between <code>a</code> and <code>b</code>.
 */ 
function manhattan (a, b) {
    if (a.length != b.length) return undefined;
    const n = a.length;
    let sum = 0;
    for (let i = 0; i < n; ++i) {
        sum += Math.abs(a[i] - b[i]);
    }
    return sum;
}

/**
 * Computes the chebyshev distance (L<sub>∞</sub>) between {@link a} and {@link b}.
 * @memberof module:metrics
 * @alias chebyshev
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} the chebyshev distance between {@link a} and {@link b}.
 */
function chebyshev (a, b) {
    if (a.length != b.length) return undefined;
    const n = a.length;
    let res = [];
    for (let i = 0; i < n; ++i) {
        res.push(Math.abs(a[i] - b[i]));
    }
    return Math.max(...res);
}

/**
 * Computes the canberra distance between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias canberra
 * @param {Number[]} a 
 * @param {Number[]} b 
 * @returns {Number} the canberra distance between <code>a</code> and <code>b</code>.
 * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}
 */
function canberra(a, b) {
    if (a.length !== b.length) return undefined;
    const n = a.length;
    let sum = 0;
    for (let i = 0; i < n; ++i) {
        sum += (Math.abs(a[i] - b[i]) / (Math.abs(a[i]) + Math.abs(b[i])));
    }
    return sum;
}

/**
 * Computes the jaccard distance between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias jaccard
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} the jaccard distance between <code>a</code> and <code>b</code>.
 */
function jaccard (a, b) {
    if (a.length != b.length) return undefined;
    const n = a.length;
    let num_non_zero = 0;
    let num_equal = 0;
    for (let i = 0; i < n; ++i) {
        const x = a[i] != 0;
        const y = b[i] != 0;
        num_non_zero += x || y;
        num_equal += x && y;
    }
    return (num_non_zero - num_equal) / num_non_zero;
}

/**
 * Computes the hamming distance between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias hamming
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} the hamming distance between <code>a</code> and <code>b</code>.
 */
function hamming (a, b) {
    if (a.length != b.length) return undefined;
    const n = a.length;
    let disagree = 0;
    for (let i = 0; i < n; ++i) {
        const x = a[i];
        const y = b[i];
        disagree += x != y;
    }
    return disagree / n;
}

/**
 * Computes the Sokal-Michener distance between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias sokal_michener
 * @param {Number[]} a 
 * @param {Number[]} b 
 * @returns {Number} the Sokal-Michener distance between <code>a</code> and <code>b</code>.  
 */
function sokal_michener(a, b) {
    if (a.length != b.length) return undefined
    const n = a.length;
    let num_not_equal = 0;
    for (let i = 0; i < n; ++i) {
        const x = a[i] != 0;
        const y = b[i] != 0;
        num_not_equal += x != y;
    }
    return (2 * num_not_equal) / (n + num_not_equal);
}

/**
 * Computes the yule distance between <code>a</code> and <code>b</code>.
 * @memberof module:metrics
 * @alias yule
 * @param {Number[]} a
 * @param {Number[]} b
 * @returns {Number} the yule distance between <code>a</code> and <code>b</code>.
 */
function yule (a, b) {
    if (a.length != b.length) return undefined;
    const n = a.length;
    let num_true_true = 0;
    let num_true_false = 0;
    let num_false_true = 0;
    for (let i = 0; i < n; ++i) {
        const x = a[i] != 0;
        const y = b[i] != 0;
        num_true_true += x && y;
        num_true_false += x && !y;
        num_false_true += !x && x;
    }
    const num_false_false = n - num_true_true - num_true_false - num_false_true;
    return num_true_false == 0 || num_false_true == 0 ? 0 : (2 * num_true_false * num_false_true) / (num_true_true * num_false_false + num_true_false * num_false_true);
}

/**
 * Computes the k-nearest neighbors of each row of {@link A}.
 * @memberof module:matrix
 * @alias k_nearest_neigbhors
 * @param {Matrix} A - Either the data matrix, or a distance matrix.
 * @param {Number} k - The number of neighbors to compute.
 * @param {Function|"precomputed"} [metric=euclidean]
 * @returns {Array<Object>} -
 */
function k_nearest_neighbors (A, k, metric = euclidean) {
    const rows = A.shape[0];
    let D = metric == "precomputed" ? A : distance_matrix(A, metric);
    let nN = new Array(rows);
    for (let row = 0; row < rows; ++row) {
        nN[row] = Array.from(D.row(row))
            .map((distance, col) => {
                return {
                    i: row,
                    j: col,
                    distance: distance,
                };
            })
            .sort((a, b) => a.distance - b.distance)
            .slice(1, k + 1);
    }
    return nN;
}

/**
 * Computes the distance matrix of datamatrix {@link A}.
 * @memberof module:matrix
 * @alias distance_matrix
 * @param {Matrix} A - Matrix.
 * @param {Function} [metric=euclidean] - The diistance metric.
 * @returns {Matrix} D - The distance matrix of {@link A}.
 */
function distance_matrix (A, metric = euclidean) {
    let n = A.shape[0];
    const D = new Matrix(n, n);
    for (let i = 0; i < n; ++i) {
        const A_i = A.row(i);
        for (let j = i + 1; j < n; ++j) {
            const dist = metric(A_i, A.row(j));
            D.set_entry(i, j, dist);
            D.set_entry(j, i, dist);
        }
    }
    return D;
}

/**
 * Creates an Array containing {@link number} numbers from {@link start} to {@link end}.
 * If <code>{@link number} = null</null>.
 * @memberof module:matrix
 * @alias linspace
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} [number = null] - Number of number between {@link start} and {@link end}.
 * @returns {Array} - An array with {@link number} entries, beginning at {@link start} ending at {@link end}.
 */
function linspace (start, end, number = null) {
    if (!number) {
        number = Math.max(Math.round(end - start) + 1, 1);
    }
    if (number < 2) {
        return number === 1 ? [start] : [];
    }
    let result = new Array(number);
    number -= 1;
    for (let i = number; i >= 0; --i) {
        result[i] = (i * end + (number - i) * start) / number;
    }
    return result;
}

//import { neumair_sum } from "../numerical/index";

/**
 * Computes the norm of a vector, by computing its distance to **0**.
 * @memberof module:matrix
 * @alias norm
 * @param {Matrix|Array<Number>|Float64Array} v - Vector.
 * @param {Function} [metric = euclidean] - Which metric should be used to compute the norm.
 * @returns {Number} - The norm of {@link v}.
 */
function norm (v, metric = euclidean) {
    let vector = null;
    if (v instanceof Matrix) {
        let [rows, cols] = v.shape;
        if (rows === 1) vector = v.row(0);
        else if (cols === 1) vector = v.col(0);
        else throw new Error("Matrix must be 1d!");
    } else {
        vector = v;
    }
    const n = vector.length;
    const zeros = new Float64Array(n);
    return metric(vector, zeros);
}

/**
 * Normalizes Vector {@link v}.
 * @memberof module:matrix
 * @alias normalize
 * @param {Array<Number>|Float64Array} v - Vector
 * @param {Function} metric 
 * @returns {Array<Number>|Float64Array} - The normalized vector with length 1.
 */
function normalize(v, metric = euclidean)  {
    const v_norm = norm(v, metric);
    return v.map(value => value / v_norm);
}

/**
 * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.
 * @memberof module:linear_algebra
 * @alias qr
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}
 */
function qr_gramschmidt (A) {
    const [rows, cols] = A.shape;
    const Q = new Matrix(rows, cols, "identity");
    const R = new Matrix(cols, cols, 0);

    for (let j = 0; j < cols; ++j) {
        let v = A.col(j);
        for (let i = 0; i < j; ++i) {
            const q = Q.col(i);
            const q_dot_v = neumair_sum(q.map((q_, k) => q_ * v[k]));
            R.set_entry(i, j, q_dot_v);
            v = v.map((v_, k) => v_ - q_dot_v * q[k]);
        }
        const v_norm = norm(v, euclidean);
        for (let k = 0; k < rows; ++k) {
            Q.set_entry(k, j, v[k] / v_norm);
        }
        R.set_entry(j, j, v_norm);
    }
    return { R, Q };
}

/**
 * Computes the QR Decomposition of the Matrix {@link A} with householder transformations.
 * @memberof module:linear_algebra
 * @alias qr_householder
 * @param {Matrix} A
 * @returns {{R: Matrix, Q: Matrix}}
 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections}
 * @see {@link http://mlwiki.org/index.php/Householder_Transformation}
 */
function qr_householder (A) {
    const [rows, cols] = A.shape;
    const Q = new Matrix(rows, rows, "I");
    const R = A.clone();

    for (let j = 0; j < cols; ++j) {
        const x = Matrix.from(R.col(j).slice(j));
        const x_norm = norm(x);
        const x0 = x.entry(0, 0);
        const rho = -Math.sign(x0);
        const u1 = x0 - rho * x_norm;
        const u = x.divide(u1).set_entry(0, 0, 1);
        const beta = (-rho * u1) / x_norm;

        const u_outer_u = u.outer(u);
        const R_block = R.get_block(j, 0);
        const new_R = R_block.sub(u_outer_u.dot(R_block).mult(beta));
        const Q_block = Q.get_block(0, j);
        const new_Q = Q_block.sub(Q_block.dot(u_outer_u).mult(beta));
        R.set_block(j, 0, new_R);
        Q.set_block(0, j, new_Q);
    }
    return { R, Q };
}

/**
 * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.
 * @memberof module:linear_algebra
 * @alias simultaneous_poweriteration
 * @param {Matrix} A - The Matrix
 * @param {Number} k - The number of eigenvectors and eigenvalues to compute.
 * @param {Object} parameters - Object containing parameterization of the simultanious poweriteration method.
 * @param {Number} [parameters.max_iterations=100] - The number of maxiumum iterations the algorithm should run.
 * @param {Number|Randomizer} [parameters.seed=1212] - The seed value or a randomizer used in the algorithm.
 * @param {Function} [parameters.qr=qr_gramschmidt] - The QR technique to use.
 * @param {Number} [parameters.tol=1e-8] - Allowed error for stopping criteria
 * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.
 */
function simultaneous_poweriteration (A, k = 2, {seed = 1212, max_iterations = 100, qr = qr_gramschmidt, tol = 1e-8} = {}) {
    const randomizer = seed instanceof Randomizer ? seed : new Randomizer(seed);
    if (!(A instanceof Matrix)) A = Matrix.from(A);
    const n = A.shape[0];
    let { Q, R } = qr(new Matrix(n, k, () => (randomizer.random - .5) * 2));
    while (max_iterations--) {
        const oldQ = Q.clone();
        const Z = A.dot(Q);
        const QR = qr(Z);
        Q = QR.Q;
        R = QR.R;
        const error = euclidean_squared(Q.values, oldQ.values);
        if (error < tol) {
            break;
        }
    }

    const eigenvalues = R.diag;
    const eigenvectors = Q.transpose().to2dArray;
    return { eigenvalues, eigenvectors };
}

/**
 * Computes the inner product between two arrays of the same length.
 * @memberof module:linear_algebra
 * @alias inner_product
 * @param {Array|Float64Array} a - Array a
 * @param {Array|Float64Array} b - Array b
 * @returns The inner product between {@link a} and {@link b}
 */
function inner_product (a, b) {
    const N = a.length;
    if (N != b.length) {
        throw new Error("Array a and b must have the same length!")
    }
    let sum = 0;
    for (let i = 0; i < N; ++i) {
        sum += a * b;
    }
    return sum;
}

/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */
class Matrix {
    /**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @memberof module:matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
    constructor(rows = null, cols = null, value = null) {
        this._rows = rows;
        this._cols = cols;
        this._data = null;
        if (rows && cols) {
            if (!value) {
                this._data = new Float64Array(rows * cols);
                return this;
            }
            if (typeof value === "function") {
                this._data = new Float64Array(rows * cols);
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        this._data[row * cols + col] = value(row, col);
                    }
                }
                return this;
            }
            if (typeof value === "string") {
                if (value === "zeros") {
                    return new Matrix(rows, cols, 0);
                }
                if (value === "identity" || value === "I") {
                    this._data = new Float64Array(rows * cols);
                    for (let row = 0; row < rows; ++row) {
                        this._data[row * cols + row] = 1;
                    }
                    return this;
                }
                if (value === "center" && rows == cols) {
                    this._data = new Float64Array(rows * cols);
                    value = (i, j) => (i === j ? 1 : 0) - 1 / rows;
                    for (let row = 0; row < rows; ++row) {
                        for (let col = 0; col < cols; ++col) {
                            this._data[row * cols + col] = value(row, col);
                        }
                    }
                    return this;
                }
            }
            if (typeof value === "number") {
                this._data = new Float64Array(rows * cols);
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        this._data[row * cols + col] = value;
                    }
                }
                return this;
            }
            if (typeof value != "undefined" && value instanceof Float64Array) {
                this._data = value;
                return this;
            }
        }
        return this;
    }

    /**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */
    static from(A, type = "row") {
        if (A instanceof Matrix) {
            return A.clone();
        } else if (Array.isArray(A) || A instanceof Float64Array) {
            let m = A.length;
            if (m === 0) throw new Error("Array is empty");
            // 1d
            if (!Array.isArray(A[0]) && !(A[0] instanceof Float64Array)) {
                if (type === "row") {
                    return new Matrix(1, m, (_, j) => A[j]);
                } else if (type === "col") {
                    return new Matrix(m, 1, (i) => A[i]);
                } else if (type === "diag") {
                    return new Matrix(m, m, (i, j) => (i == j ? A[i] : 0));
                } else {
                    throw new Error("1d array has NaN entries");
                }
                // 2d
            } else if (Array.isArray(A[0]) || A[0] instanceof Float64Array) {
                let n = A[0].length;
                for (let row = 0; row < m; ++row) {
                    if (A[row].length !== n) {
                        throw new Error("various array lengths");
                    }
                }
                return new Matrix(m, n, (i, j) => A[i][j]);
            }
        } else if (typeof A === "number") {
            return new Matrix(1, 1, A);
        } else {
            throw new Error("error");
        }
    }

    /**
     * Returns the {@link row}<sup>th</sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */
    row(row) {
        const data = this.values;
        const cols = this._cols;
        return data.subarray(row * cols, (row + 1) * cols);
    }

    /**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */
    *iterate_rows() {
        const cols = this._cols;
        const rows = this._rows;
        const data = this.values;
        for (let row = 0; row < rows; ++row) {
            yield data.subarray(row * cols, (row + 1) * cols);
        }
    }

    /**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */
    *[Symbol.iterator]() {
        for (const row of this.iterate_rows()) {
            yield row;
        }
    }

    /**
     * Sets the entries of {@link row}<sup>th</sup> row from the Matrix to the entries from {@link values}.
     * @param {Number} row
     * @param {Array} values
     * @returns {Matrix}
     */
    set_row(row, values) {
        const cols = this._cols;
        if ((Array.isArray(values) || values instanceof Float64Array) && values.length === cols) {
            const offset = row * cols;
            for (let col = 0; col < cols; ++col) {
                this.values[offset + col] = values[col];
            }
        } else if (values instanceof Matrix && values.shape[1] === cols && values.shape[0] === 1) {
            const offset = row * cols;
            for (let col = 0; col < cols; ++col) {
                this.values[offset + col] = values._data[col];
            }
        } else {
            throw new Error("Values not valid! Needs to be either an Array, a Float64Array, or a fitting Matrix!")
        }
        return this;
    }

    /**
     * Returns the {@link col}<sup>th</sup> column from the Matrix.
     * @param {Number} col
     * @returns {Array}
     */
    col(col) {
        const result_col = new Float64Array(this._rows);
        for (let row = 0; row < this._rows; ++row) {
            result_col[row] = this.values[row * this._cols + col];
        }
        return result_col;
    }

    /**
     * Returns the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */
    entry(row, col) {
        return this.values[row * this._cols + col];
    }

    /**
     * Sets the {@link col}<sup>th</sup> entry from the {@link row}<sup>th</sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */
    set_entry(row, col, value) {
        this.values[row * this._cols + col] = value;
        return this;
    }

    /**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */
    transpose() {
        let B = new Matrix(this._cols, this._rows, (row, col) => this.entry(col, row));
        return B;
    }

    /**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */
    get T() {
        return this.transpose();
    }

    /**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */
    inverse() {
        const rows = this._rows;
        const cols = this._cols;
        let B = new Matrix(rows, 2 * cols, (i, j) => {
            if (j >= cols) {
                return i === j - cols ? 1 : 0;
            } else {
                return this.entry(i, j);
            }
        });
        let h = 0;
        let k = 0;
        while (h < rows && k < cols) {
            var i_max = 0;
            let max_val = -Infinity;
            for (let i = h; i < rows; ++i) {
                let val = Math.abs(B.entry(i, k));
                if (max_val < val) {
                    i_max = i;
                    max_val = val;
                }
            }
            if (B.entry(i_max, k) == 0) {
                k++;
            } else {
                // swap rows
                for (let j = 0; j < 2 * cols; ++j) {
                    let h_val = B.entry(h, j);
                    let i_val = B.entry(i_max, j);
                    B.set_entry(h, j, h_val);
                    B.set_entry(i_max, j, i_val);
                }
                for (let i = h + 1; i < rows; ++i) {
                    let f = B.entry(i, k) / B.entry(h, k);
                    B.set_entry(i, k, 0);
                    for (let j = k + 1; j < 2 * cols; ++j) {
                        B.set_entry(i, j, B.entry(i, j) - B.entry(h, j) * f);
                    }
                }
                h++;
                k++;
            }
        }

        for (let row = 0; row < rows; ++row) {
            let f = B.entry(row, row);
            for (let col = row; col < 2 * cols; ++col) {
                B.set_entry(row, col, B.entry(row, col) / f);
            }
        }

        for (let row = rows - 1; row >= 0; --row) {
            let B_row_row = B.entry(row, row);
            for (let i = 0; i < row; i++) {
                let B_i_row = B.entry(i, row);
                let f = B_i_row / B_row_row;
                for (let j = i; j < 2 * cols; ++j) {
                    let B_i_j = B.entry(i, j);
                    let B_row_j = B.entry(row, j);
                    B_i_j = B_i_j - B_row_j * f;
                    B.set_entry(i, j, B_i_j);
                }
            }
        }

        return new Matrix(rows, cols, (i, j) => B.entry(i, j + cols));
    }

    /**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */
    dot(B) {
        if (B instanceof Matrix) {
            let A = this;
            if (A.shape[1] !== B.shape[0]) {
                throw new Error(`A.dot(B): A is a ${A.shape.join(" ⨯ ")}-Matrix, B is a ${B.shape.join(" ⨯ ")}-Matrix: 
                A has ${A.shape[1]} cols and B ${B.shape[0]} rows. 
                Must be equal!`);
            }
            let I = A.shape[1];
            let C = new Matrix(A.shape[0], B.shape[1], (row, col) => {
                const A_i = A.row(row);
                const B_i = B.col(col);
                let sum = 0;
                for (let i = 0; i < I; ++i) {
                    sum += A_i[i] * B_i[i];
                }
                return sum;
            });
            return C;
        } else if (Array.isArray(B) || B instanceof Float64Array) {
            let rows = this._rows;
            if (B.length !== rows) {
                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);
            }
            let C = new Array(rows);
            for (let row = 0; row < rows; ++row) {
                C[row] = neumair_sum(this.row(row).map((e) => e * B[row]));
            }
            return C;
        } else {
            throw new Error(`B must be Matrix or Array`);
        }
    }

    /**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */
    outer(B) {
        let A = this;
        let l = A._data.length;
        let r = B._data.length;
        if (l != r) return undefined;
        let C = new Matrix();
        C.shape = [
            l,
            l,
            (i, j) => {
                if (i <= j) {
                    return A._data[i] * B._data[j];
                } else {
                    return C.entry(j, i);
                }
            },
        ];
        return C;
    }

    /**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */
    concat(B, type = "horizontal") {
        const A = this;
        const [rows_A, cols_A] = A.shape;
        const [rows_B, cols_B] = B.shape;
        if (type == "horizontal") {
            if (rows_A != rows_B) {
                throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${rows_A} rows, B has ${rows_B} rows.`);
            }
            const X = new Matrix(rows_A, cols_A + cols_B, "zeros");
            X.set_block(0, 0, A);
            X.set_block(0, cols_A, B);
            return X;
        } else if (type == "vertical") {
            if (cols_A != cols_B) {
                throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${cols_A} columns, B has ${cols_B} columns.`);
            }
            const X = new Matrix(rows_A + rows_B, cols_A, "zeros");
            X.set_block(0, 0, A);
            X.set_block(rows_A, 0, B);
            return X;
        } else if (type == "diag") {
            const X = new Matrix(rows_A + rows_B, cols_A + cols_B, "zeros");
            X.set_block(0, 0, A);
            X.set_block(rows_A, cols_A, B);
            return X;
        } else {
            throw new Error(`type must be "horizontal" or "vertical", but type is ${type}!`);
        }
    }

    /**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */
    set_block(offset_row, offset_col, B) {
        let [rows, cols] = B.shape;
        for (let row = 0; row < rows; ++row) {
            if (row > this._rows) {
                continue;
            }
            for (let col = 0; col < cols; ++col) {
                if (col > this._cols) {
                    continue;
                }
                this.set_entry(row + offset_row, col + offset_col, B.entry(row, col));
            }
        }
        return this;
    }

    /**
     * Extracts the entries from the {@link start_row}<sup>th</sup> row to the {@link end_row}<sup>th</sup> row, the {@link start_col}<sup>th</sup> column to the {@link end_col}<sup>th</sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */
    get_block(start_row, start_col, end_row = null, end_col = null) {
        const [rows, cols] = this.shape;
        end_row = LOR(end_row ,rows);
        end_col = LOR(end_col ,cols);
        if (end_row <= start_row || end_col <= start_col) {
            throw new Error(`
                end_row must be greater than start_row, and 
                end_col must be greater than start_col, but
                end_row = ${end_row}, start_row = ${start_row}, end_col = ${end_col}, and start_col = ${start_col}!`);
        }
        const X = new Matrix(end_row - start_row, end_col - start_col, "zeros");
        for (let row = start_row, new_row = 0; row < end_row; ++row, ++new_row) {
            for (let col = start_col, new_col = 0; col < end_col; ++col, ++new_col) {
                X.set_entry(new_row, new_col, this.entry(row, col));
            }
        }
        return X;
        //return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
    }

    /**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */
    gather(row_indices, col_indices) {
        const N = row_indices.length;
        const D = col_indices.length;

        const R = new Matrix(N, D);
        for (let i = 0; i < N; ++i) {
            const row_index = row_indices[i];
            for (let j = 0; j < N; ++j) {
                const col_index = col_indices[j];
                R.set_entry(i, j, this.entry(row_index, col_index));
            }
        }

        return R;
    }

    /**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {Function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {Function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */
    _apply_array(f, v) {
        const data = this.values;
        const [rows, cols] = this.shape;
        for (let row = 0; row < rows; ++row) {
            const offset = row * cols;
            for (let col = 0; col < cols; ++col) {
                const i = offset + col;
                data[i] = f(data[i], v(row, col));
            }
        }
        return this;
    }

    _apply_rowwise_array(values, f) {
        return this._apply_array(f, (_, j) => values[j]);
    }

    _apply_colwise_array(values, f) {
        const data = this.values;
        const [rows, cols] = this.shape;
        for (let row = 0; row < rows; ++row) {
            const offset = row * cols;
            for (let col = 0; col < cols; ++col) {
                const i = offset + col;
                data[i] = f(data[i], values[row]);
            }
        }
        return this;
    }

    _apply(value, f) {
        let data = this.values;
        if (value instanceof Matrix) {
            let [value_rows, value_cols] = value.shape;
            let [rows, cols] = this.shape;
            if (value_rows === 1) {
                if (cols !== value_cols) {
                    throw new Error(`cols !== value_cols`);
                }
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        data[row * cols + col] = f(data[row * cols + col], value.entry(0, col));
                    }
                }
            } else if (value_cols === 1) {
                if (rows !== value_rows) {
                    throw new Error(`rows !== value_rows`);
                }
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        data[row * cols + col] = f(data[row * cols + col], value.entry(row, 0));
                    }
                }
            } else if (rows == value_rows && cols == value_cols) {
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        data[row * cols + col] = f(data[row * cols + col], value.entry(row, col));
                    }
                }
            } else {
                throw new Error(`error`);
            }
        } else if (Array.isArray(value)) {
            let rows = this._rows;
            let cols = this._cols;
            if (value.length === rows) {
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        data[row * cols + col] = f(data[row * cols + col], value[row]);
                    }
                }
            } else if (value.length === cols) {
                for (let row = 0; row < rows; ++row) {
                    for (let col = 0; col < cols; ++col) {
                        data[row * cols + col] = f(data[row * cols + col], value[col]);
                    }
                }
            } else {
                throw new Error(`error`);
            }
        } else {
            for (let i = 0, n = this._rows * this._cols; i < n; ++i) {
                data[i] = f(data[i], value);
            }
        }
        return this;
    }

    /**
     * Clones the Matrix.
     * @returns {Matrix}
     */
    clone() {
        let B = new Matrix();
        B._rows = this._rows;
        B._cols = this._cols;
        B._data = this.values.slice(0);
        return B;
    }

    /**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false]  - If true, applies multiplication to the element, otherwise it creates first a copy and applies the multiplication on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */
    mult(value, { inline = false } = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a * b);
    }

    /**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false] - If true, applies division to the element, otherwise it creates first a copy and applies the division on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */
    divide(value, { inline = false } = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a / b);
    }

    /**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false]  - If true, applies addition to the element, otherwise it creates first a copy and applies the addition on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */
    add(value, {inline = false} = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a + b);
    }

    /**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false] - If true, applies subtraction to the element, otherwise it creates first a copy and applies the subtraction on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */
    sub(value, { inline = false } = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a - b);
    }

    /**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */
    get shape() {
        return [this._rows, this._cols];
    }

    /**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */
    set shape([rows, cols, value = () => 0]) {
        this._rows = rows;
        this._cols = cols;
        this._data = new Float64Array(rows * cols);
        for (let row = 0; row < rows; ++row) {
            for (let col = 0; col < cols; ++col) {
                this._data[row * cols + col] = value(row, col);
            }
        }
        return this;
    }

    /**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array<Float64Array>}
     */
    get to2dArray() {
        const result = [];
        for (const row of this.iterate_rows()) {
            result.push(row);
        }
        return result;
    }

    /**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array<Array>}
     */
    get asArray() {
        const result = [];
        for (const row of this.iterate_rows()) {
            result.push(Array.from(row));
        }
        return result;
    }

    /**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */
    get diag() {
        const rows = this._rows;
        const cols = this._cols;
        const min_row_col = Math.min(rows, cols);
        let result = new Float64Array(min_row_col);
        for (let i = 0; i < min_row_col; ++i) {
            result[i] = this.entry(i, i);
        }
        return result;
    }

    /**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */
    get mean() {
        const sum = this.sum;
        const n = this._rows * this._cols;
        return sum / n;
    }

    /**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */
    get sum() {
        const data = this.values;
        return neumair_sum(data);
    }

    /**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Float64Array}
     */
    get values() {
        const data = this._data;
        return data;
    }

    /**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */
    get meanRows() {
        const data = this.values;
        const rows = this._rows;
        const cols = this._cols;
        const result = Float64Array.from({ length: rows });
        for (let row = 0; row < rows; ++row) {
            result[row] = 0;
            for (let col = 0; col < cols; ++col) {
                result[row] += data[row * cols + col];
            }
            result[row] /= cols;
        }
        return result;
    }

    /** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */
    get meanCols() {
        const data = this.values;
        const rows = this._rows;
        const cols = this._cols;
        const result = Float64Array.from({ length: cols });
        for (let col = 0; col < cols; ++col) {
            result[col] = 0;
            for (let row = 0; row < rows; ++row) {
                result[col] += data[row * cols + col];
            }
            result[col] /= rows;
        }
        return result;
    }

    /**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */
    static solve_CG(A, b, randomizer, tol = 1e-3) {
        if (randomizer === null) {
            randomizer = new Randomizer();
        }
        const rows = A.shape[0];
        const cols = b.shape[1];
        let result = new Matrix(rows, 0);
        for (let i = 0; i < cols; ++i) {
            const b_i = Matrix.from(b.col(i)).T;
            let x = new Matrix(rows, 1, () => randomizer.random);
            let r = b_i.sub(A.dot(x));
            let d = r.clone();
            do {
                const z = A.dot(d);
                const alpha = r.T.dot(r).entry(0, 0) / d.T.dot(z).entry(0, 0);
                x = x.add(d.mult(alpha));
                const r_next = r.sub(z.mult(alpha));
                const beta = r_next.T.dot(r_next).entry(0, 0) / r.T.dot(r).entry(0, 0);
                d = r_next.add(d.mult(beta));
                r = r_next;
            } while (Math.abs(r.mean) > tol);
            result = result.concat(x, "horizontal");
        }
        return result;
    }

    /**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */
    static solve(A, b) {
        let { L: L, U: U } = "L" in A && "U" in A ? A : Matrix.LU(A);
        let rows = L.shape[0];
        let x = b.clone();

        // forward
        for (let row = 0; row < rows; ++row) {
            for (let col = 0; col < row - 1; ++col) {
                x.set_entry(0, row, x.entry(0, row) - L.entry(row, col) * x.entry(1, col));
            }
            x.set_entry(0, row, x.entry(0, row) / L.entry(row, row));
        }

        // backward
        for (let row = rows - 1; row >= 0; --row) {
            for (let col = rows - 1; col > row; --col) {
                x.set_entry(0, row, x.entry(0, row) - U.entry(row, col) * x.entry(0, col));
            }
            x.set_entry(0, row, x.entry(0, row) / U.entry(row, row));
        }

        return x;
    }

    /**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */
    static LU(A) {
        const rows = A.shape[0];
        const L = new Matrix(rows, rows, "zeros");
        const U = new Matrix(rows, rows, "identity");

        for (let j = 0; j < rows; ++j) {
            for (let i = j; i < rows; ++i) {
                let sum = 0;
                for (let k = 0; k < j; ++k) {
                    sum += L.entry(i, k) * U.entry(k, j);
                }
                L.set_entry(i, j, A.entry(i, j) - sum);
            }
            for (let i = j; i < rows; ++i) {
                if (L.entry(j, j) === 0) {
                    return undefined;
                }
                let sum = 0;
                for (let k = 0; k < j; ++k) {
                    sum += L.entry(j, k) * U.entry(k, i);
                }
                U.set_entry(j, i, (A.entry(j, i) - sum) / L.entry(j, j));
            }
        }

        return { L: L, U: U };
    }

    /**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */
    static det(A) {
        const rows = A.shape[0];
        const { L, U } = Matrix.LU(A);
        const L_diag = L.diag;
        const U_diag = U.diag;
        let det = L_diag[0] * U_diag[0];
        for (let row = 1; row < rows; ++row) {
            det *= L_diag[row] * U_diag[row];
        }
        return det;
    }

    /**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */
    static SVD(M, k = 2) {
        const MT = M.T;
        let MtM = MT.dot(M);
        let MMt = M.dot(MT);
        let { eigenvectors: V, eigenvalues: Sigma } = simultaneous_poweriteration(MtM, k);
        let { eigenvectors: U } = simultaneous_poweriteration(MMt, k);
        return { U: U, Sigma: Sigma.map((sigma) => Math.sqrt(sigma)), V: V };

        //Algorithm 1a: Householder reduction to bidiagonal form:
        /* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */
    }
}

/**
 * @class
 * @memberof module:utils
 * @alias Randomizer
 */
class Randomizer {
    /**
     * Mersenne Twister random number generator.
     * @constructor
     * @param {Number} [_seed=new Date().getTime()] - The seed for the random number generator. If <code>_seed == null</code> then the actual time gets used as seed.
     * @see https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js
     */
    constructor(_seed) {
        this._N = 624;
        this._M = 397;
        this._MATRIX_A = 0x9908b0df;
        this._UPPER_MASK = 0x80000000;
        this._LOWER_MASK = 0x7fffffff;
        this._mt = new Array(this._N);
        this._mti = this.N + 1;

        this.seed = _seed || new Date().getTime();
        return this;
    }

    set seed(_seed) {
        this._seed = _seed;
        let mt = this._mt;

        mt[0] = _seed >>> 0;
        for (this._mti = 1; this._mti < this._N; this._mti += 1) {
            let mti = this._mti;
            let s = mt[mti - 1] ^ (mt[mti - 1] >>> 30);
            mt[mti] = ((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253 + mti;
            mt[mti] >>>= 0;
        }
    }

    /**
     * Returns the seed of the random number generator.
     * @returns {Number} - The seed.
     */
    get seed() {
        return this._seed;
    }

    /**
     * Returns a float between 0 and 1.
     * @returns {Number} - A random number between [0, 1]
     */
    get random() {
        return this.random_int * (1.0 / 4294967296.0);
    }

    /**
     * Returns an integer between 0 and MAX_INTEGER.
     * @returns {Integer} - A random integer.
     */
    get random_int() {
        let y,
            mag01 = new Array(0x0, this._MATRIX_A);
        if (this._mti >= this._N) {
            let kk;

            /* if (this._mti == this._N + 1) {
                this.seed = 5489;
            } */

            let N_M = this._N - this._M;
            let M_N = this._M - this._N;

            for (kk = 0; kk < N_M; ++kk) {
                y = (this._mt[kk] & this._UPPER_MASK) | (this._mt[kk + 1] & this._LOWER_MASK);
                this._mt[kk] = this._mt[kk + this._M] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            for (; kk < this._N - 1; ++kk) {
                y = (this._mt[kk] & this._UPPER_MASK) | (this._mt[kk + 1] & this._LOWER_MASK);
                this._mt[kk] = this._mt[kk + M_N] ^ (y >>> 1) ^ mag01[y & 0x1];
            }

            y = (this._mt[this._N - 1] & this._UPPER_MASK) | (this._mt[0] & this._LOWER_MASK);
            this._mt[this._N - 1] = this._mt[this._M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];

            this._mti = 0;
        }

        y = this._mt[(this._mti += 1)];
        y ^= y >>> 11;
        y ^= (y << 7) & 0x9d2c5680;
        y ^= (y << 15) & 0xefc60000;
        y ^= y >>> 18;

        return y >>> 0;
    }

    /**
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */
    choice(A, n) {
        if (A instanceof Matrix) {
            let rows = A.shape[0];
            if (n > rows) {
                throw new Error("n bigger than A!");
            }
            let sample = new Array(n);
            let index_list = linspace(0, rows - 1);
            for (let i = 0, l = index_list.length; i < n; ++i, --l) {
                let random_index = this.random_int % l;
                sample[i] = index_list.splice(random_index, 1)[0];
            }
            return sample.map((d) => A.row(d));
        } else if (Array.isArray(A) || A instanceof Float64Array) {
            let rows = A.length;
            if (n > rows) {
                throw new Error("n bigger than A!");
            }
            let sample = new Array(n);
            let index_list = linspace(0, rows - 1);
            for (let i = 0, l = index_list.length; i < n; ++i, --l) {
                let random_index = this.random_int % l;
                sample[i] = index_list.splice(random_index, 1)[0];
            }
            return sample.map((d) => A[d]);
        }
    }

    /**
     * @static
     * Returns samples from an input Matrix or Array.
     * @param {Matrix|Array|Float64Array} A - The input Matrix or Array.
     * @param {Number} n - The number of samples.
     * @param {Number} seed - The seed for the random number generator.
     * @returns {Array} - A random selection form {@link A} of {@link n} samples.
     */
    static choice(A, n, seed = 1212) {
        const R = new Randomizer(seed);
        return R.choice(A, n);
        /* let rows = A.shape[0];
        if (n > rows) {
            throw new Error("n bigger than A!");
        }
        let rand = new Randomizer(seed);
        let sample = new Array(n);
        let index_list = linspace(0, rows - 1);
        for (let i = 0, l = index_list.length; i < n; ++i, --l) {
            let random_index = rand.random_int % l;
            sample[i] = index_list.splice(random_index, 1)[0];
        }
        //return result;
        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))
        return sample.map((d) => A.row(d)); */
    }
}

/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias max
 * @param {Array} values 
 * @returns {Number}
 */
function max (values) {
    let max;
    for (const value of values) {
        if (value != null && (max < value || (max === undefined && value >= value))) {
            max = value;
        }
    }
    return max;
}

/**
 * Returns maximum in Array {@link values}.
 * @memberof module:utils
 * @alias min
 * @param {Array} values
 * @returns {Number}
 */
function min (values) {
    let min;
    for (const value of values) {
        if (value != null && (min > value || (min === undefined && value <= value))) {
            min = value;
        }
    }
    return min;
}

/**
 * @class
 * @alias Heap
 */
class Heap {
    /**
     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.
     * @constructor
     * @memberof module:datastructure
     * @alias Heap
     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.
     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.
     * @param {("min"|"max"|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}
     */
    constructor(elements = null, accessor = d => d, comparator = "min") {
        if (elements) {
            return Heap.heapify(elements, accessor, comparator);
        } else {
            this._accessor = accessor;
            this._container = [];
            if (comparator == "min") {
                this._comparator = (a, b) => a < b;
            } else if (comparator == "max") {
                this._comparator = (a, b) => a > b;
            } else {
                this._comparator = comparator;
            }
            return this
        }
    }

    /**
     * Creates a Heap from an Array
     * @param {Array|Set} elements - Contains the elements for the Heap.
     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.
     * @param {(String=|Function)} [comparator = "min"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. ("min" for a Min-Heap, "max" for a Max_heap)
     * @returns {Heap}
     */
    static heapify(elements, accessor = d => d, comparator = "min") {
        const heap = new Heap(null, accessor, comparator);
        const container = heap._container;
        for (const e of elements) {
            container.push({
                "element": e,
                "value": accessor(e),
            });
        }
        for (let i = Math.floor((elements.length / 2) - 1); i >= 0; --i) {
            heap._heapify_down(i);
        }
        return heap;
    }

    /**
     * Swaps elements of container array.
     * @private
     * @param {Number} index_a 
     * @param {Number} index_b 
     */
    _swap(index_a, index_b) {
        const container = this._container;
        [container[index_b], container[index_a]] = [container[index_a], container[index_b]];
        return;
    }

    /**
     * @private
     */
    _heapify_up() {
        const container = this._container;
        let index = container.length - 1;
        while (index > 0) {
            let parentIndex = Math.floor((index - 1) / 2);
            if (!this._comparator(container[index].value, container[parentIndex].value)) {
                break;
            } else {
            this._swap(parentIndex, index);
            index = parentIndex;
            }
        }
    }

    /**
     * Pushes the element to the heap.
     * @param {} element
     * @returns {Heap}
     */
    push(element) {
        const value = this._accessor(element);
        //const node = new Node(element, value);
        const node = {"element": element, "value": value};
        this._container.push(node);
        this._heapify_up();
        return this;
    }

    /**
     * @private
     * @param {Number} [start_index = 0] 
     */
    _heapify_down(start_index=0) {
        const container = this._container;
        const comparator = this._comparator;
        const length = container.length;
        let left = 2 * start_index + 1;
        let right = 2 * start_index + 2;
        let index = start_index;
        if (index > length) throw "index higher than length"
        if (left < length && comparator(container[left].value, container[index].value)) {
            index = left;
        }
        if (right < length && comparator(container[right].value, container[index].value)) {
            index = right;
        }
        if (index !== start_index) {
            this._swap(start_index, index);
            this._heapify_down(index);
        }
    }

    /**
     * Removes and returns the top entry of the heap.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */
    pop() {
        const container = this._container;
        if (container.length === 0) {
            return null;
        } else if (container.length === 1) {
            return container.pop();
        }
        this._swap(0, container.length - 1);
        const item = container.pop();
        this._heapify_down();
        return item;
    }

    /**
     * Returns the top entry of the heap without removing it.
     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).
     */
    get first() {
        return this._container.length > 0 ? this._container[0] : null;
    }


    /**
     * Yields the raw data
     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).
     */
    * iterate() {
        for (let i = 0, n = this._container.length; i < n; ++i) {
            yield this._container[i].element;
        }
    }

    /**
     * Returns the heap as ordered array.
     * @returns {Array} Array consisting the elements ordered by {@link comparator}.
     */
    toArray() {
        return this.data()
            .sort((a,b) => this._comparator(a, b) ? -1 : 0)
    }

    /**
     * Returns elements of container array.
     * @returns {Array} Array consisting the elements.
     */
    data() {
        return this._container
            .map(d => d.element)
    }

    /**
     * Returns the container array.
     * @returns {Array} The container array.
     */
    raw_data() {
        return this._container;
    }

    /**
     * The size of the heap.
     * @returns {Number}
     */
    get length() {
        return this._container.length;
    }

    /**
     * Returns false if the the heap has entries, true if the heap has no entries.
     * @returns {Boolean}
     */
    get empty() {
        return this.length === 0;
    }
}

/**
 * @class
 * @alias DisjointSet
 * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}
 */
class DisjointSet {
    /**
     * @constructor
     * @alias DisjointSet
     * @memberof module:datastructure
     * @param {Array=} elements 
     * @returns {DisjointSet}
     */
    constructor(elements = null) {
        this._list = new Set();
        if (elements) {
            for (const e of elements) {
                this.make_set(e);
            }
        }
        return this;
    }

    make_set(x) {
        const list = this._list;
        if (!list.has(x)) {
            list.add(x);
            x.__disjoint_set = {};
            x.__disjoint_set.parent = x;
            x.__disjoint_set.children = new Set([x]);
            x.__disjoint_set.size = 1;
        }
        return this;
    }

    find(x) {
        const list = this._list;
        if (list.has(x)) {
            if (x.__disjoint_set.parent !== x) {
                x.__disjoint_set.children.add(...x);
                x.__disjoint_set.parent = this.find(x.__disjoint_set.parent);
                return x.__disjoint_set.parent;
            } else {
                return x;
            }
        } else {
            return null;
        }
    }

    union(x, y) {
        let node_x = this.find(x);
        let node_y = this.find(y);

        if (node_x === node_y) return this;
        if (node_x.__disjoint_set.size < node_y.__disjoint_set.size) [node_x, node_y] = [node_y, node_x];

        node_y.__disjoint_set.parent = node_x;
        // keep track of children?
        node_y.__disjoint_set.children.forEach(node_x.__disjoint_set.children.add, node_x.__disjoint_set.children);
        node_x.__disjoint_set.size += node_y.__disjoint_set.size;

        return this;
    }
}

/**
 * @class
 * @alias BallTree
 */
class BallTree {
    /**
     * Generates a BallTree with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias BallTree
     * @param {Array=} elements - Elements which should be added to the BallTree
     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance
     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}
     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}
     * @returns {BallTree}
     */
    constructor(elements = null, metric = euclidean) {
        this._Node = class {
            constructor(pivot, child1=null, child2=null, radius=null) {
                this.pivot = pivot;
                this.child1 = child1;
                this.child2 = child2;
                this.radius = radius;
            }
        };
        this._Leaf = class {
            constructor(points) {
                this.points = points;
            }
        };
        this._metric = metric;
        if (elements) {
            this.add(elements);
        }
        return this;
    }

    /**
     * 
     * @param {Array<*>} elements - new elements.
     * @returns {BallTree}
     */
    add(elements) {
        elements = elements.map((element, index) => {
            return {index: index, element: element}
        });
        this._root = this._construct(elements);
        return this;
    }

    /**
     * @private
     * @param {Array<*>} elements 
     * @returns {Node} root of balltree.
     */
    _construct(elements) {
        if (elements.length === 1) {
            return new this._Leaf(elements);
        } else {
            let c = this._greatest_spread(elements);
            let sorted_elements = elements.sort((a, b) => a.element[c] - b.element[c]);
            let n = sorted_elements.length;
            let p_index = Math.floor(n / 2);
            let p = elements[p_index];
            let L = sorted_elements.slice(0, p_index);
            let R = sorted_elements.slice(p_index, n);
            let radius = Math.max(...elements.map(d => this._metric(p.element, d.element)));
            let B;
            if (L.length > 0 && R.length > 0) {         
                B = new this._Node(p, this._construct(L), this._construct(R), radius);
            } else {
                B = new this._Leaf(elements);
            }
            return B;
        }
    }

    /**
     * @private
     * @param {Node} B 
     * @returns {Number}
     */
    _greatest_spread(B) {
        let d = B[0].element.length;
        let start = new Array(d);

        for (let i = 0; i < d; ++i) {
            start[i] = [Infinity, -Infinity];
        }

        let spread = B.reduce((acc, current) => {
            for (let i = 0; i < d; ++i) {
                acc[i][0] = Math.min(acc[i][0], current.element[i]);
                acc[i][1] = Math.max(acc[i][1], current.element[i]);
            }
            return acc;
        }, start);
        spread = spread.map(d => d[1] - d[0]);
        
        let c = 0;
        for (let i = 0; i < d; ++i) {
            c = spread[i] > spread[c] ? i : c;
        }
        return c;
    }

    /**
     * 
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */
    search(t, k = 5) {
        return this._search(t, k, new Heap(null, d => this._metric(d.element, t), "max"), this._root);
    }

    /**
     * @private
     * @param {*} t - query element.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.
     * @param {Node|Leaf} B 
     */
    _search(t, k, Q, B) {
        // B is Node
        if (Q.length >= k && B.pivot && B.radius && this._metric(t, B.pivot.element) - B.radius >= Q.first.value) {
            return Q;
        } 
        if (B.child1) this._search(t, k, Q, B.child1);
        if (B.child2) this._search(t, k, Q, B.child2);
        
        // B is leaf
        if (B.points) {
            for (let i = 0, n = B.points.length; i < n; ++i) {
                let p = B.points[i];
                if (k > Q.length) {
                    Q.push(p);
                } else {
                    Q.push(p);
                    Q.pop();
                }
            }
        }
        return Q;
    }
}

/**
 * @class
 * @alias KNN
 */
class KNN {
    /**
     * Generates a KNN list with given {@link elements}.
     * @constructor
     * @memberof module:knn
     * @alias KNN
     * @param {Array=} elements - Elements which should be added to the KNN list
     * @param {Function|"precomputed"} [metric = euclidean] metric is either precomputed or a function to use: (a, b) => distance
     * @returns {KNN}
     */
    constructor(elements=null, metric=euclidean) {
        this._metric = metric;
        this._elements = elements instanceof Matrix ? elements : Matrix.from(elements);
        const N = this._elements.shape[0];
        if (metric === "precomputed") {
            this._D = this._elements.clone();
        } else {
            this._D = distance_matrix(this._elements, metric);
        }
        this.KNN = [];
        for (let row = 0; row < N; ++row) {
            const distances = this._D.row(row);
            const H = new Heap(null, d => d.value, "min");
            for (let j = 0; j < N; ++j) {
                H.push({
                    value: distances[j],
                    index: j,
                });
            }
            this.KNN.push(H);
        }
    }

    /**
     * 
     * @param {Array|Number} t - query element or index.
     * @param {Number} [k = 5] - number of nearest neighbors to return.
     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.
     */
    search(t, k = 5) {
        const metric = this._metric;
        const KNN = this.KNN;
        let H;
        if (Array.isArray(t)) {
            if (this._metric == "precomputed") {
                throw "Search by query element is only possible when not using a precomputed distance matrix!"
            } 
            const elements = this._elements;
            const N = KNN.length;
            let nearest_element_index = null;
            let nearest_dist = Infinity;
            for (let i = 0; i < N; ++i) {
                const element = elements.row(i);
                const dist = metric(t, element);
                if (dist < nearest_dist) {
                    nearest_element_index = i;
                    nearest_dist = dist;
                }
            }
            H = KNN[nearest_element_index];
        } else if (Number.isInteger(t)) {
            H = KNN[t];
        }

        let result = [];
        for (let i = 0; i < k; ++i) {
            result.push(H.pop());
        }
        result.forEach(res => H.push(res.element));
        return result
    }    
}

/**
 * @class
 * @alias DR
 * @borrows DR#parameter as DR#para
 * @borrows DR#parameter as DR#p
 */
class DR {
    /**
     * Takes the default parameters and seals them, remembers the type of input {@link X}, and initializes the random number generator.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias DR
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed value for the random number generator.
     * @returns {DR}
     */
    constructor(X, default_parameters, parameters) {
        this._parameters = Object.assign(Object.seal(default_parameters), parameters);
        if (Array.isArray(X)) {
            this._type = "array";
            this.X = Matrix.from(X);
        } else if (X instanceof Matrix) {
            this._type = "matrix";
            this.X = X;
        } else {
            throw new Error("No valid type for X!");
        }
        [this._N, this._D] = this.X.shape;
        this._randomizer = new Randomizer(this._parameters.seed);
        this._is_initialized = false;
        return this;
    }

    /**
     * Set and get parameters
     * @param {String} [name = null] - Name of the parameter. If not given then returns all parameters as an Object.
     * @param {any} [value = null] - Value of the parameter to set. If <code>name</code> is set and <code>value</code> is not given, returns the value of the respective parameter.
     * @returns {DR|any|Object} 
     * On setting a parameter, this function returns the DR object. 
     * If <code>name</code> is set and <code>value == null</code> then return actual parameter value.
     * If <code>name</code> is not given, then returns all parameters as an Object.
     * 
     * @example
     * '''
     * const DR = new druid.TSNE(X, {d: 3}); // creates a new DR object, with parameter for <code>d</code> = 3.
     * DR.parameter("d"); // returns 3,
     * DR.parameter("d", 2); // sets parameter <code>d</code> to 2 and returns <code>DR</code>.
     * '''
     */
    parameter(name = null, value = null) {
        if (name === null) {
            return Object.assign({}, this._parameters);
        }
        if (!this._parameters.hasOwnProperty(name)) {
            throw new Error(`${name} is not a valid parameter!`);
        }
        if (value !== null) {
            this._parameters[name] = value;
            this._is_initialized = false;
            return this;
        } else {
            return this._parameters[name];
        }
    }

    para(name = null, value = null) {
        return this.parameter(name, value);
    }

    p(name = null, value = null) {
        return this.parameter(name, value);
    }

    /**
     * Computes the projection.
     * @returns {Matrix} the projection.
     */
    transform() {
        this.check_init();
        return this.projection;
    }

    /**
     * Computes the projection.
     * @yields {Matrix|Number[][]} the intermediate steps of the projection.
     */
    *generator() {
        return this.transform();
    }

    /**
     * If the respective DR method has an <code>init</code> function, call it before <code>transform</code>.
     * @returns {DR}
     */
    check_init() {
        if (!this._is_initialized && typeof this.init === "function") {
            this.init();
            this._is_initialized = true;
        }
        return this;
    }

    /**
     * @returns {Matrix|Number[][]} the projection in the type of input <code>X</code>.
     */
    get projection() {
        if (this.hasOwnProperty("Y")) {
            this.check_init();
            return this._type === "matrix" ? this.Y : this.Y.to2dArray;
        } else {
            throw new Error("The dataset is not transformed yet!");
        }
    }

    /**
     * Computes the projection.
     * @param  {...unknown} args - Arguments the transform method of the respective DR method takes.
     * @returns {Promise<Matrix|Number[][]>} the dimensionality reduced dataset.
     */
    async transform_async(...args) {
        return this.transform(...args);
    }

    /**
     * Computes the projection.
     * @static
     * @param  {...unknown} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Matrix|Array} the dimensionality reduced dataset.
     */
    static transform(...args) {
        let dr = new this(...args);
        return dr.transform();
    }

    /**
     * Computes the projection.
     * @static
     * @param  {...unknown} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Promise} a promise yielding the dimensionality reduced dataset.
     */
    static async transform_async(...args) {
        return this.transform(...args);
    }

    /**
     * Computes the projection.
     * @static
     * @param  {...unknown} args - Takes the same arguments of the constructor of the respective DR method.
     * @returns {Generator} a generator yielding the intermediate steps of the dimensionality reduction method.
     */
    static *generator(...args) {
        const dr = new this(...args);
        const generator = dr.generator();
        for (const result of generator) {
            yield result;
        }
    }
}

/**
 * @class
 * @alias PCA
 * @augments DR
 */
class PCA extends DR {
    /**
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias PCA
     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @returns {PCA}
     */
    constructor(X, parameters) {
        super(X, { d: 2, seed: 1212, eig_args: {} }, parameters);
        if (!this._parameters.eig_args.hasOwnProperty("seed")) {
            this._parameters.eig_args.seed = this._randomizer;
        }
        return this;
    }

    /**
     * Transforms the inputdata {@link X} to dimensionality {@link d}. If parameter {@link A} is given, then project {@link A} with the principal components of {@link X}.
     * @param {null|Matrix|Array} [A = null] - If given, the data to project.
     * @returns {Matrix|Array} - The projected data.
     */
    transform(A = null) {
        const V = this.principal_components();
        if (A == null) {
            const X = this.X;
            this.Y = X.dot(V);
            return this.projection;
        } else if (Array.isArray(A)) {
            return Matrix.from(A).dot(V).asArray;
        } else if (A instanceof Matrix) {
            return A.dot(V);
        } else {
            throw new Error("No valid type for A!");
        }
    }

    /**
     * Computes the {@link d} principal components of Matrix {@link X}.
     * @returns {Matrix}
     */
    principal_components() {
        if (this.V) {
            return this.V;
        }
        const { d, eig_args } = this._parameters;
        const X = this.X;
        const means = Matrix.from(X.meanCols);
        const X_cent = X.sub(means);
        const C = X_cent.transpose().dot(X_cent);
        const { eigenvectors: V } = simultaneous_poweriteration(C, d, eig_args);
        this.V = Matrix.from(V).transpose();
        return this.V;
    }

    static principal_components(X, parameters) {
        const dr = new this(X, parameters);
        return dr.principal_components();
    }
}

/**
 * @class
 * @alias MDS
 * @extends DR
 */
class MDS extends DR {
    /**
     * Classical MDS.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias MDS
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     */
    constructor(X, parameters) {
        super(X, { d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);
        if (!this._parameters.eig_args.hasOwnProperty("seed")) {
            this._parameters.eig_args.seed = this._randomizer;
        }
        return this;
    }

    /**
     * Transforms the inputdata {@link X} to dimensionality {@link d}.
     * @returns {Matrix|Array}
     */
    transform() {
        const X = this.X;
        const rows = X.shape[0];
        const { d, metric, eig_args } = this._parameters;
        const A = metric === "precomputed" ? X : distance_matrix(X, metric);
        const ai_ = A.meanCols;
        const a_j = A.meanRows;
        const a__ = A.mean;

        this._d_X = A;
        const B = new Matrix(rows, rows, (i, j) => A.entry(i, j) - ai_[i] - a_j[j] + a__);

        const { eigenvectors: V } = simultaneous_poweriteration(B, d, eig_args);
        this.Y = Matrix.from(V).transpose();

        return this.projection;
    }

    /**
     * @returns {Number} - the stress of the projection.
     */
    stress() {
        const N = this.X.shape[0];
        const Y = this.Y;
        const d_X = this._d_X;
        const d_Y = new Matrix();
        d_Y.shape = [
            N,
            N,
            (i, j) => {
                return i < j ? euclidean(Y.row(i), Y.row(j)) : d_Y.entry(j, i);
            },
        ];
        let top_sum = 0;
        let bottom_sum = 0;
        for (let i = 0; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                top_sum += Math.pow(d_X.entry(i, j) - d_Y.entry(i, j), 2);
                bottom_sum += Math.pow(d_X.entry(i, j), 2);
            }
        }
        return Math.sqrt(top_sum / bottom_sum);
    }
}

/**
 * @class
 * @alias ISOMAP
 * @extends DR
 */
class ISOMAP extends DR {
    /**
     * Isometric feature mapping (ISOMAP).
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias ISOMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link ISOMAP} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2319}
     */
    constructor(X, parameters) {
        super(X, { neighbors: undefined, d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);
        this.parameter("neighbors", Math.min(LOR(this._parameters.neighbors , Math.max(Math.floor(this.X.shape[0] / 10), 2)), this._N - 1));
        if (!this._parameters.eig_args.hasOwnProperty("seed")) {
            this._parameters.eig_args.seed = this._randomizer;
        }
        return this;
    }

    /**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */
    transform() {
        this.check_init();
        const X = this.X;
        const rows = this._N;
        const { d, metric, eig_args, neighbors } = this._parameters;
        // TODO: make knn extern and parameter for constructor or transform?
        const D = new Matrix();
        D.shape = [rows, rows, (i, j) => (i <= j ? metric(X.row(i), X.row(j)) : D.entry(j, i))];
        const kNearestNeighbors = [];
        for (let i = 0; i < rows; ++i) {
            const row = [];
            for (let j = 0; j < rows; ++j) {
                row.push({
                    index: j,
                    distance: D.entry(i, j),
                });
            }
            const H = new Heap(row, (d) => d.distance, "min");
            kNearestNeighbors.push(H.toArray().slice(1, neighbors + 1));
        }

        /*D = dijkstra(kNearestNeighbors);*/
        // compute shortest paths
        // TODO: make extern
        /** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */
        const G = new Matrix(rows, rows, (i, j) => {
            const other = kNearestNeighbors[i].find((n) => n.index === j);
            return other ? other.distance : Infinity;
        });

        for (let i = 0; i < rows; ++i) {
            for (let j = 0; j < rows; ++j) {
                for (let k = 0; k < rows; ++k) {
                    G.set_entry(i, j, Math.min(G.entry(i, j), G.entry(i, k) + G.entry(k, j)));
                }
            }
        }

        let ai_ = new Float64Array(rows);
        let a_j = new Float64Array(rows);
        let a__ = 0;
        const A = new Matrix(rows, rows, (i, j) => {
            let val = G.entry(i, j);
            val = val === Infinity ? 0 : val;
            ai_[i] += val;
            a_j[j] += val;
            a__ += val;
            return val;
        });

        ai_ = ai_.map((v) => v / rows);
        a_j = a_j.map((v) => v / rows);
        a__ /= rows ** 2;
        const B = new Matrix(rows, rows, (i, j) => A.entry(i, j) - ai_[i] - a_j[j] + a__);

        // compute d eigenvectors
        const { eigenvectors: V } = simultaneous_poweriteration(B, d, eig_args);
        this.Y = Matrix.from(V).transpose();
        // return embedding
        return this.projection;
    }
}

/**
 * @class
 * @alias FASTMAP
 * @extends DR
 */
class FASTMAP extends DR {
    /**
     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias FASTMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the dimensionality of the projection.
     * @returns {FASTMAP}
     * @see {@link https://doi.org/10.1145/223784.223812}
     */
    constructor(X, parameters) {
        super(X, { d: 2, metric: euclidean, seed: 1212 }, parameters);
        return this;
    }

    /**
     * Chooses two points which are the most distant in the actual projection.
     * @private
     * @param {Function} dist
     * @returns {Array} An array consisting of first index, second index, and distance between the two points.
     */
    _choose_distant_objects(dist) {
        const X = this.X;
        const N = X.shape[0];
        let a_index = (this._randomizer.random_int % N) - 1;
        let b_index = null;
        let max_dist = -Infinity;
        for (let i = 0; i < N; ++i) {
            const d_ai = dist(a_index, i);
            if (d_ai > max_dist) {
                max_dist = d_ai;
                b_index = i;
            }
        }
        max_dist = -Infinity;
        for (let i = 0; i < N; ++i) {
            const d_bi = dist(b_index, i);
            if (d_bi > max_dist) {
                max_dist = d_bi;
                a_index = i;
            }
        }
        return [a_index, b_index, max_dist];
    }

    /**
     * Computes the projection.
     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.
     */
    transform() {
        const X = this.X;
        const N = X.shape[0];
        const { d, metric } = this._parameters;
        const Y = new Matrix(N, d, 0);
        let dist = (a, b) => metric(X.row(a), X.row(b));

        for (let _col = 0; _col < d; ++_col) {
            let old_dist = dist;
            // choose pivot objects
            const [a_index, b_index, d_ab] = this._choose_distant_objects(dist);
            if (d_ab !== 0) {
                // project the objects on the line (O_a, O_b)
                for (let i = 0; i < N; ++i) {
                    const d_ai = dist(a_index, i);
                    const d_bi = dist(b_index, i);
                    const y_i = (d_ai ** 2 + d_ab ** 2 - d_bi ** 2) / (2 * d_ab);
                    Y.set_entry(i, _col, y_i);
                }
                // consider the projections of the objects on a
                // hyperplane perpendicluar to the line (a, b);
                // the distance function D'() between two
                // projections is given by Eq.4
                dist = (a, b) => Math.sqrt(old_dist(a, b) ** 2 - (Y.entry(a, _col) - Y.entry(b, _col)) ** 2);
            }
        }
        // return embedding.
        this.Y = Y;
        return this.projection;
    }
}

/**
 * @class
 * @alias LDA
 * @extends DR
 */
class LDA extends DR {
    /**
     * Linear Discriminant Analysis.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LDA
     * @param {Matrix} X - The high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Array} parameters.labels - The labels / classes for each data point.
     * @param {number} [parameters.d = 2] - The dimensionality of the projection.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://onlinelibrary.wiley.com/doi/10.1111/j.1469-1809.1936.tb02137.x}
     */
    constructor(X, parameters) {
        super(X, { labels: null, d: 2, seed: 1212, eig_args: {} }, parameters);
        if (!this._parameters.eig_args.hasOwnProperty("seed")) {
            this._parameters.eig_args.seed = this._randomizer;
        }
        return this;
    }

    /**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */
    transform() {
        const X = this.X;
        const [rows, cols] = X.shape;
        const { d, labels, eig_args } = this._parameters;
        if (labels === null || labels.length != rows) {
            throw new Error("LDA needs parameter label to every datapoint to work!");
        }
        const unique_labels = {};
        let label_id = 0;
        labels.forEach((l, i) => {
            if (l in unique_labels) {
                unique_labels[l].count++;
                unique_labels[l].rows.push(X.row(i));
            } else {
                unique_labels[l] = {
                    id: label_id++,
                    count: 1,
                    rows: [X.row(i)],
                };
            }
        });

        // create X_mean and vector means;
        const X_mean = X.mean;
        const V_mean = new Matrix(label_id, cols);
        for (const label in unique_labels) {
            const V = Matrix.from(unique_labels[label].rows);
            const v_mean = V.meanCols;
            for (let j = 0; j < cols; ++j) {
                V_mean.set_entry(unique_labels[label].id, j, v_mean[j]);
            }
        }
        // scatter_between
        let S_b = new Matrix(cols, cols);
        for (const label in unique_labels) {
            const v = V_mean.row(unique_labels[label].id);
            const m = new Matrix(cols, 1, (j) => v[j] - X_mean);
            const N = unique_labels[label].count;
            S_b = S_b.add(m.dot(m.transpose()).mult(N));
        }

        // scatter_within
        let S_w = new Matrix(cols, cols);
        for (const label in unique_labels) {
            const v = V_mean.row(unique_labels[label].id);
            const m = new Matrix(cols, 1, (j) => v[j]);
            const R = unique_labels[label].rows;
            for (let i = 0, n = unique_labels[label].count; i < n; ++i) {
                const row_v = new Matrix(cols, 1, (j, _) => R[i][j] - m.entry(j, 0));
                S_w = S_w.add(row_v.dot(row_v.transpose()));
            }
        }

        let { eigenvectors: V } = simultaneous_poweriteration(S_w.inverse().dot(S_b), d, eig_args);
        V = Matrix.from(V).transpose();
        this.Y = X.dot(V);

        // return embedding
        return this.projection;
    }
}

/**
 * @class
 * @alias LLE
 * @extends DR
 */
class LLE extends DR {
    /**
     * Locally Linear Embedding.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LLE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} neighbors - the label / class of each data point.
     * @param {Number} [d = 2] - the dimensionality of the projection.
     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [seed = 1212] - the dimensionality of the projection.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://doi.org/10.1126/science.290.5500.2323}
     */
    constructor(X, parameters) {
        super(X, { neighbors: undefined, d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);
        this.parameter("neighbors", Math.min(LOR(parameters.neighbors , Math.max(Math.floor(this._N / 10), 2)), this._N - 1));
        if (!this._parameters.eig_args.hasOwnProperty("seed")) {
            this._parameters.eig_args.seed = this._randomizer;
        }
        return this;
    }

    /**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */
    transform() {
        const X = this.X;
        const rows = this._N;
        const cols = this._D;
        const { neighbors, d, eig_args, metric } = this._parameters;
        const nN = k_nearest_neighbors(X, neighbors, metric);
        const O = new Matrix(neighbors, 1, 1);
        const W = new Matrix(rows, rows);

        for (let row = 0; row < rows; ++row) {
            const nN_row = nN[row];
            const Z = new Matrix(neighbors, cols, (i, j) => X.entry(nN_row[i].j, j) - X.entry(row, j));
            const C = Z.dot(Z.T);
            if (neighbors > cols) {
                const C_trace = neumair_sum(C.diag) / 1000;
                for (let j = 0; j < neighbors; ++j) {
                    C.set_entry(j, j, C.entry(j, j) + C_trace);
                }
            }
            // reconstruct;
            let w = Matrix.solve_CG(C, O, this._randomizer);
            w = w.divide(w.sum);
            for (let j = 0; j < neighbors; ++j) {
                W.set_entry(row, nN_row[j].j, w.entry(j, 0));
            }
        }
        // comp embedding
        const I = new Matrix(rows, rows, "identity");
        const IW = I.sub(W);
        const M = IW.T.dot(IW);
        const { eigenvectors: V } = simultaneous_poweriteration(M.T.inverse(), d + 1, eig_args);
        this.Y = Matrix.from(V.slice(1, 1 + d)).T;

        // return embedding
        return this.projection;
    }
}

/**
 * @class
 * @alias LTSA
 * @extends DR
 */
class LTSA extends DR {
    /**
     * Local Tangent Space Alignment
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LTSA
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} parameters.neighbors - the number of neighbors {@link LTSA} should use to project the data.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @param {Number} [parameters.eig_args] - Parameters for the eigendecomposition algorithm.
     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}
     */
    constructor(X, parameters) {
        super(X, { neighbors: undefined, d: 2, metric: euclidean, seed: 1212, eig_args: {} }, parameters);
        this.parameter("neighbors", Math.min(LOR(parameters.neighbors , Math.max(Math.floor(this._N / 10), 2)), this._N - 1));
        if (!this._parameters.eig_args.hasOwnProperty("seed")) {
            this._parameters.eig_args.seed = this._randomizer;
        }
        if (this._D <= this.parameter("d")) {
            throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter("d")})!`);
        }
        return this;
    }

    /**
     * Transforms the inputdata {@link X} to dimenionality {@link d}.
     */
    transform() {
        const X = this.X;
        const [rows, D] = X.shape;
        const { d, neighbors, metric, eig_args } = this._parameters;
        // 1.1 determine k nearest neighbors
        const nN = k_nearest_neighbors(X, neighbors, metric);
        // center matrix
        const O = new Matrix(D, D, "center");
        const B = new Matrix(rows, rows, 0);

        for (let row = 0; row < rows; ++row) {
            // 1.2 compute the d largest eigenvectors of the correlation matrix
            const I_i = [row, ...nN[row].map((n) => n.j)];
            let X_i = Matrix.from(I_i.map((n) => X.row(n)));
            // center X_i
            X_i = X_i.dot(O);
            // correlation matrix
            const C = X_i.dot(X_i.transpose());
            const { eigenvectors: g } = simultaneous_poweriteration(C, d, eig_args);
            //g.push(linspace(0, k).map(_ => 1 / Math.sqrt(k + 1)));
            const G_i_t = Matrix.from(g);
            // 2. Constructing alignment matrix
            const W_i = G_i_t.transpose()
                .dot(G_i_t)
                .add(1 / Math.sqrt(neighbors + 1));
            for (let i = 0; i < neighbors + 1; ++i) {
                for (let j = 0; j < neighbors + 1; ++j) {
                    B.set_entry(I_i[i], I_i[j], B.entry(I_i[i], I_i[j]) - (i === j ? 1 : 0) + W_i.entry(i, j));
                }
            }
        }

        // 3. Aligning global coordinates
        const { eigenvectors: Y } = simultaneous_poweriteration(B, d + 1, eig_args);
        this.Y = Matrix.from(Y.slice(1)).transpose();

        // return embedding
        return this.projection;
    }
}

/**
 * @class
 * @alias TSNE
 * @extends DR
 */
class TSNE extends DR {
    /**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TSNE
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.perplexity = 50] - perplexity.
     * @param {Number} [parameters.epsilon = 10] - learning parameter.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TSNE}
     */
    constructor(X, parameters) {
        super(X, { perplexity: 50, epsilon: 10, d: 2, metric: euclidean, seed: 1212 }, parameters);
        [this._N, this._D] = this.X.shape;
        this._iter = 0;
        this.Y = new Matrix(this._N, this.parameter("d"), () => this._randomizer.random);
        return this;
    }

    /**
     *
     * @returns {TSNE}
     */
    init() {
        // init
        const Htarget = Math.log(this.parameter("perplexity"));
        const N = this._N;
        const D = this._D;
        const {metric} = this._parameters;
        const X = this.X;
        let Delta;
        if (metric =="precomputed") {
            Delta = druid.Matrix.from(X);
        } else {
            Delta = new Matrix(N, N);
            for (let i = 0; i < N; ++i) {
                const X_i = X.row(i);
                for (let j = i + 1; j < N; ++j) {
                    const distance = metric(X_i, X.row(j));
                    Delta.set_entry(i, j, distance);
                    Delta.set_entry(j, i, distance);
                }
            }
        }

        const P = new Matrix(N, N, "zeros");

        this._ystep = new Matrix(N, D, "zeros");
        this._gains = new Matrix(N, D, 1);

        // search for fitting sigma
        let prow = new Float64Array(N);
        const tol = 1e-4;
        const maxtries = 50;
        for (let i = 0; i < N; ++i) {
            let betamin = -Infinity;
            let betamax = Infinity;
            let beta = 1;
            let done = false;

            let num = 0;
            while (!done) {
                let psum = 0;
                for (let j = 0; j < N; ++j) {
                    let pj = Math.exp(-Delta.entry(i, j) * beta);
                    if (i === j) pj = 0;
                    prow[j] = pj;
                    psum += pj;
                }
                let Hhere = 0;
                for (let j = 0; j < N; ++j) {
                    let pj = psum === 0 ? 0 : prow[j] / psum;
                    prow[j] = pj;
                    if (pj > 1e-7) {
                        Hhere -= pj * Math.log(pj);
                    }
                }
                if (Hhere > Htarget) {
                    betamin = beta;
                    beta = betamax === Infinity ? beta * 2 : (beta + betamax) / 2;
                } else {
                    betamax = beta;
                    beta = betamin === -Infinity ? beta / 2 : (beta + betamin) / 2;
                }
                ++num;
                if (Math.abs(Hhere - Htarget) < tol) done = true;
                if (num >= maxtries) done = true;
            }

            for (let j = 0; j < N; ++j) {
                P.set_entry(i, j, prow[j]);
            }
        }

        //compute probabilities
        const Pout = new Matrix(N, N, "zeros");
        const N2 = N * 2;
        for (let i = 0; i < N; ++i) {
            for (let j = i; j < N; ++j) {
                const p = Math.max((P.entry(i, j) + P.entry(j, i)) / N2, 1e-100);
                Pout.set_entry(i, j, p);
                Pout.set_entry(j, i, p);
            }
        }
        this._P = Pout;
        return this;
    }

    /**
     *
     * @param {Number} [iterations=500] - Number of iterations.
     * @returns {Matrix|Number[][]} the projection.
     */
    transform(iterations = 500) {
        this.check_init();
        for (let i = 0; i < iterations; ++i) {
            this.next();
        }
        return this.projection;
    }

    /**
     *
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Number[][]} - the projection.
     */
    *generator(iterations = 500) {
        this.check_init();
        for (let i = 0; i < iterations; ++i) {
            this.next();
            yield this.projection;
        }
        return this.projection;
    }

    /**
     * performs a optimization step
     * @private
     * @returns {Matrix}
     */
    next() {
        const iter = ++this._iter;
        const P = this._P;
        const ystep = this._ystep;
        const gains = this._gains;
        const N = this._N;
        const { d: dim, epsilon} = this._parameters;
        let Y = this.Y;

        //calc cost gradient;
        const pmul = iter < 100 ? 4 : 1;

        // compute Q dist (unnormalized)
        const Qu = new Matrix(N, N, "zeros");
        let qsum = 0;
        for (let i = 0; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dsum = 0;
                for (let d = 0; d < dim; ++d) {
                    const dhere = Y.entry(i, d) - Y.entry(j, d);
                    dsum += dhere * dhere;
                }
                const qu = 1 / (1 + dsum);
                Qu.set_entry(i, j, qu);
                Qu.set_entry(j, i, qu);
                qsum += 2 * qu;
            }
        }

        // normalize Q dist
        const Q = new Matrix(N, N, 0);
        for (let i = 0; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                const val = Math.max(Qu.entry(i, j) / qsum, 1e-100);
                Q.set_entry(i, j, val);
                Q.set_entry(j, i, val);
            }
        }

        const grad = new Matrix(N, dim, "zeros");
        for (let i = 0; i < N; ++i) {
            for (let j = 0; j < N; ++j) {
                const premult = 4 * (pmul * P.entry(i, j) - Q.entry(i, j)) * Qu.entry(i, j);
                for (let d = 0; d < dim; ++d) {
                    grad.set_entry(i, d, grad.entry(i, d) + premult * (Y.entry(i, d) - Y.entry(j, d)));
                }
            }
        }

        // perform gradient step
        let ymean = new Float64Array(dim);
        for (let i = 0; i < N; ++i) {
            for (let d = 0; d < dim; ++d) {
                const gid = grad.entry(i, d);
                const sid = ystep.entry(i, d);
                const gainid = gains.entry(i, d);

                let newgain = Math.sign(gid) === Math.sign(sid) ? gainid * 0.8 : gainid + 0.2;
                if (newgain < 0.01) newgain = 0.01;
                gains.set_entry(i, d, newgain);

                const momval = iter < 250 ? 0.5 : 0.8;
                const newsid = momval * sid - epsilon * newgain * gid;
                ystep.set_entry(i, d, newsid);

                Y.set_entry(i, d, Y.entry(i, d) + newsid);
                ymean[d] += Y.entry(i, d);
            }
        }

        for (let i = 0; i < N; ++i) {
            for (let d = 0; d < 2; ++d) {
                Y.set_entry(i, d, Y.entry(i, d) - ymean[d] / N);
            }
        }

        return this.Y;
    }
}

/**
 *
 * @memberof module:optimization
 * @alias powell
 * @param {Function} f
 * @param {Array} x0
 * @param {Number} [max_iter = 300]
 * @returns {Array}
 * @see http://optimization-js.github.io/optimization-js/optimization.js.html#line438
 */
function powell (f, x0, max_iter = 300) {
    const epsilon = 1e-2;
    const n = x0.length;
    let alpha = 1e-3;
    let pfx = 10000;
    let x = x0.slice();
    let fx = f(x);
    let convergence = false;

    while (max_iter-- >= 0 && !convergence) {
        convergence = true;
        for (let i = 0; i < n; ++i) {
            x[i] += 1e-6;
            let fxi = f(x);
            x[i] -= 1e-6;
            let dx = (fxi - fx) / 1e-6;
            if (Math.abs(dx) > epsilon) {
                convergence = false;
            }
            x[i] -= alpha * dx;
            fx = f(x);
        }
        alpha *= pfx >= fx ? 1.05 : 0.4;
        pfx = fx;
    }
    return x;
}

/**
 * @class
 * @alias UMAP
 * @extends DR
 */
class UMAP extends DR {
    /**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias UMAP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.n_neighbors = 15] - size of the local neighborhood.
     * @param {Number} [parameters.local_connectivity = 1] - number of nearest neighbors connected in the local neighborhood.
     * @param {Number} [parameters.min_dist = 1] - controls how tightly points get packed together.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points in the high-dimensional space.
     * @param {Number} [parameters._spread = 1] - The effective scale of embedded points. (In combination with {@link parameters.min_dist})
     * @param {Number} [parameters._set_op_mix_ratio = 1] - Interpolate between union and intersection.
     * @param {Number} [parameters._repulsion_strength = 1]  - Weighting applied to negative samples.
     * @param {Number} [parameters._negative_sample_rate = 5] - The number of negative samples per positive sample.
     * @param {Number} [parameters._n_epochs = 350] - The number of training epochs.
     * @param {Number} [parameter._initial_alpha = 1] - The initial learning rate for the optimization.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {UMAP}
     */
    constructor(X, parameters) {
        super(X, { n_neighbors: 15, local_connectivity: 1, min_dist: 1, d: 2, metric: euclidean, seed: 1212, _spread: 1, _set_op_mix_ratio: 1, _repulsion_strength: 1, _negative_sample_rate: 5, _n_epochs: 350, _initial_alpha: 1 }, parameters);
        [this._N, this._D] = this.X.shape;
        /* let n_neighbors = Math.min(this._N - 1, parameters.n_neighbors);
        this.parameter("n_neighbors", n_neighbors);
        this.parameter("local_connectivity", Math.min(this.parameter("local_connectivity"), n_neighbors - 1)); */
        if (this.parameter("n_neighbors") > this._N) {
            throw new Error(`Parameter n_neighbors (=${this.parameter("n_neighbors")}) needs to be smaller than dataset size (N=${this._N})!`);
        }
        if (this.parameter("local_connectivity") > this.parameter("n_neighbors")) {
            throw new Error(`Parameter local_connectivity (=${this.parameter("local_connectivity")}) needs to be smaller than parameter n_neighbors (=${this.parameter("n_neighbors")})`);
        }
        this._iter = 0;
        const randomizer = this._randomizer;
        this.Y = new Matrix(this._N, this.parameter("d"), () => randomizer.random);
        return this;
    }

    /**
     * @private
     * @param {Number} spread
     * @param {Number} min_dist
     * @returns {Array}
     */
    _find_ab_params(spread, min_dist) {
        const curve = (x, a, b) => 1 / (1 + a * Math.pow(x, 2 * b));
        const xv = linspace(0, spread * 3, 300);
        const yv = linspace(0, spread * 3, 300);

        for (let i = 0, n = xv.length; i < n; ++i) {
            const xv_i = xv[i];
            yv[i] = xv_i < min_dist ? 1 : Math.exp(-(xv_i - min_dist) / spread);
        }

        const err = (p) => {
            const error = linspace(1, 300).map((_, i) => yv[i] - curve(xv[i], p[0], p[1]));
            return Math.sqrt(neumair_sum(error.map((e) => e * e)));
        };

        return powell(err, [1, 1]);
    }

    /**
     * @private
     * @param {Array<Array>} distances
     * @param {Array<Number>} sigmas
     * @param {Array<Number>} rhos
     * @returns {Array}
     */
    _compute_membership_strengths(distances, sigmas, rhos) {
        for (let i = 0, n = distances.length; i < n; ++i) {
            for (let j = 0, m = distances[i].length; j < m; ++j) {
                const v = distances[i][j].value - rhos[i];
                distances[i][j].value = v > 0 ? Math.exp(-v / sigmas[i]) : 1;
            }
        }
        return distances;
    }

    /**
     * @private
     * @param {KNN|BallTree} knn
     * @param {Number} k
     * @returns {Object}
     */
    _smooth_knn_dist(knn, k) {
        const SMOOTH_K_TOLERANCE = 1e-5;
        const MIN_K_DIST_SCALE = 1e-3;
        const n_iter = 64;
        const { local_connectivity, metric } = this._parameters;
        const target = Math.log2(k);
        const rhos = [];
        const sigmas = [];
        const X = this.X;
        const N = X.shape[0];
        //const distances = [...X].map(x_i => knn.search(x_i, k).raw_data().reverse());

        const distances = [];
        if (metric === "precomputed") {
            for (let i = 0; i < N; ++i) {
                distances.push(knn.search(i, k).reverse());
            }
        } else {
            for (const x_i of X) {
                distances.push(knn.search(x_i, k).raw_data().reverse());
            }
        }

        for (let i = 0; i < N; ++i) {
            let lo = 0;
            let hi = Infinity;
            let mid = 1;

            const search_result = distances[i];
            const non_zero_dist = search_result.filter((d) => d.value > 0);
            const non_zero_dist_length = non_zero_dist.length;
            if (non_zero_dist_length >= local_connectivity) {
                const index = Math.floor(local_connectivity);
                const interpolation = local_connectivity - index;
                if (index > 0) {
                    rhos.push(non_zero_dist[index - 1]);
                    if (interpolation > SMOOTH_K_TOLERANCE) {
                        rhos[i].value += interpolation * (non_zero_dist[index].value - non_zero_dist[index - 1]);
                    }
                } else {
                    rhos[i].value = interpolation * non_zero_dist[0].value;
                }
            } else if (non_zero_dist_length > 0) {
                rhos[i] = non_zero_dist[non_zero_dist_length - 1].value;
            }
            for (let x = 0; x < n_iter; ++x) {
                let psum = 0;
                for (let j = 0; j < k; ++j) {
                    const d = search_result[j].value - rhos[i];
                    psum += d > 0 ? Math.exp(-(d / mid)) : 1;
                }
                if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {
                    break;
                }
                if (psum > target) {
                    [hi, mid] = [mid, (lo + hi) / 2];
                } else {
                    if (hi === Infinity) {
                        [lo, mid] = [mid, mid * 2];
                    } else {
                        [lo, mid] = [mid, (lo + hi) / 2];
                    }
                }
            }
            sigmas[i] = mid;

            const mean_ithd = search_result.reduce((a, b) => a + b.value, 0) / search_result.length;
            //let mean_d = null;
            if (rhos[i] > 0) {
                if (sigmas[i] < MIN_K_DIST_SCALE * mean_ithd) {
                    sigmas[i] = MIN_K_DIST_SCALE * mean_ithd;
                }
            } else {
                const mean_d = distances.reduce((acc, res) => acc + res.reduce((a, b) => a + b.value, 0) / res.length);
                if (sigmas[i] > MIN_K_DIST_SCALE * mean_d) {
                    sigmas[i] = MIN_K_DIST_SCALE * mean_d;
                }
            }
        }
        return {
            distances: distances,
            sigmas: sigmas,
            rhos: rhos,
        };
    }

    /**
     * @private
     * @param {Matrix} X
     * @param {Number} n_neighbors
     * @returns {Matrix}
     */
    _fuzzy_simplicial_set(X, n_neighbors) {
        const N = X.shape[0];
        const { metric, _set_op_mix_ratio } = this._parameters;
        const knn = metric === "precomputed" ? new KNN(X, "precomputed") : new BallTree(X.to2dArray, metric);
        let { distances, sigmas, rhos } = this._smooth_knn_dist(knn, n_neighbors);
        distances = this._compute_membership_strengths(distances, sigmas, rhos);
        const result = new Matrix(N, N, "zeros");
        for (let i = 0; i < N; ++i) {
            const distances_i = distances[i];
            for (let j = 0; j < distances_i.length; ++j) {
                result.set_entry(i, distances_i[j].element.index, distances_i[j].value);
            }
        }

        const transposed_result = result.T;
        const prod_matrix = result.mult(transposed_result);
        return result
            .add(transposed_result)
            .sub(prod_matrix)
            .mult(_set_op_mix_ratio)
            .add(prod_matrix.mult(1 - _set_op_mix_ratio));
    }

    /**
     * @private
     * @param {Number} n_epochs
     * @returns {Array}
     */
    _make_epochs_per_sample(n_epochs) {
        const weights = this._weights;
        const result = new Float32Array(weights.length).fill(-1);
        const weights_max = max(weights);
        const n_samples = weights.map((w) => n_epochs * (w / weights_max));
        for (let i = 0; i < result.length; ++i) if (n_samples[i] > 0) result[i] = Math.round(n_epochs / n_samples[i]);
        return result;
    }

    /**
     * @private
     * @param {Matrix} graph
     * @returns {Object}
     */
    _tocoo(graph) {
        const rows = [];
        const cols = [];
        const data = [];
        const [rows_n, cols_n] = graph.shape;
        for (let row = 0; row < rows_n; ++row) {
            for (let col = 0; col < cols_n; ++col) {
                const entry = graph.entry(row, col);
                if (entry !== 0) {
                    rows.push(row);
                    cols.push(col);
                    data.push(entry);
                }
            }
        }
        return {
            rows: rows,
            cols: cols,
            data: data,
        };
    }

    /**
     * Computes all necessary
     * @returns {UMAP}
     */
    init() {
        const { _spread, min_dist, n_neighbors, _n_epochs, _negative_sample_rate } = this._parameters;
        const [a, b] = this._find_ab_params(_spread, min_dist);
        this._a = a;
        this._b = b;
        this._graph = this._fuzzy_simplicial_set(this.X, n_neighbors);
        const { rows, cols, data: weights } = this._tocoo(this._graph);
        this._head = rows;
        this._tail = cols;
        this._weights = weights;
        this._epochs_per_sample = this._make_epochs_per_sample(_n_epochs);
        this._epochs_per_negative_sample = this._epochs_per_sample.map((d) => d * _negative_sample_rate);
        this._epoch_of_next_sample = this._epochs_per_sample.slice();
        this._epoch_of_next_negative_sample = this._epochs_per_negative_sample.slice();
        return this;
    }

    graph() {
        this.check_init();
        return { cols: this._head, rows: this._tail, weights: this._weights };
    }

    /**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */
    transform(iterations = 350) {
        if (this.parameter("_n_epochs") != iterations) {
            this.parameter("_n_epochs", iterations);
            this.init();
        }
        this.check_init();
        for (let i = 0; i < iterations; ++i) {
            this.next();
        }
        return this.projection;
    }

    /**
     *
     * @param {Number} [iterations=350] - number of iterations.
     * @returns {Matrix|Array}
     */
    *generator(iterations = 350) {
        if (this.parameter("_n_epochs") != iterations) {
            this.parameter("_n_epochs", iterations);
            this.init();
        }
        this.check_init();
        for (let i = 0; i < iterations; ++i) {
            this.next();
            yield this.projection;
        }
        return this.projection;
    }

    /**
     * @private
     * @param {Number} x
     * @returns {Number}
     */
    _clip(x) {
        if (x > 4) return 4;
        if (x < -4) return -4;
        return x;
    }

    /**
     * performs the optimization step.
     * @private
     * @param {Matrix} head_embedding
     * @param {Matrix} tail_embedding
     * @param {Matrix} head
     * @param {Matrix} tail
     * @returns {Matrix}
     */
    _optimize_layout(head_embedding, tail_embedding, head, tail) {
        const randomizer = this._randomizer;
        const { _repulsion_strength, d: dim } = this._parameters;
        const { _alpha: alpha, _a: a, _b: b, _epochs_per_sample: epochs_per_sample, _epochs_per_negative_sample: epochs_per_negative_sample, _epoch_of_next_negative_sample: epoch_of_next_negative_sample, _epoch_of_next_sample: epoch_of_next_sample, _clip: clip } = this;
        const tail_length = tail.length;

        for (let i = 0, n = epochs_per_sample.length; i < n; ++i) {
            if (epoch_of_next_sample[i] <= this._iter) {
                const j = head[i];
                const k = tail[i];
                const current = head_embedding.row(j);
                const other = tail_embedding.row(k);
                const dist = euclidean_squared(current, other);
                let grad_coeff = 0;
                if (dist > 0) {
                    grad_coeff = (-2 * a * b * Math.pow(dist, b - 1)) / (a * Math.pow(dist, b) + 1);
                }
                for (let d = 0; d < dim; ++d) {
                    const grad_d = clip(grad_coeff * (current[d] - other[d])) * alpha;
                    const c = current[d] + grad_d;
                    const o = other[d] - grad_d;
                    current[d] = c;
                    other[d] = o;
                    head_embedding.set_entry(j, d, c);
                    tail_embedding.set_entry(k, d, o);
                }
                epoch_of_next_sample[i] += epochs_per_sample[i];
                const n_neg_samples = (this._iter - epoch_of_next_negative_sample[i]) / epochs_per_negative_sample[i];
                for (let p = 0; p < n_neg_samples; ++p) {
                    const k = randomizer.random_int % tail_length;
                    const other = tail_embedding.row(tail[k]);
                    const dist = euclidean_squared(current, other);
                    let grad_coeff = 0;
                    if (dist > 0) {
                        grad_coeff = (2 * _repulsion_strength * b) / ((0.01 + dist) * (a * Math.pow(dist, b) + 1));
                    } else if (j === k) {
                        continue;
                    }
                    for (let d = 0; d < dim; ++d) {
                        const grad_d = clip(grad_coeff * (current[d] - other[d])) * alpha;
                        const c = current[d] + grad_d;
                        const o = other[d] - grad_d;
                        current[d] = c;
                        other[d] = o;
                        head_embedding.set_entry(j, d, c);
                        tail_embedding.set_entry(tail[k], d, o);
                    }
                }
                epoch_of_next_negative_sample[i] += n_neg_samples * epochs_per_negative_sample[i];
            }
        }
        return head_embedding;
    }

    /**
     * @private
     * @returns {Matrix}
     */
    next() {
        const iter = ++this._iter;
        const Y = this.Y;
        const { _initial_alpha, _n_epochs } = this._parameters;
        this._alpha = _initial_alpha * (1 - iter / _n_epochs);
        this.Y = this._optimize_layout(Y, Y, this._head, this._tail);

        return this.Y;
    }
}

/**
 * @class
 * @alias TriMap
 * @extends DR
 */
class TriMap extends DR {
    /**
     *
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TriMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.weight_adj = 500] - scaling factor.
     * @param {Number} [parameters.c = 5] - number of triplets multiplier.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Number} [parameters.tol = 1e-8] -
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TriMap}
     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}
     * @see {@link https://github.com/eamid/trimap}
     */
    constructor(X, parameters) {
        super(X, { weight_adj: 500, c: 5, d: 2, metric: euclidean, tol: 1e-8, seed: 1212 }, parameters);
        return this;
    }

    /**
     *
     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used).
     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used).
     */
    init(pca = null, knn = null) {
        const X = this.X;
        const N = X.shape[0];
        const { d, metric, c } = this._parameters;
        this.n_inliers = 2 * c;
        this.n_outliers = 1 * c;
        this.n_random = 1 * c;
        this.Y = pca || new PCA(X, d).transform();
        this.knn = knn || new BallTree(X.to2dArray, metric);
        const { triplets, weights } = this._generate_triplets(this.n_inliers, this.n_outliers, this.n_random);
        this.triplets = triplets;
        this.weights = weights;
        this.lr = (1000 * N) / triplets.shape[0];
        this.C = Infinity;
        this.vel = new Matrix(N, d, 0);
        this.gain = new Matrix(N, d, 1);
        return this;
    }

    /**
     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.
     * @param {Number} n_inliers
     * @param {Number} n_outliers
     * @param {Number} n_random
     */
    _generate_triplets(n_inliers, n_outliers, n_random) {
        const { metric, weight_adj } = this._parameters;
        const X = this.X;
        const N = X.shape[0];
        const knn = this.knn;
        const n_extra = Math.min(n_inliers + 20, N);
        const nbrs = new Matrix(N, n_extra);
        const knn_distances = new Matrix(N, n_extra);
        for (let i = 0; i < N; ++i) {
            knn.search(X.row(i), n_extra + 1)
                .raw_data()
                .filter((d) => d.value != 0)
                .sort((a, b) => a.value - b.value)
                .forEach((d, j) => {
                    nbrs.set_entry(i, j, d.element.index);
                    knn_distances.set_entry(i, j, d.value);
                });
        }
        // scale parameter
        const sig = new Float64Array(N);
        for (let i = 0; i < N; ++i) {
            sig[i] = Math.max((knn_distances.entry(i, 3) + knn_distances.entry(i, 4) + knn_distances.entry(i, 5) + knn_distances.entry(i, 6)) / 4, 1e-10);
        }

        const P = this._find_p(knn_distances, sig, nbrs);

        let triplets = this._sample_knn_triplets(P, nbrs, n_inliers, n_outliers);
        let n_triplets = triplets.shape[0];
        const outlier_distances = new Float64Array(n_triplets);
        for (let i = 0; i < n_triplets; ++i) {
            const j = triplets.entry(i, 0);
            const k = triplets.entry(i, 2);
            outlier_distances[i] = metric(X.row(j), X.row(k));
        }
        let weights = this._find_weights(triplets, P, nbrs, outlier_distances, sig);

        if (n_random > 0) {
            const { random_triplets, random_weights } = this._sample_random_triplets(X, n_random, sig);
            triplets = triplets.concat(random_triplets, "vertical");
            weights = Float64Array.from([...weights, ...random_weights]);
        }
        n_triplets = triplets.shape[0];
        let max_weight = -Infinity;
        for (let i = 0; i < n_triplets; ++i) {
            if (isNaN(weights[i])) {
                weights[i] = 0;
            }
            if (max_weight < weights[i]) max_weight = weights[i];
        }
        let max_weight_2 = -Infinity;
        for (let i = 0; i < n_triplets; ++i) {
            weights[i] /= max_weight;
            weights[i] += 0.0001;
            weights[i] = Math.log(1 + weight_adj * weights[i]);
            if (max_weight_2 < weights[i]) max_weight_2 = weights[i];
        }
        for (let i = 0; i < n_triplets; ++i) {
            weights[i] /= max_weight_2;
        }
        return {
            triplets: triplets,
            weights: weights,
        };
    }

    /**
     * Calculates the similarity matrix P
     * @private
     * @param {Matrix} knn_distances - matrix of pairwise knn distances
     * @param {Float64Array} sig - scaling factor for the distances
     * @param {Matrix} nbrs - nearest neighbors
     * @returns {Matrix} pairwise similarity matrix
     */
    _find_p(knn_distances, sig, nbrs) {
        const [N, n_neighbors] = knn_distances.shape;
        return new Matrix(N, n_neighbors, (i, j) => {
            return Math.exp(-(knn_distances.entry(i, j) ** 2 / sig[i] / sig[nbrs.entry(i, j)]));
        });
    }

    /**
     * Sample nearest neighbors triplets based on the similarity values given in P.
     * @private
     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.
     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.
     * @param {Number} n_inliers - Number of inlier points.
     * @param {Number} n_outliers - Number of outlier points.
     *
     */
    _sample_knn_triplets(P, nbrs, n_inliers, n_outliers) {
        const N = nbrs.shape[0];
        const triplets = new Matrix(N * n_inliers * n_outliers, 3);
        for (let i = 0; i < N; ++i) {
            let n_i = i * n_inliers * n_outliers;
            const sort_indices = this.__argsort(P.row(i).map((d) => -d));
            for (let j = 0; j < n_inliers; ++j) {
                let n_j = j * n_outliers;
                const sim = nbrs.entry(i, sort_indices[j]);
                const samples = this._rejection_sample(n_outliers, N, sort_indices.slice(0, j + 1));
                for (let k = 0; k < n_outliers; ++k) {
                    const index = n_i + n_j + k;
                    const out = samples[k];
                    triplets.set_entry(index, 0, i);
                    triplets.set_entry(index, 1, sim);
                    triplets.set_entry(index, 2, out);
                }
            }
        }
        return triplets;
    }

    /**
     * Should do the same as np.argsort()
     * @private
     * @param {Array} A
     */
    __argsort(A) {
        return A.map((d, i) => {
            return { d: d, i: i };
        })
            .sort((a, b) => a.d - b.d)
            .map((d) => d.i);
    }

    /**
     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.
     * @private
     * @param {*} n_samples
     * @param {*} max_int
     * @param {*} rejects
     */
    _rejection_sample(n_samples, max_int, rejects) {
        const randomizer = this._randomizer;
        const interval = linspace(0, max_int - 1).filter((d) => rejects.indexOf(d) < 0);
        return randomizer.choice(interval, Math.min(n_samples, interval.length - 2));
    }

    /**
     * Calculates the weights for the sampled nearest neighbors triplets
     * @private
     * @param {Matrix} triplets - Sampled Triplets.
     * @param {Matrix} P - Pairwise similarity matrix.
     * @param {Matrix} nbrs - nearest Neighbors
     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances
     * @param {Float64Array} sig - scaling factor for the distances.
     */
    _find_weights(triplets, P, nbrs, outlier_distances, sig) {
        const n_triplets = triplets.shape[0];
        const weights = new Float64Array(n_triplets);
        for (let t = 0; t < n_triplets; ++t) {
            const i = triplets.entry(t, 0);
            const sim = nbrs.row(i).indexOf(triplets.entry(t, 1));
            const p_sim = P.entry(i, sim);
            let p_out = Math.exp(-(outlier_distances[t] ** 2 / (sig[i] * sig[triplets.entry(t, 2)])));
            if (p_out < 1e-20) p_out = 1e-20;
            weights[t] = p_sim / p_out;
        }
        return weights;
    }

    /**
     * Sample uniformly ranom triplets
     * @private
     * @param {Matrix} X - Data matrix.
     * @param {Number} n_random - Number of random triplets per point
     * @param {Float64Array} sig - Scaling factor for the distances
     */
    _sample_random_triplets(X, n_random, sig) {
        const metric = this.parameter("metric");
        const randomizer = this._randomizer;
        const N = X.shape[0];
        const random_triplets = new Matrix(N * n_random, 3);
        const random_weights = new Float64Array(N * n_random);
        for (let i = 0; i < N; ++i) {
            const n_i = i * n_random;
            const indices = [...linspace(0, i - 1), ...linspace(i + 1, N - 1)];
            for (let j = 0; j < n_random; ++j) {
                let [sim, out] = randomizer.choice(indices, 2);
                let p_sim = Math.exp(-(metric(X.row(i), X.row(sim)) ** 2 / (sig[i] * sig[sim])));
                if (p_sim < 1e-20) p_sim = 1e-20;
                let p_out = Math.exp(-(metric(X.row(i), X.row(out)) ** 2 / (sig[i] * sig[out])));
                if (p_out < 1e-20) p_out = 1e-20;

                if (p_sim < p_out) {
                    [sim, out] = [out, sim];
                    [p_sim, p_out] = [p_out, p_sim];
                }
                const index = n_i + j;
                random_triplets.set_entry(index, 0, i);
                random_triplets.set_entry(index, 1, sim);
                random_triplets.set_entry(index, 2, out);
                random_weights[index] = p_sim / p_out;
            }
        }
        return {
            random_triplets: random_triplets,
            random_weights: random_weights,
        };
    }

    /**
     * Computes the gradient for updating the embedding.
     * @param {Matrix} Y - The embedding
     */
    _grad(Y) {
        const n_inliers = this.n_inliers;
        const n_outliers = this.n_outliers;
        const triplets = this.triplets;
        const weights = this.weights;
        const [N, dim] = Y.shape;
        const n_triplets = triplets.shape[0];
        const grad = new Matrix(N, dim, 0);
        let y_ij = new Float64Array(dim);
        let y_ik = new Float64Array(dim);
        let d_ij = 1;
        let d_ik = 1;
        let n_viol = 0;
        let loss = 0;
        const n_knn_triplets = N * n_inliers * n_outliers;

        for (let t = 0; t < n_triplets; ++t) {
            const [i, j, k] = triplets.row(t);
            // update y_ij, y_ik, d_ij, d_ik
            if (t % n_outliers == 0 || t >= n_knn_triplets) {
                d_ij = 1;
                d_ik = 1;
                for (let d = 0; d < dim; ++d) {
                    const Y_id = Y.entry(i, d);
                    const Y_jd = Y.entry(j, d);
                    const Y_kd = Y.entry(k, d);
                    y_ij[d] = Y_id - Y_jd;
                    y_ik[d] = Y_id - Y_kd;
                    d_ij += y_ij[d] ** 2;
                    d_ik += y_ik[d] ** 2;
                }
                // update y_ik and d_ik only
            } else {
                d_ik = 1;
                for (let d = 0; d < dim; ++d) {
                    const Y_id = Y.entry(i, d);
                    const Y_kd = Y.entry(k, d);
                    y_ik[d] = Y_id - Y_kd;
                    d_ik += y_ik[d] ** 2;
                }
            }

            if (d_ij > d_ik) ++n_viol;
            loss += weights[t] / (1 + d_ik / d_ij);
            const w = (weights[t] / (d_ij + d_ik)) ** 2;
            for (let d = 0; d < dim; ++d) {
                const gs = y_ij[d] * d_ik * w;
                const go = y_ik[d] * d_ij * w;
                grad.set_entry(i, d, grad.entry(i, d) + gs - go);
                grad.set_entry(j, d, grad.entry(j, d) - gs);
                grad.set_entry(k, d, grad.entry(k, d) + go);
            }
        }
        return { grad, loss, n_viol };
    }

    /**
     *
     * @param {Number} max_iteration
     */
    transform(max_iteration = 400) {
        this.check_init();
        for (let iter = 0; iter < max_iteration; ++iter) {
            this._next(iter);
        }
        return this.projection;
    }

    /**
     * @param {Number} max_iteration
     * @yields {Matrix}
     * @returns {Matrix}
     */
    *generator(max_iteration = 800) {
        this.check_init();
        for (let iter = 0; iter < max_iteration; ++iter) {
            this._next(iter);
            yield this.projection;
        }
        return this.projection;
    }

    /**
     * Does the iteration step.
     * @private
     * @param {Number} iter
     */
    _next(iter) {
        const gamma = iter > 150 ? 0.5 : 0.3;
        const old_C = this.C;
        const vel = this.vel;
        const Y = this.Y.add(vel.mult(gamma));
        const { grad, loss, n_viol } = this._grad(Y);
        this.C = loss;
        this.Y = this._update_embedding(Y, iter, grad);
        this.lr *= old_C > loss + this._parameters.tol ? 1.01 : 0.9;
        return this.Y;
    }

    /**
     * Updates the embedding.
     * @private
     * @param {Matrix} Y
     * @param {Number} iter
     * @param {Matrix} grad
     */
    _update_embedding(Y, iter, grad) {
        const [N, dim] = Y.shape;
        const gamma = iter > 150 ? 0.9 : 0.5; // moment parameter
        const min_gain = 0.01;
        const gain = this.gain;
        const vel = this.vel;
        const lr = this.lr;
        for (let i = 0; i < N; ++i) {
            for (let d = 0; d < dim; ++d) {
                const new_gain = Math.sign(vel.entry(i, d)) != Math.sign(grad.entry(i, d)) ? gain.entry(i, d) + 0.2 : Math.max(gain.entry(i, d) * 0.8, min_gain);
                gain.set_entry(i, d, new_gain);
                vel.set_entry(i, d, gamma * vel.entry(i, d) - lr * gain.entry(i, d) * grad.entry(i, d));
                Y.set_entry(i, d, Y.entry(i, d) + vel.entry(i, d));
            }
        }
        return Y;
    }
}

/**
 * @class
 * @alias Hierarchical_Clustering
 */
class Hierarchical_Clustering {
    /**
     * @constructor
     * @memberof module:clustering
     * @alias Hierarchical_Clustering
     * @todo needs restructuring.
     * @param {Matrix} - Data or distance matrix if metric is 'precomputed'
     * @param {("single"|"complete"|"average")} [linkage = "complete"]
     * @param {Function|"precomputed"} [metric = euclidean]
     * @returns {Hierarchical_Clustering}
     */
    constructor(matrix, linkage = "complete", metric = euclidean) {
        this._id = 0;
        this._matrix = matrix instanceof Matrix ? matrix : Matrix.from(matrix);
        this._metric = metric;
        this._linkage = linkage;
        if (metric === "precomputed" && this._matrix.shape[0] !== this._matrix.shape[1]) {
            throw new Error("If metric is 'precomputed', then matrix has to be square!");
        }
        this.init();
        this.root = this.do();
        return this;
    }

    /**
     *
     * @param {Number} value - value where to cut the tree.
     * @param {("distance"|"depth")} [type = "distance"] - type of value.
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}.
     */
    get_clusters(value, type = "distance") {
        let clusters = [];
        let accessor;
        switch (type) {
            case "distance":
                accessor = (d) => d.dist;
                break;
            case "depth":
                accessor = (d) => d.depth;
                break;
            default:
                throw new Error("invalid type");
        }
        this._traverse(this.root, accessor, value, clusters);
        return clusters;
    }

    /**
     * @private
     * @param {} node
     * @param {*} f
     * @param {*} value
     * @param {*} result
     */
    _traverse(node, f, value, result) {
        if (f(node) <= value) {
            result.push(node.leaves());
        } else {
            this._traverse(node.left, f, value, result);
            this._traverse(node.right, f, value, result);
        }
    }

    /**
     * computes the tree.
     */
    init() {
        const metric = this._metric;
        const A = this._matrix;
        const n = (this._n = A.shape[0]);
        const d_min = (this._d_min = new Float64Array(n));
        let distance_matrix;
        if (metric !== "precomputed") {
            distance_matrix = new Matrix(n, n, 0); //new Array(n);
            for (let i = 0; i < n; ++i) {
                d_min[i] = 0;
                //distance_matrix[i] = new Float64Array(n);
                for (let j = 0; j < n; ++j) {
                    distance_matrix.set_entry(i, j, i === j ? Infinity : metric(A.row(i), A.row(j)));
                    if (distance_matrix.entry(i, d_min[i]) > distance_matrix.entry(i, j)) {
                        d_min[i] = j;
                    }
                }
            }
        } else {
            distance_matrix = this._matrix.clone();
            for (let i = 0; i < n; ++i) {
                for (let j = 0; j < n; ++j) {
                    if (i === j) {
                        distance_matrix.set_entry(i, j, Infinity);
                    } else if (distance_matrix.entry(i, d_min[i]) > distance_matrix.entry(i, j)) {
                        d_min[i] = j;
                    }
                }
            }
        }
        this._distance_matrix = distance_matrix;
        const clusters = (this._clusters = new Array(n));
        const c_size = (this._c_size = new Uint16Array(n));
        for (let i = 0; i < n; ++i) {
            clusters[i] = [];
            clusters[i][0] = new Cluster(this._id++, null, null, 0, A.row(i), i, 1, 0);
            c_size[i] = 1;
        }
        return this;
    }

    /**
     * computes the tree.
     */
    do() {
        const n = this._n;
        const d_min = this._d_min;
        const D = this._distance_matrix;
        const clusters = this._clusters;
        const c_size = this._c_size;
        const linkage = this._linkage;
        let root = null;
        for (let p = 0, p_max = n - 1; p < p_max; ++p) {
            let c1 = 0;
            for (let i = 0; i < n; ++i) {
                let D_i_min = D.entry(i, d_min[i]);
                for (let j = i + 1; j < n; ++j) {
                    if (D_i_min > D.entry(i, j)) {
                        d_min[i] = j;
                        D_i_min = D.entry(i, d_min[i]);
                    }
                }
            }
            for (let i = 0; i < n; ++i) {
                if (D.entry(i, d_min[i]) < D.entry(c1, d_min[c1])) {
                    c1 = i;
                }
            }
            let c2 = d_min[c1];
            let c1_cluster = clusters[c1][0];
            let c2_cluster = clusters[c2][0];
            let c1_cluster_indices = c1_cluster.isLeaf ? [c1_cluster.index] : c1_cluster.index;
            let c2_cluster_indices = c2_cluster.isLeaf ? [c2_cluster.index] : c2_cluster.index;
            let indices = c1_cluster_indices.concat(c2_cluster_indices);
            let new_cluster = new Cluster(this._id++, c1_cluster, c2_cluster, D.entry(c1, c2), null, indices);
            c1_cluster.parent = new_cluster;
            c2_cluster.parent = new_cluster;
            clusters[c1].unshift(new_cluster);
            c_size[c1] += c_size[c2];
            for (let j = 0; j < n; ++j) {
                const D_c1_j = D.entry(c1, j);
                const D_c2_j = D.entry(c2, j);
                let value;
                switch (linkage) {
                    case "single":
                        value = Math.min(D_c1_j, D_c2_j);
                        break;
                    case "complete":
                        value = Math.max(D_c1_j, D_c2_j);
                        break;
                    case "average":
                        value = (c_size[c1] * D_c1_j + c_size[c2] * D_c2_j) / (c_size[c1] + c_size[j]);
                        break;
                }
                D.set_entry(j, c1, value);
                D.set_entry(c1, j, value);
            }

            D.set_entry(c1, c1, Infinity);
            for (let i = 0; i < n; ++i) {
                D.set_entry(i, c2, Infinity);
                D.set_entry(c2, i, Infinity);
            }

            /* for (let j = 0; j < n; ++j) {
                if (d_min[j] === c2) {
                    d_min[j] = c1;
                }
                if (D.entry(c1, j) < D.entry(c1, d_min[c1])) {
                    d_min[c1] = j;
                }
            } */
            root = new_cluster;
        }
        return root;
    }
}

class Cluster {
    constructor(id, left, right, dist, centroid, index, size, depth) {
        this.id = id;
        this.left = left;
        this.right = right;
        this.dist = dist;
        this.index = index;
        this.size = LOR(size , left.size) + right.size;
        this.depth = LOR(depth , 1) + Math.max(left.depth, right.depth);
        this.centroid = LOR(centroid , this._calculate_centroid(left, right));
        this.parent = null;
        return this;
    }

    _calculate_centroid(left, right) {
        const l_size = left.size;
        const r_size = right.size;
        const l_centroid = left.centroid;
        const r_centroid = right.centroid;
        const size = this.size;
        const n = left.centroid.length;
        const new_centroid = new Float64Array(n);
        for (let i = 0; i < n; ++i) {
            new_centroid[i] = (l_size * l_centroid[i] + r_size * r_centroid[i]) / size;
        }
        return new_centroid;
    }

    get isLeaf() {
        return this.depth === 0;
    }

    leaves() {
        if (this.isLeaf) return [this];
        const left = this.left;
        const right = this.right;
        return (left.isLeaf ? [left] : left.leaves()).concat(right.isLeaf ? [right] : right.leaves());
    }

    descendants() {
        if (this.isLeaf) return [this];
        const left_descendants = this.left.descendants();
        const right_descendants = this.right.descendants();
        return left_descendants.concat(right_descendants).concat([this]);
    }
}

/**
 * @class
 * @alias KMeans
 */
class KMeans {
    /**
     * @constructor
     * @memberof module:clustering
     * @alias KMeans
     * @todo needs restructuring. 
     * @param {Matrix} matrix 
     * @param {Numbers} K 
     * @param {Function} [metric = euclidean] 
     * @param {Number} [seed = 1987]
     * @param {Boolean} [init = true]
     * @returns {KMeans}
     */
    constructor(matrix, K, metric = euclidean, seed=1987, init = true) {
        this._metric = metric;
        this._matrix = matrix;
        this._K = K;
        const [N, D] = matrix.shape;
        this._N = N;
        this._D = D;
        if (K > N) K = N;
        this._randomizer = new Randomizer(seed);
        this._clusters = new Array(N).fill(undefined);
        this._cluster_centroids = this._get_random_centroids(K);
        if (init) this.init(K, this._cluster_centroids);
        return this;
    }

    /**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */
    get_clusters() {
        const K = this._K;
        const clusters = this._clusters;
        const result = new Array(K).fill().map(() => new Array());
        clusters.forEach((c, i) => result[c].push(i));
        return result;
    }

    /**
     * @private
     * @param {Array} points 
     * @param {Array} candidates 
     */
    _furthest_point(points, candidates) {
        const A = this._matrix;
        const metric = this._metric;
        let i = points.length;
        let H = Heap.heapify(
            candidates, 
            (d) => {
                const Ad = A.row(d);
                let sum = 0;
                for (let j = 0; j < i; ++j) {
                    sum += metric(Ad, points[j]);
                }
                return sum;
            }, 
            "max"
        );
        return H.pop().element;
    }

    _get_random_centroids(K) {
        const N = this._N;
        const randomizer = this._randomizer;
        const A = this._matrix;
        const cluster_centroids = new Array(K).fill();
        const indices = linspace(0, N - 1);
        const random_point = randomizer.random_int % (N - 1);
        cluster_centroids[0] = A.row(random_point);
        const init_points = [random_point];
        const sample_size = Math.floor((N - K) / K);// / K
        for (let i = 1; i < K; ++i) {
            // sampling + kmeans++ improvement?
            const sample = randomizer.choice(indices.filter(d => init_points.indexOf(d) == -1), sample_size);
            const furthest_point = this._furthest_point(cluster_centroids.slice(0, i), sample);
            init_points.push(furthest_point);
            cluster_centroids[i] = A.row(furthest_point);
        }
        return cluster_centroids;
    }

    _iteration(cluster_centroids) {
        const K = cluster_centroids.length;
        const N = this._N;
        const D = this._D;
        const A = this._matrix;
        const metric = this._metric;
        const clusters = this._clusters;
        let clusters_changed = false;
        // find nearest cluster centroid.
        for (let i = 0; i < N; ++i) {
            const Ai = A.row(i);
            let min_dist = Infinity;
            let min_cluster = null;
            for (let j = 0; j < K; ++j) {
                let d = metric(cluster_centroids[j], Ai);
                if (d < min_dist) {
                    min_dist = d;
                    min_cluster = j; 
                }
            }
            if (clusters[i] !== min_cluster) {
                clusters_changed = true;
            }
            clusters[i] = min_cluster;
        }
        // update cluster centroid
        // reset cluster centroids to 0
        for (let i = 0; i < K; ++i) {
            const centroid = cluster_centroids[i];
            for (let j = 0; j < D; ++j) {
                centroid[j] = 0;
            }
        }
        // compute centroid
        this._compute_centroid(cluster_centroids);

        return {   
            "clusters_changed": clusters_changed,
            "cluster_centroids": cluster_centroids
        };
    }

    _compute_centroid(cluster_centroids) {
        const K = cluster_centroids.length;
        const N = this._N;
        const D = this._D;
        const A = this._matrix;
        const clusters = this._clusters;
        const cluster_counter = new Array(K).fill(0);

        for (let i = 0; i < N; ++i) {
            const Ai = A.row(i);
            const ci = clusters[i];
            cluster_counter[ci]++;
            const centroid = cluster_centroids[ci];
            for (let j = 0; j < D; ++j) {
                centroid[j] += Ai[j];
            }
        }
        for (let i = 0; i < K; ++i) {
            const n = cluster_counter[i];
            cluster_centroids[i] = cluster_centroids[i].map(c => c / n);
        }
        
    }

    /**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */
    init(K, cluster_centroids) {
        if (!K) K = this._K;
        if (!cluster_centroids) cluster_centroids = this._get_random_centroids(K);
        let clusters_changed = false;
        do {
            const iteration_result = this._iteration(cluster_centroids);
            cluster_centroids = iteration_result.cluster_centroids;
            clusters_changed = iteration_result.clusters_changed;
        } while (clusters_changed)
    }
    
}

/**
 * @class
 * @alias KMedoids
 */
class KMedoids {
    /**
     * @constructor
     * @memberof module:clustering
     * @alias KMedoids
     * @todo needs restructuring. 
     * @param {Matrix} matrix - data matrix
     * @param {Numbers} K - number of clusters
     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)
     * @param {Function} [metric = euclidean] - metric defining the dissimilarity 
     * @param {Number} [seed = 1212] - seed value for random number generator
     * @returns {KMedoids}
     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms
     */
    constructor(matrix, K, max_iter=null, metric = euclidean, seed=1212) {
        this._metric = metric;
        this._matrix = matrix;
        this._A = this._matrix.to2dArray;
        this._K = K;
        const [N, D] = matrix.shape;
        this._N = N;
        this._D = D;
        this._max_iter = max_iter || 10 * Math.log10(N); 
        this._distance_matrix = new Matrix(N, N, "zeros");
        /* for (let i = 1; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                let dist = metric(this._A[i], this._A[j]);
                this._distance_matrix.set_entry(i, j, dist);
                this._distance_matrix.set_entry(j, i, dist)
            }
        } */
        if (K > N) K = N;
        this._randomizer = new Randomizer(seed);
        this._clusters = new Array(N).fill(undefined);
        this._cluster_medoids = this._get_random_medoids(K);
        //if (init) this.init(K, this._cluster_medoids);
        this._is_initialized = false;
        return this;
    }

    /**
     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. 
     */
    get_clusters() {
        const K = this._K;
        const A = this._A;
        if (!this._is_initialized) {
            this.init(K, this._cluster_medoids);
        }
        const result = new Array(K).fill().map(() => new Array());
        A.forEach((x_j, j) => {
            result[this._nearest_medoid(x_j, j).index_nearest].push(j);
        });
        result.medoids = this._cluster_medoids;
        return result;
    }

//    async* generator() { @bslab+
    generator () {
        const max_iter = this._max_iter;
        // yield this.get_clusters();
        this.get_clusters();
        let finish = false;
        let i = 0;
        do {
            finish = this._iteration();
            // yield this.get_clusters();
            this.get_clusters();
        } while (!finish && ++i < max_iter)
    }

    /**
     * Algorithm 1. FastPAM1: Improved SWAP algorithm
     */
    /* _iteration_1() {
        const A = this._A;
        const N = this._N;
        const K = this._K;
        const medoids = this._cluster_medoids;
        let DeltaTD = 0;
        let m0 = null;
        let x0 = null;
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const nearest_medoid = this._nearest_medoid(x_j, j);
                const d_j = nearest_medoid.distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    // disance to new medoid
                    const d_oj = this._get_distance(o, j, x_o, x_j);
                    const {
                        "index_nearest": n,
                        "distance_nearest": d_n,
                        "distance_second": d_s,
                    } = this._nearest_medoid(x_o, o); 
                    this._clusters[o] = n; // cached values
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change
                    if (d_oj < d_n) { // reassignment check
                        deltaTD.forEach((d_i, i) => {
                            if (n !== i) {
                                deltaTD[i] = d_i + d_oj - d_n; // update loss change
                            }
                        });
                    }
                });
                // choose best medoid i;
                const i = deltaTD
                    .map((d, i) => [d, i])
                    .sort((d1, d2) => d1[0] - d2[0])[0][1];
                const deltaTD_i = deltaTD[i];
                // store
                if (deltaTD_i < DeltaTD) {
                    DeltaTD = deltaTD_i;
                    m0 = i;
                    x0 = j;
                }
            }
        });

        if (DeltaTD >= 0) {
            return true // break loop if DeltaTD >= 0
        }
        // swap roles of medoid m and non-medoid x;
        medoids[m0] = x0;
        this._cluster_medoids = medoids;
        return false
    } */

    /** Algorithm 2. FastPAM2: SWAP with multiple candidates
     * 
     */
    _iteration() {
        const A = this._A;
        const K = this._K;
        const medoids = this._cluster_medoids;
        const cache = A.map((x_o, o) => this._nearest_medoid(x_o, o));
        // empty best candidates array
        const DeltaTD = new Array(K).fill(0);
        const xs = new Array(K).fill(null);
        A.forEach((x_j, j) => {
            if (medoids.findIndex(m => m === j) < 0) {
                const d_j = cache[j].distance_nearest; // distance to current medoid
                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid
                A.forEach((x_o, o) => {
                    if (j === o) return;
                    const d_oj = this._get_distance(o, j, x_o, x_j); // distance to new medoid
                    const {"index_nearest": n, "distance_nearest": d_n, "distance_second": d_s} = cache[o]; // cached
                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change for x_o
                    // Reassignment check
                    if (d_oj < d_n) { 
                        // update loss change
                        for (let i = 0; i < K; ++i) {
                            if (i !== n) deltaTD[i] += d_oj - d_n;
                        }
                    }
                });
                // remember best swap for i;
                deltaTD
                    .map((d, i) => [d, i])
                    .filter(([d, i]) => d < DeltaTD[i])
                    .forEach(([d, i]) => {
                        if (d < DeltaTD[i]) {
                            DeltaTD[i] = d;
                            xs[i] = j;
                        }
                    });
            }
        });
        // stop if no improvements were found
        if (min(DeltaTD) >= 0) return true; 

        // execute all improvements
        while (min(DeltaTD) < 0) {
            // swap roles of medoid m_i and non_medoid xs_i
            const i = DeltaTD
                .map((d, i) => [d, i])
                .sort(([a], [b]) => a - b)[0][1];
            if (medoids.filter(m => m == xs[i]).length == 0) {
                medoids[i] = xs[i];
            }
            // disable the swap just performed
            DeltaTD[i] = 0; 
            // recompute TD for remaining swap candidates
            DeltaTD
                .map((d_j, j) => [d_j, j])
                .filter(([d_j]) => d_j < 0)
                .forEach(([_, j]) => {
                    const x_j = A[j];
                    let sum = 0;
                    A.forEach((x_o, o) => {
                        if (medoids.findIndex(m => m != j && m == o) >= 0) return;
                        if (i == j) return;
                        if (cache[o].index_nearest === medoids[j])
                            sum += (Math.min(this._get_distance(o, j, x_o, x_j), cache[o].distance_second) - cache[o].distance_nearest); 
                        else {
                            sum += (Math.min(this._get_distance(o, j, x_o, x_j) - cache[o].distance_nearest, 0));
                        }
                    });
                    DeltaTD[j] = sum;
                });
        }
        this._cluster_medoids = medoids;
        return false;
    }

    _get_distance(i, j, x_i=null, x_j=null) {
        if (i === j) return 0;
        const D = this._distance_matrix;
        const A = this._A;
        const metric = this._metric;
        let d_ij = D.entry(i, j);
        if (d_ij === 0) {
            d_ij = metric(x_i || A[i], x_j || A[j]);
            D.set_entry(i, j, d_ij);
            D.set_entry(j, i, d_ij);
        }
        return d_ij;
    }

    _nearest_medoid(x_j, j) {
        const medoids = this._cluster_medoids;
        const A = this._A;
        const [nearest, second] = medoids
            .map((m, i) => {
                const x_m = A[m]; 
                return [this._get_distance(j, m, x_j, x_m), i];
            })
            .sort((m1, m2) => m1[0] - m2[0]);
        
        return { 
            "distance_nearest": nearest[0], 
            "index_nearest": nearest[1],
            "distance_second": second[0],
            "index_second": second[1],
        };
    }

    /**
     * Computes {@link K} clusters out of the {@link matrix}.
     * @param {Number} K - number of clusters.
     */
    init(K, cluster_medoids) {
        if (!K) K = this._K;
        if (!cluster_medoids) cluster_medoids = this._get_random_medoids(K);
        const max_iter = this._max_iter;
        let finish = false;
        let i = 0;
        do {
            finish = this._iteration();
        } while (!finish && ++i < max_iter)
        return this;
    }

    /**
     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.
     * @param {number} K - number of clusters
     * 
     */
    _get_random_medoids(K) {
        const N = this._N;
        const A = this._A;
        const indices = linspace(0, N - 1);
        const randomizer = this._randomizer;
        const n = Math.min(N, 10 + Math.ceil(Math.sqrt(N)));
        const TD = new Array(n).fill(Infinity);
        const medoids = [];
        // first medoid
        let TD0 = Infinity;
        let S = randomizer.choice(indices, n);
        for (let j = 0; j < n; ++j) {
            const S_j = S[j];
            const x_j = A[S_j];
            for (let o = 0; o < n; ++o) {
                if (o === j) continue;
                const x_o = A[S[o]];
                TD[j] += this._get_distance(j, o, x_j, x_o);
            }
            if (TD[j] < TD0) {
                TD0 = TD[j]; // smallest distance sum
                medoids.push(S_j);
            }
        }
        // other medoids
        for (let i = 1; i < K; ++i) {
            let DeltaTD = Infinity;
            S = randomizer.choice(indices.filter(index => medoids.findIndex(d => d === index) < 0), n);
            for (let j = 0; j < n; ++j) {
                let deltaTD = 0;
                const S_j = S[j];
                const x_j = A[S_j];
                for (let o = 0; o < n; ++o) {
                    if (o === j) continue;
                    const S_o = S[o];
                    const x_o = A[S_o];
                    let delta = this._get_distance(S_j, S_o, x_j, x_o) - min(medoids.map(m => this._get_distance(S_o, m, x_o)));
                    if (delta < 0) {
                        deltaTD = deltaTD + delta;
                    }
                }
                // best reduction
                if (deltaTD < DeltaTD) {
                    DeltaTD = deltaTD;
                    medoids.push(S_j);
                }
            }
            TD0 += DeltaTD;
        }
        return medoids.slice(0, K);
    }
    
}

/**
 * @class
 * @alias OPTICS
 */
class OPTICS {
    /**
     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.
     * @constructor
     * @memberof module:clustering
     * @alias OPTICS
     * @todo needs restructuring. 
     * @param {Matrix} matrix - the data.
     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.
     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)
     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.
     * @returns {OPTICS}
     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}
     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}
     */
    constructor(matrix, epsilon, min_points, metric = euclidean) {
        this._matrix = matrix;
        this._epsilon = epsilon;
        this._min_points = min_points;
        this._metric = metric;

        this._ordered_list = [];
        this._clusters = [];
        this._DB = new Array(matrix.shape[0]).fill();
        this.init();
        return this;
    }

    /**
     * Computes the clustering.
     */
    init() {
        const ordered_list = this._ordered_list;
        const matrix = this._matrix;
        const N = matrix.shape[0];
        const DB = this._DB;
        const clusters = this._clusters;
        let cluster_index = this._cluster_index = 0;

        for (let i = 0; i < N; ++i) {
            DB[i] = {
                "element": matrix.row(i),
                "index": i,
                "reachability_distance": undefined,
                "processed": false,
            };
        }
        for (const p of DB) {
            if (p.processed) continue;
            p.neighbors = this._get_neighbors(p);
            p.processed = true;
            clusters.push([p.index]);
            cluster_index = clusters.length - 1;
            ordered_list.push(p);
            if (this._core_distance(p) != undefined) {
                const seeds = new Heap(null, d => d.reachability_distance, "min");
                this._update(p, seeds);
                this._expand_cluster(seeds, clusters[cluster_index]);
            }
        }
        return this;
    }

    /**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.
     */
    _get_neighbors(p) {
        if ("neighbors" in p) return p.neighbors;
        const DB = this._DB;
        const metric = this._metric;
        const epsilon = this._epsilon;
        const neighbors = [];
        for (const q of DB) {
            if (q.index == p.index) continue;
            if (metric(p.element, q.element) < epsilon) {
                neighbors.push(q);
            }
        }
        return neighbors;
    }

    /**
     * 
     * @private
     * @param {Object} p - a point of {@link matrix}.
     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.
     */
    _core_distance(p) {
        const min_points = this._min_points;
        const metric = this._metric;
        if (p.neighbors && p.neighbors.length <= min_points) {
            return undefined;
        }
        return metric(p.element, p.neighbors[min_points].element);
    }

    /**
     * Updates the reachability distance of the points.
     * @private
     * @param {Object} p 
     * @param {Heap} seeds 
     */
    _update(p, seeds) {
        const metric = this._metric;
        const core_distance = this._core_distance(p);
        const neighbors = this._get_neighbors(p);//p.neighbors;
        for (const q of neighbors) {
            if (q.processed) continue;
            const new_reachability_distance = Math.max(core_distance, metric(p.element, q.element));
            //if (q.reachability_distance == undefined) { // q is not in seeds
            if (seeds.raw_data().findIndex(d => d.element == q) < 0) {
                q.reachability_distance = new_reachability_distance;
                seeds.push(q);
            } else { // q is in seeds
                if (new_reachability_distance < q.reachability_distance) {
                    q.reachability_distance = new_reachability_distance;
                    seeds = Heap.heapify(seeds.data(), d => d.reachability_distance, "min"); // seeds change key =/
                }
            }
        }
    }

    /**
     * Expands the {@link cluster} with points in {@link seeds}.
     * @private
     * @param {Heap} seeds 
     * @param {Array} cluster 
     */
    _expand_cluster(seeds, cluster) {
        const ordered_list = this._ordered_list;
        while (!seeds.empty) {
            const q = seeds.pop().element;
            q.neighbors = this._get_neighbors(q);
            q.processed = true;
            cluster.push(q.index);
            ordered_list.push(q);
            if (this._core_distance(q) != undefined) {
                this._update(q, seeds);
                this._expand_cluster(seeds, cluster);
            }
        }
    }

    /**
     * Returns an array of clusters.
     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.
     */
    get_clusters() {
        const clusters = [];
        const outliers = [];
        const min_points = this._min_points;
        for (const cluster of this._clusters) {
            if (cluster.length < min_points) {
                outliers.push(...cluster);
            } else {
                clusters.push(cluster);
            }
        }
        clusters.push(outliers);
        return clusters;
    }

    /**
     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)
     */
    get_cluster_affirmation() {
        const N = this._matrix.shape[0];
        const result = new Array(N).fill();
        const clusters = this.get_clusters();
        for (let i = 0, n = clusters.length; i < n; ++i) {
            const cluster = clusters[i];
            for (const index of cluster) {
                result[index] = (i < n - 1) ? i : -1;
            }
        }
        return result;
    }
}

/**
 * @class
 * @alias LSP
 * @extends DR
 */
class LSP extends DR {
    /**
     * Least Squares Projection.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias LSP
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.neighbors = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.
     * @param {Number} [parameters.control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {LSP}
     * @see {@link https://ieeexplore.ieee.org/document/4378370}
     * @todo accept precomputed distance matrix.
     */
    constructor(X, parameters) {
        super(X, { neighbors: undefined, control_points: undefined, d: 2, metric: euclidean, seed: 1212 }, parameters);
        this.parameter("neighbors", Math.min(LOR(parameters.neighbors , Math.max(Math.floor(this._N / 10), 2)), this._N - 1));
        this.parameter("control_points", Math.min(LOR(parameters.control_points , Math.ceil(Math.sqrt(this._N))), this._N - 1));
        this._is_initialized = false;
        return this;
    }

    /**
     *
     * @param {DR} DR - method used for position control points.
     * @param {Object} DR_parameters - Object containing parameters for the DR method which projects the control points
     * @returns {LSP}
     */
    init(DR = MDS, DR_parameters = {}, KNN = BallTree) {
        if (this._is_initialized) return this;
        const X = this.X;
        const N = this._N;
        const K = this.parameter("neighbors");
        const d = this.parameter("d");
        const seed = this.parameter("seed");
        const metric = this.parameter("metric");
        DR_parameters = Object.assign({d, metric, seed }, DR_parameters);
        const nc = this.parameter("control_points");
        const control_points = new KMedoids(X, nc, null, metric).get_clusters().medoids;
        const C = new Matrix(nc, N, "zeros");
        control_points.forEach((c_i, i) => {
            C.set_entry(i, c_i, 1);
        });
        const Y_C = new DR(Matrix.from(control_points.map((c_i) => X.row(c_i))), DR_parameters).transform();

        const XA = X.to2dArray;
        const knn = new KNN(XA, metric);
        const L = new Matrix(N, N, "I");
        const alpha = -1 / K;
        XA.forEach((x_i, i) => {
            for (const { index: j } of knn.search(x_i, K).iterate()) {
                if (i === j) continue;
                L.set_entry(i, j, alpha);
            }
        });
        const A = L.concat(C, "vertical");

        const z = new Matrix(N, d, "zeros");
        const b = z.concat(Y_C, "vertical");

        this._A = A;
        this._b = b;
        this._is_initialized = true;
        return this;
    }

    /**
     * Computes the projection.
     * @returns {Matrix} Returns the projection.
     */
    transform() {
        this.check_init();
        const A = this._A;
        const AT = A.T;
        const b = this._b;
        const ATA = AT.dot(A);
        const ATb = AT.dot(b);
        this.Y = Matrix.solve_CG(ATA, ATb, this._randomizer);
        return this.projection;
    }
}

/**
 * @class
 * @alias TopoMap
 * @memberof module:dimensionality_reduction
 * @extends DR
 */
class TopoMap extends DR {
    /**
     * TopoMap: A 0-dimensional Homology Preserving Projection of High-Dimensional Data.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias TopoMap
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Function} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {TopoMap}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
    constructor(X, parameters) {
        super(X, { metric: euclidean, seed: 1212 }, parameters);
        [this._N, this._D] = this.X.shape;
        this._distance_matrix = new Matrix(this._N, this._N, 0);
        return this;
    }

    /**
     * @private
     */
    __lazy_distance_matrix(i, j, metric) {
        const D = this._distance_matrix;
        const X = this.X;
        const D_ij = D.entry(i, j);
        if (D_ij === 0) {
            let dist = metric(X.row(i), X.row(j));
            D.set_entry(i, j, dist);
            D.set_entry(j, i, dist);
            return dist;
        }
        return D_ij;
    }

    /**
     * Computes the minimum spanning tree, using a given metric
     * @private
     * @param {Function} metric
     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}
     */
    _make_minimum_spanning_tree(metric = euclidean) {
        const N = this._N;
        const X = [...this.X];

        let disjoint_set = new DisjointSet(X);
        const F = [];
        let E = [];
        for (let i = 0; i < N; ++i) {
            for (let j = i + 1; j < N; ++j) {
                E.push([i, j, this.__lazy_distance_matrix(i, j, metric)]);
            }
        }
        E = E.sort((a, b) => a[2] - b[2]);

        for (const [u, v, w] of E) {
            const set_u = disjoint_set.find(X[u]);
            const set_v = disjoint_set.find(X[v]);
            if (set_u !== set_v) {
                F.push([u, v, w]);
                disjoint_set.union(set_u, set_v);
            }
        }

        return F.sort((a, b) => a[2] - b[2]);
    }

    /**
     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.
     */
    init() {
        const { metric} = this._parameters;
        this.Y = new Matrix(this._N, 2, 0);
        this._Emst = this._make_minimum_spanning_tree(metric);
        this._is_initialized = true;
        return this;
    }

    /**
     * Returns true if Point C is left of line AB.
     * @private
     * @param {Array} PointA - Point A of line AB
     * @param {Array} PointB - Point B of line AB
     * @param {Array} PointC - Point C
     * @returns {Boolean}
     */
    __hull_cross([ax, ay], [bx, by], [sx, sy]) {
        return (bx - ax) * (sy - ay) - (by - ay) * (sx - ax) <= 0;
    }

    /**
     * Computes the convex hull of the set of Points S
     * @private
     * @param {Array} S - Set of Points.
     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}
     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.
     */
    __hull(S) {
        const points = S.sort(([x1, y1], [x2, y2]) => y1 - y2 || x1 - x2);
        const N = points.length;
        if (N <= 2) return points;

        const lower = [];
        for (let i = 0; i < N; ++i) {
            while (lower.length >= 2 && this.__hull_cross(lower[lower.length - 2], lower[lower.length - 1], points[i])) {
                lower.pop();
            }
            lower.push(points[i]);
        }
        const upper = [];
        for (let i = N - 1; i >= 0; --i) {
            while (upper.length >= 2 && this.__hull_cross(upper[upper.length - 2], upper[upper.length - 1], points[i])) {
                upper.pop();
            }
            upper.push(points[i]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
    }

    /**
     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.
     * @private
     * @param {Array} PointA
     * @param {Array} PointB
     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.
     */
    __findAngle([p1x, p1y], [p2x, p2y]) {
        const n = euclidean([p1x, p1y], [p2x, p2y]);
        if (n === 0)
            return {
                sin: 0,
                cos: 1,
            };
        const vec = [(p2x - p1x) / n, (p2y - p1y) / n];
        const cos = vec[0];
        let sin = Math.sqrt(1 - cos * cos);
        sin = vec[1] >= 0 ? -sin : sin;
        return {
            sin: sin,
            cos: cos,
        };
    }

    /**
     * @private
     * @param {Array} hull
     * @param {Array} p
     * @param {Bool} topEdge
     */
    __align_hull(hull, p, topEdge) {
        let v = -1;
        let d2;
        for (let i = 0; i < hull.length; ++i) {
            const d = euclidean(hull[i], p);
            if (v === -1) {
                d2 = d;
                v = i;
            } else {
                if (d2 > d) {
                    d2 = d;
                    v = i;
                }
            }
        }

        let v1;
        let v2;
        if (topEdge) {
            v1 = hull[v];
            v2 = hull[(v + 1) % hull.length];
        } else {
            if (v == 0) v = hull.length - 1;
            v1 = hull[v];
            v2 = hull[(v - 1) % hull.length];
        }

        const transformation = {
            tx: -hull[v][0],
            ty: -hull[v][1],
        };

        if (hull.length >= 2) {
            const { sin, cos } = this.__findAngle(v1, v2);
            transformation.sin = sin;
            transformation.cos = cos;
        } else {
            transformation.sin = 0;
            transformation.cos = 1;
        }

        return transformation;
    }

    /**
     * @private
     * @param {Array} Point - The point which should get transformed.
     * @param {Object} Transformation - contains the values for translation and rotation.
     */
    __transform([px, py], { tx, ty, sin, cos }) {
        let x = px + tx;
        let y = py + ty;
        let xx = x * cos - y * sin;
        let yy = x * sin + y * cos;
        return [xx, yy];
    }

    /**
     * Calls {@link __transform} for each point in Set C
     * @private
     * @param {Array} C - Set of points.
     * @param {Object} t - Transform object.
     * @param {Number} yOffset - value to offset set C.
     */
    __transform_component(C, t, yOffset) {
        const N = C.length;
        for (let i = 0; i < N; ++i) {
            const c = C[i];
            const [cx, cy] = this.__transform(c, t);
            c[0] = cx;
            c[1] = cy + yOffset;
        }
    }

    /**
     * @private
     * @param {Array} u - point u
     * @param {Array} v - point v
     * @param {Number} w - edge weight w
     */
    __align_components(u, v, w) {
        const points_u = [...u.__disjoint_set.children];
        const points_v = [...v.__disjoint_set.children];

        const hull_u = this.__hull(points_u);
        const hull_v = this.__hull(points_v);

        const t_u = this.__align_hull(hull_u, u, false);
        const t_v = this.__align_hull(hull_v, v, true);

        this.__transform_component(points_u, t_u, 0);
        this.__transform_component(points_v, t_v, w);
    }

    /**
     * Transforms the inputdata {@link X} to dimensionality 2.
     */
    transform() {
        if (!this._is_initialized) this.init();
        const Emst = this._Emst;
        const Y = this.Y.to2dArray;
        const components = new DisjointSet(
            Y.map((y, i) => {
                y.i = i;
                return y;
            })
        );

        for (const [u, v, w] of Emst) {
            const component_u = components.find(Y[u]);
            const component_v = components.find(Y[v]);
            if (component_u === component_v) continue;
            this.__align_components(component_u, component_v, w);
            components.union(component_u, component_v);
        }
        return this.projection;
    }

    *generator() {
        if (!this._is_initialized) this.init();
        const Emst = this._Emst;
        const Y = this.Y.to2dArray;
        const components = new DisjointSet(
            Y.map((y, i) => {
                y.i = i;
                return y;
            })
        );

        for (const [u, v, w] of Emst) {
            const component_u = components.find(Y[u]);
            const component_v = components.find(Y[v]);
            if (component_u === component_v) continue;
            this.__align_components(component_u, component_v, w);
            components.union(component_u, component_v);
            yield this.projection;
        }
        return this.projection;
    }
}

/**
 * @class
 * @alias SAMMON
 * @extends DR
 */
class SAMMON extends DR {
    /**
     * SAMMON's Mapping
     * @constructor
     * @memberof module:dimensionality_reduction
     * @alias SAMMON
     * @param {Matrix} X - the high-dimensional data.
     * @param {Object} parameters - Object containing parameterization of the DR method.
     * @param {Number} [parameters.d = 2] - the dimensionality of the projection.
     * @param {Function|"precomputed"} [parameters.metric = euclidean] - the metric which defines the distance between two points.
     * @param {"PCA"|"MDS"|"random"} [parameters.init = "random"] - Either "PCA" or "MDS", with which SAMMON initialiates the projection. With "random" a random matrix gets used as starting point.
     * @param {Object} [parameters.init_parameters] - Parameters for the {@link init}-DR method.
     * @param {Number} [parameters.seed = 1212] - the seed for the random number generator.
     * @returns {SAMMON}
     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}
     */
    constructor(X, parameters) {
        super(X, { magic: 0.1, d: 2, metric: euclidean, seed: 1212, init_DR: "random", init_parameters: {} }, parameters);
        return this;
    }

    /**
     * initializes the projection.
     * @private
     */
    init() {
        const N = this.X.shape[0];
        const { d, metric, init_DR: init_DR, init_parameters: DR_parameters } = this._parameters;
        if (init_DR === "random") {
            const randomizer = this._randomizer;
            this.Y = new Matrix(N, d, () => randomizer.random);
        } else if (["PCA", "MDS"].includes(init_DR)) {
            this.Y = Matrix.from(init_DR == "PCA" ? PCA.transform(this.X, DR_parameters) : MDS.transform(this.X, DR_parameters));
        } else {
            throw new Error('init_DR needs to be either "random" or a DR method!')
        }
        this.distance_matrix = metric == "precomputed" ? Matrix.from(this.X) : distance_matrix(this.X, metric);
        return this;
    }

    /**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Matrix|Array} - The projection of {@link X}.
     */
    transform(max_iter = 200) {
        if (!this._is_initialized) this.init();
        for (let j = 0; j < max_iter; ++j) {
            this._step();
        }
        return this.projection;
    }

    /**
     * Transforms the inputdata {@link X} to dimenionality 2.
     * @param {Number} [max_iter=200] - Maximum number of iteration steps.
     * @returns {Generator} - A generator yielding the intermediate steps of the projection of {@link X}.
     */
    *generator(max_iter = 200) {
        if (!this._is_initialized) this.init();

        for (let j = 0; j < max_iter; ++j) {
            this._step();
            yield this.projection;
        }

        return this.projection;
    }

    _step() {
        const MAGIC = this.parameter("magic");
        const D = this.distance_matrix;
        const N = this.X.shape[0];
        const { d, metric } = this._parameters;
        let Y = this.Y;

        let G = new Matrix(N, d, 0);

        let sum = new Float64Array(d);
        for (let i = 0; i < N; ++i) {
            let e1 = new Float64Array(d);
            let e2 = new Float64Array(d);
            const Yi = Y.row(i);
            for (let j = 0; j < N; ++j) {
                if (i === j) continue;
                const Yj = Y.row(j);
                const delta = new Float64Array(d);
                for (let k = 0; k < d; ++k) {
                    delta[k] = Yi[k] - Yj[k];
                }
                const dY = metric(Yi, Yj);
                const dX = D.entry(i, j);
                const dq = dX - dY;
                const dr = Math.max(dX * dY, 1e-2);
                for (let k = 0; k < d; ++k) {
                    e1[k] += (delta[k] * dq) / dr;
                    e2[k] += (dq - (Math.pow(delta[k], 2) * (1 + dq / dY)) / dY) / dr;
                }
            }
            for (let k = 0; k < d; ++k) {
                const val = Y.entry(i, k) + ((MAGIC * e1[k]) / Math.abs(e2[k]) || 0);
                G.set_entry(i, k, val);
                sum[k] += val;
            }
        }
        for (let k = 0; k < d; ++k) {
            sum[k] /= N;
        }

        for (let i = 0; i < N; ++i) {
            for (let k = 0; k < d; ++k) {
                Y.set_entry(i, k, G.entry(i, k) - sum[k]);
            }
        }
        return Y;
    }
}

class SQDMDS extends DR {
    /**
     * SQuadMDS: a lean Stochastic Quartet MDS improving global structure preservation in neighbor embedding like t-SNE and UMAP.
     * @constructor
     * @memberof module:dimensionality_reduction
     * @param {Matrix|Number[][]} X
     * @param {Object} [parameters]
     * @param {Number} [parameters.d=2]
     * @param {Function} [parameters.metric = euclidean]
     * @param {Number} [parameters.decay_start = 0.1] - Percentage of iterations using exaggeration phase. If random init: it is recommended to start the decay later to give the time for the global config to adjust with big steps.
     * @param {Number} [parameters.decay_cte = 0.34] - Controls the decay of the learning parameter.
     * @param {Object} [parameters.init_DR]
     * @returns {SQDMDS}
     * @see {@link https://arxiv.org/pdf/2202.12087.pdf}
     */
    constructor(X, parameters) {
        super(
            X,
            {
                d: 2,
                metric: euclidean,
                seed: 1212,
                decay_start: 0.1,
                decay_cte: 0.34, // 0.34
                init_DR: {type: "random"}
            },
            parameters
        );

        return this;
    }

    /**
     * @private
     */
    init() {
        const N = this._N;
        const d = this.parameter("d");

        // initialize helpers.
        this._add = this.__add(d);
        this._sub_div = this.__sub_div(d);
        this._minus = this.__minus(d);
        this._mult = this.__mult(d);
        this._LR_init = Math.max(2, 0.005 * N);
        this._LR = this._LR_init;
        this._offset = -Math.exp(-1 / this.parameter("decay_cte"));
        this._momentums = new Matrix(N, d, 0);
        this._grads = new Matrix(N, d, 0);
        this._indices = linspace(0, N - 1);
        // initialize projection.
        const R = this._randomizer;
        this.Y = new Matrix(N, d, () => R.random - 0.5);

        // preparing metric for optimization.
        const this_metric = this.parameter("metric");
        if (this_metric === "precomputed") {
            this._HD_metric = function (i, j, X) {
                return X.entry(i, j);
            };
            this._HD_metric_exaggeration = function (i, j, X) {
                return Math.pow(X.entry(i, j), 2);
            };
        } else {
            this._HD_metric = function (i, j, X) {
                return this_metric(X.row(i), X.row(j));
            };
            if (this_metric == euclidean) {
                this._HD_metric_exaggeration = function (i, j, X) {
                    return euclidean_squared(X.row(i), X.row(j));
                };
            } else {
                this._HD_metric_exaggeration = function (i, j, X) {
                    return Math.pow(this_metric(X.row(i), X.row(j)), 2);
                };
            }
        }
        return;
    }

    /**
     * Computes the projection.
     * @param {Number} [iterations=500] - Number of iterations.
     * @returns {Matrix|Number[][]} the projection.
     */
    transform(iterations = 500) {
        this.check_init();
        this._decay_start = Math.round(this.parameter("decay_start") * iterations);
        for (let i = 0; i < iterations; ++i) {
            this._step(i, iterations);
        }
        return this.projection;
    }

    /**
     * Computes the projection.
     * @param {Number} [iterations=500] - number of iterations.
     * @yields {Matrix|Number[][]} the intermediate steps of the projection.
     */
    *generator(iterations = 500) {
        this.check_init();
        this._decay_start = Math.round(this.parameter("decay_start") * iterations);
        for (let i = 0; i < iterations; ++i) {
            this._step(i, iterations);
            yield this.projection;
        }
        return this.projection;
    }

    /**
     * Performs an optimization step.
     * @private
     * @param {Number} i - Acutal iteration.
     * @param {Number} iterations - Number of iterations.
     */
    _step(i, iterations) {
        const decay_start = this._decay_start;
        if (i > decay_start) {
            const decay_cte = this.parameter("decay_cte");
            const offset = this._offset;
            const ratio = (i - decay_start) / (iterations - decay_start);
            this._LR = this._LR_init * (Math.exp(-(ratio * ratio) / decay_cte) + offset);
            this._distance_exaggeration = false;
        } else {
            this._distance_exaggeration = true;
        }
        this._nestrov_iteration(this._distance_exaggeration);
    }

    /**
     * Creates quartets of non overlapping indices.
     * @private
     * @returns {Number[][]}
     */
    __quartets() {
        const N = this._N;
        const max_N = N - (N % 4);
        const R = this._randomizer;
        const shuffled_indices = R.choice(this._indices, max_N);
        const result = [];
        for (let i = 0; i < max_N; i += 4) {
            result.push(Uint32Array.of(shuffled_indices[i], shuffled_indices[i + 1], shuffled_indices[i + 2], shuffled_indices[i + 3]));
        }
        return result;
    }

    /**
     * Computes and applies gradients, and updates momentum.
     * @private
     * @param {Boolean} distance_exaggeration
     */
    _nestrov_iteration(distance_exaggeration) {
        const momentums = this._momentums.mult(0.99, { inline: true });
        const LR = this._LR;
        const grads = this._fill_MDS_grads(this.Y.add(momentums), this._grads, distance_exaggeration);
        const [n, d] = momentums.shape;
        for (let i = 0; i < n; ++i) {
            const g_i = grads.row(i);
            const g_i_norm = norm(g_i);
            if (g_i_norm == 0) continue;
            const mul = LR / g_i_norm;
            const m_i = momentums.row(i);
            for (let j = 0; j < d; ++j) {
                m_i[j] -= mul * g_i[j];
            }
        } // momentums -= (LR / norm) * grads
        this.Y.add(momentums, { inline: true });
    }

    /**
     * Computes the gradients.
     * @param {Matrix} Y - The Projection.
     * @param {Matrix} grads - The gradients.
     * @param {Boolean} [exaggeration = false] - Whether or not to use early exaggeration.
     * @param {Boolean} [zero_grad = true] - Whether or not to reset the gradient in the beginning.
     * @returns {Matrix} the gradients.
     */
    _fill_MDS_grads(Y, grads, exaggeration = false, zero_grad = true) {
        if (zero_grad) {
            // compute new gradients
            grads.values.fill(0);
        }
        const add = this._add;
        const X = this.X;
        let HD_metric;
        if (exaggeration == true) {
            HD_metric = this._HD_metric_exaggeration;
        } else {
            HD_metric = this._HD_metric;
        }

        const D_quartet = new Float64Array(6);
        const quartets = this.__quartets();
        for (const [i, j, k, l] of quartets) {
            // compute quartet's HD distances.
            D_quartet[0] = HD_metric(i, j, X);
            D_quartet[1] = HD_metric(i, k, X);
            D_quartet[2] = HD_metric(i, l, X);
            D_quartet[3] = HD_metric(j, k, X);
            D_quartet[4] = HD_metric(j, l, X);
            D_quartet[5] = HD_metric(k, l, X);

            const D_quartet_sum = neumair_sum(D_quartet);

            if (D_quartet_sum > 0) {
                for (let i = 0; i < 6; ++i) {
                    D_quartet[i] /= D_quartet_sum;
                    D_quartet[i] += 1e-11;
                }
            }
            const [gi, gj, gk, gl] = this._compute_quartet_grads(Y, [i, j, k, l], D_quartet);

            // add is inline, row acces the matrix
            add(grads.row(i), gi);
            add(grads.row(j), gj);
            add(grads.row(k), gk);
            add(grads.row(l), gl);
        }
        return grads;
    }

    /**
     * Quartet gradients for a projection.
     * @private
     * @param {Matrix} Y - The acutal projection.
     * @param {Number[]} quartet - The indices of the quartet.
     * @param {Number[]} D_hd - The high-dimensional distances of the quartet.
     * @returns {Number[][]} the gradients for the quartet.
     */
    _compute_quartet_grads(Y, quartet, [p_ab, p_ac, p_ad, p_bc, p_bd, p_cd]) {
        const [a, b, c, d] = quartet.map((index) => Y.row(index));
        // LD distances, add a small number just in case
        const d_ab = euclidean(a, b) + 1e-12;
        const d_ac = euclidean(a, c) + 1e-12;
        const d_ad = euclidean(a, d) + 1e-12;
        const d_bc = euclidean(b, c) + 1e-12;
        const d_bd = euclidean(b, d) + 1e-12;
        const d_cd = euclidean(c, d) + 1e-12;
        const sum_LD_dist = neumair_sum([d_ab, d_ac, d_ad, d_bc, d_bd, d_cd]);

        // for each element of the sum: use the same gradient function and just permute the points given in input.
        const [gA1, gB1, gC1, gD1] = this._ABCD_grads(a, b, c, d, d_ab, d_ac, d_ad, d_bc, d_bd, d_cd, p_ab, sum_LD_dist);
        const [gA2, gC2, gB2, gD2] = this._ABCD_grads(a, c, b, d, d_ac, d_ab, d_ad, d_bc, d_cd, d_bd, p_ac, sum_LD_dist);
        const [gA3, gD3, gC3, gB3] = this._ABCD_grads(a, d, c, b, d_ad, d_ac, d_ab, d_cd, d_bd, d_bc, p_ad, sum_LD_dist);
        const [gB4, gC4, gA4, gD4] = this._ABCD_grads(b, c, a, d, d_bc, d_ab, d_bd, d_ac, d_cd, d_ad, p_bc, sum_LD_dist);
        const [gB5, gD5, gA5, gC5] = this._ABCD_grads(b, d, a, c, d_bd, d_ab, d_bc, d_ad, d_cd, d_ac, p_bd, sum_LD_dist);
        const [gC6, gD6, gA6, gB6] = this._ABCD_grads(c, d, a, b, d_cd, d_ac, d_bc, d_ad, d_bd, d_ab, p_cd, sum_LD_dist);

        const add = this._add;
        const gA = add(gA1, gA2, gA3, gA4, gA5, gA6);
        const gB = add(gB1, gB2, gB3, gB4, gB5, gB6);
        const gC = add(gC1, gC2, gC3, gC4, gC5, gC6);
        const gD = add(gD1, gD2, gD3, gD4, gD5, gD6);

        return [gA, gB, gC, gD];
    }

    /**
     * Gradients for one element of the loss function's sum.
     * @private
     */
    _ABCD_grads(a, b, c, d, d_ab, d_ac, d_ad, d_bc, d_bd, d_cd, p_ab, sum_LD_dist) {
        const ratio = d_ab / sum_LD_dist;
        const twice_ratio = 2 * ((p_ab - ratio) / sum_LD_dist);
        const minus = this._minus;
        const add = this._add;
        const mult = this._mult;
        const sub_div = this._sub_div;
        // no side effects because sub_div creates new arrays, and the inline functions work on this new created arrays.
        const gA = mult(minus(mult(add(sub_div(a, b, d_ab), sub_div(a, c, d_ac), sub_div(a, d, d_ad)), ratio), sub_div(a, b, d_ab)), twice_ratio);
        const gB = mult(minus(mult(add(sub_div(b, a, d_ab), sub_div(b, c, d_bc), sub_div(b, d, d_bd)), ratio), sub_div(b, a, d_ab)), twice_ratio);
        const gC = mult(add(sub_div(c, a, d_ac), sub_div(c, b, d_bc), sub_div(c, d, d_cd)), ratio * twice_ratio);
        const gD = mult(add(sub_div(d, a, d_ad), sub_div(d, b, d_bd), sub_div(d, c, d_cd)), ratio * twice_ratio);
        return [gA, gB, gC, gD];
    }

    /**
     * Inline!
     */
    __minus(d) {
        return (a, b) => {
            for (let i = 0; i < d; ++i) {
                a[i] -= b[i];
            }
            return a;
        };
    }

    /**
     * Inline!
     */
    __add(d) {
        return (...summands) => {
            const n = summands.length;
            const s1 = summands[0];
            for (let j = 1; j < n; ++j) {
                const summand = summands[j];
                for (let i = 0; i < d; ++i) {
                    s1[i] += summand[i];
                }
            }
            return s1;
        };
    }

    /**
     * Inline!
     */
    __mult(d) {
        return (a, v) => {
            for (let i = 0; i < d; ++i) {
                a[i] *= v;
            }
            return a;
        };
    }

    /**
     * Creates a new array <code>(x - y) / div</code>
     */
    __sub_div(d) {
        return (x, y, div) => {
            return Float64Array.from({ length: d }, (_, i) => (x[i] - y[i]) / div);
        };
    }
}

var version="0.6.0";

exports.BallTree = BallTree;
exports.DisjointSet = DisjointSet;
exports.FASTMAP = FASTMAP;
exports.Heap = Heap;
exports.Hierarchical_Clustering = Hierarchical_Clustering;
exports.ISOMAP = ISOMAP;
exports.KMeans = KMeans;
exports.KMedoids = KMedoids;
exports.KNN = KNN;
exports.LDA = LDA;
exports.LLE = LLE;
exports.LSP = LSP;
exports.LTSA = LTSA;
exports.MDS = MDS;
exports.Matrix = Matrix;
exports.OPTICS = OPTICS;
exports.PCA = PCA;
exports.Randomizer = Randomizer;
exports.SAMMON = SAMMON;
exports.SQDMDS = SQDMDS;
exports.TSNE = TSNE;
exports.TopoMap = TopoMap;
exports.TriMap = TriMap;
exports.UMAP = UMAP;
exports.canberra = canberra;
exports.chebyshev = chebyshev;
exports.cosine = cosine;
exports.distance_matrix = distance_matrix;
exports.euclidean = euclidean;
exports.euclidean_squared = euclidean_squared;
exports.hamming = hamming;
exports.inner_product = inner_product;
exports.jaccard = jaccard;
exports.k_nearest_neighbors = k_nearest_neighbors;
exports.kahan_sum = kahan_sum;
exports.linspace = linspace;
exports.manhattan = manhattan;
exports.max = max;
exports.min = min;
exports.neumair_sum = neumair_sum;
exports.norm = norm;
exports.normalize = normalize;
exports.powell = powell;
exports.qr = qr_gramschmidt;
exports.qr_householder = qr_householder;
exports.simultaneous_poweriteration = simultaneous_poweriteration;
exports.sokal_michener = sokal_michener;
exports.version = version;
exports.yule = yule;

Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=druid.js.map
};
BundleModuleCode['plugins/ml/som']=function (module,exports,global,process){
// SOM Algorithm
// https://github.com/mljs/som
// Array/Typedarray version
// Ver 1.2.1

'use strict';

function squaredEuclidean(p, q) {
  let d = 0;
  for (let i = 0; i < p.length; i++) {
    d += (p[i] - q[i]) * (p[i] - q[i]);
  }
  return d;
}

function round(v,decimals) {
  return Number(v.toFixed(decimals))
}

var NodeSquare = Require('plugins/ml/ml/som/node-square'),
    NodeHexagonal = Require('plugins/ml/ml/som/node-hexagonal');

var defaultOptions = {
    fields: 3,
    randomizer: Math.random,
    distance: squaredEuclidean,
    iterations: 10,
    learningRate: 0.1,
    gridType: 'rect',
    torus: true,
    method: 'random'
};

function SOM(x, y, options, reload) {
    this.x = x;
    this.y = y;

    options = options || {};
    this.options = {};
    for (var i in defaultOptions) {
        if (options.hasOwnProperty(i)) {
            this.options[i] = options[i];
        } else {
            this.options[i] = defaultOptions[i];
        }
    }

    if (typeof this.options.fields === 'number') {
        this.numWeights = this.options.fields;
    } else if (Array.isArray(this.options.fields)) {
        this.numWeights = this.options.fields.length;
        var converters = getConverters(this.options.fields);
        this.extractor = converters.extractor;
        this.creator = converters.creator;
    } else {
        throw new Error('Invalid fields definition');
    }

    if (this.options.gridType === 'rect') {
        this.NodeType = NodeSquare;
        this.gridDim = {
            x: x,
            y: y
        };
    } else {
        this.NodeType = NodeHexagonal;
        var hx = this.x - Math.floor(this.y / 2);
        this.gridDim = {
            x: hx,
            y: this.y,
            z: -(0 - hx - this.y)
        };
    }

    this.torus = this.options.torus;
    this.distanceMethod = this.torus ? 'getDistanceTorus' : 'getDistance';

    this.distance = this.options.distance;

    this.maxDistance = getMaxDistance(this.distance, this.numWeights);

    if (reload === true) { // For model loading
        this.done = true;
        return;
    }
    if (!(x > 0 && y > 0)) {
        throw new Error('x and y must be positive');
    }

    this.times = {
        findBMU: 0,
        adjust: 0
    };

    this.randomizer = this.options.randomizer;

    this.iterationCount = 0;
    this.iterations = this.options.iterations;

    this.startLearningRate = this.learningRate = this.options.learningRate;

    this.mapRadius = Math.floor(Math.max(x, y) / 2);

    this.algorithmMethod = this.options.method;

    this.initNodes();

    this.done = false;
}

// typeof @trainingValue= Vector | Array | TypedArray | object

SOM.prototype.adjust = function adjust(trainingValue, neighbourhoodRadius) {
    var now = Date.now(),
        x, y, dist, influence;

    var bmu = this.findBestMatchingUnit(trainingValue);
    if (!bmu) throw "SOM.adjust: No matching BMU found.";
    var now2 = Date.now();
    this.times.findBMU += now2 - now;

    var radiusLimit = Math.floor(neighbourhoodRadius);
    
    var xMin = bmu.x - radiusLimit,
        xMax = bmu.x + radiusLimit,
        yMin = bmu.y - radiusLimit,
        yMax = bmu.y + radiusLimit;

    for (x = xMin; x <= xMax; x++) {
        var theX = x;
        if (x < 0) {
            theX += this.x;
        } else if (x >= this.x) {
            theX -= this.x;
        }
        for (y = yMin; y <= yMax; y++) {
            var theY = y;
            if (y < 0) {
                theY += this.y;
            } else if (y >= this.y) {
                theY -= this.y;
            }

            dist = bmu[this.distanceMethod](this.nodes[theX][theY]);

            if (dist < neighbourhoodRadius) {
                influence = Math.exp(-dist / (2 * neighbourhoodRadius));
                this.nodes[theX][theY].adjustWeights(trainingValue, this.learningRate, influence);
            }

        }
    }

    this.times.adjust += (Date.now() - now2);

};

// Approximate weights (reduce precision, decrease model export size)
SOM.prototype.approximate = function approximateModel(precision) {
  precision = checkOption(precision,2);

  var min0,max0,min,max;
  for (var i = 0; i < this.x; i++) {
    for (var j = 0; j < this.y; j++) {
      this.nodes[i][j].weights=this.nodes[i][j].weights.map(function (w) {
        if (min0 == undefined) max0=w,min0=w;
        else max0=Math.max(max0,w),min0=Math.min(min0,w);
        w=round(w,precision);
        if (min == undefined) max=w,min=w;
        else max=Math.max(max,w),min=Math.min(min,w);
        return w;
      });
    }
  }
  var error=round((1-(max-min)/(max0-min0))*100,4);
  return {max:max,min:min,min0:min0,max0:max0,error:error}
}

SOM.prototype.export = function exportModel() {
    var model = {
        name: 'SOM'
    };
    model.options = {
        fields: this.options.fields,
        gridType: this.options.gridType,
        torus: this.options.torus
    };
    model.data = new Array(this.x);
    for (var i = 0; i < this.x; i++) {
        model.data[i] = new Array(this.y);
        for (var j = 0; j < this.y; j++) {
            model.data[i][j] = this.nodes[i][j].weights;
        }
    }
    if (!this.done) {
        model.ready = false;
    }
    return model;
};

SOM.prototype.findBestMatchingUnit = function findBestMatchingUnit(candidate) {

    var bmu,
        lowest = Infinity,
        dist;

    for (var i = 0; i < this.x; i++) {
        for (var j = 0; j < this.y; j++) {
            dist = this.distance(this.nodes[i][j].weights, candidate);
            if (dist < lowest) {
                lowest = dist;
                bmu = this.nodes[i][j];
            }
        }
    }

    return bmu;

};

SOM.prototype.getConvertedNodes = function getConvertedNodes() {
    var result = new Array(this.x);
    for (var i = 0; i < this.x; i++) {
        result[i] = new Array(this.y);
        for (var j = 0; j < this.y; j++) {
            var node = this.nodes[i][j];
            result[i][j] = this.creator ? this.creator(node.weights) : node.weights;
        }
    }
    return result;
};

// As seen in http://www.scholarpedia.org/article/Kohonen_network
SOM.prototype.getQuantizationError = function getQuantizationError() {
    var fit = this.getFit(),
        l = fit.length,
        sum = 0;
    for (var i = 0; i < l; i++) {
        sum += fit[i];
    }
    return sum / l;
};

SOM.prototype.getFit = function getFit(dataset) {
    if (!dataset) {
        dataset = this.trainingSet;
    }
    var l = dataset.length,
        bmu,
        result = new Array(l);
    for (var i = 0; i < l; i++) {
        bmu = this.findBestMatchingUnit(dataset[i]);
        result[i] = Math.sqrt(this.distance(dataset[i], bmu.weights));
    }
    return result;
};

SOM.prototype.getUMatrix = function getUMatrix() {
    var matrix = new Array(this.x);
    for (var i = 0; i < this.x; i++) {
        matrix[i] = new Array(this.y);
        for (var j = 0; j < this.y; j++) {
            var node = this.nodes[i][j],
                nX = node.getNeighbors('x'),
                nY = node.getNeighbors('y');
            var sum = 0,
                total = 0,
                self = this;
            if(nX[0]) {
                total++;
                sum += self.distance(node.weights, nX[0].weights);
            }
            if(nX[1]) {
                total++;
                sum += self.distance(node.weights, nX[1].weights);
            }
            if(nY[0]) {
                total++;
                sum += self.distance(node.weights, nY[0].weights);
            }
            if(nY[1]) {
                total++;
                sum += self.distance(node.weights, nY[1].weights);
            }
            matrix[i][j] = sum / total;
        }
    }
    return matrix;
};

SOM.prototype.initNodes = function initNodes() {
    var now = Date.now(),
        i, j, k;
    this.nodes = new Array(this.x);
    for (i = 0; i < this.x; i++) {
        this.nodes[i] = new Array(this.y);
        for (j = 0; j < this.y; j++) {
            var weights = new Array(this.numWeights);
            for (k = 0; k < this.numWeights; k++) {
                weights[k] = this.randomizer();
            }
            this.nodes[i][j] = new this.NodeType(i, j, weights, this);
        }
    }
    this.times.initNodes = Date.now() - now;
};

SOM.load = function loadModel(model, distance) {
    if (model.name === 'SOM') {
        var x = model.data.length,
            y = model.data[0].length;
        if (distance) {
            model.options.distance = distance;
        }
        var som = new SOM(x, y, model.options, true);
        som.nodes = new Array(x);
        for (var i = 0; i < x; i++) {
            som.nodes[i] = new Array(y);
            for (var j = 0; j < y; j++) {
                som.nodes[i][j] = new som.NodeType(i, j, model.data[i][j], som);
            }
        }
        return som;
    } else {
        throw new Error('expecting a SOM model');
    }
};

SOM.prototype.predict = function predict(data, computePosition) {
    if (typeof data === 'boolean') {
        computePosition = data;
        data = null;
    }
    if (!data) {
        data = this.trainingSet;
    }
    if (Array.isArray(data) && (Array.isArray(data[0]) || (typeof data[0] === 'object'))) { // predict a dataset
        var self = this;
        return data.map(function (element) {
            return self.predictOne(element, computePosition);
        });
    } else { // predict a single element
        return this.predictOne(data, computePosition);
    }
};

SOM.prototype.predictOne = function predictOne(element, computePosition) {
    if (!Array.isArray(element) && !Utils.isTypedArray(element)) {
        element = this.extractor(element);
    }
    var bmu = this.findBestMatchingUnit(element);
    var result = [bmu.x, bmu.y];
    if (computePosition) {
        result[2] = bmu.getPosition(element);
    }
    return result;
};

// typeof @trainingSet = (Array|TypedArray) Array|Matrix|MatrixTA

SOM.prototype.setTraining = function setTraining(trainingSet) {
   if (this.trainingSet) {
        throw new Error('training set has already been set');
    }
    var now = Date.now();
    if (Math.Matrix && Math.Matrix.isMatrix(trainingSet)) {
      trainingSet=trainingSet.data;
    } else if (Math.MatrixTA && Math.MatrixTA.isMatrix(trainingSet)) {
      var _trainingSet=[];
      for(var i=0;i<trainingSet.rows;i++) {
        _trainingSet.push(trainingSet.getRow(i)); // Array
      }
      trainingSet=_trainingSet;
    }
    var convertedSet = trainingSet;
    var i, l = trainingSet.length;
    
    if (this.extractor) {
        convertedSet = new Array(l);
        for (i = 0; i < l; i++) {
            convertedSet[i] = this.extractor(trainingSet[i]);
        }
    }
    this.numIterations = this.iterations * l;

    if (this.algorithmMethod === 'random') {
        this.timeConstant = this.numIterations / Math.log(this.mapRadius);
    } else {
        this.timeConstant = l / Math.log(this.mapRadius);
    }
    this.trainingSet = convertedSet;
    this.times.setTraining = Date.now() - now;
};

SOM.prototype.train = function train(trainingSet,options) {
  if (options && options.iterations) {
    this.iterations=options.iterations;
    this.numIterations = this.iterations * trainingSet.length;
  }
  if (!this.done) {
      this.setTraining(trainingSet);
      var needTrain = true;
      while (needTrain){
          needTrain = this.trainOne();
      }
  }
};


SOM.prototype.trainOne = function trainOne() {
    if (this.done) {
        return false;
    } else if (this.numIterations-- > 0) {
        var neighbourhoodRadius,
            trainingValue,
            trainingSetFactor;

        if (this.algorithmMethod === 'random') { // Pick a random value of the training set at each step
            neighbourhoodRadius = this.mapRadius * Math.exp(-this.iterationCount / this.timeConstant);
            trainingValue = getRandomValue(this.trainingSet, this.randomizer);
            this.adjust(trainingValue, neighbourhoodRadius);
            this.learningRate = this.startLearningRate * Math.exp(-this.iterationCount / this.numIterations);
        } else { // Get next input vector
            trainingSetFactor = -Math.floor(this.iterationCount / this.trainingSet.length);
            neighbourhoodRadius = this.mapRadius * Math.exp(trainingSetFactor / this.timeConstant);
            trainingValue = this.trainingSet.getRow(this.iterationCount % this.trainingSet.length);
            this.adjust(trainingValue, neighbourhoodRadius);
            if (((this.iterationCount + 1) % this.trainingSet.length) === 0) {
                this.learningRate = this.startLearningRate * Math.exp(trainingSetFactor / Math.floor(this.numIterations / this.trainingSet.length));
            }
        }
        this.iterationCount++;
        return true;
    } else {
        this.done = true;
        return false;
    }
};



function getConverters(fields) {
    var l = fields.length,
        normalizers = new Array(l),
        denormalizers = new Array(l),
        range;
    for (var i = 0; i < l; i++) {
        range = fields[i].range;
        normalizers[i] = getNormalizer(range[0], range[1]);
        denormalizers[i] = getDenormalizer(range[0], range[1]);
    }
    return {
        extractor: function extractor(value) {
            var result = new Array(l);
            for (var j = 0; j < l; j++) {
                result[j] = normalizers[j](value[fields[j].name]);
            }
            return result;
        },
        creator: function creator(value) {
            var result = {};
            for (var j = 0; j < l; j++) {
                result[fields[j].name] = denormalizers[j](value[j]);
            }
            return result;
        }
    };
}

function getNormalizer(min, max) {
    return function normalizer(value) {
        return (value - min) / (max - min);
    };
}

function getDenormalizer(min, max) {
    return function denormalizer(value) {
        return (min + value * (max - min));
    };
}

function getRandomValue(arr, randomizer) {
    return arr.getRow(Math.floor(randomizer() * arr.length));
}

function getMaxDistance(distance, numWeights) {
    var zero = new Array(numWeights),
        one = new Array(numWeights);
    for (var i = 0; i < numWeights; i++) {
        zero[i] = 0;
        one[i] = 1;
    }
    return distance(zero, one);
}

module.exports = SOM;

};
BundleModuleCode['plugins/ml/ml/som/node-square']=function (module,exports,global,process){
'use strict';

function NodeSquare(x, y, weights, som) {
    this.x = x;
    this.y = y;
    this.weights = weights;
    this.som = som;
    this.neighbors = {};
}

NodeSquare.prototype.adjustWeights = function adjustWeights(target, learningRate, influence) {
    for (var i = 0, ii = this.weights.length; i < ii; i++) {
        this.weights[i] += learningRate * influence * (target[i] - this.weights[i]);
    }
};

NodeSquare.prototype.getDistance = function getDistance(otherNode) {
    return Math.max(Math.abs(this.x - otherNode.x), Math.abs(this.y - otherNode.y));
};

NodeSquare.prototype.getDistanceTorus = function getDistanceTorus(otherNode) {
    var distX = Math.abs(this.x - otherNode.x),
        distY = Math.abs(this.y - otherNode.y);
    return Math.max(Math.min(distX, this.som.gridDim.x - distX), Math.min(distY, this.som.gridDim.y - distY));
};

NodeSquare.prototype.getNeighbors = function getNeighbors(xy) {
    if (!this.neighbors[xy]) {
        this.neighbors[xy] = new Array(2);

        // left or bottom neighbor
        var v;
        if (this[xy] > 0) {
            v = this[xy] - 1;
        } else if (this.som.torus) {
            v = this.som.gridDim[xy] - 1;
        }
        if (typeof v !== 'undefined') {
            var x, y;
            if (xy === 'x') {
                x = v;
                y = this.y;
            } else {
                x = this.x;
                y = v;
            }
            this.neighbors[xy][0] = this.som.nodes[x][y];
        }

        // top or right neighbor
        var w;
        if (this[xy] < (this.som.gridDim[xy] - 1)) {
            w = this[xy] + 1;
        } else if (this.som.torus) {
            w = 0;
        }
        if (typeof w !== 'undefined') {
            if (xy === 'x') {
                x = w;
                y = this.y;
            } else {
                x = this.x;
                y = w;
            }
            this.neighbors[xy][1] = this.som.nodes[x][y];
        }
    }
    return this.neighbors[xy];
};

NodeSquare.prototype.getPos = function getPos(xy, element) {
    var neighbors = this.getNeighbors(xy),
        distance = this.som.distance,
        bestNeighbor,
        direction;
    if(neighbors[0]) {
        if (neighbors[1]) {
            var dist1 = distance(element, neighbors[0].weights),
                dist2 = distance(element, neighbors[1].weights);
            if(dist1 < dist2) {
                bestNeighbor = neighbors[0];
                direction = -1;
            } else {
                bestNeighbor = neighbors[1];
                direction = 1;
            }
        } else {
            bestNeighbor = neighbors[0];
            direction = -1;
        }
    } else {
        bestNeighbor = neighbors[1];
        direction = 1;
    }
    var simA = 1 - distance(element, this.weights),
        simB = 1 - distance(element, bestNeighbor.weights);
    var factor = ((simA - simB) / (2 - simA - simB));
    return 0.5 + 0.5 * factor * direction;
};

NodeSquare.prototype.getPosition = function getPosition(element) {
    return [
        this.getPos('x', element),
        this.getPos('y', element)
    ];
};

module.exports = NodeSquare;
};
BundleModuleCode['plugins/ml/ml/som/node-hexagonal']=function (module,exports,global,process){
'use strict';

var NodeSquare = Require('plugins/ml/ml/som/node-square');

function NodeHexagonal(x, y, weights, som) {

    NodeSquare.call(this, x, y, weights, som);

    this.hX = x - Math.floor(y / 2);
    this.z = 0 - this.hX - y;

}

NodeHexagonal.prototype = new NodeSquare();
NodeHexagonal.prototype.constructor = NodeHexagonal;

NodeHexagonal.prototype.getDistance = function getDistanceHexagonal(otherNode) {
    return Math.max(Math.abs(this.hX - otherNode.hX), Math.abs(this.y - otherNode.y), Math.abs(this.z - otherNode.z));
};

NodeHexagonal.prototype.getDistanceTorus = function getDistanceTorus(otherNode) {
    var distX = Math.abs(this.hX - otherNode.hX),
        distY = Math.abs(this.y - otherNode.y),
        distZ = Math.abs(this.z - otherNode.z);
    return Math.max(Math.min(distX, this.som.gridDim.x - distX), Math.min(distY, this.som.gridDim.y - distY), Math.min(distZ, this.som.gridDim.z - distZ));
};

NodeHexagonal.prototype.getPosition = function getPosition() {
    throw new Error('Unimplemented : cannot get position of the points for hexagonal grid');
};

module.exports = NodeHexagonal;
};
BundleModuleCode['plugins/ml/helpers']=function (module,exports,global,process){
//     wink-helpers
//     Functions for cross validation, shuffle, cartesian product and more
//
//     https://github.com/winkjs/wink-helpers
//
//     Copyright (C) 2017-18  GRAYPE Systems Private Limited
//
//     This file is part of “wink-helpers”.
//
//     Permission is hereby granted, free of charge, to any person obtaining a
//     copy of this software and associated documentation files (the "Software"),
//     to deal in the Software without restriction, including without limitation
//     the rights to use, copy, modify, merge, publish, distribute, sublicense,
//     and/or sell copies of the Software, and to permit persons to whom the
//     Software is furnished to do so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included
//     in all copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//     DEALINGS IN THE SOFTWARE.

//
var helpers = Object.create( null );

// ### Private Functions

// #### Product Reducer (Callback)

// Callback function used by `reduce` inside the `product()` function.
// Follows the standard guidelines of `reduce()` callback function.
var productReducer = function ( prev, curr ) {
  var c,
      cmax = curr.length;
  var p,
      pmax = prev.length;
  var result = [];

  for ( p = 0; p < pmax; p += 1 ) {
    for ( c = 0; c < cmax; c += 1 ) {
      result.push( prev[ p ].concat( curr[ c ] ) );
    }
  }
  return ( result );
}; // productReducer()

// ### Public Function

// ### Array Helpers

helpers.array = Object.create( null);

// #### is Array

// Tests if argument `v` is a JS array; returns `true` if it is, otherwise returns `false`.
helpers.array.isArray = function ( v ) {
  return ( ( v !== undefined ) && ( v !== null ) && ( Object.prototype.toString.call( v ) === '[object Array]' ) );
}; // isArray()


// #### sorting helpers

// Set of helpers to sort either numbers or strings. For key/value pairs,
// the format for each element must be `[ key, value ]`.
// Sort helper to sort an array in ascending order.
helpers.array.ascending = function ( a, b ) {
  return ( a > b ) ? 1 :
            ( a === b ) ? 0 : -1;
}; // ascending()

// Sort helper to sort an array in descending order.
helpers.array.descending = function ( a, b ) {
  return ( b > a ) ? 1 :
            ( b === a ) ? 0 : -1;
}; // descending()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **key**.
helpers.array.ascendingOnKey = function ( a, b ) {
  return ( a[ 0 ] > b[ 0 ] ) ? 1 :
            ( a[ 0 ] === b[ 0 ] ) ? 0 : -1;
}; // ascendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in descending order by **key**.
helpers.array.descendingOnKey = function ( a, b ) {
  return ( b[ 0 ] > a[ 0 ] ) ? 1 :
            ( b[ 0 ] === a[ 0 ] ) ? 0 : -1;
}; // descendingOnKey()

// Sort helper to sort an array of `[ key, value ]` in ascending order by **value**.
helpers.array.ascendingOnValue = function ( a, b ) {
  return ( a[ 1 ] > b[ 1 ] ) ? 1 :
            ( a[ 1 ] === b[ 1 ] ) ? 0 : -1;
}; // ascendingOnValue()

// Sort helper to sort an array of `[ key, value ]` in descending order by **value**.
helpers.array.descendingOnValue = function ( a, b ) {
  return ( b[ 1 ] > a[ 1 ] ) ? 1 :
            ( b[ 1 ] === a[ 1 ] ) ? 0 : -1;
}; // descendingOnValue()

// The following two functions generate a suitable function for sorting on a single
// key or on a composite keys (max 2 only). Just a remider, the generated function
// does not sort on two keys; instead it will sort on a key composed of the two
// accessors.
// Sorts in ascending order on `accessor1` & `accessor2` (optional).
helpers.array.ascendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( a[ accessor1 ][ accessor2 ] > b[ accessor1 ][ accessor2 ] ) ? 1 :
              ( a[ accessor1 ][ accessor2 ] === b[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( a[ accessor1 ] > b[ accessor1 ] ) ? 1 :
            ( a[ accessor1 ] === b[ accessor1 ] ) ? 0 : -1;
  } );
}; // ascendingOn()

// Sorts in descending order on `accessor1` & `accessor2` (optional).
helpers.array.descendingOn = function ( accessor1, accessor2 ) {
  if ( accessor2 ) {
    return ( function ( a, b ) {
      return ( b[ accessor1 ][ accessor2 ] > a[ accessor1 ][ accessor2 ] ) ? 1 :
              ( b[ accessor1 ][ accessor2 ] === a[ accessor1 ][ accessor2 ] ) ? 0 : -1;
    } );
  }
  return ( function ( a, b ) {
    return ( b[ accessor1 ] > a[ accessor1 ] ) ? 1 :
            ( b[ accessor1 ] === a[ accessor1 ] ) ? 0 : -1;
  } );
}; // descendingOn()

// #### pluck

// Plucks specified element from each element of an **array of array**, and
// returns the resultant array. The element is specified by `i` (default `0`) and
// number of elements to pluck are defined by `limit` (default `a.length`).
helpers.array.pluck = function ( a, key, limit ) {
  var k, plucked;
  k = a.length;
  var i = key || 0;
  var lim = limit || k;
  if ( lim > k ) lim = k;
  plucked = new Array( lim );
  for ( k = 0; k < lim; k += 1 ) plucked[ k ] = a[ k ][ i ];
  return plucked;
}; // pluck()

// #### product

// Finds the Cartesian Product of arrays present inside the array `a`. Therefore
// the array `a` must be an array of 1-dimensional arrays. For example,
// `product( [ [ 9, 8 ], [ 1, 2 ] ] )`
// will produce `[ [ 9, 1 ], [ 9, 2 ], [ 8, 1 ], [ 8, 2 ] ]`.
helpers.array.product = function ( a ) {
  return (
    a.reduce( productReducer, [ [] ] )
  );
};

// #### shuffle

// Randomly shuffles the elements of an array and returns the same.
// Reference: Chapter on Random Numbers/Shuffling in Seminumerical algorithms.
// The Art of Computer Programming Volume II by Donald E Kunth
helpers.array.shuffle = function ( array ) {
  var a = array;
  var balance = a.length;
  var candidate;
  var temp;

  while ( balance ) {
    candidate = Math.floor( Math.random() * balance );
    balance -= 1;

    temp = a[ balance ];
    a[ balance ] = a[ candidate ];
    a[ candidate ] = temp;
  }

  return ( a );
};


// ### Object Helpers

var objectKeys = Object.keys;
var objectCreate = Object.create;

helpers.object = Object.create( null );

// #### is Object

// Tests if argument `v` is a JS object; returns `true` if it is, otherwise returns `false`.
helpers.object.isObject = function ( v ) {
  return ( v && ( Object.prototype.toString.call( v ) === '[object Object]' ) ) ? true : false; // eslint-disable-line no-unneeded-ternary

}; // isObject()

// #### keys

// Returns keys of the `obj` in an array.
helpers.object.keys = function ( obj ) {
  return ( objectKeys( obj ) );
}; // keys()

// #### size

// Returns the number of keys of the `obj`.
helpers.object.size = function ( obj ) {
  return ( ( objectKeys( obj ) ).length );
}; // size()

// #### values

// Returns all values from each key/value pair of the `obj` in an array.
helpers.object.values = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var values = new Array( length );
  for ( var i = 0; i < length; i += 1 ) {
    values[ i ] = obj[ keys[ i ] ];
  }
  return values;
}; // values()

// #### value Freq

// Returns the frequency of each unique value present in the `obj`, where the
// **key** is the *value* and **value** is the *frequency*.
helpers.object.valueFreq = function ( obj ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var val;
  var vf = objectCreate( null );
  for ( var i = 0; i < length; i += 1 ) {
    val = obj[ keys[ i ] ];
    vf[ val ] = 1 + ( vf[ val ] || 0 );
  }
  return vf;
}; // valueFreq()

// #### table

// Converts the `obj` in to an array of `[ key, value ]` pairs in form of a table.
// Second argument - `f` is optional and it is a function, which is called with
// each `value`.
helpers.object.table = function ( obj, f ) {
  var keys = helpers.object.keys( obj );
  var length = keys.length;
  var pairs = new Array( length );
  var ak, av;
  for ( var i = 0; i < length; i += 1 ) {
    ak = keys[ i ];
    av = obj[ ak ];
    if ( typeof f === 'function' ) f( av );
    pairs[ i ] = [ ak, av ];
  }
  return pairs;
}; // table()

// ### Validation Helpers

helpers.validate = Object.create( null );

// Create aliases for isObject and isArray.
helpers.validate.isObject = helpers.object.isObject;
helpers.validate.isArray = helpers.array.isArray;

// #### isFiniteInteger

// Validates if `n` is a finite integer.
helpers.validate.isFiniteInteger = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n ) &&
    ( n === Math.round( n ) )
  );
}; // isFiniteInteger()

// #### isFiniteNumber

// Validates if `n` is a valid number.
helpers.validate.isFiniteNumber = function ( n ) {
  return (
    ( typeof n === 'number' ) &&
    !isNaN( n ) &&
    isFinite( n )
  );
}; // isFiniteNumber()

// ### cross validation
/**
 *
 * Creates an instance of cross validator useful for machine learning tasks.
 *
 * @param {string[]} classLabels - array containing all the class labels.
 * @return {methods} object conatining set of API methods for tasks like evalutaion,
 * reset and metrics generation.
*/
helpers.validate.cross = function ( classLabels ) {
  // wink's const for unknown predictions!
  const unknown = 'unknown';
  // To ensure that metrics is not computed prior to evaluation.
  var evaluated = false;
  // The confusion matrix.
  var cm;
  var precision;
  var recall;
  var fmeasure;

  // The class labels is assigned to this variable.
  var labels;
  // The length of `labels` array.
  var labelCount;
  var labelsObj = Object.create( null );

  // Returned!
  var methods = Object.create( null );


  /**
   *
   * Resets the current instance for another round of evaluation; the class
   * labels defined at instance creation time are not touched.
   *
   * @return {undefined} nothing!
  */
  var reset = function ( ) {
    evaluated = false;
    cm = Object.create( null );
    precision = Object.create( null );
    recall = Object.create( null );
    fmeasure = Object.create( null );

    // Initialize confusion matrix and metrics.
    for ( var i = 0; i < labelCount; i += 1 ) {
      const row = labels[ i ];
      labelsObj[ row ] = true;
      cm[ row ] = Object.create( null );
      precision[ row ] = 0;
      recall[ row ] = 0;
      fmeasure[ row ] = 0;
      for ( var j = 0; j < labelCount; j += 1 ) {
        const col = labels[ j ];
        cm[ row ][ col ] = 0;
      }
    }
  }; // reset()

  /**
   *
   * Creates an instance of cross validator useful for machine learning tasks.
   *
   * @param {string} truth - the actual class label.
   * @param {string} guess - the predicted class label.
   * @return {boolean} returns true if the evaluation is successful. The evaluation
   * may fail if `truth` or `guess` is not in the array `classLabels` provided at
   * instance creation time; or if guess is equal to `unknown`.
  */
  var evaluate = function ( truth, guess ) {
    // If prediction failed then return false!
    if ( guess === unknown || !labelsObj[ truth ] || !labelsObj[ guess ] ) return false;
    // Update confusion matrix.
    if ( guess === truth ) {
      cm[ truth ][ guess ] += 1;
    } else {
      cm[ guess ][ truth ] += 1;
    }
    evaluated = true;
    return true;
  }; // evaluate()

  /**
   *
   * It computes a detailed metrics consisting of macro-averaged precision,
   * recall and f-measure along with their label-wise values and the confusion
   * matrix.
   *
   * @return {object} object containing macro-averaged `avgPrecision`, `avgRecall`,
   * `avgFMeasure` values along with other details such as label-wise values
   * and the confusion matrix. A value of `null` is returned if no evaluate()
   * has been called before.
  */
  var metrics = function ( ) {
    if ( !evaluated ) return null;
    // Numerators for every label; they are same for precision & recall both.
    var n = Object.create( null );
    // Only denominators differs for precision & recall
    var pd = Object.create( null );
    var rd = Object.create( null );
    // `row` and `col` of confusion matrix.
    var col, row;
    var i, j;
    // Macro average values for metrics.
    var avgPrecision = 0;
    var avgRecall = 0;
    var avgFMeasure = 0;

    // Compute label-wise numerators & denominators!
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      for ( j = 0; j < labelCount; j += 1 ) {
        col = labels[ j ];
        if ( row === col ) {
          n[ row ] = cm[ row ][ col ];
        }
        pd[ row ] = cm[ row ][ col ] + ( pd[ row ] || 0 );
        rd[ row ] = cm[ col ][ row ] + ( rd[ row ] || 0 );
      }
    }
    // Ready to compute metrics.
    for ( i = 0; i < labelCount; i += 1 ) {
      row = labels[ i ];
      precision[ row ] = +( n[ row ] / pd[ row ] ).toFixed( 4 );
      // NaN can occur if a label has not been encountered.
      if ( isNaN( precision[ row ] ) ) precision[ row ] = 0;

      recall[ row ] = +( n[ row ] / rd[ row ] ).toFixed( 4 );
      if ( isNaN( recall[ row ] ) ) recall[ row ] = 0;

      fmeasure[ row ] = +( 2 * precision[ row ] * recall[ row ] / ( precision[ row ] + recall[ row ] ) ).toFixed( 4 );
      if ( isNaN( fmeasure[ row ] ) ) fmeasure[ row ] = 0;
    }
    // Compute thier averages, note they will be macro avegages.
    for ( i = 0; i < labelCount; i += 1 ) {
      avgPrecision += ( precision[ labels[ i ] ] / labelCount );
      avgRecall += ( recall[ labels[ i ] ] / labelCount );
      avgFMeasure += ( fmeasure[ labels[ i ] ] / labelCount );
    }
    // Return metrics.
    return (
      {
        // Macro-averaged metrics.
        avgPrecision: +avgPrecision.toFixed( 4 ),
        avgRecall: +avgRecall.toFixed( 4 ),
        avgFMeasure: +avgFMeasure.toFixed( 4 ),
        details: {
          // Confusion Matrix.
          confusionMatrix: cm,
          // Label wise metrics details, from those averages were computed.
          precision: precision,
          recall: recall,
          fmeasure: fmeasure
        }
      }
    );
  }; // metrics()

  if ( !helpers.validate.isArray( classLabels ) ) {
    throw Error( 'cross validate: class labels must be an array.' );
  }
  if ( classLabels.length < 2 ) {
    throw Error( 'cross validate: at least 2 class labels are required.' );
  }
  labels = classLabels;
  labelCount = labels.length;

  reset();

  methods.reset = reset;
  methods.evaluate = evaluate;
  methods.metrics = metrics;

  return methods;
}; // cross()

// ### Object Helpers

helpers.string = Object.create( null );

// Regex for [diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) removal.
var rgxDiacritical = /[\u0300-\u036f]/g;

/**
 *
 * Normalizes the token's value by converting it to lower case and stripping
 * the diacritical marks (if any).
 *
 * @param {string} str — that needs to be normalized.
 * @return {string} the normalized value.
 * @example
 * normalize( 'Nestlé' );
 * // -> nestle
*/
helpers.string.normalize = function ( str ) {
  return (
    str.toLowerCase().normalize( 'NFD' ).replace( rgxDiacritical, '' )
  );
}; // normalize()

helpers.getOptions = function (options,selected) {
  var options2 = {}
  selected.forEach(function (opt) { options2[opt]=options[opt] })
  return options2;
}
helpers.updateOptions = function (options,update) {
  for(var p in options) if (update[p]!=undefined) options[p]=update[p];
  return options;
}
module.exports = helpers;
};
FilesEmbedded['plugins/ml/help.md']=function (format){return Base64.decode('JTIzJTIwTUwlMEElMEElMjMlMjMlMjBVdGlscyUwQSUwQVNjYWxpbmclMjAlM0ElMjAlN0IlN0QlMEElMjAlMjBrJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwb2ZmJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwc2hpZnQlMjAlM0IlMjBudW1iZXIlMEElMjAlMjBtaW4lMjAlM0ElMjBudW1iZXIlMEElMjAlMjBtYXglMjAlM0ElMjBudW1iZXIlMEElMjAlMjAlMEFNTC5zY2FsZSUyMCUzQSUyMGZ1bmN0aW9uJTIwJTI4ZGF0YSUyQ3NjYWxlcyUyOSUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMjAlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTIwJTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUzQSUyMCU3QiUyNGF0dHIlM0FudW1iZXIlN0QlMjAlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTNBJTIwJTdCJTI0YXR0ciUzQW51bWJlciU3RCUyMCU1QiU1RCUwQSUyMCUyMHNjYWxlcyUyMCUzQSUyMFNjYWxpbmclMEElMjAlMjBzY2FsZXMlMjAlM0ElMjBTY2FsaW5nJTIwJTVCJTVEJTBBJTIwJTIwc2NhbGVzJTIwJTNBJTIwJTdCJTIwJTI0YXR0ciUyMCUzQSUyMFNjYWxpbmclMjAlN0QlMEElMEFNTC5zY2FsZTAlMjAlM0ElMjBmdW5jdGlvbiUyMCUyOGRhdGElMkNsb3dlciU2MCUyQ3VwcGVyJTNGJTI5JTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTNBJTIwJTdCJTIwJTI0YXR0ciUzQW51bWJlciUyMCU3RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjAlN0IlMjAlMjRhdHRyJTNBbnVtYmVyJTIwJTdEJTIwJTVCJTVEJTBBJTIwJTIwJTBBJTIzJTIzJTIwQU5OJTBBJTBBV1dXJTIwJTNBJTIwaHR0cHMlM0EvL3dhZ2VuYWFydGplLmdpdGh1Yi5pby9uZWF0YXB0aWMvJTBBJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTIwJTVCJTVEJTIwJTIzJTIwcmVjb3JkJTIwYXJyYXklMEElMjAlMjBpbnB1dCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUyMCUyMG91dHB1dCUyMCUzQSUyMG51bWJlciUyMCUyMCU1QiU1RCUwQVRyYWluJTIwRGF0YSUyMCUzQSUyMCU3QiU3RCUwQSUyMCUyMHglMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTBBRGF0YSUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQURhdGElMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMjAlMEElMEFNb2RlbCUyMFBhcmFtdGVyJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIwYWxnb3JpdGhtJTIwJTNBJTIwTUwuTUwuQU5OJTBBJTIwJTIwYWN0aXZhdGlvbiUzRiUzQSUyMHN0cmluZyUyMCU1QiU1RCUyMCUyMyUyMFJFTFUlMkMlMjBJREVOVElUWSUyQyUyMExPR0lTVElDJTJDJTIwU1RFUCUwQSUyMCUyMGxheWVycyUyMCUzQSUyMG51bWViciUyMCU1QiU1RCUwQSUwQVRyYWluaW5nJTIwUGFyYW1ldGVyJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIwcmF0ZSUzRiUyMCUzQSUyMG51bWJlciUwQSUyMCUyMGl0ZXJhdGlvbnMlM0YlMjAlM0ElMjBudW1iZXIlMEElMjAlMjBlcnJvciUzRiUyMCUzQSUyMG51bWJlciUwQSUyMCUyMGRyb3B1dCUzRiUyMCUzQSUyMG51bWJlciUyQyUwQSUyMCUyMG1vbWVudHVtJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwYmF0Y2hTaXplJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwY3Jvc3NWYWxpZGF0ZSUzRiUyMCUzQSUyMCUwQSUyMCUyMCUyMCUyMHRlc3RTaXplJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwJTIwJTIwdGVzdEVycm9yJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwY2xlYXIlM0YlMjAlM0ElMjBib29sZWFuJTBBJTIwJTIwbG9nJTNGJTIwJTNBJTIwYm9vbGVhbiUwQSUyMCUyMHJhdGVQb2xpY3klM0YlMjAlM0ElMjBzdHJpbmclMEElMEFNTC5sZWFybmVyJTIwJTNBJTIwZnVuY3Rpb24lMEElMjAlMjBtb2RlbCUyMCUzQSUyME1vZGVsJTIwUGFyYW10ZXIlMjAlMEElMjAlMjByZXR1cm4lMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMCUwQU1MLnRyYWluJTIwJTNBJTIwZnVuY3Rpb24lMEElMjAlMjBtb2RlbCUyMCUyMCUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUyMCUzQSUyMFRyYWluJTIwRGF0YSUwQSUyMCUyMG9wdGlvbnMlMjAlM0ElMjBUcmFpbmluZyUyMFBhcmFtZXRlciUwQSUwQU1MLnByZWRpY3QlMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMG1vZGVsJTIwJTIwJTIwJTNBJTIwbW9kZWwlMjAlN0IlN0QlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTIwJTNBJTIwRGF0YSUwQSUyMCUyMCUwQSUyMyUyMyUyMENOTiUwQSUwQVdXVyUyMCUzQSUyMGh0dHBzJTNBLy9naXRodWIuY29tL2thcnBhdGh5L2NvbnZuZXRqcyUwQSUwQVRyYWluJTIwRGF0YSUyMCUzQSUyMCU3QiU3RCUwQSUyMCUyMHglMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMjAlMjMlMjBkZXB0aCUzRDElMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCU1QiU1RCU1QiU1RCUyMCUyMyUyMGRlcHRoJTNFMSUwQSUyMCUyMHklMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlN0IlN0QlMEElMjAlMjB4JTIwJTNBJTIwYnVmZmVyJTIwJTVCJTVEJTIwJTIzJTIwUkdCL1JHQkElMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMHVpbnQ4YXJyYXklMjAlNUIlNUQlMjAlMjMlMjBSR0IvUkdCQSUwQSUyMCUyMHklMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlN0IlN0QlMEElMjAlMjB4JTIwJTNBJTIwbWF0cml4VGElMjAlNUIlNUQlMEElMjAlMjB5JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTBBJTBBRGF0YSUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCU1QiU1RCUwQURhdGElMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlNUIlNUQlMEFEYXRhJTIwJTNBJTIwYnVmZmVyJTIwJTVCJTVEJTBBRGF0YSUyMCUzQSUyMG1hdHJpeFRBJTIwJTVCJTVEJTBBJTBBTW9kZWwlMjBQYXJhbWV0ZXIlMjAlM0ElMjAlN0IlN0QlMEElMjAlMjBhbGdvcml0aG0lMjAlM0ElMjBNTC5NTC5DTk4lMEElMjAlMjBsYXllcnMlMjAlM0ElMjAlNUIlNUQlMEElMjAlMjAlMjAlMjAlN0J0eXBlJTIwJTNEJTIwJTI3aW5wdXQlMjclMkMlMjBvdXRfc3glM0FudW1iZXIlMkMlMjBvdXRfc3klM0FudW1iZXIlMkMlMjBvdXRfZGVwdGglM0FudW1iZXIlN0QlMEElMjAlMjAlMjAlMjAlN0J0eXBlJTIwJTNEJTIwJTI3Y29udiUyNyUyQyUyMHN4JTNBbnVtYmVyJTJDJTIwZmlsdGVycyUzQW51bWJlciUyQyUyMHN0cmlkZSUzQW51bWJlciUyQyUyMHBhZCUzQW51bWJlciUyQyUyMGFjdGl2YXRpb24lM0ElMjBzdHJpbmclMjAlM0QlMjElMjAlMjdyZWx1JTI3JTdEJTBBJTIwJTIwJTIwJTIwJTdCdHlwZSUyMCUzRCUyMCUyN3Bvb2wlMjclMkMlMjBzeCUzQW51bWJlciUyQyUyMHN0cmlkZSUzQW51bWJlciU3RCUwQSUyMCUyMCUyMCUyMCU3QnR5cGUlMjAlM0QlMjAlMjdzb2Z0bWF4JTI3JTJDJTIwbnVtX2NsYXNzZXMlM0FudW1iZXIlN0QlMEElMjAlMjB0cmFpbmVyJTIwJTNBJTIwJTBBJTIwJTIwJTIwJTIwbWV0aG9kJTIwJTNBJTIwc3RyaW5nJTIwJTNEJTIwJTI3YWRhZGVsdGElMjclMjAlMEElMjAlMjAlMjAlMjBsMl9kZWNheSUyMCUzQSUyMG51bWJlciUyMCUzRCUyMSUyMDAuMDAxJTIwJTBBJTIwJTIwJTIwJTIwYmF0Y2hfc2l6ZSUyMCUzQSUyMG51bWJlciUyMCUzRCUyMSUyMDEwJTBBJTIwJTIwZGF0YXR5cGUlM0YlMjAlM0ElMjBzdHJpbmclMjAlM0QlMjAlMjdGbG9hdDMyJTI3JTdDJTI3RmxvYXQ2NCUyNyUwQSUwQVRyYWluJTIwUGFyYW1ldGVyJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMGRhdGElMEElMjAlMjB5JTIwJTNBJTIwZGF0YSUwQSUyMCUyMHdpZHRoJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwaGVpZ2h0JTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwZGVwdGglMjAlM0ElMjBudW1iZXIlMEElMjAlMjBub3JtYWxpemUlMjAlM0ElMjBudW1iZXIlMjAlNUIyJTVEJTBBJTIwJTIwaXRlcmF0aW9ucyUyMCUzQSUyMG51bWJlciUwQSUyMCUyMGNhbGxiYWNrJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjhyZXN1bHQlM0ElN0IlN0QlMkNpdGVyYXRpb24lMjklMjAtJTNFJTIwbW9yZSUzRiUzQWJvb2xlYW4lMEElMjAlMjB2ZXJib3NlJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTBBTUwubGVhcm5lciUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlM0ElMjBNb2RlbCUyMFBhcmFtdGVyJTIwJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwbW9kZWwlMjAlN0IlN0QlMEElMjAlMjAlMEFNTC50cmFpbiUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlMjAlMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlMjAlM0ElMjBUcmFpbiUyMERhdGElMEElMjAlMjBvcHRpb25zJTIwJTNBJTIwVHJhaW5pbmclMjBQYXJhbWV0ZXIlMEElMEFNTC5wcmVkaWN0JTIwJTNBJTIwZnVuY3Rpb24lMEElMjAlMjBtb2RlbCUyMCUyMCUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTIwJTIwZGF0YSUyMCUyMCUyMCUyMCUzQSUyMERhdGElMEElMEElMjMlMjMlMjBNTFAlMEElMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlMEElMjAlMjB4JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTIwJTIweSUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUwQURhdGElMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlNUIlNUQlMEElMEFNb2RlbCUyMFBhcmFtZXRlciUyMCUzQSUwQSUyMCUyMGFsZ29yaXRobSUyMCUzQSUyME1MLk1MLk1MUCUwQSUyMCUyMGxheWVycyUyMCUzQSUyMCU1QiU1RCUwQSUwQVRyYWluJTIwUGFyYW1ldGVyJTBBJTIwJTIweCUyMCUzQSUyMGRhdGElMEElMjAlMjB5JTIwJTNBJTIwZGF0YSUwQSUyMCUyMGVwb2NocyUyMCUzQSUyMG51bWJlciUwQSUwQU1MLmxlYXJuZXIlMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMG1vZGVsJTIwJTNBJTIwTW9kZWwlMjBQYXJhbXRlciUyMCUwQSUyMCUyMHJldHVybiUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTIwJTIwJTBBTUwudHJhaW4lMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMG1vZGVsJTIwJTIwJTIwJTNBJTIwbW9kZWwlMjAlN0IlN0QlMEElMjAlMjBkYXRhJTIwJTIwJTIwJTIwJTNBJTIwVHJhaW4lMjBEYXRhJTBBJTIwJTIwb3B0aW9ucyUyMCUzQSUyMFRyYWluaW5nJTIwUGFyYW1ldGVyJTBBJTBBTUwucHJlZGljdCUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlMjAlMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMGRhdGElMjAlMjAlMjAlMjAlM0ElMjBEYXRhJTBBJTBBJTIzJTIzJTIwUlQlMEElMEFXV1clMjAlM0ElMjBodHRwcyUzQS8vZ2l0aHViLmNvbS93aW5ranMvd2luay1yZWdyZXNzaW9uLXRyZWUlMEElMEFUcmFpbmluZyUyMERhdGElMjAlM0ElMjAlN0IlN0QlMjAlNUIlNUQlMjAlMjMlMjByZWNvcmQlMjBhcnJheSUwQSUyMCUyMCUyNG5hbWUlMjAlM0ElMjBudW1iZXIlMjAlN0MlMjBzdHJpbmclMEElMEFEYXRhJTIwJTNBJTIwJTdCJTdEJTIwJTIzJTIwcmVjb3JkJTIwJTBBJTIwJTIwJTI0bmFtZSUyMCUzQSUyMG51bWJlciUyMCU3QyUyMHN0cmluZyUwQURhdGElMjAlM0ElMjAlN0IlN0QlMjAlNUIlNUQlMjAlMjMlMjByZWNvcmQlMjBhcnJheSUwQSUyMCUyMCUyNG5hbWUlMjAlM0ElMjBudW1iZXIlMjAlN0MlMjBzdHJpbmclMEElMEFNb2RlbCUyMFBhcmFtZXRlciUyMCUzQSUwQSUyMCUyMGFsZ29yaXRobSUyMCUzQSUyME1MLk1MLlJUJTBBJTIwJTIwZmVhdHVyZXMlMjAlM0ElMjAlNUIlNUQlMEElMjAlMjAlMjAlMjBuYW1lJTIwJTNBJTIwc3RyaW5nJTBBJTIwJTIwJTIwJTIwY2F0ZWdvcmljYWwlMjAlM0ElMjBib29sZWFuJTBBJTIwJTIwJTIwJTIwZXhjbHVkZSUyMCUzQSUyMGJvb2xlYW4lMEElMjAlMjB0YXJnZXQlMjAlMjAlMjAlM0ElMEElMjAlMjAlMjAlMjBuYW1lJTIwJTNBJTIwc3RyaW5nJTBBJTIwJTIwJTIwJTIwY2F0ZWdvcmljYWwlMjAlM0ElMjBib29sZWFuJTIwJTNEJTIwZmFsc2UlMEElMjAlMjBtaW5QZXJjZW50VmFyaWFuY2VSZWR1Y3Rpb24lMjAlM0ElMjBudW1iZXIlMjAlM0QlM0YlMjAwLjUlMEElMjAlMjBtaW5MZWFmTm9kZUl0ZW1zJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMTAlMEElMjAlMjBtaW5TcGxpdENhbmRpZGF0ZUl0ZW1zJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMzAlMEElMjAlMjBtaW5BdmdDaGlsZHJlbkl0ZW1zJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMiUwQSUwQSUyMCUyMCUyMCUyMCUwQSUyMyUyMyUyMFNWTSUwQSUwQVdXVyUyMCUzQSUyMGh0dHBzJTNBLy9naXRodWIuY29tL2thcnBhdGh5L3N2bWpzJTBBJTBBVHJhaW4lMjBEYXRhJTIwJTNBJTIwJTdCJTdEJTBBJTIwJTIweCUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCU1QiU1RCUwQSUyMCUyMHklMjAlM0ElMjBudW1iZXIlMjAlN0ItMSUyQzElN0QlNUIlNUQlMEFUcmFpbiUyMERhdGElMjAlM0ElMjAlN0IlN0QlMEElMjAlMjB4JTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTIwJTIweSUyMCUzQSUyMG51bWJlciUyMHN0cmluZyUyMCU1QiU1RCUyMCUyMyUyME11bHRpLVNWTSUwQSUwQURhdGElMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlNUIlNUQlMEFEYXRhJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTVCJTVEJTVCJTVEJTBBJTBBTW9kZWwlMjBQYXJhbWV0ZXIlMjAlM0ElMjAlN0IlN0QlMEElMjAlMjBhbGdvcml0aG0lMjAlMjAlMjAlM0ElMjBNTC5NTC5TVk0lMEElMjAlMjBDJTNGJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMS4wJTBBJTIwJTIwdG9sJTNGJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTNGJTIwMWUtNCUwQSUyMCUyMG1heF9wYXNzZXMlM0YlMjAlM0ElMjBudW1iZXIlMjAlM0QlM0YlMjAyMCUwQSUyMCUyMGFscGhhX3RvbCUzRiUyMCUyMCUzQSUyMG51bWJlciUyMCUzRCUzRiUyMDFlLTUlMEElMjAlMjBrZXJuZWwlM0YlMjAlMjAlM0ElMjAlMjAlMjMlMjByYmYlMjBrZXJuZWwlMEElMjAlMjAlMjAlMjAlMjB0eXBlJTIwJTIwJTNBJTIwJTIycmJmJTIyJTBBJTIwJTIwJTIwJTIwJTIwc2lnbWElMjAlM0ElMjBudW1iZXIlMjAlM0QlM0YlMjAwLjUlMEElMjAlMjBrZXJuZWwlM0YlMjAlM0ElMjAlMjAlMjMlMjBwb2x5bm9taWFsJTIwa2VybmVsJTBBJTIwJTIwJTIwJTIwJTIwdHlwZSUyMCUzQSUyMCUyMnBvbHlub21pYWwlMjIlMEElMjAlMjAlMjAlMjAlMjBjJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTIwJTNEJTIxJTIwMSUyMCUwQSUyMCUyMCUyMCUyMCUyMGQlMjAlMjAlMjAlMjAlM0ElMjBudW1iZXIlMjAlM0QlMjElMjA1JTBBJTIwJTIwbGFiZWxzJTNGJTIwJTNBJTIwc3RyaW5nJTVCJTVEJTIwJTIwJTIwJTIzJTIwTXVsdGktU1ZNJTBBJTBBUHJlZGljdCUyME91dHB1dCUyMCUzQSUyMG51bWJlciUyMCUwQVByZWRpY3QlMjBPdXRwdXQlMjAlM0ElMjAlMjAlNUIlNUQlMjAlMjMlMjBNdWx0aS1TVk0lMEElMjAlMjAlMjB2YWx1ZSUyMCUzQSUyMHN0cmluZyUwQSUyMCUyMCUyMHByb2IlMjAlMjAlM0ElMjBudW1iZXIlMEElMjAlMjAlMEFNTC5sZWFybiUyMCUzQSUyMGZ1bmN0aW9uJTBBJTIwJTIwbW9kZWwlMjAlMjAlM0ElMjBNb2RlbCUyMFBhcmFtdGVyJTIwd2l0aCUyMFRyYWluJTIwRGF0YSUwQSUyMCUyMHJldHVybiUyMCUzQSUyMG1vZGVsJTIwJTdCJTdEJTBBJTBBTUwubGVhcm4lMjAlM0ElMjBmdW5jdGlvbiUwQSUyMCUyMGRhdGElMjAlMjAlMjAlM0ElMjBEYXRhJTBBJTIwJTIwbW9kZWwlMjAlMjAlM0ElMjBtb2RlbCUyMCU3QiU3RCUwQSUyMCUyMHJldHVybiUyMCUzQSUyMFByZWRpY3QlMjBPdXRwdXQlMEElMEElMEE=')};

Base64=Require('os/base64');
//Buffer=Require('os/buffer').Buffer;
window.ML=ML = Require('plugins/ml/ml.js');
</script>
    <script>var CoreModule = {};
CoreModule['com/io']='com/io.browser';
CoreModule['crypto']='os/crypto';
CoreModule['util']='os/util';
CoreModule['http']='os/http.browser';
CoreModule['url']='os/url';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['fs']='';
CoreModule['stream']='';
CoreModule['zlib']='';
CoreModule['dgram']='';
CoreModule['net']='';
CoreModule['child_process']='';
CoreModule['dns']='';
CoreModule['buffer']='os/buffer';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
// PATH=[".","/home/sbosse/proj/workbook/src"];
if (typeof global == "undefined")  global=(typeof window != "undefined"?window:{})
if (typeof process == "undefined") var process={browser:true};
Require=function(modupath) {
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}, module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,window,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,window,process);
  else return undefined;
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
var FilesEmbedded = {};
var FileEmbedd = function (path,format) {};
var FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='browser';
Script=function(){};

BundleModuleCode['os/buffer']=function (module,exports,global,process){
var Ieee754 = Require('os/buffer_ieee754');

/* ------- base64-js -------- */
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}
/* ------- base64-js -------- */

var assert;

exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= {
    ok : function(cond,msg) {
      if (cond != true) {
        console.log('** Assertion failed: '+msg+' **');
        throw Error(msg);
      }
    }
  };
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new TypeError('First argument needs to be a number, ' +
                            'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          // Round-up subject[i] to a UInt8.
          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
          //                                  = 80
          this[i] = ((subject[i] % 256) + 256) % 256;
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var b = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(b)) throw new Error('Invalid hex string');
    this[offset + i] = b;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }
  // TODO
  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
};
BundleModuleCode['os/buffer_ieee754']=function (module,exports,global,process){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};
};
BundleModuleCode['com/io.browser']=function (module,exports,global,process){
    /*
    ************
    ** Browser
    ************
    */

    var tracing = true;
    var stderr_fun = function (str) { console.log(str); };
    var stdout_fun = function (str) { console.log(str); };
    var args=[];

    module.exports = {
        checkOptions : function(options,defaultOptions) {
          return Object.assign({}, defaultOptions||{}, options) },

        checkOption : function (option,defaultOption) { 
          return option==undefined? defaultOption:option },

        config: {
            columns:undefined,
            rows:undefined
        },
        /*
         ** FILE IO
         * TODO WebStorage
         */
        close: function (fd) {
            return;
        },
        exists: function (path) {
            return false;
        },
        open: function (path, mode) {
            var fd = Fs.openSync(path, mode);
            return fd;
        },

        read: function (fd, len, foff) {
            // TODO
        },
        read_file: function (path) {
            return '';
        },

        read_line: function (fd) {
            // TODO
        },
        /**
         *
         * @param fd
         * @param buf
         * @param boff
         * @param len
         * @param [foff]
         * @returns {*}
         */
        read_buf: function (fd, buf, boff, len, foff) {
            return -1;
        },
        sync: function (fd) {
            return;
        },
        
        /**
         *
         * @param fd
         * @param data
         * @param [foff]
         * @returns {*}
         */
        write: function (fd, data, foff) {
            return -1;
        },
        /**
         *
         * @param fd
         * @param buf
         * @param bpos
         * @param blen
         * @param [foff]
         * @returns {*}
         */
        write_buf: function (fd, buf, bpos, blen, foff) {
            return -1;
        },

        /*
         ** CONSOLE IO
         */
        debug: function (msg) {
            stderr_fun('Debug: ' + msg);
        },
        err: function (msg) {
            stderr_fun('Error: ' + msg);
            throw Error(msg);
        },
        fail: function (msg) {
            stderr_fun('Fatal Error: ' + msg);
        },
        inspect: function (obj) {
            return;
        },
        stacktrace: function () {
            var e = new Error('dummy');
            var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                .split('\n');
            stderr_fun('Stack Trace');
            stderr_fun('--------------------------------');
            for(var i in stack) {
                if (i>0) {
                    var line = stack[i];
                    if(line.indexOf('Module.',0)>=0) break;
                    stderr_fun(line);
                }
            }
            stderr_fun('--------------------------------');
        },
        time : function () {
          return Date.now()
        },
        /**
         *
         * @param e
         * @param where
         */
        printstack: function (e,where) {
            if (where==undefined) stderr_fun(e);
            else stderr_fun(where+': '+e);
        },
        /**
         *
         * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
         */
        log: function (condmsg) {
            if (condmsg != true) console.warn(condmsg);
        },
        out: function (msg) {
            stdout_fun(msg)
        },
        warn: function (msg) {
            stderr_fun('Warning: ' + msg);
        },


        set_stderr: function(fun) {
            stderr_fun=fun;
        },
        set_stdout: function(fun) {
            stdout_fun=fun;
        },

        stderr: function (msg) {
            stderr_fun(msg);
        },
        stdout: function (msg) {
            stdout_fun(msg);
        },

        /** Write a message with a time stamp written to the trace file.
         *
         * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
         */
        trace: function (condmsg) {
            if (condmsg != true && tracefile != undefined) {
                var date = new Date();
                var time = date.getTime();
                this.log('[' + time + '] ' + condmsg + '\n');
            }
        },
        tracing: tracing,
        /**
         *
         * @param {string} path
         */
        trace_open: function (path) {
            return undefined;
        },

        exit: function (n) {
            return;
        },
        /**
         *
         * @returns {*} RSS HEAP in kBytes {data,heap}
         */
        mem: function () {
            return {data:0,heap:0};
        },

        getenv: function (name, def) {
            return def;
        },
        workdir: function () {
            return '';
        },
        /**
         *  @return {string []}
         */
        getargs: function () {
            return args;
        },
        set_args: function (argv) {
            args=argv;
        }
    };
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['os/util']=function (module,exports,global,process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = function isBuffer(arg) {
  return arg && typeof arg === 'object'
             && typeof arg.copy === 'function'
             && typeof arg.fill === 'function'
             && typeof arg.readUInt8 === 'function';
};

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */

exports.inherits = Require('os/inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
};
BundleModuleCode['os/inherits']=function (module,exports,global,process){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['plugins/plot/plot.js']=function (module,exports,global,process){
// Auto data plotter using chartjs library and custom plotters
// TODO: uniform format { cell, index, id, options }
// TODO: refactor code


Object.updateProperty(Array,'get', function (i,j,k) {
  if (k!=undefined)
   return this[i][j][k];
  else if (j!=undefined)
   return this[i][j];
  else
   return this[i];
})
function getOption(option,defaultValue) {
  return option!=undefined?option:defaultValue
}
function getOptionIndex(option,index,defaultValue) {
  if (option == undefined) return defaultValue;
  if (option instanceof Array)
    return option[index]!=undefined?option[index]:defaultValue;
  else 
    return option
}
function MinMax (data,key) {
  var min,max;
  if (Utils.isArrayArray(data) && typeof (data[0] && data[0][0]) =='number') {
    for(var i=0;i<data.length;i++) {
      for (var j=0;j<data[i].length;j++) {
        if (min==undefined) { min=data[i][j];max=data[i][j] }
        else { min=Math.min(min,data[i][j]); max=Math.max(max,data[i][j]) }
      }
    }
  }
  else if (Utils.isArray(data) && typeof data[0]=='number') {
    for(var i=0;i<data.length;i++) {
      if (min==undefined) { min=data[i];max=data[i] }
      else { min=Math.min(min,data[i]); max=Math.max(max,data[i]) }
    }
  }
  else if (Utils.isArray(data) && key != undefined && typeof data[0][key]=='number') {
    for(var i=0;i<data.length;i++) {
      if (min==undefined) { min=data[i][key];max=data[i][key] }
      else { min=Math.min(min,data[i][key]); max=Math.max(max,data[i][key]) }
    }
  }
  else if (Utils.isArray(data) && typeof data[0].x=='number' && typeof data[0].y=='number') {
    var xmin,xmax,ymin,ymax;
    for(var i=0;i<data.length;i++) {
      if (xmin==undefined) { xmin=data[i].x;xmax=data[i].x; ymin=data[i].y;ymax=data[i].y;}
      else { xmin=Math.min(xmin,data[i].x); xmax=Math.max(xmax,data[i].x); 
             ymin=Math.min(ymin,data[i].y); ymax=Math.max(ymax,data[i].y);}
    }
    return { x:{ min:xmin,max:ymax }, y:{ min:ymin,max:ymax }}
  }
  return { min:min,max:max }
}
if (typeof int == 'undefined') int=function(r) { return r|0 };

var Plotter = {
  color : [
      'rgb(255, 99, 132)',
      'rgb(99, 255, 132)',
      'rgb(132, 99, 255)',
      'rgb(255, 146, 18)',
      'rgb(128, 20, 20)',
      'rgb(20, 128, 20)',
      'rgb(20, 20, 128)',
      'rgb(160, 20, 200)',
      'rgb(128, 250, 250)',
      'rgb(128, 128, 128)',
      'black',  // colorindex=10
      'red', 
      'blue',
      'green',
      'rgb(16, 16, 16)',
      'rgb(32, 32, 32)',
      'rgb(48, 48, 48)',
      'rgb(64, 64, 64)',
      'rgb(80, 80, 80)',
      'rgb(96, 96, 96)',
      'rgb(112, 112, 112)',
      'rgb(128, 128, 128)',
      'rgb(144, 144, 144)',
      'rgb(160, 160, 160)',
    ],
  colorArray : [
      [255, 99, 132],
      [99, 255, 132],
      [132, 99, 255],
      [255, 146, 18],
      [128, 20, 20],
      [20, 128, 20],
      [20, 20, 128],
      [160, 20, 200],
      [128, 250, 250],
      [128, 128, 128],
      [0, 0, 0],
      [255,0,0],
      [0,255,0],
      [0,0,255],
      [16, 16, 16],
      [32, 32, 32],
      [48, 48, 48],
      [64, 64, 64],
      [80, 80, 80],
      [96, 96, 96],
      [112, 112, 112],
      [128, 128, 128],
      [144, 144, 144],
      [160, 160, 160],
    ],
  gradient : [
      'to right, rgba(255, 99, 132, 0), rgba(255, 99, 132, 1)',
      'to right, rgba(99, 255, 132, 0), rgba(99, 255, 132, 1)',
      'to right, rgba(132, 99, 255, 0), rgba(132, 99, 255, 1)',
      'to right, rgba(255, 146, 18, 0), rgba(255, 146, 18, 1)',
      'to right, rgba(128, 20, 20, 0), rgba(128, 20, 20, 1)',
      'to right, rgba(20, 128, 20, 0), rgba(20, 128, 20, 1)',
      'to right, rgba(20, 20, 128, 0), rgba(20, 20, 128, 1)',
      'to right, rgba(160, 20, 200, 0), rgba(160, 20, 200, 1)',
      'to right, rgba(128, 250, 250, 0), rgba(128, 250, 250, 1)',
      'to right, rgba(128, 128, 128, 0), rgba(128, 128, 128, 1)',
      'to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1)',
      'to right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1)',
      'to right, rgba(0, 255, 0, 0), rgba(0, 255, 0, 1)',
      'to right, rgba(0, 0, 255, 0), rgba(0, 0, 255, 1)',
      'to right, rgba(16, 16, 16, 0), rgba(16, 16, 16, 1)',
      'to right, rgba(32, 32, 32, 0), rgba(32, 32, 32, 1)',
      'to right, rgba(48, 48, 48, 0), rgba(48, 48, 48, 1)',
      'to right, rgba(64, 64, 64, 0), rgba(64, 64, 64, 1)',
      'to right, rgba(80, 80, 80, 0), rgba(80, 80, 80, 1)',
      'to right, rgba(96, 96, 96, 0), rgba(96, 96, 96, 1)',
      'to right, rgba(112, 112, 112, 0), rgba(112, 112, 112, 1)',
      'to right, rgba(128, 128, 128, 0), rgba(128, 128, 128, 1)',
      'to right, rgba(144, 144, 144, 0), rgba(144, 144, 144, 1)',
      'to right, rgba(160, 160, 160, 0), rgba(160, 160, 160, 1)',

    ],
  rainbow : function (f) {
    var a=(1-f)/0.25;	//invert and group
    var X=Math.floor(a);	//this is the integer part
    var Y=Math.floor(255*(a-X)); //fractional part from 0 to 255
    switch(X)
    {
        case 0: r=255;g=Y;b=0;break;
        case 1: r=255-Y;g=255;b=0;break;
        case 2: r=0;g=255;b=Y;break;
        case 3: r=0;g=255-Y;b=255;break;
        case 4: r=0;g=0;b=255;break;
    }            
    return 'rgb('+r+','+g+','+b+')';
  },

  // Format plot and return chart.js descriptor object
  format: function (data,options) {
    options=options||{};
    var name = options.name||'';
    var p,legend,subtitle,labels,ds,coln,rown,min,max;
    var color = Plotter.color,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
        
    function format(v,preci) {
      var s=String(v),dp=s.indexOf('.');
      if (dp==-1) return s;
      off=dp+1;
      while (s[off]=='0') off++;
      return s.substring(0,off+preci);       
    }
    // backward comp.
    if (options.image)  options.type='image';
    if (options.line)   options.type='line';
    if (options.stream) options.type='stream';

    if (options.type=='network') {    
      p=Plotter.network(data,options);
      return p;
    }
    
    // Vector/VectorTA compatibility
    if (Utils.isObj(data) && Utils.isVector(data,false,true) && data.data) {
      data=data.data;
    }
    if (Utils.isObj(data) && Utils.isMatrix(data,false,true) && data.data) {
      data=data.data;
    }
    if (Utils.isObj(data) && Utils.isVector(data.y1)) {
      data.y=data.y1;
    }
    if (Utils.isObj(data) && Utils.isVector(data.x,false,true) && data.x.data) {
      data.x=data.x.data;
    }
    if (Utils.isObj(data) && Utils.isVector(data.y,false,true) && data.y.data) {
      data.y=data.y.data;
    }
    if (Utils.isObj(data) && Utils.isVector(data.y2,false,true) && data.y2.data) {
      data.y2=data.y2.data;
    }
    if (!options.type) options.type='';
    // Function plot?
    if (Utils.isObj(data) && data.x && Utils.isArray(data.x) && typeof data.y == 'function') {
      data.y=data.x.map(data.y);
    } 
    // Data point and function plot?
    if (Utils.isObj(data) && data.x && Utils.isArray(data.x) && data.y && Utils.isArray(data.y) && typeof data.f == 'function') {
      data.y2=data.x.map(data.f);
    } 
    if (options.type=='histogram') {    
      p=Plotter.histogram(data,options);
    } else if (options.type=='scatter') {    
      p=Plotter.scatter(data,options);
    } else if (options.type=='line') {    
      p=Plotter.line(data,options);
    } else if (options.type=='pie'||options.type=='doughnut') {
      p=Plotter.pie(data,options);
    } else if (options.type=='pcp') {    
      p=Plotter.pcp(data,options);
    } else if (Utils.isArray(data) && typeof data[0] == 'number' && (options.type!='bar' || options.type=='line')) {
      // 1. Line plot: Number vector [y1,y2,..,yn]  
      p=Plotter.line(data,options);
    } else if (Utils.isArray(data[0]) && data[0].length && data[0].length>2 
               && options.type!='image' 
               && options.type != 'line'
               && options.type!='confusion') {
      p=Plotter.matrix(data,options);
      legend=options.legend;
    } else if ((Utils.isArrayArray(data)||Utils.isMatrix(data)||Utils.isTypedArray(data)||(data.data))
               && options.type=='image' 
               && options.type!='confusion') {
      p=Plotter.image(data,options);
      legend=options.legend;
    } else if ((Utils.isArrayArray(data)||Utils.isMatrix(data))
               && options.type=='confusion') {
      p=Plotter.confusion(data,options);
    } else if (Utils.isObj(data) && options.type=='bar') {
      p=Plotter.bar(data,options);
    } else if (Utils.isObj(data) && data.x && data.y && Utils.isArray(data.x) 
            && Utils.isArray(data.y) && data.y2 && Utils.isArray(data.y2)) {
      // 2b. Line plot:  x and y,y2 number arrays x:[1,2,3,4,..] y,y2:[y1,y2,..], y3?,y4?,..
      p=Plotter.line(data,options);
    } else if (Utils.isObj(data) && data.x && data.y && Utils.isArray(data.x) && Utils.isArray(data.y) &&
               !Utils.isObj(data.y[0])) {
      // 2. Line plot: x and y number array x:[1,2,3,4,..] y:[y1,y2,..]
      p = Plotter.line(data,options);
    } else if (data[0] && Utils.isObj(data[0]) && Object.keys(data[0]).length <= color.length) {
      // 4. Line plot: Data is array of records  [ {y1:,y2:,..}, .. ] or arrays of arrays (array matrix)
      p = Plotter.line(data,options);
    } else if (data.x && data.y && Utils.isObj(data.y[0]) && Object.keys(data.y[0]).length <= color.length) {
      // 3. Line plot : Array of records  x:[], y:[ {y1:,y2:,..}, .. ]
      p = Plotter.line(data,options);
    } else if (Utils.isTypedArray(data)) {
      // 3. Line plot : TypedArray. ]
      p = Plotter.line(data,options);
    } else if (Utils.isArray(data) && options.type=='stream') {
      // Data stream chart plot (smoothie.js)
      p = Plotter.stream(data,options);
      if (options.title) subtitle=options.title;
    }
    if (!p.options) p.options={}
    if (options.title)
      p.options.title =  {
        display:true,
        text:options.title
      }; else p.options.title =  {
        display:false,
      };
    if (legend) p.legend=legend;
    if (subtitle) p.subtitle=subtitle;
    if (options.size) p.size=options.size;
    return p;  
  },
  

  // Bar chart
  // typeof @data =
  // typeof @options =  { labels?:{data:[], legend?:string}, color?:string [], min?:number, max?:number}
  bar : function (data,options) {
    var p,min,max,ds,labels;
    var color = Plotter.color,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
    min = Infinity;
    max = -Infinity;
    if (options.labels && options.labels.data) {
      // multi-bar
      // data attribute is data set
      options.legend=true;
      labels=options.labels.data;
      ds=Object.keys(data).map(function (p,i) {
        return {
          label:p,
          backgroundColor:(typeof options.color == 'string'?options.color:
                            (typeof options.color == 'object'?options.color[i]||options.color[p]:color[i])),
          data:data[p]
        }
      })
    } else {
      // single bar 
      // data attribute is label
      labels=Object.keys(data);
      ds = [
        {
          label:'',
          backgroundColor:labels.map(function (p,i) { return (typeof options.color == 'string'?options.color:
                            (typeof options.color == 'object'?options.color[i]||options.color[p]:color[i])) }),
          data:labels.map(function (p) { return data[p] })
        }
      ];
      ds[0].data.forEach(function (v) {
        if (typeof v == 'object') {
          v=v.y;
        }
        min=Math.min(min,v);
        max=Math.max(max,v);        
      })
      options.legend=false;
    }
    p = {
      type : 'barWithErrorBars',
      data : {
        labels: labels,
        datasets: ds
      }, 
      options : {
        legend : {
          display: options.legend,
        },
        scales : {
          xAxes: [{
            // barPercentage: 0.4,
            maxBarThickness: 50,
            stacked: options.stacked,
          }],
          yAxes: [{
            stacked: options.stacked,
            ticks: {
                min:options.min,
                max:options.max,
                suggestedMin: options.min!=undefined?options.min:min,
                suggestedMax: options.max!=undefined?options.max:max
            },
            scaleLabel : (options.labels && options.labels.y)?{
              display:true,
              labelString:options.labels.y
            }:{display:false}
          }]        
        }
      }
    }
    // console.log(p)
    return p;  
  },
  
  
  // Confusion Matrix
  // typeof @data = numebr [][]
  // typeof @options = { labels?:{data:[],x?:string,y?:string}, height:number, width:number }
  confusion : function (data,options) {
    var p;
    var n=data.length;  // square matrix
    var labels=[]
    if (options.labels && options.labels.data) labels=options.labels.data;
    else {
      for(var i=0;i<n;i++) labels.push(String(i));
    } 
    p = {
      type: 'confusion',
      data:  data,
      options: {
        title:options.title,
        rows:n,
        cols:n,
        height:options.height||n*100,
        width:options.width||n*100,
        labels:{
          x:(options.labels&&options.labels.x)||'Actual Value',
          y:(options.labels&&options.labels.y)||'Predicted Value',
          data:labels
        }
      }
    } 
    return p;
  },
    
  histogram : function (data,options) {
    var i,p,min,max,delta,ds,labels;
    var color = Plotter.color,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
    if (options.min!=undefined) min=options.min;
    else {
      min = Infinity;
      for(i=0;i<data.length;i++) { min=Math.min(min,data[i]); } 
    }
    if (options.max!=undefined) max=options.max;
    else {
      max = -Infinity;
      for(i=0;i<data.length;i++) { max=Math.max(max,data[i]); } 
    }
    if (options.delta) delta=options.delta;
    else delta = (max-min)/100;
    
    var intervals=Math.ceil((max-min)/delta);
    var labels=[], histogram = [];
    for(i=0;i<intervals;i++) {labels.push('');histogram.push(0)};
    for(i=0;i<data.length;i++) {
      var chan=Math.floor((data[i]-min)/delta);
      histogram[chan]++;
    }
    labels[0]=min;
    labels[intervals-1]=max;
    // labels[Math.floor((intervals-1)/2)]=(max-min)/2-delta;  
    options.legend=false;
    min = 0;
    max = -Infinity;
    for(i=0;i<intervals;i++) { max=Math.max(max,histogram[i]) };
    ds=[{
       label:'',
       backgroundColor:options.color||color[0],   
       data:histogram
    }];
    p = {
      type : 'barWithErrorBars',
      data : {
        labels: labels,
        datasets: ds
      }, 
      options : {
        legend : {
          display: options.legend,
        },
        scales : {
          xAxes: [{
            // barPercentage: 0.4,
            maxBarThickness: 50,
          }],
          yAxes: [{
            ticks: {
                  suggestedMin: min,
                  suggestedMax: max
            },
            scaleLabel : (options.labels && options.labels.y)?{
              display:true,
              labelString:options.labels.y
            }:{display:false}
          }]        
        }
      }
    }
    // console.log(p)
    return p;  
  },
  
 
  // Image matrix plot
  // Matrix (number|record array array)|(matrix typedarray) -> canvas image visualization!
  image : function (data,options) {
    var p,rown,coln,i,j,min,max,legend,image,imgData;
    if (data.width && data.height && data.data) {
      image=data;
      imgData=data.data;
      if (imgData.data) imgData=imgData.data;
      var byteLength = imgData.length,
          depth = image.depth||byteLength/(image.width*image.height);
      options.zoom=options.zoom||1;
      // direct image plot
      if (depth!=4 || options.zoom!=1) {
        var _imgData=imgData;
        var z=options.zoom;
        imgData=new Uint8Array(image.width*image.height*4*z*z);
        if (z==1) {
          if (image.layout==21) {
            var q=0;  // TODO TBC
            if (depth==1) for(var i=0;i<image.width;i++) for(var j=0;j<image.height;j++) {
              imgData[q*4]=imgData[q*4+1]=imgData[q*4+2]=_imgData[j+image.width*i];
              imgData[q*4+3]=255;
              q++;
            }           
          } else {
            if (depth==1) for(var i=0;i<image.width*image.height;i++) {
              imgData[i*4]=imgData[i*4+1]=imgData[i*4+2]=_imgData[i];
              imgData[i*4+3]=255;
            }
            if (depth==3) for(var i=0;i<image.width*image.height;i++) {
              imgData[i*4]=_imgData[i*3];
              imgData[i*4+1]=_imgData[i*3+1];
              imgData[i*4+2]=_imgData[i*3+2];
              imgData[i*4+3]=255;
            };
          }
        } else {
          // TODO depth1,3, TBC
          if (depth==4 && z > 1) {
            for(var i=0;i<image.height;i++) for(var j=0;j<image.width;j++)
              for(k=0;k<z;k++) for(l=0;l<z;l++) {
                var dst=i*4*z*z*image.width+k*4*z*image.width+j*4*z+l*4,
                    src=i*4*image.width+j*4;
                // console.log(i,j,k,l,dst,src)
                imgData[dst]    = _imgData[src];
                imgData[dst+1]  = _imgData[src+1];
                imgData[dst+2]  = _imgData[src+2];
                imgData[dst+3]  = _imgData[src+3];
              }    
          }
          if (depth==4 && z < 1) {
            var l=(1/z)|0;
            // console.log(depth,z,image.width,image.height,l)
            for(var i=0;i<image.height;i+=l) for(var j=0;j<image.width;j+=l) {
                var dst=i*image.width*z*z*4+j*4*z,
                    src=i*4*image.width+j*4;
                // console.log(i,j,l,dst,src)
                imgData[dst]    = _imgData[src];
                imgData[dst+1]  = _imgData[src+1];
                imgData[dst+2]  = _imgData[src+2];
                imgData[dst+3]  = _imgData[src+3];
            }
          }
          if (depth==3 && z > 1) {
            for(var i=0;i<image.height;i++) for(var j=0;j<image.width;j++)
              for(k=0;k<z;k++) for(l=0;l<z;l++) {
                var dst=i*4*z*z*image.width+k*4*z*image.width+j*4*z+l*4,
                    src=i*3*image.width+j*3;
                // console.log(i,j,k,l,dst,src)
                imgData[dst]    = _imgData[src];
                imgData[dst+1]  = _imgData[src+1];
                imgData[dst+2]  = _imgData[src+2];
                imgData[dst+3]  = 255;
              }    
          }
          if (depth==3 && z < 1) {
            var l=(1/z)|0;
            // console.log(depth,z,image.width,image.height,l)
            for(var i=0;i<image.height;i+=l) for(var j=0;j<image.width;j+=l) {
                var dst=i*image.width*z*z*4+j*4*z,
                    src=i*3*image.width+j*3;
                // console.log(i,j,l,dst,src)
                imgData[dst]    = _imgData[src];
                imgData[dst+1]  = _imgData[src+1];
                imgData[dst+2]  = _imgData[src+2];
                imgData[dst+3]  = 255;
            }
          }
          if (depth==1 && z > 1) {
            for(var i=0;i<image.height;i++) for(var j=0;j<image.width;j++)
              for(k=0;k<z;k++) for(l=0;l<z;l++) {
                var dst=i*4*z*z*image.width+k*4*z*image.width+j*4*z+l*4,
                    src=i*1*image.width+j*1;
                // console.log(i,j,k,l,dst,src)
                imgData[dst]    = 
                imgData[dst+1]  = 
                imgData[dst+2]  = _imgData[src];
                imgData[dst+3]  = 255;
              }    
          }
          if (depth==1 && z < 1) {
            var l=(1/z)|0;
            // console.log(depth,z,image.width,image.height,l)
            for(var i=0;i<image.height;i+=l) for(var j=0;j<image.width;j+=l) {
                var dst=i*image.width*z*z*4+j*4*z,
                    src=i*1*image.width+j*1;
                // console.log(i,j,l,dst,src)
                imgData[dst]    = 
                imgData[dst+1]  = 
                imgData[dst+2]  = _imgData[src];
                imgData[dst+3]  = 255;
            }
          }
        }
      }
      p = {
        type: 'image',
        data:  imgData,
        options: {
          title:options.title,
          rows : image.height*options.zoom,
          cols : image.width*options.zoom,
          height:options.height||image.height,
          width:options.width||image.width,
          zoom:options.zoom,
          rgba : true,
        }
      }
    } else {
      var color = Plotter.color,
          colorArray = Plotter.colorArray,
          gradient = Plotter.gradient,
          colorIndex = options.colorIndex||0;
      function format(v,preci) {
        var s=String(v),dp=s.indexOf('.');
        if (dp==-1) return s;
        off=dp+1;
        while (s[off]=='0') off++;
        return s.substring(0,off+preci);       
      }
      if (Utils.isArrayArray(data)) {
        rown = data.length;
        coln = data[0].length;
      } else {
        rown = data.rows;
        coln = data.columns;
      }
      if (options.min != undefined && options.max != undefined) {
        min=options.min;
        max=options.max;
      } else {
        min = Infinity;
        max = -Infinity;
        for(i=0;i<rown;i++) for(j=0;j<coln;j++) {
          min=Math.min(min,data.get(i,j));
          max=Math.max(max,data.get(i,j));      
        }
        if (options.min!=undefined) min=options.min;
        if (options.max!=undefined) max=options.max;
      }  
      legend = {min:format(min,2),max:format(max,2), gradient:gradient[colorIndex], label:options.label};
      p = {
        type: 'image',
        data:  data,
        options: {
          color:colorArray[colorIndex],
          alpha:true,
          min:min,
          max:max,
          invert:options.invert,
          label:options.label,
          title:options.title,
          rows:rown,
          cols:coln,
          height:options.height||rown,
          width:options.width||coln,
          layout:data.layout,
          zoom:options.zoom||1,
          scale:{ k:1/(max-min), off:min }, // TODO
        }
      } 
      options.legend=legend;
    }
    return p;
  },
  
  // Line+Point plots (type=='line')
  // Line plots  (type=='line')
  // Point plots (type=='point')
  // typeof @data = {x,y} | [] | {}[] 
  // typeof @options = { points?:boolean, lines?:'straight'|'step'|false, 
  //                     min?:number, max?:number, 
  //                     color?:number|number [], 
  //                     axis?:{x,y}, 
  //                     data?:'row'|'column'.. }
  line :  function (data,options) {
    var p,name=options.name,labels;
    var color = Plotter.color,
        typ,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
    function isDataPoint(d) {
      return Utils.isNumber(d) || (Utils.isObject(d) && d.y != undefined &&
                                   d.yMin != undefined && d.yMax != undefined);
    }
    function isErrorPoint(d) {
      return (Utils.isObject(d) && d.y != undefined &&
              d.yMin != undefined && d.yMax != undefined);
    }
    if (Utils.isTypedArray(data)) {
      data=Array.from(data);
    }
    if (Utils.isArray(data) && isDataPoint(data[0])) {    
      // 1. Line plot: Dats is number vector [y1,y2,..,yn]
      typ = isErrorPoint(data[0])?'lineWithErrorBars':'line';
      p = {
        type : typ,
        data : {
          datasets : [{
            label:(options.labels && options.labels.data) || name,
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOption(options.color,0)],
            borderColor: color[getOption(options.color,0)],
            showLine: options.type=='point'?false:true,      
            data:data.map(function (y,x) { return typ=='line'?{x:x,y:y}:Object.assign({x:x},y) })
          }]
        },
        options : {
          scales: {
            xAxes: [{
              type: (options.axis && options.axis.x)||'linear',
              ticks: {
                    suggestedMin: options.xmin,
                    suggestedMax: options.xmax
              },
              scaleLabel : (options.labels && options.labels.x)?{
                display:true,
                labelString:options.labels.x
              }:{display:false}
              // ...
            }],
            yAxes: [{
              type: (options.axis && options.axis.y)||'linear',
              ticks: {
                    suggestedMin: options.min||options.ymin,
                    suggestedMax: options.max||options.ymax
              },
              scaleLabel : (options.labels && options.labels.y)?{
                display:true,
                labelString:options.labels.y
              }:{display:false}
              // ...
            }]

          }
        }
      }
    }
    if (data.x && data.y && Utils.isArray(data.y) && isDataPoint(data.y[0])) {  
      // 2a. Line plot: x and y number array x:[1,2,3,4,..] y:[y1,y2,..]
      typ = isErrorPoint(data.y[0])?'lineWithErrorBars':'line';
      p = {
        type : typ,
        data : {
          datasets : [{
            label:(options.labels && options.labels.data) || name,
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOption(options.color,0)],
            borderColor: color[getOption(options.color,0)],
            showLine: options.type=='point'?false:true,      
            data:data.x.map(function (x,i) { return typ=='line'?{x:x,y:data.y[i]}:Object.assign({x:x},data.y[i]) }),
          }]
        },
        options : {
          scales: {
            xAxes: [{
              type: (options.axis && options.axis.x)||'linear',
              ticks: {
                    suggestedMin: options.xmin,
                    suggestedMax: options.xmax
              },
              scaleLabel : (options.labels && options.labels.x)?{
                display:true,
                labelString:options.labels.x
              }:{display:false}
              // ...
            }],
            yAxes: [{
              type: (options.axis && options.axis.y)||'linear',
              ticks: {
                    suggestedMin: options.min||options.ymin,
                    suggestedMax: options.max||options.ymax
              },
              scaleLabel : (options.labels && options.labels.y)?{
                display:true,
                labelString:options.labels.y
              }:{display:false}
              // ...
            }]

          }
        }
      }
    }


    if (data.x && data.y && Utils.isArray(data.y) && isDataPoint(data.y[0]) && data.y2 && Utils.isArray(data.y2)) {  
      // 2b. Line plot:  x and y,y2 number arrays x:[1,2,3,4,..] y,y2:[y1,y2,..], y3?,y4?,..
      typ = isErrorPoint(data.y[0])?'lineWithErrorBars':'line';
      p = {
        type : typ,
        data : {
          datasets : [{
            label:(options.labels && options.labels.data && options.labels.data[0])||
                  (options.label&&options.label[0]||name+'-1'),
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOptionIndex(options.color,0,0)],
            borderColor: color[getOptionIndex(options.color,0,0)],
            showLine: options.type=='point'||options.type[0]=='point'?false:true,      
            data:data.x.map(function (x,i) { return typ=='line'?{x:x,y:data.y[i]}:Object.assign({x:x},data.y[i])}),
          },{
            label:(options.labels && options.labels.data && options.labels.data[1])||
                  (options.label&&options.label[1]||name+'-2'),
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOptionIndex(options.color,1,1)],
            borderColor: color[getOptionIndex(options.color,1,1)],
            pointRadius: data.f?0:3,
            showLine: options.type=='point'||options.type[1]=='point'?false:true,      
            data:data.x.map(function (x,i) { return typ=='line'?{x:x,y:data.y2[i]}:Object.assign({x:x},data.y2[i])}),
          }]
        },
        options : {
          scales: {
            xAxes: [{
              type: (options.axis && options.axis.x)||'linear',
              ticks: {
                    suggestedMin: options.xmin,
                    suggestedMax: options.xmax
              },
              scaleLabel : (options.labels && options.labels.x)?{
                display:true,
                labelString:options.labels.x
              }:{display:false}
              // ...
            }],
            yAxes: [{
              type: (options.axis && options.axis.y)||'linear',
              ticks: {
                    suggestedMin: options.min||options.ymin,
                    suggestedMax: options.max||options.ymax
              },
              scaleLabel : (options.labels && options.labels.y)?{
                display:true,
                labelString:options.labels.y
              }:{display:false}
              // ...
            }]

          }
        }
      }

      if (data.y3 && Utils.isArray(data.y3)) p.data.datasets.push({
            label:(options.labels && options.labels.data && options.labels.data[2])||
                  (options.label  && options.label[2]||name+'-3'),
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOptionIndex(options.color,2,2)],
            borderColor: color[getOptionIndex(options.color,2,2)],
            pointRadius: data.f?0:3,
            showLine: options.type=='point'||options.type[1]=='point'?false:true,      
            data:data.x.map(function (x,i) { return typ=='line'?{x:x,y:data.y3[i]}:Object.assign({x:x},data.y3[i])}),
          });
      if (data.y4 && Utils.isArray(data.y4)) p.data.datasets.push({
            label:(options.labels && options.labels.data && options.labels.data[3])||
                  (options.label&&options.label[3]||name+'-4'),
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOptionIndex(options.color,3,3)],
            borderColor: color[getOptionIndex(options.color,3,3)],
            pointRadius: data.f?0:3,
            showLine: options.type=='point'||options.type[1]=='point'?false:true,      
            data:data.x.map(function (x,i) { return typ=='line'?{x:x,y:data.y4[i]}:Object.assign({x:x},data.y4[i])}),
          });
    }
    
    
    if (data.x && data.y && Utils.isArray(data.y) && Utils.isObject(data.y[0]) && !isDataPoint(data.y[0])) {
      // 3. Line plot : Array of records  x:[], y:[ {y1:,y2:,..}, .. ] | number [][]
      if (options.data=='column') {
        // x:[[ds1],[ds2],..], y:[[ds1],[ds2],..]
        typ = isErrorPoint(data.y[0][0])?'lineWithErrorBars':'line';
        ds = data.x.map (function (x,i) {
          var label;
          if (!(options.labels && options.labels.date==false)) 
            label=(options.labels && options.labels.data && options.labels.data[i]) || (name?name+'.'+i:i) 
          return {
              label:label,
              fill:false,
              steppedLine:options.lines=='step'?'before':undefined,
              backgroundColor:color[getOptionIndex(options.color,i,i)],
              borderColor: color[getOptionIndex(options.color,i,i)],  
              showLine: options.type=='point'||options.type[i]=='point'?false:true,      
              data:data.y[i].map(function (y,j) { 
                return typ=='line'?{x:x[j],y:y}:Object.assign({x:x[j]},y) 
              })
          }
        })
        
      } else {
        labels = Object.keys(data.y[0]);
        coln = labels.length;
        typ = isErrorPoint(data.y[0][labels[0]])?'lineWithErrorBars':'line';
        ds = labels.map (function (xl,i) {
          var label;
          if (!(options.labels && options.labels.date==false)) 
            label=(options.labels && options.labels.data && options.labels.data[i]) || (name?name+'.'+i:i) 
          return {
              label:label,
              fill:false,
              steppedLine:options.lines=='step'?'before':undefined,
              backgroundColor:color[getOptionIndex(options.color,i,i)],
              borderColor: color[getOptionIndex(options.color,i,i)],  
              showLine: options.type=='point'||options.type[i]=='point'?false:true,      
              data:data.y.map(function (y,j) { 
                return typ=='line'?{x:data.x[j],y:y[xl]}:Object.assign({x:data.x[j]},y[xl]) 
              })
          }
        })
      }
      p = {
        type : typ,
        data : {
          datasets : ds
        },
        options : {
          scales: {
            xAxes: [{
              type: (options.axis && options.axis.x)||'linear',
              ticks: {
                    suggestedMin: options.xmin,
                    suggestedMax: options.xmax
              },
              scaleLabel : (options.labels && options.labels.x)?{
                display:true,
                labelString:options.labels.x
              }:{display:false}
              // ...
            }],
            yAxes: [{
              type: (options.axis && options.axis.y)||'linear',
              ticks: {
                    suggestedMin: options.min||options.ymin,
                    suggestedMax: options.max||options.ymax
              },
              scaleLabel : (options.labels && options.labels.y)?{
                display:true,
                labelString:options.labels.y
              }:{display:false}
              // ...
            }]
          }
        }
      }
    }
    if ((Utils.isArray(data) && Utils.isObject(data[0]) && !isDataPoint(data[0])) 
        || Utils.isArrayArray(data)) {
      // 4. Line plot: Data is array of records  [ {y1:,y2:,..}, .. ] or arrays of arrays (array matrix)
      labels = Object.keys(data[0]);
      coln = labels.length;
      typ = isErrorPoint(data[0][labels[0]])?'lineWithErrorBars':'line';
      ds = labels.map (function (x,i) {
        return {
            label:(options.labels && options.labels.data && options.labels.data[i]) || (name?name+'.'+x:x),
            fill:false,
            steppedLine:options.lines=='step'?'before':undefined,
            backgroundColor:color[getOptionIndex(options.color,i,i)],
            borderColor: color[getOptionIndex(options.color,i,i)],    
            showLine: options.type=='point'||options.type[i]=='point'?false:true,      
            data:data.map(function (y,j) { 
              return typ=='line'?{x:j,y:y[x]}:Object.assign({x:j},y[x]) 
            })
        }
      })
      p = {
        type : typ,
        data : {
          datasets : ds
        },
        options : {
          scales: {
            xAxes: [{
              type: (options.axis && options.axis.x)||'linear',
              ticks: {
                    suggestedMin: options.xmin,
                    suggestedMax: options.xmax
              },
              scaleLabel : (options.labels && options.labels.x)?{
                display:true,
                labelString:options.labels.x
              }:{display:false}
              // ...
            }],
            yAxes: [{
              type: (options.axis && options.axis.y)||'linear',
              ticks: {
                    suggestedMin: options.min||options.ymin,
                    suggestedMax: options.max||options.ymax
              },
              scaleLabel : (options.labels && options.labels.y)?{
                display:true,
                labelString:options.labels.y
              }:{display:false}
              // ...
            }]
          }
        }
      }  
    }
    if (options.points==false) p.options.elements = {
          point : {
            radius : 0,
          }
        };
    if (options.lines=='straight') p.options.elements = {
          line : {
            tension : 0,
          }
        };
    if (options.labels && options.labels.data==false) p.options.legend = {
        display: false
    };
    // workaround for box frames
    if (options.box && p.options.scales.xAxes.length==1) {
      if (!p.options.scales.xAxes[0].gridLines)
        p.options.scales.xAxes[0].gridLines={};
      p.options.scales.xAxes[0].gridLines.axisColor='rgba(0,0,0,1)';
      p.options.scales.xAxes.push({
              position: 'top',
              ticks: {
                display: false
              },
              gridLines: {
                lineWidth: 1,
                color: 'rgba(0,0,0,1)',
                display: true,
                drawOnChartArea: false,
                drawTicks: false
              }
            });
    }
    if (options.box && p.options.scales.yAxes.length==1) {
      if (!p.options.scales.yAxes[0].gridLines)
        p.options.scales.yAxes[0].gridLines={};
      p.options.scales.yAxes[0].gridLines.axisColor='rgba(0,0,0,1)';
      p.options.scales.yAxes.push({
              position: 'right',
              ticks: {
                display: false
              },
              gridLines: {
                lineWidth: 1,
                color: 'rgba(0,0,0,1)',
                display: true,
                drawOnChartArea: false,
                drawTicks: false
              }
            });
    }
    return p;
  },
  
  // Matrix (number|record array array) -> matrix chart!  [[y11,y12,..],[y21,y22,..],..]
  matrix : function (data,options) {
    var p,rown,coln,min,max,ds,labels,legend,
        name=options.name||(options.labels && options.labels.data)||'data';
    var color = Plotter.color,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
    function format(v,preci) {
      var s=String(v),dp=s.indexOf('.');
      if (dp==-1) return s;
      off=dp+1;
      while (s[off]=='0') off++;
      return s.substring(0,off+preci);       
    }
    rown = data.length;
    coln = data[0].length;
    min = options.min!=undefined?options.min:Infinity;
    max = options.max!=undefined?options.max:-Infinity;
    if (Utils.isObj(data[0][0])) {
      labels = Object.keys(data[0][0]);
      if (labels.length>color.length) return;
      ds = labels.map (function (x,i) {
        var d = {
            label:(name?name+'.'+x:x),
            data : Utils.flatten(data.map(function (row,j) {
                  return row.map(function (v,i) {
                    min=Math.min(min,v[x]);
                    max=Math.max(max,v[x]);
                    return { x:i,y:j,v:v[x] }
                  })})),
		    backgroundColor: function(ctx) {
			    var value = ctx.dataset.data[ctx.dataIndex].v;
			    var alpha = (value - min) / Math.abs(max);
			    return Color(color[i]).alpha(alpha).rgbString();
		    },
            borderColor : options.border?'#888':undefined,
            borderWidth : options.border||undefined,
		    width: function(ctx) {
			    var a = ctx.chart.chartArea;
			    return (a.right - a.left) / (coln+1);
		    },
		    height: function(ctx) {
			    var a = ctx.chart.chartArea;
			    return (a.bottom - a.top) / (rown+2);
		    }
           }
        return d;
        });
    } else
      ds =  [{
		label: name,
		data: Utils.flatten(data.map(function (row,j) {
                  return row.map(function (v,i) {
                    min=Math.min(min,v);
                    max=Math.max(max,v);
                    return { x:i,y:j,v:v }
                  })}))
                ,
		backgroundColor: function(ctx) {
			var value = ctx.dataset.data[ctx.dataIndex].v;
			var alpha = (value - min) / Math.abs(max);
            if (value==min && options.color0)
			  return Color(color[options.color0]).alpha(0.5).rgbString();
            else
			  return Color(color[options.color||0]).alpha(alpha).rgbString();
		},
        borderColor : options.border?'#888':undefined,
        borderWidth : options.border||undefined,
		width: function(ctx) {
			var a = ctx.chart.chartArea;
			return (a.right - a.left) / (coln+1);
		},
		height: function(ctx) {
			var a = ctx.chart.chartArea;
			return (a.bottom - a.top) / (rown+2);
		}
	}];
    legend = {min:format(min,2),max:format(max,2), gradient:gradient[options.color||0]};
    p = {
      type: 'matrix',
      data: {
        datasets: ds
      },
      options: {
        animation: false,
	      legend: {
		      display: true
	      },
	      tooltips: {
		      callbacks: {
			      title: function() { return '';},
			      label: function(item, data) {
				      var v = data.datasets[item.datasetIndex].data[item.index];
				      return ["x: " + v.x, "y: " + v.y, "v: " + v.v];
			      }
		      }
	      },
	      scales: {
		      xAxes: [{
			      ticks: {
				      display: true,
				      min: 0,
				      max: (coln),
				      stepSize: options.ticks||5
			      },
			      gridLines: {
				      display: false
			      },
			      afterBuildTicks: function(scale, ticks) {
				      return ticks.slice(0, coln+5);
			      },
                  scaleLabel : (options.labels && options.labels.x)?{
                    display:true,
                    labelString:options.labels.x
                  }:{display:false}
		      }],
		      yAxes: [{
			      ticks: {
				      display: true,
				      min: 0,
				      max: (rown),
				      stepSize: options.ticks||5
			      },
			      gridLines: {
				      display: false
			      },
			      afterBuildTicks: function(scale, ticks) {
				      return ticks.slice(0, rown+5);
			      },
                  scaleLabel : (options.labels && options.labels.y)?{
                    display:true,
                    labelString:options.labels.y
                  }:{display:false}
		      }]
	      }
      }                  
    }
    options.legend=legend;
    return p;
  },

  // network sparkline plots arranged in hierarchical tables
  // network consists of layers with nodes
  // each node has at least an output value y, optionally
  // input vector x, and a parameter vector p
  // [ {type,name,min,max,minX,maxX,minP,maxP,minY,maxY,minDX,maxDX,...
  //    nodes : { $id: {x?:[],p?:[],y:number,dx?:[],dp?:[],dy?:number} } } ]
  network : function (layers,options) {
    function plot(layers,options) {
      options=options||{}
      options.width=options.width||300;
      options.fontsize=options.fontsize||14;
      var t = $('<table/>',{style:'width:'+options.width+';border-spacing:5px;border-collapse: separate;'}),
          tb = $('<tbody/>').appendTo(t);
      t.appendTo($('<body>'))
      function makeSparkline (td,type,values,options) {
        switch (type) {
          case 'bar':
            td.sparkline(values,{
              type:'bar',
              height:options.height||30,
              barColor:options.color||'red',
              barWidth:options.width||20,
              zeroAxis:true,
              zeroColor:'black',
              chartRangeMin: options.min,
              chartRangeMax: options.max
            })
            break;
        }  
      }
      function options() {
        for(var i in arguments) 
          if (arguments[i]!=undefined) return arguments[i];
      }
      function isArrayAttr(nodes,attr) {
        for(var i in nodes) if (Utils.isArray(nodes[i][attr])) return true;
        return false;
      }
      function updateStats(stats,vals) {
        if (stats.min==undefined) {
          stats.min=1E9;
          stats.max=-1E9;
          stats.sum=0;
          stats.n=0;
        }
        if (Utils.isTypedArray(vals)) for(var i=0;i<vals.length;i++) updateStats(stats,vals[i]);
        else if (vals.data && Utils.isTypedArray(vals.data)) for(var i=0;i<vals.data.length;i++) updateStats(stats,vals.data[i]);
        else if (Utils.isArray(vals)) for(var i in vals) updateStats(stats,vals[i]);
        else {
          stats.min=Math.min(stats.min,vals);
          stats.max=Math.max(stats.max,vals);
          stats.sum+=vals;
          stats.n++;
        }
      }

      for(var layerIndex in layers) {
        var layer = layers[layerIndex];
        function formatStat(v) {
          if (layer.frac) return ((v/layer.frac)|0)*layer.frac;
          else return v;
        }
        var tr = $('<tr/>',{style:''}).appendTo(tb);
        var tdLabel = $('<td/>',{style:'text-align:left;min-width:100px;font-size:'+options.fontsize}).html(layer.name).appendTo(tr);
        var tdContent = $('<td/>',{style:'border:1px solid #CCC;text-align:center'}).appendTo(tr);
        var tLayer=$('<table/>',{style:'width:200px;'}).appendTo(tdContent),
            tbLayer = $('<tbody/>',{style:''}).appendTo(tLayer);
        var attributes = ['x','p','dp','y','dy'];
        var colmax=1,r=5;
        for (var a in attributes) {
          var attr = attributes[a];
          if (layer.nodes[Object.keys(layer.nodes)[0]][attr]==undefined) continue;
          var trLayer = $('<tr/>',{style:''}).appendTo(tbLayer);
          function vector(nodes,attr) {
            var vals = []
            $('<td/>',{style:'padding:5px; min-width:20px;text-align:left;font-size:'+options.fontsize}).html(attr).appendTo(trLayer);
            var cols=0;
            for (var i in nodes) {
              var node = nodes[i];
              if (node[attr]==undefined) continue;
              cols++;
              var vals = node[attr];
              if (Utils.isArray(node[attr][0])) {
                var tdNode = $('<td/>',{style:'padding: 2px;text-align:center;border-bottom:1px solid;'}).appendTo(trLayer);
                var tPart = $('<table/>',{style:'width:100%'}).appendTo(tdNode),
                    tPartBody = $('<tbody/>').appendTo(tPart);
                for (var row in node[attr]) {
                  var tPartRow = $('<tr/>',{style:''}).appendTo(tPartBody);
                  vals = node[attr][row];
                  var tdPart = $('<td/>',{style:'padding: 5px;text-align:center;'}).appendTo(tPartRow);
                  makeSparkline(tdPart,'bar',vals,{
                    min:options(layer['min'+attr.toUpperCase()],layer.min),
                    max:options(layer['max'+attr.toUpperCase()],layer.max),
                    color:options(layer['color'+attr.toUpperCase()],'green'),
                    height:options(layer['height'+attr.toUpperCase()],layer.height),
                    width:options(layer['width'+attr.toUpperCase()],layer.width,5)
                  })                
                }
              } else {
                var tdNode = $('<td/>',{style:'padding: 2px;text-align:center;border-bottom:1px solid;'}).appendTo(trLayer);
                makeSparkline(tdNode,'bar',vals,{
                  min:options(layer['min'+attr.toUpperCase()],layer.min),
                  max:options(layer['max'+attr.toUpperCase()],layer.max),
                  color:options(layer['color'+attr.toUpperCase()],'green'),
                  height:options(layer['height'+attr.toUpperCase()],layer.height),
                  width:options(layer['width'+attr.toUpperCase()],layer.width,5)
                })
              }
            }
            colmax=Math.max(cols,colmax)      
          }
          function line (nodes,attr) {
            $('<td/>',{style:'padding:5px; min-width:20px;text-align:left;font-size:'+options.fontsize}).html(attr).appendTo(trLayer);
            var vals = [], stats={}
            for (var i in layer.nodes) {
              var node = layer.nodes[i];
              updateStats(stats,node[attr])
              vals.push(node[attr]);
            }
            if (layer.stats) {
              var tdStatOuter = $('<td/>',{style:'padding: 5px;'}).appendTo(trLayer);
              var tStat  = $('<table/>',{style:'width:100%'}).appendTo(tdStatOuter),
                  tStatBody = $('<tbody/>').appendTo(tStat);
                 
              for (var s in layer.stats) {
                var stat = layer.stats[s],
                    trStat = $('<tr/>',{style:''}).appendTo(tStatBody),
                    tdStat = $('<td/>',{style:'padding:5px; min-width:20px;text-align:left;font-size:'+options.fontsize}).appendTo(trStat);
                var v = 0;
                if (stat=='min') v=formatStat(stats.min);
                if (stat=='max') v=formatStat(stats.max);
                tdStat.html(stat+'='+v);
              }
            }
            var tdLayer = $('<td/>',{style:'padding: 10px;text-align:center;'}).appendTo(trLayer);
            if (colmax>1) tdLayer.attr('colspan',colmax);
            makeSparkline(tdLayer,'bar',vals,{
              min:options(layer['min'+attr.toUpperCase()],layer.min),
              max:options(layer['max'+attr.toUpperCase()],layer.max),
              color:options(layer['color'+attr.toUpperCase()],'red'),
              height:options(layer['height'+attr.toUpperCase()],layer.height),
              width:options(layer['width'+attr.toUpperCase()],layer.width,20)
            })      
          }
          function image(nodes,attr) {
            var vals = [], stats={}, ATTR=attr.toUpperCase();
            $('<td/>',{style:'padding:5px; min-width:20px;text-align:left;font-size:'+options.fontsize}).html(attr).appendTo(trLayer);
            if (layer.stats) {
              for (var i in layer.nodes) {
                var node = layer.nodes[i];
                if (node[attr]==undefined) continue;
                updateStats(stats,node[attr])
              }
              var tdStatOuter = $('<td/>',{style:'padding: 5px;'}).appendTo(trLayer);
              var tStat  = $('<table/>',{style:'width:100%'}).appendTo(tdStatOuter),
                  tStatBody = $('<tbody/>').appendTo(tStat);
                 
              for (var s in layer.stats) {
                var stat = layer.stats[s],
                    trStat = $('<tr/>',{style:''}).appendTo(tStatBody),
                    tdStat = $('<td/>',{style:'padding:5px; min-width:20px;text-align:left;font-size:'+options.fontsize}).appendTo(trStat);
                var v = 0;
                if (stat=='min') v=formatStat(stats.min);
                if (stat=='max') v=formatStat(stats.max);
                tdStat.html(stat+'='+v);
              }
            }
            var cols=0;
            for (var i in nodes) {
              var node = nodes[i];
              if (node[attr]==undefined) continue;
              cols++;
              var mat = node[attr]; // [][], MatriXTA-2D
              var tdNode = $('<td/>',{style:'padding: 2px;text-align:center;'}).appendTo(trLayer);
              function makeImage (container,mat) {
                var min,max;
                if (layer.min!=undefined && layer.max!=undefined) {
                  min=layer.min;max=layer.max;
                } else if (layer['min'+ATTR]!=undefined && layer['max'+ATTR]!=undefined) {
                  min=layer['min'+ATTR];max=layer['max'+ATTR];
                } else if (mat.minmax) {
                  var minmax = mat.minmax();
                  min=minmax.min;max=minmax.max;
                } else {
                  // TODO
                }
                var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    zoom = layer['zoom'+attr.toUpperCase()]||1;
                $(canvas).appendTo(container);
                $(canvas).css({style:"border:1px solid;"});

                var width=mat.columns,
                    height=mat.rows,
                    depth=mat.levels||1;
                canvas.width = width*zoom;
                canvas.height = height*zoom;

                // create imageData object
                var idata = ctx.createImageData(width*zoom, height*zoom);
                var k = 255/(max-min),
                    off = min;
                for(var i=0;i<height;i++)
                  for(var j=0;j<width;j++) {
                    if (depth==1) {
                      var v=mat.get(i,j);
                      if (zoom==1) {
                        var index=(i*width+j)*4;
                        for(var id=0;id<3;id++) idata.data[index+id]=(v-off)*k;
                        idata.data[index+3]=255;
                      } else if (zoom>1) {
                        for(var zi=0;zi<zoom;zi++) 
                          for(var zj=0;zj<zoom;zj++) {
                            var index=((i*zoom+zi)*width*zoom+j*zoom+zj)*4;
                            for(var id=0;id<3;id++) idata.data[index+id]=(v-off)*k;
                            idata.data[index+3]=255;                        
                          }
                      } else if (zoom < 1) {
                        // TODO
                      }
                    } else if (depth==3) {
                      for(var id=0;id<3;id++) {
                        var v=mat.get(i,j,id);
                        if (zoom==1) {
                          var index=(i*width+j)*4;
                          idata.data[index+id]=(v-off)*k;
                          idata.data[index+3]=255;
                        } else if (zoom>1) {
                          for(var zi=0;zi<zoom;zi++) 
                            for(var zj=0;zj<zoom;zj++) {
                              var index=((i*zoom+zi)*width*zoom+j*zoom+zj)*4;
                              idata.data[index+id]=(v-off)*k;
                              idata.data[index+3]=255;                        
                            }
                        } else if (zoom < 1) {
                          // TODO
                        }
                     
                      }
                    }
                }              
                // update canvas with new data
                ctx.putImageData(idata, 0, 0);                
              }

              if (Utils.isArray(mat)) {
                // table of images
                // TODO also paritioning layer.rows, layer.cols??
                var tPart = $('<table/>',{style:'width:100%'}).appendTo(tdNode),
                    tPartBody = $('<tbody/>').appendTo(tPart);
                
                for(var trowi=0;trowi<mat.length;trowi++) {
                  var tPartRow = $('<tr/>',{style:''}).appendTo(tPartBody);
                  if (Utils.isArray(mat[trowi])) {
                    for(var tcoli=0;tcoli<mat[trowi].length;tcoli++) {
                      var tdPart = $('<td/>',{style:'padding: 3px;text-align:center;'}).appendTo(tPartRow);
                      makeImage(tdPart,mat[trowi][tcoli]);
                    }                  
                  } else {
                    var tdPart = $('<td/>',{style:'padding-bottom: 5px; text-align:center;'}).appendTo(tPartRow);
                    makeImage(tdPart,mat[trowi]);                  
                  }
                }
              } else if (mat.data) {
                makeImage(tdNode,mat)
              }
            }
          }
          switch (attr) {
            case 'x':
            case 'dx':
            case 'p':
            case 'dp':
              if (layer.type=='image') image(layer.nodes,attr);
              else if (isArrayAttr(layer.nodes,attr))
                vector(layer.nodes,attr);
              else
                line(layer.nodes,attr);
              break;
            case 'dy':
            case 'y':
              if (layer.type=='image') image(layer.nodes,attr);
              else line(layer.nodes,attr);
              break;
          }
        }
      }
      return t;
    }
    var t = plot(layers,options);
    return {
      type  : 'network',
      table : t,
      options : options,
    };
  },
  
  // parallel coordinate plots
  pcp : function (data,options) {
    var p,labels;
    p={
      type:'pcp',
      data:{
        labels:[],
        datasets:[]
      },
      options:{
        _yscales : options.axis && options.axis.y
      }
    }
    if (options.labels && options.labels.data) labels=options.labels.data;
    else labels=data.row.map(function (row,rowi) { return String(rowi+1) });
    for(var col=0;col<data[0].length;col++) p.data.labels.push(String(col+1));
    for(var row=0;row<data.length;row++) {
      p.data.datasets.push({
        // type:options.axis && options.axis.data && options.axis.data[row],
        label:labels[row],
        data:data[row]
      })
    }
    return p;
  },
  
  // PIE/doughnut  chart plot
  // typeof @data = { $x:number } | number []
  // typeof @options = { labels?:{data:[]} }
  pie : function (data,options) {
    var p,labels;
    var color = Plotter.color,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
    if (Utils.isMatrix(data))  {
      ds = data.map (function (data,index) {
        labels=[];
        if (Utils.isObject(data)) {
          data = Object.keys(data).map(function (key) {
            labels.push(key);
            return data[key];
          });
        } else labels = data.map(function (x,i) { return i });
        labels = (options.labels && options.labels.data)||labels;
        return {
          data : data,
          backgroundColor:color,
          label: 'Dataset '+index
      }});
    } else if (Utils.isArray(data)) {
      labels = (options.labels && options.labels.data)||data.map(function (x,i) { return i });
      ds = [{
        data : data,
        backgroundColor:color,
        label: ''
      }]      
    } else if (Utils.isObject(data)) {
      var labels=[];
      data = Object.keys(data).map(function (key) {
            labels.push(key);
            return data[key];
      });
      labels = (options.labels && options.labels.data)||labels;
      ds = [{
        data : data,
        backgroundColor:color,
        label: ''
      }]      
    }
    p = {
      type : options.type,
      data : {
        datasets : ds,
        labels   : labels
      },
      options : {
        responsive: true
      }
    }
    console.log(p)
    return p;
  },
  
  // Scatter point plots {x,y} []|[x,y}[][]
 
  scatter: function (data,options) {
    var p,name=options.name,labels;
    var color = Plotter.color,
        colorArray = Plotter.colorArray,
        gradient = Plotter.gradient;
    function isDataPoint(d) {
      return Utils.isObject(d) && d.x != undefined && d.y != undefined
    }
    function isDataPoint3(d) {
      return Utils.isObject(d) && d.x != undefined && d.y != undefined && d.z != undefined
    }
    function makeColor(data,index) {
      if (isDataPoint3(data[0])) {
        var minmax = MinMax(data,'z');
        return data.map(function (p) {
          return Plotter.rainbow((p.z-minmax.min)/(minmax.max-minmax.min))
        })
      }
      else return options.color!=undefined?options.color:color[0]
    }
    if (Utils.isMatrix(data) && isDataPoint(data[0][0])) {
      p= {
        type : 'scatter',
        data : {
          datasets : data.map(function (data,index) {
            return {
              data : data,
              backgroundColor:options.color?options.color[index]||color[index]:color[index],
              pointBorderColor:options.borderColor,
              label: options.labels && options.labels.data? options.labels.data[index]:String(index)
            }
           })
        }
      }
    } else if (Utils.isArray(data) && isDataPoint(data[0])) {    
      p= {
        type : 'scatter',
        data : {
          datasets : [{
            data : data,
            backgroundColor:makeColor(data,0),
            pointBorderColor:options.borderColor,
            label: ''
          }]
        }
      }
    }
    if(p) {
      p.options = {
        elements : {
          point : {
            radius : options.radius||4,
          }
        },
        scales: {
          xAxes: [{
            type: 'linear',
            scaleLabel : (options.labels && options.labels.x)?{
              display:true,
              labelString:options.labels.x
            }:{display:false},
            ticks: {
                    suggestedMin: options.xmin,
                    suggestedMax: options.xmax
            },
          }],
          yAxes: [{
            type: 'linear',
            scaleLabel : (options.labels && options.labels.y)?{
              display:true,
              labelString:options.labels.y
            }:{display:false},
            ticks: {
                    suggestedMin: options.ymin,
                    suggestedMax: options.ymax
            },
            // ...
          }]

        }
      }
    }
    if (options.rois) {
      var al = [];
      options.rois.forEach(function (bbox,bindex) {
        if (Utils.isArray(bbox)) {
          // polygon -> multi lines
          for(var i=1;i<bbox.length;i++) {
            var r = {}, p1=bbox[i-1],p2=bbox[i];
            if (p1.x!=undefined) { r.x1=p1.x; r.y1=p1.y; r.x2=p2.x; r.y2=p2.y }
            else { r.x1=p1[0]; r.y1=p1[1]; r.x2=p2[0]; r.y2=p2[1] }
            al.push({
              type: 'line',
              drawTime: 'afterDatasetsDraw',
	            xScaleID: 'x-axis-1',
	            yScaleID: 'y-axis-1',
              xMin: r.x1,
              xMax: r.x2,
              yMin: r.y1,
              yMax: r.y2,
              borderWidth: getOptionIndex(options.borderWidth,bindex,2),
              borderColor: getOptionIndex(options.borderColor,bindex,'red'),
              backgroundColor: 'transparent'
            })
          }
          console.log(al)
        } else if(Utils.isObject(bbox)) {
          var r;
          if (bbox.x1!=undefined && bbox.x2!=undefined) {
            r=bbox;
          }
          if (bbox.x!=undefined && bbox.w!=undefined) {
            r={x1:bbox.x,y1:bbox.y,x2:bbox.x+bbox.w,y2:bbox.y+bbox.h};
          }
          al.push({
              type: 'box',
              drawTime: 'beforeDatasetsDraw',
	            xScaleID: 'x-axis-1',
	            yScaleID: 'y-axis-1',
              xMin: r.x1,
              xMax: r.x2,
              yMin: r.y1,
              yMax: r.y2,
              borderWidth: getOptionIndex(options.borderWidth,bindex,2),
              borderColor: getOptionIndex(options.borderColor,bindex,'red'),
              backgroundColor: getOptionIndex(options.backgroundColor,bindex,'transparent')
          })
        }
      })
      p.options.annotation = { annotations : al }
    }
    // console.log(p)
    return p;
  },
  
  // Data stream chart plot (smoothie.js)
  stream: function (data,options) {
    var p;
      p={
        type: 'stream',
        lines : data.map(function (name) {
          return new TimeSeries();
        }),
        options : {
          width:options.width,
          height:options.height,
          min:options.min,
          max:options.max,
          lines:data,
          delay:options.delay||(typeof options.stream == 'number' && options.stream),
          fps:options.fps,
          timestamp:options.timestamp,
          tooltip:options.tooltip,
        }
      }
    return p;  
  },
  
  version : '1.16.1',

};



// Auto function plotter using chartjs library
var Plots={},_Plot,_Chart=[];



function drawPlot(output,p,options) {
  var error,num=_Plot.length,
      ctx,canvas;
  var container = $('<div/>',{style:options.width?'width:'+options.width:''});
  container.appendTo($(output));
  if (!Utils.isArray(p)) {
    canvas = $('<canvas id="plotcanvas'+num+
               '" style="padding:0px; margin:0px; background-color:white; border:1px solid #888"></canvas>')
               .appendTo(container);
    ctx=canvas[0].getContext('2d');
    if (p.type == 'confusion') {
        var ll=0,font=14;
        p.options.labels.data.forEach(function (l) { ll=Math.max(ll,l.length) });
        var ml=40+ll*10,
            mt=(p.options.title.text?30:0)+10,
            mb=30,
            cw = (p.options.width-ml)/p.options.cols,
            ch = (p.options.width-mt-mb)/p.options.rows;
        canvas[0].width = p.options.width+ml;
        canvas[0].height= p.options.height+mt+mb;
        imgData = ctx.createImageData(p.options.width, 
                                      p.options.height); // width x height
        ctx.font = font+"px Arial";
        ctx.textAlign = "left"; 
        if (p.options.title.text)
          ctx.fillText(p.options.title.text,10,20)
        ctx.textAlign = "center"; 
        for(var i=0;i<p.options.rows;i++) {
          for(var j=0;j<p.options.cols;j++) {
              var v = p.data.get(i,j),color;
              var d = (v * 255)|0;
              if (i!=j)
                color=v==0?'rgb('+[0,0,255].join(',')+')':
                           'rgb('+[255,0,0].join(',')+')';
              else
                color='rgb('+[0,255,0].join(',')+')';            
              ctx.fillStyle = color;
              ctx.globalAlpha = i!=j&&v==0?0.1:Math.min(Math.max(v,0.1),0.9);
              ctx.fillRect(j*cw+ml, i*ch+mt,cw,ch);
              ctx.fillStyle = 'black';
              ctx.globalAlpha = 1.0;
              ctx.beginPath();
              ctx.rect(j*cw+ml, i*ch+mt,cw,ch);
              ctx.stroke();
              ctx.fillText(v,j*cw+ml+cw/2,i*ch+mt+ch/2)
          }
        }
        ctx.textAlign = "left"; 
        for(var i=0;i<p.options.rows;i++) {
          ctx.fillText(p.options.labels.data[i],10,i*ch+mt+ch/2)
        }
        ctx.textAlign = "center"; 
        for(var j=0;j<p.options.cols;j++) {
          ctx.fillText(p.options.labels.data[j],j*cw+ml+cw/2,p.options.rows*ch+mt+ch/3)
        }
        ctx.fillText(p.options.labels.x,ml+p.options.width/2-cw/2,p.options.rows*ch+mt+ch/3+20)
        ctx.save();
        ctx.translate(p.options.cols*ch+ml, mt+p.options.height/2-ch/2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(p.options.labels.y,0,font/2)
        ctx.restore();
        ctx.textAlign = "left"; 
        ctx.fillText('Accu=? Recall=? Preci=? F-m=?',10,p.options.rows*ch+mt+ch/3+50)

    } else {
      _Chart[num] = new Chart(ctx, p);
    }
  } else {
    var _charts=[];
    var table = $('<table/>').appendTo(container);
    p.forEach (function (row,rownum) {
      var tr=$('<tr/>').appendTo(table);
      var _charts_row=[];
      row.forEach(function (_p,colnum) {
        var td = $('<td/>').appendTo(tr);
        canvas = $('<canvas id="plotcanvas'+num+'-'+rownum+'-'+colnum+
               '" style="padding:0px; margin:0px; background-color:white; border:1px solid #888"></canvas>')
               .appendTo(td);
        ctx=canvas[0].getContext('2d');
        _charts_row.push(new Chart(ctx, _p));
      });
      _charts.push(_charts_row);
    })
    _Chart[num] = _charts;
  } 
}

Plot = function Plot(output,data,options) {
  var p = Plotter.format(data,options);
  _Plot=p;
  return drawPlot(output,p,options);
}

PlotTable = function PlotTable(output,table) {
  var plots=[];
  table.forEach(function (row) {
    var _row=[];
    row.forEach (function (col) {
      if (col.data && col.options) {
        _row.push(Plot(col.data,col.options));
      }
    })
    plots.push(_row);
  });
  _Plot=plots;
  return drawPlot(output,p,options);
}



};

Base64=Require('os/base64');
//Buffer=Require('os/buffer').Buffer;
window.PLOT=PLOT = Require('plugins/plot/plot.js');
</script>
    <script>var CoreModule = {};
CoreModule['com/io']='com/io.browser';
CoreModule['crypto']='os/crypto';
CoreModule['util']='os/util';
CoreModule['http']='os/http.browser';
CoreModule['url']='os/url';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['fs']='';
CoreModule['stream']='';
CoreModule['zlib']='';
CoreModule['dgram']='';
CoreModule['net']='';
CoreModule['child_process']='';
CoreModule['dns']='';
CoreModule['buffer']='os/buffer';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
PATH=[".","/home/sbosse/proj/workbook/src"];
if (typeof global == "undefined")  global=(typeof window != "undefined"?window:{})
if (typeof process == "undefined") var process={browser:true};
Require=function(modupath) {
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}, module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,window,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,window,process);
  else return undefined;
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
var FilesEmbedded = {};
var FileEmbedd = function (path,format) {};
var FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='browser';
Script=function(){};

BundleModuleCode['os/buffer']=function (module,exports,global,process){
var Ieee754 = Require('os/buffer_ieee754');

/* ------- base64-js -------- */
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}
/* ------- base64-js -------- */

var assert;

exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= {
    ok : function(cond,msg) {
      if (cond != true) {
        console.log('** Assertion failed: '+msg+' **');
        throw Error(msg);
      }
    }
  };
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new TypeError('First argument needs to be a number, ' +
                            'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          // Round-up subject[i] to a UInt8.
          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
          //                                  = 80
          this[i] = ((subject[i] % 256) + 256) % 256;
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var b = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(b)) throw new Error('Invalid hex string');
    this[offset + i] = b;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }
  // TODO
  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
};
BundleModuleCode['os/buffer_ieee754']=function (module,exports,global,process){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};
};
BundleModuleCode['com/io.browser']=function (module,exports,global,process){
    /*
    ************
    ** Browser
    ************
    */

    var tracing = true;
    var stderr_fun = function (str) { console.log(str); };
    var stdout_fun = function (str) { console.log(str); };
    var args=[];

    module.exports = {
        checkOptions : function(options,defaultOptions) {
          return Object.assign({}, defaultOptions||{}, options) },

        checkOption : function (option,defaultOption) { 
          return option==undefined? defaultOption:option },

        config: {
            columns:undefined,
            rows:undefined
        },
        /*
         ** FILE IO
         * TODO WebStorage
         */
        close: function (fd) {
            return;
        },
        exists: function (path) {
            return false;
        },
        open: function (path, mode) {
            var fd = Fs.openSync(path, mode);
            return fd;
        },

        read: function (fd, len, foff) {
            // TODO
        },
        read_file: function (path) {
            return '';
        },

        read_line: function (fd) {
            // TODO
        },
        /**
         *
         * @param fd
         * @param buf
         * @param boff
         * @param len
         * @param [foff]
         * @returns {*}
         */
        read_buf: function (fd, buf, boff, len, foff) {
            return -1;
        },
        sync: function (fd) {
            return;
        },
        
        /**
         *
         * @param fd
         * @param data
         * @param [foff]
         * @returns {*}
         */
        write: function (fd, data, foff) {
            return -1;
        },
        /**
         *
         * @param fd
         * @param buf
         * @param bpos
         * @param blen
         * @param [foff]
         * @returns {*}
         */
        write_buf: function (fd, buf, bpos, blen, foff) {
            return -1;
        },

        /*
         ** CONSOLE IO
         */
        debug: function (msg) {
            stderr_fun('Debug: ' + msg);
        },
        err: function (msg) {
            stderr_fun('Error: ' + msg);
            throw Error(msg);
        },
        fail: function (msg) {
            stderr_fun('Fatal Error: ' + msg);
        },
        inspect: function (obj) {
            return;
        },
        stacktrace: function () {
            var e = new Error('dummy');
            var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                .split('\n');
            stderr_fun('Stack Trace');
            stderr_fun('--------------------------------');
            for(var i in stack) {
                if (i>0) {
                    var line = stack[i];
                    if(line.indexOf('Module.',0)>=0) break;
                    stderr_fun(line);
                }
            }
            stderr_fun('--------------------------------');
        },
        time : function () {
          return Date.now()
        },
        /**
         *
         * @param e
         * @param where
         */
        printstack: function (e,where) {
            if (where==undefined) stderr_fun(e);
            else stderr_fun(where+': '+e);
        },
        /**
         *
         * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
         */
        log: function (condmsg) {
            if (condmsg != true) console.warn(condmsg);
        },
        out: function (msg) {
            stdout_fun(msg)
        },
        warn: function (msg) {
            stderr_fun('Warning: ' + msg);
        },


        set_stderr: function(fun) {
            stderr_fun=fun;
        },
        set_stdout: function(fun) {
            stdout_fun=fun;
        },

        stderr: function (msg) {
            stderr_fun(msg);
        },
        stdout: function (msg) {
            stdout_fun(msg);
        },

        /** Write a message with a time stamp written to the trace file.
         *
         * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
         */
        trace: function (condmsg) {
            if (condmsg != true && tracefile != undefined) {
                var date = new Date();
                var time = date.getTime();
                this.log('[' + time + '] ' + condmsg + '\n');
            }
        },
        tracing: tracing,
        /**
         *
         * @param {string} path
         */
        trace_open: function (path) {
            return undefined;
        },

        exit: function (n) {
            return;
        },
        /**
         *
         * @returns {*} RSS HEAP in kBytes {data,heap}
         */
        mem: function () {
            return {data:0,heap:0};
        },

        getenv: function (name, def) {
            return def;
        },
        workdir: function () {
            return '';
        },
        /**
         *  @return {string []}
         */
        getargs: function () {
            return args;
        },
        set_args: function (argv) {
            args=argv;
        }
    };
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['os/util']=function (module,exports,global,process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = function isBuffer(arg) {
  return arg && typeof arg === 'object'
             && typeof arg.copy === 'function'
             && typeof arg.fill === 'function'
             && typeof arg.readUInt8 === 'function';
};

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */

exports.inherits = Require('os/inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
};
BundleModuleCode['os/inherits']=function (module,exports,global,process){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['plugins/csp/csp.js']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 BSSLAB
 **    $CREATED:     29-5-19 by sbosse.
 **    $VERSION:     1.3.1
 **
 **    $INFO:
 **
 **  Universal Constraint Solver Programming Module
 **
 **    $ENDOFINFO
 */
 
var Io = Require('com/io');
var Comp = Require('com/compat');
var simple = Require('plugins/csp/cspS');
var casso  = Require('plugins/csp/cassowary');
var constr = Require('plugins/csp/constrained');
var fmin   = Require('plugins/csp/fmin');
var checkOptions = Io.checkOptions,
    checkOption = Io.checkOption;

CSP = {
  /* Add constraint */
  C : function (model,v1,v2,f) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        model.constraints.push([v1,v2,f]);
        break;
      case CSP.CSP.CASSOWARY:
        model.solver.addConstraint(v1);
        model.constraints.push(v1);
        break;
      case CSP.CSP.CONSTRAINED:
        model.solver.addConstraint(v1);
        model.constraints.push(v1);
        break;
      case CSP.CSP.FMIN:
        model.constraints.push(v1);
        break;
    }    
  },
  
  // Create Equation
  EQ: function (model,x1,x2) {
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        var eq = new casso.Equation(x1,x2);
        model.equations.push(eq);
        return eq;
        break;
    }   
  },
  // Add constant
  N : function (model,name,val) {
    switch (model.algorithm) {
      case CSP.CSP.CONSTRAINED:
        model.constants[name]=val;
        return model.solver.addConstant(name, model.constants, name);
        break;
      case CSP.CSP.FMIN:
        model.constants[name]=val;
        break;
    }    
    return model.variables[name];
  },

  NEQ: function (model,x1,op,x2) {
    var expr;
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        switch (op) {
          case '<=':
          case '<':
            expr = new casso.Inequality(x1,casso.LEQ,x2);
            break;
          case '>=':
          case '>':
            expr = new casso.Inequality(x1,casso.GEQ,x2);
            break;
        }
        return expr;
        break;
    }   
  },


  // Create Expression
  EXPR: function (model,x1,op,x2) {
    var expr;
    switch (model.algorithm) {
      case CSP.CSP.CASSOWARY:
        switch (op) {
          case '+':
            expr = casso.plus(x1,x2);
            break;
          case '-':
            expr = casso.minus(x1,x2);
            break;
          case '<':
            expr = new casso.Inequality(x1,casso.LEQ,x2);
            break;
          case undefined:
            expr = new casso.Expression(x1);
            break;
        }
        return expr;
        break;
    }   
  },
  
  // Add variable
  V : function (model,name,val) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        model.variables[name]=val;
        break;
      case CSP.CSP.CASSOWARY:
        model.variables[name]=new casso.Variable({value:val});
        break;
      case CSP.CSP.CONSTRAINED:
        model.variables[name]=val;
        return model.solver.addVariable(name, model.variables, name);
        break;
      case CSP.CSP.FMIN:
        model.variables[name]=val;
        break;
    }    
    return model.variables[name];
  },


  model2loss : function (model) {
    var objvar,expr,
        vars  = Object.keys(model.variables),
        constraints = model.constraints;
    // only equality constraints are supported!
    if (typeof constraints[0]=='function') 
     return constraints[0];
    if (constraints.length==1 && constraints[0].indexOf('=')>0) {
      var eq = constraints[0].split('=');
      if (objvar=eq[1].match(/[ ]([a-zA-Z0-9]+)/)) {
        objvar=objvar[1];
        expr=eq[0].trim();
      }
    }
    if (objvar && expr && model.constants[objvar]!=undefined) {
      var fcode = 'function loss(_x){';
      fcode += 'var ';
      fcode += vars.map(function (v,index) {  return (v+'=_x['+index+']') }).join(',');
      fcode += '; var err = ';
      fcode += expr;
      fcode += ('-'+model.constants[objvar]);
      fcode += '; return err*err}';
      eval(fcode);
      return loss;
    }
  },
  
  range : function (a,b,step) {
    var res=[];
    if (step==undefined) step=1;
    for(var i=a;i<=b;i=i+step) res.push(i);
    return res;
  },
  
  /* Create a new solver */
  solver : function (options) {
    var model={}
    options=checkOptions(options,{});
    options.algorithm=checkOption(options.algorithm,CSP.CSP.SIMPLE);
    model.algorithm=options.algorithm;
    switch (options.algorithm) {
      case CSP.CSP.SIMPLE:
        model.variables= {}
        model.constraints = []
        break;
      case CSP.CSP.CASSOWARY:
        model.variables= {}
        model.constraints = []
        model.equations = []
        model.solver = new casso.SimplexSolver();
        break;
      case CSP.CSP.CONSTRAINED:
        model.constants= {}
        model.variables= {}
        model.constraints = []
        model.solver = new constr.System();
        break;
      case CSP.CSP.FMIN:
        model.variables= {}
        model.constants= {}
        model.constraints = []
        model.algorithm2=options.solver||'nelderMead';
        model.solver = fmin[model.algorithm2];
        break;
    }
    return model
  },
  /* Solve the problem, return solutions */
  solve : function (model,options) {
    switch (model.algorithm) {
      case CSP.CSP.SIMPLE:
        return simple.solve(model)
      case CSP.CSP.CASSOWARY:
        model.solver.resolve();
        return model.solver.getInternalInfo()
      case CSP.CSP.CONSTRAINED:
        if (options && options.minimize) return model.solver.minimize(options.minimize);
        if (options && options.maximize) return model.solver.maximize(options.maximize);
        model.solver.resolve();
        return model.variables
      case CSP.CSP.FMIN:
        // here is the main work: construct a loss function from variables, constants, and constraint(s)
        var loss = CSP.model2loss(model);
        var solution = model.solver(loss,
                                    Object.keys(model.variables).map(function (v) {
                                      return model.variables[v]
                                    }));
        return solution
        break;
    }  
  },
  CSP:{
    SIMPLE    : 'SIMPLE',
    DISCRETE  : 'SIMPLE',
    CASSOWARY : 'CASSOWARY',
    LINEAR    : 'CASSOWARY',
    CONSTRAINED : 'CONSTRAINED',
    FMIN : 'FMIN',
  },
  CASSOWARY:casso,
  version: '1.3.1'
}

module.exports = CSP;


};
BundleModuleCode['com/compat']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     30-3-15 by sbosse.
 **    $VERSION:     1.23.6X
 **
 **    $INFO:
 **
 **  JavaScript-OCaML Compatibility Module
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Path = Require('com/path');
var Sprintf = Require('com/sprintf');

/*******************************
** Some global special "values"
********************************/

/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var any = undefined;
/** A matching template pattern matching any value
 *
 * @type {undefined}
 */
var _ = undefined;

/**
 *
 * @type {null}
 */
var none = null;
/**
 *
 * @type {null}
 */
var empty = null;

var NL = '\n';

global.int = function (v) {return v|0};
global.div = function (a,b) {return a/b|0};

if (!Object.prototype.forEach) {
	Object.defineProperties(Object.prototype, {
		'forEach': {
			value: function (callback) {
				if (this == null) {
					throw new TypeError('Not an object');
				}
				var obj = this;
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						callback.call(obj, obj[key], key, obj);
					}
				}
			},
			writable: true
		}
	});
}
/** Just transfer parent prototypes to child
 *
 */
function inherit(child,parent) {
  for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}

/** Portable class inheritance and instanceOf polyfill
 *
 */
// SomeObject.prototype.__proto__=SomeObject2.prototype;
// Child class inherits prototype from parent using __proto__
function inheritPrototype(child,parent) {
  var __proto__=child.__proto__;
  child.prototype.__proto__=parent.prototype;
  if (!__proto__) for(var p in parent.prototype) {
    if (p == '__proto__') continue;
    child.prototype[p]=parent.prototype[p];
  }
}
// Polyfill fir o instanceof c with inheritance check (checking __proto__)
function instanceOf(obj,cla) {
  var p=obj.__proto__;
  if (obj instanceof cla) return true;
  while (p) {
    if (p === cla.prototype) return true;
    p=p.__proto__
  }
  return false;
}
// Polyfill for __defineGetter__ / __defineSetter__
function defineGetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    get:fun
  });
}
function defineSetter(cla,prop,fun) {
  Object.defineProperty(cla.prototype,prop,{
    configurable:true,
    set:fun
  });

}

var inherit = inherit;
var inheritPrototype = inheritPrototype;
var instanceOf = instanceOf;
var defineGetter = defineGetter;
var defineSetter = defineSetter;

/**
 *
 */
var assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
};
global.assert=assert;

function forof(obj,f) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = obj[Symbol.iterator](), _step; 
         !(_iteratorNormalCompletion = (_step = _iterator.next()).done); 
         _iteratorNormalCompletion = true) {
      element = _step.value;

      f(element);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}


global.forof=forof;

/** OBJ
 *
 */
var obj = {
    /** Compact an object:
     * [{a:b},[c:d},..] -> {a:b,c:d,..}
     * {a:[b]} -> {a:b}
     *
     */
    compact: function (o) {
      var a;
      if (obj.isArray(o)) {
        if (o.length==1 && obj.isObject(o[0])) return obj.compact(o[0]);
        else return o;
      } else if (obj.isObject(o)) for (a in o) {
          var elem=o[a];
          o[a]=obj.compact(elem);
      }
      return o;
    },
    copy: function (o) {
      if (o === null || typeof o !== 'object') {
        return o;
      }
 
      var temp = (o instanceof Array) ? [] : {};
      for (var key in o) {
        temp[key] = obj.copy(o[key]);
      }
 
      return temp;    
    },
    equal: function (o1,o2) {
      if (!o1 || !o2) return false;
      for(var i in o1) if (o1[i]!=o2[i]) return false;
      for(var i in o2) if (o1[i]!=o2[i]) return false;
      return true;
    },
    extend: function (o1,o2) {
      for(var i in o2) o1[i]=o2[i];
      return o1;
    },
    find: function(obj,fun) {
      var p;
      for(p in obj) {
          if (fun(obj[p],p)) return obj[p];
      }
    },

    hasProperty: function (o,p) {
      return o[p]!=undefined || (p in o);
    },
    head:function(o) {
      for (var p in o) return p;
      return undefined;
    },
    // transfer src attributes to dst recusively (no object overwrite)
    inherit: function (dst,src) {
      for(var i in src) {
        if (typeof dst[i] == 'object' && typeof src[i] == 'object')
          inherit(dst[i],src[i]);
        else if (typeof dst[i] == 'undefined')
          dst[i]=src[i];
      }
      return dst;
    },
    isArray:function (o) {
      if (o==_ || o ==null) return false;
      else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
    },
    isMatrix:function (o) {
      if (o==_ || o ==null) return false;
      else return obj.isArray(o) &&
                  obj.isArray(o[0]);
    },
    isEmpty: function (o) {
      for(var prop in o) {
         if (o[prop]!=undefined) return false;
      }
      return true;  
    },
    isFunction: function (o) {
        return typeof o == "function";
    },
    isObj:function (o) {
        return typeof o == "object";
    },
    isObject:function (o) {
        return typeof o == "object";
    },
    isRegex: function (o) {
        return o instanceof RegExp;
    },
    isString: function (o) {
        return typeof o == "string" || (typeof o == "object" && o.constructor === String);
    },
    isNumber: function (o) {
        return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
    },


    iter: function(obj,fun) {
      var p;
      for(p in obj) {
        fun(obj[p],p)
      }
    }
};

/** ARRAY
 *
 */
var array = {
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean conjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    and: function(array,fun) {
        var res=true;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res&&fun(element,i)
        }
        return res;
    },
    /** Append one element at the end of the array.
     *
     * @param {* []} array
     * @param {*} element
     * @returns {* []}
     */
    append : function(array,element) {
        array.push(element);
        return array;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    call: function(array,args) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            element()
        }
    },
    /** Check for an elenment in the array by using a check function.
     *
     * @param array
     * @param fun
     * @returns {boolean}
     */
    check: function(array,fun) {
        var i,exist;
        exist=false;
        loop: for(i in array) {
            var element=array[i];
            if (fun(element,i)) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Append array2 at the end of array inplace. The extended array is returned.
     *  Source array (1) will be modified.
     *
     * @param {*[]} array
     * @param {*[]} array2
     * @returns {*[]}
     */
    concat : function(array,array2) {
        for(var i in array2) {
            array.push(array2[i]);
        }
        return array;
    },
    /** Create the conjunction set of two arrays
     *
     */
    conjunction :function (set1,set2,fun) {
      return array.union(set1,set2,fun);
    },
    /**
     *
     * @param {*[]} array
     * @param {number|string|*|*[]} elements
     * @param {function} [fun] Optional equality test function
     * @returns {boolean}
     */
    contains : function(array,elements,fun) {
        var i = array.length;
        if (!fun) fun=function(o1,o2) {return o1===o2};
        if (obj.isArray(elements)) {
          while (i--) {
            var j = elements.length;
            while (j--) {
              if (fun(array[i],elements[j])) {
                  return true;
              }          
            }
          }
        }
        else while (i--) {
            if (fun(array[i],elements)) {
                return true;
            }
        }
        return false;
    },
    /** Return a fresh copy of the source array or copy src array to dst.
     *
     * @param array
     * @returns {Array.<T>|string|Blob|ArrayBuffer}
     */
    copy: function(src,dst) {
        var i;
        if (dst) {
          for(i in src) dst[i]=src[i];  
        } else return src.slice();
    },
    /** Create a new array with initial element values.
     *
     * @param length
     * @param init
     * @returns {Array}
     */
    create : function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    },
    /** Create a matrix (array of array) with initial element values.
     *
     */
    create_matrix : function(rows,cols,init) {
        var m = [];
        var r = [];
        var i,j;
        for (i = 0; i < rows; i++) {
            r=[];
            for(j=0;j<cols;j++) r.push(init);
            m.push(r);
        }
        return m;
    },
    /** Create the (inclusive) disjunction set of two arrays.
     *  Source arrays will not be modified.
     *
     */
    disjunction :function (set1,set2,fun) {
      return array.merge(set1,set2);
    },
    /**
     *
     * @param array
     * @returns {boolean}
     */
    empty : function (array) {
      return (array==undefined ||
              array.length==0)
    },
    
    /** Test for equality
    */
    equal: function (a1,a2) {
      if (a1.length != a2.length) return false;
      for(var i in a1) if (a1[i]!=a2[i]) return false;
      return true;
    },
    
    /** Create the (exclusive) disjunction set of two arrays. 
     *  Source arrays will not be modified.
     *
     */
    exclusive :function (set1,set2,fun) {
        var i,j,found,res = [];
        for (i in set1) {
          found=false;
          loop1: for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) {found=true; break loop1;}
            else if (fun == undefined && set1[i]==set2[j]) {found=true; break loop1;};
          }
          if (!found) res.push(set1[i]);
        }
        for (i in set2) {
          found=false;
          loop2: for (j in set1) {
            if (fun != undefined && fun(set2[i],set1[j])) {found=true; break loop2;}
            else if (fun == undefined && set2[i]==set1[j]) {found=true; break loop2;};
          }
          if (!found) res.push(set2[i]);
        }
        return res;
    },
    /** Find an element in an array and return it (or none);
     *
     * @param array
     * @param fun
     * @returns {undefined|*}
     */
    find: function(array,fun) {
        var i;
        for(i in array) {
          if (fun(array[i],i)) return array[i];
        }
        return none;
    },
    /** Search and map an element of an array using a test&map function.
     *
     * @param array
     * @param {function(*,number):*} fun
     * @returns {undefined|*}
     */
    findmap: function(array,fun) {
        var i,found;
        for(i in array) {
          found=fun(array[i],i);
          if (found) return found;
        }
        return none;
    },
    /** Filter out elements using a test function.
     *
     * @param {* []} array
     * @param {function(*,number):boolean} fun
     * @returns {* []}
     */
    filter: function(array,fun) {
      if (array.filter) return array.filter(fun);
      else {
        var res=[],
            len=array.length,
            element,i;
        for(i=0;i<len;i++) {
            element=array[i];
            if (fun(element,i)) res.push(element);
        }
        return res;
      }
    },
    /** Filter out and map elements using a test&map function.
     *
     * @param {* []} array
     * @param {function(*,number):*|undefined} fun
     * @returns {* []}
     */
    filtermap: function(array,fun) {
        var res=[],
            len=array.length,
            element,mapped,i;
        for(i=0;i<len;i++) {
            element=array[i];
            mapped=fun(element,i);
            if (mapped!=undefined) res.push(mapped);
        }
        return res;
    },
    /** Flattens an array consting of arrays (and elements)
     *
     * @param array
     * @returns {Array}
     */
    flatten: function (array) {
        var res=[];
        var len=array.length;
        var i;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (!obj.isArray(element)) res.push(element);
            else {
                var j;
                var len2=element.length;
                for(j=0;j<len2;j++) {
                    var element2=element[j];
                    res.push(element2);
                }
            }
        }
        return res;

    },
    /**
     *
     * @param array
     * @returns {*}
     */
    head : function(array) {
        return array[0];
    },
    /**
     *
     * @param length
     * @param fun
     * @returns {Array}
     */
    init : function(length,fun) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = fun(i);
        }
        return arr;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter: function(array,fun) {
      /*
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            fun(array[i],i)
        }
      */
      array.forEach(fun);
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     */
    iter2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.iter2: arrays of different lengths'));
        /*
        var len=array1.length;
        for(i=0;i<len;i++) {
            fun(array1[i],array2[i],i)
        }
        */
        array1.forEach(function (e1,i) { fun(e1,array2[i],i) });
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun Returning a true value leaves iteration loop
     */
    iter_break: function(array,fun) {
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            if (fun(element,i)) return;
        }
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    iter_rev: function(array,fun) {
        var i;
        var len=array.length;
        for(i=len-1;i>=0;i--) {
            fun(array[i],i)
        }
    },
    /** Return last element of array.
     *
     */
    last : function(array) {
      var len=array.length;
      if (len==0) return none;
      else return array[len-1];
    },
    
    length : function(array) {
        return array.length;
    },
    /**
     *
     * @param {* []} array1
     * @param {* []} array2
     * @param {function(*,*,number)} fun
     * @returns {* []}
     */
    map2: function(array1,array2,fun) {
        var i=0;
        assert((array1.length == array2.length)||('Array.map2: arrays of different lengths'));
        var len=array1.length;
        var res=[];
        for(i=0;i<len;i++) {
            res.push(fun(array1[i],array2[i],i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     * @returns {* []}
     */
    map: function(array,fun) {
        var i=0;
        var len=array.length;
        var res=[];
        for(i=0;i<len;i++) {
            var element=array[i];
            res.push(fun(element,i));
        }
        return res;
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hdtl  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match: function(array,fun_hdtl,fun_empty) {
        if (array.length == 0) {
            if (fun_empty) fun_empty();
        } else if (array.length>1) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else fun_hdtl(this.head(array),[]);
    },
    /**
     *
     * @param {* []} array
     * @param {Function} fun_hd1hd2  - function(hd1,hd2)
     * @param {Function} [fun_hdtl]  - function(hd,tl)
     * @param {Function} [fun_empty] - function()
     */
    match2: function(array,fun_hd1hd2,fun_hdtl,fun_empty) {
        if (array.length == 0 && fun_empty)
            fun_empty();
        else if (array.length == 2) {
            var hd1 = this.head(array);
            var hd2 = this.second(array);
            fun_hd1hd2(hd1,hd2);
        }
        else if (array.length>1 && fun_hdtl) {
            var hd = this.head(array);
            var tl = this.tail(array);
            fun_hdtl(hd,tl);
        } else if (fun_hdtl) fun_hdtl(this.head(array),[]);
    },
    /** Return the maximum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    max : function (array,fun) {        
        var res,max,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (max==undefined) { max=num; res=array[i] } 
            else if (num > max) { max=num; res=array[i] }
        }
        return res;
    },
    /** Return the minimum element of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    min : function (array,fun) {        
        var res,min,num;
        for(var i in array) {
            if (fun) num=fun(array[i],i); else num=array[i];
            if (min==undefined) { min=num; res=array[i] }
            else if (num < min) { min=num; res=array[i] }
        }
        return res;
    },
    /** Check for an element in the array.
     *
     * @param {(number|string|boolean) []} array
     * @param {number|string|boolean} element
     * @returns {boolean}
     */
    member: function(array,element) {
        var i,exist;
        var len=array.length;
        exist=false;
        loop: for(i=0;i<len;i++) {
            var _element=array[i];
            if (_element==element) {
                exist=true;
                break loop;
            }
        }
        return exist;
    },
    /** Merge all arrays and return a new array.
     *
     * @param {Array} array1
     * @param {Array} array2
     * @param {Array} [array3]
     * @param {Array} [array4]
     * @returns {Array}
     */
    merge: function(array1,array2,array3,array4) {
        var arraynew=array1.slice();
        arraynew=arraynew.concat(array2);
        if (array3!=undefined) arraynew=arraynew.concat(array3);
        if (array4!=undefined) arraynew=arraynew.concat(array4);
        return arraynew;
    },
    /** Return the next element from array after val (next element after last is first!)
     * @param {Array} array
     * @param {number|string} val
     * @returns {number|string}
     */
    next: function(array,val) {
        var i;
        var len=array.length;
        if (obj.isString(val))
          for(i=0;i<len;i++) {
            if (string.equal(array[i],val)) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
        else
          for(i=0;i<len;i++) {
            if (array[i]==val) {
              if (i==len-1) return array[0];
              else return array[i+1];
            }
          }
          
        return none;
    },
    /** Evaluate a function returning a boolean value for each member of the array and
     *  compute the boolean disjunction.
     *
     * @param {* []} array
     * @param {function(*,number)} fun
     */
    or: function(array,fun) {
        var res=false;
        var i=0;
        var len=array.length;
        for(i=0;i<len;i++) {
            var element=array[i];
            res=res||fun(element,i)
        }
        return res;
    },
    
   /**
     * Gets the property value of `key` from all elements in `collection`.
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * pluck(users, 'user');
     * // => ['barney', 'fred']
     */
    pluck: function(collection, key) {
      return collection.map(function(object) {
          return object == null ? undefined : object[key];
        });
    },
    /*
     ** Push/pop head elements (Stack behaviour)
     */
    /** Remove and return top element of array.
     *
     * @param array
     * @returns {*}
     */
    pop : function(array) {
        var element=array[0];
        array.shift();
        return element;
    },
    print: function(array) {
        var i;
        var len=array.length;
        var str='[';
        for(i=0;i<len;i++) {
            var cell=array[i];
            str=str+cell;
        }
        return str+']';
    },
    /** Add new element at top of array.
     *
     * @param array
     * @param element
     */
    push : function(array,element) {
        array.unshift(element);
    },
    /** Create an ordered array of numbers {a,a+1,..b}
     *
     * @param a
     * @param b
     * @returns {Array}
     */
    range : function(a,b) {
        var i;
        var array=[];
        for(i=a;i<=b;i++) array.push(i);
        return array;
    },
    /** Remove elements from an array.
     *  [1,2,3,4,5,6] (begin=2,end=4) => [1,2,6]
     * @param {* []} array
     * @returns {* []}
     */
    remove: function(array,begin,end) {
      var i,a;
      if (end==undefined) end=begin+1;
      if (begin<0 || end >= array.length) return [];
      a=array.slice(0,begin);
      for(i=end;i<array.length;i++) a.push(array[i]);
      return a;
    },
    
    second : function(array) {
        return array[1];
    },
    /**
     *
     * @param {* []} array
     * @param {function(*,*):number} fun   (1:a gt. b by the ordering criterion,-1: a lt. b, 0: a eq. b)
     * @returns {* []}
     */
    sort: function(array,fun) {
        var array2=array.slice();
        array2.sort(fun);
        return array2;
    },
    /** Split an array at position 'pos', i.e., remove 'len' (1) elements starting at 
     *  position 'pos'.
     *  ==> use remove!!! split should return two arrays!!
     *
     * @param array
     * @param pos
     * @param [len]
     * @param element
     */    
    split: function(array,pos,len) {
      if (pos==0) return array.slice((len||1));
      else {
        var a1=array.slice(0,pos);
        var a2=array.slice(pos+(len||1));
        return a1.concat(a2);
      }
    },
    /** Return the sum number of an array applying
     *  an optional mapping function.
     *
     * @param {* []} array
     * @param [fun]
     * @returns {number|undefined}
     */
    sum : function (array,fun) {        
        var res=0;
        for(var i in array) {
            var num=0;
            if (fun) num=fun(array[i]); else num=array[i];
            if (!obj.isNumber(num)) return undefined;
            res += num;
        }
        return res;
    },
    /** Return a new array w/o the head element (or optional 
     *  w/o the first top elements).
     *
     */
    tail : function(array,top) {
        var array2=array.slice();
        array2.shift();
        if (top) for(;top>1;top--) array2.shift();
        return array2;
    },
    /** Return union of two sets (== conjunction set)
     *
     * @param {* []} set1 
     * @param {* []} set2
     * @param {function} [fun]  Equality test
     * @returns {* []}
     */
    union : function(set1,set2,fun) {
        var i,j,res = [];
        for (i in set1) {
          for (j in set2) {
            if (fun != undefined && fun(set1[i],set2[j])) res.push(set1[i]);
            else if (fun == undefined && set1[i]==set2[j]) res.push(set1[i]);
          }
        }
        return res;
    },
    
    /**
     * Creates a duplicate-free version of an array
     */
    unique: function(array) {
      var length = array ? array.length : 0;
      function baseUniq(array) {
        var index = -1,
            length = array.length,
            seen,
            result = [];

        seen = result;
        outer:
        while (++index < length) {
          var value = array[index];
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        return result;
      }
      if (!length) {
        return [];
      }
      return baseUniq(array);
    },
    
    /**
     * Creates an array excluding all provided values
     * without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    without: function () {
      var array,
          values=[];
      for(var i in arguments) {
        if (i==0) array=arguments[0];
        else values.push(arguments[i]);
      }
      return array.filter(function (e) {
        return values.indexOf(e) == -1;
      });
    },
    /** Test for zero elements {0, '', false, undefined, ..}
    */
    zero: function (array) {
      for(var i in array) if (!!array[i]) return false;
      return true;
    },
};

/** STRING
 *
 */
var string = {
    /** Is pattern conatined in template?
     *
     */
    contains: function (template,pattern) {
      return template.indexOf(pattern)>-1;
    },
    copy: function(src) {
        var i;
        var dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
    },
    /**
     *
     * @param {number} size
     * @returns {string} filled with spaces
     */
    create: function(size)
    {
        var i;
        var s='';
        var init=' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    endsWith : function (str,tail) {
        return str.indexOf(tail)==(str.length-tail.length);
    },
    empty: function (str) {
      return this.equal(str,'');
    },
    equal:  function(str1,str2) {
        var i;
        var eq=true;
        if (str1.length != str2.length) return false;
        for(i=0;i<str1.length;i++) { if (string.get(str1,i)!=string.get(str2,i)) eq=false;}
        return eq;
    },
    find: function (search,str) {
        return str.indexOf(search);
    },
    format_hex: function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
    },
    /**
     *
     * @param {string} str
     * @param {number} index
     * @returns {string}
     */
    get: function (str,index) {
        assert((str != undefined && index < str.length && index >= 0)||('string.get ('+str.length+')'));
        return str.charAt(index);
    },
    isBoolean: function (str) {
        return (str=='true' || str=='false')
    },
    isNumeric: function (str) {
        return !isNaN(parseFloat(str)) && isFinite(str);
    },
    isText: function (s) {
      var is_text=true;
      string.iter(s,function (ch,i) {
        string.match(ch,[
          ['a','z',function () {}],
          ['A','Z',function () {}],
          ['0','9',function () {if (i==0) is_text=false;}],
          function () {is_text=false;}
        ]);
      });
      return is_text;
    },
    /**
     *
     * @param {string} str
     * @param {function(string,number)} fun
     */
    iter: function(str,fun) {
        var i;
        var len=str.length;
        for (i = 0; i < len; i++)  {
            var c = str.charAt(i);
            fun(c,i);
        }
    },
    /**
     *
     * @param str
     * @returns {*}
     */
    length: function(str) {
        if (str!=undefined) return str.length;
        else return 0;
    },
    /**
     *
     * @param str
     * @returns {string}
     */
    lowercase : function (str) {
        return str.toLowerCase();
    },
    /**
     *
     * @param {number} size
     * @param {string} init
     * @returns {string}
     */
    make: function(size,init)
    {
        var i;
        var s='';
        for(i=0;i<size;i++) s=s+init;
        return s;
    },
    /** Map a string with a set of (test,reuslt) transformation rules.
     * 
     * @param {string} str
     * @param {* [] []} case - ([string,string] | fun) []
     */
    map: function(str,mapping) {
        var i;
        var map;
        for(i in mapping) {
            map=mapping[i];
            if (obj.isFunction(map)) return map(str);
            else if (this.equal(str,map[0])) return map[1];
        }          
    },
    /** Match a string with different patterns and apply a matching function.
     *
     * @param {string} str
     * @param {* [] []} cases - ([string,fun] | [string [<case1>,<case2>,..],fun] | [<range1>:string,<range2>:string,fun] | fun) []
     */
    match: function(str,cases) {
        var i,j;
        var cas,cex,cv;
        for(i in cases) {
            cas=cases[i];
            if (obj.isArray(cas)) {
              switch (cas.length) {
                case 2:
                  // Multi-value-case
                  cex=cas[0];
                  if (!obj.isArray(cex)) {
                      if (this.equal(str,cex)) {
                          cas[1]();
                          return;
                      }
                  } else {
                      for(j in cex) {
                          cv=cex[j];
                          if (this.equal(str,cv)) {
                              cas[1]();
                              return;
                          }
                      }
                  }
                  break;
                case 3:
                  // Character range check
                  try {
                    j=pervasives.int_of_char(str);
                    if (j>= pervasives.int_of_char(cas[0]) && j<=pervasives.int_of_char(cas[1])) {
                      cas[2](str);
                      return;
                    }
                  } catch(e) {
                    return
                  };
                  break;
                case 1:
                  cas[0](str); // Default case - obsolete
                  return;
                default: 
                  throw 'String.match #args';
              }
            } else if (obj.isFunction(cas)) {
                // Default case
                cas(str);
                return;
            }
        }
    },
    /** Pad a string on the left (pre-str.length) if pre>0,
     *  right (post-str.length) if post>0, or centered (pre>0&post>0).
     *
     */
     
    pad: function (str,pre,post,char) {
      var len = str.length;
      if (pre>0 && post==0) return string.make(len-pre,char||' ')+str;
      else if (post>0 && pre==0) return str+string.make(post-len,char||' ');
      else return string.make(len-pre/2,char||' ')+str+string.make(len-post/2,char||' ');
    },
    /**
     *
     * @param str
     * @param pos
     * @param len
     * @returns {Number}
     */
    parse_hex: function (str,pos,len) {
        // parse a hexadecimal number in string 'str' starting at position 'pos' with 'len' figures.
        return parseInt(this.sub(str,pos,len),16);
    },
    /** Return the sub-string after a point in the source string ('.' or optional point string).
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    postfix: function (str,point) {
      var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(n+1);
    },
    /** Return the sub-string before a point in the source string ('.' or optional point string)
     * If there is no splitting point, the original string is returned.
     *
     * @param str
     * @param [point]
     * @returns {string}
     */
    prefix: function (str,point) {
        var n = str.indexOf(point||'.');
        if (n <= 0) return str;
        else return str.substr(0,n);
    },
    replace_first: function (pat,repl,str) {
        return str.replace(pat,repl);
    },
    replace_all: function (pat,repl,str) {
        return str.replace('/'+pat+'/g',repl);
    },
    /**
     *
     * @param str
     * @param index
     * @param char
     * @returns {string}
     */
    set: function (str,index,char) {
        assert((str != undefined && index < str.length && index >= 0)||'string.get');
        return str.substr(0, index) + char + str.substr(index+1)
    },
    /**
     *
     * @param delim
     * @param str
     * @returns {*|Array}
     */
    split: function (delim,str) {
        return str.split(delim);
    },
    startsWith : function (str,head) {
        return !str.indexOf(head);
    },
    /** Return a sub-string.
     * 
     * @param str
     * @param off
     * @param [len] If not give, return a sub-string from off to end
     * @returns {string}
     */
    sub: function (str,off,len) {
        if (len)
            return str.substr(off,len);
        else
            return str.substr(off);
    },
    /** Remove leading and trailing characters from string
     *
     * @param str
     * @param {number} pref number of head characters to remove
     * @param {number} post number of tail characters to remove
     * @returns {*}
     */
    trim: function (str,pref,post) {
        if (str.length==0 ||
            pref>str.length ||
            post>str.length ||
            pref < 0 || post < 0 ||
            (pref==0 && post==0)
        ) return str;
        return str.substr(pref,str.length-pref-post);
    },
    /** Return a string with all characters converted to uppercase letters.
     *
     * @param str
     * @returns {string}
     */
    uppercase : function (str) {
        return str.toUpperCase();
    },
    /** Return a string with first character converted to uppercase letter.
     *
     * @param str
     * @returns {string}
     */
    Uppercase : function (str) {
        var len = str.length;
        if (len > 1) {
            var head = str.substr(0,1);
            var tail = str.substr(1,len-1);
            return head.toUpperCase()+tail.toLowerCase()
        } if (len==1) return str.toUpperCase();
        else return '';
    }
};

/** RANDOM
 *
 */
var rnd = Math.random;
/* Antti Syk�ri's algorithm adapted from Wikipedia MWC
** Returns a random generator function [0.0,1.0| with seed initialization
*/
var seeder = function(s) {
    var m_w  = s;
    var m_z  = 987654321;
    var mask = 0xffffffff;

    return function() {
      m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
      m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;

      var result = ((m_z << 16) + m_w) & mask;
      result /= 4294967296;

      return result + 0.5;
    }
}
 
var random = {
    float: function(max) {
        return rnd()*max
    }, 
    int: function(max) {
        return Math.floor(rnd()*max+0)
    },
    // integer
    interval: function(min,max) {
        return Math.round(min+rnd()*(max-min))
    },
    // float
    range: function(min,max) {
        return min+rnd()*(max-min)
    },
    seed: function (s) {
      // Create a new initialized random generator
      rnd=seeder(s);
    }
};

/** PRINTF
 *
 */
var printf = {
    /** Trim string(s).
     *
     * @param str
     * @param indent
     * @param [width]
     * @param {string} [tab]
     * @returns {string}
     */
    align: function (str,indent,width,tab) {
        var lines = string.split('\n',str);
        var form = '';
        var sp = printf.spaces(indent);
        var spbreak = sp;

        array.iter(lines,function(line){
            var rest;
            function breakit(spbreak,str) {
                if (width < (str.length + spbreak.length)) {
                    return spbreak+string.sub(str,0,width-spbreak.length)+'\n'+
                           breakit(spbreak,string.sub(str,width-spbreak.length,str.length-width+spbreak.length));
                } else return spbreak+str+'\n';
            }
            if (width && width < (line.length + indent)) {
                if (tab) {
                    var pos = string.find(tab,line);
                    if (pos > 0 && pos < width) spbreak=printf.spaces(pos+indent+1);
                    else spbreak=sp;
                }
                form=form+sp+string.sub(line,0,width-indent)+'\n';
                rest=string.sub(line,width-indent,line.length-width+indent);
                form=form+breakit(spbreak,rest);
            }
            else
                form=form+sp+line+'\n';
        });
        return form;
    },
    /** Format a list of array elements using the (optional) mapping
     *  function <fun> and the separator <sep> (optional, too, default is ',').
     * 
     */
    list: function (array,fun,sep) {
      var i, str='';
      if (sep==undefined) sep=',';
      if (fun==undefined) fun=function (s) {return s;};
      if (!obj.isArray(array)) array=[array];
      for (i in array) {
        if (str==='') str=fun(array[i]);
        else str=str+sep+fun(array[i]);
      }
      return str;
    },
    /**
     *
     * @param n
     * @returns {string}
     */
    spaces: function (n){
        return string.make(n,' ');
    },
    /** Formatted printer (simplified)
     *
     * @param {* []} args (['%format',arg]|string) []  format=%s,%d,%f,%c,%x,%#d,%#s,..
     * @returns {string}
     */
    sprintf2: function(args) {
        var str='';
        array.iter(args,function(fmtarg) {
            var len, n,fs;
            if (obj.isArray(fmtarg)) {
                if (fmtarg.length==2) {
                    var fmt=fmtarg[0];
                    var arg=fmtarg[1];
                    var fc='';
                    var fn=0;
                    string.iter(fmt,function(c) {
                        if (c=='s' || c=='d' || c=='f' || c=='x') {
                            fc=c;
                        } else if (c!='%') {
                            fn=fn*10;
                            n=parseInt(c);
                            if (!isNaN(n)) fn=fn+n;
                        }
                    });
                    if (fc=='s' && obj.isString(arg)) {
                        str=str+arg;
                        if (fn!=0) {
                            len=arg.length;
                            if (len<fn) str=str+string.create(fn-len);
                        }
                    } else if (fc=='d' && obj.isNumber(arg)) {
                        fs = pervasives.string_of_int(arg);
                        if (fn!=0) {
                            len = fs.length;
                            if (len < fn) {
                                str=str+string.create(fn-len);
                            }
                        }
                        str=str+fs;
                    } else if (fc=='x' && obj.isNumber(arg)) {
                        fs = string.format_hex(arg,fn||8);
                        str=str+fs;
                    }
                }
            } else if (obj.isString(fmtarg)) {
                str = str + fmtarg;
            }
        });
        return str;
    },
    sprintf:Sprintf.sprintf
};

/** FILENAME
 *
 */
var filename = {
    /**
     *
     * @param path
     * @returns {string}
     */
    basename : function (path) {
        return Path.basename(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    dirname : function (path) {
        return Path.dirname(path);
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    extname : function (path) {
        return Path.extname(path)
    },
    /**
     *
     * @param path
     * @returns {boolean}
     */
    is_relative: function(path) {
        return !(path.length > 0 && path[0] == '/');
    },
    /**
     *
     * @param pathl
     * @param absolute
     * @returns {string}
     */
    join: function (pathl,absolute) {
        var path=(absolute?'/':'');
        array.iter(pathl,function (name,index) {
            if (index>0) {
                path=path+'/'+name;
            }
            else {
                path=path+name;
            }
        });
        return path;
    },
    /**
     *
     * @param path
     * @returns {string}
     */
    normalize : function (path) {
        return Path.normalize(path)
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    path_absolute: function (path) {
        if (this.is_relative(path)) {
            var workdir = Io.workdir();
            return this.path_normalize(workdir + '/' + path);
        } else return this.path_normalize(path);
    },
    /** Duplicate of Path.normalize!?
     *
     * @param path
     * @returns {string}
     */
    path_normalize: function (path) {
        var i;
        if (string.equal(path, '')) path = '/';
        var relpath = !(string.get(path, 0) == '/');
        var pathlist = path.split('/');
        var pathlist2 = pathlist.filter(function (s) {
            return (!string.equal(s, '') && !string.equal(s, '.'))
        });
        var pathlist3 = [];
        array.iter(pathlist2, function (pe) {
            if (!string.equal(pe, '..')) {
                array.push(pathlist3, pe)
            } else {
                if (pathlist3.length == 0) return '';
                else
                    pathlist3 = array.tail(pathlist3);
            }
        });
        var path2 = '';
        i = 0;
        array.iter(pathlist3, function (pe) {
            var sep;
            if (i == 0) sep = ''; else sep = '/';
            path2 = pe + sep + path2;
            i++;
        });
        if (relpath) return path2; else return '/' + path2;
    },
    removeext: function (path) {
      return path.substr(0, path.lastIndexOf('.'));
    }
};

/** PERVASIVES
 *
 *
 */
var pervasives = {
    assert:assert,
    char_of_int: function (i) {return String.fromCharCode(i)},
    div: function(a,b) {return a/b|0;},
    failwith: function(msg) {Io.err(msg);},
    float_of_string: function(s) {var num=parseFloat(s); if (isNaN(num)) throw 'NaN'; else return num;},
    int_of_char: function(c) {return c.charCodeAt()},
    int_of_float: function(f) {return f|0;},
    int_of_string: function(s) {      
      var num=parseInt(s); if (isNaN(num)) throw 'NaN'; else return num;
    },

    /** Try to find a value in a search list and return a mapping value.
     *
     * @param {*} value
     * @param {* []} mapping [testval,mapval] []
     * @returns {*}
     */
    map: function(value,mapping) {
        function eq(v1,v2) {
            if (v1==v2) return true;
            if (obj.isString(v1) && obj.isString(v2)) return string.equal(v1,v2);
            return false;
        }
        if (!array.empty(mapping)) {
          var hd=array.head(mapping);
          var tl=array.tail(mapping);
          if (eq(hd[0],value)) return hd[1];
          else return pervasives.map(value,tl);
        }  else return undefined;
    },
    /** Apply a matcher function to a list of cases with case handler functions.
     * A case is matched if the matcher function returns a value/object.
     *
     * The result of the matcher function is passed as an argument ot the case handler function.
     * The return value of the case handler fucntion is finally returned by this match function
     * or undefined if there was no matching case.
     *
     * @param {function(*,*):*} matcher function(expr,pat)
     * @param {*} expr
     * @param {*[]} cases (pattern,handler function | handler function) []
     * @returns {*|undefined}
     */
    match: function (matcher,expr,cases) {
        var ret = undefined;
        array.iter_break(cases, function (match) {
            var quit, succ, pat, fun;

            if (match.length == 2) {
                /*
                 ** Pattern, Function
                 */
                pat = match[0];
                fun = match[1];
                succ = matcher(expr, pat);
                if (succ) ret = fun(succ);
                quit = succ!=undefined;
            } else if (match.length == 1) {
                /*
                 ** Default case, Function
                 */
                fun = match[0];
                ret = fun();
                quit= true;
            }
            return quit;
        });
        return ret;
    },
    mtime: function () {var time = new Date(); return time.getTime();},
    min: function(a,b) { return (a<b)?a:b},
    max: function(a,b) { return (a>b)?a:b},
    string_of_float: function(f) {return f.toString()},
    string_of_int: function(i) {return i.toString()},
    string_of_int64: function(i) {return i.toString()},
    time: function () {var time = new Date(); return (time.getTime()/1000)|0;}
};

/** BIT
 *
 */
var bit = {
    get: function (v,b) {return (v >> b) && 1;},
    isSet: function (v,b) {return ((v >> b) && 1)==1;},
    set: function (v,b) {return v & (1 << b);}
};

/** ARGS
 *
 */
var args = {
    /** Parse process or command line arguments (array argv). The first offset [1] arguments are
     ** ignored. The numarg pattern '*' consumes all remaining arguments.
     *
     * @param {string []} argv
     * @param {*[]} map  [<argname>,<numargs:0..3|'*'>,<handler(up to 3 arguments|[])>]|[<defhandler(val)>] []
     * @param {number} [offset]
     */
    parse: function(argv,map,offset) {
        var shift=undefined,
            in_shift=0,
            shift_args=[],
            names,
            mapfun,
            numarg,
            len=argv.length;

        if (offset==undefined) offset=1;

        argv.forEach(function (val, index) {
            var last=index==(len-1);
            if(index>=offset) {
                if (in_shift==0) {
                    array.check(map,function (onemap) {
                        assert(onemap!=undefined||'map');
                        if (onemap.length==3) {
                            names  = onemap[0];
                            numarg = onemap[1];
                            mapfun = onemap[2];
                            if (!obj.isArray(names)) names=[names];
                            var found = array.find(names,function (name) {
                                if (string.equal(val, name)) return name; else _;
                            });
                            if (found) {
                                if (numarg==0) mapfun(found);
                                else {
                                    in_shift=numarg;
                                    shift_args=[];
                                    shift=mapfun;
                                }
                                return true;
                            }
                        } else if (obj.isFunction(onemap)) {
                          onemap(val);
                          return true;                        
                        } else if (onemap.length==1) {
                            mapfun = onemap[0];
                            mapfun(val);
                            return true;
                        }
                        return false;
                    });
                } else {
                    shift_args.push(val);
                    if (in_shift!='*') in_shift--;
                    if (in_shift==0 && shift!=undefined) {
                        numarg=shift_args.length;
                        switch (numarg) {
                            case 0: shift(val);break;
                            case 1: shift(shift_args[0],val); break;
                            case 2: shift(shift_args[0],shift_args[1],val); break;
                            case 3: shift(shift_args[0],shift_args[1],shift_args[2],val); break;
                            default: break;
                        }
                        shift=undefined;
                    } else if (in_shift=='*' && last) shift(shift_args);
                }
            }
        });
    }

};

/** HASHTBL
 *
 */
var hashtbl = {
    add: function(hash,key,data) {
        hash[key]=data;
    },
    create: function(initial) {
        return [];
    },
    empty: function(hash) {
        for (var key in hash) return false;
        return true;
    },
    find: function(hash,key) {
        return hash[key];
    },
    invalidate: function(hash,key) {
        hash[key]=undefined;
    },
    iter: function(hash,fun) {
        for (var key in hash) {
            if (hash[key]!=undefined) fun(key,hash[key]);
        }
    },
    mem: function(hash,key) {
        return hash[key] != undefined;
    },
    remove: function(hash,key) {
        // TODO: check, its wrong!
        if (!hash.hasOwnProperty(key))
            return;
        if (isNaN(parseInt(key)) || !(hash instanceof Array))
            delete hash[key];
        else
            hash.splice(key, 1)
    }
};

var types = [];
/**
 * 
 * @param name
 * @returns {number}
 */
function register_type(name) {
    var typoff = 1000+types.length*1000;
    if (array.member(types,name)) throw('[COMP] register_type: type '+name+' exists already.');
    types.push(name);
    return typoff;
}

/**
 *
 * @typedef {{v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tuple
 */
/**
 *
 * @typedef {{t:number, v1:*, v2:*, v3:*, v4:*, v5:*, v6:*, v7:*, v8:*, v9:*  }} tagged_tuple
 */

module.exports = {
    args:args,
    assert: assert,
    array:array,
    bit:bit,
    defineGetter : defineGetter,
    defineSetter : defineSetter,
    div:pervasives.div,
    filename:filename,
    hashtbl:hashtbl,
    inherit : inherit,
    inheritPrototype : inheritPrototype,
    instanceOf : instanceOf,
    isNodeJS: function () {
        return (typeof global !== "undefined" &&
                {}.toString.call(global) == '[object global]');
    },
    obj:obj,
    pervasives:pervasives,
    printf:printf,
    random:random,
    string:string,
    isArray: obj.isArray,
    isString: obj.isString,
    isNumber: obj.isNumber,

    register_type:register_type,
    /**
     *
     * @param tag
     * @param [val1]
     * @param [val2]
     * @param [val3]
     * @returns {(tagged_tuple)}
     */
    Tuple: function (tag,val1,val2,val3) {
        if(val3) return {t:tag,v1:val1,v2:val2,v3:val3};
        else if (val2) return {t:tag,v1:val1,v2:val2};
        else if (val1) return {t:tag,v1:val1};
        else return {t:tag};
    }
};
};
BundleModuleCode['plugins/csp/cspS']=function (module,exports,global,process){
var CSP = {},
    FAILURE = 'FAILURE',
    stepCounter = 0;

CSP.solve = function solve(csp) {
  // Solves a constraint satisfaction problem.
  // `csp` is an object that should have the properties:
  //    `variables`  : object that holds variable names and their domain.
  //    `constraints`: list of constraints where each element is an 
  //                   array of [head node, tail node, constraint function]
  //    `cb`: optional callback function.

  var result = backtrack({}, csp.variables, csp);
  if (result == FAILURE) { return result; }
  // Unwrap values from array containers.
  for (var key in result) {
    result[key] = result[key][0];
  }
  if (csp.cb) csp.cb(result);
  return result;
}

function backtrack(_assigned, unassigned, csp) {
  // Backtracking search.
  
  // Copying assigned in necessary because we modify it. Without copying
  // the object over, modifying assigned would also change values for old
  // assigned objects (which are used in callbacks).
  var assigned = {};
  for (var key in _assigned) { assigned[key] = _assigned[key]; }

  if (finished(unassigned)) { return assigned; } // Base case.
  var nextKey = selectUnassignedVariable(unassigned),
      values = orderValues(nextKey, assigned, unassigned, csp);
  delete unassigned[nextKey];

  for (var i = 0; i < values.length; i++) {
    stepCounter++;
    assigned[nextKey] = [values[i]]; // Assign a value to a variable.
    var consistent = enforceConsistency(assigned, unassigned, csp);
    var newUnassigned = {}, newAssigned = {};
    for (var key in consistent) {
      if (assigned[key]) { newAssigned[key] = assigned[key].slice(); }
      else { newUnassigned[key] = consistent[key].slice(); }
    }
    if (anyEmpty(consistent)) { continue; } // Empty domains means failure.
    var result = backtrack(newAssigned, newUnassigned, csp);
    if (result != FAILURE) { return result; }
  }

  return FAILURE;
}

function finished(unassigned) {
  // Checks if there are no more variables to assign.
  return Object.keys(unassigned).length == 0;
}

function anyEmpty(consistent) {
  // Checks if any variable's domain is empty.
  for (var key in consistent) {
    if (consistent[key].length == 0) { return true; }
  }
  return false;
}

function partialAssignment(assigned, unassigned) {
  // Combine unassigned and assigned for use in enforceConsistency.
  var partial = {};
  for (var key in unassigned) { partial[key] = unassigned[key].slice(); }
  for (var key in assigned) { partial[key] = assigned[key].slice(); }
  return partial;
}

function enforceConsistency(assigned, unassigned, csp) {
  // Enforces arc consistency by removing inconsistent values from
  // every constraint's tail node.

  function removeInconsistentValues(head, tail, constraint, variables) {
    var hv,tv,validHeadValues,validTailValues,removed;
    if (tail) {
      // Removes inconsistent values from the tail node. A value is
      // inconsistent when if the `tail` is assigned that value, there are
      // no values in `head`'s domain that satisfies the constraint.
      // - binray constraint
      hv = variables[head], tv = variables[tail];
      validTailValues = tv.filter(function (t) {
        return hv.some(function (h) {
          return constraint(h, t);
        });
      });
      removed = tv.length != validTailValues.length;
      variables[tail] = validTailValues;
    } else {
      // unary constraint - modify head
      hv = variables[head];
      validHeadValues = hv.filter(function (h) {
          return constraint(h);
      });
      removed = hv.length != validHeadValues.length;
      variables[head] = validHeadValues;
    }
    return removed;
  }

  function incomingConstraints(node) {
    // Returns all the constraints where `node` is the head node.
    return csp.constraints.filter(function (c) {
      return c[0] == node;
    });
  }
  
  var queue = csp.constraints.slice(), 
      variables = partialAssignment(assigned, unassigned);
  while (queue.length) { // While there are more constraints to test.
    var c = queue.shift(), head = c[0], tail = c[1], constraint = c[2];
    if (removeInconsistentValues(head, tail, constraint, variables)) {
      // If values from the tail have been removed, incoming constraints
      // to the tail must be rechecked.
      queue = queue.concat(incomingConstraints(tail));
    }
  }
  return variables;
}

function selectUnassignedVariable(unassigned) {
  // Picks the next variable to assign according to the Minimum
  // Remaining Values heuristic. Pick the variable with the fewest
  // values remaining in its domain. This helps identify domain
  // failures earlier.
  var minKey = null, minLen = Number.POSITIVE_INFINITY;
  for (var key in unassigned) {
    var len = unassigned[key].length;
    if (len < minLen) { minKey = key, minLen = len; }
  }
  return minKey;
}

function orderValues(nextKey, assigned, unassigned, csp) {
  // Orders the values of an unassigned variable according to the
  // Least Constraining Values heuristic. Perform arc consistency
  // on each possible value, and order variables according to the
  // how many values were eliminated from all the domains (fewest
  // eliminated in the front). This helps makes success more likely
  // by keeping future options open.
  
  function countValues(vars) {
    var sum = 0;
    for (var key in vars) { sum += vars[key].length; }
    return sum;
  }

  function valuesEliminated(val) {
    assigned[nextKey] = [val];
    var newLength = countValues(enforceConsistency(assigned, unassigned, csp));
    delete assigned[nextKey];
    return newLength;
  }

  // Cache valuesEliminated to be used in sort.
  var cache = {}, values = unassigned[nextKey];
  values.forEach(function(val) {
    cache[val] = valuesEliminated(val);
  });
  // Descending order based on the number of domain values remaining.
  values.sort(function (a, b) { return cache[b] - cache[a]; });
  return values;
}

module.exports = CSP;
};
BundleModuleCode['plugins/csp/cassowary']=function (module,exports,global,process){
/**
 * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
 * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
 *
 * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
 *
 * This is a compiled version of Cassowary/JS. For source versions or to
 * contribute, see the github project:
 *
 *  https://github.com/slightlyoff/cassowary.js/
 *  https://github.com/slightlyoff/cassowary-js-refactor
 *
 */

(function() {
!function(a){"use strict";var b="undefined"!=typeof a.HTMLElement,c=function(a){for(var b=null;a&&a!=Object.prototype;){if(a.tagName){b=a.tagName;break}a=a.prototype}return b||"div"},d=1e-8,e={},f=function(a,b){if(a&&b){if("function"==typeof a[b])return a[b];var c=a.prototype;if(c&&"function"==typeof c[b])return c[b];if(c!==Object.prototype&&c!==Function.prototype)return"function"==typeof a.__super__?f(a.__super__,b):void 0}},g=!1;try{var h=new Map;h.set("foo","bar");var i=h.values();i.next(),h.forEach(function(){});var k=new Map(h);if(k.get("foo")!=h.get("foo"))throw"ctor fail";g=!0}catch(l){}var m=a.c=function(){return m._api?m._api.apply(this,arguments):void 0};m._functionalMap=g,m.GEQ=1,m.LEQ=2;var n=b?function(b,d,e){if(d&&d.prototype instanceof a.HTMLElement){var g=b,h=c(e),i=function(a){return a.__proto__=e,g.apply(a,arguments),e.created&&a.created(),e.decorate&&a.decorate(),a};m.extend(e,{upgrade:i}),b=function(){return i(a.document.createElement(h))},b.prototype=e,m.extend(b,{ctor:g})}return b}:function(a){return a};m.inherit=function(a){var b=null,c=null;a["extends"]&&(c=a["extends"],delete a["extends"]),a.initialize&&(b=a.initialize,delete a.initialize);var d=b||function(){};Object.defineProperty(d,"__super__",{value:c?c:Object,enumerable:!1,configurable:!0,writable:!1}),a._t&&(e[a._t]=d);var f=d.prototype=Object.create(c?c.prototype:Object.prototype);return m.extend(f,a),n(d,c,f,a)},m.own=function(b,c,d){return Object.getOwnPropertyNames(b).forEach(c,d||a),b},m.extend=function(a,b){return m.own(b,function(c){var d=Object.getOwnPropertyDescriptor(b,c);if("function"==typeof d.get||"function"==typeof d.set)Object.defineProperty(a,c,d);else if("function"==typeof d.value||"_"===c.charAt(0))d.writable=!0,d.configurable=!0,d.enumerable=!1,Object.defineProperty(a,c,d);else try{a[c]=b[c]}catch(e){}}),a},m.assert=function(a,b){if(!a)throw new m.InternalError("Assertion failed: "+b)};var o=function(a){return"number"==typeof a?m.Expression.fromConstant(a):a instanceof m.Variable?m.Expression.fromVariable(a):a};m.plus=function(a,b){return a=o(a),b=o(b),a.plus(b)},m.minus=function(a,b){return a=o(a),b=o(b),a.minus(b)},m.times=function(a,b){return a=o(a),b=o(b),a.times(b)},m.divide=function(a,b){return a=o(a),b=o(b),a.divide(b)},m.approx=function(a,b){return a=+a,b=+b,a===b?!0:0==a?Math.abs(b)<d:0==b?Math.abs(a)<d:Math.abs(a-b)<Math.abs(a)*d};var p=1;m._inc=function(){return p++},m.parseJSON=function(a){return JSON.parse(a,function(a,b){if("object"!=typeof b||"string"!=typeof b._t)return b;var c=b._t,d=e[c];if(c&&d){var g=f(d,"fromJSON");if(g)return g(b,d)}return b})},"function"==typeof define&&define.amd?define(m):"object"==typeof module&&module.exports?module.exports=m:a.c=m}(this),function(a){"use strict";if(a._functionalMap)a.HashTable=a.inherit({initialize:function(b){this.hashCode=a._inc(),this._store=b instanceof a.HashTable?new Map(b._store):new Map},clone:function(){return new a.HashTable(this)},get:function(a){var b=this._store.get(a.hashCode);return void 0===b?null:b[1]},clear:function(){this._store.clear()},get size(){return this._store.size},set:function(a,b){return this._store.set(a.hashCode,[a,b])},has:function(a){return this._store.has(a.hashCode)},"delete":function(a){return this._store.delete(a.hashCode)},each:function(a,b){this._store.forEach(function(c){return a.call(b||null,c[0],c[1])},b)},escapingEach:function(a,b){if(this._store.size)for(var c,e,f=this._store.values(),e=f.next();!e.done;){if(c=a.call(b||null,e.value[0],e.value[1])){if(void 0!==c.retval)return c;if(c.brk)break}e=f.next()}},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c in this._store.keys())if(void 0==b._store.get(c))return!1;return!0}});else{var b={},c=function(a,b){Object.keys(a).forEach(function(c){b[c]=a[c]})};a.HashTable=a.inherit({initialize:function(){this.size=0,this._store={},this._deleted=0},set:function(a,b){var c=a.hashCode;"undefined"==typeof this._store[c]&&this.size++,this._store[c]=[a,b]},get:function(a){if(!this.size)return null;a=a.hashCode;var b=this._store[a];return"undefined"!=typeof b?b[1]:null},clear:function(){this.size=0,this._store={}},_compact:function(){var a={};c(this._store,a),this._store=a},_compactThreshold:100,_perhapsCompact:function(){this._size>30||this._deleted>this._compactThreshold&&(this._compact(),this._deleted=0)},"delete":function(a){a=a.hashCode,this._store.hasOwnProperty(a)&&(this._deleted++,delete this._store[a],this.size>0&&this.size--)},each:function(a,b){if(this.size){this._perhapsCompact();var c=this._store;for(var d in this._store)this._store.hasOwnProperty(d)&&a.call(b||null,c[d][0],c[d][1])}},escapingEach:function(a,c){if(this.size){this._perhapsCompact();for(var d=this,e=this._store,f=b,g=Object.keys(e),h=0;h<g.length;h++)if(function(b){d._store.hasOwnProperty(b)&&(f=a.call(c||null,e[b][0],e[b][1]))}(g[h]),f){if(void 0!==f.retval)return f;if(f.brk)break}}},clone:function(){var b=new a.HashTable;return this.size&&(b.size=this.size,c(this._store,b._store)),b},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c=Object.keys(this._store),d=0;d<c.length;d++){var e=c[d];if(this._store[e][0]!==b._store[e][0])return!1}return!0},toString:function(){var b="";return this.each(function(a,c){b+=a+" => "+c+"\n"}),b},toJSON:function(){return{_t:"c.HashTable"}},fromJSON:function(){var c=new a.HashTable;return c}})}}(this.c||module.parent.exports||{}),function(a){"use strict";a.HashSet=a._functionalMap?a.inherit({_t:"c.HashSet",initialize:function(b){this.hashCode=a._inc(),this._store=b instanceof a.HashSet?new Map(b._store):new Map},add:function(a){return this._store.set(a.hashCode,a)},has:function(a){return this._store.has(a.hashCode)},get size(){return this._store.size},clear:function(){this._store.clear()},values:function(){for(var a=[],b=this._store.values(),c=b.next();!c.done;)a.push(c.value),c=b.next();return a},first:function(){var a=this._store.values(),b=a.next();return b.done?null:b.value},"delete":function(a){this._store.delete(a.hashCode)},each:function(a,b){var c=this;this._store.forEach(function(d){return a.call(b||null,d,d,c)},b)},escapingEach:function(a,b){this.size&&this._store.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a[a.length]=b.toJSON()}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c._store=b.data),c}}):a.inherit({_t:"c.HashSet",initialize:function(){this._store=[],this.size=0,this.hashCode=a._inc()},add:function(a){var b=this._store;b.indexOf(a),-1==b.indexOf(a)&&(b[b.length]=a),this.size=b.length},values:function(){return this._store},first:function(){return this._store[0]},has:function(a){return-1!=this._store.indexOf(a)},"delete":function(a){var b=this._store.indexOf(a);return-1==b?null:(this._store.splice(b,1)[0],this.size=this._store.length,void 0)},clear:function(){this._store.length=0},each:function(a,b){this.size&&this._store.forEach(a,b)},escapingEach:function(a,b){this.size&&this._store.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a[a.length]=b.toJSON()}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c._store=b.data),c}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Error=a.inherit({initialize:function(a){a&&(this._description=a)},_name:"c.Error",_description:"An error has occured in Cassowary",set description(a){this._description=a},get description(){return"("+this._name+") "+this._description},get message(){return this.description},toString:function(){return this.description}});var b=function(b,c){return a.inherit({"extends":a.Error,initialize:function(){a.Error.apply(this,arguments)},_name:b||"",_description:c||""})};a.ConstraintNotFound=b("c.ConstraintNotFound","Tried to remove a constraint never added to the tableu"),a.InternalError=b("c.InternalError"),a.NonExpression=b("c.NonExpression","The resulting expression would be non"),a.NotEnoughStays=b("c.NotEnoughStays","There are not enough stays to give specific values to every variable"),a.RequiredFailure=b("c.RequiredFailure","A required constraint cannot be satisfied"),a.TooDifficult=b("c.TooDifficult","The constraints are too difficult to solve")}(this.c||module.parent.exports||{}),function(a){"use strict";var b=1e3;a.SymbolicWeight=a.inherit({_t:"c.SymbolicWeight",initialize:function(){this.value=0;for(var a=1,c=arguments.length-1;c>=0;--c)this.value+=arguments[c]*a,a*=b},toJSON:function(){return{_t:this._t,value:this.value}}})}(this.c||module.parent.exports||{}),function(a){a.Strength=a.inherit({initialize:function(b,c,d,e){this.name=b,this.symbolicWeight=c instanceof a.SymbolicWeight?c:new a.SymbolicWeight(c,d,e)},get required(){return this===a.Strength.required},toString:function(){return this.name+(this.required?"":":"+this.symbolicWeight)}}),a.Strength.required=new a.Strength("<Required>",1e3,1e3,1e3),a.Strength.strong=new a.Strength("strong",1,0,0),a.Strength.medium=new a.Strength("medium",0,1,0),a.Strength.weak=new a.Strength("weak",0,0,1)}(this.c||("undefined"!=typeof module?module.parent.exports.c:{})),function(a){"use strict";a.AbstractVariable=a.inherit({isDummy:!1,isExternal:!1,isPivotable:!1,isRestricted:!1,_init:function(b,c){this.hashCode=a._inc(),this.name=(c||"")+this.hashCode,b&&("undefined"!=typeof b.name&&(this.name=b.name),"undefined"!=typeof b.value&&(this.value=b.value),"undefined"!=typeof b.prefix&&(this._prefix=b.prefix))},_prefix:"",name:"",value:0,valueOf:function(){return this.value},toJSON:function(){var a={};return this._t&&(a._t=this._t),this.name&&(a.name=this.name),"undefined"!=typeof this.value&&(a.value=this.value),this._prefix&&(a._prefix=this._prefix),this._t&&(a._t=this._t),a},fromJSON:function(b,c){var d=new c;return a.extend(d,b),d},toString:function(){return this._prefix+"["+this.name+":"+this.value+"]"}}),a.Variable=a.inherit({_t:"c.Variable","extends":a.AbstractVariable,initialize:function(b){this._init(b,"v");var c=a.Variable._map;c&&(c[this.name]=this)},isExternal:!0}),a.DummyVariable=a.inherit({_t:"c.DummyVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"d")},isDummy:!0,isRestricted:!0,value:"dummy"}),a.ObjectiveVariable=a.inherit({_t:"c.ObjectiveVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"o")},value:"obj"}),a.SlackVariable=a.inherit({_t:"c.SlackVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"s")},isPivotable:!0,isRestricted:!0,value:"slack"})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Point=a.inherit({initialize:function(b,c,d){if(b instanceof a.Variable)this._x=b;else{var e={value:b};d&&(e.name="x"+d),this._x=new a.Variable(e)}if(c instanceof a.Variable)this._y=c;else{var f={value:c};d&&(f.name="y"+d),this._y=new a.Variable(f)}},get x(){return this._x},set x(b){b instanceof a.Variable?this._x=b:this._x.value=b},get y(){return this._y},set y(b){b instanceof a.Variable?this._y=b:this._y.value=b},toString:function(){return"("+this.x+", "+this.y+")"}})}(this.c||module.parent.exports||{}),function(a){"use strict";var b=function(a,b){return"number"==typeof a?a:b};a.Expression=a.inherit({initialize:function(c,d,e){this.constant=b(e,0),this.terms=new a.HashTable,this.externalVariables=new a.HashSet,Object.defineProperty(this,"solver",{enumerable:!1,configurable:!0,writable:!0,value:null}),c instanceof a.AbstractVariable?(d=b(d,1),this.setVariable(c,d)):"number"==typeof c&&(isNaN(c)?console.trace():this.constant=c)},initializeFromHash:function(a,b){return this.constant=a,this.terms=b.clone(),this},multiplyMe:function(a){this.constant*=a;var b=this.terms;return b.each(function(c,d){b.set(c,d*a)}),this},clone:function(){var b=a.Expression.empty();return b.initializeFromHash(this.constant,this.terms),b.solver=this.solver,b},times:function(b){if("number"==typeof b)return this.clone().multiplyMe(b);if(this.isConstant)return b.times(this.constant);if(b.isConstant)return this.times(b.constant);throw new a.NonExpression},plus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,1):b instanceof a.Variable?this.clone().addVariable(b,1):void 0},minus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,-1):b instanceof a.Variable?this.clone().addVariable(b,-1):void 0},divide:function(b){if("number"==typeof b){if(a.approx(b,0))throw new a.NonExpression;return this.times(1/b)}if(b instanceof a.Expression){if(!b.isConstant)throw new a.NonExpression;return this.times(1/b.constant)}},addExpression:function(c,d,e){return c instanceof a.AbstractVariable&&(c=a.Expression.fromVariable(c)),d=b(d,1),this.constant+=d*c.constant,c.terms.each(function(a,b){this.addVariable(a,b*d,e),this._updateIfExternal(a)},this),this},addVariable:function(b,c,d){null==c&&(c=1);var e=this.terms.get(b);if(e){var f=e+c;0==f||a.approx(f,0)?(this.solver&&this.solver.noteRemovedVariable(b,d),this.terms.delete(b)):this.setVariable(b,f)}else a.approx(c,0)||(this.setVariable(b,c),this.solver&&this.solver.noteAddedVariable(b,d));return this},_updateIfExternal:function(a){a.isExternal&&(this.externalVariables.add(a),this.solver&&this.solver._noteUpdatedExternal(a))},setVariable:function(a,b){return this.terms.set(a,b),this._updateIfExternal(a),this},anyPivotableVariable:function(){if(this.isConstant)throw new a.InternalError("anyPivotableVariable called on a constant");var b=this.terms.escapingEach(function(a){return a.isPivotable?{retval:a}:void 0});return b&&void 0!==b.retval?b.retval:null},substituteOut:function(b,c,d){var e=this.solver;if(!e)throw new a.InternalError("Expressions::substituteOut called without a solver");var f=this.setVariable.bind(this),g=this.terms,h=g.get(b);g.delete(b),this.constant+=h*c.constant,c.terms.each(function(b,c){var i=g.get(b);if(i){var j=i+h*c;a.approx(j,0)?(e.noteRemovedVariable(b,d),g.delete(b)):f(b,j)}else f(b,h*c),e&&e.noteAddedVariable(b,d)})},changeSubject:function(a,b){this.setVariable(a,this.newSubject(b))},newSubject:function(a){var b=1/this.terms.get(a);return this.terms.delete(a),this.multiplyMe(-b),b},coefficientFor:function(a){return this.terms.get(a)||0},get isConstant(){return 0==this.terms.size},toString:function(){var b="",c=!1;if(!a.approx(this.constant,0)||this.isConstant){if(b+=this.constant,this.isConstant)return b;c=!0}return this.terms.each(function(a,d){c&&(b+=" + "),b+=d+"*"+a,c=!0}),b},equals:function(b){return b===this?!0:b instanceof a.Expression&&b.constant===this.constant&&b.terms.equals(this.terms)},Plus:function(a,b){return a.plus(b)},Minus:function(a,b){return a.minus(b)},Times:function(a,b){return a.times(b)},Divide:function(a,b){return a.divide(b)}}),a.Expression.empty=function(b){var c=new a.Expression(void 0,1,0);return c.solver=b,c},a.Expression.fromConstant=function(b,c){var d=new a.Expression(b);return d.solver=c,d},a.Expression.fromValue=function(b,c){b=+b;var d=new a.Expression(void 0,b,0);return d.solver=c,d},a.Expression.fromVariable=function(b,c){var d=new a.Expression(b,1,0);return d.solver=c,d}}(this.c||module.parent.exports||{}),function(a){"use strict";a.AbstractConstraint=a.inherit({initialize:function(b,c){this.hashCode=a._inc(),this.strength=b||a.Strength.required,this.weight=c||1},isEdit:!1,isInequality:!1,isStay:!1,get required(){return this.strength===a.Strength.required},toString:function(){return this.strength+" {"+this.weight+"} ("+this.expression+")"}});var b=a.AbstractConstraint.prototype.toString,c=function(b,c,d){a.AbstractConstraint.call(this,c||a.Strength.strong,d),this.variable=b,this.expression=new a.Expression(b,-1,b.value)};a.EditConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isEdit:!0,toString:function(){return"edit:"+b.call(this)}}),a.StayConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isStay:!0,toString:function(){return"stay:"+b.call(this)}});var d=a.Constraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(b,c,d){a.AbstractConstraint.call(this,c,d),this.expression=b}});a.Inequality=a.inherit({"extends":a.Constraint,_cloneOrNewCle:function(b){return b.clone?b.clone():new a.Expression(b)},initialize:function(b,c,e,f,g){var h=b instanceof a.Expression,i=e instanceof a.Expression,j=b instanceof a.AbstractVariable,k=e instanceof a.AbstractVariable,l="number"==typeof b,m="number"==typeof e;if((h||l)&&k){var n=b,o=c,p=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else if(j&&(i||m)){var n=e,o=c,p=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else{if(h&&m){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(l&&i){var s=e,o=c,t=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(h&&i){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(t),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(s));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(s),-1)}}else{if(h)return d.call(this,b,c,e);if(c==a.GEQ)d.call(this,new a.Expression(e),f,g),this.expression.multiplyMe(-1),this.expression.addVariable(b);else{if(c!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");d.call(this,new a.Expression(e),f,g),this.expression.addVariable(b,-1)}}}},isInequality:!0,toString:function(){return d.prototype.toString.call(this)+" >= 0) id: "+this.hashCode}}),a.Equation=a.inherit({"extends":a.Constraint,initialize:function(b,c,e,f){if(b instanceof a.Expression&&!c||c instanceof a.Strength)d.call(this,b,c,e);else if(b instanceof a.AbstractVariable&&c instanceof a.Expression){var g=b,h=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.AbstractVariable&&"number"==typeof c){var g=b,k=c,i=e,j=f;d.call(this,new a.Expression(k),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.Expression&&c instanceof a.AbstractVariable){var h=b,g=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else{if(!(b instanceof a.Expression||b instanceof a.AbstractVariable||"number"==typeof b)||!(c instanceof a.Expression||c instanceof a.AbstractVariable||"number"==typeof c))throw"Bad initializer to c.Equation";b=b instanceof a.Expression?b.clone():new a.Expression(b),c=c instanceof a.Expression?c.clone():new a.Expression(c),d.call(this,b,e,f),this.expression.addExpression(c,-1)}a.assert(this.strength instanceof a.Strength,"_strength not set")},toString:function(){return d.prototype.toString.call(this)+" = 0)"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.EditInfo=a.inherit({initialize:function(a,b,c,d,e){this.constraint=a,this.editPlus=b,this.editMinus=c,this.prevEditConstant=d,this.index=e},toString:function(){return"<cn="+this.constraint+", ep="+this.editPlus+", em="+this.editMinus+", pec="+this.prevEditConstant+", index="+this.index+">"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Tableau=a.inherit({initialize:function(){this.columns=new a.HashTable,this.rows=new a.HashTable,this._infeasibleRows=new a.HashSet,this._externalRows=new a.HashTable},noteRemovedVariable:function(a,b){var c=this.columns.get(a);b&&c&&c.delete(b)},noteAddedVariable:function(a,b){b&&this.insertColVar(a,b)},getInternalInfo:function(){return"Tableau Information:\nRows: "+this.rows.size+" (= "+(this.rows.size-1)+" constraints)"+"\nColumns: "+this.columns.size+"\nInfeasible Rows: "+this._infeasibleRows.size+"\nExternal basic variables: "+this._externalRows.size},toString:function(){var a="Tableau:\n";return this.rows.each(function(b,c){a+=b+" <==> "+c+"\n"}),a+="\nColumns:\n",a+=this.columns,a+="\nInfeasible rows: ",a+=this._infeasibleRows,a+="External basic variables: ",a+=this._externalRows},insertColVar:function(b,c){var d=this.columns.get(b);d||(d=new a.HashSet,this.columns.set(b,d)),d.add(c)},addRow:function(a,b){this.rows.set(a,b),b.terms.each(function(b){this.insertColVar(b,a)},this),a.isExternal&&this._externalRows.set(a,b)},removeColumn:function(a){var b=this.columns.get(a);b&&(this.columns.delete(a),b.each(function(b){var c=this.rows.get(b);c.terms.delete(a)},this)),a.isExternal&&this._externalRows.delete(a)},removeRow:function(b){var c=this.rows.get(b);return a.assert(null!=c),c.terms.each(function(a){var d=this.columns.get(a);null!=d&&d.delete(b)},this),this._infeasibleRows.delete(b),b.isExternal&&this._externalRows.delete(b),this.rows.delete(b),c},substituteOut:function(a,b){var c=this.columns.get(a);c.each(function(c){var d=this.rows.get(c);d.substituteOut(a,b,c,this),c.isExternal&&this._updatedExternals.add(c),c.isRestricted&&d.constant<0&&this._infeasibleRows.add(c)},this),a.isExternal&&this._externalRows.set(a,b),this.columns.delete(a)},columnsHasKey:function(a){return!!this.columns.get(a)}})}(this.c||module.parent.exports||{}),function(a){var b=a.Tableau,c=b.prototype,d=1e-8,e=a.Strength.weak,f={eplus:null,eminus:null,prevEConstant:null};a.SimplexSolver=a.inherit({"extends":a.Tableau,initialize:function(){a.Tableau.call(this),this._stayMinusErrorVars=[],this._stayPlusErrorVars=[],this._errorVars=new a.HashTable,this._markerVars=new a.HashTable,this._objective=new a.ObjectiveVariable({name:"Z"}),this._editVarMap=new a.HashTable,this._editVarList=[],this._slackCounter=0,this._artificialCounter=0,this._dummyCounter=0,this.autoSolve=!0,this._needsSolving=!1,this._optimizeCount=0,this.rows.set(this._objective,a.Expression.empty(this)),this._editVariableStack=[0],this._updatedExternals=new a.HashSet},_noteUpdatedExternal:function(a){this._updatedExternals.add(a)},add:function(){for(var a=0;a<arguments.length;a++)this.addConstraint(arguments[a]);return this},addEditVar:function(b,c,d){var e=new a.EditConstraint(b,c||a.Strength.strong,d);return this.addEditConstraint(e),this},addEditConstraint:function(a){var b=f;return this.addConstraint(a),this._addEditConstraint(a,b.eplus,b.eminus,b.prevEConstant),this},_addEditConstraint:function(b,c,d,e){var f=this._editVarMap.size,g=new a.EditInfo(b,c,d,e,f);this._editVarMap.set(b.variable,g),this._editVarList[f]={v:b.variable,info:g}},addConstraint:function(b){if(b instanceof a.Constraint){var c=this;b.expression.externalVariables.each(function(a){c._noteUpdatedExternal(a)})}var d=this.newExpression(b);return d.solver=this,this.tryAddingDirectly(d)||this.addWithArtificialVariable(d),this._needsSolving=!0,this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},addConstraintNoException:function(a){try{return this.addConstraint(a),!0}catch(b){return console.error(b),!1}},beginEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this._infeasibleRows.clear(),this._resetStayConstants(),this._editVariableStack[this._editVariableStack.length]=this._editVarMap.size,this},endEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this.resolve(),this._editVariableStack.pop(),this.removeEditVarsTo(this._editVariableStack[this._editVariableStack.length-1]),this},removeAllEditVars:function(){return this.removeEditVarsTo(0)},removeEditVarsTo:function(b){try{for(var c=this._editVarList.length,d=b;c>d;d++)this._editVarList[d]&&this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);return this._editVarList.length=b,a.assert(this._editVarMap.size==b,"_editVarMap.size == n"),this}catch(e){throw new a.InternalError("Constraint not found in removeEditVarsTo")}},addPointStays:function(a){return a.forEach(function(a,b){this.addStay(a.x,e,Math.pow(2,b)),this.addStay(a.y,e,Math.pow(2,b))},this),this},addStay:function(b,c,d){var f=new a.StayConstraint(b,c||e,d||1);return this.addConstraint(f)},setConstant:function(a,b){this._setConstant(a,b),this.resolve()},removeConstraint:function(b){this._needsSolving=!0,this._resetStayConstants();var c=this.rows.get(this._objective),d=this._errorVars.get(b);null!=d&&d.each(function(a){var d=this.rows.get(a);null==d?c.addVariable(a,-b.weight*b.strength.symbolicWeight.value,this._objective,this):c.addExpression(d,-b.weight*b.strength.symbolicWeight.value,this._objective,this)},this);var e=this._markerVars.get(b);if(this._markerVars.delete(b),null==e)throw new a.InternalError("Constraint not found in removeConstraintInternal");if(null==this.rows.get(e)){var f=this.columns.get(e),g=null,h=0;f.each(function(b){if(b.isRestricted){var c=this.rows.get(b),d=c.coefficientFor(e);if(0>d){var f=-c.constant/d;(null==g||h>f||a.approx(f,h)&&b.hashCode<g.hashCode)&&(h=f,g=b)}}},this),null==g&&f.each(function(a){if(a.isRestricted){var b=this.rows.get(a),c=b.coefficientFor(e),d=b.constant/c;(null==g||h>d)&&(h=d,g=a)}},this),null==g&&(0==f.size?this.removeColumn(e):f.escapingEach(function(a){return a!=this._objective?(g=a,{brk:!0}):void 0},this)),null!=g&&this.pivot(e,g)}if(null!=this.rows.get(e)&&this.removeRow(e),null!=d&&d.each(function(a){a!=e&&this.removeColumn(a)},this),b.isStay){if(null!=d)for(var j=0;j<this._stayPlusErrorVars.length;j++)d.delete(this._stayPlusErrorVars[j]),d.delete(this._stayMinusErrorVars[j])}else if(b.isEdit){var k=this._editVarMap.get(b.variable);this.removeColumn(k.editMinus),this._editVarMap.delete(b.variable)}return null!=d&&this._errorVars.delete(d),this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},reset:function(){throw new a.InternalError("reset not implemented")},resolveArray:function(a){var b=a.length;this._editVarMap.each(function(c,d){var e=d.index;b>e&&this.suggestValue(c,a[e])},this),this.resolve()},resolvePair:function(a,b){this.suggestValue(this._editVarList[0].v,a),this.suggestValue(this._editVarList[1].v,b),this.resolve()},resolve:function(){this.dualOptimize(),this._setExternalVariables(),this._infeasibleRows.clear(),this._resetStayConstants()},suggestValue:function(b,c){var d=this._editVarMap.get(b);if(!d)throw new a.Error("suggestValue for variable "+b+", but var is not an edit variable");var e=c-d.prevEditConstant;return d.prevEditConstant=c,this.deltaEditConstant(e,d.editPlus,d.editMinus),this},solve:function(){return this._needsSolving&&(this.optimize(this._objective),this._setExternalVariables()),this},setEditedValue:function(b,c){if(!this.columnsHasKey(b)&&null==this.rows.get(b))return b.value=c,this;if(!a.approx(c,b.value)){this.addEditVar(b),this.beginEdit();try{this.suggestValue(b,c)}catch(d){throw new a.InternalError("Error in setEditedValue")}this.endEdit()}return this},addVar:function(b){if(!this.columnsHasKey(b)&&null==this.rows.get(b))try{this.addStay(b)}catch(c){throw new a.InternalError("Error in addVar -- required failure is impossible")}return this},getInternalInfo:function(){var a=c.getInternalInfo.call(this);return a+="\nSolver info:\n",a+="Stay Error Variables: ",a+=this._stayPlusErrorVars.length+this._stayMinusErrorVars.length,a+=" ("+this._stayPlusErrorVars.length+" +, ",a+=this._stayMinusErrorVars.length+" -)\n",a+="Edit Variables: "+this._editVarMap.size,a+="\n"},getDebugInfo:function(){return this.toString()+this.getInternalInfo()+"\n"},toString:function(){var a=c.getInternalInfo.call(this);return a+="\n_stayPlusErrorVars: ",a+="["+this._stayPlusErrorVars+"]",a+="\n_stayMinusErrorVars: ",a+="["+this._stayMinusErrorVars+"]",a+="\n",a+="_editVarMap:\n"+this._editVarMap,a+="\n"},addWithArtificialVariable:function(b){var c=new a.SlackVariable({value:++this._artificialCounter,prefix:"a"}),d=new a.ObjectiveVariable({name:"az"}),e=b.clone();this.addRow(d,e),this.addRow(c,b),this.optimize(d);var f=this.rows.get(d);if(!a.approx(f.constant,0))throw this.removeRow(d),this.removeColumn(c),new a.RequiredFailure;var g=this.rows.get(c);if(null!=g){if(g.isConstant)return this.removeRow(c),this.removeRow(d),void 0;var h=g.anyPivotableVariable();this.pivot(h,c)}a.assert(null==this.rows.get(c),"rowExpression(av) == null"),this.removeColumn(c),this.removeRow(d)},tryAddingDirectly:function(a){var b=this.chooseSubject(a);return null==b?!1:(a.newSubject(b),this.columnsHasKey(b)&&this.substituteOut(b,a),this.addRow(b,a),!0)},chooseSubject:function(b){var c=null,d=!1,e=!1,f=b.terms,g=f.escapingEach(function(a,b){if(d){if(!a.isRestricted&&!this.columnsHasKey(a))return{retval:a}}else if(a.isRestricted){if(!e&&!a.isDummy&&0>b){var f=this.columns.get(a);(null==f||1==f.size&&this.columnsHasKey(this._objective))&&(c=a,e=!0)}}else c=a,d=!0},this);if(g&&void 0!==g.retval)return g.retval;if(null!=c)return c;var h=0,g=f.escapingEach(function(a,b){return a.isDummy?(this.columnsHasKey(a)||(c=a,h=b),void 0):{retval:null}},this);if(g&&void 0!==g.retval)return g.retval;if(!a.approx(b.constant,0))throw new a.RequiredFailure;return h>0&&b.multiplyMe(-1),c},deltaEditConstant:function(a,b,c){var d=this.rows.get(b);if(null!=d)return d.constant+=a,d.constant<0&&this._infeasibleRows.add(b),void 0;var e=this.rows.get(c);if(null!=e)return e.constant+=-a,e.constant<0&&this._infeasibleRows.add(c),void 0;var f=this.columns.get(c);f||console.log("columnVars is null -- tableau is:\n"+this),f.each(function(b){var d=this.rows.get(b),e=d.coefficientFor(c);d.constant+=e*a,b.isExternal&&this._noteUpdatedExternal(b),b.isRestricted&&d.constant<0&&this._infeasibleRows.add(b)},this)},dualOptimize:function(){for(var b=this.rows.get(this._objective);this._infeasibleRows.size;){var c=this._infeasibleRows.first();this._infeasibleRows.delete(c);var d=null,e=this.rows.get(c);if(e&&e.constant<0){var g,f=Number.MAX_VALUE,h=e.terms;if(h.each(function(c,e){if(e>0&&c.isPivotable){var h=b.coefficientFor(c);g=h/e,(f>g||a.approx(g,f)&&c.hashCode<d.hashCode)&&(d=c,f=g)}}),f==Number.MAX_VALUE)throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");this.pivot(d,c)}}},newExpression:function(b){var c=f;c.eplus=null,c.eminus=null,c.prevEConstant=null;var d=b.expression,e=a.Expression.fromConstant(d.constant,this),g=new a.SlackVariable,h=new a.DummyVariable,i=new a.SlackVariable,j=new a.SlackVariable,k=d.terms;if(k.each(function(a,b){var c=this.rows.get(a);c?e.addExpression(c,b):e.addVariable(a,b)},this),b.isInequality){if(++this._slackCounter,g=new a.SlackVariable({value:this._slackCounter,prefix:"s"}),e.setVariable(g,-1),this._markerVars.set(b,g),!b.required){++this._slackCounter,i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),e.setVariable(i,1);var l=this.rows.get(this._objective);l.setVariable(i,b.strength.symbolicWeight.value*b.weight),this.insertErrorVar(b,i),this.noteAddedVariable(i,this._objective)}}else if(b.required)++this._dummyCounter,h=new a.DummyVariable({value:this._dummyCounter,prefix:"d"}),c.eplus=h,c.eminus=h,c.prevEConstant=d.constant,e.setVariable(h,1),this._markerVars.set(b,h);else{++this._slackCounter,j=new a.SlackVariable({value:this._slackCounter,prefix:"ep"}),i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),e.setVariable(j,-1),e.setVariable(i,1),this._markerVars.set(b,j);
var l=this.rows.get(this._objective),m=b.strength.symbolicWeight.value*b.weight;l.setVariable(j,m),this.noteAddedVariable(j,this._objective),l.setVariable(i,m),this.noteAddedVariable(i,this._objective),this.insertErrorVar(b,i),this.insertErrorVar(b,j),b.isStay?(this._stayPlusErrorVars[this._stayPlusErrorVars.length]=j,this._stayMinusErrorVars[this._stayMinusErrorVars.length]=i):b.isEdit&&(c.eplus=j,c.eminus=i,c.prevEConstant=d.constant)}return e.constant<0&&e.multiplyMe(-1),e},optimize:function(b){this._optimizeCount++;var c=this.rows.get(b);a.assert(null!=c,"zRow != null");for(var g,h,e=null,f=null;;){if(g=0,h=c.terms,h.escapingEach(function(a,b){return a.isPivotable&&g>b?(g=b,e=a,{brk:1}):void 0},this),g>=-d)return;var i=Number.MAX_VALUE,j=this.columns.get(e),k=0;if(j.each(function(b){if(b.isPivotable){var c=this.rows.get(b),d=c.coefficientFor(e);0>d&&(k=-c.constant/d,(i>k||a.approx(k,i)&&b.hashCode<f.hashCode)&&(i=k,f=b))}},this),i==Number.MAX_VALUE)throw new a.InternalError("Objective function is unbounded in optimize");this.pivot(e,f)}},pivot:function(a,b){var c=!1;c&&console.time(" SimplexSolver::pivot"),null==a&&console.warn("pivot: entryVar == null"),null==b&&console.warn("pivot: exitVar == null"),c&&console.time("  removeRow");var d=this.removeRow(b);c&&console.timeEnd("  removeRow"),c&&console.time("  changeSubject"),d.changeSubject(b,a),c&&console.timeEnd("  changeSubject"),c&&console.time("  substituteOut"),this.substituteOut(a,d),c&&console.timeEnd("  substituteOut"),c&&console.time("  addRow"),this.addRow(a,d),c&&console.timeEnd("  addRow"),c&&console.timeEnd(" SimplexSolver::pivot")},_resetStayConstants:function(){for(var a=this._stayPlusErrorVars,b=a.length,c=0;b>c;c++){var d=this.rows.get(a[c]);null===d&&(d=this.rows.get(this._stayMinusErrorVars[c])),null!=d&&(d.constant=0)}},_setExternalVariables:function(){var a=[];this._updatedExternals.each(function(b){var c=b.value,d=this._externalRows.get(b);return d?(b.value=d.constant,c!==b.value&&a.push({type:"update",name:b.name,variable:b,oldValue:c}),void 0):(b.value=0,void 0)},this),this._updatedExternals.clear(),this._needsSolving=!1,this._informCallbacks(a),a.length&&this.onsolved(a)},onsolved:function(){},_informCallbacks:function(a){this._callbacks&&this._callbacks.forEach(function(b){b(a)})},_addCallback:function(a){var b=this._callbacks||(this._callbacks=[]);b[b.length]=a},insertErrorVar:function(b,c){var d=this._errorVars.get(b);d||(d=new a.HashSet,this._errorVars.set(b,d)),d.add(c)}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Timer=a.inherit({initialize:function(){this.isRunning=!1,this._elapsedMs=0},start:function(){return this.isRunning=!0,this._startReading=new Date,this},stop:function(){return this.isRunning=!1,this._elapsedMs+=new Date-this._startReading,this},reset:function(){return this.isRunning=!1,this._elapsedMs=0,this},elapsedTime:function(){return this.isRunning?(this._elapsedMs+(new Date-this._startReading))/1e3:this._elapsedMs/1e3}})}(this.c||module.parent.exports||{}),this.c.parser=function(){function a(a){return'"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,escape)+'"'}var b={parse:function(b,c){function k(a){g>e||(e>g&&(g=e,h=[]),h.push(a))}function l(){var a,b,c,d,f;if(d=e,f=e,a=A(),null!==a){for(b=[],c=m();null!==c;)b.push(c),c=m();null!==b?(c=A(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)}else a=null,e=f;return null!==a&&(a=function(a,b){return b}(d,a[1])),null===a&&(e=d),a}function m(){var a,b,c,d;return c=e,d=e,a=Q(),null!==a?(b=t(),null!==b?a=[a,b]:(a=null,e=d)):(a=null,e=d),null!==a&&(a=function(a,b){return b}(c,a[0])),null===a&&(e=c),a}function n(){var a;return b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),a}function o(){var a;return/^[a-zA-Z]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[a-zA-Z]")),null===a&&(36===b.charCodeAt(e)?(a="$",e++):(a=null,0===f&&k('"$"')),null===a&&(95===b.charCodeAt(e)?(a="_",e++):(a=null,0===f&&k('"_"')))),a}function p(){var a;return a=o(),null===a&&(/^[0-9]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[0-9]"))),a}function q(){var a;return f++,/^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\t\\x0B\\f \\xA0\\uFEFF]")),f--,0===f&&null===a&&k("whitespace"),a}function r(){var a;return/^[\n\r\u2028\u2029]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\n\\r\\u2028\\u2029]")),a}function s(){var a;return f++,10===b.charCodeAt(e)?(a="\n",e++):(a=null,0===f&&k('"\\n"')),null===a&&("\r\n"===b.substr(e,2)?(a="\r\n",e+=2):(a=null,0===f&&k('"\\r\\n"')),null===a&&(13===b.charCodeAt(e)?(a="\r",e++):(a=null,0===f&&k('"\\r"')),null===a&&(8232===b.charCodeAt(e)?(a="\u2028",e++):(a=null,0===f&&k('"\\u2028"')),null===a&&(8233===b.charCodeAt(e)?(a="\u2029",e++):(a=null,0===f&&k('"\\u2029"')))))),f--,0===f&&null===a&&k("end of line"),a}function t(){var a,c,d;return d=e,a=A(),null!==a?(59===b.charCodeAt(e)?(c=";",e++):(c=null,0===f&&k('";"')),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=z(),null!==a?(c=s(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=A(),null!==a?(c=u(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d))),a}function u(){var a,c;return c=e,f++,b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),f--,null===a?a="":(a=null,e=c),a}function v(){var a;return f++,a=w(),null===a&&(a=y()),f--,0===f&&null===a&&k("comment"),a}function w(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function x(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=r()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=r()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function y(){var a,c,d,g,h,i,j;if(h=e,"//"===b.substr(e,2)?(a="//",e+=2):(a=null,0===f&&k('"//"')),null!==a){for(c=[],i=e,j=e,f++,d=r(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,d=r(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?(d=r(),null===d&&(d=u()),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function z(){var a,b;for(a=[],b=q(),null===b&&(b=x(),null===b&&(b=y()));null!==b;)a.push(b),b=q(),null===b&&(b=x(),null===b&&(b=y()));return a}function A(){var a,b;for(a=[],b=q(),null===b&&(b=s(),null===b&&(b=v()));null!==b;)a.push(b),b=q(),null===b&&(b=s(),null===b&&(b=v()));return a}function B(){var a,b;return b=e,a=D(),null===a&&(a=C()),null!==a&&(a=function(a,b){return{type:"NumericLiteral",value:b}}(b,a)),null===a&&(e=b),a}function C(){var a,c,d;if(d=e,/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]")),null!==c)for(a=[];null!==c;)a.push(c),/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]"));else a=null;return null!==a&&(a=function(a,b){return parseInt(b.join(""))}(d,a)),null===a&&(e=d),a}function D(){var a,c,d,g,h;return g=e,h=e,a=C(),null!==a?(46===b.charCodeAt(e)?(c=".",e++):(c=null,0===f&&k('"."')),null!==c?(d=C(),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)):(a=null,e=h),null!==a&&(a=function(a,b){return parseFloat(b.join(""))}(g,a)),null===a&&(e=g),a}function E(){var a,c,d,g;if(g=e,/^[\-+]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\-+]")),a=null!==a?a:"",null!==a){if(/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]")),null!==d)for(c=[];null!==d;)c.push(d),/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]"));else c=null;null!==c?a=[a,c]:(a=null,e=g)}else a=null,e=g;return a}function F(){var a,b;return f++,b=e,a=G(),null!==a&&(a=function(a,b){return b}(b,a)),null===a&&(e=b),f--,0===f&&null===a&&k("identifier"),a}function G(){var a,b,c,d,g;if(f++,d=e,g=e,a=o(),null!==a){for(b=[],c=p();null!==c;)b.push(c),c=p();null!==b?a=[a,b]:(a=null,e=g)}else a=null,e=g;return null!==a&&(a=function(a,b,c){return b+c.join("")}(d,a[0],a[1])),null===a&&(e=d),f--,0===f&&null===a&&k("identifier"),a}function H(){var a,c,d,g,h,i,j;return i=e,a=F(),null!==a&&(a=function(a,b){return{type:"Variable",name:b}}(i,a)),null===a&&(e=i),null===a&&(a=B(),null===a&&(i=e,j=e,40===b.charCodeAt(e)?(a="(",e++):(a=null,0===f&&k('"("')),null!==a?(c=A(),null!==c?(d=Q(),null!==d?(g=A(),null!==g?(41===b.charCodeAt(e)?(h=")",e++):(h=null,0===f&&k('")"')),null!==h?a=[a,c,d,g,h]:(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j),null!==a&&(a=function(a,b){return b}(i,a[2])),null===a&&(e=i))),a}function I(){var a,b,c,d,f;return a=H(),null===a&&(d=e,f=e,a=J(),null!==a?(b=A(),null!==b?(c=I(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)):(a=null,e=f),null!==a&&(a=function(a,b,c){return{type:"UnaryExpression",operator:b,expression:c}}(d,a[0],a[2])),null===a&&(e=d)),a}function J(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"')),null===a&&(33===b.charCodeAt(e)?(a="!",e++):(a=null,0===f&&k('"!"')))),a}function K(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=I(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=L(),null!==d?(f=A(),null!==f?(g=I(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=L(),null!==d?(f=A(),null!==f?(g=I(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"MultiplicativeExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function L(){var a;return 42===b.charCodeAt(e)?(a="*",e++):(a=null,0===f&&k('"*"')),null===a&&(47===b.charCodeAt(e)?(a="/",e++):(a=null,0===f&&k('"/"'))),a}function M(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=K(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=N(),null!==d?(f=A(),null!==f?(g=K(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=N(),null!==d?(f=A(),null!==f?(g=K(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"AdditiveExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function N(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"'))),a}function O(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=M(),null!==a){for(b=[],j=e,c=A(),null!==c?(d=P(),null!==d?(f=A(),null!==f?(g=M(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=A(),null!==c?(d=P(),null!==d?(f=A(),null!==f?(g=M(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"Inequality",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function P(){var a;return"<="===b.substr(e,2)?(a="<=",e+=2):(a=null,0===f&&k('"<="')),null===a&&(">="===b.substr(e,2)?(a=">=",e+=2):(a=null,0===f&&k('">="')),null===a&&(60===b.charCodeAt(e)?(a="<",e++):(a=null,0===f&&k('"<"')),null===a&&(62===b.charCodeAt(e)?(a=">",e++):(a=null,0===f&&k('">"'))))),a}function Q(){var a,c,d,g,h,i,j,l,m;if(j=e,l=e,a=O(),null!==a){for(c=[],m=e,d=A(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=A(),null!==h?(i=O(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==d;)c.push(d),m=e,d=A(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=A(),null!==h?(i=O(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==c?a=[a,c]:(a=null,e=l)}else a=null,e=l;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;e<c.length;e++)d={type:"Equality",operator:c[e][1],left:d,right:c[e][3]};return d}(j,a[0],a[1])),null===a&&(e=j),a}function R(a){a.sort();for(var b=null,c=[],d=0;d<a.length;d++)a[d]!==b&&(c.push(a[d]),b=a[d]);return c}function S(){for(var a=1,c=1,d=!1,f=0;f<Math.max(e,g);f++){var h=b.charAt(f);"\n"===h?(d||a++,c=1,d=!1):"\r"===h||"\u2028"===h||"\u2029"===h?(a++,c=1,d=!0):(c++,d=!1)}return{line:a,column:c}}var d={start:l,Statement:m,SourceCharacter:n,IdentifierStart:o,IdentifierPart:p,WhiteSpace:q,LineTerminator:r,LineTerminatorSequence:s,EOS:t,EOF:u,Comment:v,MultiLineComment:w,MultiLineCommentNoLineTerminator:x,SingleLineComment:y,_:z,__:A,Literal:B,Integer:C,Real:D,SignedInteger:E,Identifier:F,IdentifierName:G,PrimaryExpression:H,UnaryExpression:I,UnaryOperator:J,MultiplicativeExpression:K,MultiplicativeOperator:L,AdditiveExpression:M,AdditiveOperator:N,InequalityExpression:O,InequalityOperator:P,LinearExpression:Q};if(void 0!==c){if(void 0===d[c])throw new Error("Invalid rule name: "+a(c)+".")}else c="start";var e=0,f=0,g=0,h=[],T=d[c]();if(null===T||e!==b.length){var U=Math.max(e,g),V=U<b.length?b.charAt(U):null,W=S();throw new this.SyntaxError(R(h),V,U,W.line,W.column)}return T},toSource:function(){return this._source}};return b.SyntaxError=function(b,c,d,e,f){function g(b,c){var d,e;switch(b.length){case 0:d="end of input";break;case 1:d=b[0];break;default:d=b.slice(0,b.length-1).join(", ")+" or "+b[b.length-1]}return e=c?a(c):"end of input","Expected "+d+" but "+e+" found."}this.name="SyntaxError",this.expected=b,this.found=c,this.message=g(b,c),this.offset=d,this.line=e,this.column=f},b.SyntaxError.prototype=Error.prototype,b}(),function(a){"use strict";var b=new a.SimplexSolver,c={},d={},e=a.Strength.weak;a.Strength.medium,a.Strength.strong,a.Strength.required;var i=function(f){if(d[f])return d[f];switch(f.type){case"Inequality":var g="<="==f.operator?a.LEQ:a.GEQ,h=new a.Inequality(i(f.left),g,i(f.right),e);return b.addConstraint(h),h;case"Equality":var h=new a.Equation(i(f.left),i(f.right),e);return b.addConstraint(h),h;case"MultiplicativeExpression":var h=a.times(i(f.left),i(f.right));return b.addConstraint(h),h;case"AdditiveExpression":return"+"==f.operator?a.plus(i(f.left),i(f.right)):a.minus(i(f.left),i(f.right));case"NumericLiteral":return new a.Expression(f.value);case"Variable":return c[f.name]||(c[f.name]=new a.Variable({name:f.name})),c[f.name];case"UnaryExpression":console.log("UnaryExpression...WTF?")}},j=function(a){return a.map(i)};a._api=function(){var c=Array.prototype.slice.call(arguments);if(1==c.length){if("string"==typeof c[0]){var d=a.parser.parse(c[0]);return j(d)}"function"==typeof c[0]&&b._addCallback(c[0])}}}(this.c||module.parent.exports||{});
}).call(
  (typeof module != "undefined") ?
      (module.compiled = true && module) : this
);
};
BundleModuleCode['plugins/csp/constrained']=function (module,exports,global,process){
/* https://github.com/Wizcorp/constrained */
var _modules={};
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
})({
    1: [function(require, module, exports) {
        /**
         * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
         * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
         *
         * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
         *
         * This is a compiled version of Cassowary/JS. For source versions or to
         * contribute, see the github project:
         *
         *  https://github.com/slightlyoff/cassowary-js-refactor
         *
         */

        (function() {
            ! function(a) {
                "use strict";
                var b = "undefined" != typeof a.HTMLElement,
                    c = function(a) {
                        for (var b = null; a && a != Object.prototype;) {
                            if (a.tagName) {
                                b = a.tagName;
                                break
                            }
                            a = a.prototype
                        }
                        return b || "div"
                    },
                    d = 1e-8,
                    e = {},
                    f = function(a, b) {
                        if (a && b) {
                            if ("function" == typeof a[b]) return a[b];
                            var c = a.prototype;
                            if (c && "function" == typeof c[b]) return c[b];
                            if (c !== Object.prototype && c !== Function.prototype) return "function" == typeof a.__super__ ? f(a.__super__, b) : void 0
                        }
                    },
                    g = !1;
                try {
                    var h = new Map;
                    h.set("foo", "bar");
                    var i = h.values();
                    i.next(), h.forEach(function() {});
                    var k = new Map(h);
                    if (k.get("foo") != h.get("foo")) throw "ctor fail";
                    g = !0
                } catch (l) {}
                var m = a.c = function() {
                    return m._api ? m._api.apply(this, arguments) : void 0
                };
                m._functionalMap = g, m.GEQ = 1, m.LEQ = 2;
                var n = b ? function(b, d, e) {
                    if (d && d.prototype instanceof a.HTMLElement) {
                        var g = b,
                            h = c(e),
                            i = function(a) {
                                return a.__proto__ = e, g.apply(a, arguments), e.created && a.created(), e.decorate && a.decorate(), a
                            };
                        m.extend(e, {
                            upgrade: i
                        }), b = function() {
                            return i(a.document.createElement(h))
                        }, b.prototype = e, m.extend(b, {
                            ctor: g
                        })
                    }
                    return b
                } : function(a) {
                    return a
                };
                m.inherit = function(a) {
                    var b = null,
                        c = null;
                    a["extends"] && (c = a["extends"], delete a["extends"]), a.initialize && (b = a.initialize, delete a.initialize);
                    var d = b || function() {};
                    Object.defineProperty(d, "__super__", {
                        value: c ? c : Object,
                        enumerable: !1,
                        configurable: !0,
                        writable: !1
                    }), a._t && (e[a._t] = d);
                    var f = d.prototype = Object.create(c ? c.prototype : Object.prototype);
                    return m.extend(f, a), n(d, c, f, a)
                }, m.own = function(b, c, d) {
                    return Object.getOwnPropertyNames(b).forEach(c, d || a), b
                }, m.extend = function(a, b) {
                    return m.own(b, function(c) {
                        var d = Object.getOwnPropertyDescriptor(b, c);
                        if ("function" == typeof d.get || "function" == typeof d.set) Object.defineProperty(a, c, d);
                        else if ("function" == typeof d.value || "_" === c.charAt(0)) d.writable = !0, d.configurable = !0, d.enumerable = !1, Object.defineProperty(a, c, d);
                        else try {
                            a[c] = b[c]
                        } catch (e) {}
                    }), a
                }, m.assert = function(a, b) {
                    if (!a) throw new m.InternalError("Assertion failed: " + b)
                };
                var o = function(a) {
                    return "number" == typeof a ? m.Expression.fromConstant(a) : a instanceof m.Variable ? m.Expression.fromVariable(a) : a
                };
                m.plus = function(a, b) {
                    return a = o(a), b = o(b), a.plus(b)
                }, m.minus = function(a, b) {
                    return a = o(a), b = o(b), a.minus(b)
                }, m.times = function(a, b) {
                    return a = o(a), b = o(b), a.times(b)
                }, m.divide = function(a, b) {
                    return a = o(a), b = o(b), a.divide(b)
                }, m.approx = function(a, b) {
                    return a = +a, b = +b, a === b ? !0 : 0 == a ? Math.abs(b) < d : 0 == b ? Math.abs(a) < d : Math.abs(a - b) < Math.abs(a) * d
                };
                var p = 1;
                m._inc = function() {
                    return p++
                }, m.parseJSON = function(a) {
                    return JSON.parse(a, function(a, b) {
                        if ("object" != typeof b || "string" != typeof b._t) return b;
                        var c = b._t,
                            d = e[c];
                        if (c && d) {
                            var g = f(d, "fromJSON");
                            if (g) return g(b, d)
                        }
                        return b
                    })
                }, "function" == typeof define && define.amd ? define(m) : "object" == typeof module && module.exports ? module.exports = m : a.c = m
            }(this),
            function(a) {
                "use strict";
                if (a._functionalMap) a.HashTable = a.inherit({
                    initialize: function(b) {
                        this.hashCode = a._inc(), this._store = b instanceof a.HashTable ? new Map(b._store) : new Map
                    },
                    clone: function() {
                        return new a.HashTable(this)
                    },
                    get: function(a) {
                        var b = this._store.get(a.hashCode);
                        return void 0 === b ? null : b[1]
                    },
                    clear: function() {
                        this._store.clear()
                    },
                    get size() {
                        return this._store.size
                    },
                    set: function(a, b) {
                        return this._store.set(a.hashCode, [a, b])
                    },
                    has: function(a) {
                        return this._store.has(a.hashCode)
                    },
                    "delete": function(a) {
                        return this._store.delete(a.hashCode)
                    },
                    each: function(a, b) {
                        this._store.forEach(function(c) {
                            return a.call(b || null, c[0], c[1])
                        }, b)
                    },
                    escapingEach: function(a, b) {
                        if (this._store.size)
                            for (var c, e, f = this._store.values(), e = f.next(); !e.done;) {
                                if (c = a.call(b || null, e.value[0], e.value[1])) {
                                    if (void 0 !== c.retval) return c;
                                    if (c.brk) break
                                }
                                e = f.next()
                            }
                    },
                    equals: function(b) {
                        if (b === this) return !0;
                        if (!(b instanceof a.HashTable) || b._size !== this._size) return !1;
                        for (var c in this._store.keys())
                            if (void 0 == b._store.get(c)) return !1;
                        return !0
                    }
                });
                else {
                    var b = {},
                        c = function(a, b) {
                            Object.keys(a).forEach(function(c) {
                                b[c] = a[c]
                            })
                        };
                    a.HashTable = a.inherit({
                        initialize: function() {
                            this.size = 0, this._store = {}, this._deleted = 0
                        },
                        set: function(a, b) {
                            var c = a.hashCode;
                            "undefined" == typeof this._store[c] && this.size++, this._store[c] = [a, b]
                        },
                        get: function(a) {
                            if (!this.size) return null;
                            a = a.hashCode;
                            var b = this._store[a];
                            return "undefined" != typeof b ? b[1] : null
                        },
                        clear: function() {
                            this.size = 0, this._store = {}
                        },
                        _compact: function() {
                            var a = {};
                            c(this._store, a), this._store = a
                        },
                        _compactThreshold: 100,
                        _perhapsCompact: function() {
                            this._size > 30 || this._deleted > this._compactThreshold && (this._compact(), this._deleted = 0)
                        },
                        "delete": function(a) {
                            a = a.hashCode, this._store.hasOwnProperty(a) && (this._deleted++, delete this._store[a], this.size > 0 && this.size--)
                        },
                        each: function(a, b) {
                            if (this.size) {
                                this._perhapsCompact();
                                var c = this._store;
                                for (var d in this._store) this._store.hasOwnProperty(d) && a.call(b || null, c[d][0], c[d][1])
                            }
                        },
                        escapingEach: function(a, c) {
                            if (this.size) {
                                this._perhapsCompact();
                                for (var d = this, e = this._store, f = b, g = Object.keys(e), h = 0; h < g.length; h++)
                                    if (function(b) {
                                            d._store.hasOwnProperty(b) && (f = a.call(c || null, e[b][0], e[b][1]))
                                        }(g[h]), f) {
                                        if (void 0 !== f.retval) return f;
                                        if (f.brk) break
                                    }
                            }
                        },
                        clone: function() {
                            var b = new a.HashTable;
                            return this.size && (b.size = this.size, c(this._store, b._store)), b
                        },
                        equals: function(b) {
                            if (b === this) return !0;
                            if (!(b instanceof a.HashTable) || b._size !== this._size) return !1;
                            for (var c = Object.keys(this._store), d = 0; d < c.length; d++) {
                                var e = c[d];
                                if (this._store[e][0] !== b._store[e][0]) return !1
                            }
                            return !0
                        },
                        toString: function() {
                            var b = "";
                            return this.each(function(a, c) {
                                b += a + " => " + c + "\n"
                            }), b
                        },
                        toJSON: function() {
                            return {
                                _t: "c.HashTable"
                            }
                        },
                        fromJSON: function() {
                            var c = new a.HashTable;
                            return c
                        }
                    })
                }
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.HashSet = a._functionalMap ? a.inherit({
                    _t: "c.HashSet",
                    initialize: function(b) {
                        this.hashCode = a._inc(), this._store = b instanceof a.HashSet ? new Map(b._store) : new Map
                    },
                    add: function(a) {
                        return this._store.set(a.hashCode, a)
                    },
                    has: function(a) {
                        return this._store.has(a.hashCode)
                    },
                    get size() {
                        return this._store.size
                    },
                    clear: function() {
                        this._store.clear()
                    },
                    values: function() {
                        for (var a = [], b = this._store.values(), c = b.next(); !c.done;) a.push(c.value), c = b.next();
                        return a
                    },
                    first: function() {
                        var a = this._store.values(),
                            b = a.next();
                        return b.done ? null : b.value
                    },
                    "delete": function(a) {
                        this._store.delete(a.hashCode)
                    },
                    each: function(a, b) {
                        var c = this;
                        this._store.forEach(function(d) {
                            return a.call(b || null, d, d, c)
                        }, b)
                    },
                    escapingEach: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    toString: function() {
                        var a = this.size + " {",
                            b = !0;
                        return this.each(function(c) {
                            b ? b = !1 : a += ", ", a += c
                        }), a += "}\n"
                    },
                    toJSON: function() {
                        var a = [];
                        return this.each(function(b) {
                            a[a.length] = b.toJSON()
                        }), {
                            _t: "c.HashSet",
                            data: a
                        }
                    },
                    fromJSON: function(b) {
                        var c = new a.HashSet;
                        return b.data && (c.size = b.data.length, c._store = b.data), c
                    }
                }) : a.inherit({
                    _t: "c.HashSet",
                    initialize: function() {
                        this._store = [], this.size = 0, this.hashCode = a._inc()
                    },
                    add: function(a) {
                        var b = this._store;
                        b.indexOf(a), -1 == b.indexOf(a) && (b[b.length] = a), this.size = b.length
                    },
                    values: function() {
                        return this._store
                    },
                    first: function() {
                        return this._store[0]
                    },
                    has: function(a) {
                        return -1 != this._store.indexOf(a)
                    },
                    "delete": function(a) {
                        var b = this._store.indexOf(a);
                        return -1 == b ? null : (this._store.splice(b, 1)[0], this.size = this._store.length, void 0)
                    },
                    clear: function() {
                        this._store.length = 0
                    },
                    each: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    escapingEach: function(a, b) {
                        this.size && this._store.forEach(a, b)
                    },
                    toString: function() {
                        var a = this.size + " {",
                            b = !0;
                        return this.each(function(c) {
                            b ? b = !1 : a += ", ", a += c
                        }), a += "}\n"
                    },
                    toJSON: function() {
                        var a = [];
                        return this.each(function(b) {
                            a[a.length] = b.toJSON()
                        }), {
                            _t: "c.HashSet",
                            data: a
                        }
                    },
                    fromJSON: function(b) {
                        var c = new a.HashSet;
                        return b.data && (c.size = b.data.length, c._store = b.data), c
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Error = a.inherit({
                    initialize: function(a) {
                        a && (this._description = a)
                    },
                    _name: "c.Error",
                    _description: "An error has occured in Cassowary",
                    set description(a) {
                        this._description = a
                    },
                    get description() {
                        return "(" + this._name + ") " + this._description
                    },
                    get message() {
                        return this.description
                    },
                    toString: function() {
                        return this.description
                    }
                });
                var b = function(b, c) {
                    return a.inherit({
                        "extends": a.Error,
                        initialize: function() {
                            a.Error.apply(this, arguments)
                        },
                        _name: b || "",
                        _description: c || ""
                    })
                };
                a.ConstraintNotFound = b("c.ConstraintNotFound", "Tried to remove a constraint never added to the tableu"), a.InternalError = b("c.InternalError"), a.NonExpression = b("c.NonExpression", "The resulting expression would be non"), a.NotEnoughStays = b("c.NotEnoughStays", "There are not enough stays to give specific values to every variable"), a.RequiredFailure = b("c.RequiredFailure", "A required constraint cannot be satisfied"), a.TooDifficult = b("c.TooDifficult", "The constraints are too difficult to solve")
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                var b = 1e3;
                a.SymbolicWeight = a.inherit({
                    _t: "c.SymbolicWeight",
                    initialize: function() {
                        this.value = 0;
                        for (var a = 1, c = arguments.length - 1; c >= 0; --c) this.value += arguments[c] * a, a *= b
                    },
                    toJSON: function() {
                        return {
                            _t: this._t,
                            value: this.value
                        }
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                a.Strength = a.inherit({
                    initialize: function(b, c, d, e) {
                        this.name = b, this.symbolicWeight = c instanceof a.SymbolicWeight ? c : new a.SymbolicWeight(c, d, e)
                    },
                    get required() {
                        return this === a.Strength.required
                    },
                    toString: function() {
                        return this.name + (this.required ? "" : ":" + this.symbolicWeight)
                    }
                }), a.Strength.required = new a.Strength("<Required>", 1e3, 1e3, 1e3), a.Strength.strong = new a.Strength("strong", 1, 0, 0), a.Strength.medium = new a.Strength("medium", 0, 1, 0), a.Strength.weak = new a.Strength("weak", 0, 0, 1)
            }(this.c || ("undefined" != typeof module ? module.parent.exports.c : {})),
            function(a) {
                "use strict";
                a.AbstractVariable = a.inherit({
                    isDummy: !1,
                    isExternal: !1,
                    isPivotable: !1,
                    isRestricted: !1,
                    _init: function(b, c) {
                        this.hashCode = a._inc(), this.name = (c || "") + this.hashCode, b && ("undefined" != typeof b.name && (this.name = b.name), "undefined" != typeof b.value && (this.value = b.value), "undefined" != typeof b.prefix && (this._prefix = b.prefix))
                    },
                    _prefix: "",
                    name: "",
                    value: 0,
                    valueOf: function() {
                        return this.value
                    },
                    toJSON: function() {
                        var a = {};
                        return this._t && (a._t = this._t), this.name && (a.name = this.name), "undefined" != typeof this.value && (a.value = this.value), this._prefix && (a._prefix = this._prefix), this._t && (a._t = this._t), a
                    },
                    fromJSON: function(b, c) {
                        var d = new c;
                        return a.extend(d, b), d
                    },
                    toString: function() {
                        return this._prefix + "[" + this.name + ":" + this.value + "]"
                    }
                }), a.Variable = a.inherit({
                    _t: "c.Variable",
                    "extends": a.AbstractVariable,
                    initialize: function(b) {
                        this._init(b, "v");
                        var c = a.Variable._map;
                        c && (c[this.name] = this)
                    },
                    isExternal: !0
                }), a.DummyVariable = a.inherit({
                    _t: "c.DummyVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "d")
                    },
                    isDummy: !0,
                    isRestricted: !0,
                    value: "dummy"
                }), a.ObjectiveVariable = a.inherit({
                    _t: "c.ObjectiveVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "o")
                    },
                    value: "obj"
                }), a.SlackVariable = a.inherit({
                    _t: "c.SlackVariable",
                    "extends": a.AbstractVariable,
                    initialize: function(a) {
                        this._init(a, "s")
                    },
                    isPivotable: !0,
                    isRestricted: !0,
                    value: "slack"
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Point = a.inherit({
                    initialize: function(b, c, d) {
                        if (b instanceof a.Variable) this._x = b;
                        else {
                            var e = {
                                value: b
                            };
                            d && (e.name = "x" + d), this._x = new a.Variable(e)
                        }
                        if (c instanceof a.Variable) this._y = c;
                        else {
                            var f = {
                                value: c
                            };
                            d && (f.name = "y" + d), this._y = new a.Variable(f)
                        }
                    },
                    get x() {
                        return this._x
                    },
                    set x(b) {
                        b instanceof a.Variable ? this._x = b : this._x.value = b
                    },
                    get y() {
                        return this._y
                    },
                    set y(b) {
                        b instanceof a.Variable ? this._y = b : this._y.value = b
                    },
                    toString: function() {
                        return "(" + this.x + ", " + this.y + ")"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                var b = function(a, b) {
                    return "number" == typeof a ? a : b
                };
                a.Expression = a.inherit({
                    initialize: function(c, d, e) {
                        this.constant = b(e, 0), this.terms = new a.HashTable, this.externalVariables = new a.HashSet, Object.defineProperty(this, "solver", {
                            enumerable: !1,
                            configurable: !0,
                            writable: !0,
                            value: null
                        }), c instanceof a.AbstractVariable ? (d = b(d, 1), this.setVariable(c, d)) : "number" == typeof c && (isNaN(c) ? console.trace() : this.constant = c)
                    },
                    initializeFromHash: function(a, b) {
                        return this.constant = a, this.terms = b.clone(), this
                    },
                    multiplyMe: function(a) {
                        this.constant *= a;
                        var b = this.terms;
                        return b.each(function(c, d) {
                            b.set(c, d * a)
                        }), this
                    },
                    clone: function() {
                        var b = a.Expression.empty();
                        return b.initializeFromHash(this.constant, this.terms), b.solver = this.solver, b
                    },
                    times: function(b) {
                        if ("number" == typeof b) return this.clone().multiplyMe(b);
                        if (this.isConstant) return b.times(this.constant);
                        if (b.isConstant) return this.times(b.constant);
                        throw new a.NonExpression
                    },
                    plus: function(b) {
                        return b instanceof a.Expression ? this.clone().addExpression(b, 1) : b instanceof a.Variable ? this.clone().addVariable(b, 1) : void 0
                    },
                    minus: function(b) {
                        return b instanceof a.Expression ? this.clone().addExpression(b, -1) : b instanceof a.Variable ? this.clone().addVariable(b, -1) : void 0
                    },
                    divide: function(b) {
                        if ("number" == typeof b) {
                            if (a.approx(b, 0)) throw new a.NonExpression;
                            return this.times(1 / b)
                        }
                        if (b instanceof a.Expression) {
                            if (!b.isConstant) throw new a.NonExpression;
                            return this.times(1 / b.constant)
                        }
                    },
                    addExpression: function(c, d, e) {
                        return c instanceof a.AbstractVariable && (c = a.Expression.fromVariable(c)), d = b(d, 1), this.constant += d * c.constant, c.terms.each(function(a, b) {
                            this.addVariable(a, b * d, e), this._updateIfExternal(a)
                        }, this), this
                    },
                    addVariable: function(b, c, d) {
                        null == c && (c = 1);
                        var e = this.terms.get(b);
                        if (e) {
                            var f = e + c;
                            0 == f || a.approx(f, 0) ? (this.solver && this.solver.noteRemovedVariable(b, d), this.terms.delete(b)) : this.setVariable(b, f)
                        } else a.approx(c, 0) || (this.setVariable(b, c), this.solver && this.solver.noteAddedVariable(b, d));
                        return this
                    },
                    _updateIfExternal: function(a) {
                        a.isExternal && (this.externalVariables.add(a), this.solver && this.solver._noteUpdatedExternal(a))
                    },
                    setVariable: function(a, b) {
                        return this.terms.set(a, b), this._updateIfExternal(a), this
                    },
                    anyPivotableVariable: function() {
                        if (this.isConstant) throw new a.InternalError("anyPivotableVariable called on a constant");
                        var b = this.terms.escapingEach(function(a) {
                            return a.isPivotable ? {
                                retval: a
                            } : void 0
                        });
                        return b && void 0 !== b.retval ? b.retval : null
                    },
                    substituteOut: function(b, c, d) {
                        var e = this.solver;
                        if (!e) throw new a.InternalError("Expressions::substituteOut called without a solver");
                        var f = this.setVariable.bind(this),
                            g = this.terms,
                            h = g.get(b);
                        g.delete(b), this.constant += h * c.constant, c.terms.each(function(b, c) {
                            var i = g.get(b);
                            if (i) {
                                var j = i + h * c;
                                a.approx(j, 0) ? (e.noteRemovedVariable(b, d), g.delete(b)) : f(b, j)
                            } else f(b, h * c), e && e.noteAddedVariable(b, d)
                        })
                    },
                    changeSubject: function(a, b) {
                        this.setVariable(a, this.newSubject(b))
                    },
                    newSubject: function(a) {
                        var b = 1 / this.terms.get(a);
                        return this.terms.delete(a), this.multiplyMe(-b), b
                    },
                    coefficientFor: function(a) {
                        return this.terms.get(a) || 0
                    },
                    get isConstant() {
                        return 0 == this.terms.size
                    },
                    toString: function() {
                        var b = "",
                            c = !1;
                        if (!a.approx(this.constant, 0) || this.isConstant) {
                            if (b += this.constant, this.isConstant) return b;
                            c = !0
                        }
                        return this.terms.each(function(a, d) {
                            c && (b += " + "), b += d + "*" + a, c = !0
                        }), b
                    },
                    equals: function(b) {
                        return b === this ? !0 : b instanceof a.Expression && b.constant === this.constant && b.terms.equals(this.terms)
                    },
                    Plus: function(a, b) {
                        return a.plus(b)
                    },
                    Minus: function(a, b) {
                        return a.minus(b)
                    },
                    Times: function(a, b) {
                        return a.times(b)
                    },
                    Divide: function(a, b) {
                        return a.divide(b)
                    }
                }), a.Expression.empty = function(b) {
                    var c = new a.Expression(void 0, 1, 0);
                    return c.solver = b, c
                }, a.Expression.fromConstant = function(b, c) {
                    var d = new a.Expression(b);
                    return d.solver = c, d
                }, a.Expression.fromValue = function(b, c) {
                    b = +b;
                    var d = new a.Expression(void 0, b, 0);
                    return d.solver = c, d
                }, a.Expression.fromVariable = function(b, c) {
                    var d = new a.Expression(b, 1, 0);
                    return d.solver = c, d
                }
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.AbstractConstraint = a.inherit({
                    initialize: function(b, c) {
                        this.hashCode = a._inc(), this.strength = b || a.Strength.required, this.weight = c || 1
                    },
                    isEdit: !1,
                    isInequality: !1,
                    isStay: !1,
                    get required() {
                        return this.strength === a.Strength.required
                    },
                    toString: function() {
                        return this.strength + " {" + this.weight + "} (" + this.expression + ")"
                    }
                });
                var b = a.AbstractConstraint.prototype.toString,
                    c = function(b, c, d) {
                        a.AbstractConstraint.call(this, c || a.Strength.strong, d), this.variable = b, this.expression = new a.Expression(b, -1, b.value)
                    };
                a.EditConstraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function() {
                        c.apply(this, arguments)
                    },
                    isEdit: !0,
                    toString: function() {
                        return "edit:" + b.call(this)
                    }
                }), a.StayConstraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function() {
                        c.apply(this, arguments)
                    },
                    isStay: !0,
                    toString: function() {
                        return "stay:" + b.call(this)
                    }
                });
                var d = a.Constraint = a.inherit({
                    "extends": a.AbstractConstraint,
                    initialize: function(b, c, d) {
                        a.AbstractConstraint.call(this, c, d), this.expression = b
                    }
                });
                a.Inequality = a.inherit({
                    "extends": a.Constraint,
                    _cloneOrNewCle: function(b) {
                        return b.clone ? b.clone() : new a.Expression(b)
                    },
                    initialize: function(b, c, e, f, g) {
                        var h = b instanceof a.Expression,
                            i = e instanceof a.Expression,
                            j = b instanceof a.AbstractVariable,
                            k = e instanceof a.AbstractVariable,
                            l = "number" == typeof b,
                            m = "number" == typeof e;
                        if ((h || l) && k) {
                            var n = b,
                                o = c,
                                p = e,
                                q = f,
                                r = g;
                            if (d.call(this, this._cloneOrNewCle(n), q, r), o == a.LEQ) this.expression.multiplyMe(-1), this.expression.addVariable(p);
                            else {
                                if (o != a.GEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                this.expression.addVariable(p, -1)
                            }
                        } else if (j && (i || m)) {
                            var n = e,
                                o = c,
                                p = b,
                                q = f,
                                r = g;
                            if (d.call(this, this._cloneOrNewCle(n), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addVariable(p);
                            else {
                                if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                this.expression.addVariable(p, -1)
                            }
                        } else {
                            if (h && m) {
                                var s = b,
                                    o = c,
                                    t = e,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(s), q, r), o == a.LEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(t));
                                else {
                                    if (o != a.GEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(t), -1)
                                }
                                return this
                            }
                            if (l && i) {
                                var s = e,
                                    o = c,
                                    t = b,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(s), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(t));
                                else {
                                    if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(t), -1)
                                }
                                return this
                            }
                            if (h && i) {
                                var s = b,
                                    o = c,
                                    t = e,
                                    q = f,
                                    r = g;
                                if (d.call(this, this._cloneOrNewCle(t), q, r), o == a.GEQ) this.expression.multiplyMe(-1), this.expression.addExpression(this._cloneOrNewCle(s));
                                else {
                                    if (o != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    this.expression.addExpression(this._cloneOrNewCle(s), -1)
                                }
                            } else {
                                if (h) return d.call(this, b, c, e);
                                if (c == a.GEQ) d.call(this, new a.Expression(e), f, g), this.expression.multiplyMe(-1), this.expression.addVariable(b);
                                else {
                                    if (c != a.LEQ) throw new a.InternalError("Invalid operator in c.Inequality constructor");
                                    d.call(this, new a.Expression(e), f, g), this.expression.addVariable(b, -1)
                                }
                            }
                        }
                    },
                    isInequality: !0,
                    toString: function() {
                        return d.prototype.toString.call(this) + " >= 0) id: " + this.hashCode
                    }
                }), a.Equation = a.inherit({
                    "extends": a.Constraint,
                    initialize: function(b, c, e, f) {
                        if (b instanceof a.Expression && !c || c instanceof a.Strength) d.call(this, b, c, e);
                        else if (b instanceof a.AbstractVariable && c instanceof a.Expression) {
                            var g = b,
                                h = c,
                                i = e,
                                j = f;
                            d.call(this, h.clone(), i, j), this.expression.addVariable(g, -1)
                        } else if (b instanceof a.AbstractVariable && "number" == typeof c) {
                            var g = b,
                                k = c,
                                i = e,
                                j = f;
                            d.call(this, new a.Expression(k), i, j), this.expression.addVariable(g, -1)
                        } else if (b instanceof a.Expression && c instanceof a.AbstractVariable) {
                            var h = b,
                                g = c,
                                i = e,
                                j = f;
                            d.call(this, h.clone(), i, j), this.expression.addVariable(g, -1)
                        } else {
                            if (!(b instanceof a.Expression || b instanceof a.AbstractVariable || "number" == typeof b) || !(c instanceof a.Expression || c instanceof a.AbstractVariable || "number" == typeof c)) throw "Bad initializer to c.Equation";
                            b = b instanceof a.Expression ? b.clone() : new a.Expression(b), c = c instanceof a.Expression ? c.clone() : new a.Expression(c), d.call(this, b, e, f), this.expression.addExpression(c, -1)
                        }
                        a.assert(this.strength instanceof a.Strength, "_strength not set")
                    },
                    toString: function() {
                        return d.prototype.toString.call(this) + " = 0)"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.EditInfo = a.inherit({
                    initialize: function(a, b, c, d, e) {
                        this.constraint = a, this.editPlus = b, this.editMinus = c, this.prevEditConstant = d, this.index = e
                    },
                    toString: function() {
                        return "<cn=" + this.constraint + ", ep=" + this.editPlus + ", em=" + this.editMinus + ", pec=" + this.prevEditConstant + ", index=" + this.index + ">"
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Tableau = a.inherit({
                    initialize: function() {
                        this.columns = new a.HashTable, this.rows = new a.HashTable, this._infeasibleRows = new a.HashSet, this._externalRows = new a.HashTable
                    },
                    noteRemovedVariable: function(a, b) {
                        var c = this.columns.get(a);
                        b && c && c.delete(b)
                    },
                    noteAddedVariable: function(a, b) {
                        b && this.insertColVar(a, b)
                    },
                    getInternalInfo: function() {
                        return "Tableau Information:\nRows: " + this.rows.size + " (= " + (this.rows.size - 1) + " constraints)" + "\nColumns: " + this.columns.size + "\nInfeasible Rows: " + this._infeasibleRows.size + "\nExternal basic variables: " + this._externalRows.size
                    },
                    toString: function() {
                        var a = "Tableau:\n";
                        return this.rows.each(function(b, c) {
                            a += b + " <==> " + c + "\n"
                        }), a += "\nColumns:\n", this.columns.each(function(b, c) {
                            a += b + " <==> " + c
                        }), a += "\nInfeasible rows: ", a += this._infeasibleRows, a += "External basic variables: ", a += this._externalRows
                    },
                    insertColVar: function(b, c) {
                        var d = this.columns.get(b);
                        d || (d = new a.HashSet, this.columns.set(b, d)), d.add(c)
                    },
                    addRow: function(a, b) {
                        this.rows.set(a, b), b.terms.each(function(b) {
                            this.insertColVar(b, a)
                        }, this), a.isExternal && this._externalRows.set(a, b)
                    },
                    removeColumn: function(a) {
                        var b = this.columns.get(a);
                        b && (this.columns.delete(a), b.each(function(b) {
                            var c = this.rows.get(b);
                            c.terms.delete(a)
                        }, this)), a.isExternal && this._externalRows.delete(a)
                    },
                    removeRow: function(b) {
                        var c = this.rows.get(b);
                        return a.assert(null != c), c.terms.each(function(a) {
                            var d = this.columns.get(a);
                            null != d && d.delete(b)
                        }, this), this._infeasibleRows.delete(b), b.isExternal && this._externalRows.delete(b), this.rows.delete(b), c
                    },
                    substituteOut: function(a, b) {
                        var c = this.columns.get(a);
                        c.each(function(c) {
                            var d = this.rows.get(c);
                            d.substituteOut(a, b, c, this), c.isExternal && this._updatedExternals.add(c), c.isRestricted && d.constant < 0 && this._infeasibleRows.add(c)
                        }, this), a.isExternal && this._externalRows.set(a, b), this.columns.delete(a)
                    },
                    columnsHasKey: function(a) {
                        return !!this.columns.get(a)
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                var b = a.Tableau,
                    c = b.prototype,
                    d = 1e-8,
                    e = a.Strength.weak,
                    f = {
                        eplus: null,
                        eminus: null,
                        prevEConstant: null
                    };
                a.SimplexSolver = a.inherit({
                    "extends": a.Tableau,
                    initialize: function() {
                        a.Tableau.call(this), this._stayMinusErrorVars = [], this._stayPlusErrorVars = [], this._errorVars = new a.HashTable, this._markerVars = new a.HashTable, this._objective = new a.ObjectiveVariable({
                            name: "Z"
                        }), this._editVarMap = new a.HashTable, this._editVarList = [], this._slackCounter = 0, this._artificialCounter = 0, this._dummyCounter = 0, this.autoSolve = !0, this._needsSolving = !1, this._optimizeCount = 0, this.rows.set(this._objective, a.Expression.empty(this)), this._editVariableStack = [0], this._updatedExternals = new a.HashSet
                    },
                    _noteUpdatedExternal: function(a) {
                        this._updatedExternals.add(a)
                    },
                    add: function() {
                        for (var a = 0; a < arguments.length; a++) this.addConstraint(arguments[a]);
                        return this
                    },
                    addEditVar: function(b, c, d) {
                        var e = new a.EditConstraint(b, c || a.Strength.strong, d);
                        return this.addEditConstraint(e), this
                    },
                    addEditConstraint: function(a) {
                        var b = f;
                        return this.addConstraint(a), this._addEditConstraint(a, b.eplus, b.eminus, b.prevEConstant), this
                    },
                    _addEditConstraint: function(b, c, d, e) {
                        var f = this._editVarMap.size,
                            g = new a.EditInfo(b, c, d, e, f);
                        this._editVarMap.set(b.variable, g), this._editVarList[f] = {
                            v: b.variable,
                            info: g
                        }
                    },
                    addConstraint: function(b) {
                        if (b instanceof a.Constraint) {
                            var c = this;
                            b.expression.externalVariables.each(function(a) {
                                c._noteUpdatedExternal(a)
                            })
                        }
                        var d = this.newExpression(b);
                        return d.solver = this, this.tryAddingDirectly(d) || this.addWithArtificialVariable(d), this._needsSolving = !0, this.autoSolve && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    addConstraintNoException: function(a) {
                        try {
                            return this.addConstraint(a), !0
                        } catch (b) {
                            return console.error(b), !1
                        }
                    },
                    beginEdit: function() {
                        return a.assert(this._editVarMap.size > 0, "_editVarMap.size > 0"), this._infeasibleRows.clear(), this._resetStayConstants(), this._editVariableStack[this._editVariableStack.length] = this._editVarMap.size, this
                    },
                    endEdit: function() {
                        return a.assert(this._editVarMap.size > 0, "_editVarMap.size > 0"), this.resolve(), this._editVariableStack.pop(), this.removeEditVarsTo(this._editVariableStack[this._editVariableStack.length - 1]), this
                    },
                    removeAllEditVars: function() {
                        return this.removeEditVarsTo(0)
                    },
                    removeEditVarsTo: function(b) {
                        try {
                            for (var c = this._editVarList.length, d = b; c > d; d++) this._editVarList[d] && this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);
                            return this._editVarList.length = b, a.assert(this._editVarMap.size == b, "_editVarMap.size == n"), this
                        } catch (e) {
                            throw new a.InternalError("Constraint not found in removeEditVarsTo")
                        }
                    },
                    addPointStays: function(a) {
                        return a.forEach(function(a, b) {
                            this.addStay(a.x, e, Math.pow(2, b)), this.addStay(a.y, e, Math.pow(2, b))
                        }, this), this
                    },
                    addStay: function(b, c, d) {
                        var f = new a.StayConstraint(b, c || e, d || 1);
                        return this.addConstraint(f)
                    },
                    setConstant: function(a, b) {
                        this._setConstant(a, b), this.resolve()
                    },
                    removeConstraint: function(b) {
                        this._needsSolving = !0, this._resetStayConstants();
                        var c = this.rows.get(this._objective),
                            d = this._errorVars.get(b);
                        null != d && d.each(function(a) {
                            var d = this.rows.get(a);
                            null == d ? c.addVariable(a, -b.weight * b.strength.symbolicWeight.value, this._objective, this) : c.addExpression(d, -b.weight * b.strength.symbolicWeight.value, this._objective, this)
                        }, this);
                        var e = this._markerVars.get(b);
                        if (this._markerVars.delete(b), null == e) throw new a.InternalError("Constraint not found in removeConstraintInternal");
                        if (null == this.rows.get(e)) {
                            var f = this.columns.get(e),
                                g = null,
                                h = 0;
                            f.each(function(b) {
                                if (b.isRestricted) {
                                    var c = this.rows.get(b),
                                        d = c.coefficientFor(e);
                                    if (0 > d) {
                                        var f = -c.constant / d;
                                        (null == g || h > f || a.approx(f, h) && b.hashCode < g.hashCode) && (h = f, g = b)
                                    }
                                }
                            }, this), null == g && f.each(function(a) {
                                if (a.isRestricted) {
                                    var b = this.rows.get(a),
                                        c = b.coefficientFor(e),
                                        d = b.constant / c;
                                    (null == g || h > d) && (h = d, g = a)
                                }
                            }, this), null == g && (0 == f.size ? this.removeColumn(e) : f.escapingEach(function(a) {
                                return a != this._objective ? (g = a, {
                                    brk: !0
                                }) : void 0
                            }, this)), null != g && this.pivot(e, g)
                        }
                        if (null != this.rows.get(e) && this.removeRow(e), null != d && d.each(function(a) {
                                a != e && this.removeColumn(a)
                            }, this), b.isStay) {
                            if (null != d)
                                for (var j = 0; j < this._stayPlusErrorVars.length; j++) d.delete(this._stayPlusErrorVars[j]), d.delete(this._stayMinusErrorVars[j])
                        } else if (b.isEdit) {
                            var k = this._editVarMap.get(b.variable);
                            this.removeColumn(k.editMinus), this._editVarMap.delete(b.variable)
                        }
                        return null != d && this._errorVars.delete(d), this.autoSolve && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    reset: function() {
                        throw new a.InternalError("reset not implemented")
                    },
                    resolveArray: function(a) {
                        var b = a.length;
                        this._editVarMap.each(function(c, d) {
                            var e = d.index;
                            b > e && this.suggestValue(c, a[e])
                        }, this), this.resolve()
                    },
                    resolvePair: function(a, b) {
                        this.suggestValue(this._editVarList[0].v, a), this.suggestValue(this._editVarList[1].v, b), this.resolve()
                    },
                    resolve: function() {
                        this.dualOptimize(), this._setExternalVariables(), this._infeasibleRows.clear(), this._resetStayConstants()
                    },
                    suggestValue: function(b, c) {
                        var d = this._editVarMap.get(b);
                        if (!d) throw new a.Error("suggestValue for variable " + b + ", but var is not an edit variable");
                        var e = c - d.prevEditConstant;
                        return d.prevEditConstant = c, this.deltaEditConstant(e, d.editPlus, d.editMinus), this
                    },
                    solve: function() {
                        return this._needsSolving && (this.optimize(this._objective), this._setExternalVariables()), this
                    },
                    setEditedValue: function(b, c) {
                        if (!this.columnsHasKey(b) && null == this.rows.get(b)) return b.value = c, this;
                        if (!a.approx(c, b.value)) {
                            this.addEditVar(b), this.beginEdit();
                            try {
                                this.suggestValue(b, c)
                            } catch (d) {
                                throw new a.InternalError("Error in setEditedValue")
                            }
                            this.endEdit()
                        }
                        return this
                    },
                    addVar: function(b) {
                        if (!this.columnsHasKey(b) && null == this.rows.get(b)) try {
                            this.addStay(b)
                        } catch (c) {
                            throw new a.InternalError("Error in addVar -- required failure is impossible")
                        }
                        return this
                    },
                    getInternalInfo: function() {
                        var a = c.getInternalInfo.call(this);
                        return a += "\nSolver info:\n", a += "Stay Error Variables: ", a += this._stayPlusErrorVars.length + this._stayMinusErrorVars.length, a += " (" + this._stayPlusErrorVars.length + " +, ", a += this._stayMinusErrorVars.length + " -)\n", a += "Edit Variables: " + this._editVarMap.size, a += "\n"
                    },
                    getDebugInfo: function() {
                        return this.toString() + this.getInternalInfo() + "\n"
                    },
                    toString: function() {
                        var a = c.getInternalInfo.call(this);
                        return a += "\n_stayPlusErrorVars: ", a += "[" + this._stayPlusErrorVars + "]", a += "\n_stayMinusErrorVars: ", a += "[" + this._stayMinusErrorVars + "]", a += "\n", a += "_editVarMap:\n" + this._editVarMap, a += "\n"
                    },
                    addWithArtificialVariable: function(b) {
                        var c = new a.SlackVariable({
                                value: ++this._artificialCounter,
                                prefix: "a"
                            }),
                            d = new a.ObjectiveVariable({
                                name: "az"
                            }),
                            e = b.clone();
                        this.addRow(d, e), this.addRow(c, b), this.optimize(d);
                        var f = this.rows.get(d);
                        if (!a.approx(f.constant, 0)) throw this.removeRow(d), this.removeColumn(c), new a.RequiredFailure;
                        var g = this.rows.get(c);
                        if (null != g) {
                            if (g.isConstant) return this.removeRow(c), this.removeRow(d), void 0;
                            var h = g.anyPivotableVariable();
                            this.pivot(h, c)
                        }
                        a.assert(null == this.rows.get(c), "rowExpression(av) == null"), this.removeColumn(c), this.removeRow(d)
                    },
                    tryAddingDirectly: function(a) {
                        var b = this.chooseSubject(a);
                        return null == b ? !1 : (a.newSubject(b), this.columnsHasKey(b) && this.substituteOut(b, a), this.addRow(b, a), !0)
                    },
                    chooseSubject: function(b) {
                        var c = null,
                            d = !1,
                            e = !1,
                            f = b.terms,
                            g = f.escapingEach(function(a, b) {
                                if (d) {
                                    if (!a.isRestricted && !this.columnsHasKey(a)) return {
                                        retval: a
                                    }
                                } else if (a.isRestricted) {
                                    if (!e && !a.isDummy && 0 > b) {
                                        var f = this.columns.get(a);
                                        (null == f || 1 == f.size && this.columnsHasKey(this._objective)) && (c = a, e = !0)
                                    }
                                } else c = a, d = !0
                            }, this);
                        if (g && void 0 !== g.retval) return g.retval;
                        if (null != c) return c;
                        var h = 0,
                            g = f.escapingEach(function(a, b) {
                                return a.isDummy ? (this.columnsHasKey(a) || (c = a, h = b), void 0) : {
                                    retval: null
                                }
                            }, this);
                        if (g && void 0 !== g.retval) return g.retval;
                        if (!a.approx(b.constant, 0)) throw new a.RequiredFailure;
                        return h > 0 && b.multiplyMe(-1), c
                    },
                    deltaEditConstant: function(a, b, c) {
                        var d = this.rows.get(b);
                        if (null != d) return d.constant += a, d.constant < 0 && this._infeasibleRows.add(b), void 0;
                        var e = this.rows.get(c);
                        if (null != e) return e.constant += -a, e.constant < 0 && this._infeasibleRows.add(c), void 0;
                        var f = this.columns.get(c);
                        f || console.log("columnVars is null -- tableau is:\n" + this), f.each(function(b) {
                            var d = this.rows.get(b),
                                e = d.coefficientFor(c);
                            d.constant += e * a, b.isExternal && this._noteUpdatedExternal(b), b.isRestricted && d.constant < 0 && this._infeasibleRows.add(b)
                        }, this)
                    },
                    dualOptimize: function() {
                        for (var b = this.rows.get(this._objective); this._infeasibleRows.size;) {
                            var c = this._infeasibleRows.first();
                            this._infeasibleRows.delete(c);
                            var d = null,
                                e = this.rows.get(c);
                            if (e && e.constant < 0) {
                                var g, f = Number.MAX_VALUE,
                                    h = e.terms;
                                if (h.each(function(c, e) {
                                        if (e > 0 && c.isPivotable) {
                                            var h = b.coefficientFor(c);
                                            g = h / e, (f > g || a.approx(g, f) && c.hashCode < d.hashCode) && (d = c, f = g)
                                        }
                                    }), f == Number.MAX_VALUE) throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");
                                this.pivot(d, c)
                            }
                        }
                    },
                    newExpression: function(b) {
                        var c = f;
                        c.eplus = null, c.eminus = null, c.prevEConstant = null;
                        var d = b.expression,
                            e = a.Expression.fromConstant(d.constant, this),
                            g = new a.SlackVariable,
                            h = new a.DummyVariable,
                            i = new a.SlackVariable,
                            j = new a.SlackVariable,
                            k = d.terms;
                        if (k.each(function(a, b) {
                                var c = this.rows.get(a);
                                c ? e.addExpression(c, b) : e.addVariable(a, b)
                            }, this), b.isInequality) {
                            if (++this._slackCounter, g = new a.SlackVariable({
                                    value: this._slackCounter,
                                    prefix: "s"
                                }), e.setVariable(g, -1), this._markerVars.set(b, g), !b.required) {
                                ++this._slackCounter, i = new a.SlackVariable({
                                    value: this._slackCounter,
                                    prefix: "em"
                                }), e.setVariable(i, 1);
                                var l = this.rows.get(this._objective);
                                l.setVariable(i, b.strength.symbolicWeight.value * b.weight), this.insertErrorVar(b, i), this.noteAddedVariable(i, this._objective)
                            }
                        } else if (b.required) ++this._dummyCounter, h = new a.DummyVariable({
                            value: this._dummyCounter,
                            prefix: "d"
                        }), c.eplus = h, c.eminus = h, c.prevEConstant = d.constant, e.setVariable(h, 1), this._markerVars.set(b, h);
                        else {
                            ++this._slackCounter, j = new a.SlackVariable({
                                value: this._slackCounter,
                                prefix: "ep"
                            }), i = new a.SlackVariable({
                                value: this._slackCounter,
                                prefix: "em"
                            }), e.setVariable(j, -1), e.setVariable(i, 1), this._markerVars.set(b, j);
                            var l = this.rows.get(this._objective),
                                m = b.strength.symbolicWeight.value * b.weight;
                            l.setVariable(j, m), this.noteAddedVariable(j, this._objective), l.setVariable(i, m), this.noteAddedVariable(i, this._objective), this.insertErrorVar(b, i), this.insertErrorVar(b, j), b.isStay ? (this._stayPlusErrorVars[this._stayPlusErrorVars.length] = j, this._stayMinusErrorVars[this._stayMinusErrorVars.length] = i) : b.isEdit && (c.eplus = j, c.eminus = i, c.prevEConstant = d.constant)
                        }
                        return e.constant < 0 && e.multiplyMe(-1), e
                    },
                    optimize: function(b) {
                        this._optimizeCount++;
                        var c = this.rows.get(b);
                        a.assert(null != c, "zRow != null");
                        for (var g, h, e = null, f = null;;) {
                            if (g = 0, h = c.terms, h.escapingEach(function(a, b) {
                                    return a.isPivotable && g > b ? (g = b, e = a, {
                                        brk: 1
                                    }) : void 0
                                }, this), g >= -d) return;
                            var i = Number.MAX_VALUE,
                                j = this.columns.get(e),
                                k = 0;
                            if (j.each(function(b) {
                                    if (b.isPivotable) {
                                        var c = this.rows.get(b),
                                            d = c.coefficientFor(e);
                                        0 > d && (k = -c.constant / d, (i > k || a.approx(k, i) && b.hashCode < f.hashCode) && (i = k, f = b))
                                    }
                                }, this), i == Number.MAX_VALUE) throw new a.InternalError("Objective function is unbounded in optimize");
                            this.pivot(e, f)
                        }
                    },
                    pivot: function(a, b) {
                        var c = !1;
                        c && console.time(" SimplexSolver::pivot"), null == a && console.warn("pivot: entryVar == null"), null == b && console.warn("pivot: exitVar == null"), c && console.time("  removeRow");
                        var d = this.removeRow(b);
                        c && console.timeEnd("  removeRow"), c && console.time("  changeSubject"), d.changeSubject(b, a), c && console.timeEnd("  changeSubject"), c && console.time("  substituteOut"), this.substituteOut(a, d), c && console.timeEnd("  substituteOut"), c && console.time("  addRow"), this.addRow(a, d), c && console.timeEnd("  addRow"), c && console.timeEnd(" SimplexSolver::pivot")
                    },
                    _resetStayConstants: function() {
                        for (var a = this._stayPlusErrorVars, b = a.length, c = 0; b > c; c++) {
                            var d = this.rows.get(a[c]);
                            null === d && (d = this.rows.get(this._stayMinusErrorVars[c])), null != d && (d.constant = 0)
                        }
                    },
                    _setExternalVariables: function() {
                        var a = [];
                        this._updatedExternals.each(function(b) {
                            var c = b.value,
                                d = this._externalRows.get(b);
                            return d ? (b.value = d.constant, c !== b.value && a.push({
                                type: "update",
                                name: b.name,
                                variable: b,
                                oldValue: c
                            }), void 0) : (b.value = 0, void 0)
                        }, this), this._updatedExternals.clear(), this._needsSolving = !1, this._informCallbacks(a), a.length && this.onsolved(a)
                    },
                    onsolved: function() {},
                    _informCallbacks: function(a) {
                        this._callbacks && this._callbacks.forEach(function(b) {
                            b(a)
                        })
                    },
                    _addCallback: function(a) {
                        var b = this._callbacks || (this._callbacks = []);
                        b[b.length] = a
                    },
                    insertErrorVar: function(b, c) {
                        var d = this._errorVars.get(b);
                        d || (d = new a.HashSet, this._errorVars.set(b, d)), d.add(c)
                    }
                })
            }(this.c || module.parent.exports || {}),
            function(a) {
                "use strict";
                a.Timer = a.inherit({
                    initialize: function() {
                        this.isRunning = !1, this._elapsedMs = 0
                    },
                    start: function() {
                        return this.isRunning = !0, this._startReading = new Date, this
                    },
                    stop: function() {
                        return this.isRunning = !1, this._elapsedMs += new Date - this._startReading, this
                    },
                    reset: function() {
                        return this.isRunning = !1, this._elapsedMs = 0, this
                    },
                    elapsedTime: function() {
                        return this.isRunning ? (this._elapsedMs + (new Date - this._startReading)) / 1e3 : this._elapsedMs / 1e3
                    }
                })
            }(this.c || module.parent.exports || {}), this.c.parser = function() {
                    function a(a) {
                        return '"' + a.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"'
                    }
                    var b = {
                        parse: function(b, c) {
                            function k(a) {
                                g > e || (e > g && (g = e, h = []), h.push(a))
                            }

                            function l() {
                                var a, b, c, d, f;
                                if (d = e, f = e, a = A(), null !== a) {
                                    for (b = [], c = m(); null !== c;) b.push(c), c = m();
                                    null !== b ? (c = A(), null !== c ? a = [a, b, c] : (a = null, e = f)) : (a = null, e = f)
                                } else a = null, e = f;
                                return null !== a && (a = function(a, b) {
                                    return b
                                }(d, a[1])), null === a && (e = d), a
                            }

                            function m() {
                                var a, b, c, d;
                                return c = e, d = e, a = Q(), null !== a ? (b = t(), null !== b ? a = [a, b] : (a = null, e = d)) : (a = null, e = d), null !== a && (a = function(a, b) {
                                    return b
                                }(c, a[0])), null === a && (e = c), a
                            }

                            function n() {
                                var a;
                                return b.length > e ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("any character")), a
                            }

                            function o() {
                                var a;
                                return /^[a-zA-Z]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[a-zA-Z]")), null === a && (36 === b.charCodeAt(e) ? (a = "$", e++) : (a = null, 0 === f && k('"$"')), null === a && (95 === b.charCodeAt(e) ? (a = "_", e++) : (a = null, 0 === f && k('"_"')))), a
                            }

                            function p() {
                                var a;
                                return a = o(), null === a && (/^[0-9]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[0-9]"))), a
                            }

                            function q() {
                                var a;
                                return f++, /^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\t\\x0B\\f \\xA0\\uFEFF]")), f--, 0 === f && null === a && k("whitespace"), a
                            }

                            function r() {
                                var a;
                                return /^[\n\r\u2028\u2029]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\n\\r\\u2028\\u2029]")), a
                            }

                            function s() {
                                var a;
                                return f++, 10 === b.charCodeAt(e) ? (a = "\n", e++) : (a = null, 0 === f && k('"\\n"')), null === a && ("\r\n" === b.substr(e, 2) ? (a = "\r\n", e += 2) : (a = null, 0 === f && k('"\\r\\n"')), null === a && (13 === b.charCodeAt(e) ? (a = "\r", e++) : (a = null, 0 === f && k('"\\r"')), null === a && (8232 === b.charCodeAt(e) ? (a = "\u2028", e++) : (a = null, 0 === f && k('"\\u2028"')), null === a && (8233 === b.charCodeAt(e) ? (a = "\u2029", e++) : (a = null, 0 === f && k('"\\u2029"')))))), f--, 0 === f && null === a && k("end of line"), a
                            }

                            function t() {
                                var a, c, d;
                                return d = e, a = A(), null !== a ? (59 === b.charCodeAt(e) ? (c = ";", e++) : (c = null, 0 === f && k('";"')), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d), null === a && (d = e, a = z(), null !== a ? (c = s(), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d), null === a && (d = e, a = A(), null !== a ? (c = u(), null !== c ? a = [a, c] : (a = null, e = d)) : (a = null, e = d))), a
                            }

                            function u() {
                                var a, c;
                                return c = e, f++, b.length > e ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("any character")), f--, null === a ? a = "" : (a = null, e = c), a
                            }

                            function v() {
                                var a;
                                return f++, a = w(), null === a && (a = y()), f--, 0 === f && null === a && k("comment"), a
                            }

                            function w() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "/*" === b.substr(e, 2) ? (a = "/*", e += 2) : (a = null, 0 === f && k('"/*"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? ("*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function x() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "/*" === b.substr(e, 2) ? (a = "/*", e += 2) : (a = null, 0 === f && k('"/*"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null === d && (d = r()), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, "*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null === d && (d = r()), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? ("*/" === b.substr(e, 2) ? (d = "*/", e += 2) : (d = null, 0 === f && k('"*/"')), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function y() {
                                var a, c, d, g, h, i, j;
                                if (h = e, "//" === b.substr(e, 2) ? (a = "//", e += 2) : (a = null, 0 === f && k('"//"')), null !== a) {
                                    for (c = [], i = e, j = e, f++, d = r(), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i); null !== d;) c.push(d), i = e, j = e, f++, d = r(), f--, null === d ? d = "" : (d = null, e = j), null !== d ? (g = n(), null !== g ? d = [d, g] : (d = null, e = i)) : (d = null, e = i);
                                    null !== c ? (d = r(), null === d && (d = u()), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)
                                } else a = null, e = h;
                                return a
                            }

                            function z() {
                                var a, b;
                                for (a = [], b = q(), null === b && (b = x(), null === b && (b = y())); null !== b;) a.push(b), b = q(), null === b && (b = x(), null === b && (b = y()));
                                return a
                            }

                            function A() {
                                var a, b;
                                for (a = [], b = q(), null === b && (b = s(), null === b && (b = v())); null !== b;) a.push(b), b = q(), null === b && (b = s(), null === b && (b = v()));
                                return a
                            }

                            function B() {
                                var a, b;
                                return b = e, a = D(), null === a && (a = C()), null !== a && (a = function(a, b) {
                                    return {
                                        type: "NumericLiteral",
                                        value: b
                                    }
                                }(b, a)), null === a && (e = b), a
                            }

                            function C() {
                                var a, c, d;
                                if (d = e, /^[0-9]/.test(b.charAt(e)) ? (c = b.charAt(e), e++) : (c = null, 0 === f && k("[0-9]")), null !== c)
                                    for (a = []; null !== c;) a.push(c), /^[0-9]/.test(b.charAt(e)) ? (c = b.charAt(e), e++) : (c = null, 0 === f && k("[0-9]"));
                                else a = null;
                                return null !== a && (a = function(a, b) {
                                    return parseInt(b.join(""))
                                }(d, a)), null === a && (e = d), a
                            }

                            function D() {
                                var a, c, d, g, h;
                                return g = e, h = e, a = C(), null !== a ? (46 === b.charCodeAt(e) ? (c = ".", e++) : (c = null, 0 === f && k('"."')), null !== c ? (d = C(), null !== d ? a = [a, c, d] : (a = null, e = h)) : (a = null, e = h)) : (a = null, e = h), null !== a && (a = function(a, b) {
                                    return parseFloat(b.join(""))
                                }(g, a)), null === a && (e = g), a
                            }

                            function E() {
                                var a, c, d, g;
                                if (g = e, /^[\-+]/.test(b.charAt(e)) ? (a = b.charAt(e), e++) : (a = null, 0 === f && k("[\\-+]")), a = null !== a ? a : "", null !== a) {
                                    if (/^[0-9]/.test(b.charAt(e)) ? (d = b.charAt(e), e++) : (d = null, 0 === f && k("[0-9]")), null !== d)
                                        for (c = []; null !== d;) c.push(d), /^[0-9]/.test(b.charAt(e)) ? (d = b.charAt(e), e++) : (d = null, 0 === f && k("[0-9]"));
                                    else c = null;
                                    null !== c ? a = [a, c] : (a = null, e = g)
                                } else a = null, e = g;
                                return a
                            }

                            function F() {
                                var a, b;
                                return f++, b = e, a = G(), null !== a && (a = function(a, b) {
                                    return b
                                }(b, a)), null === a && (e = b), f--, 0 === f && null === a && k("identifier"), a
                            }

                            function G() {
                                var a, b, c, d, g;
                                if (f++, d = e, g = e, a = o(), null !== a) {
                                    for (b = [], c = p(); null !== c;) b.push(c), c = p();
                                    null !== b ? a = [a, b] : (a = null, e = g)
                                } else a = null, e = g;
                                return null !== a && (a = function(a, b, c) {
                                    return b + c.join("")
                                }(d, a[0], a[1])), null === a && (e = d), f--, 0 === f && null === a && k("identifier"), a
                            }

                            function H() {
                                var a, c, d, g, h, i, j;
                                return i = e, a = F(), null !== a && (a = function(a, b) {
                                    return {
                                        type: "Variable",
                                        name: b
                                    }
                                }(i, a)), null === a && (e = i), null === a && (a = B(), null === a && (i = e, j = e, 40 === b.charCodeAt(e) ? (a = "(", e++) : (a = null, 0 === f && k('"("')), null !== a ? (c = A(), null !== c ? (d = Q(), null !== d ? (g = A(), null !== g ? (41 === b.charCodeAt(e) ? (h = ")", e++) : (h = null, 0 === f && k('")"')), null !== h ? a = [a, c, d, g, h] : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j)) : (a = null, e = j), null !== a && (a = function(a, b) {
                                    return b
                                }(i, a[2])), null === a && (e = i))), a
                            }

                            function I() {
                                var a, b, c, d, f;
                                return a = H(), null === a && (d = e, f = e, a = J(), null !== a ? (b = A(), null !== b ? (c = I(), null !== c ? a = [a, b, c] : (a = null, e = f)) : (a = null, e = f)) : (a = null, e = f), null !== a && (a = function(a, b, c) {
                                    return {
                                        type: "UnaryExpression",
                                        operator: b,
                                        expression: c
                                    }
                                }(d, a[0], a[2])), null === a && (e = d)), a
                            }

                            function J() {
                                var a;
                                return 43 === b.charCodeAt(e) ? (a = "+", e++) : (a = null, 0 === f && k('"+"')), null === a && (45 === b.charCodeAt(e) ? (a = "-", e++) : (a = null, 0 === f && k('"-"')), null === a && (33 === b.charCodeAt(e) ? (a = "!", e++) : (a = null, 0 === f && k('"!"')))), a
                            }

                            function K() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = I(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = L(), null !== d ? (f = A(), null !== f ? (g = I(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = L(), null !== d ? (f = A(), null !== f ? (g = I(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "MultiplicativeExpression",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function L() {
                                var a;
                                return 42 === b.charCodeAt(e) ? (a = "*", e++) : (a = null, 0 === f && k('"*"')), null === a && (47 === b.charCodeAt(e) ? (a = "/", e++) : (a = null, 0 === f && k('"/"'))), a
                            }

                            function M() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = K(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = N(), null !== d ? (f = A(), null !== f ? (g = K(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = N(), null !== d ? (f = A(), null !== f ? (g = K(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "AdditiveExpression",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function N() {
                                var a;
                                return 43 === b.charCodeAt(e) ? (a = "+", e++) : (a = null, 0 === f && k('"+"')), null === a && (45 === b.charCodeAt(e) ? (a = "-", e++) : (a = null, 0 === f && k('"-"'))), a
                            }

                            function O() {
                                var a, b, c, d, f, g, h, i, j;
                                if (h = e, i = e, a = M(), null !== a) {
                                    for (b = [], j = e, c = A(), null !== c ? (d = P(), null !== d ? (f = A(), null !== f ? (g = M(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j); null !== c;) b.push(c), j = e, c = A(), null !== c ? (d = P(), null !== d ? (f = A(), null !== f ? (g = M(), null !== g ? c = [c, d, f, g] : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j)) : (c = null, e = j);
                                    null !== b ? a = [a, b] : (a = null, e = i)
                                } else a = null, e = i;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "Inequality",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(h, a[0], a[1])), null === a && (e = h), a
                            }

                            function P() {
                                var a;
                                return "<=" === b.substr(e, 2) ? (a = "<=", e += 2) : (a = null, 0 === f && k('"<="')), null === a && (">=" === b.substr(e, 2) ? (a = ">=", e += 2) : (a = null, 0 === f && k('">="')), null === a && (60 === b.charCodeAt(e) ? (a = "<", e++) : (a = null, 0 === f && k('"<"')), null === a && (62 === b.charCodeAt(e) ? (a = ">", e++) : (a = null, 0 === f && k('">"'))))), a
                            }

                            function Q() {
                                var a, c, d, g, h, i, j, l, m;
                                if (j = e, l = e, a = O(), null !== a) {
                                    for (c = [], m = e, d = A(), null !== d ? ("==" === b.substr(e, 2) ? (g = "==", e += 2) : (g = null, 0 === f && k('"=="')), null !== g ? (h = A(), null !== h ? (i = O(), null !== i ? d = [d, g, h, i] : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m); null !== d;) c.push(d), m = e, d = A(), null !== d ? ("==" === b.substr(e, 2) ? (g = "==", e += 2) : (g = null, 0 === f && k('"=="')), null !== g ? (h = A(), null !== h ? (i = O(), null !== i ? d = [d, g, h, i] : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m)) : (d = null, e = m);
                                    null !== c ? a = [a, c] : (a = null, e = l)
                                } else a = null, e = l;
                                return null !== a && (a = function(a, b, c) {
                                    for (var d = b, e = 0; e < c.length; e++) d = {
                                        type: "Equality",
                                        operator: c[e][1],
                                        left: d,
                                        right: c[e][3]
                                    };
                                    return d
                                }(j, a[0], a[1])), null === a && (e = j), a
                            }

                            function R(a) {
                                a.sort();
                                for (var b = null, c = [], d = 0; d < a.length; d++) a[d] !== b && (c.push(a[d]), b = a[d]);
                                return c
                            }

                            function S() {
                                for (var a = 1, c = 1, d = !1, f = 0; f < Math.max(e, g); f++) {
                                    var h = b.charAt(f);
                                    "\n" === h ? (d || a++, c = 1, d = !1) : "\r" === h || "\u2028" === h || "\u2029" === h ? (a++, c = 1, d = !0) : (c++, d = !1)
                                }
                                return {
                                    line: a,
                                    column: c
                                }
                            }
                            var d = {
                                start: l,
                                Statement: m,
                                SourceCharacter: n,
                                IdentifierStart: o,
                                IdentifierPart: p,
                                WhiteSpace: q,
                                LineTerminator: r,
                                LineTerminatorSequence: s,
                                EOS: t,
                                EOF: u,
                                Comment: v,
                                MultiLineComment: w,
                                MultiLineCommentNoLineTerminator: x,
                                SingleLineComment: y,
                                _: z,
                                __: A,
                                Literal: B,
                                Integer: C,
                                Real: D,
                                SignedInteger: E,
                                Identifier: F,
                                IdentifierName: G,
                                PrimaryExpression: H,
                                UnaryExpression: I,
                                UnaryOperator: J,
                                MultiplicativeExpression: K,
                                MultiplicativeOperator: L,
                                AdditiveExpression: M,
                                AdditiveOperator: N,
                                InequalityExpression: O,
                                InequalityOperator: P,
                                LinearExpression: Q
                            };
                            if (void 0 !== c) {
                                if (void 0 === d[c]) throw new Error("Invalid rule name: " + a(c) + ".")
                            } else c = "start";
                            var e = 0,
                                f = 0,
                                g = 0,
                                h = [],
                                T = d[c]();
                            if (null === T || e !== b.length) {
                                var U = Math.max(e, g),
                                    V = U < b.length ? b.charAt(U) : null,
                                    W = S();
                                throw new this.SyntaxError(R(h), V, U, W.line, W.column)
                            }
                            return T
                        },
                        toSource: function() {
                            return this._source
                        }
                    };
                    return b.SyntaxError = function(b, c, d, e, f) {
                        function g(b, c) {
                            var d, e;
                            switch (b.length) {
                                case 0:
                                    d = "end of input";
                                    break;
                                case 1:
                                    d = b[0];
                                    break;
                                default:
                                    d = b.slice(0, b.length - 1).join(", ") + " or " + b[b.length - 1]
                            }
                            return e = c ? a(c) : "end of input", "Expected " + d + " but " + e + " found."
                        }
                        this.name = "SyntaxError", this.expected = b, this.found = c, this.message = g(b, c), this.offset = d, this.line = e, this.column = f
                    }, b.SyntaxError.prototype = Error.prototype, b
                }(),
                function(a) {
                    "use strict";
                    var b = new a.SimplexSolver,
                        c = {},
                        d = {},
                        e = a.Strength.weak;
                    a.Strength.medium, a.Strength.strong, a.Strength.required;
                    var i = function(f) {
                            if (d[f]) return d[f];
                            switch (f.type) {
                                case "Inequality":
                                    var g = "<=" == f.operator ? a.LEQ : a.GEQ,
                                        h = new a.Inequality(i(f.left), g, i(f.right), e);
                                    return b.addConstraint(h), h;
                                case "Equality":
                                    var h = new a.Equation(i(f.left), i(f.right), e);
                                    return b.addConstraint(h), h;
                                case "MultiplicativeExpression":
                                    var h = a.times(i(f.left), i(f.right));
                                    return b.addConstraint(h), h;
                                case "AdditiveExpression":
                                    return "+" == f.operator ? a.plus(i(f.left), i(f.right)) : a.minus(i(f.left), i(f.right));
                                case "NumericLiteral":
                                    return new a.Expression(f.value);
                                case "Variable":
                                    return c[f.name] || (c[f.name] = new a.Variable({
                                        name: f.name
                                    })), c[f.name];
                                case "UnaryExpression":
                                    console.log("UnaryExpression...WTF?")
                            }
                        },
                        j = function(a) {
                            return a.map(i)
                        };
                    a._api = function() {
                        var c = Array.prototype.slice.call(arguments);
                        if (1 == c.length) {
                            if ("string" == typeof c[0]) {
                                var d = a.parser.parse(c[0]);
                                return j(d)
                            }
                            "function" == typeof c[0] && b._addCallback(c[0])
                        }
                    }
                }(this.c || module.parent.exports || {});
        }).call(
            (typeof module != "undefined") ?
            (module.compiled = true && module) : this
        );

    }, {}],
    2: [function(require, module, exports) {
        function Expression() {
            this._left = null;
            this._right = null;
        }
        module.exports = Expression;

        Expression.prototype.addExpressions = function(left, right) {
            this._left = left;
            this._right = right;
        };

        // Overridable method
        Expression.prototype.construct = function() {};
    }, {}],
    3: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var primitives = require('./primitives.js');
        var operators = require('./operators.js');
        var parseExpression = require('./parser.js');

        var Numeral = primitives.Numeral;
        var Constant = primitives.Constant;
        var Variable = primitives.Variable;

        var Equality = operators.Equality;
        var Multiplication = operators.Multiplication;

        function System() {
            if ((this instanceof System) === false) {
                return new System();
            }

            this._solver = new cassowary.SimplexSolver();
            this._solver.autoSolve = false;

            this._variables = [];
            this._constants = [];
            this._constraints = {};
            this._parameters = {};

            // Callback and its parameters
            // Yes it is possible to pass the parameters of the callback
            // to allow the user to avoid keeping closures around (closures keep objects in memory!)
            this._onNewSolution = null;
            this._onNewSolutionParams = null;

            this._forceResolving = true;

            // Optimization parameters
            this.z = 0;
            this._objectiveVariable = null;
            this._optimization = false;
            this._minimization = true;

            // Callback function when a parameter is missing
            // when parsing an expression
            var self = this;
            this._onParameterMissing = function(name) {
                return self.addVariable(name, {
                    x: 0
                }, 'x').getVariable(name);
            };
        }
        module.exports = System;

        System.prototype.onNewSolution = function(onNewSolution, onNewSolutionParams) {
            this._onNewSolution = onNewSolution;
            this._onNewSolutionParams = onNewSolutionParams;
            return this;
        };

        System.prototype._optimize = function(expression) {
            if (expression instanceof Variable === true) {
                this._objectiveVariable = expression;
                this._solver.optimize(expression._variable);
            } else {
                this._objectiveVariable = new Variable('z', {
                    z: 0
                }, 'z');
                this.addConstraint(new Equality(this._objectiveVariable, expression));
                this._solver.optimize(this._objectiveVariable._variable);
            }

            this._forceResolving = true;
            this._optimization = true;
        };

        System.prototype.minimize = function(expression) {
            if (typeof(expression) === 'string') {
                expression = parseExpression(expression, this._parameters, this._onParameterMissing);
            }

            this._optimize(expression);
            this._minimization = true;
            return this;
        };

        System.prototype.maximize = function(expression) {
            if (typeof(expression) === 'string') {
                expression = parseExpression(expression, this._parameters, this._onParameterMissing);
            }

            this._optimize(new Multiplication(expression, new Numeral(-1)));
            this._minimization = false;
            return this;
        };

        System.prototype.addVariable = function(name, object, property) {
            var variable = new Variable(name, object, property);
            this._variables.push(variable);
            this._parameters[name] = variable;
            return this;
        };

        System.prototype.addConstant = function(name, object, property) {
            var constant = new Constant(name, object, property);
            this._constants.push(constant);
            this._parameters[name] = constant;
            return this;
        };

        System.prototype.getVariable = function(name) {
            for (var v = 0; v < this._variables.length; v += 1) {
                if (this._variables[v]._name === name) {
                    return this._variables[v];
                }
            }
        };

        System.prototype.addConstraint = function(constraint) {
            if (typeof(constraint) === 'string') {
                constraint = parseExpression(constraint, this._parameters, this._onParameterMissing);
            }

            if (this._constraints[constraint._id] !== undefined) {
                console.warn('[System.addConstraint] Constraint already present in the system:', constraint);
                return;
            }

            this._solver.addConstraint(constraint.construct());
            this._constraints[constraint._id] = constraint;

            this._forceResolving = true;
            return this;
        };

        System.prototype.removeConstraint = function(constraint) {
            if (this._constraints[constraint._id] === undefined) {
                console.warn('[System.removeConstraint] Constraint not present in the system:', constraint);
                return;
            }

            constraint._unregisterFromPrimitives();
            this._solver.removeConstraint(constraint._constraint);
            delete this._constraints[constraint._id];

            this._forceResolving = true;
            return this;
        };

        System.prototype.resolve = function(slacking) {
            var c0, c1, constraint;

            var systemIsSameSameButDifferent = this._forceResolving;
            this._forceResolving = false;

            // Checking whether a constant has changed
            // var constraintsToUpdate = null;
            for (c0 = 0; c0 < this._constants.length; c0 += 1) {
                var constant = this._constants[c0];
                if (constant.refresh()) {
                    // The value of the constant has changed

                    // // At least one constraint will be updated
                    // if (constraintsToUpdate === null) {
                    // 	constraintsToUpdate = {};
                    // }

                    // // Updating all the constraints containing the constant
                    // var constraints = constant._constraints;
                    // for (c1 = 0; c1 < constraints.length; c1 += 1) {
                    // 	constraint = constraints[c1];
                    // 	constraintsToUpdate[constraint.id] = constraint;
                    // }

                    // Therefore it will need resolving
                    systemIsSameSameButDifferent = true;
                }
            }

            // // Updating constraints for which a constant has changed
            // if (constraintsToUpdate !== null) {
            // 	var constraintIds = Object.keys(constraintsToUpdate);
            // 	for (c1 = 0; c1 < constraintIds.length; c1 += 1) {
            // 		constraint = constraintsToUpdate[constraintIds[c1]];
            // 		// (Inefficient) Process to update a constraint:
            // 		// 1 - Remove the constraint
            // 		this._solver.removeConstraint(constraint._constraint);
            // 		// 2 - Reconstructing to consider the new constant value
            // 		constraint.construct();
            // 		// 3 - Add back the constraint
            // 		this._solver.addConstraint(constraint._constraint);

            // 		// Should be:
            // 		// constraint.updateConstant(constant);
            // 	}
            // }

            // Reconstructing the whole problem even if only one constant has changed
            if (systemIsSameSameButDifferent === true) {
                this._solver = new cassowary.SimplexSolver();
                this._solver.autoSolve = false;

                var constraintIds = Object.keys(this._constraints);
                for (c1 = 0; c1 < constraintIds.length; c1 += 1) {
                    constraint = this._constraints[constraintIds[c1]];
                    this._solver.addConstraint(constraint.construct());
                }
            }

            // Skip the resolution if no constant has changed and solver is required to slack
            if (systemIsSameSameButDifferent === false && slacking === true) {
                return;
            }

            // Resolving the problem
            this._solver.resolve();

            // Refreshing variables so that their corresponding objects get updated
            // with the newly computed feasible solution
            var solutionIsSameSameButDifferent = false;
            for (var v = 0; v < this._variables.length; v += 1) {
                if (this._variables[v].refresh() === true) {
                    solutionIsSameSameButDifferent = true;
                }
            }

            // Refreshing objective variable, if any
            if (this._optimization === true) {
                this._objectiveVariable.refresh();
                this.z = (this._minimization === true) ? this._objectiveVariable._value : -this._objectiveVariable._value;
            }

            // Triggering callback if the solution has changed
            if (solutionIsSameSameButDifferent === true) {
                if (this._onNewSolution !== null) {
                    this._onNewSolution(this._onNewSolutionParams);
                }
            }

            return this;
        };

        System.prototype.log = function() {
            for (var v = 0; v < this._variables.length; v += 1) {
                var variable = this._variables[v];
                console.log(variable._name, '=', variable._value);
            }

            console.log('objective value =', this.z);
        };

        System.prototype.getValue = function(name) {
            return this._parameters[name]._value;
        };

        System.prototype.getObjectiveValue = function() {
            return this.z;
        };
    }, {
        "../deps/cassowary.js": 1,
        "./operators.js": 5,
        "./parser.js": 6,
        "./primitives.js": 7
    }],
    4: [function(require, module, exports) {
        (function(global) {
            var primitives = require('./primitives.js');
            var operators = require('./operators.js');

            var System = require('./System.js');
            var Numeral = primitives.Numeral;

            var Addition = operators.Addition;
            var Subtraction = operators.Subtraction;
            var Multiplication = operators.Multiplication;
            var Division = operators.Division;
            var GreaterOrEqual = operators.GreaterOrEqual;
            var LowerOrEqual = operators.LowerOrEqual;
            var Equality = operators.Equality;

            var Constrained = {
                // System of constraints
                System: System,

                // Expression operators
                plus: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Addition(expression1, expression2);
                },

                minus: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Subtraction(expression1, expression2);
                },

                times: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Multiplication(expression1, expression2);
                },

                dividedBy: function(expression1, expression2) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Division(expression1, expression2);
                },

                // Constraint generators
                greaterThan: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new GreaterOrEqual(expression1, expression2, strength, weight);
                },

                lowerThan: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new LowerOrEqual(expression1, expression2, strength, weight);
                },

                equals: function(expression1, expression2, strength, weight) {
                    if (typeof(expression1) === 'number') {
                        expression1 = new Numeral(expression1);
                    }
                    if (typeof(expression2) === 'number') {
                        expression2 = new Numeral(expression2);
                    }
                    return new Equality(expression1, expression2, strength, weight);
                }
            };

            // window within a browser, global within node
            var root;
            if (typeof(window) !== 'undefined') {
                root = window;
            } else if (typeof(global) !== 'undefined') {
                root = global;
            } else {
                console.warn('[TINA] Your environment might not support TINA.');
                root = this;
            }

            module.exports = root.Constrained = Constrained;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "./System.js": 3,
        "./operators.js": 5,
        "./primitives.js": 7
    }],
    5: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var Expression = require('./Expression.js');

        function Addition(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Addition.prototype = Object.create(Expression.prototype);
        Addition.prototype.constructor = Addition;
        Addition.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.plus(right);
        };

        function Subtraction(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Subtraction.prototype = Object.create(Expression.prototype);
        Subtraction.prototype.constructor = Subtraction;
        Subtraction.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.minus(right);
        };

        function Multiplication(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Multiplication.prototype = Object.create(Expression.prototype);
        Multiplication.prototype.constructor = Multiplication;
        Multiplication.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.times(right);
        };

        function Division(expression1, expression2) {
            Expression.call(this);
            this.addExpressions(expression1, expression2);
        }
        Division.prototype = Object.create(Expression.prototype);
        Division.prototype.constructor = Division;
        Division.prototype.construct = function() {
            var left = this._left.construct();
            var right = this._right.construct();
            return left.divide(right);
        };

        var constraintCount = 0;

        function Constraint(expression1, expression2, strength, weight) {
            this._expression1 = expression1;
            this._expression2 = expression2;
            this._strength = strength;
            this._weight = weight;

            this._constraint = null;
            this._id = (constraintCount++).toString();

            this._registerToPrimitives();
        }

        Constraint.prototype._registerToPrimitives = function() {
            var stack = [this._expression1, this._expression2];
            while (stack.length !== 0) {
                var expression = stack.pop();
                if (expression._left === null) {
                    expression._register(this);
                } else {
                    stack.push(expression._left);
                    stack.push(expression._right);
                }
            }
        };

        Constraint.prototype._unregisterFromPrimitives = function() {
            var stack = [this._expression1, this._expression2];
            while (stack.length !== 0) {
                var expression = stack.pop();
                if (expression._left === null) {
                    expression._unregister(this);
                } else {
                    stack.push(expression._left);
                    stack.push(expression._right);
                }
            }
        };

        function LowerOrEqual(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        LowerOrEqual.prototype = Object.create(Constraint.prototype);
        LowerOrEqual.prototype.constructor = LowerOrEqual;
        LowerOrEqual.prototype.construct = function() {
            this._constraint = new cassowary.Inequality(
                this._expression1.construct(),
                cassowary.LEQ,
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        function GreaterOrEqual(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        GreaterOrEqual.prototype = Object.create(Constraint.prototype);
        GreaterOrEqual.prototype.constructor = GreaterOrEqual;
        GreaterOrEqual.prototype.construct = function() {
            this._constraint = new cassowary.Inequality(
                this._expression1.construct(),
                cassowary.GEQ,
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        function Equality(expression1, expression2, strength, weight) {
            Constraint.call(this, expression1, expression2, strength, weight);
        }
        Equality.prototype = Object.create(Constraint.prototype);
        Equality.prototype.constructor = Equality;
        Equality.prototype.construct = function() {
            this._constraint = new cassowary.Equation(
                this._expression1.construct(),
                this._expression2.construct(),
                this._strength,
                this._weight
            );
            return this._constraint;
        };

        module.exports = {
            Addition: Addition,
            Subtraction: Subtraction,
            Multiplication: Multiplication,
            Division: Division,
            LowerOrEqual: LowerOrEqual,
            GreaterOrEqual: GreaterOrEqual,
            Equality: Equality
        };
    }, {
        "../deps/cassowary.js": 1,
        "./Expression.js": 2
    }],
    6: [function(require, module, exports) {
        var systemOperators = require('./operators.js');
        var systemPrimitives = require('./primitives.js');

        var Addition = systemOperators.Addition;
        var Subtraction = systemOperators.Subtraction;
        var Multiplication = systemOperators.Multiplication;
        var Division = systemOperators.Division;
        var GreaterOrEqual = systemOperators.GreaterOrEqual;
        var LowerOrEqual = systemOperators.LowerOrEqual;
        var Equality = systemOperators.Equality;

        var Numeral = systemPrimitives.Numeral;

        //���������������������������������������������������������������������������
        /**
         * @class  Expression Parser
         * @author Cedric Stoquer
         *
         * @param {String} str - string buffer
         *
         *
         * Simple expression parser with the following features:
         * - parse variables, integer and float numbers, string constants, unary and binary operators,
         *   parenthesis, predefined functions with any number of parameters.
         * - correctly resolve operator precedence.
         *
         * Originaly designed to parse BASIC programs
         */
        function Parser(str) {
            this.str = str;
            this.parameterMap = null;
            this.onParameterMissing = null;
        }

        function parseExpression(str, parameterMap, onParameterMissing) {
            var parser = new Parser(str);
            parser.parameterMap = parameterMap;
            parser.onParameterMissing = onParameterMissing;
            return parser.parseExpression();
        }

        module.exports = parseExpression;

        //���������������������������������������������������������������������������

        var operators = [
            // { id: ';',   precedence: 0 },
            // { id: 'AND', precedence: 1 },
            // { id: 'OR',  precedence: 1 },
            // { id: 'XOR', precedence: 1 },
            // { id: '<>',  precedence: 2 },
            {
                id: '>=',
                precedence: 2,
                class: GreaterOrEqual
            }, {
                id: '<=',
                precedence: 2,
                class: LowerOrEqual
            }, {
                id: '=',
                precedence: 2,
                class: Equality
            },
            // { id: '>',   precedence: 2 },
            // { id: '<',   precedence: 2 },
            {
                id: '+',
                precedence: 3,
                class: Addition
            }, {
                id: '-',
                precedence: 3,
                class: Subtraction
            },
            // { id: '\\',  precedence: 4 },
            // { id: 'MOD', precedence: 4 },
            {
                id: '*',
                precedence: 4,
                class: Multiplication
            }, {
                id: '/',
                precedence: 4,
                class: Division
            }
        ];

        var unaryOperators = [
            // { id: '!' }
        ];

        var functions = [
            // { id: 'ABS',      parameters: 1 },
            // { id: 'ATN',      parameters: 1 },
            // { id: 'CIN',      parameters: 1 },
            // { id: 'COS',      parameters: 1 },
            // { id: 'EXP',      parameters: 1 },
            // { id: 'INT',      parameters: 1 },
            // { id: 'LOG10',    parameters: 1 },
            // { id: 'LOG',      parameters: 1 },
            // { id: 'MAX',      parameters: '*' },
            // { id: 'MIN',      parameters: '*' },
            // { id: 'PI',       parameters: 0 },
            // { id: 'ROUND',    parameters: [1, 2] },
            // { id: 'SGN',      parameters: 1 },
            // { id: 'SIN',      parameters: 1 },
            // { id: 'SQR',      parameters: 1 },
            // { id: 'TAN',      parameters: 1 }
        ];

        //���������������������������������������������������������������������������

        Parser.prototype.removeWhiteSpace = function() {
            var t = this;
            // while (t.str[0] === ' ' || t.str[0] === '\n') t.str = t.str.substring(1);
            t.str = t.str.replace(' ', '');
            t.str = t.str.replace('\n', '');
        };

        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������
        //�������������������������������������������������������������������������������

        /** @method parseParenthesis
         */
        Parser.prototype.parseParenthesis = function() {
            var t = this;
            if (t.str[0] !== '(') throw new Error('An opening parenthesis is missing.');
            //consume first parenthesis
            t.str = t.str.substring(1);
            var res = '';
            var stackParenthesis = 0;
            while (!(t.str[0] === ')' && stackParenthesis === 0)) {
                if (t.str[0] === '(') stackParenthesis++;
                if (t.str[0] === ')') stackParenthesis--;
                if (stackParenthesis < 0) throw new Error('Too much closing parenthesis.');
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Parenthesis expression doesn\'t resolve');
            }
            // consume last parenthesis
            t.str = t.str.substring(1);

            // parse expression inside parenthesis
            res = parseExpression(res, t.parameterMap, t.onParameterMissing);
            // res = {
            // 	type: 'parenthesis',
            // 	arg: res
            // };
            return res;
        };

        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������
        //�����������������������������������������

        /** @method getParenthesisList
         * Parse a list of comma separated arguments
         */
        Parser.prototype.getParenthesisList = function() {
            var t = this;
            // parse parenthesis content: (expr, expr, ...)
            if (t.str[0] !== '(') throw new Error('An opening parenthesis is missing.');
            // consume first "("
            t.str = t.str.substring(1);
            var args = [];
            var arg = '';
            var stackParenthesis = 0;
            while (!(t.str[0] === ')' && stackParenthesis === 0)) {
                if (t.str[0] === '(') stackParenthesis++;
                if (t.str[0] === ')') stackParenthesis--;
                if (stackParenthesis < 0) throw new Error('Too much closing parenthesis.');
                if (t.str[0] === ',' && stackParenthesis === 0) {
                    arg = parseExpression(arg);
                    args.push(arg);
                    arg = '';
                } else {
                    arg += t.str[0];
                }
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Parenthesis expression doesn\'t resolve');
            }
            // push last parameter
            arg = parseExpression(arg);
            args.push(arg);
            // consume last ")"
            t.str = t.str.substring(1);
            return args;
        };

        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������
        //�������������������������������������������������

        /** @method parseString
         */
        Parser.prototype.parseString = function() {
            var t = this;
            var res = '';
            if (t.str[0] !== '"') throw new Error('An opening quote is missing.');
            // consume first double quote
            t.str = t.str.substring(1);
            while (t.str[0] !== '"') {
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') throw new Error('Closing quote not found.');
            }
            // consume last double quote
            t.str = t.str.substring(1);
            return {
                type: 'string',
                value: res
            };
        };

        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������
        //��������������������������������������������������

        /** @method parseNumber
         */
        Parser.prototype.parseNumber = function() {
            var t = this;
            var type = 'int';
            var res = '';

            // check for a negative number
            if (t.str[0] === '-') {
                res = '-';
                t.str = t.str.substring(1);
                t.removeWhiteSpace();
            }

            if (t.str === '') throw new Error('End of line before number.');

            if (t.str[0].search(/[0-9]/) === -1) throw new Error('Not a digit character');
            while (t.str[0].search(/[0-9]/) === 0) {
                res += t.str[0];
                t.str = t.str.substring(1);
                if (t.str === '') break;
            }

            // check for a decimal point
            if (t.str[0] === '.') {
                type = 'float';
                res += '.';
                t.str = t.str.substring(1);
                // continue to consume decimal digits
                while (t.str[0].search(/[0-9]/) === 0) {
                    res += t.str[0];
                    t.str = t.str.substring(1);
                    if (t.str === '') break;
                }
            }

            // var value = Number(res);
            return new Numeral(parseFloat(res));
        };

        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������

        /** @method parseFunction
         * @desc   get function parameters content
         * @param {Object} func - function definition object
         *
         * A function have the following syntax:
         * - without parameters                : FUNC
         * - parameters defined in parenthesis : FUNC(X)
         * - and comma separated               : FUNC(X1, X2, X3, ...)
         */
        Parser.prototype.parseFunction = function(func) {
            var t = this;
            // function name has already been consumed.
            var res = {
                type: 'function',
                id: func.id
            };
            var parameters = func.parameters;
            // parameters can be:
            // 0 -> no parameters, thus no parenthesis
            if (parameters === 0) return res;

            // int   -> a fixed number of parameter
            // array -> various number of parameters is possible
            // '*'   -> number of parameters is free (but at least 1)

            // special case: if function can have 0 or more parameters,
            // then if we have 0 parameters, there are no parenthesis
            if (Array.isArray(parameters) && parameters.indexOf(0) !== -1 && t.str[0] !== '(') {
                return res;
            }

            var args = t.getParenthesisList();

            // check parameters count
            var count = args.length;
            // there are no parameter (but there are brackets)
            if (count === 0) throw new Error('There is no arguments inside function brackets.');
            // number of parameters is incorrect
            if (!isNaN(parameters) && count !== parameters) throw new Error('Incorrect number of arguments.');
            // check when various number of parameters are possible
            if (Array.isArray(parameters)) {
                var ok = false;
                for (var i = 0, len = parameters.length; i < len; i++) {
                    if (count === parameters[i]) {
                        ok = true;
                        break;
                    }
                }
                if (!ok) throw new Error('Incorrect number of arguments.');
            }

            // add parameters in result
            res.args = args;
            return res;
        };


        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������
        //�����������������������������������������������������������������

        /** @method parseVariable
         */
        Parser.prototype.parseVariable = function() {
            var t = this;
            var res = '';
            // default type for locomotive basic are float
            var varType = 'float';

            // first character must be a letter
            if (t.str[0].search(/[A-Za-z]/) === -1) throw new Error('Invalid variable name');
            res += t.str[0];
            t.str = t.str.substring(1);

            // following character could be letters or numbers
            while (t.str !== '' && t.str[0].search(/[A-Za-z0-9]/) !== -1) {
                res += t.str[0];
                t.str = t.str.substring(1);
            }

            // variable name can ends with one of these special characters : $ % !
            if (t.str[0] === '$' || t.str[0] === '%' || t.str[0] === '!') {
                res += t.str[0];
                switch (t.str[0]) {
                    case '$':
                        varType = 'string';
                        break;
                    case '%':
                        varType = 'int';
                        break;
                    case '!':
                        varType = 'float';
                        break;
                }
                t.str = t.str.substring(1);
            }

            /*res = {
            	type: 'variable',
            	varType: varType,
            	id: res,
            };

            // if variable is an array, following character is a opening bracket
            if (t.str[0] === '(') {
            	// extract parenthesis content
            	res.indexes = t.getParenthesisList();
            	// set variable as an array
            	res.isArray = true;
            }

            return res;*/

            var parameter = t.parameterMap[res];
            return (parameter === undefined) ? t.onParameterMissing(res) : parameter;
        };

        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������
        //��������������������������������������������������������������������������

        /** @method getNextObject
         *
         * next object should be one of these:
         *  ~  (e)     an expression in parenthesis
         *  ~  -1      a number (possibly negative). NOTA: no whitespace allowed between "-" operator and the number
         *  ~  -e      unary operator applied to an expression
         *  ~  NOT e   unary boolean operator NOT
         *  ~  F(e,e)  a function (function names are known, see table)
         *  ~  X       a variable name
         */
        Parser.prototype.getNextObject = function() {
            var t = this;
            t.removeWhiteSpace();

            if (t.str === '') return null;

            // check if next object is an expression in parenthesis
            if (t.str[0] === '(') return t.parseParenthesis();

            // check if next object is a string
            if (t.str[0] === '"') return t.parseString();

            // TODO: hexadecimal number

            // check for unary '-' operator (not with number)
            if (t.str[0] === '-' && t.str[1].search(/[0-9]/) === -1) {
                // consume '-'
                t.str = t.str.substring(1);
                return new Multiplication(new Numeral(-1), t.getNextObject());
                // return { type: 'unaryOp', id: '-', arg: t.getNextObject() };
            }

            // check for unary operators
            var i;
            for (i = 0; i < unaryOperators.length; i++) {
                var operatorId = unaryOperators[i].id;
                var strLen = operatorId.length;
                if (t.str.substring(0, strLen) === operatorId) {
                    // consume operator
                    t.str = t.str.substring(strLen);
                    return new unaryOperators[i].class(t.getNextObject());
                    // return { type: 'unaryOp', id: operatorId, arg: t.getNextObject() };
                }
            }

            // check if next object is a number
            if (t.str[0].search(/[\-0-9]/) !== -1) return t.parseNumber();

            // check if next object is a function
            for (i = 0; i < functions.length; i++) {
                var fLen = functions[i].id.length;
                if (t.str.substring(0, fLen) === functions[i].id) {
                    // consume funtion name
                    t.str = t.str.substring(fLen);
                    // get parameters and return function object
                    return t.parseFunction(functions[i]);
                }
            }

            // check if next object is a variable name
            if (t.str[0].search(/[A-Za-z]/) !== -1) return t.parseVariable();

            // not recognized object
            return null;
        };

        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������
        //������������������������������������������������������������������������������������������

        /** @method getNextOperator
         *
         * next token is an operator in the list
         */
        Parser.prototype.getNextOperator = function() {
            var t = this;
            t.removeWhiteSpace();

            // check end of stream
            if (t.str === '') return null;

            // check each of operators
            for (var i = 0; i < operators.length; i++) {
                var oLen = operators[i].id.length;
                if (t.str.substring(0, oLen) === operators[i].id) {
                    // consume token
                    t.str = t.str.substring(oLen);
                    // return operator
                    return operators[i];
                }
            }

            // next element is not a token
            return null;
        };

        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������
        //������������������������������������������������������������������������

        /** @method parseExpression
         *
         * next token is an operator in the list
         */
        Parser.prototype.parseExpression = function() {
            // get all tokens
            var operator;
            var objects = [];
            var operators = [];
            while (true) {
                objects.push(this.getNextObject());
                operator = this.getNextOperator();
                if (operator === null) break;
                operators.push(operator);
            }

            // parse expression
            var i = 0;
            while (operators.length > 0) {
                operator = operators[i];
                var lookahead = operators[i + 1];
                if (!lookahead || operator.precedence >= lookahead.precedence) {
                    // reducing object[i] operator[i] object[i+1]
                    // var object = {
                    // 	type: 'operator',
                    // 	id:   operator.id,
                    // 	arg1: objects[i],
                    // 	arg2: objects[i+1]
                    // };

                    var object = new operator.class(objects[i], objects[i + 1]);

                    objects.splice(i, 2, object);
                    operators.splice(i, 1);
                    i = 0;
                    continue;
                }
                i += 1;
            }
            return objects[0];
        };



    }, {
        "./operators.js": 5,
        "./primitives.js": 7
    }],
    7: [function(require, module, exports) {
        var cassowary = require('../deps/cassowary.js');
        var Expression = require('./Expression.js');

        function Numeral(value) {
            this._value = value;
            Expression.call(this);
        }
        Numeral.prototype = Object.create(Expression.prototype);
        Numeral.prototype.constructor = Numeral;

        Numeral.prototype.construct = function() {
            return new cassowary.Expression(this._value);
        };

        Numeral.prototype._register = function() {};
        Numeral.prototype._unregister = function() {};


        function ObjectBinder(name, object, property) {
            this._name = name;
            this._object = object;
            this._property = property;
            this._value = object[property];

            this._constraints = [];
        }

        ObjectBinder.prototype._register = function(constraint) {
            this._constraints.push(constraint);
        };

        ObjectBinder.prototype._unregister = function(constraint) {
            var idx = this._constraints.indexOf(constraint);
            if (idx === -1) {
                this._constraints.splice(idx, 1);
            }
        };


        function Constant(name, object, property) {
            if ((this instanceof Constant) === false) {
                return new Constant(object, property);
            }

            ObjectBinder.call(this, name, object, property);
            Expression.call(this);
        }
        Constant.prototype = Object.create(Expression.prototype);
        Constant.prototype.constructor = Constant;
        Constant.prototype._register = ObjectBinder.prototype._register;
        Constant.prototype._unregister = ObjectBinder.prototype._unregister;

        Constant.prototype.construct = function() {
            return new cassowary.Expression(this._object[this._property]);
        };

        Constant.prototype.refresh = function() {
            if (this._value !== this._object[this._property]) {
                this._value = this._object[this._property];
                return true;
            }

            return false;
        };


        function Variable(name, object, property) {
            if ((this instanceof Variable) === false) {
                return new Variable(object, property);
            }

            // Callback and its parameters
            // Yes it is possible to pass the parameters of the callback
            // to allow the user to avoid keeping closures around (closures keep objects in memory!)
            this._onChange = null;
            this._onChangeParams = null;

            ObjectBinder.call(this, name, object, property);
            Expression.call(this);

            this._variable = new cassowary.Variable({
                name: this._name,
                value: this._value
            });
        }
        Variable.prototype = Object.create(cassowary.Variable.prototype);
        Variable.prototype.constructor = Variable;
        Variable.prototype._register = ObjectBinder.prototype._register;

        Variable.prototype.construct = function() {
            return new cassowary.Expression(this._variable, 1);
        };

        Variable.prototype.refresh = function() {
            if (this._value !== this._variable.value) {
                this._object[this._property] = this._variable.value;
                if (this._onChange !== null) {
                    this._onChange(this._onChangeParams, this._variable.value, this._value);
                }
                this._value = this._variable.value;
                return true;
            }

            return false;
        };

        Variable.prototype.onChange = function(onChange, onChangeParams) {
            this._onChange = onChange;
            this._onChangeParams = onChangeParams;
            return this;
        };

        module.exports = {
            Numeral: Numeral,
            Constant: Constant,
            Variable: Variable
        };
    }, {
        "../deps/cassowary.js": 1,
        "./Expression.js": 2
    }]
}, _modules , [4]);

module.exports = _modules[4].exports;
};
BundleModuleCode['plugins/csp/fmin']=function (module,exports,global,process){
/* https://github.com/benfred/fmin */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.fmin = global.fmin || {})));
}(this, function (exports) { 'use strict';

    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    function bisect(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
        }

        if (fA === 0) return a;
        if (fB === 0) return b;

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    }

    // need some basic operations on vectors, rather than adding a dependency,
    // just define here
    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

    function dot(a, b) {
        var ret = 0;
        for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
        }
        return ret;
    }

    function norm2(a)  {
        return Math.sqrt(dot(a, a));
    }

    function scale(ret, value, c) {
        for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
        }
    }

    function weightedSum(ret, w1, v1, w2, v2) {
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
        }
    }

    /** minimizes a function using the downhill simplex method */
    function nelderMead(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.05,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-6,
            minTolerance = parameters.minErrorDelta || 1e-5,
            rho = (parameters.rho !== undefined) ? parameters.rho : 1,
            chi = (parameters.chi !== undefined) ? parameters.chi : 2,
            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
            maxDiff;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        simplex[0].id = 0;
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
            simplex[i+1].id = i+1;
        }

        function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
                simplex[N][i] = value[i];
            }
            simplex[N].fx = value.fx;
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        var centroid = x0.slice(),
            reflected = x0.slice(),
            contracted = x0.slice(),
            expanded = x0.slice();

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
                // copy the simplex (since later iterations will mutate) and
                // sort it to have a consistent order between iterations
                var sortedSimplex = simplex.map(function (x) {
                    var state = x.slice();
                    state.fx = x.fx;
                    state.id = x.id;
                    return state;
                });
                sortedSimplex.sort(function(a,b) { return a.id - b.id; });

                parameters.history.push({x: simplex[0].slice(),
                                         fx: simplex[0].fx,
                                         simplex: sortedSimplex});
            }

            maxDiff = 0;
            for (i = 0; i < N; ++i) {
                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
                (maxDiff < minTolerance)) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            weightedSum(reflected, 1+rho, centroid, -rho, worst);
            reflected.fx = f(reflected);

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx < simplex[0].fx) {
                weightedSum(expanded, 1+chi, centroid, -chi, worst);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    updateSimplex(expanded);
                }  else {
                    updateSimplex(reflected);
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                    // do an inside contraction
                    weightedSum(contracted, 1+psi, centroid, -psi, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < reflected.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // if we don't contract here, we're done
                    if (sigma >= 1) break;

                    // do a reduction
                    for (i = 1; i < simplex.length; ++i) {
                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            } else {
                updateSimplex(reflected);
            }
        }

        simplex.sort(sortOrder);
        return {fx : simplex[0].fx,
                x : simplex[0]};
    }

    /// searches along line 'pk' for a point that satifies the wolfe conditions
    /// See 'Numerical Optimization' by Nocedal and Wright p59-60
    /// f : objective function
    /// pk : search direction
    /// current: object containing current gradient/loss
    /// next: output: contains next gradient/loss
    /// returns a: step size taken
    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),
            phi = phi0, phi_old = phi0,
            phiPrime = phiPrime0,
            a0 = 0;

        a = a || 1;
        c1 = c1 || 1e-6;
        c2 = c2 || 0.1;

        function zoom(a_lo, a_high, phi_lo) {
            for (var iteration = 0; iteration < 16; ++iteration) {
                a = (a_lo + a_high)/2;
                weightedSum(next.x, 1.0, current.x, a, pk);
                phi = next.fx = f(next.x, next.fxprime);
                phiPrime = dot(next.fxprime, pk);

                if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                    (phi >= phi_lo)) {
                    a_high = a;

                } else  {
                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                        return a;
                    }

                    if (phiPrime * (a_high - a_lo) >=0) {
                        a_high = a_lo;
                    }

                    a_lo = a;
                    phi_lo = phi;
                }
            }

            return 0;
        }

        for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);
            if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                (iteration && (phi >= phi_old))) {
                return zoom(a0, a, phi_old);
            }

            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                return a;
            }

            if (phiPrime >= 0 ) {
                return zoom(a, a0, phi);
            }

            phi_old = phi;
            a0 = a;
            a *= 2;
        }

        return a;
    }

    function conjugateGradient(f, initial, params) {
        // allocate all memory up front here, keep out of the loop for perfomance
        // reasons
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            yk = initial.slice(),
            pk, temp,
            a = 1,
            maxIterations;

        params = params || {};
        maxIterations = params.maxIterations || initial.length * 20;

        current.fx = f(current.x, current.fxprime);
        pk = current.fxprime.slice();
        scale(pk, current.fxprime,-1);

        for (var i = 0; i < maxIterations; ++i) {
            a = wolfeLineSearch(f, pk, current, next, a);

            // todo: history in wrong spot?
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     alpha: a});
            }

            if (!a) {
                // faiiled to find point that satifies wolfe conditions.
                // reset direction for next iteration
                scale(pk, current.fxprime, -1);

            } else {
                // update direction using Polak–Ribiere CG method
                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);

                var delta_k = dot(current.fxprime, current.fxprime),
                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);

                weightedSum(pk, beta_k, pk, -1, next.fxprime);

                temp = current;
                current = next;
                next = temp;
            }

            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        if (params.history) {
            params.history.push({x: current.x.slice(),
                                 fx: current.fx,
                                 fxprime: current.fxprime.slice(),
                                 alpha: a});
        }

        return current;
    }

    function gradientDescent(f, initial, params) {
        params = params || {};
        var maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 0.001,
            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};

        for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice()});
            }

            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        return current;
    }

    function gradientDescentLineSearch(f, initial, params) {
        params = params || {};
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 1,
            pk = initial.slice(),
            c1 = params.c1 || 1e-3,
            c2 = params.c2 || 0.1,
            temp,
            functionCalls = [];

        if (params.history) {
            // wrap the function call to track linesearch samples
            var inner = f;
            f = function(x, fxprime) {
                functionCalls.push(x.slice());
                return inner(x, fxprime);
            };
        }

        current.fx = f(current.x, current.fxprime);
        for (var i = 0; i < maxIterations; ++i) {
            scale(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);

            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     functionCalls: functionCalls,
                                     learnRate: learnRate,
                                     alpha: learnRate});
                functionCalls = [];
            }


            temp = current;
            current = next;
            next = temp;

            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;
        }

        return current;
    }

    exports.bisect = bisect;
    exports.nelderMead = nelderMead;
    exports.conjugateGradient = conjugateGradient;
    exports.gradientDescent = gradientDescent;
    exports.gradientDescentLineSearch = gradientDescentLineSearch;
    exports.zeros = zeros;
    exports.zerosM = zerosM;
    exports.norm2 = norm2;
    exports.weightedSum = weightedSum;
    exports.scale = scale;

}));
};

Base64=Require('os/base64');
//Buffer=Require('os/buffer').Buffer;
window.CSP=CSP = Require('plugins/csp/csp.js');
</script>
    <script>/*!
 * jQuery JavaScript Library v3.2.1X01
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",      // changed \0 to \\x00

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\x00" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
// if ( !noGlobal ) 
{
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );
</script>
    <script type="text/javascript" charset="utf-8">/*!
 * The buffer module from node.js, for the browser.
 * Can be used with SharedArrayBuffers!
 * Uses Uin8Array as data buffer (only slow buffers).
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * 
 * @license  MIT
 *
 * https://github.com/feross/buffer
 */
/* eslint-disable no-proto */

BufferArray = {};
BufferArray.init=function () {
  // 'use strict'
  if (typeof BufferArray == 'undefined') BufferArray = {};
  var exports=BufferArray;
  var base64 = {};
  (function (exports) {
    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray

    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63
    function getLens (b64) {
      var len = b64.length

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len
      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)

      return [validLen, placeHoldersLen]
    }
    function byteLength (b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    function toByteArray (b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
      var curByte = 0
      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen

      var i
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
      return arr
    }
    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }
    function encodeChunk (uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }
    function fromByteArray (uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }
      return parts.join('')
    }
  })(base64);
  const ieee754 = {
    read : function(buffer, offset, isBE, mLen, nBytes) {
      var e, m,
          eLen = nBytes * 8 - mLen - 1,
          eMax = (1 << eLen) - 1,
          eBias = eMax >> 1,
          nBits = -7,
          i = isBE ? 0 : (nBytes - 1),
          d = isBE ? 1 : -1,
          s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity);
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    },

    write :  function(buffer, value, offset, isBE, mLen, nBytes) {
      var e, m, c,
          eLen = nBytes * 8 - mLen - 1,
          eMax = (1 << eLen) - 1,
          eBias = eMax >> 1,
          rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
          i = isBE ? (nBytes - 1) : 0,
          d = isBE ? -1 : 1,
          s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

      buffer[offset + i - d] |= s * 128;
    }
  }
  const customInspectSymbol =
    (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
      ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
      : null
  exports.Buffer = Buffer
  exports.SlowBuffer = SlowBuffer
  exports.INSPECT_MAX_BYTES = 50

  const K_MAX_LENGTH = 0x7fffffff
  exports.kMaxLength = K_MAX_LENGTH

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
      typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by ' +
      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    )
  }

  function typedArraySupport () {
    // Can typed array instances can be augmented?
    try {
      const arr = new Uint8Array(1)
      const proto = { foo: function () { return 42 } }
      Object.setPrototypeOf(proto, Uint8Array.prototype)
      Object.setPrototypeOf(arr, proto)
      return arr.foo() === 42
    } catch (e) {
      return false
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined
      return this.buffer
    }
  })

  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined
      return this.byteOffset
    }
  })

  function createBuffer (length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length)
    Object.setPrototypeOf(buf, Buffer.prototype)
    return buf
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192 // not used by this implementation

  function from (value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset)
    }

    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value)
    }

    if (value == null) {
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }

    if (isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }

    if (typeof SharedArrayBuffer !== 'undefined' &&
        (isInstance(value, SharedArrayBuffer) ||
        (value && isInstance(value.buffer, SharedArrayBuffer)))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }

    if (typeof value === 'number') {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      )
    }

    const valueOf = value.valueOf && value.valueOf()
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length)
    }

    const b = fromObject(value)
    if (b) return b

    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
    }

    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length)
  }

  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
  Object.setPrototypeOf(Buffer, Uint8Array)

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }

  function alloc (size, fill, encoding) {
    assertSize(size)
    if (size <= 0) {
      return createBuffer(size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpreted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(size).fill(fill, encoding)
        : createBuffer(size).fill(fill)
    }
    return createBuffer(size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding)
  }

  function allocUnsafe (size) {
    assertSize(size)
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  }
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size)
  }

  function fromString (string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8'
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }

    const length = byteLength(string, encoding) | 0
    let buf = createBuffer(length)

    const actual = buf.write(string, encoding)

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual)
    }

    return buf
  }

  function fromArrayLike (array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0
    const buf = createBuffer(length)
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255
    }
    return buf
  }

  function fromArrayView (arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView)
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
    }
    return fromArrayLike(arrayView)
  }

  function fromArrayBuffer (array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds')
    }

    let buf
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array)
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset)
    } else {
      buf = new Uint8Array(array, byteOffset, length)
    }

    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype)

    return buf
  }

  function fromObject (obj) {
    if (Buffer.isBuffer(obj)) {
      const len = checked(obj.length) | 0
      const buf = createBuffer(len)

      if (buf.length === 0) {
        return buf
      }

      obj.copy(buf, 0, 0, len)
      return buf
    }

    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  function checked (length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0
    }
    return Buffer.alloc(+length)
  }

  Buffer.isBuffer = function isBuffer (b) {
    return b != null && b._isBuffer === true &&
      b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
  }

  Buffer.compare = function compare (a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      )
    }

    if (a === b) return 0

    let x = a.length
    let y = b.length

    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i]
        y = b[i]
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  }

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  }

  Buffer.concat = function concat (list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    let i
    if (length === undefined) {
      length = 0
      for (i = 0; i < list.length; ++i) {
        length += list[i].length
      }
    }

    const buffer = Buffer.allocUnsafe(length)
    let pos = 0
    for (i = 0; i < list.length; ++i) {
      let buf = list[i]
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer.isBuffer(buf)) {
            buf = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
          }
          buf.copy(buffer, pos)
        } else {
          Uint8Array.prototype.set.call(
            buffer,
            buf,
            pos
          )
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      } else {
        buf.copy(buffer, pos)
      }
      pos += buf.length
    }
    return buffer
  }

  function byteLength (string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
        'Received type ' + typeof string
      )
    }

    const len = string.length
    const mustMatch = (arguments.length > 2 && arguments[2] === true)
    if (!mustMatch && len === 0) return 0

    // Use a for loop to avoid recursion
    let loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
          }
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer.byteLength = byteLength

  function slowToString (encoding, start, end) {
    let loweredCase = false

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length
    }

    if (end <= 0) {
      return ''
    }

    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0
    start >>>= 0

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8'

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase()
          loweredCase = true
      }
    }
  }

  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true

  function swap (b, n, m) {
    const i = b[n]
    b[n] = b[m]
    b[m] = i
  }

  Buffer.prototype.swap16 = function swap16 () {
    const len = this.length
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1)
    }
    return this
  }

  Buffer.prototype.swap32 = function swap32 () {
    const len = this.length
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3)
      swap(this, i + 1, i + 2)
    }
    return this
  }

  Buffer.prototype.swap64 = function swap64 () {
    const len = this.length
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7)
      swap(this, i + 1, i + 6)
      swap(this, i + 2, i + 5)
      swap(this, i + 3, i + 4)
    }
    return this
  }

  Buffer.prototype.toString = function toString () {
    const length = this.length
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  }

  Buffer.prototype.toLocaleString = Buffer.prototype.toString

  Buffer.prototype.equals = function equals (b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  }

  Buffer.prototype.inspect = function inspect () {
    let str = ''
    const max = exports.INSPECT_MAX_BYTES
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
    if (this.length > max) str += ' ... '
    return '<Buffer ' + str + '>'
  }
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
  }

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength)
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. ' +
        'Received type ' + (typeof target)
      )
    }

    if (start === undefined) {
      start = 0
    }
    if (end === undefined) {
      end = target ? target.length : 0
    }
    if (thisStart === undefined) {
      thisStart = 0
    }
    if (thisEnd === undefined) {
      thisEnd = this.length
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0
    end >>>= 0
    thisStart >>>= 0
    thisEnd >>>= 0

    if (this === target) return 0

    let x = thisEnd - thisStart
    let y = end - start
    const len = Math.min(x, y)

    const thisCopy = this.slice(thisStart, thisEnd)
    const targetCopy = target.slice(start, end)

    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i]
        y = targetCopy[i]
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  }

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset
      byteOffset = 0
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000
    }
    byteOffset = +byteOffset // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1)
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding)
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    let indexSize = 1
    let arrLength = arr.length
    let valLength = val.length

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase()
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2
        arrLength /= 2
        valLength /= 2
        byteOffset /= 2
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    let i
    if (dir) {
      let foundIndex = -1
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex
          foundIndex = -1
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
      for (i = byteOffset; i >= 0; i--) {
        let found = true
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  }

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  }

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  }

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0
    const remaining = buf.length - offset
    if (!length) {
      length = remaining
    } else {
      length = Number(length)
      if (length > remaining) {
        length = remaining
      }
    }

    const strLen = string.length

    if (length > strLen / 2) {
      length = strLen / 2
    }
    let i
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16)
      if (numberIsNaN(parsed)) return i
      buf[offset + i] = parsed
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8'
      length = this.length
      offset = 0
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset
      length = this.length
      offset = 0
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0
      if (isFinite(length)) {
        length = length >>> 0
        if (encoding === undefined) encoding = 'utf8'
      } else {
        encoding = length
        length = undefined
      }
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    const remaining = this.length - offset
    if (length === undefined || length > remaining) length = remaining

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8'

    let loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  }

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf)
    } else {
      return base64.fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end)
    const res = []

    let i = start
    while (i < end) {
      const firstByte = buf[i]
      let codePoint = null
      let bytesPerSequence = (firstByte > 0xEF)
        ? 4
        : (firstByte > 0xDF)
            ? 3
            : (firstByte > 0xBF)
                ? 2
                : 1

      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte
            }
            break
          case 2:
            secondByte = buf[i + 1]
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint
              }
            }
            break
          case 3:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint
              }
            }
            break
          case 4:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            fourthByte = buf[i + 3]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD
        bytesPerSequence = 1
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000
        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
        codePoint = 0xDC00 | codePoint & 0x3FF
      }

      res.push(codePoint)
      i += bytesPerSequence
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  const MAX_ARGUMENTS_LENGTH = 0x1000

  function decodeCodePointsArray (codePoints) {
    const len = codePoints.length
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    let res = ''
    let i = 0
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      )
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    let ret = ''
    end = Math.min(buf.length, end)

    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F)
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    let ret = ''
    end = Math.min(buf.length, end)

    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i])
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    const len = buf.length

    if (!start || start < 0) start = 0
    if (!end || end < 0 || end > len) end = len

    let out = ''
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]]
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    const bytes = buf.slice(start, end)
    let res = ''
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    const len = this.length
    start = ~~start
    end = end === undefined ? len : ~~end

    if (start < 0) {
      start += len
      if (start < 0) start = 0
    } else if (start > len) {
      start = len
    }

    if (end < 0) {
      end += len
      if (end < 0) end = 0
    } else if (end > len) {
      end = len
    }

    if (end < start) end = start

    const newBuf = this.subarray(start, end)
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype)

    return newBuf
  }

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUintLE =
  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    let val = this[offset]
    let mul = 1
    let i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }

    return val
  }

  Buffer.prototype.readUintBE =
  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length)
    }

    let val = this[offset + --byteLength]
    let mul = 1
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul
    }

    return val
  }

  Buffer.prototype.readUint8 =
  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    return this[offset]
  }

  Buffer.prototype.readUint16LE =
  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return this[offset] | (this[offset + 1] << 8)
  }

  Buffer.prototype.readUint16BE =
  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return (this[offset] << 8) | this[offset + 1]
  }

  Buffer.prototype.readUint32LE =
  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  }

  Buffer.prototype.readUint32BE =
  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  }

  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last = this[offset + 7]
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8)
    }

    const lo = first +
      this[++offset] * 2 ** 8 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 24

    const hi = this[++offset] +
      this[++offset] * 2 ** 8 +
      this[++offset] * 2 ** 16 +
      last * 2 ** 24

    return BigInt(lo) + (BigInt(hi) << BigInt(32))
  })

  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last = this[offset + 7]
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8)
    }

    const hi = first * 2 ** 24 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      this[++offset]

    const lo = this[++offset] * 2 ** 24 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      last

    return (BigInt(hi) << BigInt(32)) + BigInt(lo)
  })

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    let val = this[offset]
    let mul = 1
    let i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }
    mul *= 0x80

    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

    return val
  }

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    let i = byteLength
    let mul = 1
    let val = this[offset + --i]
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul
    }
    mul *= 0x80

    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

    return val
  }

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  }

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    const val = this[offset] | (this[offset + 1] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    const val = this[offset + 1] | (this[offset] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  }

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  }

  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last = this[offset + 7]
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8)
    }

    const val = this[offset + 4] +
      this[offset + 5] * 2 ** 8 +
      this[offset + 6] * 2 ** 16 +
      (last << 24) // Overflow

    return (BigInt(val) << BigInt(32)) +
      BigInt(first +
      this[++offset] * 2 ** 8 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 24)
  })

  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last = this[offset + 7]
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8)
    }

    const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      this[++offset]

    return (BigInt(val) << BigInt(32)) +
      BigInt(this[++offset] * 2 ** 24 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      last)
  })

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, true, 23, 4)
  }

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, false, 23, 4)
  }

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, true, 52, 8)
  }

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, false, 52, 8)
  }

  function checkInt (buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUintLE =
  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }

    let mul = 1
    let i = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeUintBE =
  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }

    let i = byteLength - 1
    let mul = 1
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeUint8 =
  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
    this[offset] = (value & 0xff)
    return offset + 1
  }

  Buffer.prototype.writeUint16LE =
  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    return offset + 2
  }

  Buffer.prototype.writeUint16BE =
  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
    return offset + 2
  }

  Buffer.prototype.writeUint32LE =
  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
    return offset + 4
  }

  Buffer.prototype.writeUint32BE =
  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
    return offset + 4
  }

  function wrtBigUInt64LE (buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7)

    let lo = Number(value & BigInt(0xffffffff))
    buf[offset++] = lo
    lo = lo >> 8
    buf[offset++] = lo
    lo = lo >> 8
    buf[offset++] = lo
    lo = lo >> 8
    buf[offset++] = lo
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
    buf[offset++] = hi
    hi = hi >> 8
    buf[offset++] = hi
    hi = hi >> 8
    buf[offset++] = hi
    hi = hi >> 8
    buf[offset++] = hi
    return offset
  }

  function wrtBigUInt64BE (buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7)

    let lo = Number(value & BigInt(0xffffffff))
    buf[offset + 7] = lo
    lo = lo >> 8
    buf[offset + 6] = lo
    lo = lo >> 8
    buf[offset + 5] = lo
    lo = lo >> 8
    buf[offset + 4] = lo
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
    buf[offset + 3] = hi
    hi = hi >> 8
    buf[offset + 2] = hi
    hi = hi >> 8
    buf[offset + 1] = hi
    hi = hi >> 8
    buf[offset] = hi
    return offset + 8
  }

  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  })

  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  })

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      const limit = Math.pow(2, (8 * byteLength) - 1)

      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }

    let i = 0
    let mul = 1
    let sub = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      const limit = Math.pow(2, (8 * byteLength) - 1)

      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }

    let i = byteLength - 1
    let mul = 1
    let sub = 0
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
    if (value < 0) value = 0xff + value + 1
    this[offset] = (value & 0xff)
    return offset + 1
  }

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    return offset + 2
  }

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
    return offset + 2
  }

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
    return offset + 4
  }

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    if (value < 0) value = 0xffffffff + value + 1
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
    return offset + 4
  }

  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  })

  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  })

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4)
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  }

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  }

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8)
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  }

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  }

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    if (!start) start = 0
    if (!end && end !== 0) end = this.length
    if (targetStart >= target.length) targetStart = target.length
    if (!targetStart) targetStart = 0
    if (end > 0 && end < start) end = start

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start
    }

    const len = end - start

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end)
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      )
    }

    return len
  }

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start
        start = 0
        end = this.length
      } else if (typeof end === 'string') {
        encoding = end
        end = this.length
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0)
        if ((encoding === 'utf8' && code < 128) ||
            encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255
    } else if (typeof val === 'boolean') {
      val = Number(val)
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0
    end = end === undefined ? this.length : end >>> 0

    if (!val) val = 0

    let i
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val
      }
    } else {
      const bytes = Buffer.isBuffer(val)
        ? val
        : Buffer.from(val, encoding)
      const len = bytes.length
      if (len === 0) {
        throw new TypeError('The value "' + val +
          '" is invalid for argument "value"')
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len]
      }
    }

    return this
  }

  // CUSTOM ERRORS
  // =============

  // Simplified versions from Node, changed for Buffer-only usage
  const errors = {}
  function E (sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor () {
        super()

        Object.defineProperty(this, 'message', {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        })

        // Add the error code to the name to include it in the stack trace.
        this.name = `${this.name} [${sym}]`
        // Access the stack to generate the error message including the error code
        // from the name.
        this.stack // eslint-disable-line no-unused-expressions
        // Reset the name to the actual name.
        delete this.name
      }

      get code () {
        return sym
      }

      set code (value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        })
      }

      toString () {
        return `${this.name} [${sym}]: ${this.message}`
      }
    }
  }

  E('ERR_BUFFER_OUT_OF_BOUNDS',
    function (name) {
      if (name) {
        return `${name} is outside of buffer bounds`
      }

      return 'Attempt to access memory outside buffer bounds'
    }, RangeError)
  E('ERR_INVALID_ARG_TYPE',
    function (name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`
    }, TypeError)
  E('ERR_OUT_OF_RANGE',
    function (str, range, input) {
      let msg = `The value of "${str}" is out of range.`
      let received = input
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input))
      } else if (typeof input === 'bigint') {
        received = String(input)
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received)
        }
        received += 'n'
      }
      msg += ` It must be ${range}. Received ${received}`
      return msg
    }, RangeError)

  function addNumericalSeparator (val) {
    let res = ''
    let i = val.length
    const start = val[0] === '-' ? 1 : 0
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`
    }
    return `${val.slice(0, i)}${res}`
  }

  // CHECK FUNCTIONS
  // ===============

  function checkBounds (buf, offset, byteLength) {
    validateNumber(offset, 'offset')
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
      boundsError(offset, buf.length - (byteLength + 1))
    }
  }

  function checkIntBI (value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
      const n = typeof min === 'bigint' ? 'n' : ''
      let range
      if (byteLength > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
        } else {
          range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                  `${(byteLength + 1) * 8 - 1}${n}`
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`
      }
      throw new errors.ERR_OUT_OF_RANGE('value', range, value)
    }
    checkBounds(buf, offset, byteLength)
  }

  function validateNumber (value, name) {
    if (typeof value !== 'number') {
      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
    }
  }

  function boundsError (value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type)
      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
    }

    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
    }

    throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                      `>= ${type ? 1 : 0} and <= ${length}`,
                                      value)
  }

  // HELPER FUNCTIONS
  // ================

  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

  function base64clean (str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0]
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '')
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '='
    }
    return str
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity
    let codePoint
    const length = string.length
    let leadSurrogate = null
    const bytes = []

    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i)

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          }

          // valid lead
          leadSurrogate = codePoint

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      }

      leadSurrogate = null

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint)
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    const byteArray = []
    for (let i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF)
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    let c, hi, lo
    const byteArray = []
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i)
      hi = c >> 8
      lo = c % 256
      byteArray.push(lo)
      byteArray.push(hi)
    }

    return byteArray
  }

  function base64ToBytes (str) {
    return base64.toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    let i
    for (i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i]
    }
    return i
  }

  // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166
  function isInstance (obj, type) {
    return obj instanceof type ||
      (obj != null && obj.constructor != null && obj.constructor.name != null &&
        obj.constructor.name === type.name)
  }
  function numberIsNaN (obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
  }

  // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219
  const hexSliceLookupTable = (function () {
    const alphabet = '0123456789abcdef'
    const table = new Array(256)
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j]
      }
    }
    return table
  })()

  // Return not function with Error if BigInt not supported
  function defineBigIntMethod (fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
  }

  function BufferBigIntNotDefined () {
    throw new Error('BigInt not supported')
  }
}
BufferArray.init();

</script>
    <script type="text/javascript" charset="utf-8">/*
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     1-1-21 by sbosse.
 **    $VERSION:     1.3.2
 **
 **    $INFO:
 **
 ** Static Typed Buffer Objects 
 ** JS Objects are stored and serialized in generic buffers (arrays) 
 ** Buffer objects are accessed transparently by object monitors 
 ** perforiming buffer serialization and deserialization.
 ** Supported types: core (number, string, boolean), records, arrays, typed arrays
 **
 **    $ENDOFINFO
*/

BufferObjects={}
BufferObjects.init = function(module) {
  var version='1.3.3'
  if (typeof BufferObjects=='undefined') BufferObjects={};
  var NULL = -1
  //////////////////// BUFFER SEGMENT OBJECT MEMORY ////////////////////
  function SizeOf(typOrObj,types,parameter) {
    if (typeof typOrObj == 'object' && typOrObj.__size) return typOrObj.__size;
    var typ = typOrObj;
    var eltyp  = typ.match(/([^\[\*]+)/)[1],
        length  = typ.match(/\[([^\]]*)\]/),  // array length if any
        pointer = typ.indexOf('*')!=-1;
    if (length) {
      length=length[1];
      if (parameter) for(var p in parameter) length=length.replace(p,parameter[p]);
      length=Number(length);
    } else length=1;
    if (pointer) return 4*length;
    eltyp=eltyp.trim();
    if (parameter && parameter[eltyp]) eltyp=parameter[eltyp];
    switch (eltyp) {
      case 'char' : return length;
      case 'int'  : return 4*length;
      case 'int32' : return 4*length;
      case 'void' : return 4*length;
      case 'float': return 4*length;
      case 'float32' : return 4*length;
      case 'double': return 8*length;
      case 'float64' : return 8*length;
      default     : if (types && types[eltyp]) return length*types[eltyp].size();
    }
  }
  function TypeOf(typ,parameter) {
    var eltyp = typ.match(/([^\[\*]+)/)[1],
        length  = typ.match(/\[([^\]]*)\]/),  // array length if any
        pointer = typ.indexOf('*')!=-1,
        array = false,
        size0,
        size; // total size of this type
    if (length) {
      length=length[1];
      if (parameter) for(var p in parameter) length=length.replace(p,parameter[p]);
      length=Number(length);
      array=true;
    } else length=1;
    eltyp=eltyp.trim();
    if (parameter && parameter[eltyp]) eltyp=parameter[eltyp];
    switch (eltyp) {
      case 'char' :  size0=1; size = 1*length ; break;
      case 'int'  :  size0=4; size = 4*length ; break;
      case 'void' :  size0=4; size = 4*length ; break;
      case 'float':  size0=4; size = 4*length ; break;
      case 'float32':  size0=4; size = 4*length ; break;
      case 'double':  size0=8; size = 8*length ; break;
      case 'float64':  size0=8; size = 8*length ; break;
    }
    if (pointer) { size0=4; size=4 };
    return { typ : eltyp, length:length, size : size, size0:size0, pointer:pointer, array:array }
  }
  function TypeIf(o) {
    if (Utils.isArray(o)) {
      return 
    }
    if (Utils.isString(o)) return 'char[]';
    if (Utils.isNumber(o)) return 'float';
    if (Utils.isObject(o)) {
      var ti={}
      for(var k in o) {
        ti[k]=TypeIf(o[k]);
      }
      return ti
    }
  }
  // Structure Type Object constructor
  function StructType(desc,name,types) {
    var typConstr = function (buf,addr,parameter,segment) {
      var bo = {}, offset=0;
      for(var key in desc) {
        var dt = TypeOf(desc[key],parameter);
        // console.log(key,dt)
        switch (dt.typ) {
          case 'int':
            if (!dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readInt32LE(addr+offset);
                },
                set(value) {
                  buf.writeInt32LE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'float':
            if (!dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readFloatLE(addr+offset);
                },
                set(value) {
                  buf.writeFloatLE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'void':      
            if (dt-pointer && !dt.array) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return buf.readInt32LE(addr+offset);
                },
                set(value) {
                  buf.writeInt32LE(value,addr+offset);
                }
              })})(offset);
              offset += dt.size;
            } else {
              bo[key]=ArrayType(dt.typ)(buf,addr+offset,dt.length);
              offset += dt.size;
            }
            break;
          case 'char':
            if (dt.array) {
              (function (offset,size) { Object.defineProperty(bo, key, {
                get() {
                  var end = buf.indexOf(0,addr+offset);
                  return buf.slice(addr+offset,end).toString('utf8');
                },
                set(value) {
                  Buffer(value).copy(buf,addr+offset);
                }
              })})(offset,dt.size);
              offset += dt.size;
            } else if (!dt.pointer) {
              (function (offset) { Object.defineProperty(bo, key, {
                get() {
                  return String.fromCharCode(buf[addr+offset]);
                },
                set(value) {
                  buf[addr+offset]=value.charCodeAt(0);
                }
              })})(offset);
              offset += dt.size;          
            }
            break;
          default:
            // console.log(dt);
            if (dt.pointer && !dt.array) {
               (function (offset,size,dt) { 
                  var typcon;
                  if (dt.typ==name) typcon=typConstr;
                  else if (types) typcon=types[dt.type];
                  if (!typcon) throw "typConstr: Unknown type "+dt.typ;
                  bo['_'+key]=NULL; // shadow pointer
                  var b2o,addr;
                  Object.defineProperty(bo, key, {
                  get() {
                    if (bo['_'+key]!=NULL){
                      if (!b2o || bo['_'+key]!=addr) {
                        addr=bo['_'+key];
                        b2o=typConstr(buf,addr);  // cache wrapper
                      }
                      return b2o;
                    } else throw "typConstr: NULL pointer ("+name+"."+key+")"
                  },
                  set(ref) {
                    if (typeof ref=='number') bo['_'+key]=ref;
                    if (typeof ref=='object' && ref.__address) bo['_'+key]=ref.__address;                  
                  }
                })})(offset,dt.size,dt);
                offset += dt.size;
            } else if (!dt.pointer && dt.array) {
              if (types[dt.typ]) {
              console.log(types[dt.typ])
                bo[key]=ArrayType(types[dt.typ].desc)(buf,addr+offset,dt.length);
                offset += dt.size; 
              } else throw "StructType: unknown struct type "+dt.typ;         
            }
            break;    
        }
      }
      bo.__address=addr; bo.__size=offset; bo.__desc=desc; bo.__parameter=parameter; bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.StructType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.StructType.deserialize(objdesc)}};
      }
      bo.__class='Struct';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      var dataSize=0;
      for(var key in desc) dataSize += SizeOf(desc[key],types,parameter);
      return dataSize;
    }
    typConstr.name;
    typConstr.class='Struct';
    typConstr.desc=desc;
    return typConstr;
  }
  StructType.cache=[];
  // create a share of an object //
  
  // 1. Serialize a buffer object
  StructType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  StructType.deserialize = function (buffer,share) {
    // TODO types mapping
    // TODO struct caching
    if (!share) { 
     share=buffer; 
     var sms=BufferSegments[share.segment]; 
     if (sms) buffer=sms.buffer;
   };
    if (!buffer) throw "StructType.deserialize: no buffer segment specified";
    
    var st = StructType(share.struct,share.type,share.types);
    return st(buffer,share.address,share.parameter,share.segment);
  }


  // Array Type Object constructor
  function ArrayType(desc,name,types) {
    var size1=0,computeSize;
    var typConstr = function (buf,addr,length,parameter,segment) {
      var bo = {}, size=0, internal={};
      switch (desc) {
        case 'char':
          size=1;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return String.fromCharCode(buf[addr+index*size]);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf[addr+index*size]=val.charCodeAt(0);
            },
          });
          break;
        case 'int':
        case 'int32':
        case 'void':
          size=4;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.readInt32LE(addr+index*size);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.writeInt32LE(val,addr+index*size);
            }
          });
          break;
        case 'float':
        case 'float32':
          size=4;
          bo = new Proxy([],{
            get : function (target,name) {
              if (typeof name == 'symbol' || isNaN(Number(name))) {
                switch (name) {
                  case 'length':
                    return internal.__length;
                  default: return internal[name];
                }
              };
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.readFloatLE(addr+index*size);
            },
            set : function (target,name,val) {
              if (typeof name == 'symbol' || isNaN(Number(name))) return;
              var index=Number(name); if (length && index>length-1) throw "Array index out of bound";
              return buf.writeFloatLE(val,addr+index*size);
            }
          });
          break;
        default:
          // structure type?
          if (typeof desc == 'string') {
            // find structure descriptor
            desc = types && types[desc];
          }
          if (!desc) throw ("BufferObjects.ArrayType: Cannot resolve type "+desc);
          size=0;
          if (typeof desc == 'function') size = desc.size(parameter);
          else for(var key in desc) size += SizeOf(desc[key],parameter);
          // console.log(length,parameter,size,desc)
          if (isNaN(size)) throw ("BufferObjects.ArrayType: computed size of struct is invalid ("+name+")");
          if (!(typeof desc == 'function')) {
            // we have to create a structure object each time an array element is dereferenced!
            // but caching and remembering the last access struct object wrapper
            var st = StructType(desc);
            var cache=[];
            bo = new Proxy([],{
              get : function (target,name) {
                if (typeof name == 'symbol' || isNaN(Number(name))) {
                  switch (name) {
                    case 'length':
                      return internal.__length;
                    default: return internal[name];
                  }
                };
                var index=Number(name),offset=0,ro={};
                if (length && index>length-1) throw "BufferObjects.ArrayType.get: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              },
              set : function (target,name,val) {
                if (typeof name == 'symbol' || isNaN(Number(name))) return;
                // val must be entire updated struct (for copy)
                var index=Number(name),ro={};  // requires getters and setters
                if (length && index>length-1) throw "BufferObjects.ArrayType.set: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              }
            });                  
          } else {
            var cache=[];
            var st = desc;
               
            bo = new Proxy([],{
              get : function (target,name) {
                if (typeof name == 'symbol' || isNaN(Number(name))) {
                  switch (name) {
                    case 'length':
                      return internal.__length;
                    default: return internal[name];
                  }
                };
                var index=Number(name),offset=0,ro={};
                if (length && index>length-1) throw "BufferObjects.ArrayType.get: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              },
              set : function (target,name,val) {
                if (typeof name == 'symbol' || isNaN(Number(name))) return;
                // val must be entire updated struct (for copy)
                var index=Number(name),ro={};  // requires getters and setters
                if (length && index>length-1) throw "BufferObjects.ArrayType.set: index out of bound";
                // TODO atomic objects (int,...)
                if (!cache[index]) {
                  cache[index]=st(buf,addr+index*size);
                  return cache[index]
                } else return cache[index]
              }
            });                  
          }
          break;
      }
      // We can't attach the attributes to bo due to the Proxy wrapper
      internal.__address=addr; 
      internal.__size=size*length; 
      internal.__desc=typeof desc == 'function'?desc.desc:desc; 
      internal.__parameter=parameter; internal.__type=name;
      internal.__segment=segment; bo.__class='Array';
      internal.__length = length;
      internal.__share  = function () {
        /* TODO */
        return {data:BufferObjects.ArrayType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.ArrayType.deserialize(objdesc)}};
      }
      size1=size;
      return bo;
    }
    computeSize=false;
    typConstr.size=function (parameter) {
      if (!computeSize) {
        computeSize=true;
        typConstr({},0,0);
      }
      return size1;
    };
    typConstr.class='Array';
    typConstr.name=name;
    typConstr.desc=desc;  
    return typConstr;  
  }
  // 1. Serialize a buffer object
  ArrayType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment, length:bo.__length } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  ArrayType.deserialize = function (buffer,share) {
    // TODO types mapping
    // TODO struct caching
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "ArrayType.deserialize: no buffer segment specified";
    
    var st = ArrayType(share.struct,share.type,share.types);
    return st(buffer,share.address,share.parameter,share.segment);
  }

  // Matrix Type Object constructor
  // desc=='Float32'|...
  function MatrixType(desc,name) {
    var size1=0;
    var datatype = 'Float32';
    var typConstr = function (buf,addr,length,parameter,segment) {
      var bytesize;
      var bo=Math.MatrixTA({data:function (size) {
        bytesize=size;
        return buf.buffer
      },rows:length[0],columns:length[1],datatype:datatype,offset:addr})
      // length must be a dataspace array
      bo.__address=addr; 
      bo.__size=bytesize; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__length = length;
      bo.__share=function () {
        return {data:BufferObjects.MatrixType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.MatrixType.deserialize(objdesc)}};
      }
      bo.__class='Struct';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 4
    }
    typConstr.name=name;
    typConstr.class='MatrixTA';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  MatrixType.serialize = function (bo) {
    // TODO types descriptor mapping
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, 
             parameter: bo.__parameter, segment:bo.__segment, length:bo.__length } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  MatrixType.deserialize = function (buffer,share) {
    if (!share) { 
     share=buffer; 
     var sms=BufferSegments[share.segment]; 
     if (sms) buffer=sms.buffer;
   };
    if (!buffer) throw "MatrixType.deserialize: no buffer segment specified";
    
    var st = MatrixType(share.struct,share.type);
    return st(buffer,share.address,share.length,share.segment);
  }


  function BarrierType(desc,name,N,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.barrier?Code.barrier.shared:Barrier)(buf.buffer,N,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.BarrierType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.BarrierType.deserialize(objdesc)}};
      }
      bo.__class='Barrier';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Barrier';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  BarrierType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type,  id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  BarrierType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "BarrierType.deserialize: no buffer segment specified";
    
    var st = BarrierType(share.struct,share.type,null,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }


  function MutexType(desc,name,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.mutex?Code.mutex.shared:Mutex)(buf.buffer,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.MutexType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.MutexType.deserialize(objdesc)}};
      }
      bo.__class='Mutex';
      return bo;
    }
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Mutex';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  MutexType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  MutexType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "SemaType.deserialize: no buffer segment specified";
    
    var st = MutexType(share.struct,share.type,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }
 
 
  function SemaType(desc,name,init,id) {
    var size1=1;
    var typConstr = function (buf,addr,parameter,segment) {
      var bytesize;
      var bo=(Code.semaphore?Code.semaphore.shared:Semaphore)(buf.buffer,init,addr,id);
      bo.__address=addr; 
      bo.__size=16; 
      bo.__desc=desc; 
      bo.__parameter=parameter; 
      bo.__type=name;
      bo.__segment=segment;
      bo.__share=function () {
        return {data:BufferObjects.SemaType.serialize(bo), /* original array buffer object */
                eval:function (objdesc) { return BufferObjects.SemaType.deserialize(objdesc)}};
      }
      bo.__class='Semaphore';
      return bo;
    }
    // optionally parameterised size computation int [N] => {N:8} ...
    typConstr.size=function (parameter) {
      // todo
      return 16
    }
    typConstr.name=name;
    typConstr.class='Semaphore';
    typConstr.desc=desc;
    return typConstr;  

  }
  // 1. Serialize a buffer object
  SemaType.serialize = function (bo) {
    return { address: bo.__address, size:bo.__size, struct:bo.__desc, type: bo.__type, id:bo.__id,
             parameter: bo.__parameter, segment:bo.__segment } 
  }
  // 2. Deserialize a buffer object (create the share in a buffer)
  SemaType.deserialize = function (buffer,share) {
    if (!share) { 
      share=buffer; 
      var sms=BufferSegments[share.segment]; 
      if (sms) buffer=sms.buffer;
    };
    if (!buffer) throw "SemaType.deserialize: no buffer segment specified";
    
    var st = SemaType(share.struct,share.type,null,share.id);
    return st(buffer,share.address,share.parameter,share.segment);
  }
  
  // Generic buffer type support (can by typed arrays, too)
  // In contrast to arrays always shared buffer (array), i.e., a slice of segment buffer
  // Returns a block descriptor
  function BufferType () {
    function typConstr(buf,addr,length,datatype,segment) {
      // we can only slice (sharing) the main segment buffer with typearrays!
      console.log('BufferType',addr,length,datatype);
      return {
        data  : new Utils.TypedArrayOfName[datatype+'Array'](buf.buffer,addr /* bytes! */ ,length /* # elements */ ),
        addr  : addr,
        size  : length,
        datatype : datatype,
        segment : segment,
      }
    };
    typConstr.size = function (elements,datatype) {
      datatype=datatype||'Uint8';
      return elements*Utils.DataSize[datatype];
    }
    typConstr.class = 'Buffer';
    typConstr.name = 'buffer';
    return typConstr;
  }
  
  function AddrOf (bo) {
    return bo.__address
  }
  
  function Library (types) {
    var compiled={}
    for(var t in types) {
      // Type descriptor to be compiled
      if (!Utils.isArray(types[t])) compiled[t]=StructType(types[t],t,compiled);
      else compiled[t]=ArrayType(types[t][0],t,compiled);
    }
    return compiled;
  }
  Object.assign(BufferObjects ,{
    AddrOf  : AddrOf,
    SizeOf  : SizeOf,
    TypeOf  : TypeOf,
    TypeIf  : TypeIf,
    StructType  : StructType,
    ArrayType   : ArrayType,
    MatrixType  : MatrixType,
    BufferType  : BufferType,
    BarrierType : BarrierType,
    MutexType   : MutexType,
    SemaType    : SemaType,
    Library : Library,
    version : version
  }) 
  if (module!=undefined)
    module.exports = {
      AddrOf:AddrOf,
      SizeOf:SizeOf,
      TypeOf:TypeOf,
      TypeIf:TypeIf,
      StructType  : StructType,
      ArrayType   : ArrayType,
      MatrixType  : MatrixType,
      BufferType  : BufferType,
      BarrierType : BarrierType,
      MutexType   : MutexType,
      SemaType    : SemaType,
      Library : Library,
      version : version
    }   
}
BufferObjects.init()


</script>
    <script type="text/javascript" charset="utf-8">/*
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-21 by sbosse.
 **    $VERSION:     1.3.2
 **
 **    $INFO:
 **
 ** Allocated Memory Segments for Buffer Objects (see bufferObjects module)
 ** with alloc/free block management and free block compaction
 ** Can use Buffer, Array, Uint8Array, SharedArrayBuffer, ArrayBuffer for backing store.
 **
 ** Examples:
 **
 ** shared = new SharedArrayBuffer(100E3);
 ** sm = BufferSegment(this.shared,{key:'shm1'});
 ** sm.create();
 ** 
 ** sm.library({xy:{x:'int',y:'int'}});
 **
 ** Code.worker.share(this.worker,'sm',sm);
 **
 **    $ENDOFINFO
*/

BufferSegment = {}
BufferSegment.init = function () {
  if (typeof BufferSegment=='undefined') BufferSegment={};
  
  var Options = {
    version : '1.3.2',
    verbose : 0
  }


  var NULL      = -1
  // null terminated strings
  function str2buf(str) {
    var buf = Buffer(str.length+1);
    Buffer(str).copy(buf)
    buf[str.length]=0;
    return buf
  }

  var AddrOf=BufferObjects.AddrOf,
      SizeOf=BufferObjects.SizeOf,
      TypeOf=BufferObjects.TypeOf,
      TypeIf=BufferObjects.TypeIf,
      StructType=BufferObjects.StructType,
      BufferType=BufferObjects.BufferType,
      Library=BufferObjects.Library,
      ArrayType=BufferObjects.ArrayType,
      MatrixType=BufferObjects.MatrixType,
      SemaType=BufferObjects.SemaType,
      MutexType=BufferObjects.MutexType,
      BarrierType=BufferObjects.BarrierType;
      

  //////////////// Shared Memory Segment ///////////////////////
  /// typeof @buffer = Buffer | Uint8Array | BufferArray 
  // workshell: size,options
  function sms(buffer,options) {
    var size;
    // key=='<buffer>' -> using JS buffer instead of C memory; not sharable
    if (!(this instanceof sms)) return new sms(buffer,options);
    if (typeof buffer == 'number') {
      size   = buffer;
      buffer = new SharedArrayBuffer(size);
    }
    this._buffer=buffer;
    if ((buffer instanceof SharedArrayBuffer) ||
        (buffer instanceof ArrayBuffer)) buffer=BufferArray.Buffer(buffer);
    options=options||{}
    this.options=options;
    this.verbose=options.verbose||0;
    this.key=options.key||('/shm'+Utils.uniqueID(8));
    this.base=0;
    this.buffer=buffer;
    this.allocasize=options.freelistSize||512;
    this.size=buffer.length;
    this.top=this.size-this.allocasize;
    // register segment globally
    BufferSegments[this.key]=this;
  }


  // tinyalloc
  sms.prototype.alloc = function (size) {
    var bprt,bprev,
        ptr  = this.alloca.heap.free,
        prev = NULL,
        num  = size,
        top  = this.alloca.heap.top;
    num = (num + this.alloca.alignment - 1) & -this.alloca.alignment;
    while (ptr != NULL) {
        bptr=this.alloca.blocks[ptr];
        var is_top = (bptr.addr + bptr.size >= top) && (bptr.addr + num <= this.alloca.heap.limit);
        if (is_top || bptr.size >= num) {
            if (prev != NULL) {
                bprev=this.alloca.blocks[prev];
                bprev.next = bptr.next;
            } else {
                this.alloca.heap.free = bptr.next;
            }
            bptr.next  = this.alloca.heap.used;
            this.alloca.heap.used = ptr;
            if (is_top) {
                // console.log("resize top block");
                bptr.size = num;
                this.alloca.heap.top = bptr.addr + num;
            } else if (!this.alloca.disable_split && this.alloca.heap.fresh != NULL) {
                var excess = bptr.size - num;
                if (excess >= this.alloca.heap.split_thresh) {
                    blocksize    = num;
                    var split = this.alloca.heap.fresh,
                        bsplit = this.alloca.blocks[split];
                    this.alloca.heap.fresh  = bsplit.next;
                    bsplit.addr  = bptr.addr + num;
                    // console.log("split");
                    // console.log(bsplit.addr);
                    bsplit.size = excess;
                    this.insert_block(split,bsplit);
                    if (!this.alloca.disable_compact) this.compact();
                }
            }
            return bptr.addr;
        }
        prev = ptr;
        ptr  = bptr.next;
    }
    // no matching free blocks
    // see if any other blocks available
    var new_top = top + num;
    if (this.alloca.heap.fresh != NULL && new_top <= this.alloca.limit) {
        ptr         = this.alloca.heap.fresh;
        bptr        = this.alloca.blocks[ptr];
        this.alloca.heap.fresh  = bptr.next;
        bptr.addr   = top;
        bptr.next   = this.alloca.heap.used;
        bptr.size   = num;
        this.alloca.heap.used  = ptr;
        this.alloca.heap.top   = new_top;
        return bptr.addr;
    }
    return NULL;
  }

  sms.prototype.calloc = function (size) {
    var addr=this.alloc(size);
    if (addr) this.buffer.fill(0,addr,addr+size);
    return addr
  }

  // compact heap block list (tinyalloc)
  sms.prototype.compact = function () {
    var bptr,bprev,bscan,
        ptr = this.alloca.heap.free,
        prev, scan;

    while (ptr != NULL) {
        bptr = this.alloca.blocks[ptr];
        prev = ptr;
        bprev = bptr;
        scan = bptr.next;
        bscan = this.alloca.blocks[scan];
        while (scan != NULL &&
               bprev.addr + bprev.size == bscan.addr) {
            // print_s("merge");
            // print_i((size_t)scan);
            prev = scan;
            scan = bscan.next;
        }
        if (prev != ptr) {
            var new_size =
                bprev.addr - bptr.addr + bprev.size;
            // print_s("new size");
            // print_i(new_size);
            bptr.size   = new_size;
            var next = bprev.next;
            // make merged blocks available
            this.release_blocks(bptr.next, bprev.next);
            // relink
            bptr.next = next;
        }
        ptr = bptr.next;
    }
  }
  // Create and open shared memory segment (or create a non-shareable buffer insteda, key=='<buffer>')
  sms.prototype.create = function () {
    /////////////// tinyalloc block management //////////////
    var blocks = ArrayType({
      addr:'int',
      next:'int',
      size:'int',
    });
    var heapControl = StructType({
      free:'int',
      used:'int',
      fresh:'int',
      top:'int'
    })
    var heap_blocks = Math.floor((this.allocasize-heapControl.size())/(SizeOf('int')*3));
    //// block lists at beginning of segment!!! ////
    this.alloca = {
      blocks : blocks(this.buffer,heapControl.size(),heap_blocks),
      heap   : heapControl(this.buffer,0),
      base   : 0,
      limit  : this.top+this.allocasize,
      max_blocks : heap_blocks-1,
      split_thresh : 16,
      alignment : 4,
      disable_compact : false,
      disable_split   : false, 
    }
    if (Options.verbose)
      Code.print('[SM '+this.key+'] Created shared segment ('+this.allocasize+'/'+this.size+') with blocks',heap_blocks,'heap_max_blocks',this.alloca.max_blocks);
    this.alloca.heap.free=NULL;
    this.alloca.heap.used=NULL;  
    this.alloca.heap.fresh=1;
    this.alloca.heap.top=this.allocasize;
    
    var i = this.alloca.heap.fresh; 
    while (i<heap_blocks-1) {
      var block = this.alloca.blocks[i];
      block.next = i + 1;
      i++;
    }
    this.alloca.blocks[i].next=NULL;
    
    ///////////////////////////////////////////////////////
    
  }
  
  sms.prototype.destroy = function () {
    delete BufferSegments[this.key];
  }

  // Returns (free) a memory block. Free is either the block address or a buffer object
  // with an __address attribute.
  sms.prototype.free = function (free) {
    if (typeof free == 'object' && free.__address) free=free.__address;
    else if (typeof free != 'number') throw "free: argument must be an address number";
    var bblock,block = this.alloca.heap.used;
    var bprev,prev  = NULL;
    while (block != NULL) {
        bblock=this.alloca.blocks[block];
        if (free == bblock.addr) {
            if (prev != NULL) {
                bprev=this.alloca.blocks[prev];
                bprev.next = bblock.next;
            } else {
                this.alloca.heap.used = bblock.next;
            }
            this.insert_block(block);
            if (!this.alloca.disable_compact) this.compact();
            return true;
        }
        prev  = block;
        block = bblock.next;
    }
    return false;
  }

  sms.prototype.info = function () {
    return { fd : this.fd, size : this.size, top: this.top }
  }

  // insert a block (tinyalloc)
  sms.prototype.insert_block = function (block,bblock) {
    if (!bblock) bblock = this.alloca.blocks[block];
    if (!this.alloca.disable_compact) {
      var bptr, ptr  = this.alloca.heap.free;
      var bprev, prev = NULL;
      while (ptr != NULL) {
          bptr = this.alloca.blocks[ptr];
          if (bblock.addr <= bptr.addr) {
              // print_s("insert");
              // print_i((size_t)ptr);
              break;
          }
          prev = ptr;
          ptr  = bptr.next;
      }
      if (prev != NULL) {
          bprev = this.alloca.blocks[prev];
          if (ptr == NULL) {
              // print_s("new tail");
          }
          bprev.next = block;
      } else {
          // print_s("new head");
          this.alloca.heap.free = block;
      }
      bblock.next = ptr;
    } else {
      bblock.next = this.alloca.heap.free;
      this.alloca.heap.free  = block;
    }
  }
  // compile and attach type constructor library
  sms.prototype.library = function (types) {
    this.typesDef=types;
    this.types=Library(types);
    return this.types;
  }
  
  // Map already created shared memory segment
  sms.prototype.map = function () {
    /////////////// tinyalloc block management //////////////
    var blocks = ArrayType({
      addr:'int',
      next:'int',
      size:'int',
    });
    var heapControl = StructType({
      free:'int',
      used:'int',
      fresh:'int',
      top:'int'
    })
    var heap_blocks = Math.floor((this.allocasize-heapControl.size())/(SizeOf('int')*3));
    //// block lists at beginning of segment!!! ////
    this.alloca = {
      blocks : blocks(this.buffer,heapControl.size(),heap_blocks),
      heap   : heapControl(this.buffer,0),
      base   : 0,
      limit  : this.top+this.allocasize,
      max_blocks : heap_blocks-1,
      split_thresh : 16,
      alignment : 4,
      disable_compact : false,
      disable_split   : false, 
    }
    if (Options.verbose)
      console.log('[SM '+this.key+'] Mapped shared segment ('+this.allocasize+'/'+this.size+') with blocks',heap_blocks,'heap_max_blocks',this.alloca.max_blocks);
  }

  // allocate or share an object (scalar, struct, array)
  sms.prototype.object = function (typcon,elements,address,parameter) {
    var _typcon=typcon,_elements=elements;
    if (typeof typcon == 'string') {
      if (/Array$/.test(typcon)) {
        // typed arary
        parameter=typcon.replace('Array','');
        typcon=BufferType();
      } else if (/^MatrixTA\-/.test(typcon)) {
        typcon=MatrixType(typcon.replace('MatrixTA-',''),typcon)
        elements=elements.prod();
      } else if (typcon=='Semaphore') {
        typcon=SemaType('semaphore','semaphore',elements);
        elements=1;
      } else if (typcon=='Barrier') {
        typcon=BarrierType('barrier','barrier',elements);
        elements=1;
      } else if (typcon=='Mutex') {
        typcon=MutexType('mutex','mutex');
        elements=1;
      } else if (this.types) {
        if (!this.types[typcon]) throw Error('sms.object: unknown type '+typcon);
        typcon=this.types[typcon];
      }
    }
    
    if (typeof elements == 'object' && !Utils.isArray(elements)) { parameter=elements; elements=1; }
    if (typeof elements == 'boolean') { address=elements; elements=1; }
    if (typeof elements == 'undefined') elements=1; 
    if (typeof typcon != 'function') throw Error('BufferSegment.sms.object: First argument must be a valid type constructor function');
    var size1 = typcon.size(parameter);
    if (size1==0) throw Error('BufferSegment.sms.object('+_typcon+'): Zero object/element size!');
    if (isNaN(elements)) throw Error('BufferSegment.sms.object('+_typcon+'): Invalid elements parameter!');
    if (typeof address=='undefined') address = this.calloc(size1*elements);

    if (Options.verbose) console.log('sm.object:',address,size1,elements,parameter)
    
    var obj;
    switch (typcon.class) {
      case 'Array':
      case 'MatrixTA':
        return typcon(this.buffer,address,_elements,null,this.key);
      case 'Buffer':
        var block=typcon(this.buffer,address,elements,parameter,this.key); // returns a block {addr,size,data}
        block.segment=this.key;
        return block;
      case 'Mutex':
      case 'Semaphore':
      case 'Barrier':
        return typcon(this.buffer,address,null,this.key)
      default:
        return typcon(this.buffer,address,null,this.key)
    }
  }


  sms.prototype.release_blocks = function (scan, to) {
    var bscan = this.alloca.blocks[scan], 
        bto = this.alloca.blocks[to],
        bscan_next, scan_next;
    while (scan != to) {
        // print_s("release");
        // print_i((size_t)scan);
        scan_next   = bscan.next;
        bscan_next  = this.alloca.blocks[scan_next];
        bscan.next  = this.alloca.heap.fresh;
        this.alloca.heap.fresh = scan;
        bscan.addr  = 0;
        bscan.size  = 0;
        scan        = scan_next;
    }
  }
  sms.prototype.__share = function () {
    // return an expression that can be evaluated in a remote process to create a share of this segment
    // by the shared buffer data passed to the evaluation function 'argument'
    return {data:{buffer:this._buffer,size:this.size,types:this.typesDef,key:this.key}, /* original array buffer object */
            eval:function (data) { var sms=BufferSegment(data.buffer,{key:data.key}); sms.library(data.types); return sms; }};
  }
  sms.prototype.stats = function () {
    var self=this;
    function count_blocks(ptr) {
      var bptr, num = 0;
      while (ptr != NULL) {
          num++;
          bptr = self.alloca.blocks[ptr];
          ptr = bptr.next;
      }
      return num;
    }
    return {
      free  : this.alloca.heap.free,
      used  : this.alloca.heap.used,
      fresh : this.alloca.heap.fresh,
      nfree : count_blocks(this.alloca.heap.free),
      nused : count_blocks(this.alloca.heap.used),
      nfresh : count_blocks(this.alloca.heap.fresh),
      ntotal : this.alloca.max_blocks,
    }
  }
  sms.version = Options.version;

  //////////////////////////////////////////////////////////////////
  var init = BufferSegment.init;
  BufferSegment = sms;
  BufferSegment.AddrOf = AddrOf;
  BufferSegment.SizeOf = SizeOf;
  BufferSegment.TypeOf = TypeOf;
  BufferSegment.TypeIf = TypeIf;
  BufferSegment.StructType = StructType;
  BufferSegment.ArrayType = ArrayType;
  BufferSegment.BufferType = BufferType;
  BufferSegment.MatrixType = MatrixType;
  BufferSegment.SemaType = SemaType;
  BufferSegment.BarrierType = BarrierType;
  BufferSegment.MutexType = MutexType;
  BufferSegment.options = Options;
  BufferSegment.init = init;

  BufferSegment.object = function (segment,typcon,elements,address,parameter) {
    var sm = BufferSegments[segment];
    if (!sm) return Code.error('BufferSegment.object: unknown segment '+segment);
    return sm.object(typcon,elements,address,parameter);
  };
  
  BufferSegments = {}
}
BufferSegment.init()

</script>
    <script type="text/javascript" charset="utf-8">/**
*  Minimal jquery-ui core framework
*/

(function ($) {
$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";

/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;

/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );

/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}


function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

})(jQuery)

</script>
    <script type="text/javascript" charset="utf-8">(function ($) {

/*!
 * jQuery UI Tooltip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tooltip
//>>group: Widgets
//>>description: Shows additional information for any element on hover or focus.
//>>docs: http://api.jqueryui.com/tooltip/
//>>demos: http://jqueryui.com/tooltip/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tooltip.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tooltip", {
	version: "1.12.1",
	options: {
		classes: {
			"ui-tooltip": "ui-corner-all ui-widget-shadow"
		},
		content: function() {

			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";

			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,

		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		track: false,

		// Callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on( {
			mouseover: "open",
			focusin: "open"
		} );

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};

		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr( {
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			} )
			.appendTo( this.document[ 0 ].body );
		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		this.disabledTitles = $( [] );
	},

	_setOption: function( key, value ) {
		var that = this;

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, tooltipData ) {
				that._updateContent( tooltipData.element );
			} );
		}
	},

	_setOptionDisabled: function( value ) {
		this[ value ? "_disable" : "_enable" ]();
	},

	_disable: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = tooltipData.element[ 0 ];
			that.close( event, true );
		} );

		// Remove title attributes to prevent native tooltips
		this.disabledTitles = this.disabledTitles.add(
			this.element.find( this.options.items ).addBack()
				.filter( function() {
					var element = $( this );
					if ( element.is( "[title]" ) ) {
						return element
							.data( "ui-tooltip-title", element.attr( "title" ) )
							.removeAttr( "title" );
					}
				} )
		);
	},

	_enable: function() {

		// restore title attributes
		this.disabledTitles.each( function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		} );
		this.disabledTitles = $( [] );
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )

				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// Kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each( function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			} );
		}

		this._registerCloseHandlers( event, target );
		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" || contentOption.nodeType ||
				contentOption.jquery ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[ 0 ], function( response ) {

			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay( function() {

				// Ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}

				// JQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			} );
		} );
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltipData, tooltip, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltipData = this._find( target );
		if ( tooltipData ) {
			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// If we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltipData = this._tooltip( target );
		tooltip = tooltipData.tooltip;
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
		a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
		a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		a11yContent.appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			} );

			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend( {
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );

		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		// Adds the check to add the timers only when both delay and track options are set (#14682)
		if ( this.options.track && this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval( function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );
	},

	_registerCloseHandlers: function( event, target ) {
		var events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event( event );
					fakeEvent.currentTarget = target[ 0 ];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( this._find( target ).tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var tooltip,
			that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltipData = this._find( target );

		// The tooltip may already be closed
		if ( !tooltipData ) {

			// We set ui-tooltip-open immediately upon open (in open()), but only set the
			// additional data once there's actually content to show (in _open()). So even if the
			// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
			// the period between open() and _open().
			target.removeData( "ui-tooltip-open" );
			return;
		}

		tooltip = tooltipData.tooltip;

		// Disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( tooltipData.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// Only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltipData.hiding = true;
		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		} );

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			} );
		}

		tooltipData.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		if ( !tooltipData.hiding ) {
			tooltipData.closing = false;
		}
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
			content = $( "<div>" ).appendTo( tooltip ),
			id = tooltip.uniqueId().attr( "id" );

		this._addClass( content, "ui-tooltip-content" );
		this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );

		tooltip.appendTo( this._appendTo( element ) );

		return this.tooltips[ id ] = {
			element: element,
			tooltip: tooltip
		};
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? this.tooltips[ id ] : null;
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_appendTo: function( target ) {
		var element = target.closest( ".ui-front, dialog" );

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_destroy: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {

			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" ),
				element = tooltipData.element;
			event.target = event.currentTarget = element[ 0 ];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {

				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		} );
		this.liveRegion.remove();
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for tooltipClass option
	$.widget( "ui.tooltip", $.ui.tooltip, {
		options: {
			tooltipClass: null
		},
		_tooltip: function() {
			var tooltipData = this._superApply( arguments );
			if ( this.options.tooltipClass ) {
				tooltipData.tooltip.addClass( this.options.tooltipClass );
			}
			return tooltipData;
		}
	} );
}

var widgetsTooltip = $.ui.tooltip;


})(jQuery);
</script>
    <script type="text/javascript" charset="utf-8">/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  OJ=exports.stringify;
  JO=exports.parse;
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));


</script>
    <script type="text/javascript" charset="utf-8">/*!
 * Chart.js v2.8.0
 * https://www.chartjs.org
 * (c) 2019 Chart.js Contributors
 * Released under the MIT License
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(function() { try { return require('moment'); } catch(e) { } }()) :
typeof define === 'function' && define.amd ? define(['require'], function(require) { return factory(function() { try { return require('moment'); } catch(e) { } }()); }) :
(global.Chart = factory(global.moment));
}(this, (function (moment) { 'use strict';

moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

/* MIT license */

var conversions = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
};


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

var convert = function() {
   return new Converter();
};

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   };
});

var colorConvert = convert;

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

/* MIT license */


var colorString = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
};

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3,4})$/i,
       hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       keyword = /(\w+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr),
       hexAlpha = "";
   if (match) {
      match = match[1];
      hexAlpha = match[3];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
         a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
      }
   }
   else if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
      if (hexAlpha) {
         a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorName[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
    var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgba, a) {
   var a = (a !== undefined && rgba.length === 3) ? a : rgba[3];
   return "#" + hexDouble(rgba[0]) 
              + hexDouble(rgba[1])
              + hexDouble(rgba[2])
              + (
                 (a >= 0 && a < 1)
                 ? hexDouble(Math.round(a * 255))
                 : ""
              );
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorName) {
   reverseNames[colorName[name]] = name;
}

/* MIT license */



var Color = function (obj) {
	if (obj instanceof Color) {
		return obj;
	}
	if (!(this instanceof Color)) {
		return new Color(obj);
	}

	this.valid = false;
	this.values = {
		rgb: [0, 0, 0],
		hsl: [0, 0, 0],
		hsv: [0, 0, 0],
		hwb: [0, 0, 0],
		cmyk: [0, 0, 0, 0],
		alpha: 1
	};

	// parse Color() argument
	var vals;
	if (typeof obj === 'string') {
		vals = colorString.getRgba(obj);
		if (vals) {
			this.setValues('rgb', vals);
		} else if (vals = colorString.getHsla(obj)) {
			this.setValues('hsl', vals);
		} else if (vals = colorString.getHwb(obj)) {
			this.setValues('hwb', vals);
		}
	} else if (typeof obj === 'object') {
		vals = obj;
		if (vals.r !== undefined || vals.red !== undefined) {
			this.setValues('rgb', vals);
		} else if (vals.l !== undefined || vals.lightness !== undefined) {
			this.setValues('hsl', vals);
		} else if (vals.v !== undefined || vals.value !== undefined) {
			this.setValues('hsv', vals);
		} else if (vals.w !== undefined || vals.whiteness !== undefined) {
			this.setValues('hwb', vals);
		} else if (vals.c !== undefined || vals.cyan !== undefined) {
			this.setValues('cmyk', vals);
		}
	}
};

Color.prototype = {
	isValid: function () {
		return this.valid;
	},
	rgb: function () {
		return this.setSpace('rgb', arguments);
	},
	hsl: function () {
		return this.setSpace('hsl', arguments);
	},
	hsv: function () {
		return this.setSpace('hsv', arguments);
	},
	hwb: function () {
		return this.setSpace('hwb', arguments);
	},
	cmyk: function () {
		return this.setSpace('cmyk', arguments);
	},

	rgbArray: function () {
		return this.values.rgb;
	},
	hslArray: function () {
		return this.values.hsl;
	},
	hsvArray: function () {
		return this.values.hsv;
	},
	hwbArray: function () {
		var values = this.values;
		if (values.alpha !== 1) {
			return values.hwb.concat([values.alpha]);
		}
		return values.hwb;
	},
	cmykArray: function () {
		return this.values.cmyk;
	},
	rgbaArray: function () {
		var values = this.values;
		return values.rgb.concat([values.alpha]);
	},
	hslaArray: function () {
		var values = this.values;
		return values.hsl.concat([values.alpha]);
	},
	alpha: function (val) {
		if (val === undefined) {
			return this.values.alpha;
		}
		this.setValues('alpha', val);
		return this;
	},

	red: function (val) {
		return this.setChannel('rgb', 0, val);
	},
	green: function (val) {
		return this.setChannel('rgb', 1, val);
	},
	blue: function (val) {
		return this.setChannel('rgb', 2, val);
	},
	hue: function (val) {
		if (val) {
			val %= 360;
			val = val < 0 ? 360 + val : val;
		}
		return this.setChannel('hsl', 0, val);
	},
	saturation: function (val) {
		return this.setChannel('hsl', 1, val);
	},
	lightness: function (val) {
		return this.setChannel('hsl', 2, val);
	},
	saturationv: function (val) {
		return this.setChannel('hsv', 1, val);
	},
	whiteness: function (val) {
		return this.setChannel('hwb', 1, val);
	},
	blackness: function (val) {
		return this.setChannel('hwb', 2, val);
	},
	value: function (val) {
		return this.setChannel('hsv', 2, val);
	},
	cyan: function (val) {
		return this.setChannel('cmyk', 0, val);
	},
	magenta: function (val) {
		return this.setChannel('cmyk', 1, val);
	},
	yellow: function (val) {
		return this.setChannel('cmyk', 2, val);
	},
	black: function (val) {
		return this.setChannel('cmyk', 3, val);
	},

	hexString: function () {
		return colorString.hexString(this.values.rgb);
	},
	rgbString: function () {
		return colorString.rgbString(this.values.rgb, this.values.alpha);
	},
	rgbaString: function () {
		return colorString.rgbaString(this.values.rgb, this.values.alpha);
	},
	percentString: function () {
		return colorString.percentString(this.values.rgb, this.values.alpha);
	},
	hslString: function () {
		return colorString.hslString(this.values.hsl, this.values.alpha);
	},
	hslaString: function () {
		return colorString.hslaString(this.values.hsl, this.values.alpha);
	},
	hwbString: function () {
		return colorString.hwbString(this.values.hwb, this.values.alpha);
	},
	keyword: function () {
		return colorString.keyword(this.values.rgb, this.values.alpha);
	},

	rgbNumber: function () {
		var rgb = this.values.rgb;
		return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.values.rgb;
		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}
		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();
		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}
		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.values.rgb;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = [];
		for (var i = 0; i < 3; i++) {
			rgb[i] = 255 - this.values.rgb[i];
		}
		this.setValues('rgb', rgb);
		return this;
	},

	lighten: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] += hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	darken: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] -= hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	saturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] += hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	desaturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] -= hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	whiten: function (ratio) {
		var hwb = this.values.hwb;
		hwb[1] += hwb[1] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	blacken: function (ratio) {
		var hwb = this.values.hwb;
		hwb[2] += hwb[2] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	greyscale: function () {
		var rgb = this.values.rgb;
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		this.setValues('rgb', [val, val, val]);
		return this;
	},

	clearer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha - (alpha * ratio));
		return this;
	},

	opaquer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha + (alpha * ratio));
		return this;
	},

	rotate: function (degrees) {
		var hsl = this.values.hsl;
		var hue = (hsl[0] + degrees) % 360;
		hsl[0] = hue < 0 ? 360 + hue : hue;
		this.setValues('hsl', hsl);
		return this;
	},

	/**
	 * Ported from sass implementation in C
	 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
	 */
	mix: function (mixinColor, weight) {
		var color1 = this;
		var color2 = mixinColor;
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return this
			.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue()
			)
			.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
	},

	toJSON: function () {
		return this.rgb();
	},

	clone: function () {
		// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
		// making the final build way to big to embed in Chart.js. So let's do it manually,
		// assuming that values to clone are 1 dimension arrays containing only numbers,
		// except 'alpha' which is a number.
		var result = new Color();
		var source = this.values;
		var target = result.values;
		var value, type;

		for (var prop in source) {
			if (source.hasOwnProperty(prop)) {
				value = source[prop];
				type = ({}).toString.call(value);
				if (type === '[object Array]') {
					target[prop] = value.slice(0);
				} else if (type === '[object Number]') {
					target[prop] = value;
				} else {
					console.error('unexpected color value:', value);
				}
			}
		}

		return result;
	}
};

Color.prototype.spaces = {
	rgb: ['red', 'green', 'blue'],
	hsl: ['hue', 'saturation', 'lightness'],
	hsv: ['hue', 'saturation', 'value'],
	hwb: ['hue', 'whiteness', 'blackness'],
	cmyk: ['cyan', 'magenta', 'yellow', 'black']
};

Color.prototype.maxes = {
	rgb: [255, 255, 255],
	hsl: [360, 100, 100],
	hsv: [360, 100, 100],
	hwb: [360, 100, 100],
	cmyk: [100, 100, 100, 100]
};

Color.prototype.getValues = function (space) {
	var values = this.values;
	var vals = {};

	for (var i = 0; i < space.length; i++) {
		vals[space.charAt(i)] = values[space][i];
	}

	if (values.alpha !== 1) {
		vals.a = values.alpha;
	}

	// {r: 255, g: 255, b: 255, a: 0.4}
	return vals;
};

Color.prototype.setValues = function (space, vals) {
	var values = this.values;
	var spaces = this.spaces;
	var maxes = this.maxes;
	var alpha = 1;
	var i;

	this.valid = true;

	if (space === 'alpha') {
		alpha = vals;
	} else if (vals.length) {
		// [10, 10, 10]
		values[space] = vals.slice(0, space.length);
		alpha = vals[space.length];
	} else if (vals[space.charAt(0)] !== undefined) {
		// {r: 10, g: 10, b: 10}
		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[space.charAt(i)];
		}

		alpha = vals.a;
	} else if (vals[spaces[space][0]] !== undefined) {
		// {red: 10, green: 10, blue: 10}
		var chans = spaces[space];

		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[chans[i]];
		}

		alpha = vals.alpha;
	}

	values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

	if (space === 'alpha') {
		return false;
	}

	var capped;

	// cap values of the space prior converting all values
	for (i = 0; i < space.length; i++) {
		capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
		values[space][i] = Math.round(capped);
	}

	// convert to all the other color spaces
	for (var sname in spaces) {
		if (sname !== space) {
			values[sname] = colorConvert[space][sname](values[space]);
		}
	}

	return true;
};

Color.prototype.setSpace = function (space, args) {
	var vals = args[0];

	if (vals === undefined) {
		// color.rgb()
		return this.getValues(space);
	}

	// color.rgb(10, 10, 10)
	if (typeof vals === 'number') {
		vals = Array.prototype.slice.call(args);
	}

	this.setValues(space, vals);
	return this;
};

Color.prototype.setChannel = function (space, index, val) {
	var svalues = this.values[space];
	if (val === undefined) {
		// color.red()
		return svalues[index];
	} else if (val === svalues[index]) {
		// color.red(color.red())
		return this;
	}

	// color.red(100)
	svalues[index] = val;
	this.setValues(space, svalues);

	return this;
};

if (typeof window !== 'undefined') {
	window.Color = Color;
}

var chartjsColor = Color;

/**
 * @namespace Chart.helpers
 */
var helpers = {
	/**
	 * An empty function that can be used, for example, for optional callback.
	 */
	noop: function() {},

	/**
	 * Returns a unique id, sequentially generated from a global variable.
	 * @returns {number}
	 * @function
	 */
	uid: (function() {
		var id = 0;
		return function() {
			return id++;
		};
	}()),

	/**
	 * Returns true if `value` is neither null nor undefined, else returns false.
	 * @param {*} value - The value to test.
	 * @returns {boolean}
	 * @since 2.7.0
	 */
	isNullOrUndef: function(value) {
		return value === null || typeof value === 'undefined';
	},

	/**
	 * Returns true if `value` is an array (including typed arrays), else returns false.
	 * @param {*} value - The value to test.
	 * @returns {boolean}
	 * @function
	 */
	isArray: function(value) {
		if (Array.isArray && Array.isArray(value)) {
			return true;
		}
		var type = Object.prototype.toString.call(value);
		if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
			return true;
		}
		return false;
	},

	/**
	 * Returns true if `value` is an object (excluding null), else returns false.
	 * @param {*} value - The value to test.
	 * @returns {boolean}
	 * @since 2.7.0
	 */
	isObject: function(value) {
		return value !== null && Object.prototype.toString.call(value) === '[object Object]';
	},

	/**
	 * Returns true if `value` is a finite number, else returns false
	 * @param {*} value  - The value to test.
	 * @returns {boolean}
	 */
	isFinite: function(value) {
		return (typeof value === 'number' || value instanceof Number) && isFinite(value);
	},

	/**
	 * Returns `value` if defined, else returns `defaultValue`.
	 * @param {*} value - The value to return if defined.
	 * @param {*} defaultValue - The value to return if `value` is undefined.
	 * @returns {*}
	 */
	valueOrDefault: function(value, defaultValue) {
		return typeof value === 'undefined' ? defaultValue : value;
	},

	/**
	 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
	 * @param {Array} value - The array to lookup for value at `index`.
	 * @param {number} index - The index in `value` to lookup for value.
	 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
	 * @returns {*}
	 */
	valueAtIndexOrDefault: function(value, index, defaultValue) {
		return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
	},

	/**
	 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
	 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
	 * @param {function} fn - The function to call.
	 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
	 * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
	 * @returns {*}
	 */
	callback: function(fn, args, thisArg) {
		if (fn && typeof fn.call === 'function') {
			return fn.apply(thisArg, args);
		}
	},

	/**
	 * Note(SB) for performance sake, this method should only be used when loopable type
	 * is unknown or in none intensive code (not called often and small loopable). Else
	 * it's preferable to use a regular for() loop and save extra function calls.
	 * @param {object|Array} loopable - The object or array to be iterated.
	 * @param {function} fn - The function to call for each item.
	 * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
	 * @param {boolean} [reverse] - If true, iterates backward on the loopable.
	 */
	each: function(loopable, fn, thisArg, reverse) {
		var i, len, keys;
		if (helpers.isArray(loopable)) {
			len = loopable.length;
			if (reverse) {
				for (i = len - 1; i >= 0; i--) {
					fn.call(thisArg, loopable[i], i);
				}
			} else {
				for (i = 0; i < len; i++) {
					fn.call(thisArg, loopable[i], i);
				}
			}
		} else if (helpers.isObject(loopable)) {
			keys = Object.keys(loopable);
			len = keys.length;
			for (i = 0; i < len; i++) {
				fn.call(thisArg, loopable[keys[i]], keys[i]);
			}
		}
	},

	/**
	 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
	 * @see https://stackoverflow.com/a/14853974
	 * @param {Array} a0 - The array to compare
	 * @param {Array} a1 - The array to compare
	 * @returns {boolean}
	 */
	arrayEquals: function(a0, a1) {
		var i, ilen, v0, v1;

		if (!a0 || !a1 || a0.length !== a1.length) {
			return false;
		}

		for (i = 0, ilen = a0.length; i < ilen; ++i) {
			v0 = a0[i];
			v1 = a1[i];

			if (v0 instanceof Array && v1 instanceof Array) {
				if (!helpers.arrayEquals(v0, v1)) {
					return false;
				}
			} else if (v0 !== v1) {
				// NOTE: two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}

		return true;
	},

	/**
	 * Returns a deep copy of `source` without keeping references on objects and arrays.
	 * @param {*} source - The value to clone.
	 * @returns {*}
	 */
	clone: function(source) {
		if (helpers.isArray(source)) {
			return source.map(helpers.clone);
		}

		if (helpers.isObject(source)) {
			var target = {};
			var keys = Object.keys(source);
			var klen = keys.length;
			var k = 0;

			for (; k < klen; ++k) {
				target[keys[k]] = helpers.clone(source[keys[k]]);
			}

			return target;
		}

		return source;
	},

	/**
	 * The default merger when Chart.helpers.merge is called without merger option.
	 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
	 * @private
	 */
	_merger: function(key, target, source, options) {
		var tval = target[key];
		var sval = source[key];

		if (helpers.isObject(tval) && helpers.isObject(sval)) {
			helpers.merge(tval, sval, options);
		} else {
			target[key] = helpers.clone(sval);
		}
	},

	/**
	 * Merges source[key] in target[key] only if target[key] is undefined.
	 * @private
	 */
	_mergerIf: function(key, target, source) {
		var tval = target[key];
		var sval = source[key];

		if (helpers.isObject(tval) && helpers.isObject(sval)) {
			helpers.mergeIf(tval, sval);
		} else if (!target.hasOwnProperty(key)) {
			target[key] = helpers.clone(sval);
		}
	},

	/**
	 * Recursively deep copies `source` properties into `target` with the given `options`.
	 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
	 * @param {object} target - The target object in which all sources are merged into.
	 * @param {object|object[]} source - Object(s) to merge into `target`.
	 * @param {object} [options] - Merging options:
	 * @param {function} [options.merger] - The merge method (key, target, source, options)
	 * @returns {object} The `target` object.
	 */
	merge: function(target, source, options) {
		var sources = helpers.isArray(source) ? source : [source];
		var ilen = sources.length;
		var merge, i, keys, klen, k;

		if (!helpers.isObject(target)) {
			return target;
		}

		options = options || {};
		merge = options.merger || helpers._merger;

		for (i = 0; i < ilen; ++i) {
			source = sources[i];
			if (!helpers.isObject(source)) {
				continue;
			}

			keys = Object.keys(source);
			for (k = 0, klen = keys.length; k < klen; ++k) {
				merge(keys[k], target, source, options);
			}
		}

		return target;
	},

	/**
	 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
	 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
	 * @param {object} target - The target object in which all sources are merged into.
	 * @param {object|object[]} source - Object(s) to merge into `target`.
	 * @returns {object} The `target` object.
	 */
	mergeIf: function(target, source) {
		return helpers.merge(target, source, {merger: helpers._mergerIf});
	},

	/**
	 * Applies the contents of two or more objects together into the first object.
	 * @param {object} target - The target object in which all objects are merged into.
	 * @param {object} arg1 - Object containing additional properties to merge in target.
	 * @param {object} argN - Additional objects containing properties to merge in target.
	 * @returns {object} The `target` object.
	 */
	extend: function(target) {
		var setFn = function(value, key) {
			target[key] = value;
		};
		for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
			helpers.each(arguments[i], setFn);
		}
		return target;
	},

	/**
	 * Basic javascript inheritance based on the model created in Backbone.js
	 */
	inherits: function(extensions) {
		var me = this;
		var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
			return me.apply(this, arguments);
		};

		var Surrogate = function() {
			this.constructor = ChartElement;
		};

		Surrogate.prototype = me.prototype;
		ChartElement.prototype = new Surrogate();
		ChartElement.extend = helpers.inherits;

		if (extensions) {
			helpers.extend(ChartElement.prototype, extensions);
		}

		ChartElement.__super__ = me.prototype;
		return ChartElement;
	}
};

var helpers_core = helpers;

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.callback instead.
 * @function Chart.helpers.callCallback
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */
helpers.callCallback = helpers.callback;

/**
 * Provided for backward compatibility, use Array.prototype.indexOf instead.
 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
 * @function Chart.helpers.indexOf
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.indexOf = function(array, item, fromIndex) {
	return Array.prototype.indexOf.call(array, item, fromIndex);
};

/**
 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
 * @function Chart.helpers.getValueOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.getValueOrDefault = helpers.valueOrDefault;

/**
 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
 * @function Chart.helpers.getValueAtIndexOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easingEffects
 * @see http://www.robertpenner.com/easing/
 */
var effects = {
	linear: function(t) {
		return t;
	},

	easeInQuad: function(t) {
		return t * t;
	},

	easeOutQuad: function(t) {
		return -t * (t - 2);
	},

	easeInOutQuad: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t;
		}
		return -0.5 * ((--t) * (t - 2) - 1);
	},

	easeInCubic: function(t) {
		return t * t * t;
	},

	easeOutCubic: function(t) {
		return (t = t - 1) * t * t + 1;
	},

	easeInOutCubic: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t;
		}
		return 0.5 * ((t -= 2) * t * t + 2);
	},

	easeInQuart: function(t) {
		return t * t * t * t;
	},

	easeOutQuart: function(t) {
		return -((t = t - 1) * t * t * t - 1);
	},

	easeInOutQuart: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t * t;
		}
		return -0.5 * ((t -= 2) * t * t * t - 2);
	},

	easeInQuint: function(t) {
		return t * t * t * t * t;
	},

	easeOutQuint: function(t) {
		return (t = t - 1) * t * t * t * t + 1;
	},

	easeInOutQuint: function(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t * t * t;
		}
		return 0.5 * ((t -= 2) * t * t * t * t + 2);
	},

	easeInSine: function(t) {
		return -Math.cos(t * (Math.PI / 2)) + 1;
	},

	easeOutSine: function(t) {
		return Math.sin(t * (Math.PI / 2));
	},

	easeInOutSine: function(t) {
		return -0.5 * (Math.cos(Math.PI * t) - 1);
	},

	easeInExpo: function(t) {
		return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
	},

	easeOutExpo: function(t) {
		return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
	},

	easeInOutExpo: function(t) {
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if ((t /= 0.5) < 1) {
			return 0.5 * Math.pow(2, 10 * (t - 1));
		}
		return 0.5 * (-Math.pow(2, -10 * --t) + 2);
	},

	easeInCirc: function(t) {
		if (t >= 1) {
			return t;
		}
		return -(Math.sqrt(1 - t * t) - 1);
	},

	easeOutCirc: function(t) {
		return Math.sqrt(1 - (t = t - 1) * t);
	},

	easeInOutCirc: function(t) {
		if ((t /= 0.5) < 1) {
			return -0.5 * (Math.sqrt(1 - t * t) - 1);
		}
		return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	},

	easeInElastic: function(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if (!p) {
			p = 0.3;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
	},

	easeOutElastic: function(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if (!p) {
			p = 0.3;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
	},

	easeInOutElastic: function(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if ((t /= 0.5) === 2) {
			return 1;
		}
		if (!p) {
			p = 0.45;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		if (t < 1) {
			return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		}
		return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
	},
	easeInBack: function(t) {
		var s = 1.70158;
		return t * t * ((s + 1) * t - s);
	},

	easeOutBack: function(t) {
		var s = 1.70158;
		return (t = t - 1) * t * ((s + 1) * t + s) + 1;
	},

	easeInOutBack: function(t) {
		var s = 1.70158;
		if ((t /= 0.5) < 1) {
			return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
		}
		return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
	},

	easeInBounce: function(t) {
		return 1 - effects.easeOutBounce(1 - t);
	},

	easeOutBounce: function(t) {
		if (t < (1 / 2.75)) {
			return 7.5625 * t * t;
		}
		if (t < (2 / 2.75)) {
			return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
		}
		if (t < (2.5 / 2.75)) {
			return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
		}
		return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
	},

	easeInOutBounce: function(t) {
		if (t < 0.5) {
			return effects.easeInBounce(t * 2) * 0.5;
		}
		return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
	}
};

var helpers_easing = {
	effects: effects
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
 * @function Chart.helpers.easingEffects
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers_core.easingEffects = effects;

var PI = Math.PI;
var RAD_PER_DEG = PI / 180;
var DOUBLE_PI = PI * 2;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;

/**
 * @namespace Chart.helpers.canvas
 */
var exports$1 = {
	/**
	 * Clears the entire canvas associated to the given `chart`.
	 * @param {Chart} chart - The chart for which to clear the canvas.
	 */
	clear: function(chart) {
		chart.ctx.clearRect(0, 0, chart.width, chart.height);
	},

	/**
	 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
	 * given size (width, height) and the same `radius` for all corners.
	 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
	 * @param {number} x - The x axis of the coordinate for the rectangle starting point.
	 * @param {number} y - The y axis of the coordinate for the rectangle starting point.
	 * @param {number} width - The rectangle's width.
	 * @param {number} height - The rectangle's height.
	 * @param {number} radius - The rounded amount (in pixels) for the four corners.
	 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
	 */
	roundedRect: function(ctx, x, y, width, height, radius) {
		if (radius) {
			var r = Math.min(radius, height / 2, width / 2);
			var left = x + r;
			var top = y + r;
			var right = x + width - r;
			var bottom = y + height - r;

			ctx.moveTo(x, top);
			if (left < right && top < bottom) {
				ctx.arc(left, top, r, -PI, -HALF_PI);
				ctx.arc(right, top, r, -HALF_PI, 0);
				ctx.arc(right, bottom, r, 0, HALF_PI);
				ctx.arc(left, bottom, r, HALF_PI, PI);
			} else if (left < right) {
				ctx.moveTo(left, y);
				ctx.arc(right, top, r, -HALF_PI, HALF_PI);
				ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
			} else if (top < bottom) {
				ctx.arc(left, top, r, -PI, 0);
				ctx.arc(left, bottom, r, 0, PI);
			} else {
				ctx.arc(left, top, r, -PI, PI);
			}
			ctx.closePath();
			ctx.moveTo(x, y);
		} else {
			ctx.rect(x, y, width, height);
		}
	},

	drawPoint: function(ctx, style, radius, x, y, rotation) {
		var type, xOffset, yOffset, size, cornerRadius;
		var rad = (rotation || 0) * RAD_PER_DEG;

		if (style && typeof style === 'object') {
			type = style.toString();
			if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
				ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
				return;
			}
		}

		if (isNaN(radius) || radius <= 0) {
			return;
		}

		ctx.beginPath();

		switch (style) {
		// Default includes circle
		default:
			ctx.arc(x, y, radius, 0, DOUBLE_PI);
			ctx.closePath();
			break;
		case 'triangle':
			ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
			rad += TWO_THIRDS_PI;
			ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
			rad += TWO_THIRDS_PI;
			ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
			ctx.closePath();
			break;
		case 'rectRounded':
			// NOTE: the rounded rect implementation changed to use `arc` instead of
			// `quadraticCurveTo` since it generates better results when rect is
			// almost a circle. 0.516 (instead of 0.5) produces results with visually
			// closer proportion to the previous impl and it is inscribed in the
			// circle with `radius`. For more details, see the following PRs:
			// https://github.com/chartjs/Chart.js/issues/5597
			// https://github.com/chartjs/Chart.js/issues/5858
			cornerRadius = radius * 0.516;
			size = radius - cornerRadius;
			xOffset = Math.cos(rad + QUARTER_PI) * size;
			yOffset = Math.sin(rad + QUARTER_PI) * size;
			ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
			ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
			ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
			ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
			ctx.closePath();
			break;
		case 'rect':
			if (!rotation) {
				size = Math.SQRT1_2 * radius;
				ctx.rect(x - size, y - size, 2 * size, 2 * size);
				break;
			}
			rad += QUARTER_PI;
			/* falls through */
		case 'rectRot':
			xOffset = Math.cos(rad) * radius;
			yOffset = Math.sin(rad) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + yOffset, y - xOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.lineTo(x - yOffset, y + xOffset);
			ctx.closePath();
			break;
		case 'crossRot':
			rad += QUARTER_PI;
			/* falls through */
		case 'cross':
			xOffset = Math.cos(rad) * radius;
			yOffset = Math.sin(rad) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x + yOffset, y - xOffset);
			ctx.lineTo(x - yOffset, y + xOffset);
			break;
		case 'star':
			xOffset = Math.cos(rad) * radius;
			yOffset = Math.sin(rad) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x + yOffset, y - xOffset);
			ctx.lineTo(x - yOffset, y + xOffset);
			rad += QUARTER_PI;
			xOffset = Math.cos(rad) * radius;
			yOffset = Math.sin(rad) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x + yOffset, y - xOffset);
			ctx.lineTo(x - yOffset, y + xOffset);
			break;
		case 'line':
			xOffset = Math.cos(rad) * radius;
			yOffset = Math.sin(rad) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			break;
		case 'dash':
			ctx.moveTo(x, y);
			ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
			break;
		}

		ctx.fill();
		ctx.stroke();
	},

	/**
	 * Returns true if the point is inside the rectangle
	 * @param {object} point - The point to test
	 * @param {object} area - The rectangle
	 * @returns {boolean}
	 * @private
	 */
	_isPointInArea: function(point, area) {
		var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

		return point.x > area.left - epsilon && point.x < area.right + epsilon &&
			point.y > area.top - epsilon && point.y < area.bottom + epsilon;
	},

	clipArea: function(ctx, area) {
		ctx.save();
		ctx.beginPath();
		ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
		ctx.clip();
	},

	unclipArea: function(ctx) {
		ctx.restore();
	},

	lineTo: function(ctx, previous, target, flip) {
		var stepped = target.steppedLine;
		if (stepped) {
			if (stepped === 'middle') {
				var midpoint = (previous.x + target.x) / 2.0;
				ctx.lineTo(midpoint, flip ? target.y : previous.y);
				ctx.lineTo(midpoint, flip ? previous.y : target.y);
			} else if ((stepped === 'after' && !flip) || (stepped !== 'after' && flip)) {
				ctx.lineTo(previous.x, target.y);
			} else {
				ctx.lineTo(target.x, previous.y);
			}
			ctx.lineTo(target.x, target.y);
			return;
		}

		if (!target.tension) {
			ctx.lineTo(target.x, target.y);
			return;
		}

		ctx.bezierCurveTo(
			flip ? previous.controlPointPreviousX : previous.controlPointNextX,
			flip ? previous.controlPointPreviousY : previous.controlPointNextY,
			flip ? target.controlPointNextX : target.controlPointPreviousX,
			flip ? target.controlPointNextY : target.controlPointPreviousY,
			target.x,
			target.y);
	}
};

var helpers_canvas = exports$1;

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
 * @namespace Chart.helpers.clear
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers_core.clear = exports$1.clear;

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
 * @namespace Chart.helpers.drawRoundedRectangle
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers_core.drawRoundedRectangle = function(ctx) {
	ctx.beginPath();
	exports$1.roundedRect.apply(exports$1, arguments);
};

var defaults = {
	/**
	 * @private
	 */
	_set: function(scope, values) {
		return helpers_core.merge(this[scope] || (this[scope] = {}), values);
	}
};

defaults._set('global', {
	defaultColor: 'rgba(0,0,0,0.1)',
	defaultFontColor: '#666',
	defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
	defaultFontSize: 12,
	defaultFontStyle: 'normal',
	defaultLineHeight: 1.2,
	showLines: true
});

var core_defaults = defaults;

var valueOrDefault = helpers_core.valueOrDefault;

/**
 * Converts the given font object into a CSS font string.
 * @param {object} font - A font object.
 * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
 * @private
 */
function toFontString(font) {
	if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
		return null;
	}

	return (font.style ? font.style + ' ' : '')
		+ (font.weight ? font.weight + ' ' : '')
		+ font.size + 'px '
		+ font.family;
}

/**
 * @alias Chart.helpers.options
 * @namespace
 */
var helpers_options = {
	/**
	 * Converts the given line height `value` in pixels for a specific font `size`.
	 * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
	 * @param {number} size - The font size (in pixels) used to resolve relative `value`.
	 * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
	 * @since 2.7.0
	 */
	toLineHeight: function(value, size) {
		var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
		if (!matches || matches[1] === 'normal') {
			return size * 1.2;
		}

		value = +matches[2];

		switch (matches[3]) {
		case 'px':
			return value;
		case '%':
			value /= 100;
			break;
		default:
			break;
		}

		return size * value;
	},

	/**
	 * Converts the given value into a padding object with pre-computed width/height.
	 * @param {number|object} value - If a number, set the value to all TRBL component,
	 *  else, if and object, use defined properties and sets undefined ones to 0.
	 * @returns {object} The padding values (top, right, bottom, left, width, height)
	 * @since 2.7.0
	 */
	toPadding: function(value) {
		var t, r, b, l;

		if (helpers_core.isObject(value)) {
			t = +value.top || 0;
			r = +value.right || 0;
			b = +value.bottom || 0;
			l = +value.left || 0;
		} else {
			t = r = b = l = +value || 0;
		}

		return {
			top: t,
			right: r,
			bottom: b,
			left: l,
			height: t + b,
			width: l + r
		};
	},

	/**
	 * Parses font options and returns the font object.
	 * @param {object} options - A object that contains font options to be parsed.
	 * @return {object} The font object.
	 * @todo Support font.* options and renamed to toFont().
	 * @private
	 */
	_parseFont: function(options) {
		var globalDefaults = core_defaults.global;
		var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
		var font = {
			family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
			lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
			size: size,
			style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
			weight: null,
			string: ''
		};

		font.string = toFontString(font);
		return font;
	},

	/**
	 * Evaluates the given `inputs` sequentially and returns the first defined value.
	 * @param {Array} inputs - An array of values, falling back to the last value.
	 * @param {object} [context] - If defined and the current value is a function, the value
	 * is called with `context` as first argument and the result becomes the new input.
	 * @param {number} [index] - If defined and the current value is an array, the value
	 * at `index` become the new input.
	 * @since 2.7.0
	 */
	resolve: function(inputs, context, index) {
		var i, ilen, value;

		for (i = 0, ilen = inputs.length; i < ilen; ++i) {
			value = inputs[i];
			if (value === undefined) {
				continue;
			}
			if (context !== undefined && typeof value === 'function') {
				value = value(context);
			}
			if (index !== undefined && helpers_core.isArray(value)) {
				value = value[index];
			}
			if (value !== undefined) {
				return value;
			}
		}
	}
};

var helpers$1 = helpers_core;
var easing = helpers_easing;
var canvas = helpers_canvas;
var options = helpers_options;
helpers$1.easing = easing;
helpers$1.canvas = canvas;
helpers$1.options = options;

function interpolate(start, view, model, ease) {
	var keys = Object.keys(model);
	var i, ilen, key, actual, origin, target, type, c0, c1;

	for (i = 0, ilen = keys.length; i < ilen; ++i) {
		key = keys[i];

		target = model[key];

		// if a value is added to the model after pivot() has been called, the view
		// doesn't contain it, so let's initialize the view to the target value.
		if (!view.hasOwnProperty(key)) {
			view[key] = target;
		}

		actual = view[key];

		if (actual === target || key[0] === '_') {
			continue;
		}

		if (!start.hasOwnProperty(key)) {
			start[key] = actual;
		}

		origin = start[key];

		type = typeof target;

		if (type === typeof origin) {
			if (type === 'string') {
				c0 = chartjsColor(origin);
				if (c0.valid) {
					c1 = chartjsColor(target);
					if (c1.valid) {
						view[key] = c1.mix(c0, ease).rgbString();
						continue;
					}
				}
			} else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
				view[key] = origin + (target - origin) * ease;
				continue;
			}
		}

		view[key] = target;
	}
}

var Element = function(configuration) {
	helpers$1.extend(this, configuration);
	this.initialize.apply(this, arguments);
};

helpers$1.extend(Element.prototype, {

	initialize: function() {
		this.hidden = false;
	},

	pivot: function() {
		var me = this;
		if (!me._view) {
			me._view = helpers$1.clone(me._model);
		}
		me._start = {};
		return me;
	},

	transition: function(ease) {
		var me = this;
		var model = me._model;
		var start = me._start;
		var view = me._view;

		// No animation -> No Transition
		if (!model || ease === 1) {
			me._view = model;
			me._start = null;
			return me;
		}

		if (!view) {
			view = me._view = {};
		}

		if (!start) {
			start = me._start = {};
		}

		interpolate(start, view, model, ease);

		return me;
	},

	tooltipPosition: function() {
		return {
			x: this._model.x,
			y: this._model.y
		};
	},

	hasValue: function() {
		return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
	}
});

Element.extend = helpers$1.inherits;

var core_element = Element;

var exports$2 = core_element.extend({
	chart: null, // the animation associated chart instance
	currentStep: 0, // the current animation step
	numSteps: 60, // default number of steps
	easing: '', // the easing to use for this animation
	render: null, // render function used by the animation service

	onAnimationProgress: null, // user specified callback to fire on each step of the animation
	onAnimationComplete: null, // user specified callback to fire when the animation finishes
});

var core_animation = exports$2;

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.Animation instead
 * @prop Chart.Animation#animationObject
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 */
Object.defineProperty(exports$2.prototype, 'animationObject', {
	get: function() {
		return this;
	}
});

/**
 * Provided for backward compatibility, use Chart.Animation#chart instead
 * @prop Chart.Animation#chartInstance
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 */
Object.defineProperty(exports$2.prototype, 'chartInstance', {
	get: function() {
		return this.chart;
	},
	set: function(value) {
		this.chart = value;
	}
});

core_defaults._set('global', {
	animation: {
		duration: 1000,
		easing: 'easeOutQuart',
		onProgress: helpers$1.noop,
		onComplete: helpers$1.noop
	}
});

var core_animations = {
	animations: [],
	request: null,

	/**
	 * @param {Chart} chart - The chart to animate.
	 * @param {Chart.Animation} animation - The animation that we will animate.
	 * @param {number} duration - The animation duration in ms.
	 * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
	 */
	addAnimation: function(chart, animation, duration, lazy) {
		var animations = this.animations;
		var i, ilen;

		animation.chart = chart;
		animation.startTime = Date.now();
		animation.duration = duration;

		if (!lazy) {
			chart.animating = true;
		}

		for (i = 0, ilen = animations.length; i < ilen; ++i) {
			if (animations[i].chart === chart) {
				animations[i] = animation;
				return;
			}
		}

		animations.push(animation);

		// If there are no animations queued, manually kickstart a digest, for lack of a better word
		if (animations.length === 1) {
			this.requestAnimationFrame();
		}
	},

	cancelAnimation: function(chart) {
		var index = helpers$1.findIndex(this.animations, function(animation) {
			return animation.chart === chart;
		});

		if (index !== -1) {
			this.animations.splice(index, 1);
			chart.animating = false;
		}
	},

	requestAnimationFrame: function() {
		var me = this;
		if (me.request === null) {
			// Skip animation frame requests until the active one is executed.
			// This can happen when processing mouse events, e.g. 'mousemove'
			// and 'mouseout' events will trigger multiple renders.
			me.request = helpers$1.requestAnimFrame.call(window, function() {
				me.request = null;
				me.startDigest();
			});
		}
	},

	/**
	 * @private
	 */
	startDigest: function() {
		var me = this;

		me.advance();

		// Do we have more stuff to animate?
		if (me.animations.length > 0) {
			me.requestAnimationFrame();
		}
	},

	/**
	 * @private
	 */
	advance: function() {
		var animations = this.animations;
		var animation, chart, numSteps, nextStep;
		var i = 0;

		// 1 animation per chart, so we are looping charts here
		while (i < animations.length) {
			animation = animations[i];
			chart = animation.chart;
			numSteps = animation.numSteps;

			// Make sure that currentStep starts at 1
			// https://github.com/chartjs/Chart.js/issues/6104
			nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
			animation.currentStep = Math.min(nextStep, numSteps);

			helpers$1.callback(animation.render, [chart, animation], chart);
			helpers$1.callback(animation.onAnimationProgress, [animation], chart);

			if (animation.currentStep >= numSteps) {
				helpers$1.callback(animation.onAnimationComplete, [animation], chart);
				chart.animating = false;
				animations.splice(i, 1);
			} else {
				++i;
			}
		}
	}
};

var resolve = helpers$1.options.resolve;

var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

/**
 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
 */
function listenArrayEvents(array, listener) {
	if (array._chartjs) {
		array._chartjs.listeners.push(listener);
		return;
	}

	Object.defineProperty(array, '_chartjs', {
		configurable: true,
		enumerable: false,
		value: {
			listeners: [listener]
		}
	});

	arrayEvents.forEach(function(key) {
		var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
		var base = array[key];

		Object.defineProperty(array, key, {
			configurable: true,
			enumerable: false,
			value: function() {
				var args = Array.prototype.slice.call(arguments);
				var res = base.apply(this, args);

				helpers$1.each(array._chartjs.listeners, function(object) {
					if (typeof object[method] === 'function') {
						object[method].apply(object, args);
					}
				});

				return res;
			}
		});
	});
}

/**
 * Removes the given array event listener and cleanup extra attached properties (such as
 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
 */
function unlistenArrayEvents(array, listener) {
	var stub = array._chartjs;
	if (!stub) {
		return;
	}

	var listeners = stub.listeners;
	var index = listeners.indexOf(listener);
	if (index !== -1) {
		listeners.splice(index, 1);
	}

	if (listeners.length > 0) {
		return;
	}

	arrayEvents.forEach(function(key) {
		delete array[key];
	});

	delete array._chartjs;
}

// Base class for all dataset controllers (line, bar, etc)
var DatasetController = function(chart, datasetIndex) {
	this.initialize(chart, datasetIndex);
};

helpers$1.extend(DatasetController.prototype, {

	/**
	 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
	 * @type {Chart.core.element}
	 */
	datasetElementType: null,

	/**
	 * Element type used to generate a meta data (e.g. Chart.element.Point).
	 * @type {Chart.core.element}
	 */
	dataElementType: null,

	initialize: function(chart, datasetIndex) {
		var me = this;
		me.chart = chart;
		me.index = datasetIndex;
		me.linkScales();
		me.addElements();
	},

	updateIndex: function(datasetIndex) {
		this.index = datasetIndex;
	},

	linkScales: function() {
		var me = this;
		var meta = me.getMeta();
		var dataset = me.getDataset();

		if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
			meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
		}
		if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
			meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
		}
	},

	getDataset: function() {
		return this.chart.data.datasets[this.index];
	},

	getMeta: function() {
		return this.chart.getDatasetMeta(this.index);
	},

	getScaleForId: function(scaleID) {
		return this.chart.scales[scaleID];
	},

	/**
	 * @private
	 */
	_getValueScaleId: function() {
		return this.getMeta().yAxisID;
	},

	/**
	 * @private
	 */
	_getIndexScaleId: function() {
		return this.getMeta().xAxisID;
	},

	/**
	 * @private
	 */
	_getValueScale: function() {
		return this.getScaleForId(this._getValueScaleId());
	},

	/**
	 * @private
	 */
	_getIndexScale: function() {
		return this.getScaleForId(this._getIndexScaleId());
	},

	reset: function() {
		this.update(true);
	},

	/**
	 * @private
	 */
	destroy: function() {
		if (this._data) {
			unlistenArrayEvents(this._data, this);
		}
	},

	createMetaDataset: function() {
		var me = this;
		var type = me.datasetElementType;
		return type && new type({
			_chart: me.chart,
			_datasetIndex: me.index
		});
	},

	createMetaData: function(index) {
		var me = this;
		var type = me.dataElementType;
		return type && new type({
			_chart: me.chart,
			_datasetIndex: me.index,
			_index: index
		});
	},

	addElements: function() {
		var me = this;
		var meta = me.getMeta();
		var data = me.getDataset().data || [];
		var metaData = meta.data;
		var i, ilen;

		for (i = 0, ilen = data.length; i < ilen; ++i) {
			metaData[i] = metaData[i] || me.createMetaData(i);
		}

		meta.dataset = meta.dataset || me.createMetaDataset();
	},

	addElementAndReset: function(index) {
		var element = this.createMetaData(index);
		this.getMeta().data.splice(index, 0, element);
		this.updateElement(element, index, true);
	},

	buildOrUpdateElements: function() {
		var me = this;
		var dataset = me.getDataset();
		var data = dataset.data || (dataset.data = []);

		// In order to correctly handle data addition/deletion animation (an thus simulate
		// real-time charts), we need to monitor these data modifications and synchronize
		// the internal meta data accordingly.
		if (me._data !== data) {
			if (me._data) {
				// This case happens when the user replaced the data array instance.
				unlistenArrayEvents(me._data, me);
			}

			if (data && Object.isExtensible(data)) {
				listenArrayEvents(data, me);
			}
			me._data = data;
		}

		// Re-sync meta data in case the user replaced the data array or if we missed
		// any updates and so make sure that we handle number of datapoints changing.
		me.resyncElements();
	},

	update: helpers$1.noop,

	transition: function(easingValue) {
		var meta = this.getMeta();
		var elements = meta.data || [];
		var ilen = elements.length;
		var i = 0;

		for (; i < ilen; ++i) {
			elements[i].transition(easingValue);
		}

		if (meta.dataset) {
			meta.dataset.transition(easingValue);
		}
	},

	draw: function() {
		var meta = this.getMeta();
		var elements = meta.data || [];
		var ilen = elements.length;
		var i = 0;

		if (meta.dataset) {
			meta.dataset.draw();
		}

		for (; i < ilen; ++i) {
			elements[i].draw();
		}
	},

	removeHoverStyle: function(element) {
		helpers$1.merge(element._model, element.$previousStyle || {});
		delete element.$previousStyle;
	},

	setHoverStyle: function(element) {
		var dataset = this.chart.data.datasets[element._datasetIndex];
		var index = element._index;
		var custom = element.custom || {};
		var model = element._model;
		var getHoverColor = helpers$1.getHoverColor;

		element.$previousStyle = {
			backgroundColor: model.backgroundColor,
			borderColor: model.borderColor,
			borderWidth: model.borderWidth
		};

		model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
		model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
		model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
	},

	/**
	 * @private
	 */
	resyncElements: function() {
		var me = this;
		var meta = me.getMeta();
		var data = me.getDataset().data;
		var numMeta = meta.data.length;
		var numData = data.length;

		if (numData < numMeta) {
			meta.data.splice(numData, numMeta - numData);
		} else if (numData > numMeta) {
			me.insertElements(numMeta, numData - numMeta);
		}
	},

	/**
	 * @private
	 */
	insertElements: function(start, count) {
		for (var i = 0; i < count; ++i) {
			this.addElementAndReset(start + i);
		}
	},

	/**
	 * @private
	 */
	onDataPush: function() {
		var count = arguments.length;
		this.insertElements(this.getDataset().data.length - count, count);
	},

	/**
	 * @private
	 */
	onDataPop: function() {
		this.getMeta().data.pop();
	},

	/**
	 * @private
	 */
	onDataShift: function() {
		this.getMeta().data.shift();
	},

	/**
	 * @private
	 */
	onDataSplice: function(start, count) {
		this.getMeta().data.splice(start, count);
		this.insertElements(start, arguments.length - 2);
	},

	/**
	 * @private
	 */
	onDataUnshift: function() {
		this.insertElements(0, arguments.length);
	}
});

DatasetController.extend = helpers$1.inherits;

var core_datasetController = DatasetController;

core_defaults._set('global', {
	elements: {
		arc: {
			backgroundColor: core_defaults.global.defaultColor,
			borderColor: '#fff',
			borderWidth: 2,
			borderAlign: 'center'
		}
	}
});

var element_arc = core_element.extend({
	inLabelRange: function(mouseX) {
		var vm = this._view;

		if (vm) {
			return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
		}
		return false;
	},

	inRange: function(chartX, chartY) {
		var vm = this._view;

		if (vm) {
			var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x: chartX, y: chartY});
			var	angle = pointRelativePosition.angle;
			var distance = pointRelativePosition.distance;

			// Sanitise angle range
			var startAngle = vm.startAngle;
			var endAngle = vm.endAngle;
			while (endAngle < startAngle) {
				endAngle += 2.0 * Math.PI;
			}
			while (angle > endAngle) {
				angle -= 2.0 * Math.PI;
			}
			while (angle < startAngle) {
				angle += 2.0 * Math.PI;
			}

			// Check if within the range of the open/close angle
			var betweenAngles = (angle >= startAngle && angle <= endAngle);
			var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

			return (betweenAngles && withinRadius);
		}
		return false;
	},

	getCenterPoint: function() {
		var vm = this._view;
		var halfAngle = (vm.startAngle + vm.endAngle) / 2;
		var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
		return {
			x: vm.x + Math.cos(halfAngle) * halfRadius,
			y: vm.y + Math.sin(halfAngle) * halfRadius
		};
	},

	getArea: function() {
		var vm = this._view;
		return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
	},

	tooltipPosition: function() {
		var vm = this._view;
		var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
		var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

		return {
			x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
			y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
		};
	},

	draw: function() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var sA = vm.startAngle;
		var eA = vm.endAngle;
		var pixelMargin = (vm.borderAlign === 'inner') ? 0.33 : 0;
		var angleMargin;

		ctx.save();

		ctx.beginPath();
		ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
		ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
		ctx.closePath();

		ctx.fillStyle = vm.backgroundColor;
		ctx.fill();

		if (vm.borderWidth) {
			if (vm.borderAlign === 'inner') {
				// Draw an inner border by cliping the arc and drawing a double-width border
				// Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
				ctx.beginPath();
				angleMargin = pixelMargin / vm.outerRadius;
				ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);
				if (vm.innerRadius > pixelMargin) {
					angleMargin = pixelMargin / vm.innerRadius;
					ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
				} else {
					ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
				}
				ctx.closePath();
				ctx.clip();

				ctx.beginPath();
				ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
				ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
				ctx.closePath();

				ctx.lineWidth = vm.borderWidth * 2;
				ctx.lineJoin = 'round';
			} else {
				ctx.lineWidth = vm.borderWidth;
				ctx.lineJoin = 'bevel';
			}

			ctx.strokeStyle = vm.borderColor;
			ctx.stroke();
		}

		ctx.restore();
	}
});

var valueOrDefault$1 = helpers$1.valueOrDefault;

var defaultColor = core_defaults.global.defaultColor;

core_defaults._set('global', {
	elements: {
		line: {
			tension: 0.4,
			backgroundColor: defaultColor,
			borderWidth: 3,
			borderColor: defaultColor,
			borderCapStyle: 'butt',
			borderDash: [],
			borderDashOffset: 0.0,
			borderJoinStyle: 'miter',
			capBezierPoints: true,
			fill: true, // do we fill in the area between the line and its base axis
		}
	}
});

var element_line = core_element.extend({
	draw: function() {
		var me = this;
		var vm = me._view;
		var ctx = me._chart.ctx;
		var spanGaps = vm.spanGaps;
		var points = me._children.slice(); // clone array
		var globalDefaults = core_defaults.global;
		var globalOptionLineElements = globalDefaults.elements.line;
		var lastDrawnIndex = -1;
		var index, current, previous, currentVM;

		// If we are looping, adding the first point again
		if (me._loop && points.length) {
			points.push(points[0]);
		}

		ctx.save();

		// Stroke Line Options
		ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

		// IE 9 and 10 do not support line dash
		if (ctx.setLineDash) {
			ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
		}

		ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
		ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
		ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
		ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

		// Stroke Line
		ctx.beginPath();
		lastDrawnIndex = -1;

		for (index = 0; index < points.length; ++index) {
			current = points[index];
			previous = helpers$1.previousItem(points, index);
			currentVM = current._view;

			// First point moves to it's starting position no matter what
			if (index === 0) {
				if (!currentVM.skip) {
					ctx.moveTo(currentVM.x, currentVM.y);
					lastDrawnIndex = index;
				}
			} else {
				previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

				if (!currentVM.skip) {
					if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
						// There was a gap and this is the first point after the gap
						ctx.moveTo(currentVM.x, currentVM.y);
					} else {
						// Line to next point
						helpers$1.canvas.lineTo(ctx, previous._view, current._view);
					}
					lastDrawnIndex = index;
				}
			}
		}

		ctx.stroke();
		ctx.restore();
	}
});

var valueOrDefault$2 = helpers$1.valueOrDefault;

var defaultColor$1 = core_defaults.global.defaultColor;

core_defaults._set('global', {
	elements: {
		point: {
			radius: 3,
			pointStyle: 'circle',
			backgroundColor: defaultColor$1,
			borderColor: defaultColor$1,
			borderWidth: 1,
			// Hover
			hitRadius: 1,
			hoverRadius: 4,
			hoverBorderWidth: 1
		}
	}
});

function xRange(mouseX) {
	var vm = this._view;
	return vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
}

function yRange(mouseY) {
	var vm = this._view;
	return vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
}

var element_point = core_element.extend({
	inRange: function(mouseX, mouseY) {
		var vm = this._view;
		return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
	},

	inLabelRange: xRange,
	inXRange: xRange,
	inYRange: yRange,

	getCenterPoint: function() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y
		};
	},

	getArea: function() {
		return Math.PI * Math.pow(this._view.radius, 2);
	},

	tooltipPosition: function() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y,
			padding: vm.radius + vm.borderWidth
		};
	},

	draw: function(chartArea) {
		var vm = this._view;
		var ctx = this._chart.ctx;
		var pointStyle = vm.pointStyle;
		var rotation = vm.rotation;
		var radius = vm.radius;
		var x = vm.x;
		var y = vm.y;
		var globalDefaults = core_defaults.global;
		var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

		if (vm.skip) {
			return;
		}

		// Clipping for Points.
		if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
			ctx.strokeStyle = vm.borderColor || defaultColor;
			ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
			ctx.fillStyle = vm.backgroundColor || defaultColor;
			helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
		}
	}
});

var defaultColor$2 = core_defaults.global.defaultColor;

core_defaults._set('global', {
	elements: {
		rectangle: {
			backgroundColor: defaultColor$2,
			borderColor: defaultColor$2,
			borderSkipped: 'bottom',
			borderWidth: 0
		}
	}
});

function isVertical(vm) {
	return vm && vm.width !== undefined;
}

/**
 * Helper function to get the bounds of the bar regardless of the orientation
 * @param bar {Chart.Element.Rectangle} the bar
 * @return {Bounds} bounds of the bar
 * @private
 */
function getBarBounds(vm) {
	var x1, x2, y1, y2, half;

	if (isVertical(vm)) {
		half = vm.width / 2;
		x1 = vm.x - half;
		x2 = vm.x + half;
		y1 = Math.min(vm.y, vm.base);
		y2 = Math.max(vm.y, vm.base);
	} else {
		half = vm.height / 2;
		x1 = Math.min(vm.x, vm.base);
		x2 = Math.max(vm.x, vm.base);
		y1 = vm.y - half;
		y2 = vm.y + half;
	}

	return {
		left: x1,
		top: y1,
		right: x2,
		bottom: y2
	};
}

function swap(orig, v1, v2) {
	return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}

function parseBorderSkipped(vm) {
	var edge = vm.borderSkipped;
	var res = {};

	if (!edge) {
		return res;
	}

	if (vm.horizontal) {
		if (vm.base > vm.x) {
			edge = swap(edge, 'left', 'right');
		}
	} else if (vm.base < vm.y) {
		edge = swap(edge, 'bottom', 'top');
	}

	res[edge] = true;
	return res;
}

function parseBorderWidth(vm, maxW, maxH) {
	var value = vm.borderWidth;
	var skip = parseBorderSkipped(vm);
	var t, r, b, l;

	if (helpers$1.isObject(value)) {
		t = +value.top || 0;
		r = +value.right || 0;
		b = +value.bottom || 0;
		l = +value.left || 0;
	} else {
		t = r = b = l = +value || 0;
	}

	return {
		t: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,
		r: skip.right || (r < 0) ? 0 : r > maxW ? maxW : r,
		b: skip.bottom || (b < 0) ? 0 : b > maxH ? maxH : b,
		l: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l
	};
}

function boundingRects(vm) {
	var bounds = getBarBounds(vm);
	var width = bounds.right - bounds.left;
	var height = bounds.bottom - bounds.top;
	var border = parseBorderWidth(vm, width / 2, height / 2);

	return {
		outer: {
			x: bounds.left,
			y: bounds.top,
			w: width,
			h: height
		},
		inner: {
			x: bounds.left + border.l,
			y: bounds.top + border.t,
			w: width - border.l - border.r,
			h: height - border.t - border.b
		}
	};
}

function inRange(vm, x, y) {
	var skipX = x === null;
	var skipY = y === null;
	var bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);

	return bounds
		&& (skipX || x >= bounds.left && x <= bounds.right)
		&& (skipY || y >= bounds.top && y <= bounds.bottom);
}

var element_rectangle = core_element.extend({
	draw: function() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var rects = boundingRects(vm);
		var outer = rects.outer;
		var inner = rects.inner;

		ctx.fillStyle = vm.backgroundColor;
		ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

		if (outer.w === inner.w && outer.h === inner.h) {
			return;
		}

		ctx.save();
		ctx.beginPath();
		ctx.rect(outer.x, outer.y, outer.w, outer.h);
		ctx.clip();
		ctx.fillStyle = vm.borderColor;
		ctx.rect(inner.x, inner.y, inner.w, inner.h);
		ctx.fill('evenodd');
		ctx.restore();
	},

	height: function() {
		var vm = this._view;
		return vm.base - vm.y;
	},

	inRange: function(mouseX, mouseY) {
		return inRange(this._view, mouseX, mouseY);
	},

	inLabelRange: function(mouseX, mouseY) {
		var vm = this._view;
		return isVertical(vm)
			? inRange(vm, mouseX, null)
			: inRange(vm, null, mouseY);
	},

	inXRange: function(mouseX) {
		return inRange(this._view, mouseX, null);
	},

	inYRange: function(mouseY) {
		return inRange(this._view, null, mouseY);
	},

	getCenterPoint: function() {
		var vm = this._view;
		var x, y;
		if (isVertical(vm)) {
			x = vm.x;
			y = (vm.y + vm.base) / 2;
		} else {
			x = (vm.x + vm.base) / 2;
			y = vm.y;
		}

		return {x: x, y: y};
	},

	getArea: function() {
		var vm = this._view;

		return isVertical(vm)
			? vm.width * Math.abs(vm.y - vm.base)
			: vm.height * Math.abs(vm.x - vm.base);
	},

	tooltipPosition: function() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y
		};
	}
});

var elements = {};
var Arc = element_arc;
var Line = element_line;
var Point = element_point;
var Rectangle = element_rectangle;
elements.Arc = Arc;
elements.Line = Line;
elements.Point = Point;
elements.Rectangle = Rectangle;

var resolve$1 = helpers$1.options.resolve;

core_defaults._set('bar', {
	hover: {
		mode: 'label'
	},

	scales: {
		xAxes: [{
			type: 'category',
			categoryPercentage: 0.8,
			barPercentage: 0.9,
			offset: true,
			gridLines: {
				offsetGridLines: true
			}
		}],

		yAxes: [{
			type: 'linear'
		}]
	}
});

/**
 * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
 * @private
 */
function computeMinSampleSize(scale, pixels) {
	var min = scale.isHorizontal() ? scale.width : scale.height;
	var ticks = scale.getTicks();
	var prev, curr, i, ilen;

	for (i = 1, ilen = pixels.length; i < ilen; ++i) {
		min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
	}

	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
		curr = scale.getPixelForTick(i);
		min = i > 0 ? Math.min(min, curr - prev) : min;
		prev = curr;
	}

	return min;
}

/**
 * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
 * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
 * mode currently always generates bars equally sized (until we introduce scriptable options?).
 * @private
 */
function computeFitCategoryTraits(index, ruler, options) {
	var thickness = options.barThickness;
	var count = ruler.stackCount;
	var curr = ruler.pixels[index];
	var size, ratio;

	if (helpers$1.isNullOrUndef(thickness)) {
		size = ruler.min * options.categoryPercentage;
		ratio = options.barPercentage;
	} else {
		// When bar thickness is enforced, category and bar percentages are ignored.
		// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
		// and deprecate barPercentage since this value is ignored when thickness is absolute.
		size = thickness * count;
		ratio = 1;
	}

	return {
		chunk: size / count,
		ratio: ratio,
		start: curr - (size / 2)
	};
}

/**
 * Computes an "optimal" category that globally arranges bars side by side (no gap when
 * percentage options are 1), based on the previous and following categories. This mode
 * generates bars with different widths when data are not evenly spaced.
 * @private
 */
function computeFlexCategoryTraits(index, ruler, options) {
	var pixels = ruler.pixels;
	var curr = pixels[index];
	var prev = index > 0 ? pixels[index - 1] : null;
	var next = index < pixels.length - 1 ? pixels[index + 1] : null;
	var percent = options.categoryPercentage;
	var start, size;

	if (prev === null) {
		// first data: its size is double based on the next point or,
		// if it's also the last data, we use the scale size.
		prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
	}

	if (next === null) {
		// last data: its size is also double based on the previous point.
		next = curr + curr - prev;
	}

	start = curr - (curr - Math.min(prev, next)) / 2 * percent;
	size = Math.abs(next - prev) / 2 * percent;

	return {
		chunk: size / ruler.stackCount,
		ratio: options.barPercentage,
		start: start
	};
}

var controller_bar = core_datasetController.extend({

	dataElementType: elements.Rectangle,

	initialize: function() {
		var me = this;
		var meta;

		core_datasetController.prototype.initialize.apply(me, arguments);

		meta = me.getMeta();
		meta.stack = me.getDataset().stack;
		meta.bar = true;
	},

	update: function(reset) {
		var me = this;
		var rects = me.getMeta().data;
		var i, ilen;

		me._ruler = me.getRuler();

		for (i = 0, ilen = rects.length; i < ilen; ++i) {
			me.updateElement(rects[i], i, reset);
		}
	},

	updateElement: function(rectangle, index, reset) {
		var me = this;
		var meta = me.getMeta();
		var dataset = me.getDataset();
		var options = me._resolveElementOptions(rectangle, index);

		rectangle._xScale = me.getScaleForId(meta.xAxisID);
		rectangle._yScale = me.getScaleForId(meta.yAxisID);
		rectangle._datasetIndex = me.index;
		rectangle._index = index;
		rectangle._model = {
			backgroundColor: options.backgroundColor,
			borderColor: options.borderColor,
			borderSkipped: options.borderSkipped,
			borderWidth: options.borderWidth,
			datasetLabel: dataset.label,
			label: me.chart.data.labels[index]
		};

		me._updateElementGeometry(rectangle, index, reset);

		rectangle.pivot();
	},

	/**
	 * @private
	 */
	_updateElementGeometry: function(rectangle, index, reset) {
		var me = this;
		var model = rectangle._model;
		var vscale = me._getValueScale();
		var base = vscale.getBasePixel();
		var horizontal = vscale.isHorizontal();
		var ruler = me._ruler || me.getRuler();
		var vpixels = me.calculateBarValuePixels(me.index, index);
		var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

		model.horizontal = horizontal;
		model.base = reset ? base : vpixels.base;
		model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
		model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
		model.height = horizontal ? ipixels.size : undefined;
		model.width = horizontal ? undefined : ipixels.size;
	},

	/**
	 * Returns the stacks based on groups and bar visibility.
	 * @param {number} [last] - The dataset index
	 * @returns {string[]} The list of stack IDs
	 * @private
	 */
	_getStacks: function(last) {
		var me = this;
		var chart = me.chart;
		var scale = me._getIndexScale();
		var stacked = scale.options.stacked;
		var ilen = last === undefined ? chart.data.datasets.length : last + 1;
		var stacks = [];
		var i, meta;

		for (i = 0; i < ilen; ++i) {
			meta = chart.getDatasetMeta(i);
			if (meta.bar && chart.isDatasetVisible(i) &&
				(stacked === false ||
				(stacked === true && stacks.indexOf(meta.stack) === -1) ||
				(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
				stacks.push(meta.stack);
			}
		}

		return stacks;
	},

	/**
	 * Returns the effective number of stacks based on groups and bar visibility.
	 * @private
	 */
	getStackCount: function() {
		return this._getStacks().length;
	},

	/**
	 * Returns the stack index for the given dataset based on groups and bar visibility.
	 * @param {number} [datasetIndex] - The dataset index
	 * @param {string} [name] - The stack name to find
	 * @returns {number} The stack index
	 * @private
	 */
	getStackIndex: function(datasetIndex, name) {
		var stacks = this._getStacks(datasetIndex);
		var index = (name !== undefined)
			? stacks.indexOf(name)
			: -1; // indexOf returns -1 if element is not present

		return (index === -1)
			? stacks.length - 1
			: index;
	},

	/**
	 * @private
	 */
	getRuler: function() {
		var me = this;
		var scale = me._getIndexScale();
		var stackCount = me.getStackCount();
		var datasetIndex = me.index;
		var isHorizontal = scale.isHorizontal();
		var start = isHorizontal ? scale.left : scale.top;
		var end = start + (isHorizontal ? scale.width : scale.height);
		var pixels = [];
		var i, ilen, min;

		for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
			pixels.push(scale.getPixelForValue(null, i, datasetIndex));
		}

		min = helpers$1.isNullOrUndef(scale.options.barThickness)
			? computeMinSampleSize(scale, pixels)
			: -1;

		return {
			min: min,
			pixels: pixels,
			start: start,
			end: end,
			stackCount: stackCount,
			scale: scale
		};
	},

	/**
	 * Note: pixel values are not clamped to the scale area.
	 * @private
	 */
	calculateBarValuePixels: function(datasetIndex, index) {
		var me = this;
		var chart = me.chart;
		var meta = me.getMeta();
		var scale = me._getValueScale();
		var isHorizontal = scale.isHorizontal();
		var datasets = chart.data.datasets;
		var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
		var minBarLength = scale.options.minBarLength;
		var stacked = scale.options.stacked;
		var stack = meta.stack;
		var start = 0;
		var i, imeta, ivalue, base, head, size;

		if (stacked || (stacked === undefined && stack !== undefined)) {
			for (i = 0; i < datasetIndex; ++i) {
				imeta = chart.getDatasetMeta(i);

				if (imeta.bar &&
					imeta.stack === stack &&
					imeta.controller._getValueScaleId() === scale.id &&
					chart.isDatasetVisible(i)) {

					ivalue = +scale.getRightValue(datasets[i].data[index]);
					if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
						start += ivalue;
					}
				}
			}
		}

		base = scale.getPixelForValue(start);
		head = scale.getPixelForValue(start + value);
		size = head - base;

		if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
			size = minBarLength;
			if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
				head = base - minBarLength;
			} else {
				head = base + minBarLength;
			}
		}

		return {
			size: size,
			base: base,
			head: head,
			center: head + size / 2
		};
	},

	/**
	 * @private
	 */
	calculateBarIndexPixels: function(datasetIndex, index, ruler) {
		var me = this;
		var options = ruler.scale.options;
		var range = options.barThickness === 'flex'
			? computeFlexCategoryTraits(index, ruler, options)
			: computeFitCategoryTraits(index, ruler, options);

		var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
		var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
		var size = Math.min(
			helpers$1.valueOrDefault(options.maxBarThickness, Infinity),
			range.chunk * range.ratio);

		return {
			base: center - size / 2,
			head: center + size / 2,
			center: center,
			size: size
		};
	},

	draw: function() {
		var me = this;
		var chart = me.chart;
		var scale = me._getValueScale();
		var rects = me.getMeta().data;
		var dataset = me.getDataset();
		var ilen = rects.length;
		var i = 0;

		helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

		for (; i < ilen; ++i) {
			if (!isNaN(scale.getRightValue(dataset.data[i]))) {
				rects[i].draw();
			}
		}

		helpers$1.canvas.unclipArea(chart.ctx);
	},

	/**
	 * @private
	 */
	_resolveElementOptions: function(rectangle, index) {
		var me = this;
		var chart = me.chart;
		var datasets = chart.data.datasets;
		var dataset = datasets[me.index];
		var custom = rectangle.custom || {};
		var options = chart.options.elements.rectangle;
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var keys = [
			'backgroundColor',
			'borderColor',
			'borderSkipped',
			'borderWidth'
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$1([
				custom[key],
				dataset[key],
				options[key]
			], context, index);
		}

		return values;
	}
});

var valueOrDefault$3 = helpers$1.valueOrDefault;
var resolve$2 = helpers$1.options.resolve;

core_defaults._set('bubble', {
	hover: {
		mode: 'single'
	},

	scales: {
		xAxes: [{
			type: 'linear', // bubble should probably use a linear scale by default
			position: 'bottom',
			id: 'x-axis-0' // need an ID so datasets can reference the scale
		}],
		yAxes: [{
			type: 'linear',
			position: 'left',
			id: 'y-axis-0'
		}]
	},

	tooltips: {
		callbacks: {
			title: function() {
				// Title doesn't make sense for scatter since we format the data as a point
				return '';
			},
			label: function(item, data) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				var dataPoint = data.datasets[item.datasetIndex].data[item.index];
				return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
			}
		}
	}
});

var controller_bubble = core_datasetController.extend({
	/**
	 * @protected
	 */
	dataElementType: elements.Point,

	/**
	 * @protected
	 */
	update: function(reset) {
		var me = this;
		var meta = me.getMeta();
		var points = meta.data;

		// Update Points
		helpers$1.each(points, function(point, index) {
			me.updateElement(point, index, reset);
		});
	},

	/**
	 * @protected
	 */
	updateElement: function(point, index, reset) {
		var me = this;
		var meta = me.getMeta();
		var custom = point.custom || {};
		var xScale = me.getScaleForId(meta.xAxisID);
		var yScale = me.getScaleForId(meta.yAxisID);
		var options = me._resolveElementOptions(point, index);
		var data = me.getDataset().data[index];
		var dsIndex = me.index;

		var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
		var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

		point._xScale = xScale;
		point._yScale = yScale;
		point._options = options;
		point._datasetIndex = dsIndex;
		point._index = index;
		point._model = {
			backgroundColor: options.backgroundColor,
			borderColor: options.borderColor,
			borderWidth: options.borderWidth,
			hitRadius: options.hitRadius,
			pointStyle: options.pointStyle,
			rotation: options.rotation,
			radius: reset ? 0 : options.radius,
			skip: custom.skip || isNaN(x) || isNaN(y),
			x: x,
			y: y,
		};

		point.pivot();
	},

	/**
	 * @protected
	 */
	setHoverStyle: function(point) {
		var model = point._model;
		var options = point._options;
		var getHoverColor = helpers$1.getHoverColor;

		point.$previousStyle = {
			backgroundColor: model.backgroundColor,
			borderColor: model.borderColor,
			borderWidth: model.borderWidth,
			radius: model.radius
		};

		model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
		model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
		model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
		model.radius = options.radius + options.hoverRadius;
	},

	/**
	 * @private
	 */
	_resolveElementOptions: function(point, index) {
		var me = this;
		var chart = me.chart;
		var datasets = chart.data.datasets;
		var dataset = datasets[me.index];
		var custom = point.custom || {};
		var options = chart.options.elements.point;
		var data = dataset.data[index];
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var keys = [
			'backgroundColor',
			'borderColor',
			'borderWidth',
			'hoverBackgroundColor',
			'hoverBorderColor',
			'hoverBorderWidth',
			'hoverRadius',
			'hitRadius',
			'pointStyle',
			'rotation'
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$2([
				custom[key],
				dataset[key],
				options[key]
			], context, index);
		}

		// Custom radius resolution
		values.radius = resolve$2([
			custom.radius,
			data ? data.r : undefined,
			dataset.radius,
			options.radius
		], context, index);

		return values;
	}
});

var resolve$3 = helpers$1.options.resolve;
var valueOrDefault$4 = helpers$1.valueOrDefault;

core_defaults._set('doughnut', {
	animation: {
		// Boolean - Whether we animate the rotation of the Doughnut
		animateRotate: true,
		// Boolean - Whether we animate scaling the Doughnut from the centre
		animateScale: false
	},
	hover: {
		mode: 'single'
	},
	legendCallback: function(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = data.datasets;
		var labels = data.labels;

		if (datasets.length) {
			for (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				if (labels[i]) {
					text.push(labels[i]);
				}
				text.push('</li>');
			}
		}

		text.push('</ul>');
		return text.join('');
	},
	legend: {
		labels: {
			generateLabels: function(chart) {
				var data = chart.data;
				if (data.labels.length && data.datasets.length) {
					return data.labels.map(function(label, i) {
						var meta = chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc && arc.custom || {};
						var arcOpts = chart.options.elements.arc;
						var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
						var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
						var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);

						return {
							text: label,
							fillStyle: fill,
							strokeStyle: stroke,
							lineWidth: bw,
							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Extra data used for toggling the correct item
							index: i
						};
					});
				}
				return [];
			}
		},

		onClick: function(e, legendItem) {
			var index = legendItem.index;
			var chart = this.chart;
			var i, ilen, meta;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				// toggle visibility of index if exists
				if (meta.data[index]) {
					meta.data[index].hidden = !meta.data[index].hidden;
				}
			}

			chart.update();
		}
	},

	// The percentage of the chart that we cut out of the middle.
	cutoutPercentage: 50,

	// The rotation of the chart, where the first data arc begins.
	rotation: Math.PI * -0.5,

	// The total circumference of the chart.
	circumference: Math.PI * 2.0,

	// Need to override these to give a nice default
	tooltips: {
		callbacks: {
			title: function() {
				return '';
			},
			label: function(tooltipItem, data) {
				var dataLabel = data.labels[tooltipItem.index];
				var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

				if (helpers$1.isArray(dataLabel)) {
					// show value on first line of multiline label
					// need to clone because we are changing the value
					dataLabel = dataLabel.slice();
					dataLabel[0] += value;
				} else {
					dataLabel += value;
				}

				return dataLabel;
			}
		}
	}
});

var controller_doughnut = core_datasetController.extend({

	dataElementType: elements.Arc,

	linkScales: helpers$1.noop,

	// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
	getRingIndex: function(datasetIndex) {
		var ringIndex = 0;

		for (var j = 0; j < datasetIndex; ++j) {
			if (this.chart.isDatasetVisible(j)) {
				++ringIndex;
			}
		}

		return ringIndex;
	},

	update: function(reset) {
		var me = this;
		var chart = me.chart;
		var chartArea = chart.chartArea;
		var opts = chart.options;
		var availableWidth = chartArea.right - chartArea.left;
		var availableHeight = chartArea.bottom - chartArea.top;
		var minSize = Math.min(availableWidth, availableHeight);
		var offset = {x: 0, y: 0};
		var meta = me.getMeta();
		var arcs = meta.data;
		var cutoutPercentage = opts.cutoutPercentage;
		var circumference = opts.circumference;
		var chartWeight = me._getRingWeight(me.index);
		var i, ilen;

		// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
		if (circumference < Math.PI * 2.0) {
			var startAngle = opts.rotation % (Math.PI * 2.0);
			startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
			var endAngle = startAngle + circumference;
			var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
			var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
			var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
			var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
			var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
			var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
			var cutout = cutoutPercentage / 100.0;
			var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
			var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
			var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
			minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
			offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
		}

		for (i = 0, ilen = arcs.length; i < ilen; ++i) {
			arcs[i]._options = me._resolveElementOptions(arcs[i], i);
		}

		chart.borderWidth = me.getMaxBorderWidth();
		chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
		chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
		chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
		chart.offsetX = offset.x * chart.outerRadius;
		chart.offsetY = offset.y * chart.outerRadius;

		meta.total = me.calculateTotal();

		me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
		me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

		for (i = 0, ilen = arcs.length; i < ilen; ++i) {
			me.updateElement(arcs[i], i, reset);
		}
	},

	updateElement: function(arc, index, reset) {
		var me = this;
		var chart = me.chart;
		var chartArea = chart.chartArea;
		var opts = chart.options;
		var animationOpts = opts.animation;
		var centerX = (chartArea.left + chartArea.right) / 2;
		var centerY = (chartArea.top + chartArea.bottom) / 2;
		var startAngle = opts.rotation; // non reset case handled later
		var endAngle = opts.rotation; // non reset case handled later
		var dataset = me.getDataset();
		var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
		var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
		var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
		var options = arc._options || {};

		helpers$1.extend(arc, {
			// Utility
			_datasetIndex: me.index,
			_index: index,

			// Desired view properties
			_model: {
				backgroundColor: options.backgroundColor,
				borderColor: options.borderColor,
				borderWidth: options.borderWidth,
				borderAlign: options.borderAlign,
				x: centerX + chart.offsetX,
				y: centerY + chart.offsetY,
				startAngle: startAngle,
				endAngle: endAngle,
				circumference: circumference,
				outerRadius: outerRadius,
				innerRadius: innerRadius,
				label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
			}
		});

		var model = arc._model;

		// Set correct angles if not resetting
		if (!reset || !animationOpts.animateRotate) {
			if (index === 0) {
				model.startAngle = opts.rotation;
			} else {
				model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
			}

			model.endAngle = model.startAngle + model.circumference;
		}

		arc.pivot();
	},

	calculateTotal: function() {
		var dataset = this.getDataset();
		var meta = this.getMeta();
		var total = 0;
		var value;

		helpers$1.each(meta.data, function(element, index) {
			value = dataset.data[index];
			if (!isNaN(value) && !element.hidden) {
				total += Math.abs(value);
			}
		});

		/* if (total === 0) {
			total = NaN;
		}*/

		return total;
	},

	calculateCircumference: function(value) {
		var total = this.getMeta().total;
		if (total > 0 && !isNaN(value)) {
			return (Math.PI * 2.0) * (Math.abs(value) / total);
		}
		return 0;
	},

	// gets the max border or hover width to properly scale pie charts
	getMaxBorderWidth: function(arcs) {
		var me = this;
		var max = 0;
		var chart = me.chart;
		var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

		if (!arcs) {
			// Find the outmost visible dataset
			for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
				if (chart.isDatasetVisible(i)) {
					meta = chart.getDatasetMeta(i);
					arcs = meta.data;
					if (i !== me.index) {
						controller = meta.controller;
					}
					break;
				}
			}
		}

		if (!arcs) {
			return 0;
		}

		for (i = 0, ilen = arcs.length; i < ilen; ++i) {
			arc = arcs[i];
			options = controller ? controller._resolveElementOptions(arc, i) : arc._options;
			if (options.borderAlign !== 'inner') {
				borderWidth = options.borderWidth;
				hoverWidth = options.hoverBorderWidth;

				max = borderWidth > max ? borderWidth : max;
				max = hoverWidth > max ? hoverWidth : max;
			}
		}
		return max;
	},

	/**
	 * @protected
	 */
	setHoverStyle: function(arc) {
		var model = arc._model;
		var options = arc._options;
		var getHoverColor = helpers$1.getHoverColor;

		arc.$previousStyle = {
			backgroundColor: model.backgroundColor,
			borderColor: model.borderColor,
			borderWidth: model.borderWidth,
		};

		model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
		model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
		model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
	},

	/**
	 * @private
	 */
	_resolveElementOptions: function(arc, index) {
		var me = this;
		var chart = me.chart;
		var dataset = me.getDataset();
		var custom = arc.custom || {};
		var options = chart.options.elements.arc;
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var keys = [
			'backgroundColor',
			'borderColor',
			'borderWidth',
			'borderAlign',
			'hoverBackgroundColor',
			'hoverBorderColor',
			'hoverBorderWidth',
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$3([
				custom[key],
				dataset[key],
				options[key]
			], context, index);
		}

		return values;
	},

	/**
	 * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
	 * @private
	 */
	_getRingWeightOffset: function(datasetIndex) {
		var ringWeightOffset = 0;

		for (var i = 0; i < datasetIndex; ++i) {
			if (this.chart.isDatasetVisible(i)) {
				ringWeightOffset += this._getRingWeight(i);
			}
		}

		return ringWeightOffset;
	},

	/**
	 * @private
	 */
	_getRingWeight: function(dataSetIndex) {
		return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
	},

	/**
	 * Returns the sum of all visibile data set weights.  This value can be 0.
	 * @private
	 */
	_getVisibleDatasetWeightTotal: function() {
		return this._getRingWeightOffset(this.chart.data.datasets.length);
	}
});

core_defaults._set('horizontalBar', {
	hover: {
		mode: 'index',
		axis: 'y'
	},

	scales: {
		xAxes: [{
			type: 'linear',
			position: 'bottom'
		}],

		yAxes: [{
			type: 'category',
			position: 'left',
			categoryPercentage: 0.8,
			barPercentage: 0.9,
			offset: true,
			gridLines: {
				offsetGridLines: true
			}
		}]
	},

	elements: {
		rectangle: {
			borderSkipped: 'left'
		}
	},

	tooltips: {
		mode: 'index',
		axis: 'y'
	}
});

var controller_horizontalBar = controller_bar.extend({
	/**
	 * @private
	 */
	_getValueScaleId: function() {
		return this.getMeta().xAxisID;
	},

	/**
	 * @private
	 */
	_getIndexScaleId: function() {
		return this.getMeta().yAxisID;
	}
});

var valueOrDefault$5 = helpers$1.valueOrDefault;
var resolve$4 = helpers$1.options.resolve;
var isPointInArea = helpers$1.canvas._isPointInArea;

core_defaults._set('line', {
	showLines: true,
	spanGaps: false,

	hover: {
		mode: 'label'
	},

	scales: {
		xAxes: [{
			type: 'category',
			id: 'x-axis-0'
		}],
		yAxes: [{
			type: 'linear',
			id: 'y-axis-0'
		}]
	}
});

function lineEnabled(dataset, options) {
	return valueOrDefault$5(dataset.showLine, options.showLines);
}

var controller_line = core_datasetController.extend({

	datasetElementType: elements.Line,

	dataElementType: elements.Point,

	update: function(reset) {
		var me = this;
		var meta = me.getMeta();
		var line = meta.dataset;
		var points = meta.data || [];
		var scale = me.getScaleForId(meta.yAxisID);
		var dataset = me.getDataset();
		var showLine = lineEnabled(dataset, me.chart.options);
		var i, ilen;

		// Update Line
		if (showLine) {
			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
				dataset.lineTension = dataset.tension;
			}

			// Utility
			line._scale = scale;
			line._datasetIndex = me.index;
			// Data
			line._children = points;
			// Model
			line._model = me._resolveLineOptions(line);

			line.pivot();
		}

		// Update Points
		for (i = 0, ilen = points.length; i < ilen; ++i) {
			me.updateElement(points[i], i, reset);
		}

		if (showLine && line._model.tension !== 0) {
			me.updateBezierControlPoints();
		}

		// Now pivot the point for animation
		for (i = 0, ilen = points.length; i < ilen; ++i) {
			points[i].pivot();
		}
	},

	updateElement: function(point, index, reset) {
		var me = this;
		var meta = me.getMeta();
		var custom = point.custom || {};
		var dataset = me.getDataset();
		var datasetIndex = me.index;
		var value = dataset.data[index];
		var yScale = me.getScaleForId(meta.yAxisID);
		var xScale = me.getScaleForId(meta.xAxisID);
		var lineModel = meta.dataset._model;
		var x, y;

		var options = me._resolvePointOptions(point, index);

		x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
		y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

		// Utility
		point._xScale = xScale;
		point._yScale = yScale;
		point._options = options;
		point._datasetIndex = datasetIndex;
		point._index = index;

		// Desired view properties
		point._model = {
			x: x,
			y: y,
			skip: custom.skip || isNaN(x) || isNaN(y),
			// Appearance
			radius: options.radius,
			pointStyle: options.pointStyle,
			rotation: options.rotation,
			backgroundColor: options.backgroundColor,
			borderColor: options.borderColor,
			borderWidth: options.borderWidth,
			tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
			steppedLine: lineModel ? lineModel.steppedLine : false,
			// Tooltip
			hitRadius: options.hitRadius
		};
	},

	/**
	 * @private
	 */
	_resolvePointOptions: function(element, index) {
		var me = this;
		var chart = me.chart;
		var dataset = chart.data.datasets[me.index];
		var custom = element.custom || {};
		var options = chart.options.elements.point;
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var ELEMENT_OPTIONS = {
			backgroundColor: 'pointBackgroundColor',
			borderColor: 'pointBorderColor',
			borderWidth: 'pointBorderWidth',
			hitRadius: 'pointHitRadius',
			hoverBackgroundColor: 'pointHoverBackgroundColor',
			hoverBorderColor: 'pointHoverBorderColor',
			hoverBorderWidth: 'pointHoverBorderWidth',
			hoverRadius: 'pointHoverRadius',
			pointStyle: 'pointStyle',
			radius: 'pointRadius',
			rotation: 'pointRotation'
		};
		var keys = Object.keys(ELEMENT_OPTIONS);

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$4([
				custom[key],
				dataset[ELEMENT_OPTIONS[key]],
				dataset[key],
				options[key]
			], context, index);
		}

		return values;
	},

	/**
	 * @private
	 */
	_resolveLineOptions: function(element) {
		var me = this;
		var chart = me.chart;
		var dataset = chart.data.datasets[me.index];
		var custom = element.custom || {};
		var options = chart.options;
		var elementOptions = options.elements.line;
		var values = {};
		var i, ilen, key;

		var keys = [
			'backgroundColor',
			'borderWidth',
			'borderColor',
			'borderCapStyle',
			'borderDash',
			'borderDashOffset',
			'borderJoinStyle',
			'fill',
			'cubicInterpolationMode'
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$4([
				custom[key],
				dataset[key],
				elementOptions[key]
			]);
		}

		// The default behavior of lines is to break at null values, according
		// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
		// This option gives lines the ability to span gaps
		values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
		values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
		values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);

		return values;
	},

	calculatePointY: function(value, index, datasetIndex) {
		var me = this;
		var chart = me.chart;
		var meta = me.getMeta();
		var yScale = me.getScaleForId(meta.yAxisID);
		var sumPos = 0;
		var sumNeg = 0;
		var i, ds, dsMeta;

		if (yScale.options.stacked) {
			for (i = 0; i < datasetIndex; i++) {
				ds = chart.data.datasets[i];
				dsMeta = chart.getDatasetMeta(i);
				if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
					var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
					if (stackedRightValue < 0) {
						sumNeg += stackedRightValue || 0;
					} else {
						sumPos += stackedRightValue || 0;
					}
				}
			}

			var rightValue = Number(yScale.getRightValue(value));
			if (rightValue < 0) {
				return yScale.getPixelForValue(sumNeg + rightValue);
			}
			return yScale.getPixelForValue(sumPos + rightValue);
		}

		return yScale.getPixelForValue(value);
	},

	updateBezierControlPoints: function() {
		var me = this;
		var chart = me.chart;
		var meta = me.getMeta();
		var lineModel = meta.dataset._model;
		var area = chart.chartArea;
		var points = meta.data || [];
		var i, ilen, model, controlPoints;

		// Only consider points that are drawn in case the spanGaps option is used
		if (lineModel.spanGaps) {
			points = points.filter(function(pt) {
				return !pt._model.skip;
			});
		}

		function capControlPoint(pt, min, max) {
			return Math.max(Math.min(pt, max), min);
		}

		if (lineModel.cubicInterpolationMode === 'monotone') {
			helpers$1.splineCurveMonotone(points);
		} else {
			for (i = 0, ilen = points.length; i < ilen; ++i) {
				model = points[i]._model;
				controlPoints = helpers$1.splineCurve(
					helpers$1.previousItem(points, i)._model,
					model,
					helpers$1.nextItem(points, i)._model,
					lineModel.tension
				);
				model.controlPointPreviousX = controlPoints.previous.x;
				model.controlPointPreviousY = controlPoints.previous.y;
				model.controlPointNextX = controlPoints.next.x;
				model.controlPointNextY = controlPoints.next.y;
			}
		}

		if (chart.options.elements.line.capBezierPoints) {
			for (i = 0, ilen = points.length; i < ilen; ++i) {
				model = points[i]._model;
				if (isPointInArea(model, area)) {
					if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
						model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
						model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
					}
					if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
						model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
						model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
					}
				}
			}
		}
	},

	draw: function() {
		var me = this;
		var chart = me.chart;
		var meta = me.getMeta();
		var points = meta.data || [];
		var area = chart.chartArea;
		var ilen = points.length;
		var halfBorderWidth;
		var i = 0;

		if (lineEnabled(me.getDataset(), chart.options)) {
			halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;

			helpers$1.canvas.clipArea(chart.ctx, {
				left: area.left,
				right: area.right,
				top: area.top - halfBorderWidth,
				bottom: area.bottom + halfBorderWidth
			});

			meta.dataset.draw();

			helpers$1.canvas.unclipArea(chart.ctx);
		}

		// Draw the points
		for (; i < ilen; ++i) {
			points[i].draw(area);
		}
	},

	/**
	 * @protected
	 */
	setHoverStyle: function(point) {
		var model = point._model;
		var options = point._options;
		var getHoverColor = helpers$1.getHoverColor;

		point.$previousStyle = {
			backgroundColor: model.backgroundColor,
			borderColor: model.borderColor,
			borderWidth: model.borderWidth,
			radius: model.radius
		};

		model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
		model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
		model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
		model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
	},
});

var resolve$5 = helpers$1.options.resolve;

core_defaults._set('polarArea', {
	scale: {
		type: 'radialLinear',
		angleLines: {
			display: false
		},
		gridLines: {
			circular: true
		},
		pointLabels: {
			display: false
		},
		ticks: {
			beginAtZero: true
		}
	},

	// Boolean - Whether to animate the rotation of the chart
	animation: {
		animateRotate: true,
		animateScale: true
	},

	startAngle: -0.5 * Math.PI,
	legendCallback: function(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = data.datasets;
		var labels = data.labels;

		if (datasets.length) {
			for (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				if (labels[i]) {
					text.push(labels[i]);
				}
				text.push('</li>');
			}
		}

		text.push('</ul>');
		return text.join('');
	},
	legend: {
		labels: {
			generateLabels: function(chart) {
				var data = chart.data;
				if (data.labels.length && data.datasets.length) {
					return data.labels.map(function(label, i) {
						var meta = chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc.custom || {};
						var arcOpts = chart.options.elements.arc;
						var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
						var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
						var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);

						return {
							text: label,
							fillStyle: fill,
							strokeStyle: stroke,
							lineWidth: bw,
							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Extra data used for toggling the correct item
							index: i
						};
					});
				}
				return [];
			}
		},

		onClick: function(e, legendItem) {
			var index = legendItem.index;
			var chart = this.chart;
			var i, ilen, meta;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				meta.data[index].hidden = !meta.data[index].hidden;
			}

			chart.update();
		}
	},

	// Need to override these to give a nice default
	tooltips: {
		callbacks: {
			title: function() {
				return '';
			},
			label: function(item, data) {
				return data.labels[item.index] + ': ' + item.yLabel;
			}
		}
	}
});

var controller_polarArea = core_datasetController.extend({

	dataElementType: elements.Arc,

	linkScales: helpers$1.noop,

	update: function(reset) {
		var me = this;
		var dataset = me.getDataset();
		var meta = me.getMeta();
		var start = me.chart.options.startAngle || 0;
		var starts = me._starts = [];
		var angles = me._angles = [];
		var arcs = meta.data;
		var i, ilen, angle;

		me._updateRadius();

		meta.count = me.countVisibleElements();

		for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
			starts[i] = start;
			angle = me._computeAngle(i);
			angles[i] = angle;
			start += angle;
		}

		for (i = 0, ilen = arcs.length; i < ilen; ++i) {
			arcs[i]._options = me._resolveElementOptions(arcs[i], i);
			me.updateElement(arcs[i], i, reset);
		}
	},

	/**
	 * @private
	 */
	_updateRadius: function() {
		var me = this;
		var chart = me.chart;
		var chartArea = chart.chartArea;
		var opts = chart.options;
		var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);

		chart.outerRadius = Math.max(minSize / 2, 0);
		chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
		chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

		me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
		me.innerRadius = me.outerRadius - chart.radiusLength;
	},

	updateElement: function(arc, index, reset) {
		var me = this;
		var chart = me.chart;
		var dataset = me.getDataset();
		var opts = chart.options;
		var animationOpts = opts.animation;
		var scale = chart.scale;
		var labels = chart.data.labels;

		var centerX = scale.xCenter;
		var centerY = scale.yCenter;

		// var negHalfPI = -0.5 * Math.PI;
		var datasetStartAngle = opts.startAngle;
		var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
		var startAngle = me._starts[index];
		var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);

		var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
		var options = arc._options || {};

		helpers$1.extend(arc, {
			// Utility
			_datasetIndex: me.index,
			_index: index,
			_scale: scale,

			// Desired view properties
			_model: {
				backgroundColor: options.backgroundColor,
				borderColor: options.borderColor,
				borderWidth: options.borderWidth,
				borderAlign: options.borderAlign,
				x: centerX,
				y: centerY,
				innerRadius: 0,
				outerRadius: reset ? resetRadius : distance,
				startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
				endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
				label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
			}
		});

		arc.pivot();
	},

	countVisibleElements: function() {
		var dataset = this.getDataset();
		var meta = this.getMeta();
		var count = 0;

		helpers$1.each(meta.data, function(element, index) {
			if (!isNaN(dataset.data[index]) && !element.hidden) {
				count++;
			}
		});

		return count;
	},

	/**
	 * @protected
	 */
	setHoverStyle: function(arc) {
		var model = arc._model;
		var options = arc._options;
		var getHoverColor = helpers$1.getHoverColor;
		var valueOrDefault = helpers$1.valueOrDefault;

		arc.$previousStyle = {
			backgroundColor: model.backgroundColor,
			borderColor: model.borderColor,
			borderWidth: model.borderWidth,
		};

		model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
		model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
		model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
	},

	/**
	 * @private
	 */
	_resolveElementOptions: function(arc, index) {
		var me = this;
		var chart = me.chart;
		var dataset = me.getDataset();
		var custom = arc.custom || {};
		var options = chart.options.elements.arc;
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var keys = [
			'backgroundColor',
			'borderColor',
			'borderWidth',
			'borderAlign',
			'hoverBackgroundColor',
			'hoverBorderColor',
			'hoverBorderWidth',
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$5([
				custom[key],
				dataset[key],
				options[key]
			], context, index);
		}

		return values;
	},

	/**
	 * @private
	 */
	_computeAngle: function(index) {
		var me = this;
		var count = this.getMeta().count;
		var dataset = me.getDataset();
		var meta = me.getMeta();

		if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
			return 0;
		}

		// Scriptable options
		var context = {
			chart: me.chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		return resolve$5([
			me.chart.options.elements.arc.angle,
			(2 * Math.PI) / count
		], context, index);
	}
});

core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));
core_defaults._set('pie', {
	cutoutPercentage: 0
});

// Pie charts are Doughnut chart with different defaults
var controller_pie = controller_doughnut;

var valueOrDefault$6 = helpers$1.valueOrDefault;
var resolve$6 = helpers$1.options.resolve;

core_defaults._set('radar', {
	scale: {
		type: 'radialLinear'
	},
	elements: {
		line: {
			tension: 0 // no bezier in radar
		}
	}
});

var controller_radar = core_datasetController.extend({

	datasetElementType: elements.Line,

	dataElementType: elements.Point,

	linkScales: helpers$1.noop,

	update: function(reset) {
		var me = this;
		var meta = me.getMeta();
		var line = meta.dataset;
		var points = meta.data || [];
		var scale = me.chart.scale;
		var dataset = me.getDataset();
		var i, ilen;

		// Compatibility: If the properties are defined with only the old name, use those values
		if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
			dataset.lineTension = dataset.tension;
		}

		// Utility
		line._scale = scale;
		line._datasetIndex = me.index;
		// Data
		line._children = points;
		line._loop = true;
		// Model
		line._model = me._resolveLineOptions(line);

		line.pivot();

		// Update Points
		for (i = 0, ilen = points.length; i < ilen; ++i) {
			me.updateElement(points[i], i, reset);
		}

		// Update bezier control points
		me.updateBezierControlPoints();

		// Now pivot the point for animation
		for (i = 0, ilen = points.length; i < ilen; ++i) {
			points[i].pivot();
		}
	},

	updateElement: function(point, index, reset) {
		var me = this;
		var custom = point.custom || {};
		var dataset = me.getDataset();
		var scale = me.chart.scale;
		var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
		var options = me._resolvePointOptions(point, index);
		var lineModel = me.getMeta().dataset._model;
		var x = reset ? scale.xCenter : pointPosition.x;
		var y = reset ? scale.yCenter : pointPosition.y;

		// Utility
		point._scale = scale;
		point._options = options;
		point._datasetIndex = me.index;
		point._index = index;

		// Desired view properties
		point._model = {
			x: x, // value not used in dataset scale, but we want a consistent API between scales
			y: y,
			skip: custom.skip || isNaN(x) || isNaN(y),
			// Appearance
			radius: options.radius,
			pointStyle: options.pointStyle,
			rotation: options.rotation,
			backgroundColor: options.backgroundColor,
			borderColor: options.borderColor,
			borderWidth: options.borderWidth,
			tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),

			// Tooltip
			hitRadius: options.hitRadius
		};
	},

	/**
	 * @private
	 */
	_resolvePointOptions: function(element, index) {
		var me = this;
		var chart = me.chart;
		var dataset = chart.data.datasets[me.index];
		var custom = element.custom || {};
		var options = chart.options.elements.point;
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var ELEMENT_OPTIONS = {
			backgroundColor: 'pointBackgroundColor',
			borderColor: 'pointBorderColor',
			borderWidth: 'pointBorderWidth',
			hitRadius: 'pointHitRadius',
			hoverBackgroundColor: 'pointHoverBackgroundColor',
			hoverBorderColor: 'pointHoverBorderColor',
			hoverBorderWidth: 'pointHoverBorderWidth',
			hoverRadius: 'pointHoverRadius',
			pointStyle: 'pointStyle',
			radius: 'pointRadius',
			rotation: 'pointRotation'
		};
		var keys = Object.keys(ELEMENT_OPTIONS);

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$6([
				custom[key],
				dataset[ELEMENT_OPTIONS[key]],
				dataset[key],
				options[key]
			], context, index);
		}

		return values;
	},

	/**
	 * @private
	 */
	_resolveLineOptions: function(element) {
		var me = this;
		var chart = me.chart;
		var dataset = chart.data.datasets[me.index];
		var custom = element.custom || {};
		var options = chart.options.elements.line;
		var values = {};
		var i, ilen, key;

		var keys = [
			'backgroundColor',
			'borderWidth',
			'borderColor',
			'borderCapStyle',
			'borderDash',
			'borderDashOffset',
			'borderJoinStyle',
			'fill'
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve$6([
				custom[key],
				dataset[key],
				options[key]
			]);
		}

		values.tension = valueOrDefault$6(dataset.lineTension, options.tension);

		return values;
	},

	updateBezierControlPoints: function() {
		var me = this;
		var meta = me.getMeta();
		var area = me.chart.chartArea;
		var points = meta.data || [];
		var i, ilen, model, controlPoints;

		function capControlPoint(pt, min, max) {
			return Math.max(Math.min(pt, max), min);
		}

		for (i = 0, ilen = points.length; i < ilen; ++i) {
			model = points[i]._model;
			controlPoints = helpers$1.splineCurve(
				helpers$1.previousItem(points, i, true)._model,
				model,
				helpers$1.nextItem(points, i, true)._model,
				model.tension
			);

			// Prevent the bezier going outside of the bounds of the graph
			model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
			model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
			model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
			model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
		}
	},

	setHoverStyle: function(point) {
		var model = point._model;
		var options = point._options;
		var getHoverColor = helpers$1.getHoverColor;

		point.$previousStyle = {
			backgroundColor: model.backgroundColor,
			borderColor: model.borderColor,
			borderWidth: model.borderWidth,
			radius: model.radius
		};

		model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
		model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
		model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
		model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
	}
});

core_defaults._set('scatter', {
	hover: {
		mode: 'single'
	},

	scales: {
		xAxes: [{
			id: 'x-axis-1',    // need an ID so datasets can reference the scale
			type: 'linear',    // scatter should not use a category axis
			position: 'bottom'
		}],
		yAxes: [{
			id: 'y-axis-1',
			type: 'linear',
			position: 'left'
		}]
	},

	showLines: false,

	tooltips: {
		callbacks: {
			title: function() {
				return '';     // doesn't make sense for scatter since data are formatted as a point
			},
			label: function(item) {
				return '(' + item.xLabel + ', ' + item.yLabel + ')';
			}
		}
	}
});

// Scatter charts use line controllers
var controller_scatter = controller_line;

// NOTE export a map in which the key represents the controller type, not
// the class, and so must be CamelCase in order to be correctly retrieved
// by the controller in core.controller.js (`controllers[meta.type]`).

var controllers = {
	bar: controller_bar,
	bubble: controller_bubble,
	doughnut: controller_doughnut,
	horizontalBar: controller_horizontalBar,
	line: controller_line,
	polarArea: controller_polarArea,
	pie: controller_pie,
	radar: controller_radar,
	scatter: controller_scatter
};

/**
 * Helper function to get relative position for an event
 * @param {Event|IEvent} event - The event to get the position for
 * @param {Chart} chart - The chart
 * @returns {object} the event position
 */
function getRelativePosition(e, chart) {
	if (e.native) {
		return {
			x: e.x,
			y: e.y
		};
	}

	return helpers$1.getRelativePosition(e, chart);
}

/**
 * Helper function to traverse all of the visible elements in the chart
 * @param {Chart} chart - the chart
 * @param {function} handler - the callback to execute for each visible item
 */
function parseVisibleItems(chart, handler) {
	var datasets = chart.data.datasets;
	var meta, i, j, ilen, jlen;

	for (i = 0, ilen = datasets.length; i < ilen; ++i) {
		if (!chart.isDatasetVisible(i)) {
			continue;
		}

		meta = chart.getDatasetMeta(i);
		for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
			var element = meta.data[j];
			if (!element._view.skip) {
				handler(element);
			}
		}
	}
}

/**
 * Helper function to get the items that intersect the event position
 * @param {ChartElement[]} items - elements to filter
 * @param {object} position - the point to be nearest to
 * @return {ChartElement[]} the nearest items
 */
function getIntersectItems(chart, position) {
	var elements = [];

	parseVisibleItems(chart, function(element) {
		if (element.inRange(position.x, position.y)) {
			elements.push(element);
		}
	});

	return elements;
}

/**
 * Helper function to get the items nearest to the event position considering all visible items in teh chart
 * @param {Chart} chart - the chart to look at elements from
 * @param {object} position - the point to be nearest to
 * @param {boolean} intersect - if true, only consider items that intersect the position
 * @param {function} distanceMetric - function to provide the distance between points
 * @return {ChartElement[]} the nearest items
 */
function getNearestItems(chart, position, intersect, distanceMetric) {
	var minDistance = Number.POSITIVE_INFINITY;
	var nearestItems = [];

	parseVisibleItems(chart, function(element) {
		if (intersect && !element.inRange(position.x, position.y)) {
			return;
		}

		var center = element.getCenterPoint();
		var distance = distanceMetric(position, center);
		if (distance < minDistance) {
			nearestItems = [element];
			minDistance = distance;
		} else if (distance === minDistance) {
			// Can have multiple items at the same distance in which case we sort by size
			nearestItems.push(element);
		}
	});

	return nearestItems;
}

/**
 * Get a distance metric function for two points based on the
 * axis mode setting
 * @param {string} axis - the axis mode. x|y|xy
 */
function getDistanceMetricForAxis(axis) {
	var useX = axis.indexOf('x') !== -1;
	var useY = axis.indexOf('y') !== -1;

	return function(pt1, pt2) {
		var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
		var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	};
}

function indexMode(chart, e, options) {
	var position = getRelativePosition(e, chart);
	// Default axis for index mode is 'x' to match old behaviour
	options.axis = options.axis || 'x';
	var distanceMetric = getDistanceMetricForAxis(options.axis);
	var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
	var elements = [];

	if (!items.length) {
		return [];
	}

	chart.data.datasets.forEach(function(dataset, datasetIndex) {
		if (chart.isDatasetVisible(datasetIndex)) {
			var meta = chart.getDatasetMeta(datasetIndex);
			var element = meta.data[items[0]._index];

			// don't count items that are skipped (null data)
			if (element && !element._view.skip) {
				elements.push(element);
			}
		}
	});

	return elements;
}

/**
 * @interface IInteractionOptions
 */
/**
 * If true, only consider items that intersect the point
 * @name IInterfaceOptions#boolean
 * @type Boolean
 */

/**
 * Contains interaction related functions
 * @namespace Chart.Interaction
 */
var core_interaction = {
	// Helper function for different modes
	modes: {
		single: function(chart, e) {
			var position = getRelativePosition(e, chart);
			var elements = [];

			parseVisibleItems(chart, function(element) {
				if (element.inRange(position.x, position.y)) {
					elements.push(element);
					return elements;
				}
			});

			return elements.slice(0, 1);
		},

		/**
		 * @function Chart.Interaction.modes.label
		 * @deprecated since version 2.4.0
		 * @todo remove at version 3
		 * @private
		 */
		label: indexMode,

		/**
		 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
		 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
		 * @function Chart.Interaction.modes.index
		 * @since v2.4.0
		 * @param {Chart} chart - the chart we are returning items from
		 * @param {Event} e - the event we are find things at
		 * @param {IInteractionOptions} options - options to use during interaction
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		index: indexMode,

		/**
		 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
		 * If the options.intersect is false, we find the nearest item and return the items in that dataset
		 * @function Chart.Interaction.modes.dataset
		 * @param {Chart} chart - the chart we are returning items from
		 * @param {Event} e - the event we are find things at
		 * @param {IInteractionOptions} options - options to use during interaction
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		dataset: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			options.axis = options.axis || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

			if (items.length > 0) {
				items = chart.getDatasetMeta(items[0]._datasetIndex).data;
			}

			return items;
		},

		/**
		 * @function Chart.Interaction.modes.x-axis
		 * @deprecated since version 2.4.0. Use index mode and intersect == true
		 * @todo remove at version 3
		 * @private
		 */
		'x-axis': function(chart, e) {
			return indexMode(chart, e, {intersect: false});
		},

		/**
		 * Point mode returns all elements that hit test based on the event position
		 * of the event
		 * @function Chart.Interaction.modes.intersect
		 * @param {Chart} chart - the chart we are returning items from
		 * @param {Event} e - the event we are find things at
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		point: function(chart, e) {
			var position = getRelativePosition(e, chart);
			return getIntersectItems(chart, position);
		},

		/**
		 * nearest mode returns the element closest to the point
		 * @function Chart.Interaction.modes.intersect
		 * @param {Chart} chart - the chart we are returning items from
		 * @param {Event} e - the event we are find things at
		 * @param {IInteractionOptions} options - options to use
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		nearest: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			options.axis = options.axis || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			return getNearestItems(chart, position, options.intersect, distanceMetric);
		},

		/**
		 * x mode returns the elements that hit-test at the current x coordinate
		 * @function Chart.Interaction.modes.x
		 * @param {Chart} chart - the chart we are returning items from
		 * @param {Event} e - the event we are find things at
		 * @param {IInteractionOptions} options - options to use
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		x: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			var items = [];
			var intersectsItem = false;

			parseVisibleItems(chart, function(element) {
				if (element.inXRange(position.x)) {
					items.push(element);
				}

				if (element.inRange(position.x, position.y)) {
					intersectsItem = true;
				}
			});

			// If we want to trigger on an intersect and we don't have any items
			// that intersect the position, return nothing
			if (options.intersect && !intersectsItem) {
				items = [];
			}
			return items;
		},

		/**
		 * y mode returns the elements that hit-test at the current y coordinate
		 * @function Chart.Interaction.modes.y
		 * @param {Chart} chart - the chart we are returning items from
		 * @param {Event} e - the event we are find things at
		 * @param {IInteractionOptions} options - options to use
		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
		 */
		y: function(chart, e, options) {
			var position = getRelativePosition(e, chart);
			var items = [];
			var intersectsItem = false;

			parseVisibleItems(chart, function(element) {
				if (element.inYRange(position.y)) {
					items.push(element);
				}

				if (element.inRange(position.x, position.y)) {
					intersectsItem = true;
				}
			});

			// If we want to trigger on an intersect and we don't have any items
			// that intersect the position, return nothing
			if (options.intersect && !intersectsItem) {
				items = [];
			}
			return items;
		}
	}
};

function filterByPosition(array, position) {
	return helpers$1.where(array, function(v) {
		return v.position === position;
	});
}

function sortByWeight(array, reverse) {
	array.forEach(function(v, i) {
		v._tmpIndex_ = i;
		return v;
	});
	array.sort(function(a, b) {
		var v0 = reverse ? b : a;
		var v1 = reverse ? a : b;
		return v0.weight === v1.weight ?
			v0._tmpIndex_ - v1._tmpIndex_ :
			v0.weight - v1.weight;
	});
	array.forEach(function(v) {
		delete v._tmpIndex_;
	});
}

function findMaxPadding(boxes) {
	var top = 0;
	var left = 0;
	var bottom = 0;
	var right = 0;
	helpers$1.each(boxes, function(box) {
		if (box.getPadding) {
			var boxPadding = box.getPadding();
			top = Math.max(top, boxPadding.top);
			left = Math.max(left, boxPadding.left);
			bottom = Math.max(bottom, boxPadding.bottom);
			right = Math.max(right, boxPadding.right);
		}
	});
	return {
		top: top,
		left: left,
		bottom: bottom,
		right: right
	};
}

function addSizeByPosition(boxes, size) {
	helpers$1.each(boxes, function(box) {
		size[box.position] += box.isHorizontal() ? box.height : box.width;
	});
}

core_defaults._set('global', {
	layout: {
		padding: {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0
		}
	}
});

/**
 * @interface ILayoutItem
 * @prop {string} position - The position of the item in the chart layout. Possible values are
 * 'left', 'top', 'right', 'bottom', and 'chartArea'
 * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
 * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
 * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
 * @prop {function} update - Takes two parameters: width and height. Returns size of item
 * @prop {function} getPadding -  Returns an object with padding on the edges
 * @prop {number} width - Width of item. Must be valid after update()
 * @prop {number} height - Height of item. Must be valid after update()
 * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
 * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
 * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
 * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
 */

// The layout service is very self explanatory.  It's responsible for the layout within a chart.
// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
// It is this service's responsibility of carrying out that layout.
var core_layouts = {
	defaults: {},

	/**
	 * Register a box to a chart.
	 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
	 * @param {Chart} chart - the chart to use
	 * @param {ILayoutItem} item - the item to add to be layed out
	 */
	addBox: function(chart, item) {
		if (!chart.boxes) {
			chart.boxes = [];
		}

		// initialize item with default values
		item.fullWidth = item.fullWidth || false;
		item.position = item.position || 'top';
		item.weight = item.weight || 0;

		chart.boxes.push(item);
	},

	/**
	 * Remove a layoutItem from a chart
	 * @param {Chart} chart - the chart to remove the box from
	 * @param {ILayoutItem} layoutItem - the item to remove from the layout
	 */
	removeBox: function(chart, layoutItem) {
		var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
		if (index !== -1) {
			chart.boxes.splice(index, 1);
		}
	},

	/**
	 * Sets (or updates) options on the given `item`.
	 * @param {Chart} chart - the chart in which the item lives (or will be added to)
	 * @param {ILayoutItem} item - the item to configure with the given options
	 * @param {object} options - the new item options.
	 */
	configure: function(chart, item, options) {
		var props = ['fullWidth', 'position', 'weight'];
		var ilen = props.length;
		var i = 0;
		var prop;

		for (; i < ilen; ++i) {
			prop = props[i];
			if (options.hasOwnProperty(prop)) {
				item[prop] = options[prop];
			}
		}
	},

	/**
	 * Fits boxes of the given chart into the given size by having each box measure itself
	 * then running a fitting algorithm
	 * @param {Chart} chart - the chart
	 * @param {number} width - the width to fit into
	 * @param {number} height - the height to fit into
	 */
	update: function(chart, width, height) {
		if (!chart) {
			return;
		}

		var layoutOptions = chart.options.layout || {};
		var padding = helpers$1.options.toPadding(layoutOptions.padding);
		var leftPadding = padding.left;
		var rightPadding = padding.right;
		var topPadding = padding.top;
		var bottomPadding = padding.bottom;

		var leftBoxes = filterByPosition(chart.boxes, 'left');
		var rightBoxes = filterByPosition(chart.boxes, 'right');
		var topBoxes = filterByPosition(chart.boxes, 'top');
		var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
		var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

		// Sort boxes by weight. A higher weight is further away from the chart area
		sortByWeight(leftBoxes, true);
		sortByWeight(rightBoxes, false);
		sortByWeight(topBoxes, true);
		sortByWeight(bottomBoxes, false);

		var verticalBoxes = leftBoxes.concat(rightBoxes);
		var horizontalBoxes = topBoxes.concat(bottomBoxes);
		var outerBoxes = verticalBoxes.concat(horizontalBoxes);

		// Essentially we now have any number of boxes on each of the 4 sides.
		// Our canvas looks like the following.
		// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
		// B1 is the bottom axis
		// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
		// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
		// an error will be thrown.
		//
		// |----------------------------------------------------|
		// |                  T1 (Full Width)                   |
		// |----------------------------------------------------|
		// |    |    |                 T2                  |    |
		// |    |----|-------------------------------------|----|
		// |    |    | C1 |                           | C2 |    |
		// |    |    |----|                           |----|    |
		// |    |    |                                     |    |
		// | L1 | L2 |           ChartArea (C0)            | R1 |
		// |    |    |                                     |    |
		// |    |    |----|                           |----|    |
		// |    |    | C3 |                           | C4 |    |
		// |    |----|-------------------------------------|----|
		// |    |    |                 B1                  |    |
		// |----------------------------------------------------|
		// |                  B2 (Full Width)                   |
		// |----------------------------------------------------|
		//
		// What we do to find the best sizing, we do the following
		// 1. Determine the minimum size of the chart area.
		// 2. Split the remaining width equally between each vertical axis
		// 3. Split the remaining height equally between each horizontal axis
		// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
		// 5. Adjust the sizes of each axis based on it's minimum reported size.
		// 6. Refit each axis
		// 7. Position each axis in the final location
		// 8. Tell the chart the final location of the chart area
		// 9. Tell any axes that overlay the chart area the positions of the chart area

		// Step 1
		var chartWidth = width - leftPadding - rightPadding;
		var chartHeight = height - topPadding - bottomPadding;
		var chartAreaWidth = chartWidth / 2; // min 50%

		// Step 2
		var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length;

		// Step 3
		// TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
		// var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;

		// Step 4
		var maxChartAreaWidth = chartWidth;
		var maxChartAreaHeight = chartHeight;
		var outerBoxSizes = {top: topPadding, left: leftPadding, bottom: bottomPadding, right: rightPadding};
		var minBoxSizes = [];
		var maxPadding;

		function getMinimumBoxSize(box) {
			var minSize;
			var isHorizontal = box.isHorizontal();

			if (isHorizontal) {
				minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
				maxChartAreaHeight -= minSize.height;
			} else {
				minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
				maxChartAreaWidth -= minSize.width;
			}

			minBoxSizes.push({
				horizontal: isHorizontal,
				width: minSize.width,
				box: box,
			});
		}

		helpers$1.each(outerBoxes, getMinimumBoxSize);

		// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
		maxPadding = findMaxPadding(outerBoxes);

		// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
		// be if the axes are drawn at their minimum sizes.
		// Steps 5 & 6

		// Function to fit a box
		function fitBox(box) {
			var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function(minBox) {
				return minBox.box === box;
			});

			if (minBoxSize) {
				if (minBoxSize.horizontal) {
					var scaleMargin = {
						left: Math.max(outerBoxSizes.left, maxPadding.left),
						right: Math.max(outerBoxSizes.right, maxPadding.right),
						top: 0,
						bottom: 0
					};

					// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
					// on the margin. Sometimes they need to increase in size slightly
					box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
				} else {
					box.update(minBoxSize.width, maxChartAreaHeight);
				}
			}
		}

		// Update, and calculate the left and right margins for the horizontal boxes
		helpers$1.each(verticalBoxes, fitBox);
		addSizeByPosition(verticalBoxes, outerBoxSizes);

		// Set the Left and Right margins for the horizontal boxes
		helpers$1.each(horizontalBoxes, fitBox);
		addSizeByPosition(horizontalBoxes, outerBoxSizes);

		function finalFitVerticalBox(box) {
			var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function(minSize) {
				return minSize.box === box;
			});

			var scaleMargin = {
				left: 0,
				right: 0,
				top: outerBoxSizes.top,
				bottom: outerBoxSizes.bottom
			};

			if (minBoxSize) {
				box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
			}
		}

		// Let the left layout know the final margin
		helpers$1.each(verticalBoxes, finalFitVerticalBox);

		// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
		outerBoxSizes = {top: topPadding, left: leftPadding, bottom: bottomPadding, right: rightPadding};
		addSizeByPosition(outerBoxes, outerBoxSizes);

		// We may be adding some padding to account for rotated x axis labels
		var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
		outerBoxSizes.left += leftPaddingAddition;
		outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);

		var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
		outerBoxSizes.top += topPaddingAddition;
		outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0);

		// Figure out if our chart area changed. This would occur if the dataset layout label rotation
		// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
		// without calling `fit` again
		var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
		var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

		if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
			helpers$1.each(verticalBoxes, function(box) {
				box.height = newMaxChartAreaHeight;
			});

			helpers$1.each(horizontalBoxes, function(box) {
				if (!box.fullWidth) {
					box.width = newMaxChartAreaWidth;
				}
			});

			maxChartAreaHeight = newMaxChartAreaHeight;
			maxChartAreaWidth = newMaxChartAreaWidth;
		}

		// Step 7 - Position the boxes
		var left = leftPadding + leftPaddingAddition;
		var top = topPadding + topPaddingAddition;

		function placeBox(box) {
			if (box.isHorizontal()) {
				box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
				box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
				box.top = top;
				box.bottom = top + box.height;

				// Move to next point
				top = box.bottom;

			} else {

				box.left = left;
				box.right = left + box.width;
				box.top = outerBoxSizes.top;
				box.bottom = outerBoxSizes.top + maxChartAreaHeight;

				// Move to next point
				left = box.right;
			}
		}

		helpers$1.each(leftBoxes.concat(topBoxes), placeBox);

		// Account for chart width and height
		left += maxChartAreaWidth;
		top += maxChartAreaHeight;

		helpers$1.each(rightBoxes, placeBox);
		helpers$1.each(bottomBoxes, placeBox);

		// Step 8
		chart.chartArea = {
			left: outerBoxSizes.left,
			top: outerBoxSizes.top,
			right: outerBoxSizes.left + maxChartAreaWidth,
			bottom: outerBoxSizes.top + maxChartAreaHeight
		};

		// Step 9
		helpers$1.each(chartAreaBoxes, function(box) {
			box.left = chart.chartArea.left;
			box.top = chart.chartArea.top;
			box.right = chart.chartArea.right;
			box.bottom = chart.chartArea.bottom;

			box.update(maxChartAreaWidth, maxChartAreaHeight);
		});
	}
};

/**
 * Platform fallback implementation (minimal).
 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
 */

var platform_basic = {
	acquireContext: function(item) {
		if (item && item.canvas) {
			// Support for any object associated to a canvas (including a context2d)
			item = item.canvas;
		}

		return item && item.getContext('2d') || null;
	}
};

var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";

var platform_dom$1 = /*#__PURE__*/Object.freeze({
default: platform_dom
});

function getCjsExportFromNamespace (n) {
	return n && n.default || n;
}

var stylesheet = getCjsExportFromNamespace(platform_dom$1);

var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

/**
 * DOM event types -> Chart.js event types.
 * Note: only events with different types are mapped.
 * @see https://developer.mozilla.org/en-US/docs/Web/Events
 */
var EVENT_TYPES = {
	touchstart: 'mousedown',
	touchmove: 'mousemove',
	touchend: 'mouseup',
	pointerenter: 'mouseenter',
	pointerdown: 'mousedown',
	pointermove: 'mousemove',
	pointerup: 'mouseup',
	pointerleave: 'mouseout',
	pointerout: 'mouseout'
};

/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns {number} Size in pixels or undefined if unknown.
 */
function readUsedSize(element, property) {
	var value = helpers$1.getStyle(element, property);
	var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
	return matches ? Number(matches[1]) : undefined;
}

/**
 * Initializes the canvas style and render size without modifying the canvas display size,
 * since responsiveness is handled by the controller.resize() method. The config is used
 * to determine the aspect ratio to apply in case no explicit height has been specified.
 */
function initCanvas(canvas, config) {
	var style = canvas.style;

	// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
	// returns null or '' if no explicit value has been set to the canvas attribute.
	var renderHeight = canvas.getAttribute('height');
	var renderWidth = canvas.getAttribute('width');

	// Chart.js modifies some canvas values that we want to restore on destroy
	canvas[EXPANDO_KEY] = {
		initial: {
			height: renderHeight,
			width: renderWidth,
			style: {
				display: style.display,
				height: style.height,
				width: style.width
			}
		}
	};

	// Force canvas to display as block to avoid extra space caused by inline
	// elements, which would interfere with the responsive resize process.
	// https://github.com/chartjs/Chart.js/issues/2538
	style.display = style.display || 'block';

	if (renderWidth === null || renderWidth === '') {
		var displayWidth = readUsedSize(canvas, 'width');
		if (displayWidth !== undefined) {
			canvas.width = displayWidth;
		}
	}

	if (renderHeight === null || renderHeight === '') {
		if (canvas.style.height === '') {
			// If no explicit render height and style height, let's apply the aspect ratio,
			// which one can be specified by the user but also by charts as default option
			// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
			canvas.height = canvas.width / (config.options.aspectRatio || 2);
		} else {
			var displayHeight = readUsedSize(canvas, 'height');
			if (displayWidth !== undefined) {
				canvas.height = displayHeight;
			}
		}
	}

	return canvas;
}

/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */
var supportsEventListenerOptions = (function() {
	var supports = false;
	try {
		var options = Object.defineProperty({}, 'passive', {
			// eslint-disable-next-line getter-return
			get: function() {
				supports = true;
			}
		});
		window.addEventListener('e', null, options);
	} catch (e) {
		// continue regardless of error
	}
	return supports;
}());

// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
// https://github.com/chartjs/Chart.js/issues/4287
var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;

function addListener(node, type, listener) {
	node.addEventListener(type, listener, eventListenerOptions);
}

function removeListener(node, type, listener) {
	node.removeEventListener(type, listener, eventListenerOptions);
}

function createEvent(type, chart, x, y, nativeEvent) {
	return {
		type: type,
		chart: chart,
		native: nativeEvent || null,
		x: x !== undefined ? x : null,
		y: y !== undefined ? y : null,
	};
}

function fromNativeEvent(event, chart) {
	var type = EVENT_TYPES[event.type] || event.type;
	var pos = helpers$1.getRelativePosition(event, chart);
	return createEvent(type, chart, pos.x, pos.y, event);
}

function throttled(fn, thisArg) {
	var ticking = false;
	var args = [];

	return function() {
		args = Array.prototype.slice.call(arguments);
		thisArg = thisArg || this;

		if (!ticking) {
			ticking = true;
			helpers$1.requestAnimFrame.call(window, function() {
				ticking = false;
				fn.apply(thisArg, args);
			});
		}
	};
}

function createDiv(cls) {
	var el = document.createElement('div');
	el.className = cls || '';
	return el;
}

// Implementation based on https://github.com/marcj/css-element-queries
function createResizer(handler) {
	var maxSize = 1000000;

	// NOTE(SB) Don't use innerHTML because it could be considered unsafe.
	// https://github.com/chartjs/Chart.js/issues/5902
	var resizer = createDiv(CSS_SIZE_MONITOR);
	var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
	var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');

	expand.appendChild(createDiv());
	shrink.appendChild(createDiv());

	resizer.appendChild(expand);
	resizer.appendChild(shrink);
	resizer._reset = function() {
		expand.scrollLeft = maxSize;
		expand.scrollTop = maxSize;
		shrink.scrollLeft = maxSize;
		shrink.scrollTop = maxSize;
	};

	var onScroll = function() {
		resizer._reset();
		handler();
	};

	addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
	addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

	return resizer;
}

// https://davidwalsh.name/detect-node-insertion
function watchForRender(node, handler) {
	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
	var proxy = expando.renderProxy = function(e) {
		if (e.animationName === CSS_RENDER_ANIMATION) {
			handler();
		}
	};

	helpers$1.each(ANIMATION_START_EVENTS, function(type) {
		addListener(node, type, proxy);
	});

	// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
	// is removed then added back immediately (same animation frame?). Accessing the
	// `offsetParent` property will force a reflow and re-evaluate the CSS animation.
	// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
	// https://github.com/chartjs/Chart.js/issues/4737
	expando.reflow = !!node.offsetParent;

	node.classList.add(CSS_RENDER_MONITOR);
}

function unwatchForRender(node) {
	var expando = node[EXPANDO_KEY] || {};
	var proxy = expando.renderProxy;

	if (proxy) {
		helpers$1.each(ANIMATION_START_EVENTS, function(type) {
			removeListener(node, type, proxy);
		});

		delete expando.renderProxy;
	}

	node.classList.remove(CSS_RENDER_MONITOR);
}

function addResizeListener(node, listener, chart) {
	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

	// Let's keep track of this added resizer and thus avoid DOM query when removing it.
	var resizer = expando.resizer = createResizer(throttled(function() {
		if (expando.resizer) {
			var container = chart.options.maintainAspectRatio && node.parentNode;
			var w = container ? container.clientWidth : 0;
			listener(createEvent('resize', chart));
			if (container && container.clientWidth < w && chart.canvas) {
				// If the container size shrank during chart resize, let's assume
				// scrollbar appeared. So we resize again with the scrollbar visible -
				// effectively making chart smaller and the scrollbar hidden again.
				// Because we are inside `throttled`, and currently `ticking`, scroll
				// events are ignored during this whole 2 resize process.
				// If we assumed wrong and something else happened, we are resizing
				// twice in a frame (potential performance issue)
				listener(createEvent('resize', chart));
			}
		}
	}));

	// The resizer needs to be attached to the node parent, so we first need to be
	// sure that `node` is attached to the DOM before injecting the resizer element.
	watchForRender(node, function() {
		if (expando.resizer) {
			var container = node.parentNode;
			if (container && container !== resizer.parentNode) {
				container.insertBefore(resizer, container.firstChild);
			}

			// The container size might have changed, let's reset the resizer state.
			resizer._reset();
		}
	});
}

function removeResizeListener(node) {
	var expando = node[EXPANDO_KEY] || {};
	var resizer = expando.resizer;

	delete expando.resizer;
	unwatchForRender(node);

	if (resizer && resizer.parentNode) {
		resizer.parentNode.removeChild(resizer);
	}
}

function injectCSS(platform, css) {
	// https://stackoverflow.com/q/3922139
	var style = platform._style || document.createElement('style');
	if (!platform._style) {
		platform._style = style;
		css = '/* Chart.js */\n' + css;
		style.setAttribute('type', 'text/css');
		document.getElementsByTagName('head')[0].appendChild(style);
	}

	style.appendChild(document.createTextNode(css));
}

var platform_dom$2 = {
	/**
	 * When `true`, prevents the automatic injection of the stylesheet required to
	 * correctly detect when the chart is added to the DOM and then resized. This
	 * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
	 * to be manually imported to make this library compatible with any CSP.
	 * See https://github.com/chartjs/Chart.js/issues/5208
	 */
	disableCSSInjection: false,

	/**
	 * This property holds whether this platform is enabled for the current environment.
	 * Currently used by platform.js to select the proper implementation.
	 * @private
	 */
	_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

	/**
	 * @private
	 */
	_ensureLoaded: function() {
		if (this._loaded) {
			return;
		}

		this._loaded = true;

		// https://github.com/chartjs/Chart.js/issues/5208
		if (!this.disableCSSInjection) {
			injectCSS(this, stylesheet);
		}
	},

	acquireContext: function(item, config) {
		if (typeof item === 'string') {
			item = document.getElementById(item);
		} else if (item.length) {
			// Support for array based queries (such as jQuery)
			item = item[0];
		}

		if (item && item.canvas) {
			// Support for any object associated to a canvas (including a context2d)
			item = item.canvas;
		}

		// To prevent canvas fingerprinting, some add-ons undefine the getContext
		// method, for example: https://github.com/kkapsner/CanvasBlocker
		// https://github.com/chartjs/Chart.js/issues/2807
		var context = item && item.getContext && item.getContext('2d');

		// Load platform resources on first chart creation, to make possible to change
		// platform options after importing the library (e.g. `disableCSSInjection`).
		this._ensureLoaded();

		// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
		// inside an iframe or when running in a protected environment. We could guess the
		// types from their toString() value but let's keep things flexible and assume it's
		// a sufficient condition if the item has a context2D which has item as `canvas`.
		// https://github.com/chartjs/Chart.js/issues/3887
		// https://github.com/chartjs/Chart.js/issues/4102
		// https://github.com/chartjs/Chart.js/issues/4152
		if (context && context.canvas === item) {
			initCanvas(item, config);
			return context;
		}

		return null;
	},

	releaseContext: function(context) {
		var canvas = context.canvas;
		if (!canvas[EXPANDO_KEY]) {
			return;
		}

		var initial = canvas[EXPANDO_KEY].initial;
		['height', 'width'].forEach(function(prop) {
			var value = initial[prop];
			if (helpers$1.isNullOrUndef(value)) {
				canvas.removeAttribute(prop);
			} else {
				canvas.setAttribute(prop, value);
			}
		});

		helpers$1.each(initial.style || {}, function(value, key) {
			canvas.style[key] = value;
		});

		// The canvas render size might have been changed (and thus the state stack discarded),
		// we can't use save() and restore() to restore the initial state. So make sure that at
		// least the canvas context is reset to the default state by setting the canvas width.
		// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
		// eslint-disable-next-line no-self-assign
		canvas.width = canvas.width;

		delete canvas[EXPANDO_KEY];
	},

	addEventListener: function(chart, type, listener) {
		var canvas = chart.canvas;
		if (type === 'resize') {
			// Note: the resize event is not supported on all browsers.
			addResizeListener(canvas, listener, chart);
			return;
		}

		var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
		var proxies = expando.proxies || (expando.proxies = {});
		var proxy = proxies[chart.id + '_' + type] = function(event) {
			listener(fromNativeEvent(event, chart));
		};

		addListener(canvas, type, proxy);
	},

	removeEventListener: function(chart, type, listener) {
		var canvas = chart.canvas;
		if (type === 'resize') {
			// Note: the resize event is not supported on all browsers.
			removeResizeListener(canvas);
			return;
		}

		var expando = listener[EXPANDO_KEY] || {};
		var proxies = expando.proxies || {};
		var proxy = proxies[chart.id + '_' + type];
		if (!proxy) {
			return;
		}

		removeListener(canvas, type, proxy);
	}
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use EventTarget.addEventListener instead.
 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * @function Chart.helpers.addEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers$1.addEvent = addListener;

/**
 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
 * @function Chart.helpers.removeEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers$1.removeEvent = removeListener;

// @TODO Make possible to select another platform at build time.
var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;

/**
 * @namespace Chart.platform
 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
 * @since 2.4.0
 */
var platform = helpers$1.extend({
	/**
	 * @since 2.7.0
	 */
	initialize: function() {},

	/**
	 * Called at chart construction time, returns a context2d instance implementing
	 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
	 * @param {*} item - The native item from which to acquire context (platform specific)
	 * @param {object} options - The chart options
	 * @returns {CanvasRenderingContext2D} context2d instance
	 */
	acquireContext: function() {},

	/**
	 * Called at chart destruction time, releases any resources associated to the context
	 * previously returned by the acquireContext() method.
	 * @param {CanvasRenderingContext2D} context - The context2d instance
	 * @returns {boolean} true if the method succeeded, else false
	 */
	releaseContext: function() {},

	/**
	 * Registers the specified listener on the given chart.
	 * @param {Chart} chart - Chart from which to listen for event
	 * @param {string} type - The ({@link IEvent}) type to listen for
	 * @param {function} listener - Receives a notification (an object that implements
	 * the {@link IEvent} interface) when an event of the specified type occurs.
	 */
	addEventListener: function() {},

	/**
	 * Removes the specified listener previously registered with addEventListener.
	 * @param {Chart} chart - Chart from which to remove the listener
	 * @param {string} type - The ({@link IEvent}) type to remove
	 * @param {function} listener - The listener function to remove from the event target.
	 */
	removeEventListener: function() {}

}, implementation);

core_defaults._set('global', {
	plugins: {}
});

/**
 * The plugin service singleton
 * @namespace Chart.plugins
 * @since 2.1.0
 */
var core_plugins = {
	/**
	 * Globally registered plugins.
	 * @private
	 */
	_plugins: [],

	/**
	 * This identifier is used to invalidate the descriptors cache attached to each chart
	 * when a global plugin is registered or unregistered. In this case, the cache ID is
	 * incremented and descriptors are regenerated during following API calls.
	 * @private
	 */
	_cacheId: 0,

	/**
	 * Registers the given plugin(s) if not already registered.
	 * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
	 */
	register: function(plugins) {
		var p = this._plugins;
		([]).concat(plugins).forEach(function(plugin) {
			if (p.indexOf(plugin) === -1) {
				p.push(plugin);
			}
		});

		this._cacheId++;
	},

	/**
	 * Unregisters the given plugin(s) only if registered.
	 * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
	 */
	unregister: function(plugins) {
		var p = this._plugins;
		([]).concat(plugins).forEach(function(plugin) {
			var idx = p.indexOf(plugin);
			if (idx !== -1) {
				p.splice(idx, 1);
			}
		});

		this._cacheId++;
	},

	/**
	 * Remove all registered plugins.
	 * @since 2.1.5
	 */
	clear: function() {
		this._plugins = [];
		this._cacheId++;
	},

	/**
	 * Returns the number of registered plugins?
	 * @returns {number}
	 * @since 2.1.5
	 */
	count: function() {
		return this._plugins.length;
	},

	/**
	 * Returns all registered plugin instances.
	 * @returns {IPlugin[]} array of plugin objects.
	 * @since 2.1.5
	 */
	getAll: function() {
		return this._plugins;
	},

	/**
	 * Calls enabled plugins for `chart` on the specified hook and with the given args.
	 * This method immediately returns as soon as a plugin explicitly returns false. The
	 * returned value can be used, for instance, to interrupt the current action.
	 * @param {Chart} chart - The chart instance for which plugins should be called.
	 * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
	 * @param {Array} [args] - Extra arguments to apply to the hook call.
	 * @returns {boolean} false if any of the plugins return false, else returns true.
	 */
	notify: function(chart, hook, args) {
		var descriptors = this.descriptors(chart);
		var ilen = descriptors.length;
		var i, descriptor, plugin, params, method;

		for (i = 0; i < ilen; ++i) {
			descriptor = descriptors[i];
			plugin = descriptor.plugin;
			method = plugin[hook];
			if (typeof method === 'function') {
				params = [chart].concat(args || []);
				params.push(descriptor.options);
				if (method.apply(plugin, params) === false) {
					return false;
				}
			}
		}

		return true;
	},

	/**
	 * Returns descriptors of enabled plugins for the given chart.
	 * @returns {object[]} [{ plugin, options }]
	 * @private
	 */
	descriptors: function(chart) {
		var cache = chart.$plugins || (chart.$plugins = {});
		if (cache.id === this._cacheId) {
			return cache.descriptors;
		}

		var plugins = [];
		var descriptors = [];
		var config = (chart && chart.config) || {};
		var options = (config.options && config.options.plugins) || {};

		this._plugins.concat(config.plugins || []).forEach(function(plugin) {
			var idx = plugins.indexOf(plugin);
			if (idx !== -1) {
				return;
			}

			var id = plugin.id;
			var opts = options[id];
			if (opts === false) {
				return;
			}

			if (opts === true) {
				opts = helpers$1.clone(core_defaults.global.plugins[id]);
			}

			plugins.push(plugin);
			descriptors.push({
				plugin: plugin,
				options: opts || {}
			});
		});

		cache.descriptors = descriptors;
		cache.id = this._cacheId;
		return descriptors;
	},

	/**
	 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
	 * but in some cases, this reference can be changed by the user when updating options.
	 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
	 * @private
	 */
	_invalidate: function(chart) {
		delete chart.$plugins;
	}
};

var core_scaleService = {
	// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
	// use the new chart options to grab the correct scale
	constructors: {},
	// Use a registration function so that we can move to an ES6 map when we no longer need to support
	// old browsers

	// Scale config defaults
	defaults: {},
	registerScaleType: function(type, scaleConstructor, scaleDefaults) {
		this.constructors[type] = scaleConstructor;
		this.defaults[type] = helpers$1.clone(scaleDefaults);
	},
	getScaleConstructor: function(type) {
		return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
	},
	getScaleDefaults: function(type) {
		// Return the scale defaults merged with the global settings so that we always use the latest ones
		return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
	},
	updateScaleDefaults: function(type, additions) {
		var me = this;
		if (me.defaults.hasOwnProperty(type)) {
			me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
		}
	},
	addScalesToLayout: function(chart) {
		// Adds each scale to the chart.boxes array to be sized accordingly
		helpers$1.each(chart.scales, function(scale) {
			// Set ILayoutItem parameters for backwards compatibility
			scale.fullWidth = scale.options.fullWidth;
			scale.position = scale.options.position;
			scale.weight = scale.options.weight;
			core_layouts.addBox(chart, scale);
		});
	}
};

var valueOrDefault$7 = helpers$1.valueOrDefault;

core_defaults._set('global', {
	tooltips: {
		enabled: true,
		custom: null,
		mode: 'nearest',
		position: 'average',
		intersect: true,
		backgroundColor: 'rgba(0,0,0,0.8)',
		titleFontStyle: 'bold',
		titleSpacing: 2,
		titleMarginBottom: 6,
		titleFontColor: '#fff',
		titleAlign: 'left',
		bodySpacing: 2,
		bodyFontColor: '#fff',
		bodyAlign: 'left',
		footerFontStyle: 'bold',
		footerSpacing: 2,
		footerMarginTop: 6,
		footerFontColor: '#fff',
		footerAlign: 'left',
		yPadding: 6,
		xPadding: 6,
		caretPadding: 2,
		caretSize: 5,
		cornerRadius: 6,
		multiKeyBackground: '#fff',
		displayColors: true,
		borderColor: 'rgba(0,0,0,0)',
		borderWidth: 0,
		callbacks: {
			// Args are: (tooltipItems, data)
			beforeTitle: helpers$1.noop,
			title: function(tooltipItems, data) {
				var title = '';
				var labels = data.labels;
				var labelCount = labels ? labels.length : 0;

				if (tooltipItems.length > 0) {
					var item = tooltipItems[0];
					if (item.label) {
						title = item.label;
					} else if (item.xLabel) {
						title = item.xLabel;
					} else if (labelCount > 0 && item.index < labelCount) {
						title = labels[item.index];
					}
				}

				return title;
			},
			afterTitle: helpers$1.noop,

			// Args are: (tooltipItems, data)
			beforeBody: helpers$1.noop,

			// Args are: (tooltipItem, data)
			beforeLabel: helpers$1.noop,
			label: function(tooltipItem, data) {
				var label = data.datasets[tooltipItem.datasetIndex].label || '';

				if (label) {
					label += ': ';
				}
				if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
					label += tooltipItem.value;
				} else {
					label += tooltipItem.yLabel;
				}
				return label;
			},
			labelColor: function(tooltipItem, chart) {
				var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
				var activeElement = meta.data[tooltipItem.index];
				var view = activeElement._view;
				return {
					borderColor: view.borderColor,
					backgroundColor: view.backgroundColor
				};
			},
			labelTextColor: function() {
				return this._options.bodyFontColor;
			},
			afterLabel: helpers$1.noop,

			// Args are: (tooltipItems, data)
			afterBody: helpers$1.noop,

			// Args are: (tooltipItems, data)
			beforeFooter: helpers$1.noop,
			footer: helpers$1.noop,
			afterFooter: helpers$1.noop
		}
	}
});

var positioners = {
	/**
	 * Average mode places the tooltip at the average position of the elements shown
	 * @function Chart.Tooltip.positioners.average
	 * @param elements {ChartElement[]} the elements being displayed in the tooltip
	 * @returns {object} tooltip position
	 */
	average: function(elements) {
		if (!elements.length) {
			return false;
		}

		var i, len;
		var x = 0;
		var y = 0;
		var count = 0;

		for (i = 0, len = elements.length; i < len; ++i) {
			var el = elements[i];
			if (el && el.hasValue()) {
				var pos = el.tooltipPosition();
				x += pos.x;
				y += pos.y;
				++count;
			}
		}

		return {
			x: x / count,
			y: y / count
		};
	},

	/**
	 * Gets the tooltip position nearest of the item nearest to the event position
	 * @function Chart.Tooltip.positioners.nearest
	 * @param elements {Chart.Element[]} the tooltip elements
	 * @param eventPosition {object} the position of the event in canvas coordinates
	 * @returns {object} the tooltip position
	 */
	nearest: function(elements, eventPosition) {
		var x = eventPosition.x;
		var y = eventPosition.y;
		var minDistance = Number.POSITIVE_INFINITY;
		var i, len, nearestElement;

		for (i = 0, len = elements.length; i < len; ++i) {
			var el = elements[i];
			if (el && el.hasValue()) {
				var center = el.getCenterPoint();
				var d = helpers$1.distanceBetweenPoints(eventPosition, center);

				if (d < minDistance) {
					minDistance = d;
					nearestElement = el;
				}
			}
		}

		if (nearestElement) {
			var tp = nearestElement.tooltipPosition();
			x = tp.x;
			y = tp.y;
		}

		return {
			x: x,
			y: y
		};
	}
};

// Helper to push or concat based on if the 2nd parameter is an array or not
function pushOrConcat(base, toPush) {
	if (toPush) {
		if (helpers$1.isArray(toPush)) {
			// base = base.concat(toPush);
			Array.prototype.push.apply(base, toPush);
		} else {
			base.push(toPush);
		}
	}

	return base;
}

/**
 * Returns array of strings split by newline
 * @param {string} value - The value to split by newline.
 * @returns {string[]} value if newline present - Returned from String split() method
 * @function
 */
function splitNewlines(str) {
	if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
		return str.split('\n');
	}
	return str;
}


/**
 * Private helper to create a tooltip item model
 * @param element - the chart element (point, arc, bar) to create the tooltip item for
 * @return new tooltip item
 */
function createTooltipItem(element) {
	var xScale = element._xScale;
	var yScale = element._yScale || element._scale; // handle radar || polarArea charts
	var index = element._index;
	var datasetIndex = element._datasetIndex;
	var controller = element._chart.getDatasetMeta(datasetIndex).controller;
	var indexScale = controller._getIndexScale();
	var valueScale = controller._getValueScale();

	return {
		xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
		yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
		label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
		value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
		index: index,
		datasetIndex: datasetIndex,
		x: element._model.x,
		y: element._model.y
	};
}

/**
 * Helper to get the reset model for the tooltip
 * @param tooltipOpts {object} the tooltip options
 */
function getBaseModel(tooltipOpts) {
	var globalDefaults = core_defaults.global;

	return {
		// Positioning
		xPadding: tooltipOpts.xPadding,
		yPadding: tooltipOpts.yPadding,
		xAlign: tooltipOpts.xAlign,
		yAlign: tooltipOpts.yAlign,

		// Body
		bodyFontColor: tooltipOpts.bodyFontColor,
		_bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
		_bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
		_bodyAlign: tooltipOpts.bodyAlign,
		bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
		bodySpacing: tooltipOpts.bodySpacing,

		// Title
		titleFontColor: tooltipOpts.titleFontColor,
		_titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
		_titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
		titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
		_titleAlign: tooltipOpts.titleAlign,
		titleSpacing: tooltipOpts.titleSpacing,
		titleMarginBottom: tooltipOpts.titleMarginBottom,

		// Footer
		footerFontColor: tooltipOpts.footerFontColor,
		_footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
		_footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
		footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
		_footerAlign: tooltipOpts.footerAlign,
		footerSpacing: tooltipOpts.footerSpacing,
		footerMarginTop: tooltipOpts.footerMarginTop,

		// Appearance
		caretSize: tooltipOpts.caretSize,
		cornerRadius: tooltipOpts.cornerRadius,
		backgroundColor: tooltipOpts.backgroundColor,
		opacity: 0,
		legendColorBackground: tooltipOpts.multiKeyBackground,
		displayColors: tooltipOpts.displayColors,
		borderColor: tooltipOpts.borderColor,
		borderWidth: tooltipOpts.borderWidth
	};
}

/**
 * Get the size of the tooltip
 */
function getTooltipSize(tooltip, model) {
	var ctx = tooltip._chart.ctx;

	var height = model.yPadding * 2; // Tooltip Padding
	var width = 0;

	// Count of all lines in the body
	var body = model.body;
	var combinedBodyLength = body.reduce(function(count, bodyItem) {
		return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
	}, 0);
	combinedBodyLength += model.beforeBody.length + model.afterBody.length;

	var titleLineCount = model.title.length;
	var footerLineCount = model.footer.length;
	var titleFontSize = model.titleFontSize;
	var bodyFontSize = model.bodyFontSize;
	var footerFontSize = model.footerFontSize;

	height += titleLineCount * titleFontSize; // Title Lines
	height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
	height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
	height += combinedBodyLength * bodyFontSize; // Body Lines
	height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
	height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
	height += footerLineCount * (footerFontSize); // Footer Lines
	height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

	// Title width
	var widthPadding = 0;
	var maxLineWidth = function(line) {
		width = Math.max(width, ctx.measureText(line).width + widthPadding);
	};

	ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
	helpers$1.each(model.title, maxLineWidth);

	// Body width
	ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
	helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

	// Body lines may include some extra width due to the color box
	widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
	helpers$1.each(body, function(bodyItem) {
		helpers$1.each(bodyItem.before, maxLineWidth);
		helpers$1.each(bodyItem.lines, maxLineWidth);
		helpers$1.each(bodyItem.after, maxLineWidth);
	});

	// Reset back to 0
	widthPadding = 0;

	// Footer width
	ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
	helpers$1.each(model.footer, maxLineWidth);

	// Add padding
	width += 2 * model.xPadding;

	return {
		width: width,
		height: height
	};
}

/**
 * Helper to get the alignment of a tooltip given the size
 */
function determineAlignment(tooltip, size) {
	var model = tooltip._model;
	var chart = tooltip._chart;
	var chartArea = tooltip._chart.chartArea;
	var xAlign = 'center';
	var yAlign = 'center';

	if (model.y < size.height) {
		yAlign = 'top';
	} else if (model.y > (chart.height - size.height)) {
		yAlign = 'bottom';
	}

	var lf, rf; // functions to determine left, right alignment
	var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
	var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
	var midX = (chartArea.left + chartArea.right) / 2;
	var midY = (chartArea.top + chartArea.bottom) / 2;

	if (yAlign === 'center') {
		lf = function(x) {
			return x <= midX;
		};
		rf = function(x) {
			return x > midX;
		};
	} else {
		lf = function(x) {
			return x <= (size.width / 2);
		};
		rf = function(x) {
			return x >= (chart.width - (size.width / 2));
		};
	}

	olf = function(x) {
		return x + size.width + model.caretSize + model.caretPadding > chart.width;
	};
	orf = function(x) {
		return x - size.width - model.caretSize - model.caretPadding < 0;
	};
	yf = function(y) {
		return y <= midY ? 'top' : 'bottom';
	};

	if (lf(model.x)) {
		xAlign = 'left';

		// Is tooltip too wide and goes over the right side of the chart.?
		if (olf(model.x)) {
			xAlign = 'center';
			yAlign = yf(model.y);
		}
	} else if (rf(model.x)) {
		xAlign = 'right';

		// Is tooltip too wide and goes outside left edge of canvas?
		if (orf(model.x)) {
			xAlign = 'center';
			yAlign = yf(model.y);
		}
	}

	var opts = tooltip._options;
	return {
		xAlign: opts.xAlign ? opts.xAlign : xAlign,
		yAlign: opts.yAlign ? opts.yAlign : yAlign
	};
}

/**
 * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
 */
function getBackgroundPoint(vm, size, alignment, chart) {
	// Background Position
	var x = vm.x;
	var y = vm.y;

	var caretSize = vm.caretSize;
	var caretPadding = vm.caretPadding;
	var cornerRadius = vm.cornerRadius;
	var xAlign = alignment.xAlign;
	var yAlign = alignment.yAlign;
	var paddingAndSize = caretSize + caretPadding;
	var radiusAndPadding = cornerRadius + caretPadding;

	if (xAlign === 'right') {
		x -= size.width;
	} else if (xAlign === 'center') {
		x -= (size.width / 2);
		if (x + size.width > chart.width) {
			x = chart.width - size.width;
		}
		if (x < 0) {
			x = 0;
		}
	}

	if (yAlign === 'top') {
		y += paddingAndSize;
	} else if (yAlign === 'bottom') {
		y -= size.height + paddingAndSize;
	} else {
		y -= (size.height / 2);
	}

	if (yAlign === 'center') {
		if (xAlign === 'left') {
			x += paddingAndSize;
		} else if (xAlign === 'right') {
			x -= paddingAndSize;
		}
	} else if (xAlign === 'left') {
		x -= radiusAndPadding;
	} else if (xAlign === 'right') {
		x += radiusAndPadding;
	}

	return {
		x: x,
		y: y
	};
}

function getAlignedX(vm, align) {
	return align === 'center'
		? vm.x + vm.width / 2
		: align === 'right'
			? vm.x + vm.width - vm.xPadding
			: vm.x + vm.xPadding;
}

/**
 * Helper to build before and after body lines
 */
function getBeforeAfterBodyLines(callback) {
	return pushOrConcat([], splitNewlines(callback));
}

var exports$3 = core_element.extend({
	initialize: function() {
		this._model = getBaseModel(this._options);
		this._lastActive = [];
	},

	// Get the title
	// Args are: (tooltipItem, data)
	getTitle: function() {
		var me = this;
		var opts = me._options;
		var callbacks = opts.callbacks;

		var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
		var title = callbacks.title.apply(me, arguments);
		var afterTitle = callbacks.afterTitle.apply(me, arguments);

		var lines = [];
		lines = pushOrConcat(lines, splitNewlines(beforeTitle));
		lines = pushOrConcat(lines, splitNewlines(title));
		lines = pushOrConcat(lines, splitNewlines(afterTitle));

		return lines;
	},

	// Args are: (tooltipItem, data)
	getBeforeBody: function() {
		return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
	},

	// Args are: (tooltipItem, data)
	getBody: function(tooltipItems, data) {
		var me = this;
		var callbacks = me._options.callbacks;
		var bodyItems = [];

		helpers$1.each(tooltipItems, function(tooltipItem) {
			var bodyItem = {
				before: [],
				lines: [],
				after: []
			};
			pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
			pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
			pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));

			bodyItems.push(bodyItem);
		});

		return bodyItems;
	},

	// Args are: (tooltipItem, data)
	getAfterBody: function() {
		return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
	},

	// Get the footer and beforeFooter and afterFooter lines
	// Args are: (tooltipItem, data)
	getFooter: function() {
		var me = this;
		var callbacks = me._options.callbacks;

		var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
		var footer = callbacks.footer.apply(me, arguments);
		var afterFooter = callbacks.afterFooter.apply(me, arguments);

		var lines = [];
		lines = pushOrConcat(lines, splitNewlines(beforeFooter));
		lines = pushOrConcat(lines, splitNewlines(footer));
		lines = pushOrConcat(lines, splitNewlines(afterFooter));

		return lines;
	},

	update: function(changed) {
		var me = this;
		var opts = me._options;

		// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
		// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
		// which breaks any animations.
		var existingModel = me._model;
		var model = me._model = getBaseModel(opts);
		var active = me._active;

		var data = me._data;

		// In the case where active.length === 0 we need to keep these at existing values for good animations
		var alignment = {
			xAlign: existingModel.xAlign,
			yAlign: existingModel.yAlign
		};
		var backgroundPoint = {
			x: existingModel.x,
			y: existingModel.y
		};
		var tooltipSize = {
			width: existingModel.width,
			height: existingModel.height
		};
		var tooltipPosition = {
			x: existingModel.caretX,
			y: existingModel.caretY
		};

		var i, len;

		if (active.length) {
			model.opacity = 1;

			var labelColors = [];
			var labelTextColors = [];
			tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);

			var tooltipItems = [];
			for (i = 0, len = active.length; i < len; ++i) {
				tooltipItems.push(createTooltipItem(active[i]));
			}

			// If the user provided a filter function, use it to modify the tooltip items
			if (opts.filter) {
				tooltipItems = tooltipItems.filter(function(a) {
					return opts.filter(a, data);
				});
			}

			// If the user provided a sorting function, use it to modify the tooltip items
			if (opts.itemSort) {
				tooltipItems = tooltipItems.sort(function(a, b) {
					return opts.itemSort(a, b, data);
				});
			}

			// Determine colors for boxes
			helpers$1.each(tooltipItems, function(tooltipItem) {
				labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
				labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
			});


			// Build the Text Lines
			model.title = me.getTitle(tooltipItems, data);
			model.beforeBody = me.getBeforeBody(tooltipItems, data);
			model.body = me.getBody(tooltipItems, data);
			model.afterBody = me.getAfterBody(tooltipItems, data);
			model.footer = me.getFooter(tooltipItems, data);

			// Initial positioning and colors
			model.x = tooltipPosition.x;
			model.y = tooltipPosition.y;
			model.caretPadding = opts.caretPadding;
			model.labelColors = labelColors;
			model.labelTextColors = labelTextColors;

			// data points
			model.dataPoints = tooltipItems;

			// We need to determine alignment of the tooltip
			tooltipSize = getTooltipSize(this, model);
			alignment = determineAlignment(this, tooltipSize);
			// Final Size and Position
			backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
		} else {
			model.opacity = 0;
		}

		model.xAlign = alignment.xAlign;
		model.yAlign = alignment.yAlign;
		model.x = backgroundPoint.x;
		model.y = backgroundPoint.y;
		model.width = tooltipSize.width;
		model.height = tooltipSize.height;

		// Point where the caret on the tooltip points to
		model.caretX = tooltipPosition.x;
		model.caretY = tooltipPosition.y;

		me._model = model;

		if (changed && opts.custom) {
			opts.custom.call(me, model);
		}

		return me;
	},

	drawCaret: function(tooltipPoint, size) {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

		ctx.lineTo(caretPosition.x1, caretPosition.y1);
		ctx.lineTo(caretPosition.x2, caretPosition.y2);
		ctx.lineTo(caretPosition.x3, caretPosition.y3);
	},
	getCaretPosition: function(tooltipPoint, size, vm) {
		var x1, x2, x3, y1, y2, y3;
		var caretSize = vm.caretSize;
		var cornerRadius = vm.cornerRadius;
		var xAlign = vm.xAlign;
		var yAlign = vm.yAlign;
		var ptX = tooltipPoint.x;
		var ptY = tooltipPoint.y;
		var width = size.width;
		var height = size.height;

		if (yAlign === 'center') {
			y2 = ptY + (height / 2);

			if (xAlign === 'left') {
				x1 = ptX;
				x2 = x1 - caretSize;
				x3 = x1;

				y1 = y2 + caretSize;
				y3 = y2 - caretSize;
			} else {
				x1 = ptX + width;
				x2 = x1 + caretSize;
				x3 = x1;

				y1 = y2 - caretSize;
				y3 = y2 + caretSize;
			}
		} else {
			if (xAlign === 'left') {
				x2 = ptX + cornerRadius + (caretSize);
				x1 = x2 - caretSize;
				x3 = x2 + caretSize;
			} else if (xAlign === 'right') {
				x2 = ptX + width - cornerRadius - caretSize;
				x1 = x2 - caretSize;
				x3 = x2 + caretSize;
			} else {
				x2 = vm.caretX;
				x1 = x2 - caretSize;
				x3 = x2 + caretSize;
			}
			if (yAlign === 'top') {
				y1 = ptY;
				y2 = y1 - caretSize;
				y3 = y1;
			} else {
				y1 = ptY + height;
				y2 = y1 + caretSize;
				y3 = y1;
				// invert drawing order
				var tmp = x3;
				x3 = x1;
				x1 = tmp;
			}
		}
		return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
	},

	drawTitle: function(pt, vm, ctx) {
		var title = vm.title;

		if (title.length) {
			pt.x = getAlignedX(vm, vm._titleAlign);

			ctx.textAlign = vm._titleAlign;
			ctx.textBaseline = 'top';

			var titleFontSize = vm.titleFontSize;
			var titleSpacing = vm.titleSpacing;

			ctx.fillStyle = vm.titleFontColor;
			ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

			var i, len;
			for (i = 0, len = title.length; i < len; ++i) {
				ctx.fillText(title[i], pt.x, pt.y);
				pt.y += titleFontSize + titleSpacing; // Line Height and spacing

				if (i + 1 === title.length) {
					pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
				}
			}
		}
	},

	drawBody: function(pt, vm, ctx) {
		var bodyFontSize = vm.bodyFontSize;
		var bodySpacing = vm.bodySpacing;
		var bodyAlign = vm._bodyAlign;
		var body = vm.body;
		var drawColorBoxes = vm.displayColors;
		var labelColors = vm.labelColors;
		var xLinePadding = 0;
		var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
		var textColor;

		ctx.textAlign = bodyAlign;
		ctx.textBaseline = 'top';
		ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

		pt.x = getAlignedX(vm, bodyAlign);

		// Before Body
		var fillLineOfText = function(line) {
			ctx.fillText(line, pt.x + xLinePadding, pt.y);
			pt.y += bodyFontSize + bodySpacing;
		};

		// Before body lines
		ctx.fillStyle = vm.bodyFontColor;
		helpers$1.each(vm.beforeBody, fillLineOfText);

		xLinePadding = drawColorBoxes && bodyAlign !== 'right'
			? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)
			: 0;

		// Draw body lines now
		helpers$1.each(body, function(bodyItem, i) {
			textColor = vm.labelTextColors[i];
			ctx.fillStyle = textColor;
			helpers$1.each(bodyItem.before, fillLineOfText);

			helpers$1.each(bodyItem.lines, function(line) {
				// Draw Legend-like boxes if needed
				if (drawColorBoxes) {
					// Fill a white rect so that colours merge nicely if the opacity is < 1
					ctx.fillStyle = vm.legendColorBackground;
					ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);

					// Border
					ctx.lineWidth = 1;
					ctx.strokeStyle = labelColors[i].borderColor;
					ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);

					// Inner square
					ctx.fillStyle = labelColors[i].backgroundColor;
					ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
					ctx.fillStyle = textColor;
				}

				fillLineOfText(line);
			});

			helpers$1.each(bodyItem.after, fillLineOfText);
		});

		// Reset back to 0 for after body
		xLinePadding = 0;

		// After body lines
		helpers$1.each(vm.afterBody, fillLineOfText);
		pt.y -= bodySpacing; // Remove last body spacing
	},

	drawFooter: function(pt, vm, ctx) {
		var footer = vm.footer;

		if (footer.length) {
			pt.x = getAlignedX(vm, vm._footerAlign);
			pt.y += vm.footerMarginTop;

			ctx.textAlign = vm._footerAlign;
			ctx.textBaseline = 'top';

			ctx.fillStyle = vm.footerFontColor;
			ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

			helpers$1.each(footer, function(line) {
				ctx.fillText(line, pt.x, pt.y);
				pt.y += vm.footerFontSize + vm.footerSpacing;
			});
		}
	},

	drawBackground: function(pt, vm, ctx, tooltipSize) {
		ctx.fillStyle = vm.backgroundColor;
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = vm.borderWidth;
		var xAlign = vm.xAlign;
		var yAlign = vm.yAlign;
		var x = pt.x;
		var y = pt.y;
		var width = tooltipSize.width;
		var height = tooltipSize.height;
		var radius = vm.cornerRadius;

		ctx.beginPath();
		ctx.moveTo(x + radius, y);
		if (yAlign === 'top') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
		if (yAlign === 'center' && xAlign === 'right') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
		if (yAlign === 'bottom') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
		if (yAlign === 'center' && xAlign === 'left') {
			this.drawCaret(pt, tooltipSize);
		}
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
		ctx.closePath();

		ctx.fill();

		if (vm.borderWidth > 0) {
			ctx.stroke();
		}
	},

	draw: function() {
		var ctx = this._chart.ctx;
		var vm = this._view;

		if (vm.opacity === 0) {
			return;
		}

		var tooltipSize = {
			width: vm.width,
			height: vm.height
		};
		var pt = {
			x: vm.x,
			y: vm.y
		};

		// IE11/Edge does not like very small opacities, so snap to 0
		var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

		// Truthy/falsey value for empty tooltip
		var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

		if (this._options.enabled && hasTooltipContent) {
			ctx.save();
			ctx.globalAlpha = opacity;

			// Draw Background
			this.drawBackground(pt, vm, ctx, tooltipSize);

			// Draw Title, Body, and Footer
			pt.y += vm.yPadding;

			// Titles
			this.drawTitle(pt, vm, ctx);

			// Body
			this.drawBody(pt, vm, ctx);

			// Footer
			this.drawFooter(pt, vm, ctx);

			ctx.restore();
		}
	},

	/**
	 * Handle an event
	 * @private
	 * @param {IEvent} event - The event to handle
	 * @returns {boolean} true if the tooltip changed
	 */
	handleEvent: function(e) {
		var me = this;
		var options = me._options;
		var changed = false;

		me._lastActive = me._lastActive || [];

		// Find Active Elements for tooltips
		if (e.type === 'mouseout') {
			me._active = [];
		} else {
			me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
		}

		// Remember Last Actives
		changed = !helpers$1.arrayEquals(me._active, me._lastActive);

		// Only handle target event on tooltip change
		if (changed) {
			me._lastActive = me._active;

			if (options.enabled || options.custom) {
				me._eventPosition = {
					x: e.x,
					y: e.y
				};

				me.update(true);
				me.pivot();
			}
		}

		return changed;
	}
});

/**
 * @namespace Chart.Tooltip.positioners
 */
var positioners_1 = positioners;

var core_tooltip = exports$3;
core_tooltip.positioners = positioners_1;

var valueOrDefault$8 = helpers$1.valueOrDefault;

core_defaults._set('global', {
	elements: {},
	events: [
		'mousemove',
		'mouseout',
		'click',
		'touchstart',
		'touchmove'
	],
	hover: {
		onHover: null,
		mode: 'nearest',
		intersect: true,
		animationDuration: 400
	},
	onClick: null,
	maintainAspectRatio: true,
	responsive: true,
	responsiveAnimationDuration: 0
});

/**
 * Recursively merge the given config objects representing the `scales` option
 * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
 * returns a deep copy of the result, thus doesn't alter inputs.
 */
function mergeScaleConfig(/* config objects ... */) {
	return helpers$1.merge({}, [].slice.call(arguments), {
		merger: function(key, target, source, options) {
			if (key === 'xAxes' || key === 'yAxes') {
				var slen = source[key].length;
				var i, type, scale;

				if (!target[key]) {
					target[key] = [];
				}

				for (i = 0; i < slen; ++i) {
					scale = source[key][i];
					type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

					if (i >= target[key].length) {
						target[key].push({});
					}

					if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
						// new/untyped scale or type changed: let's apply the new defaults
						// then merge source scale to correctly overwrite the defaults.
						helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
					} else {
						// scales type are the same
						helpers$1.merge(target[key][i], scale);
					}
				}
			} else {
				helpers$1._merger(key, target, source, options);
			}
		}
	});
}

/**
 * Recursively merge the given config objects as the root options by handling
 * default scale options for the `scales` and `scale` properties, then returns
 * a deep copy of the result, thus doesn't alter inputs.
 */
function mergeConfig(/* config objects ... */) {
	return helpers$1.merge({}, [].slice.call(arguments), {
		merger: function(key, target, source, options) {
			var tval = target[key] || {};
			var sval = source[key];

			if (key === 'scales') {
				// scale config merging is complex. Add our own function here for that
				target[key] = mergeScaleConfig(tval, sval);
			} else if (key === 'scale') {
				// used in polar area & radar charts since there is only one scale
				target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
			} else {
				helpers$1._merger(key, target, source, options);
			}
		}
	});
}

function initConfig(config) {
	config = config || {};

	// Do NOT use mergeConfig for the data object because this method merges arrays
	// and so would change references to labels and datasets, preventing data updates.
	var data = config.data = config.data || {};
	data.datasets = data.datasets || [];
	data.labels = data.labels || [];
	config.options = mergeConfig(
		core_defaults.global,
		core_defaults[config.type],
		config.options || {});

	return config;
}

function updateConfig(chart) {
	var newOptions = chart.options;

	helpers$1.each(chart.scales, function(scale) {
		core_layouts.removeBox(chart, scale);
	});

	newOptions = mergeConfig(
		core_defaults.global,
		core_defaults[chart.config.type],
		newOptions);

	chart.options = chart.config.options = newOptions;
	chart.ensureScalesHaveIDs();
	chart.buildOrUpdateScales();

	// Tooltip
	chart.tooltip._options = newOptions.tooltips;
	chart.tooltip.initialize();
}

function positionIsHorizontal(position) {
	return position === 'top' || position === 'bottom';
}

var Chart = function(item, config) {
	this.construct(item, config);
	return this;
};

helpers$1.extend(Chart.prototype, /** @lends Chart */ {
	/**
	 * @private
	 */
	construct: function(item, config) {
		var me = this;

		config = initConfig(config);

		var context = platform.acquireContext(item, config);
		var canvas = context && context.canvas;
		var height = canvas && canvas.height;
		var width = canvas && canvas.width;

		me.id = helpers$1.uid();
		me.ctx = context;
		me.canvas = canvas;
		me.config = config;
		me.width = width;
		me.height = height;
		me.aspectRatio = height ? width / height : null;
		me.options = config.options;
		me._bufferedRender = false;
        me.defaultFontSize = config.size;
        
		/**
		 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
		 * the "instance" still need to be defined since it might be called from plugins.
		 * @prop Chart#chart
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 * @private
		 */
		me.chart = me;
		me.controller = me; // chart.chart.controller #inception

		// Add the chart instance to the global namespace
		Chart.instances[me.id] = me;

		// Define alias to the config data: `chart.data === chart.config.data`
		Object.defineProperty(me, 'data', {
			get: function() {
				return me.config.data;
			},
			set: function(value) {
				me.config.data = value;
			}
		});

		if (!context || !canvas) {
			// The given item is not a compatible context2d element, let's return before finalizing
			// the chart initialization but after setting basic chart / controller properties that
			// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
			// https://github.com/chartjs/Chart.js/issues/2807
			console.error("Failed to create chart: can't acquire context from the given item");
			return;
		}

		me.initialize();
		me.update();
	},

	/**
	 * @private
	 */
	initialize: function() {
		var me = this;

		// Before init plugin notification
		core_plugins.notify(me, 'beforeInit');

		helpers$1.retinaScale(me, me.options.devicePixelRatio);

		me.bindEvents();

		if (me.options.responsive) {
			// Initial resize before chart draws (must be silent to preserve initial animations).
			me.resize(true);
		}

		// Make sure scales have IDs and are built before we build any controllers.
		me.ensureScalesHaveIDs();
		me.buildOrUpdateScales();
		me.initToolTip();

		// After init plugin notification
		core_plugins.notify(me, 'afterInit');

		return me;
	},

	clear: function() {
		helpers$1.canvas.clear(this);
		return this;
	},

	stop: function() {
		// Stops any current animation loop occurring
		core_animations.cancelAnimation(this);
		return this;
	},

	resize: function(silent) {
		var me = this;
		var options = me.options;
		var canvas = me.canvas;
		var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

		// the canvas render width and height will be casted to integers so make sure that
		// the canvas display style uses the same integer values to avoid blurring effect.

		// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed
		var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
		var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

		if (me.width === newWidth && me.height === newHeight) {
			return;
		}

		canvas.width = me.width = newWidth;
		canvas.height = me.height = newHeight;
		canvas.style.width = newWidth + 'px';
		canvas.style.height = newHeight + 'px';

		helpers$1.retinaScale(me, options.devicePixelRatio);

		if (!silent) {
			// Notify any plugins about the resize
			var newSize = {width: newWidth, height: newHeight};
			core_plugins.notify(me, 'resize', [newSize]);

			// Notify of resize
			if (options.onResize) {
				options.onResize(me, newSize);
			}

			me.stop();
			me.update({
				duration: options.responsiveAnimationDuration
			});
		}
	},

	ensureScalesHaveIDs: function() {
		var options = this.options;
		var scalesOptions = options.scales || {};
		var scaleOptions = options.scale;

		helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {
			xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
		});

		helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {
			yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
		});

		if (scaleOptions) {
			scaleOptions.id = scaleOptions.id || 'scale';
		}
	},

	/**
	 * Builds a map of scale ID to scale object for future lookup.
	 */
	buildOrUpdateScales: function() {
		var me = this;
		var options = me.options;
		var scales = me.scales || {};
		var items = [];
		var updated = Object.keys(scales).reduce(function(obj, id) {
			obj[id] = false;
			return obj;
		}, {});

		if (options.scales) {
			items = items.concat(
				(options.scales.xAxes || []).map(function(xAxisOptions) {
					return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
				}),
				(options.scales.yAxes || []).map(function(yAxisOptions) {
					return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
				})
			);
		}

		if (options.scale) {
			items.push({
				options: options.scale,
				dtype: 'radialLinear',
				isDefault: true,
				dposition: 'chartArea'
			});
		}

		helpers$1.each(items, function(item) {
			var scaleOptions = item.options;
			var id = scaleOptions.id;
			var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

			if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
				scaleOptions.position = item.dposition;
			}

			updated[id] = true;
			var scale = null;
			if (id in scales && scales[id].type === scaleType) {
				scale = scales[id];
				scale.options = scaleOptions;
				scale.ctx = me.ctx;
				scale.chart = me;
			} else {
				var scaleClass = core_scaleService.getScaleConstructor(scaleType);
				if (!scaleClass) {
					return;
				}
				scale = new scaleClass({
					id: id,
					type: scaleType,
					options: scaleOptions,
					ctx: me.ctx,
					chart: me
				});
				scales[scale.id] = scale;
			}

			scale.mergeTicksOptions();

			// TODO(SB): I think we should be able to remove this custom case (options.scale)
			// and consider it as a regular scale part of the "scales"" map only! This would
			// make the logic easier and remove some useless? custom code.
			if (item.isDefault) {
				me.scale = scale;
			}
		});
		// clear up discarded scales
		helpers$1.each(updated, function(hasUpdated, id) {
			if (!hasUpdated) {
				delete scales[id];
			}
		});

		me.scales = scales;

		core_scaleService.addScalesToLayout(this);
	},

	buildOrUpdateControllers: function() {
		var me = this;
		var newControllers = [];

		helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
			var meta = me.getDatasetMeta(datasetIndex);
			var type = dataset.type || me.config.type;

			if (meta.type && meta.type !== type) {
				me.destroyDatasetMeta(datasetIndex);
				meta = me.getDatasetMeta(datasetIndex);
			}
			meta.type = type;

			if (meta.controller) {
				meta.controller.updateIndex(datasetIndex);
				meta.controller.linkScales();
			} else {
				var ControllerClass = controllers[meta.type];
				if (ControllerClass === undefined) {
					throw new Error('"' + meta.type + '" is not a chart type.');
				}

				meta.controller = new ControllerClass(me, datasetIndex);
				newControllers.push(meta.controller);
			}
		}, me);

		return newControllers;
	},

	/**
	 * Reset the elements of all datasets
	 * @private
	 */
	resetElements: function() {
		var me = this;
		helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
			me.getDatasetMeta(datasetIndex).controller.reset();
		}, me);
	},

	/**
	* Resets the chart back to it's state before the initial animation
	*/
	reset: function() {
		this.resetElements();
		this.tooltip.initialize();
	},

	update: function(config) {
		var me = this, _oldDefaultFontSize=core_defaults.global.defaultFontSize;

		if (!config || typeof config !== 'object') {
			// backwards compatibility
			config = {
				duration: config,
				lazy: arguments[1]
			};
		}

        if (me.defaultFontSize) core_defaults.global.defaultFontSize=me.defaultFontSize;
		updateConfig(me);

		// plugins options references might have change, let's invalidate the cache
		// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
		core_plugins._invalidate(me);

		if (core_plugins.notify(me, 'beforeUpdate') === false) {
            if (me.defaultFontSize) core_defaults.global.defaultFontSize=_oldDefaultFontSize;
			return;
		}

		// In case the entire data object changed
		me.tooltip._data = me.data;

		// Make sure dataset controllers are updated and new controllers are reset
		var newControllers = me.buildOrUpdateControllers();

		// Make sure all dataset controllers have correct meta data counts
		helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
			me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
		}, me);

		me.updateLayout();

		// Can only reset the new controllers after the scales have been updated
		if (me.options.animation && me.options.animation.duration) {
			helpers$1.each(newControllers, function(controller) {
				controller.reset();
			});
		}

		me.updateDatasets();

		// Need to reset tooltip in case it is displayed with elements that are removed
		// after update.
		me.tooltip.initialize();

		// Last active contains items that were previously in the tooltip.
		// When we reset the tooltip, we need to clear it
		me.lastActive = [];

		// Do this before render so that any plugins that need final scale updates can use it
		core_plugins.notify(me, 'afterUpdate');

		if (me._bufferedRender) {
			me._bufferedRequest = {
				duration: config.duration,
				easing: config.easing,
				lazy: config.lazy
			};
		} else {
			me.render(config);
		}
	},

	/**
	 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
	 * hook, in which case, plugins will not be called on `afterLayout`.
	 * @private
	 */
	updateLayout: function() {
		var me = this;

		if (core_plugins.notify(me, 'beforeLayout') === false) {
			return;
		}

		core_layouts.update(this, this.width, this.height);

		/**
		 * Provided for backward compatibility, use `afterLayout` instead.
		 * @method IPlugin#afterScaleUpdate
		 * @deprecated since version 2.5.0
		 * @todo remove at version 3
		 * @private
		 */
		core_plugins.notify(me, 'afterScaleUpdate');
		core_plugins.notify(me, 'afterLayout');
	},

	/**
	 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
	 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
	 * @private
	 */
	updateDatasets: function() {
		var me = this;

		if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
			return;
		}

		for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
			me.updateDataset(i);
		}

		core_plugins.notify(me, 'afterDatasetsUpdate');
	},

	/**
	 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
	 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
	 * @private
	 */
	updateDataset: function(index) {
		var me = this;
		var meta = me.getDatasetMeta(index);
		var args = {
			meta: meta,
			index: index
		};

		if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
			return;
		}

		meta.controller.update();

		core_plugins.notify(me, 'afterDatasetUpdate', [args]);
	},

	render: function(config) {
		var me = this, _oldDefaultFontSize=core_defaults.global.defaultFontSize;

		if (!config || typeof config !== 'object') {
			// backwards compatibility
			config = {
				duration: config,
				lazy: arguments[1]
			};
		}

        if (me.defaultFontSize) core_defaults.global.defaultFontSize=me.defaultFontSize;
        
		var animationOptions = me.options.animation;
		var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
		var lazy = config.lazy;

		if (core_plugins.notify(me, 'beforeRender') === false) {
            if (me.defaultFontSize) core_defaults.global.defaultFontSize=_oldDefaultFontSize;
			return;
		}

		var onComplete = function(animation) {
			core_plugins.notify(me, 'afterRender');
			helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
		};

		if (animationOptions && duration) {
			var animation = new core_animation({
				numSteps: duration / 16.66, // 60 fps
				easing: config.easing || animationOptions.easing,

				render: function(chart, animationObject) {
					var easingFunction = helpers$1.easing.effects[animationObject.easing];
					var currentStep = animationObject.currentStep;
					var stepDecimal = currentStep / animationObject.numSteps;

					chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
				},

				onAnimationProgress: animationOptions.onProgress,
				onAnimationComplete: onComplete
			});

			core_animations.addAnimation(me, animation, duration, lazy);
		} else {
			me.draw();

			// See https://github.com/chartjs/Chart.js/issues/3781
			onComplete(new core_animation({numSteps: 0, chart: me}));
		}

        if (me.defaultFontSize) core_defaults.global.defaultFontSize=_oldDefaultFontSize;

		return me;
	},

	draw: function(easingValue) {
		var me = this;

		me.clear();

		if (helpers$1.isNullOrUndef(easingValue)) {
			easingValue = 1;
		}

		me.transition(easingValue);

		if (me.width <= 0 || me.height <= 0) {
			return;
		}

		if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
			return;
		}

		// Draw all the scales
		helpers$1.each(me.boxes, function(box) {
			box.draw(me.chartArea);
		}, me);

		me.drawDatasets(easingValue);
		me._drawTooltip(easingValue);

		core_plugins.notify(me, 'afterDraw', [easingValue]);
	},

	/**
	 * @private
	 */
	transition: function(easingValue) {
		var me = this;

		for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
			if (me.isDatasetVisible(i)) {
				me.getDatasetMeta(i).controller.transition(easingValue);
			}
		}

		me.tooltip.transition(easingValue);
	},

	/**
	 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
	 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
	 * @private
	 */
	drawDatasets: function(easingValue) {
		var me = this;

		if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
			return;
		}

		// Draw datasets reversed to support proper line stacking
		for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
			if (me.isDatasetVisible(i)) {
				me.drawDataset(i, easingValue);
			}
		}

		core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
	},

	/**
	 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
	 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
	 * @private
	 */
	drawDataset: function(index, easingValue) {
		var me = this;
		var meta = me.getDatasetMeta(index);
		var args = {
			meta: meta,
			index: index,
			easingValue: easingValue
		};

		if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
			return;
		}

		meta.controller.draw(easingValue);

		core_plugins.notify(me, 'afterDatasetDraw', [args]);
	},

	/**
	 * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
	 * hook, in which case, plugins will not be called on `afterTooltipDraw`.
	 * @private
	 */
	_drawTooltip: function(easingValue) {
		var me = this;
		var tooltip = me.tooltip;
		var args = {
			tooltip: tooltip,
			easingValue: easingValue
		};

		if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
			return;
		}

		tooltip.draw();

		core_plugins.notify(me, 'afterTooltipDraw', [args]);
	},

	/**
	 * Get the single element that was clicked on
	 * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
	 */
	getElementAtEvent: function(e) {
		return core_interaction.modes.single(this, e);
	},

	getElementsAtEvent: function(e) {
		return core_interaction.modes.label(this, e, {intersect: true});
	},

	getElementsAtXAxis: function(e) {
		return core_interaction.modes['x-axis'](this, e, {intersect: true});
	},

	getElementsAtEventForMode: function(e, mode, options) {
		var method = core_interaction.modes[mode];
		if (typeof method === 'function') {
			return method(this, e, options);
		}

		return [];
	},

	getDatasetAtEvent: function(e) {
		return core_interaction.modes.dataset(this, e, {intersect: true});
	},

	getDatasetMeta: function(datasetIndex) {
		var me = this;
		var dataset = me.data.datasets[datasetIndex];
		if (!dataset._meta) {
			dataset._meta = {};
		}

		var meta = dataset._meta[me.id];
		if (!meta) {
			meta = dataset._meta[me.id] = {
				type: null,
				data: [],
				dataset: null,
				controller: null,
				hidden: null,			// See isDatasetVisible() comment
				xAxisID: null,
				yAxisID: null
			};
		}

		return meta;
	},

	getVisibleDatasetCount: function() {
		var count = 0;
		for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
			if (this.isDatasetVisible(i)) {
				count++;
			}
		}
		return count;
	},

	isDatasetVisible: function(datasetIndex) {
		var meta = this.getDatasetMeta(datasetIndex);

		// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
		// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
		return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
	},

	generateLegend: function() {
		return this.options.legendCallback(this);
	},

	/**
	 * @private
	 */
	destroyDatasetMeta: function(datasetIndex) {
		var id = this.id;
		var dataset = this.data.datasets[datasetIndex];
		var meta = dataset._meta && dataset._meta[id];

		if (meta) {
			meta.controller.destroy();
			delete dataset._meta[id];
		}
	},

	destroy: function() {
		var me = this;
		var canvas = me.canvas;
		var i, ilen;

		me.stop();

		// dataset controllers need to cleanup associated data
		for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
			me.destroyDatasetMeta(i);
		}

		if (canvas) {
			me.unbindEvents();
			helpers$1.canvas.clear(me);
			platform.releaseContext(me.ctx);
			me.canvas = null;
			me.ctx = null;
		}

		core_plugins.notify(me, 'destroy');

		delete Chart.instances[me.id];
	},

	toBase64Image: function() {
		return this.canvas.toDataURL.apply(this.canvas, arguments);
	},

	toBinary: function() {
      var ctx = this.canvas.getContext("2d");
      return {
        width   : this.canvas.width,
        height  : this.canvas.height,
        data    : ctx.getImageData(0, 0, this.canvas.width, this.canvas.height).data
      }  
	},

	initToolTip: function() {
		var me = this;
		me.tooltip = new core_tooltip({
			_chart: me,
			_chartInstance: me, // deprecated, backward compatibility
			_data: me.data,
			_options: me.options.tooltips
		}, me);
	},

	/**
	 * @private
	 */
	bindEvents: function() {
		var me = this;
		var listeners = me._listeners = {};
		var listener = function() {
			me.eventHandler.apply(me, arguments);
		};

		helpers$1.each(me.options.events, function(type) {
			platform.addEventListener(me, type, listener);
			listeners[type] = listener;
		});

		// Elements used to detect size change should not be injected for non responsive charts.
		// See https://github.com/chartjs/Chart.js/issues/2210
		if (me.options.responsive) {
			listener = function() {
				me.resize();
			};

			platform.addEventListener(me, 'resize', listener);
			listeners.resize = listener;
		}
	},

	/**
	 * @private
	 */
	unbindEvents: function() {
		var me = this;
		var listeners = me._listeners;
		if (!listeners) {
			return;
		}

		delete me._listeners;
		helpers$1.each(listeners, function(listener, type) {
			platform.removeEventListener(me, type, listener);
		});
	},

	updateHoverStyle: function(elements, mode, enabled) {
		var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
		var element, i, ilen;

		for (i = 0, ilen = elements.length; i < ilen; ++i) {
			element = elements[i];
			if (element) {
				this.getDatasetMeta(element._datasetIndex).controller[method](element);
			}
		}
	},

	/**
	 * @private
	 */
	eventHandler: function(e) {
		var me = this;
		var tooltip = me.tooltip;

		if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
			return;
		}

		// Buffer any update calls so that renders do not occur
		me._bufferedRender = true;
		me._bufferedRequest = null;

		var changed = me.handleEvent(e);
		// for smooth tooltip animations issue #4989
		// the tooltip should be the source of change
		// Animation check workaround:
		// tooltip._start will be null when tooltip isn't animating
		if (tooltip) {
			changed = tooltip._start
				? tooltip.handleEvent(e)
				: changed | tooltip.handleEvent(e);
		}

		core_plugins.notify(me, 'afterEvent', [e]);

		var bufferedRequest = me._bufferedRequest;
		if (bufferedRequest) {
			// If we have an update that was triggered, we need to do a normal render
			me.render(bufferedRequest);
		} else if (changed && !me.animating) {
			// If entering, leaving, or changing elements, animate the change via pivot
			me.stop();

			// We only need to render at this point. Updating will cause scales to be
			// recomputed generating flicker & using more memory than necessary.
			me.render({
				duration: me.options.hover.animationDuration,
				lazy: true
			});
		}

		me._bufferedRender = false;
		me._bufferedRequest = null;

		return me;
	},

	/**
	 * Handle an event
	 * @private
	 * @param {IEvent} event the event to handle
	 * @return {boolean} true if the chart needs to re-render
	 */
	handleEvent: function(e) {
		var me = this;
		var options = me.options || {};
		var hoverOptions = options.hover;
		var changed = false;

		me.lastActive = me.lastActive || [];

		// Find Active Elements for hover and tooltips
		if (e.type === 'mouseout') {
			me.active = [];
		} else {
			me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
		}

		// Invoke onHover hook
		// Need to call with native event here to not break backwards compatibility
		helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

		if (e.type === 'mouseup' || e.type === 'click') {
			if (options.onClick) {
				// Use e.native here for backwards compatibility
				options.onClick.call(me, e.native, me.active);
			}
		}

		// Remove styling for last active (even if it may still be active)
		if (me.lastActive.length) {
			me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
		}

		// Built in hover styling
		if (me.active.length && hoverOptions.mode) {
			me.updateHoverStyle(me.active, hoverOptions.mode, true);
		}

		changed = !helpers$1.arrayEquals(me.active, me.lastActive);

		// Remember Last Actives
		me.lastActive = me.active;

		return changed;
	}
});

/**
 * NOTE(SB) We actually don't use this container anymore but we need to keep it
 * for backward compatibility. Though, it can still be useful for plugins that
 * would need to work on multiple charts?!
 */
Chart.instances = {};

var core_controller = Chart;

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart instead.
 * @class Chart.Controller
 * @deprecated since version 2.6
 * @todo remove at version 3
 * @private
 */
Chart.Controller = Chart;

/**
 * Provided for backward compatibility, not available anymore.
 * @namespace Chart
 * @deprecated since version 2.8
 * @todo remove at version 3
 * @private
 */
Chart.types = {};

/**
 * Provided for backward compatibility, not available anymore.
 * @namespace Chart.helpers.configMerge
 * @deprecated since version 2.8.0
 * @todo remove at version 3
 * @private
 */
helpers$1.configMerge = mergeConfig;

/**
 * Provided for backward compatibility, not available anymore.
 * @namespace Chart.helpers.scaleMerge
 * @deprecated since version 2.8.0
 * @todo remove at version 3
 * @private
 */
helpers$1.scaleMerge = mergeScaleConfig;

var core_helpers = function() {

	// -- Basic js utility methods

	helpers$1.where = function(collection, filterCallback) {
		if (helpers$1.isArray(collection) && Array.prototype.filter) {
			return collection.filter(filterCallback);
		}
		var filtered = [];

		helpers$1.each(collection, function(item) {
			if (filterCallback(item)) {
				filtered.push(item);
			}
		});

		return filtered;
	};
	helpers$1.findIndex = Array.prototype.findIndex ?
		function(array, callback, scope) {
			return array.findIndex(callback, scope);
		} :
		function(array, callback, scope) {
			scope = scope === undefined ? array : scope;
			for (var i = 0, ilen = array.length; i < ilen; ++i) {
				if (callback.call(scope, array[i], i, array)) {
					return i;
				}
			}
			return -1;
		};
	helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to start of the array
		if (helpers$1.isNullOrUndef(startIndex)) {
			startIndex = -1;
		}
		for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to end of the array
		if (helpers$1.isNullOrUndef(startIndex)) {
			startIndex = arrayToSearch.length;
		}
		for (var i = startIndex - 1; i >= 0; i--) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};

	// -- Math methods
	helpers$1.isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};
	helpers$1.almostEquals = function(x, y, epsilon) {
		return Math.abs(x - y) < epsilon;
	};
	helpers$1.almostWhole = function(x, epsilon) {
		var rounded = Math.round(x);
		return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
	};
	helpers$1.max = function(array) {
		return array.reduce(function(max, value) {
			if (!isNaN(value)) {
				return Math.max(max, value);
			}
			return max;
		}, Number.NEGATIVE_INFINITY);
	};
	helpers$1.min = function(array) {
		return array.reduce(function(min, value) {
			if (!isNaN(value)) {
				return Math.min(min, value);
			}
			return min;
		}, Number.POSITIVE_INFINITY);
	};
	helpers$1.sign = Math.sign ?
		function(x) {
			return Math.sign(x);
		} :
		function(x) {
			x = +x; // convert to a number
			if (x === 0 || isNaN(x)) {
				return x;
			}
			return x > 0 ? 1 : -1;
		};
	helpers$1.log10 = Math.log10 ?
		function(x) {
			return Math.log10(x);
		} :
		function(x) {
			var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
			// Check for whole powers of 10,
			// which due to floating point rounding error should be corrected.
			var powerOf10 = Math.round(exponent);
			var isPowerOf10 = x === Math.pow(10, powerOf10);

			return isPowerOf10 ? powerOf10 : exponent;
		};
	helpers$1.toRadians = function(degrees) {
		return degrees * (Math.PI / 180);
	};
	helpers$1.toDegrees = function(radians) {
		return radians * (180 / Math.PI);
	};

	/**
	 * Returns the number of decimal places
	 * i.e. the number of digits after the decimal point, of the value of this Number.
	 * @param {number} x - A number.
	 * @returns {number} The number of decimal places.
	 * @private
	 */
	helpers$1._decimalPlaces = function(x) {
		if (!helpers$1.isFinite(x)) {
			return;
		}
		var e = 1;
		var p = 0;
		while (Math.round(x * e) / e !== x) {
			e *= 10;
			p++;
		}
		return p;
	};

	// Gets the angle from vertical upright to the point about a centre.
	helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
		var distanceFromXCenter = anglePoint.x - centrePoint.x;
		var distanceFromYCenter = anglePoint.y - centrePoint.y;
		var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

		var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

		if (angle < (-0.5 * Math.PI)) {
			angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
		}

		return {
			angle: angle,
			distance: radialDistanceFromCenter
		};
	};
	helpers$1.distanceBetweenPoints = function(pt1, pt2) {
		return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
	};

	/**
	 * Provided for backward compatibility, not available anymore
	 * @function Chart.helpers.aliasPixel
	 * @deprecated since version 2.8.0
	 * @todo remove at version 3
	 */
	helpers$1.aliasPixel = function(pixelWidth) {
		return (pixelWidth % 2 === 0) ? 0 : 0.5;
	};

	/**
	 * Returns the aligned pixel value to avoid anti-aliasing blur
	 * @param {Chart} chart - The chart instance.
	 * @param {number} pixel - A pixel value.
	 * @param {number} width - The width of the element.
	 * @returns {number} The aligned pixel value.
	 * @private
	 */
	helpers$1._alignPixel = function(chart, pixel, width) {
		var devicePixelRatio = chart.currentDevicePixelRatio;
		var halfWidth = width / 2;
		return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
	};

	helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
		// Props to Rob Spencer at scaled innovation for his post on splining between points
		// http://scaledinnovation.com/analytics/splines/aboutSplines.html

		// This function must also respect "skipped" points

		var previous = firstPoint.skip ? middlePoint : firstPoint;
		var current = middlePoint;
		var next = afterPoint.skip ? middlePoint : afterPoint;

		var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
		var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

		var s01 = d01 / (d01 + d12);
		var s12 = d12 / (d01 + d12);

		// If all points are the same, s01 & s02 will be inf
		s01 = isNaN(s01) ? 0 : s01;
		s12 = isNaN(s12) ? 0 : s12;

		var fa = t * s01; // scaling factor for triangle Ta
		var fb = t * s12;

		return {
			previous: {
				x: current.x - fa * (next.x - previous.x),
				y: current.y - fa * (next.y - previous.y)
			},
			next: {
				x: current.x + fb * (next.x - previous.x),
				y: current.y + fb * (next.y - previous.y)
			}
		};
	};
	helpers$1.EPSILON = Number.EPSILON || 1e-14;
	helpers$1.splineCurveMonotone = function(points) {
		// This function calculates Bézier control points in a similar way than |splineCurve|,
		// but preserves monotonicity of the provided data and ensures no local extremums are added
		// between the dataset discrete points due to the interpolation.
		// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

		var pointsWithTangents = (points || []).map(function(point) {
			return {
				model: point._model,
				deltaK: 0,
				mK: 0
			};
		});

		// Calculate slopes (deltaK) and initialize tangents (mK)
		var pointsLen = pointsWithTangents.length;
		var i, pointBefore, pointCurrent, pointAfter;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointAfter && !pointAfter.model.skip) {
				var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

				// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
				pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
			}

			if (!pointBefore || pointBefore.model.skip) {
				pointCurrent.mK = pointCurrent.deltaK;
			} else if (!pointAfter || pointAfter.model.skip) {
				pointCurrent.mK = pointBefore.deltaK;
			} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
				pointCurrent.mK = 0;
			} else {
				pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
			}
		}

		// Adjust tangents to ensure monotonic properties
		var alphaK, betaK, tauK, squaredMagnitude;
		for (i = 0; i < pointsLen - 1; ++i) {
			pointCurrent = pointsWithTangents[i];
			pointAfter = pointsWithTangents[i + 1];
			if (pointCurrent.model.skip || pointAfter.model.skip) {
				continue;
			}

			if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
				pointCurrent.mK = pointAfter.mK = 0;
				continue;
			}

			alphaK = pointCurrent.mK / pointCurrent.deltaK;
			betaK = pointAfter.mK / pointCurrent.deltaK;
			squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
			if (squaredMagnitude <= 9) {
				continue;
			}

			tauK = 3 / Math.sqrt(squaredMagnitude);
			pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
			pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
		}

		// Compute control points
		var deltaX;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointBefore && !pointBefore.model.skip) {
				deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
				pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
				pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
			}
			if (pointAfter && !pointAfter.model.skip) {
				deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
				pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
				pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
			}
		}
	};
	helpers$1.nextItem = function(collection, index, loop) {
		if (loop) {
			return index >= collection.length - 1 ? collection[0] : collection[index + 1];
		}
		return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
	};
	helpers$1.previousItem = function(collection, index, loop) {
		if (loop) {
			return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
		}
		return index <= 0 ? collection[0] : collection[index - 1];
	};
	// Implementation of the nice number algorithm used in determining where axis labels will go
	helpers$1.niceNum = function(range, round) {
		var exponent = Math.floor(helpers$1.log10(range));
		var fraction = range / Math.pow(10, exponent);
		var niceFraction;

		if (round) {
			if (fraction < 1.5) {
				niceFraction = 1;
			} else if (fraction < 3) {
				niceFraction = 2;
			} else if (fraction < 7) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
		} else if (fraction <= 1.0) {
			niceFraction = 1;
		} else if (fraction <= 2) {
			niceFraction = 2;
		} else if (fraction <= 5) {
			niceFraction = 5;
		} else {
			niceFraction = 10;
		}

		return niceFraction * Math.pow(10, exponent);
	};
	// Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
	helpers$1.requestAnimFrame = (function() {
		if (typeof window === 'undefined') {
			return function(callback) {
				callback();
			};
		}
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				return window.setTimeout(callback, 1000 / 60);
			};
	}());
	// -- DOM methods
	helpers$1.getRelativePosition = function(evt, chart) {
		var mouseX, mouseY;
		var e = evt.originalEvent || evt;
		var canvas = evt.target || evt.srcElement;
		var boundingRect = canvas.getBoundingClientRect();

		var touches = e.touches;
		if (touches && touches.length > 0) {
			mouseX = touches[0].clientX;
			mouseY = touches[0].clientY;

		} else {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}

		// Scale mouse coordinates into canvas coordinates
		// by following the pattern laid out by 'jerryj' in the comments of
		// https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
		var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
		var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
		var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
		var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

		// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
		// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

		return {
			x: mouseX,
			y: mouseY
		};

	};

	// Private helper function to convert max-width/max-height values that may be percentages into a number
	function parseMaxStyle(styleValue, node, parentProperty) {
		var valueInPixels;
		if (typeof styleValue === 'string') {
			valueInPixels = parseInt(styleValue, 10);

			if (styleValue.indexOf('%') !== -1) {
				// percentage * size in dimension
				valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
			}
		} else {
			valueInPixels = styleValue;
		}

		return valueInPixels;
	}

	/**
	 * Returns if the given value contains an effective constraint.
	 * @private
	 */
	function isConstrainedValue(value) {
		return value !== undefined && value !== null && value !== 'none';
	}

	/**
	 * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
	 * @param {HTMLElement} domNode - the node to check the constraint on
	 * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
	 * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
	 * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
	 */
	function getConstraintDimension(domNode, maxStyle, percentageProperty) {
		var view = document.defaultView;
		var parentNode = helpers$1._getParentNode(domNode);
		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
		var hasCNode = isConstrainedValue(constrainedNode);
		var hasCContainer = isConstrainedValue(constrainedContainer);
		var infinity = Number.POSITIVE_INFINITY;

		if (hasCNode || hasCContainer) {
			return Math.min(
				hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
				hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
		}

		return 'none';
	}
	// returns Number or undefined if no constraint
	helpers$1.getConstraintWidth = function(domNode) {
		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
	};
	// returns Number or undefined if no constraint
	helpers$1.getConstraintHeight = function(domNode) {
		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
	};
	/**
	 * @private
 	 */
	helpers$1._calculatePadding = function(container, padding, parentDimension) {
		padding = helpers$1.getStyle(container, padding);

		return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
	};
	/**
	 * @private
	 */
	helpers$1._getParentNode = function(domNode) {
		var parent = domNode.parentNode;
		if (parent && parent.toString() === '[object ShadowRoot]') {
			parent = parent.host;
		}
		return parent;
	};
	helpers$1.getMaximumWidth = function(domNode) {
		var container = helpers$1._getParentNode(domNode);
		if (!container) {
			return domNode.clientWidth;
		}

		var clientWidth = container.clientWidth;
		var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);
		var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

		var w = clientWidth - paddingLeft - paddingRight;
		var cw = helpers$1.getConstraintWidth(domNode);
		return isNaN(cw) ? w : Math.min(w, cw);
	};
	helpers$1.getMaximumHeight = function(domNode) {
		var container = helpers$1._getParentNode(domNode);
		if (!container) {
			return domNode.clientHeight;
		}

		var clientHeight = container.clientHeight;
		var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);
		var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

		var h = clientHeight - paddingTop - paddingBottom;
		var ch = helpers$1.getConstraintHeight(domNode);
		return isNaN(ch) ? h : Math.min(h, ch);
	};
	helpers$1.getStyle = function(el, property) {
		return el.currentStyle ?
			el.currentStyle[property] :
			document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
	};
	helpers$1.retinaScale = function(chart, forceRatio) {
		var pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;
		if (pixelRatio === 1) {
			return;
		}

		var canvas = chart.canvas;
		var height = chart.height;
		var width = chart.width;

		canvas.height = height * pixelRatio;
		canvas.width = width * pixelRatio;
		chart.ctx.scale(pixelRatio, pixelRatio);

		// If no style has been set on the canvas, the render size is used as display size,
		// making the chart visually bigger, so let's enforce it to the "correct" values.
		// See https://github.com/chartjs/Chart.js/issues/3575
		if (!canvas.style.height && !canvas.style.width) {
			canvas.style.height = height + 'px';
			canvas.style.width = width + 'px';
		}
	};
	// -- Canvas methods
	helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
		return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
	};
	helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
		cache = cache || {};
		var data = cache.data = cache.data || {};
		var gc = cache.garbageCollect = cache.garbageCollect || [];

		if (cache.font !== font) {
			data = cache.data = {};
			gc = cache.garbageCollect = [];
			cache.font = font;
		}

		ctx.font = font;
		var longest = 0;
		helpers$1.each(arrayOfThings, function(thing) {
			// Undefined strings and arrays should not be measured
			if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
				longest = helpers$1.measureText(ctx, data, gc, longest, thing);
			} else if (helpers$1.isArray(thing)) {
				// if it is an array lets measure each element
				// to do maybe simplify this function a bit so we can do this more recursively?
				helpers$1.each(thing, function(nestedThing) {
					// Undefined strings and arrays should not be measured
					if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
						longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
					}
				});
			}
		});

		var gcLen = gc.length / 2;
		if (gcLen > arrayOfThings.length) {
			for (var i = 0; i < gcLen; i++) {
				delete data[gc[i]];
			}
			gc.splice(0, gcLen);
		}
		return longest;
	};
	helpers$1.measureText = function(ctx, data, gc, longest, string) {
		var textWidth = data[string];
		if (!textWidth) {
			textWidth = data[string] = ctx.measureText(string).width;
			gc.push(string);
		}
		if (textWidth > longest) {
			longest = textWidth;
		}
		return longest;
	};
	helpers$1.numberOfLabelLines = function(arrayOfThings) {
		var numberOfLines = 1;
		helpers$1.each(arrayOfThings, function(thing) {
			if (helpers$1.isArray(thing)) {
				if (thing.length > numberOfLines) {
					numberOfLines = thing.length;
				}
			}
		});
		return numberOfLines;
	};

	helpers$1.color = !chartjsColor ?
		function(value) {
			console.error('Color.js not found!');
			return value;
		} :
		function(value) {
			/* global CanvasGradient */
			if (value instanceof CanvasGradient) {
				value = core_defaults.global.defaultColor;
			}

			return chartjsColor(value);
		};

	helpers$1.getHoverColor = function(colorValue) {
		/* global CanvasPattern */
		return (colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient) ?
			colorValue :
			helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
	};
};

function abstract() {
	throw new Error(
		'This method is not implemented: either no adapter can ' +
		'be found or an incomplete integration was provided.'
	);
}

/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */

/**
 * Currently supported unit string values.
 * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
 * @memberof Chart._adapters._date
 * @name Unit
 */

/**
 * @class
 */
function DateAdapter(options) {
	this.options = options || {};
}

helpers$1.extend(DateAdapter.prototype, /** @lends DateAdapter */ {
	/**
	 * Returns a map of time formats for the supported formatting units defined
	 * in Unit as well as 'datetime' representing a detailed date/time string.
	 * @returns {{string: string}}
	 */
	formats: abstract,

	/**
	 * Parses the given `value` and return the associated timestamp.
	 * @param {any} value - the value to parse (usually comes from the data)
	 * @param {string} [format] - the expected data format
	 * @returns {(number|null)}
	 * @function
	 */
	parse: abstract,

	/**
	 * Returns the formatted date in the specified `format` for a given `timestamp`.
	 * @param {number} timestamp - the timestamp to format
	 * @param {string} format - the date/time token
	 * @return {string}
	 * @function
	 */
	format: abstract,

	/**
	 * Adds the specified `amount` of `unit` to the given `timestamp`.
	 * @param {number} timestamp - the input timestamp
	 * @param {number} amount - the amount to add
	 * @param {Unit} unit - the unit as string
	 * @return {number}
	 * @function
	 */
	add: abstract,

	/**
	 * Returns the number of `unit` between the given timestamps.
	 * @param {number} max - the input timestamp (reference)
	 * @param {number} min - the timestamp to substract
	 * @param {Unit} unit - the unit as string
	 * @return {number}
	 * @function
	 */
	diff: abstract,

	/**
	 * Returns start of `unit` for the given `timestamp`.
	 * @param {number} timestamp - the input timestamp
	 * @param {Unit} unit - the unit as string
	 * @param {number} [weekday] - the ISO day of the week with 1 being Monday
	 * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
	 * @function
	 */
	startOf: abstract,

	/**
	 * Returns end of `unit` for the given `timestamp`.
	 * @param {number} timestamp - the input timestamp
	 * @param {Unit} unit - the unit as string
	 * @function
	 */
	endOf: abstract,

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility for scale.getValueForPixel(),
	 * this method should be overridden only by the moment adapter.
	 * @deprecated since version 2.8.0
	 * @todo remove at version 3
	 * @private
	 */
	_create: function(value) {
		return value;
	}
});

DateAdapter.override = function(members) {
	helpers$1.extend(DateAdapter.prototype, members);
};

var _date = DateAdapter;

var core_adapters = {
	_date: _date
};

/**
 * Namespace to hold static tick generation functions
 * @namespace Chart.Ticks
 */
var core_ticks = {
	/**
	 * Namespace to hold formatters for different types of ticks
	 * @namespace Chart.Ticks.formatters
	 */
	formatters: {
		/**
		 * Formatter for value labels
		 * @method Chart.Ticks.formatters.values
		 * @param value the value to display
		 * @return {string|string[]} the label to display
		 */
		values: function(value) {
			return helpers$1.isArray(value) ? value : '' + value;
		},

		/**
		 * Formatter for linear numeric ticks
		 * @method Chart.Ticks.formatters.linear
		 * @param tickValue {number} the value to be formatted
		 * @param index {number} the position of the tickValue parameter in the ticks array
		 * @param ticks {number[]} the list of ticks being converted
		 * @return {string} string representation of the tickValue parameter
		 */
		linear: function(tickValue, index, ticks) {
			// If we have lots of ticks, don't use the ones
			var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

			// If we have a number like 2.5 as the delta, figure out how many decimal places we need
			if (Math.abs(delta) > 1) {
				if (tickValue !== Math.floor(tickValue)) {
					// not an integer
					delta = tickValue - Math.floor(tickValue);
				}
			}

			var logDelta = helpers$1.log10(Math.abs(delta));
			var tickString = '';

			if (tickValue !== 0) {
				var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
				if (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation
					var logTick = helpers$1.log10(Math.abs(tickValue));
					tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
				} else {
					var numDecimal = -1 * Math.floor(logDelta);
					numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString = tickValue.toFixed(numDecimal);
				}
			} else {
				tickString = '0'; // never show decimal places for 0
			}

			return tickString;
		},

		logarithmic: function(tickValue, index, ticks) {
			var remain = tickValue / (Math.pow(10, Math.floor(helpers$1.log10(tickValue))));

			if (tickValue === 0) {
				return '0';
			} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
				return tickValue.toExponential();
			}
			return '';
		}
	}
};

var valueOrDefault$9 = helpers$1.valueOrDefault;
var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

core_defaults._set('scale', {
	display: true,
	position: 'left',
	offset: false,

	// grid line settings
	gridLines: {
		display: true,
		color: 'rgba(0, 0, 0, 0.1)',
		lineWidth: 1,
		drawBorder: true,
		drawOnChartArea: true,
		drawTicks: true,
		tickMarkLength: 10,
		zeroLineWidth: 1,
		zeroLineColor: 'rgba(0,0,0,0.25)',
		zeroLineBorderDash: [],
		zeroLineBorderDashOffset: 0.0,
		offsetGridLines: false,
		borderDash: [],
		borderDashOffset: 0.0
	},

	// scale label
	scaleLabel: {
		// display property
		display: false,

		// actual label
		labelString: '',

		// top/bottom padding
		padding: {
			top: 4,
			bottom: 4
		}
	},

	// label settings
	ticks: {
		beginAtZero: false,
		minRotation: 0,
		maxRotation: 50,
		mirror: false,
		padding: 0,
		reverse: false,
		display: true,
		autoSkip: true,
		autoSkipPadding: 0,
		labelOffset: 0,
		// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
		callback: core_ticks.formatters.values,
		minor: {},
		major: {}
	}
});

function labelsFromTicks(ticks) {
	var labels = [];
	var i, ilen;

	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
		labels.push(ticks[i].label);
	}

	return labels;
}

function getPixelForGridLine(scale, index, offsetGridLines) {
	var lineValue = scale.getPixelForTick(index);

	if (offsetGridLines) {
		if (scale.getTicks().length === 1) {
			lineValue -= scale.isHorizontal() ?
				Math.max(lineValue - scale.left, scale.right - lineValue) :
				Math.max(lineValue - scale.top, scale.bottom - lineValue);
		} else if (index === 0) {
			lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
		} else {
			lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
		}
	}
	return lineValue;
}

function computeTextSize(context, tick, font) {
	return helpers$1.isArray(tick) ?
		helpers$1.longestText(context, font, tick) :
		context.measureText(tick).width;
}

var core_scale = core_element.extend({
	/**
	 * Get the padding needed for the scale
	 * @method getPadding
	 * @private
	 * @returns {Padding} the necessary padding
	 */
	getPadding: function() {
		var me = this;
		return {
			left: me.paddingLeft || 0,
			top: me.paddingTop || 0,
			right: me.paddingRight || 0,
			bottom: me.paddingBottom || 0
		};
	},

	/**
	 * Returns the scale tick objects ({label, major})
	 * @since 2.7
	 */
	getTicks: function() {
		return this._ticks;
	},

	// These methods are ordered by lifecyle. Utilities then follow.
	// Any function defined here is inherited by all scale types.
	// Any function can be extended by the scale type

	mergeTicksOptions: function() {
		var ticks = this.options.ticks;
		if (ticks.minor === false) {
			ticks.minor = {
				display: false
			};
		}
		if (ticks.major === false) {
			ticks.major = {
				display: false
			};
		}
		for (var key in ticks) {
			if (key !== 'major' && key !== 'minor') {
				if (typeof ticks.minor[key] === 'undefined') {
					ticks.minor[key] = ticks[key];
				}
				if (typeof ticks.major[key] === 'undefined') {
					ticks.major[key] = ticks[key];
				}
			}
		}
	},
	beforeUpdate: function() {
		helpers$1.callback(this.options.beforeUpdate, [this]);
	},

	update: function(maxWidth, maxHeight, margins) {
		var me = this;
		var i, ilen, labels, label, ticks, tick;

		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
		me.beforeUpdate();

		// Absorb the master measurements
		me.maxWidth = maxWidth;
		me.maxHeight = maxHeight;
		me.margins = helpers$1.extend({
			left: 0,
			right: 0,
			top: 0,
			bottom: 0
		}, margins);

		me._maxLabelLines = 0;
		me.longestLabelWidth = 0;
		me.longestTextCache = me.longestTextCache || {};

		// Dimensions
		me.beforeSetDimensions();
		me.setDimensions();
		me.afterSetDimensions();

		// Data min/max
		me.beforeDataLimits();
		me.determineDataLimits();
		me.afterDataLimits();

		// Ticks - `this.ticks` is now DEPRECATED!
		// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
		// and must not be accessed directly from outside this class. `this.ticks` being
		// around for long time and not marked as private, we can't change its structure
		// without unexpected breaking changes. If you need to access the scale ticks,
		// use scale.getTicks() instead.

		me.beforeBuildTicks();

		// New implementations should return an array of objects but for BACKWARD COMPAT,
		// we still support no return (`this.ticks` internally set by calling this method).
		ticks = me.buildTicks() || [];

		// Allow modification of ticks in callback.
		ticks = me.afterBuildTicks(ticks) || ticks;

		me.beforeTickToLabelConversion();

		// New implementations should return the formatted tick labels but for BACKWARD
		// COMPAT, we still support no return (`this.ticks` internally changed by calling
		// this method and supposed to contain only string values).
		labels = me.convertTicksToLabels(ticks) || me.ticks;

		me.afterTickToLabelConversion();

		me.ticks = labels;   // BACKWARD COMPATIBILITY

		// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

		// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
		for (i = 0, ilen = labels.length; i < ilen; ++i) {
			label = labels[i];
			tick = ticks[i];
			if (!tick) {
				ticks.push(tick = {
					label: label,
					major: false
				});
			} else {
				tick.label = label;
			}
		}

		me._ticks = ticks;

		// Tick Rotation
		me.beforeCalculateTickRotation();
		me.calculateTickRotation();
		me.afterCalculateTickRotation();
		// Fit
		me.beforeFit();
		me.fit();
		me.afterFit();
		//
		me.afterUpdate();

		return me.minSize;

	},
	afterUpdate: function() {
		helpers$1.callback(this.options.afterUpdate, [this]);
	},

	//

	beforeSetDimensions: function() {
		helpers$1.callback(this.options.beforeSetDimensions, [this]);
	},
	setDimensions: function() {
		var me = this;
		// Set the unconstrained dimension before label rotation
		if (me.isHorizontal()) {
			// Reset position before calculating rotation
			me.width = me.maxWidth;
			me.left = 0;
			me.right = me.width;
		} else {
			me.height = me.maxHeight;

			// Reset position before calculating rotation
			me.top = 0;
			me.bottom = me.height;
		}

		// Reset padding
		me.paddingLeft = 0;
		me.paddingTop = 0;
		me.paddingRight = 0;
		me.paddingBottom = 0;
	},
	afterSetDimensions: function() {
		helpers$1.callback(this.options.afterSetDimensions, [this]);
	},

	// Data limits
	beforeDataLimits: function() {
		helpers$1.callback(this.options.beforeDataLimits, [this]);
	},
	determineDataLimits: helpers$1.noop,
	afterDataLimits: function() {
		helpers$1.callback(this.options.afterDataLimits, [this]);
	},

	//
	beforeBuildTicks: function() {
		helpers$1.callback(this.options.beforeBuildTicks, [this]);
	},
	buildTicks: helpers$1.noop,
	afterBuildTicks: function(ticks) {
		var me = this;
		// ticks is empty for old axis implementations here
		if (helpers$1.isArray(ticks) && ticks.length) {
			return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
		}
		// Support old implementations (that modified `this.ticks` directly in buildTicks)
		me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
		return ticks;
	},

	beforeTickToLabelConversion: function() {
		helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
	},
	convertTicksToLabels: function() {
		var me = this;
		// Convert ticks to strings
		var tickOpts = me.options.ticks;
		me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
	},
	afterTickToLabelConversion: function() {
		helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
	},

	//

	beforeCalculateTickRotation: function() {
		helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
	},
	calculateTickRotation: function() {
		var me = this;
		var context = me.ctx;
		var tickOpts = me.options.ticks;
		var labels = labelsFromTicks(me._ticks);

		// Get the width of each grid by calculating the difference
		// between x offsets between 0 and 1.
		var tickFont = helpers$1.options._parseFont(tickOpts);
		context.font = tickFont.string;

		var labelRotation = tickOpts.minRotation || 0;

		if (labels.length && me.options.display && me.isHorizontal()) {
			var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
			var labelWidth = originalLabelWidth;
			var cosRotation, sinRotation;

			// Allow 3 pixels x2 padding either side for label readability
			var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

			// Max label rotation can be set or default to 90 - also act as a loop counter
			while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
				var angleRadians = helpers$1.toRadians(labelRotation);
				cosRotation = Math.cos(angleRadians);
				sinRotation = Math.sin(angleRadians);

				if (sinRotation * originalLabelWidth > me.maxHeight) {
					// go back one step
					labelRotation--;
					break;
				}

				labelRotation++;
				labelWidth = cosRotation * originalLabelWidth;
			}
		}

		me.labelRotation = labelRotation;
	},
	afterCalculateTickRotation: function() {
		helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
	},

	//

	beforeFit: function() {
		helpers$1.callback(this.options.beforeFit, [this]);
	},
	fit: function() {
		var me = this;
		// Reset
		var minSize = me.minSize = {
			width: 0,
			height: 0
		};

		var labels = labelsFromTicks(me._ticks);

		var opts = me.options;
		var tickOpts = opts.ticks;
		var scaleLabelOpts = opts.scaleLabel;
		var gridLineOpts = opts.gridLines;
		var display = me._isVisible();
		var position = opts.position;
		var isHorizontal = me.isHorizontal();

		var parseFont = helpers$1.options._parseFont;
		var tickFont = parseFont(tickOpts);
		var tickMarkLength = opts.gridLines.tickMarkLength;

		// Width
		if (isHorizontal) {
			// subtract the margins to line up with the chartArea if we are a full width scale
			minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
		} else {
			minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
		}

		// height
		if (isHorizontal) {
			minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
		} else {
			minSize.height = me.maxHeight; // fill all the height
		}

		// Are we showing a title for the scale?
		if (scaleLabelOpts.display && display) {
			var scaleLabelFont = parseFont(scaleLabelOpts);
			var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
			var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

			if (isHorizontal) {
				minSize.height += deltaHeight;
			} else {
				minSize.width += deltaHeight;
			}
		}

		// Don't bother fitting the ticks if we are not showing the labels
		if (tickOpts.display && display) {
			var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
			var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
			var lineSpace = tickFont.size * 0.5;
			var tickPadding = me.options.ticks.padding;

			// Store max number of lines and widest label for _autoSkip
			me._maxLabelLines = tallestLabelHeightInLines;
			me.longestLabelWidth = largestTextWidth;

			if (isHorizontal) {
				var angleRadians = helpers$1.toRadians(me.labelRotation);
				var cosRotation = Math.cos(angleRadians);
				var sinRotation = Math.sin(angleRadians);

				// TODO - improve this calculation
				var labelHeight = (sinRotation * largestTextWidth)
					+ (tickFont.lineHeight * tallestLabelHeightInLines)
					+ lineSpace; // padding

				minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

				me.ctx.font = tickFont.string;
				var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
				var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
				var offsetLeft = me.getPixelForTick(0) - me.left;
				var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
				var paddingLeft, paddingRight;

				// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
				// which means that the right padding is dominated by the font height
				if (me.labelRotation !== 0) {
					paddingLeft = position === 'bottom' ? (cosRotation * firstLabelWidth) : (cosRotation * lineSpace);
					paddingRight = position === 'bottom' ? (cosRotation * lineSpace) : (cosRotation * lastLabelWidth);
				} else {
					paddingLeft = firstLabelWidth / 2;
					paddingRight = lastLabelWidth / 2;
				}
				me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges
				me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
			} else {
				// A vertical axis is more constrained by the width. Labels are the
				// dominant factor here, so get that length first and account for padding
				if (tickOpts.mirror) {
					largestTextWidth = 0;
				} else {
					// use lineSpace for consistency with horizontal axis
					// tickPadding is not implemented for horizontal
					largestTextWidth += tickPadding + lineSpace;
				}

				minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

				me.paddingTop = tickFont.size / 2;
				me.paddingBottom = tickFont.size / 2;
			}
		}

		me.handleMargins();

		me.width = minSize.width;
		me.height = minSize.height;
	},

	/**
	 * Handle margins and padding interactions
	 * @private
	 */
	handleMargins: function() {
		var me = this;
		if (me.margins) {
			me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
			me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
			me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
			me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
		}
	},

	afterFit: function() {
		helpers$1.callback(this.options.afterFit, [this]);
	},

	// Shared Methods
	isHorizontal: function() {
		return this.options.position === 'top' || this.options.position === 'bottom';
	},
	isFullWidth: function() {
		return (this.options.fullWidth);
	},

	// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
	getRightValue: function(rawValue) {
		// Null and undefined values first
		if (helpers$1.isNullOrUndef(rawValue)) {
			return NaN;
		}
		// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
		if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
			return NaN;
		}
		// If it is in fact an object, dive in one more level
		if (rawValue) {
			if (this.isHorizontal()) {
				if (rawValue.x !== undefined) {
					return this.getRightValue(rawValue.x);
				}
			} else if (rawValue.y !== undefined) {
				return this.getRightValue(rawValue.y);
			}
		}

		// Value is good, return it
		return rawValue;
	},

	/**
	 * Used to get the value to display in the tooltip for the data at the given index
	 * @param index
	 * @param datasetIndex
	 */
	getLabelForIndex: helpers$1.noop,

	/**
	 * Returns the location of the given data point. Value can either be an index or a numerical value
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 * @param value
	 * @param index
	 * @param datasetIndex
	 */
	getPixelForValue: helpers$1.noop,

	/**
	 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 * @param pixel
	 */
	getValueForPixel: helpers$1.noop,

	/**
	 * Returns the location of the tick at the given index
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 */
	getPixelForTick: function(index) {
		var me = this;
		var offset = me.options.offset;
		if (me.isHorizontal()) {
			var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
			var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
			var pixel = (tickWidth * index) + me.paddingLeft;

			if (offset) {
				pixel += tickWidth / 2;
			}

			var finalVal = me.left + pixel;
			finalVal += me.isFullWidth() ? me.margins.left : 0;
			return finalVal;
		}
		var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
		return me.top + (index * (innerHeight / (me._ticks.length - 1)));
	},

	/**
	 * Utility for getting the pixel location of a percentage of scale
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 */
	getPixelForDecimal: function(decimal) {
		var me = this;
		if (me.isHorizontal()) {
			var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
			var valueOffset = (innerWidth * decimal) + me.paddingLeft;

			var finalVal = me.left + valueOffset;
			finalVal += me.isFullWidth() ? me.margins.left : 0;
			return finalVal;
		}
		return me.top + (decimal * me.height);
	},

	/**
	 * Returns the pixel for the minimum chart value
	 * The coordinate (0, 0) is at the upper-left corner of the canvas
	 */
	getBasePixel: function() {
		return this.getPixelForValue(this.getBaseValue());
	},

	getBaseValue: function() {
		var me = this;
		var min = me.min;
		var max = me.max;

		return me.beginAtZero ? 0 :
			min < 0 && max < 0 ? max :
			min > 0 && max > 0 ? min :
			0;
	},

	/**
	 * Returns a subset of ticks to be plotted to avoid overlapping labels.
	 * @private
	 */
	_autoSkip: function(ticks) {
		var me = this;
		var isHorizontal = me.isHorizontal();
		var optionTicks = me.options.ticks.minor;
		var tickCount = ticks.length;
		var skipRatio = false;
		var maxTicks = optionTicks.maxTicksLimit;

		// Total space needed to display all ticks. First and last ticks are
		// drawn as their center at end of axis, so tickCount-1
		var ticksLength = me._tickSize() * (tickCount - 1);

		// Axis length
		var axisLength = isHorizontal
			? me.width - (me.paddingLeft + me.paddingRight)
			: me.height - (me.paddingTop + me.PaddingBottom);

		var result = [];
		var i, tick;

		if (ticksLength > axisLength) {
			skipRatio = 1 + Math.floor(ticksLength / axisLength);
		}

		// if they defined a max number of optionTicks,
		// increase skipRatio until that number is met
		if (tickCount > maxTicks) {
			skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
		}

		for (i = 0; i < tickCount; i++) {
			tick = ticks[i];

			if (skipRatio > 1 && i % skipRatio > 0) {
				// leave tick in place but make sure it's not displayed (#4635)
				delete tick.label;
			}
			result.push(tick);
		}
		return result;
	},

	/**
	 * @private
	 */
	_tickSize: function() {
		var me = this;
		var isHorizontal = me.isHorizontal();
		var optionTicks = me.options.ticks.minor;

		// Calculate space needed by label in axis direction.
		var rot = helpers$1.toRadians(me.labelRotation);
		var cos = Math.abs(Math.cos(rot));
		var sin = Math.abs(Math.sin(rot));

		var padding = optionTicks.autoSkipPadding || 0;
		var w = (me.longestLabelWidth + padding) || 0;

		var tickFont = helpers$1.options._parseFont(optionTicks);
		var h = (me._maxLabelLines * tickFont.lineHeight + padding) || 0;

		// Calculate space needed for 1 tick in axis direction.
		return isHorizontal
			? h * cos > w * sin ? w / cos : h / sin
			: h * sin < w * cos ? h / cos : w / sin;
	},

	/**
	 * @private
	 */
	_isVisible: function() {
		var me = this;
		var chart = me.chart;
		var display = me.options.display;
		var i, ilen, meta;

		if (display !== 'auto') {
			return !!display;
		}

		// When 'auto', the scale is visible if at least one associated dataset is visible.
		for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
			if (chart.isDatasetVisible(i)) {
				meta = chart.getDatasetMeta(i);
				if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
					return true;
				}
			}
		}

		return false;
	},

	/**
	 * Actually draw the scale on the canvas
	 * @param {object} chartArea - the area of the chart to draw full grid lines on
	 */
	draw: function(chartArea) {
		var me = this;
		var options = me.options;

		if (!me._isVisible()) {
			return;
		}
		var chart = me.chart;
		var context = me.ctx;
		var globalDefaults = core_defaults.global;
		var defaultFontColor = globalDefaults.defaultFontColor;
		var optionTicks = options.ticks.minor;
		var optionMajorTicks = options.ticks.major || optionTicks;
		var gridLines = options.gridLines;
		var scaleLabel = options.scaleLabel;
		var position = options.position;

		var isRotated = me.labelRotation !== 0;
		var isMirrored = optionTicks.mirror;
		var isHorizontal = me.isHorizontal();

		var parseFont = helpers$1.options._parseFont;
		var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
		var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
		var tickFont = parseFont(optionTicks);
		var lineHeight = tickFont.lineHeight;
		var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
		var majorTickFont = parseFont(optionMajorTicks);
		var tickPadding = optionTicks.padding;
		var labelOffset = optionTicks.labelOffset;

		var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

		var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
		var scaleLabelFont = parseFont(scaleLabel);
		var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
		var labelRotationRadians = helpers$1.toRadians(me.labelRotation);

		var itemsToDraw = [];

		var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
		var alignPixel = helpers$1._alignPixel;
		var borderValue, tickStart, tickEnd;

		if (position === 'top') {
			borderValue = alignPixel(chart, me.bottom, axisWidth);
			tickStart = me.bottom - tl;
			tickEnd = borderValue - axisWidth / 2;
		} else if (position === 'bottom') {
			borderValue = alignPixel(chart, me.top, axisWidth);
			tickStart = borderValue + axisWidth / 2;
			tickEnd = me.top + tl;
		} else if (position === 'left') {
			borderValue = alignPixel(chart, me.right, axisWidth);
			tickStart = me.right - tl;
			tickEnd = borderValue - axisWidth / 2;
		} else {
			borderValue = alignPixel(chart, me.left, axisWidth);
			tickStart = borderValue + axisWidth / 2;
			tickEnd = me.left + tl;
		}

		var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

		helpers$1.each(ticks, function(tick, index) {
			// autoskipper skipped this tick (#4635)
			if (helpers$1.isNullOrUndef(tick.label)) {
				return;
			}

			var label = tick.label;
			var lineWidth, lineColor, borderDash, borderDashOffset;
			if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
				// Draw the first index specially
				lineWidth = gridLines.zeroLineWidth;
				lineColor = gridLines.zeroLineColor;
				borderDash = gridLines.zeroLineBorderDash || [];
				borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
			} else {
				lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
				lineColor = valueAtIndexOrDefault(gridLines.color, index);
				borderDash = gridLines.borderDash || [];
				borderDashOffset = gridLines.borderDashOffset || 0.0;
			}

			// Common properties
			var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
			var labelCount = helpers$1.isArray(label) ? label.length : 1;
			var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

			if (isHorizontal) {
				var labelYOffset = tl + tickPadding;

				if (lineValue < me.left - epsilon) {
					lineColor = 'rgba(0,0,0,0)';
				}

				tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
				ty1 = tickStart;
				ty2 = tickEnd;
				labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

				if (position === 'top') {
					y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
					y2 = chartArea.bottom;
					textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
					textAlign = !isRotated ? 'center' : 'left';
					labelY = me.bottom - labelYOffset;
				} else {
					y1 = chartArea.top;
					y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
					textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
					textAlign = !isRotated ? 'center' : 'right';
					labelY = me.top + labelYOffset;
				}
			} else {
				var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

				if (lineValue < me.top - epsilon) {
					lineColor = 'rgba(0,0,0,0)';
				}

				tx1 = tickStart;
				tx2 = tickEnd;
				ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
				labelY = me.getPixelForTick(index) + labelOffset;
				textOffset = (1 - labelCount) * lineHeight / 2;

				if (position === 'left') {
					x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
					x2 = chartArea.right;
					textAlign = isMirrored ? 'left' : 'right';
					labelX = me.right - labelXOffset;
				} else {
					x1 = chartArea.left;
					x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
					textAlign = isMirrored ? 'right' : 'left';
					labelX = me.left + labelXOffset;
				}
			}

			itemsToDraw.push({
				tx1: tx1,
				ty1: ty1,
				tx2: tx2,
				ty2: ty2,
				x1: x1,
				y1: y1,
				x2: x2,
				y2: y2,
				labelX: labelX,
				labelY: labelY,
				glWidth: lineWidth,
				glColor: lineColor,
				glBorderDash: borderDash,
				glBorderDashOffset: borderDashOffset,
				rotation: -1 * labelRotationRadians,
				label: label,
				major: tick.major,
				textOffset: textOffset,
				textAlign: textAlign
			});
		});

		// Draw all of the tick labels, tick marks, and grid lines at the correct places
		helpers$1.each(itemsToDraw, function(itemToDraw) {
			var glWidth = itemToDraw.glWidth;
			var glColor = itemToDraw.glColor;

			if (gridLines.display && glWidth && glColor) {
				context.save();
				context.lineWidth = glWidth;
				context.strokeStyle = glColor;
				if (context.setLineDash) {
					context.setLineDash(itemToDraw.glBorderDash);
					context.lineDashOffset = itemToDraw.glBorderDashOffset;
				}

				context.beginPath();

				if (gridLines.drawTicks) {
					context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
					context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
				}

				if (gridLines.drawOnChartArea) {
					context.moveTo(itemToDraw.x1, itemToDraw.y1);
					context.lineTo(itemToDraw.x2, itemToDraw.y2);
				}

				context.stroke();
				context.restore();
			}

			if (optionTicks.display) {
				// Make sure we draw text in the correct color and font
				context.save();
				context.translate(itemToDraw.labelX, itemToDraw.labelY);
				context.rotate(itemToDraw.rotation);
				context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
				context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
				context.textBaseline = 'middle';
				context.textAlign = itemToDraw.textAlign;

				var label = itemToDraw.label;
				var y = itemToDraw.textOffset;
				if (helpers$1.isArray(label)) {
					for (var i = 0; i < label.length; ++i) {
						// We just make sure the multiline element is a string here..
						context.fillText('' + label[i], 0, y);
						y += lineHeight;
					}
				} else {
					context.fillText(label, 0, y);
				}
				context.restore();
			}
		});

		if (scaleLabel.display) {
			// Draw the scale label
			var scaleLabelX;
			var scaleLabelY;
			var rotation = 0;
			var halfLineHeight = scaleLabelFont.lineHeight / 2;

			if (isHorizontal) {
				scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
				scaleLabelY = position === 'bottom'
					? me.bottom - halfLineHeight - scaleLabelPadding.bottom
					: me.top + halfLineHeight + scaleLabelPadding.top;
			} else {
				var isLeft = position === 'left';
				scaleLabelX = isLeft
					? me.left + halfLineHeight + scaleLabelPadding.top
					: me.right - halfLineHeight - scaleLabelPadding.top;
				scaleLabelY = me.top + ((me.bottom - me.top) / 2);
				rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
			}

			context.save();
			context.translate(scaleLabelX, scaleLabelY);
			context.rotate(rotation);
			context.textAlign = 'center';
			context.textBaseline = 'middle';
			context.fillStyle = scaleLabelFontColor; // render in correct colour
			context.font = scaleLabelFont.string;
			context.fillText(scaleLabel.labelString, 0, 0);
			context.restore();
		}

		if (axisWidth) {
			// Draw the line at the edge of the axis
			var firstLineWidth = axisWidth;
			var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
			var x1, x2, y1, y2;

			if (isHorizontal) {
				x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
				x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
				y1 = y2 = borderValue;
			} else {
				y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
				y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
				x1 = x2 = borderValue;
			}

			context.lineWidth = axisWidth;
			context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
			context.beginPath();
			context.moveTo(x1, y1);
			context.lineTo(x2, y2);
			context.stroke();
		}
	}
});

var defaultConfig = {
	position: 'bottom'
};

var scale_category = core_scale.extend({
	/**
	* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
	* else fall back to data.labels
	* @private
	*/
	getLabels: function() {
		var data = this.chart.data;
		return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
	},

	determineDataLimits: function() {
		var me = this;
		var labels = me.getLabels();
		me.minIndex = 0;
		me.maxIndex = labels.length - 1;
		var findIndex;

		if (me.options.ticks.min !== undefined) {
			// user specified min value
			findIndex = labels.indexOf(me.options.ticks.min);
			me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
		}

		if (me.options.ticks.max !== undefined) {
			// user specified max value
			findIndex = labels.indexOf(me.options.ticks.max);
			me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
		}

		me.min = labels[me.minIndex];
		me.max = labels[me.maxIndex];
	},

	buildTicks: function() {
		var me = this;
		var labels = me.getLabels();
		// If we are viewing some subset of labels, slice the original array
		me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
	},

	getLabelForIndex: function(index, datasetIndex) {
		var me = this;
		var chart = me.chart;

		if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
			return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
		}

		return me.ticks[index - me.minIndex];
	},

	// Used to get data value locations.  Value can either be an index or a numerical value
	getPixelForValue: function(value, index) {
		var me = this;
		var offset = me.options.offset;
		// 1 is added because we need the length but we have the indexes
		var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);

		// If value is a data object, then index is the index in the data array,
		// not the index of the scale. We need to change that.
		var valueCategory;
		if (value !== undefined && value !== null) {
			valueCategory = me.isHorizontal() ? value.x : value.y;
		}
		if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
			var labels = me.getLabels();
			value = valueCategory || value;
			var idx = labels.indexOf(value);
			index = idx !== -1 ? idx : index;
		}

		if (me.isHorizontal()) {
			var valueWidth = me.width / offsetAmt;
			var widthOffset = (valueWidth * (index - me.minIndex));

			if (offset) {
				widthOffset += (valueWidth / 2);
			}

			return me.left + widthOffset;
		}
		var valueHeight = me.height / offsetAmt;
		var heightOffset = (valueHeight * (index - me.minIndex));

		if (offset) {
			heightOffset += (valueHeight / 2);
		}

		return me.top + heightOffset;
	},

	getPixelForTick: function(index) {
		return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
	},

	getValueForPixel: function(pixel) {
		var me = this;
		var offset = me.options.offset;
		var value;
		var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
		var horz = me.isHorizontal();
		var valueDimension = (horz ? me.width : me.height) / offsetAmt;

		pixel -= horz ? me.left : me.top;

		if (offset) {
			pixel -= (valueDimension / 2);
		}

		if (pixel <= 0) {
			value = 0;
		} else {
			value = Math.round(pixel / valueDimension);
		}

		return value + me.minIndex;
	},

	getBasePixel: function() {
		return this.bottom;
	}
});

// INTERNAL: static default options, registered in src/index.js
var _defaults = defaultConfig;
scale_category._defaults = _defaults;

var noop = helpers$1.noop;
var isNullOrUndef = helpers$1.isNullOrUndef;

/**
 * Generate a set of linear ticks
 * @param generationOptions the options used to generate the ticks
 * @param dataRange the range of the data
 * @returns {number[]} array of tick values
 */
function generateTicks(generationOptions, dataRange) {
	var ticks = [];
	// To get a "nice" value for the tick spacing, we will use the appropriately named
	// "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
	// for details.

	var MIN_SPACING = 1e-14;
	var stepSize = generationOptions.stepSize;
	var unit = stepSize || 1;
	var maxNumSpaces = generationOptions.maxTicks - 1;
	var min = generationOptions.min;
	var max = generationOptions.max;
	var precision = generationOptions.precision;
	var rmin = dataRange.min;
	var rmax = dataRange.max;
	var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
	var factor, niceMin, niceMax, numSpaces;

	// Beyond MIN_SPACING floating point numbers being to lose precision
	// such that we can't do the math necessary to generate ticks
	if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
		return [rmin, rmax];
	}

	numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
	if (numSpaces > maxNumSpaces) {
		// If the calculated num of spaces exceeds maxNumSpaces, recalculate it
		spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
	}

	if (stepSize || isNullOrUndef(precision)) {
		// If a precision is not specified, calculate factor based on spacing
		factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
	} else {
		// If the user specified a precision, round to that number of decimal places
		factor = Math.pow(10, precision);
		spacing = Math.ceil(spacing * factor) / factor;
	}

	niceMin = Math.floor(rmin / spacing) * spacing;
	niceMax = Math.ceil(rmax / spacing) * spacing;

	// If min, max and stepSize is set and they make an evenly spaced scale use it.
	if (stepSize) {
		// If very close to our whole number, use it.
		if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
			niceMin = min;
		}
		if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
			niceMax = max;
		}
	}

	numSpaces = (niceMax - niceMin) / spacing;
	// If very close to our rounded value, use it.
	if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
		numSpaces = Math.round(numSpaces);
	} else {
		numSpaces = Math.ceil(numSpaces);
	}

	niceMin = Math.round(niceMin * factor) / factor;
	niceMax = Math.round(niceMax * factor) / factor;
	ticks.push(isNullOrUndef(min) ? niceMin : min);
	for (var j = 1; j < numSpaces; ++j) {
		ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
	}
	ticks.push(isNullOrUndef(max) ? niceMax : max);

	return ticks;
}

var scale_linearbase = core_scale.extend({
	getRightValue: function(value) {
		if (typeof value === 'string') {
			return +value;
		}
		return core_scale.prototype.getRightValue.call(this, value);
	},

	handleTickRangeOptions: function() {
		var me = this;
		var opts = me.options;
		var tickOpts = opts.ticks;

		// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
		// do nothing since that would make the chart weird. If the user really wants a weird chart
		// axis, they can manually override it
		if (tickOpts.beginAtZero) {
			var minSign = helpers$1.sign(me.min);
			var maxSign = helpers$1.sign(me.max);

			if (minSign < 0 && maxSign < 0) {
				// move the top up to 0
				me.max = 0;
			} else if (minSign > 0 && maxSign > 0) {
				// move the bottom down to 0
				me.min = 0;
			}
		}

		var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
		var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

		if (tickOpts.min !== undefined) {
			me.min = tickOpts.min;
		} else if (tickOpts.suggestedMin !== undefined) {
			if (me.min === null) {
				me.min = tickOpts.suggestedMin;
			} else {
				me.min = Math.min(me.min, tickOpts.suggestedMin);
			}
		}

		if (tickOpts.max !== undefined) {
			me.max = tickOpts.max;
		} else if (tickOpts.suggestedMax !== undefined) {
			if (me.max === null) {
				me.max = tickOpts.suggestedMax;
			} else {
				me.max = Math.max(me.max, tickOpts.suggestedMax);
			}
		}

		if (setMin !== setMax) {
			// We set the min or the max but not both.
			// So ensure that our range is good
			// Inverted or 0 length range can happen when
			// ticks.min is set, and no datasets are visible
			if (me.min >= me.max) {
				if (setMin) {
					me.max = me.min + 1;
				} else {
					me.min = me.max - 1;
				}
			}
		}

		if (me.min === me.max) {
			me.max++;

			if (!tickOpts.beginAtZero) {
				me.min--;
			}
		}
	},

	getTickLimit: function() {
		var me = this;
		var tickOpts = me.options.ticks;
		var stepSize = tickOpts.stepSize;
		var maxTicksLimit = tickOpts.maxTicksLimit;
		var maxTicks;

		if (stepSize) {
			maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
		} else {
			maxTicks = me._computeTickLimit();
			maxTicksLimit = maxTicksLimit || 11;
		}

		if (maxTicksLimit) {
			maxTicks = Math.min(maxTicksLimit, maxTicks);
		}

		return maxTicks;
	},

	_computeTickLimit: function() {
		return Number.POSITIVE_INFINITY;
	},

	handleDirectionalChanges: noop,

	buildTicks: function() {
		var me = this;
		var opts = me.options;
		var tickOpts = opts.ticks;

		// Figure out what the max number of ticks we can support it is based on the size of
		// the axis area. For now, we say that the minimum tick spacing in pixels must be 40
		// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
		// the graph. Make sure we always have at least 2 ticks
		var maxTicks = me.getTickLimit();
		maxTicks = Math.max(2, maxTicks);

		var numericGeneratorOptions = {
			maxTicks: maxTicks,
			min: tickOpts.min,
			max: tickOpts.max,
			precision: tickOpts.precision,
			stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
		};
		var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);

		me.handleDirectionalChanges();

		// At this point, we need to update our max and min given the tick values since we have expanded the
		// range of the scale
		me.max = helpers$1.max(ticks);
		me.min = helpers$1.min(ticks);

		if (tickOpts.reverse) {
			ticks.reverse();

			me.start = me.max;
			me.end = me.min;
		} else {
			me.start = me.min;
			me.end = me.max;
		}
	},

	convertTicksToLabels: function() {
		var me = this;
		me.ticksAsNumbers = me.ticks.slice();
		me.zeroLineIndex = me.ticks.indexOf(0);

		core_scale.prototype.convertTicksToLabels.call(me);
	}
});

var defaultConfig$1 = {
	position: 'left',
	ticks: {
		callback: core_ticks.formatters.linear
	}
};

var scale_linear = scale_linearbase.extend({
	determineDataLimits: function() {
		var me = this;
		var opts = me.options;
		var chart = me.chart;
		var data = chart.data;
		var datasets = data.datasets;
		var isHorizontal = me.isHorizontal();
		var DEFAULT_MIN = 0;
		var DEFAULT_MAX = 1;

		function IDMatches(meta) {
			return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
		}

		// First Calculate the range
		me.min = null;
		me.max = null;

		var hasStacks = opts.stacked;
		if (hasStacks === undefined) {
			helpers$1.each(datasets, function(dataset, datasetIndex) {
				if (hasStacks) {
					return;
				}

				var meta = chart.getDatasetMeta(datasetIndex);
				if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
					meta.stack !== undefined) {
					hasStacks = true;
				}
			});
		}

		if (opts.stacked || hasStacks) {
			var valuesPerStack = {};

			helpers$1.each(datasets, function(dataset, datasetIndex) {
				var meta = chart.getDatasetMeta(datasetIndex);
				var key = [
					meta.type,
					// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
					((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
					meta.stack
				].join('.');

				if (valuesPerStack[key] === undefined) {
					valuesPerStack[key] = {
						positiveValues: [],
						negativeValues: []
					};
				}

				// Store these per type
				var positiveValues = valuesPerStack[key].positiveValues;
				var negativeValues = valuesPerStack[key].negativeValues;

				if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
					helpers$1.each(dataset.data, function(rawValue, index) {
						var value = +me.getRightValue(rawValue);
						if (isNaN(value) || meta.data[index].hidden) {
							return;
						}

						positiveValues[index] = positiveValues[index] || 0;
						negativeValues[index] = negativeValues[index] || 0;

						if (opts.relativePoints) {
							positiveValues[index] = 100;
						} else if (value < 0) {
							negativeValues[index] += value;
						} else {
							positiveValues[index] += value;
						}
					});
				}
			});

			helpers$1.each(valuesPerStack, function(valuesForType) {
				var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
				var minVal = helpers$1.min(values);
				var maxVal = helpers$1.max(values);
				me.min = me.min === null ? minVal : Math.min(me.min, minVal);
				me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
			});

		} else {
			helpers$1.each(datasets, function(dataset, datasetIndex) {
				var meta = chart.getDatasetMeta(datasetIndex);
				if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
					helpers$1.each(dataset.data, function(rawValue, index) {
						var value = +me.getRightValue(rawValue);
						if (isNaN(value) || meta.data[index].hidden) {
							return;
						}

						if (me.min === null) {
							me.min = value;
						} else if (value < me.min) {
							me.min = value;
						}

						if (me.max === null) {
							me.max = value;
						} else if (value > me.max) {
							me.max = value;
						}
					});
				}
			});
		}

		me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
		me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

		// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
		this.handleTickRangeOptions();
	},

	// Returns the maximum number of ticks based on the scale dimension
	_computeTickLimit: function() {
		var me = this;
		var tickFont;

		if (me.isHorizontal()) {
			return Math.ceil(me.width / 40);
		}
		tickFont = helpers$1.options._parseFont(me.options.ticks);
		return Math.ceil(me.height / tickFont.lineHeight);
	},

	// Called after the ticks are built. We need
	handleDirectionalChanges: function() {
		if (!this.isHorizontal()) {
			// We are in a vertical orientation. The top value is the highest. So reverse the array
			this.ticks.reverse();
		}
	},

	getLabelForIndex: function(index, datasetIndex) {
		return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
	},

	// Utils
	getPixelForValue: function(value) {
		// This must be called after fit has been run so that
		// this.left, this.top, this.right, and this.bottom have been defined
		var me = this;
		var start = me.start;

		var rightValue = +me.getRightValue(value);
		var pixel;
		var range = me.end - start;

		if (me.isHorizontal()) {
			pixel = me.left + (me.width / range * (rightValue - start));
		} else {
			pixel = me.bottom - (me.height / range * (rightValue - start));
		}
		return pixel;
	},

	getValueForPixel: function(pixel) {
		var me = this;
		var isHorizontal = me.isHorizontal();
		var innerDimension = isHorizontal ? me.width : me.height;
		var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
		return me.start + ((me.end - me.start) * offset);
	},

	getPixelForTick: function(index) {
		return this.getPixelForValue(this.ticksAsNumbers[index]);
	}
});

// INTERNAL: static default options, registered in src/index.js
var _defaults$1 = defaultConfig$1;
scale_linear._defaults = _defaults$1;

var valueOrDefault$a = helpers$1.valueOrDefault;

/**
 * Generate a set of logarithmic ticks
 * @param generationOptions the options used to generate the ticks
 * @param dataRange the range of the data
 * @returns {number[]} array of tick values
 */
function generateTicks$1(generationOptions, dataRange) {
	var ticks = [];

	var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));

	var endExp = Math.floor(helpers$1.log10(dataRange.max));
	var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
	var exp, significand;

	if (tickVal === 0) {
		exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
		significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

		ticks.push(tickVal);
		tickVal = significand * Math.pow(10, exp);
	} else {
		exp = Math.floor(helpers$1.log10(tickVal));
		significand = Math.floor(tickVal / Math.pow(10, exp));
	}
	var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

	do {
		ticks.push(tickVal);

		++significand;
		if (significand === 10) {
			significand = 1;
			++exp;
			precision = exp >= 0 ? 1 : precision;
		}

		tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
	} while (exp < endExp || (exp === endExp && significand < endSignificand));

	var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
	ticks.push(lastTick);

	return ticks;
}

var defaultConfig$2 = {
	position: 'left',

	// label settings
	ticks: {
		callback: core_ticks.formatters.logarithmic
	}
};

// TODO(v3): change this to positiveOrDefault
function nonNegativeOrDefault(value, defaultValue) {
	return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
}

var scale_logarithmic = core_scale.extend({
	determineDataLimits: function() {
		var me = this;
		var opts = me.options;
		var chart = me.chart;
		var data = chart.data;
		var datasets = data.datasets;
		var isHorizontal = me.isHorizontal();
		function IDMatches(meta) {
			return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
		}

		// Calculate Range
		me.min = null;
		me.max = null;
		me.minNotZero = null;

		var hasStacks = opts.stacked;
		if (hasStacks === undefined) {
			helpers$1.each(datasets, function(dataset, datasetIndex) {
				if (hasStacks) {
					return;
				}

				var meta = chart.getDatasetMeta(datasetIndex);
				if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
					meta.stack !== undefined) {
					hasStacks = true;
				}
			});
		}

		if (opts.stacked || hasStacks) {
			var valuesPerStack = {};

			helpers$1.each(datasets, function(dataset, datasetIndex) {
				var meta = chart.getDatasetMeta(datasetIndex);
				var key = [
					meta.type,
					// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
					((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
					meta.stack
				].join('.');

				if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
					if (valuesPerStack[key] === undefined) {
						valuesPerStack[key] = [];
					}

					helpers$1.each(dataset.data, function(rawValue, index) {
						var values = valuesPerStack[key];
						var value = +me.getRightValue(rawValue);
						// invalid, hidden and negative values are ignored
						if (isNaN(value) || meta.data[index].hidden || value < 0) {
							return;
						}
						values[index] = values[index] || 0;
						values[index] += value;
					});
				}
			});

			helpers$1.each(valuesPerStack, function(valuesForType) {
				if (valuesForType.length > 0) {
					var minVal = helpers$1.min(valuesForType);
					var maxVal = helpers$1.max(valuesForType);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				}
			});

		} else {
			helpers$1.each(datasets, function(dataset, datasetIndex) {
				var meta = chart.getDatasetMeta(datasetIndex);
				if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
					helpers$1.each(dataset.data, function(rawValue, index) {
						var value = +me.getRightValue(rawValue);
						// invalid, hidden and negative values are ignored
						if (isNaN(value) || meta.data[index].hidden || value < 0) {
							return;
						}

						if (me.min === null) {
							me.min = value;
						} else if (value < me.min) {
							me.min = value;
						}

						if (me.max === null) {
							me.max = value;
						} else if (value > me.max) {
							me.max = value;
						}

						if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
							me.minNotZero = value;
						}
					});
				}
			});
		}

		// Common base implementation to handle ticks.min, ticks.max
		this.handleTickRangeOptions();
	},

	handleTickRangeOptions: function() {
		var me = this;
		var tickOpts = me.options.ticks;
		var DEFAULT_MIN = 1;
		var DEFAULT_MAX = 10;

		me.min = nonNegativeOrDefault(tickOpts.min, me.min);
		me.max = nonNegativeOrDefault(tickOpts.max, me.max);

		if (me.min === me.max) {
			if (me.min !== 0 && me.min !== null) {
				me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
				me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
			} else {
				me.min = DEFAULT_MIN;
				me.max = DEFAULT_MAX;
			}
		}
		if (me.min === null) {
			me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
		}
		if (me.max === null) {
			me.max = me.min !== 0
				? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1)
				: DEFAULT_MAX;
		}
		if (me.minNotZero === null) {
			if (me.min > 0) {
				me.minNotZero = me.min;
			} else if (me.max < 1) {
				me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
			} else {
				me.minNotZero = DEFAULT_MIN;
			}
		}
	},

	buildTicks: function() {
		var me = this;
		var tickOpts = me.options.ticks;
		var reverse = !me.isHorizontal();

		var generationOptions = {
			min: nonNegativeOrDefault(tickOpts.min),
			max: nonNegativeOrDefault(tickOpts.max)
		};
		var ticks = me.ticks = generateTicks$1(generationOptions, me);

		// At this point, we need to update our max and min given the tick values since we have expanded the
		// range of the scale
		me.max = helpers$1.max(ticks);
		me.min = helpers$1.min(ticks);

		if (tickOpts.reverse) {
			reverse = !reverse;
			me.start = me.max;
			me.end = me.min;
		} else {
			me.start = me.min;
			me.end = me.max;
		}
		if (reverse) {
			ticks.reverse();
		}
	},

	convertTicksToLabels: function() {
		this.tickValues = this.ticks.slice();

		core_scale.prototype.convertTicksToLabels.call(this);
	},

	// Get the correct tooltip label
	getLabelForIndex: function(index, datasetIndex) {
		return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
	},

	getPixelForTick: function(index) {
		return this.getPixelForValue(this.tickValues[index]);
	},

	/**
	 * Returns the value of the first tick.
	 * @param {number} value - The minimum not zero value.
	 * @return {number} The first tick value.
	 * @private
	 */
	_getFirstTickValue: function(value) {
		var exp = Math.floor(helpers$1.log10(value));
		var significand = Math.floor(value / Math.pow(10, exp));

		return significand * Math.pow(10, exp);
	},

	getPixelForValue: function(value) {
		var me = this;
		var tickOpts = me.options.ticks;
		var reverse = tickOpts.reverse;
		var log10 = helpers$1.log10;
		var firstTickValue = me._getFirstTickValue(me.minNotZero);
		var offset = 0;
		var innerDimension, pixel, start, end, sign;

		value = +me.getRightValue(value);
		if (reverse) {
			start = me.end;
			end = me.start;
			sign = -1;
		} else {
			start = me.start;
			end = me.end;
			sign = 1;
		}
		if (me.isHorizontal()) {
			innerDimension = me.width;
			pixel = reverse ? me.right : me.left;
		} else {
			innerDimension = me.height;
			sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
			pixel = reverse ? me.top : me.bottom;
		}
		if (value !== start) {
			if (start === 0) { // include zero tick
				offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
				innerDimension -= offset;
				start = firstTickValue;
			}
			if (value !== 0) {
				offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
			}
			pixel += sign * offset;
		}
		return pixel;
	},

	getValueForPixel: function(pixel) {
		var me = this;
		var tickOpts = me.options.ticks;
		var reverse = tickOpts.reverse;
		var log10 = helpers$1.log10;
		var firstTickValue = me._getFirstTickValue(me.minNotZero);
		var innerDimension, start, end, value;

		if (reverse) {
			start = me.end;
			end = me.start;
		} else {
			start = me.start;
			end = me.end;
		}
		if (me.isHorizontal()) {
			innerDimension = me.width;
			value = reverse ? me.right - pixel : pixel - me.left;
		} else {
			innerDimension = me.height;
			value = reverse ? pixel - me.top : me.bottom - pixel;
		}
		if (value !== start) {
			if (start === 0) { // include zero tick
				var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
				value -= offset;
				innerDimension -= offset;
				start = firstTickValue;
			}
			value *= log10(end) - log10(start);
			value /= innerDimension;
			value = Math.pow(10, log10(start) + value);
		}
		return value;
	}
});

// INTERNAL: static default options, registered in src/index.js
var _defaults$2 = defaultConfig$2;
scale_logarithmic._defaults = _defaults$2;

var valueOrDefault$b = helpers$1.valueOrDefault;
var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
var resolve$7 = helpers$1.options.resolve;

var defaultConfig$3 = {
	display: true,

	// Boolean - Whether to animate scaling the chart from the centre
	animate: true,
	position: 'chartArea',

	angleLines: {
		display: true,
		color: 'rgba(0, 0, 0, 0.1)',
		lineWidth: 1,
		borderDash: [],
		borderDashOffset: 0.0
	},

	gridLines: {
		circular: false
	},

	// label settings
	ticks: {
		// Boolean - Show a backdrop to the scale label
		showLabelBackdrop: true,

		// String - The colour of the label backdrop
		backdropColor: 'rgba(255,255,255,0.75)',

		// Number - The backdrop padding above & below the label in pixels
		backdropPaddingY: 2,

		// Number - The backdrop padding to the side of the label in pixels
		backdropPaddingX: 2,

		callback: core_ticks.formatters.linear
	},

	pointLabels: {
		// Boolean - if true, show point labels
		display: true,

		// Number - Point label font size in pixels
		fontSize: 10,

		// Function - Used to convert point labels
		callback: function(label) {
			return label;
		}
	}
};

function getValueCount(scale) {
	var opts = scale.options;
	return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
}

function getTickBackdropHeight(opts) {
	var tickOpts = opts.ticks;

	if (tickOpts.display && opts.display) {
		return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
	}
	return 0;
}

function measureLabelSize(ctx, lineHeight, label) {
	if (helpers$1.isArray(label)) {
		return {
			w: helpers$1.longestText(ctx, ctx.font, label),
			h: label.length * lineHeight
		};
	}

	return {
		w: ctx.measureText(label).width,
		h: lineHeight
	};
}

function determineLimits(angle, pos, size, min, max) {
	if (angle === min || angle === max) {
		return {
			start: pos - (size / 2),
			end: pos + (size / 2)
		};
	} else if (angle < min || angle > max) {
		return {
			start: pos - size,
			end: pos
		};
	}

	return {
		start: pos,
		end: pos + size
	};
}

/**
 * Helper function to fit a radial linear scale with point labels
 */
function fitWithPointLabels(scale) {

	// Right, this is really confusing and there is a lot of maths going on here
	// The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
	//
	// Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
	//
	// Solution:
	//
	// We assume the radius of the polygon is half the size of the canvas at first
	// at each index we check if the text overlaps.
	//
	// Where it does, we store that angle and that index.
	//
	// After finding the largest index and angle we calculate how much we need to remove
	// from the shape radius to move the point inwards by that x.
	//
	// We average the left and right distances to get the maximum shape radius that can fit in the box
	// along with labels.
	//
	// Once we have that, we can find the centre point for the chart, by taking the x text protrusion
	// on each side, removing that from the size, halving it and adding the left x protrusion width.
	//
	// This will mean we have a shape fitted to the canvas, as large as it can be with the labels
	// and position it in the most space efficient manner
	//
	// https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif

	var plFont = helpers$1.options._parseFont(scale.options.pointLabels);

	// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
	// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
	var furthestLimits = {
		l: 0,
		r: scale.width,
		t: 0,
		b: scale.height - scale.paddingTop
	};
	var furthestAngles = {};
	var i, textSize, pointPosition;

	scale.ctx.font = plFont.string;
	scale._pointLabelSizes = [];

	var valueCount = getValueCount(scale);
	for (i = 0; i < valueCount; i++) {
		pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
		textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
		scale._pointLabelSizes[i] = textSize;

		// Add quarter circle to make degree 0 mean top of circle
		var angleRadians = scale.getIndexAngle(i);
		var angle = helpers$1.toDegrees(angleRadians) % 360;
		var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
		var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

		if (hLimits.start < furthestLimits.l) {
			furthestLimits.l = hLimits.start;
			furthestAngles.l = angleRadians;
		}

		if (hLimits.end > furthestLimits.r) {
			furthestLimits.r = hLimits.end;
			furthestAngles.r = angleRadians;
		}

		if (vLimits.start < furthestLimits.t) {
			furthestLimits.t = vLimits.start;
			furthestAngles.t = angleRadians;
		}

		if (vLimits.end > furthestLimits.b) {
			furthestLimits.b = vLimits.end;
			furthestAngles.b = angleRadians;
		}
	}

	scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
}

function getTextAlignForAngle(angle) {
	if (angle === 0 || angle === 180) {
		return 'center';
	} else if (angle < 180) {
		return 'left';
	}

	return 'right';
}

function fillText(ctx, text, position, lineHeight) {
	var y = position.y + lineHeight / 2;
	var i, ilen;

	if (helpers$1.isArray(text)) {
		for (i = 0, ilen = text.length; i < ilen; ++i) {
			ctx.fillText(text[i], position.x, y);
			y += lineHeight;
		}
	} else {
		ctx.fillText(text, position.x, y);
	}
}

function adjustPointPositionForLabelHeight(angle, textSize, position) {
	if (angle === 90 || angle === 270) {
		position.y -= (textSize.h / 2);
	} else if (angle > 270 || angle < 90) {
		position.y -= textSize.h;
	}
}

function drawPointLabels(scale) {
	var ctx = scale.ctx;
	var opts = scale.options;
	var angleLineOpts = opts.angleLines;
	var gridLineOpts = opts.gridLines;
	var pointLabelOpts = opts.pointLabels;
	var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
	var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
	var tickBackdropHeight = getTickBackdropHeight(opts);

	ctx.save();
	ctx.lineWidth = lineWidth;
	ctx.strokeStyle = lineColor;
	if (ctx.setLineDash) {
		ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
		ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
	}

	var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

	// Point Label Font
	var plFont = helpers$1.options._parseFont(pointLabelOpts);

	ctx.font = plFont.string;
	ctx.textBaseline = 'middle';

	for (var i = getValueCount(scale) - 1; i >= 0; i--) {
		if (angleLineOpts.display && lineWidth && lineColor) {
			var outerPosition = scale.getPointPosition(i, outerDistance);
			ctx.beginPath();
			ctx.moveTo(scale.xCenter, scale.yCenter);
			ctx.lineTo(outerPosition.x, outerPosition.y);
			ctx.stroke();
		}

		if (pointLabelOpts.display) {
			// Extra pixels out for some label spacing
			var extra = (i === 0 ? tickBackdropHeight / 2 : 0);
			var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);

			// Keep this in loop since we may support array properties here
			var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
			ctx.fillStyle = pointLabelFontColor;

			var angleRadians = scale.getIndexAngle(i);
			var angle = helpers$1.toDegrees(angleRadians);
			ctx.textAlign = getTextAlignForAngle(angle);
			adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
			fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
		}
	}
	ctx.restore();
}

function drawRadiusLine(scale, gridLineOpts, radius, index) {
	var ctx = scale.ctx;
	var circular = gridLineOpts.circular;
	var valueCount = getValueCount(scale);
	var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
	var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
	var pointPosition;

	if ((!circular && !valueCount) || !lineColor || !lineWidth) {
		return;
	}

	ctx.save();
	ctx.strokeStyle = lineColor;
	ctx.lineWidth = lineWidth;
	if (ctx.setLineDash) {
		ctx.setLineDash(gridLineOpts.borderDash || []);
		ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
	}

	ctx.beginPath();
	if (circular) {
		// Draw circular arcs between the points
		ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
	} else {
		// Draw straight lines connecting each index
		pointPosition = scale.getPointPosition(0, radius);
		ctx.moveTo(pointPosition.x, pointPosition.y);

		for (var i = 1; i < valueCount; i++) {
			pointPosition = scale.getPointPosition(i, radius);
			ctx.lineTo(pointPosition.x, pointPosition.y);
		}
	}
	ctx.closePath();
	ctx.stroke();
	ctx.restore();
}

function numberOrZero(param) {
	return helpers$1.isNumber(param) ? param : 0;
}

var scale_radialLinear = scale_linearbase.extend({
	setDimensions: function() {
		var me = this;

		// Set the unconstrained dimension before label rotation
		me.width = me.maxWidth;
		me.height = me.maxHeight;
		me.paddingTop = getTickBackdropHeight(me.options) / 2;
		me.xCenter = Math.floor(me.width / 2);
		me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
		me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
	},

	determineDataLimits: function() {
		var me = this;
		var chart = me.chart;
		var min = Number.POSITIVE_INFINITY;
		var max = Number.NEGATIVE_INFINITY;

		helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
			if (chart.isDatasetVisible(datasetIndex)) {
				var meta = chart.getDatasetMeta(datasetIndex);

				helpers$1.each(dataset.data, function(rawValue, index) {
					var value = +me.getRightValue(rawValue);
					if (isNaN(value) || meta.data[index].hidden) {
						return;
					}

					min = Math.min(value, min);
					max = Math.max(value, max);
				});
			}
		});

		me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
		me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

		// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
		me.handleTickRangeOptions();
	},

	// Returns the maximum number of ticks based on the scale dimension
	_computeTickLimit: function() {
		return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
	},

	convertTicksToLabels: function() {
		var me = this;

		scale_linearbase.prototype.convertTicksToLabels.call(me);

		// Point labels
		me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
	},

	getLabelForIndex: function(index, datasetIndex) {
		return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
	},

	fit: function() {
		var me = this;
		var opts = me.options;

		if (opts.display && opts.pointLabels.display) {
			fitWithPointLabels(me);
		} else {
			me.setCenterPoint(0, 0, 0, 0);
		}
	},

	/**
	 * Set radius reductions and determine new radius and center point
	 * @private
	 */
	setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
		var me = this;
		var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
		var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
		var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
		var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);

		radiusReductionLeft = numberOrZero(radiusReductionLeft);
		radiusReductionRight = numberOrZero(radiusReductionRight);
		radiusReductionTop = numberOrZero(radiusReductionTop);
		radiusReductionBottom = numberOrZero(radiusReductionBottom);

		me.drawingArea = Math.min(
			Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
			Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
		me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
	},

	setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
		var me = this;
		var maxRight = me.width - rightMovement - me.drawingArea;
		var maxLeft = leftMovement + me.drawingArea;
		var maxTop = topMovement + me.drawingArea;
		var maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;

		me.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);
		me.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);
	},

	getIndexAngle: function(index) {
		var angleMultiplier = (Math.PI * 2) / getValueCount(this);
		var startAngle = this.chart.options && this.chart.options.startAngle ?
			this.chart.options.startAngle :
			0;

		var startAngleRadians = startAngle * Math.PI * 2 / 360;

		// Start from the top instead of right, so remove a quarter of the circle
		return index * angleMultiplier + startAngleRadians;
	},

	getDistanceFromCenterForValue: function(value) {
		var me = this;

		if (value === null) {
			return 0; // null always in center
		}

		// Take into account half font size + the yPadding of the top value
		var scalingFactor = me.drawingArea / (me.max - me.min);
		if (me.options.ticks.reverse) {
			return (me.max - value) * scalingFactor;
		}
		return (value - me.min) * scalingFactor;
	},

	getPointPosition: function(index, distanceFromCenter) {
		var me = this;
		var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
		return {
			x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
			y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
		};
	},

	getPointPositionForValue: function(index, value) {
		return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
	},

	getBasePosition: function() {
		var me = this;
		var min = me.min;
		var max = me.max;

		return me.getPointPositionForValue(0,
			me.beginAtZero ? 0 :
			min < 0 && max < 0 ? max :
			min > 0 && max > 0 ? min :
			0);
	},

	draw: function() {
		var me = this;
		var opts = me.options;
		var gridLineOpts = opts.gridLines;
		var tickOpts = opts.ticks;

		if (opts.display) {
			var ctx = me.ctx;
			var startAngle = this.getIndexAngle(0);
			var tickFont = helpers$1.options._parseFont(tickOpts);

			if (opts.angleLines.display || opts.pointLabels.display) {
				drawPointLabels(me);
			}

			helpers$1.each(me.ticks, function(label, index) {
				// Don't draw a centre value (if it is minimum)
				if (index > 0 || tickOpts.reverse) {
					var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

					// Draw circular lines around the scale
					if (gridLineOpts.display && index !== 0) {
						drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
					}

					if (tickOpts.display) {
						var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
						ctx.font = tickFont.string;

						ctx.save();
						ctx.translate(me.xCenter, me.yCenter);
						ctx.rotate(startAngle);

						if (tickOpts.showLabelBackdrop) {
							var labelWidth = ctx.measureText(label).width;
							ctx.fillStyle = tickOpts.backdropColor;
							ctx.fillRect(
								-labelWidth / 2 - tickOpts.backdropPaddingX,
								-yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY,
								labelWidth + tickOpts.backdropPaddingX * 2,
								tickFont.size + tickOpts.backdropPaddingY * 2
							);
						}

						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						ctx.fillStyle = tickFontColor;
						ctx.fillText(label, 0, -yCenterOffset);
						ctx.restore();
					}
				}
			});
		}
	}
});

// INTERNAL: static default options, registered in src/index.js
var _defaults$3 = defaultConfig$3;
scale_radialLinear._defaults = _defaults$3;

var valueOrDefault$c = helpers$1.valueOrDefault;

// Integer constants are from the ES6 spec.
var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

var INTERVALS = {
	millisecond: {
		common: true,
		size: 1,
		steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
	},
	second: {
		common: true,
		size: 1000,
		steps: [1, 2, 5, 10, 15, 30]
	},
	minute: {
		common: true,
		size: 60000,
		steps: [1, 2, 5, 10, 15, 30]
	},
	hour: {
		common: true,
		size: 3600000,
		steps: [1, 2, 3, 6, 12]
	},
	day: {
		common: true,
		size: 86400000,
		steps: [1, 2, 5]
	},
	week: {
		common: false,
		size: 604800000,
		steps: [1, 2, 3, 4]
	},
	month: {
		common: true,
		size: 2.628e9,
		steps: [1, 2, 3]
	},
	quarter: {
		common: false,
		size: 7.884e9,
		steps: [1, 2, 3, 4]
	},
	year: {
		common: true,
		size: 3.154e10
	}
};

var UNITS = Object.keys(INTERVALS);

function sorter(a, b) {
	return a - b;
}

function arrayUnique(items) {
	var hash = {};
	var out = [];
	var i, ilen, item;

	for (i = 0, ilen = items.length; i < ilen; ++i) {
		item = items[i];
		if (!hash[item]) {
			hash[item] = true;
			out.push(item);
		}
	}

	return out;
}

/**
 * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
 * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
 * extremity (left + width or top + height). Note that it would be more optimized to directly
 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
 *
 * @param {number[]} timestamps - timestamps sorted from lowest to highest.
 * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
 * If 'series', timestamps will be positioned at the same distance from each other. In this
 * case, only timestamps that break the time linearity are registered, meaning that in the
 * best case, all timestamps are linear, the table contains only min and max.
 */
function buildLookupTable(timestamps, min, max, distribution) {
	if (distribution === 'linear' || !timestamps.length) {
		return [
			{time: min, pos: 0},
			{time: max, pos: 1}
		];
	}

	var table = [];
	var items = [min];
	var i, ilen, prev, curr, next;

	for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
		curr = timestamps[i];
		if (curr > min && curr < max) {
			items.push(curr);
		}
	}

	items.push(max);

	for (i = 0, ilen = items.length; i < ilen; ++i) {
		next = items[i + 1];
		prev = items[i - 1];
		curr = items[i];

		// only add points that breaks the scale linearity
		if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
			table.push({time: curr, pos: i / (ilen - 1)});
		}
	}

	return table;
}

// @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
function lookup(table, key, value) {
	var lo = 0;
	var hi = table.length - 1;
	var mid, i0, i1;

	while (lo >= 0 && lo <= hi) {
		mid = (lo + hi) >> 1;
		i0 = table[mid - 1] || null;
		i1 = table[mid];

		if (!i0) {
			// given value is outside table (before first item)
			return {lo: null, hi: i1};
		} else if (i1[key] < value) {
			lo = mid + 1;
		} else if (i0[key] > value) {
			hi = mid - 1;
		} else {
			return {lo: i0, hi: i1};
		}
	}

	// given value is outside table (after last item)
	return {lo: i1, hi: null};
}

/**
 * Linearly interpolates the given source `value` using the table items `skey` values and
 * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
 * index [0, 1] or [n - 1, n] are used for the interpolation.
 */
function interpolate$1(table, skey, sval, tkey) {
	var range = lookup(table, skey, sval);

	// Note: the lookup table ALWAYS contains at least 2 items (min and max)
	var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
	var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

	var span = next[skey] - prev[skey];
	var ratio = span ? (sval - prev[skey]) / span : 0;
	var offset = (next[tkey] - prev[tkey]) * ratio;

	return prev[tkey] + offset;
}

function toTimestamp(scale, input) {
	var adapter = scale._adapter;
	var options = scale.options.time;
	var parser = options.parser;
	var format = parser || options.format;
	var value = input;

	if (typeof parser === 'function') {
		value = parser(value);
	}

	// Only parse if its not a timestamp already
	if (!helpers$1.isFinite(value)) {
		value = typeof format === 'string'
			? adapter.parse(value, format)
			: adapter.parse(value);
	}

	if (value !== null) {
		return +value;
	}

	// Labels are in an incompatible format and no `parser` has been provided.
	// The user might still use the deprecated `format` option for parsing.
	if (!parser && typeof format === 'function') {
		value = format(input);

		// `format` could return something else than a timestamp, if so, parse it
		if (!helpers$1.isFinite(value)) {
			value = adapter.parse(value);
		}
	}

	return value;
}

function parse(scale, input) {
	if (helpers$1.isNullOrUndef(input)) {
		return null;
	}

	var options = scale.options.time;
	var value = toTimestamp(scale, scale.getRightValue(input));
	if (value === null) {
		return value;
	}

	if (options.round) {
		value = +scale._adapter.startOf(value, options.round);
	}

	return value;
}

/**
 * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
 * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
 */
function determineStepSize(min, max, unit, capacity) {
	var range = max - min;
	var interval = INTERVALS[unit];
	var milliseconds = interval.size;
	var steps = interval.steps;
	var i, ilen, factor;

	if (!steps) {
		return Math.ceil(range / (capacity * milliseconds));
	}

	for (i = 0, ilen = steps.length; i < ilen; ++i) {
		factor = steps[i];
		if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
			break;
		}
	}

	return factor;
}

/**
 * Figures out what unit results in an appropriate number of auto-generated ticks
 */
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
	var ilen = UNITS.length;
	var i, interval, factor;

	for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
		interval = INTERVALS[UNITS[i]];
		factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

		if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
			return UNITS[i];
		}
	}

	return UNITS[ilen - 1];
}

/**
 * Figures out what unit to format a set of ticks with
 */
function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
	var ilen = UNITS.length;
	var i, unit;

	for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
		unit = UNITS[i];
		if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
			return unit;
		}
	}

	return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}

function determineMajorUnit(unit) {
	for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
		if (INTERVALS[UNITS[i]].common) {
			return UNITS[i];
		}
	}
}

/**
 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
 * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
 * Important: this method can return ticks outside the min and max range, it's the
 * responsibility of the calling code to clamp values if needed.
 */
function generate(scale, min, max, capacity) {
	var adapter = scale._adapter;
	var options = scale.options;
	var timeOpts = options.time;
	var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
	var major = determineMajorUnit(minor);
	var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
	var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
	var majorTicksEnabled = options.ticks.major.enabled;
	var interval = INTERVALS[minor];
	var first = min;
	var last = max;
	var ticks = [];
	var time;

	if (!stepSize) {
		stepSize = determineStepSize(min, max, minor, capacity);
	}

	// For 'week' unit, handle the first day of week option
	if (weekday) {
		first = +adapter.startOf(first, 'isoWeek', weekday);
		last = +adapter.startOf(last, 'isoWeek', weekday);
	}

	// Align first/last ticks on unit
	first = +adapter.startOf(first, weekday ? 'day' : minor);
	last = +adapter.startOf(last, weekday ? 'day' : minor);

	// Make sure that the last tick include max
	if (last < max) {
		last = +adapter.add(last, 1, minor);
	}

	time = first;

	if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
		// Align the first tick on the previous `minor` unit aligned on the `major` unit:
		// we first aligned time on the previous `major` unit then add the number of full
		// stepSize there is between first and the previous major time.
		time = +adapter.startOf(time, major);
		time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
	}

	for (; time < last; time = +adapter.add(time, stepSize, minor)) {
		ticks.push(+time);
	}

	ticks.push(+time);

	return ticks;
}

/**
 * Returns the start and end offsets from edges in the form of {start, end}
 * where each value is a relative width to the scale and ranges between 0 and 1.
 * They add extra margins on the both sides by scaling down the original scale.
 * Offsets are added when the `offset` option is true.
 */
function computeOffsets(table, ticks, min, max, options) {
	var start = 0;
	var end = 0;
	var first, last;

	if (options.offset && ticks.length) {
		if (!options.time.min) {
			first = interpolate$1(table, 'time', ticks[0], 'pos');
			if (ticks.length === 1) {
				start = 1 - first;
			} else {
				start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
			}
		}
		if (!options.time.max) {
			last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');
			if (ticks.length === 1) {
				end = last;
			} else {
				end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
			}
		}
	}

	return {start: start, end: end};
}

function ticksFromTimestamps(scale, values, majorUnit) {
	var ticks = [];
	var i, ilen, value, major;

	for (i = 0, ilen = values.length; i < ilen; ++i) {
		value = values[i];
		major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;

		ticks.push({
			value: value,
			major: major
		});
	}

	return ticks;
}

var defaultConfig$4 = {
	position: 'bottom',

	/**
	 * Data distribution along the scale:
	 * - 'linear': data are spread according to their time (distances can vary),
	 * - 'series': data are spread at the same distance from each other.
	 * @see https://github.com/chartjs/Chart.js/pull/4507
	 * @since 2.7.0
	 */
	distribution: 'linear',

	/**
	 * Scale boundary strategy (bypassed by min/max time options)
	 * - `data`: make sure data are fully visible, ticks outside are removed
	 * - `ticks`: make sure ticks are fully visible, data outside are truncated
	 * @see https://github.com/chartjs/Chart.js/pull/4556
	 * @since 2.7.0
	 */
	bounds: 'data',

	adapters: {},
	time: {
		parser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
		format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
		unit: false, // false == automatic or override with week, month, year, etc.
		round: false, // none, or override with week, month, year, etc.
		displayFormat: false, // DEPRECATED
		isoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
		minUnit: 'millisecond',
		displayFormats: {}
	},
	ticks: {
		autoSkip: false,

		/**
		 * Ticks generation input values:
		 * - 'auto': generates "optimal" ticks based on scale size and time options.
		 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
		 * - 'labels': generates ticks from user given `data.labels` values ONLY.
		 * @see https://github.com/chartjs/Chart.js/pull/4507
		 * @since 2.7.0
		 */
		source: 'auto',

		major: {
			enabled: false
		}
	}
};

var scale_time = core_scale.extend({
	initialize: function() {
		this.mergeTicksOptions();
		core_scale.prototype.initialize.call(this);
	},

	update: function() {
		var me = this;
		var options = me.options;
		var time = options.time || (options.time = {});
		var adapter = me._adapter = new core_adapters._date(options.adapters.date);

		// DEPRECATIONS: output a message only one time per update
		if (time.format) {
			console.warn('options.time.format is deprecated and replaced by options.time.parser.');
		}

		// Backward compatibility: before introducing adapter, `displayFormats` was
		// supposed to contain *all* unit/string pairs but this can't be resolved
		// when loading the scale (adapters are loaded afterward), so let's populate
		// missing formats on update
		helpers$1.mergeIf(time.displayFormats, adapter.formats());

		return core_scale.prototype.update.apply(me, arguments);
	},

	/**
	 * Allows data to be referenced via 't' attribute
	 */
	getRightValue: function(rawValue) {
		if (rawValue && rawValue.t !== undefined) {
			rawValue = rawValue.t;
		}
		return core_scale.prototype.getRightValue.call(this, rawValue);
	},

	determineDataLimits: function() {
		var me = this;
		var chart = me.chart;
		var adapter = me._adapter;
		var timeOpts = me.options.time;
		var unit = timeOpts.unit || 'day';
		var min = MAX_INTEGER;
		var max = MIN_INTEGER;
		var timestamps = [];
		var datasets = [];
		var labels = [];
		var i, j, ilen, jlen, data, timestamp;
		var dataLabels = chart.data.labels || [];

		// Convert labels to timestamps
		for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
			labels.push(parse(me, dataLabels[i]));
		}

		// Convert data to timestamps
		for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
			if (chart.isDatasetVisible(i)) {
				data = chart.data.datasets[i].data;

				// Let's consider that all data have the same format.
				if (helpers$1.isObject(data[0])) {
					datasets[i] = [];

					for (j = 0, jlen = data.length; j < jlen; ++j) {
						timestamp = parse(me, data[j]);
						timestamps.push(timestamp);
						datasets[i][j] = timestamp;
					}
				} else {
					for (j = 0, jlen = labels.length; j < jlen; ++j) {
						timestamps.push(labels[j]);
					}
					datasets[i] = labels.slice(0);
				}
			} else {
				datasets[i] = [];
			}
		}

		if (labels.length) {
			// Sort labels **after** data have been converted
			labels = arrayUnique(labels).sort(sorter);
			min = Math.min(min, labels[0]);
			max = Math.max(max, labels[labels.length - 1]);
		}

		if (timestamps.length) {
			timestamps = arrayUnique(timestamps).sort(sorter);
			min = Math.min(min, timestamps[0]);
			max = Math.max(max, timestamps[timestamps.length - 1]);
		}

		min = parse(me, timeOpts.min) || min;
		max = parse(me, timeOpts.max) || max;

		// In case there is no valid min/max, set limits based on unit time option
		min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
		max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;

		// Make sure that max is strictly higher than min (required by the lookup table)
		me.min = Math.min(min, max);
		me.max = Math.max(min + 1, max);

		// PRIVATE
		me._horizontal = me.isHorizontal();
		me._table = [];
		me._timestamps = {
			data: timestamps,
			datasets: datasets,
			labels: labels
		};
	},

	buildTicks: function() {
		var me = this;
		var min = me.min;
		var max = me.max;
		var options = me.options;
		var timeOpts = options.time;
		var timestamps = [];
		var ticks = [];
		var i, ilen, timestamp;

		switch (options.ticks.source) {
		case 'data':
			timestamps = me._timestamps.data;
			break;
		case 'labels':
			timestamps = me._timestamps.labels;
			break;
		case 'auto':
		default:
			timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
		}

		if (options.bounds === 'ticks' && timestamps.length) {
			min = timestamps[0];
			max = timestamps[timestamps.length - 1];
		}

		// Enforce limits with user min/max options
		min = parse(me, timeOpts.min) || min;
		max = parse(me, timeOpts.max) || max;

		// Remove ticks outside the min/max range
		for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
			timestamp = timestamps[i];
			if (timestamp >= min && timestamp <= max) {
				ticks.push(timestamp);
			}
		}

		me.min = min;
		me.max = max;

		// PRIVATE
		me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
		me._majorUnit = determineMajorUnit(me._unit);
		me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
		me._offsets = computeOffsets(me._table, ticks, min, max, options);

		if (options.ticks.reverse) {
			ticks.reverse();
		}

		return ticksFromTimestamps(me, ticks, me._majorUnit);
	},

	getLabelForIndex: function(index, datasetIndex) {
		var me = this;
		var adapter = me._adapter;
		var data = me.chart.data;
		var timeOpts = me.options.time;
		var label = data.labels && index < data.labels.length ? data.labels[index] : '';
		var value = data.datasets[datasetIndex].data[index];

		if (helpers$1.isObject(value)) {
			label = me.getRightValue(value);
		}
		if (timeOpts.tooltipFormat) {
			return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
		}
		if (typeof label === 'string') {
			return label;
		}
		return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
	},

	/**
	 * Function to format an individual tick mark
	 * @private
	 */
	tickFormatFunction: function(time, index, ticks, format) {
		var me = this;
		var adapter = me._adapter;
		var options = me.options;
		var formats = options.time.displayFormats;
		var minorFormat = formats[me._unit];
		var majorUnit = me._majorUnit;
		var majorFormat = formats[majorUnit];
		var majorTime = +adapter.startOf(time, majorUnit);
		var majorTickOpts = options.ticks.major;
		var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
		var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
		var tickOpts = major ? majorTickOpts : options.ticks.minor;
		var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);

		return formatter ? formatter(label, index, ticks) : label;
	},

	convertTicksToLabels: function(ticks) {
		var labels = [];
		var i, ilen;

		for (i = 0, ilen = ticks.length; i < ilen; ++i) {
			labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
		}

		return labels;
	},

	/**
	 * @private
	 */
	getPixelForOffset: function(time) {
		var me = this;
		var isReverse = me.options.ticks.reverse;
		var size = me._horizontal ? me.width : me.height;
		var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
		var pos = interpolate$1(me._table, 'time', time, 'pos');
		var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);

		return isReverse ? start - offset : start + offset;
	},

	getPixelForValue: function(value, index, datasetIndex) {
		var me = this;
		var time = null;

		if (index !== undefined && datasetIndex !== undefined) {
			time = me._timestamps.datasets[datasetIndex][index];
		}

		if (time === null) {
			time = parse(me, value);
		}

		if (time !== null) {
			return me.getPixelForOffset(time);
		}
	},

	getPixelForTick: function(index) {
		var ticks = this.getTicks();
		return index >= 0 && index < ticks.length ?
			this.getPixelForOffset(ticks[index].value) :
			null;
	},

	getValueForPixel: function(pixel) {
		var me = this;
		var size = me._horizontal ? me.width : me.height;
		var start = me._horizontal ? me.left : me.top;
		var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
		var time = interpolate$1(me._table, 'pos', pos, 'time');

		// DEPRECATION, we should return time directly
		return me._adapter._create(time);
	},

	/**
	 * Crude approximation of what the label width might be
	 * @private
	 */
	getLabelWidth: function(label) {
		var me = this;
		var ticksOpts = me.options.ticks;
		var tickLabelWidth = me.ctx.measureText(label).width;
		var angle = helpers$1.toRadians(ticksOpts.maxRotation);
		var cosRotation = Math.cos(angle);
		var sinRotation = Math.sin(angle);
		var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);

		return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
	},

	/**
	 * @private
	 */
	getLabelCapacity: function(exampleTime) {
		var me = this;

		// pick the longest format (milliseconds) for guestimation
		var format = me.options.time.displayFormats.millisecond;
		var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
		var tickLabelWidth = me.getLabelWidth(exampleLabel);
		var innerWidth = me.isHorizontal() ? me.width : me.height;
		var capacity = Math.floor(innerWidth / tickLabelWidth);

		return capacity > 0 ? capacity : 1;
	}
});

// INTERNAL: static default options, registered in src/index.js
var _defaults$4 = defaultConfig$4;
scale_time._defaults = _defaults$4;

var scales = {
	category: scale_category,
	linear: scale_linear,
	logarithmic: scale_logarithmic,
	radialLinear: scale_radialLinear,
	time: scale_time
};

var FORMATS = {
	datetime: 'MMM D, YYYY, h:mm:ss a',
	millisecond: 'h:mm:ss.SSS a',
	second: 'h:mm:ss a',
	minute: 'h:mm a',
	hour: 'hA',
	day: 'MMM D',
	week: 'll',
	month: 'MMM YYYY',
	quarter: '[Q]Q - YYYY',
	year: 'YYYY'
};

core_adapters._date.override(typeof moment === 'function' ? {
	_id: 'moment', // DEBUG ONLY

	formats: function() {
		return FORMATS;
	},

	parse: function(value, format) {
		if (typeof value === 'string' && typeof format === 'string') {
			value = moment(value, format);
		} else if (!(value instanceof moment)) {
			value = moment(value);
		}
		return value.isValid() ? value.valueOf() : null;
	},

	format: function(time, format) {
		return moment(time).format(format);
	},

	add: function(time, amount, unit) {
		return moment(time).add(amount, unit).valueOf();
	},

	diff: function(max, min, unit) {
		return moment.duration(moment(max).diff(moment(min))).as(unit);
	},

	startOf: function(time, unit, weekday) {
		time = moment(time);
		if (unit === 'isoWeek') {
			return time.isoWeekday(weekday).valueOf();
		}
		return time.startOf(unit).valueOf();
	},

	endOf: function(time, unit) {
		return moment(time).endOf(unit).valueOf();
	},

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility with scale.getValueForPixel().
	 * @deprecated since version 2.8.0
	 * @todo remove at version 3
	 * @private
	 */
	_create: function(time) {
		return moment(time);
	},
} : {});

core_defaults._set('global', {
	plugins: {
		filler: {
			propagate: true
		}
	}
});

var mappers = {
	dataset: function(source) {
		var index = source.fill;
		var chart = source.chart;
		var meta = chart.getDatasetMeta(index);
		var visible = meta && chart.isDatasetVisible(index);
		var points = (visible && meta.dataset._children) || [];
		var length = points.length || 0;

		return !length ? null : function(point, i) {
			return (i < length && points[i]._view) || null;
		};
	},

	boundary: function(source) {
		var boundary = source.boundary;
		var x = boundary ? boundary.x : null;
		var y = boundary ? boundary.y : null;

		return function(point) {
			return {
				x: x === null ? point.x : x,
				y: y === null ? point.y : y,
			};
		};
	}
};

// @todo if (fill[0] === '#')
function decodeFill(el, index, count) {
	var model = el._model || {};
	var fill = model.fill;
	var target;

	if (fill === undefined) {
		fill = !!model.backgroundColor;
	}

	if (fill === false || fill === null) {
		return false;
	}

	if (fill === true) {
		return 'origin';
	}

	target = parseFloat(fill, 10);
	if (isFinite(target) && Math.floor(target) === target) {
		if (fill[0] === '-' || fill[0] === '+') {
			target = index + target;
		}

		if (target === index || target < 0 || target >= count) {
			return false;
		}

		return target;
	}

	switch (fill) {
	// compatibility
	case 'bottom':
		return 'start';
	case 'top':
		return 'end';
	case 'zero':
		return 'origin';
	// supported boundaries
	case 'origin':
	case 'start':
	case 'end':
		return fill;
	// invalid fill values
	default:
		return false;
	}
}

function computeBoundary(source) {
	var model = source.el._model || {};
	var scale = source.el._scale || {};
	var fill = source.fill;
	var target = null;
	var horizontal;

	if (isFinite(fill)) {
		return null;
	}

	// Backward compatibility: until v3, we still need to support boundary values set on
	// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
	// controllers might still use it (e.g. the Smith chart).

	if (fill === 'start') {
		target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
	} else if (fill === 'end') {
		target = model.scaleTop === undefined ? scale.top : model.scaleTop;
	} else if (model.scaleZero !== undefined) {
		target = model.scaleZero;
	} else if (scale.getBasePosition) {
		target = scale.getBasePosition();
	} else if (scale.getBasePixel) {
		target = scale.getBasePixel();
	}

	if (target !== undefined && target !== null) {
		if (target.x !== undefined && target.y !== undefined) {
			return target;
		}

		if (helpers$1.isFinite(target)) {
			horizontal = scale.isHorizontal();
			return {
				x: horizontal ? target : null,
				y: horizontal ? null : target
			};
		}
	}

	return null;
}

function resolveTarget(sources, index, propagate) {
	var source = sources[index];
	var fill = source.fill;
	var visited = [index];
	var target;

	if (!propagate) {
		return fill;
	}

	while (fill !== false && visited.indexOf(fill) === -1) {
		if (!isFinite(fill)) {
			return fill;
		}

		target = sources[fill];
		if (!target) {
			return false;
		}

		if (target.visible) {
			return fill;
		}

		visited.push(fill);
		fill = target.fill;
	}

	return false;
}

function createMapper(source) {
	var fill = source.fill;
	var type = 'dataset';

	if (fill === false) {
		return null;
	}

	if (!isFinite(fill)) {
		type = 'boundary';
	}

	return mappers[type](source);
}

function isDrawable(point) {
	return point && !point.skip;
}

function drawArea(ctx, curve0, curve1, len0, len1) {
	var i;

	if (!len0 || !len1) {
		return;
	}

	// building first area curve (normal)
	ctx.moveTo(curve0[0].x, curve0[0].y);
	for (i = 1; i < len0; ++i) {
		helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
	}

	// joining the two area curves
	ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

	// building opposite area curve (reverse)
	for (i = len1 - 1; i > 0; --i) {
		helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
	}
}

function doFill(ctx, points, mapper, view, color, loop) {
	var count = points.length;
	var span = view.spanGaps;
	var curve0 = [];
	var curve1 = [];
	var len0 = 0;
	var len1 = 0;
	var i, ilen, index, p0, p1, d0, d1;

	ctx.beginPath();

	for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
		index = i % count;
		p0 = points[index]._view;
		p1 = mapper(p0, index, view);
		d0 = isDrawable(p0);
		d1 = isDrawable(p1);

		if (d0 && d1) {
			len0 = curve0.push(p0);
			len1 = curve1.push(p1);
		} else if (len0 && len1) {
			if (!span) {
				drawArea(ctx, curve0, curve1, len0, len1);
				len0 = len1 = 0;
				curve0 = [];
				curve1 = [];
			} else {
				if (d0) {
					curve0.push(p0);
				}
				if (d1) {
					curve1.push(p1);
				}
			}
		}
	}

	drawArea(ctx, curve0, curve1, len0, len1);

	ctx.closePath();
	ctx.fillStyle = color;
	ctx.fill();
}

var plugin_filler = {
	id: 'filler',

	afterDatasetsUpdate: function(chart, options) {
		var count = (chart.data.datasets || []).length;
		var propagate = options.propagate;
		var sources = [];
		var meta, i, el, source;

		for (i = 0; i < count; ++i) {
			meta = chart.getDatasetMeta(i);
			el = meta.dataset;
			source = null;

			if (el && el._model && el instanceof elements.Line) {
				source = {
					visible: chart.isDatasetVisible(i),
					fill: decodeFill(el, i, count),
					chart: chart,
					el: el
				};
			}

			meta.$filler = source;
			sources.push(source);
		}

		for (i = 0; i < count; ++i) {
			source = sources[i];
			if (!source) {
				continue;
			}

			source.fill = resolveTarget(sources, i, propagate);
			source.boundary = computeBoundary(source);
			source.mapper = createMapper(source);
		}
	},

	beforeDatasetDraw: function(chart, args) {
		var meta = args.meta.$filler;
		if (!meta) {
			return;
		}

		var ctx = chart.ctx;
		var el = meta.el;
		var view = el._view;
		var points = el._children || [];
		var mapper = meta.mapper;
		var color = view.backgroundColor || core_defaults.global.defaultColor;

		if (mapper && color && points.length) {
			helpers$1.canvas.clipArea(ctx, chart.chartArea);
			doFill(ctx, points, mapper, view, color, el._loop);
			helpers$1.canvas.unclipArea(ctx);
		}
	}
};

var noop$1 = helpers$1.noop;
var valueOrDefault$d = helpers$1.valueOrDefault;

core_defaults._set('global', {
	legend: {
		display: true,
		position: 'top',
		fullWidth: true,
		reverse: false,
		weight: 1000,

		// a callback that will handle
		onClick: function(e, legendItem) {
			var index = legendItem.datasetIndex;
			var ci = this.chart;
			var meta = ci.getDatasetMeta(index);

			// See controller.isDatasetVisible comment
			meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

			// We hid a dataset ... rerender the chart
			ci.update();
		},

		onHover: null,
		onLeave: null,

		labels: {
			boxWidth: 40,
			padding: 10,
			// Generates labels shown in the legend
			// Valid properties to return:
			// text : text to display
			// fillStyle : fill of coloured box
			// strokeStyle: stroke of coloured box
			// hidden : if this legend item refers to a hidden item
			// lineCap : cap style for line
			// lineDash
			// lineDashOffset :
			// lineJoin :
			// lineWidth :
			generateLabels: function(chart) {
				var data = chart.data;
				return helpers$1.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
					return {
						text: dataset.label,
						fillStyle: (!helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
						hidden: !chart.isDatasetVisible(i),
						lineCap: dataset.borderCapStyle,
						lineDash: dataset.borderDash,
						lineDashOffset: dataset.borderDashOffset,
						lineJoin: dataset.borderJoinStyle,
						lineWidth: dataset.borderWidth,
						strokeStyle: dataset.borderColor,
						pointStyle: dataset.pointStyle,

						// Below is extra data used for toggling the datasets
						datasetIndex: i
					};
				}, this) : [];
			}
		}
	},

	legendCallback: function(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');
		for (var i = 0; i < chart.data.datasets.length; i++) {
			text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
			if (chart.data.datasets[i].label) {
				text.push(chart.data.datasets[i].label);
			}
			text.push('</li>');
		}
		text.push('</ul>');
		return text.join('');
	}
});

/**
 * Helper function to get the box width based on the usePointStyle option
 * @param {object} labelopts - the label options on the legend
 * @param {number} fontSize - the label font size
 * @return {number} width of the color box area
 */
function getBoxWidth(labelOpts, fontSize) {
	return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?
		fontSize :
		labelOpts.boxWidth;
}

/**
 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
 */
var Legend = core_element.extend({

	initialize: function(config) {
		helpers$1.extend(this, config);

		// Contains hit boxes for each dataset (in dataset order)
		this.legendHitBoxes = [];

		/**
 		 * @private
 		 */
		this._hoveredItem = null;

		// Are we in doughnut mode which has a different data type
		this.doughnutMode = false;
	},

	// These methods are ordered by lifecycle. Utilities then follow.
	// Any function defined here is inherited by all legend types.
	// Any function can be extended by the legend type

	beforeUpdate: noop$1,
	update: function(maxWidth, maxHeight, margins) {
		var me = this;

		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
		me.beforeUpdate();

		// Absorb the master measurements
		me.maxWidth = maxWidth;
		me.maxHeight = maxHeight;
		me.margins = margins;

		// Dimensions
		me.beforeSetDimensions();
		me.setDimensions();
		me.afterSetDimensions();
		// Labels
		me.beforeBuildLabels();
		me.buildLabels();
		me.afterBuildLabels();

		// Fit
		me.beforeFit();
		me.fit();
		me.afterFit();
		//
		me.afterUpdate();

		return me.minSize;
	},
	afterUpdate: noop$1,

	//

	beforeSetDimensions: noop$1,
	setDimensions: function() {
		var me = this;
		// Set the unconstrained dimension before label rotation
		if (me.isHorizontal()) {
			// Reset position before calculating rotation
			me.width = me.maxWidth;
			me.left = 0;
			me.right = me.width;
		} else {
			me.height = me.maxHeight;

			// Reset position before calculating rotation
			me.top = 0;
			me.bottom = me.height;
		}

		// Reset padding
		me.paddingLeft = 0;
		me.paddingTop = 0;
		me.paddingRight = 0;
		me.paddingBottom = 0;

		// Reset minSize
		me.minSize = {
			width: 0,
			height: 0
		};
	},
	afterSetDimensions: noop$1,

	//

	beforeBuildLabels: noop$1,
	buildLabels: function() {
		var me = this;
		var labelOpts = me.options.labels || {};
		var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

		if (labelOpts.filter) {
			legendItems = legendItems.filter(function(item) {
				return labelOpts.filter(item, me.chart.data);
			});
		}

		if (me.options.reverse) {
			legendItems.reverse();
		}

		me.legendItems = legendItems;
	},
	afterBuildLabels: noop$1,

	//

	beforeFit: noop$1,
	fit: function() {
		var me = this;
		var opts = me.options;
		var labelOpts = opts.labels;
		var display = opts.display;

		var ctx = me.ctx;

		var labelFont = helpers$1.options._parseFont(labelOpts);
		var fontSize = labelFont.size;

		// Reset hit boxes
		var hitboxes = me.legendHitBoxes = [];

		var minSize = me.minSize;
		var isHorizontal = me.isHorizontal();

		if (isHorizontal) {
			minSize.width = me.maxWidth; // fill all the width
			minSize.height = display ? 10 : 0;
		} else {
			minSize.width = display ? 10 : 0;
			minSize.height = me.maxHeight; // fill all the height
		}

		// Increase sizes here
		if (display) {
			ctx.font = labelFont.string;

			if (isHorizontal) {
				// Labels

				// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
				var lineWidths = me.lineWidths = [0];
				var totalHeight = 0;

				ctx.textAlign = 'left';
				ctx.textBaseline = 'top';

				helpers$1.each(me.legendItems, function(legendItem, i) {
					var boxWidth = getBoxWidth(labelOpts, fontSize);
					var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

					if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
						totalHeight += fontSize + labelOpts.padding;
						lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
					}

					// Store the hitbox width and height here. Final position will be updated in `draw`
					hitboxes[i] = {
						left: 0,
						top: 0,
						width: width,
						height: fontSize
					};

					lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
				});

				minSize.height += totalHeight;

			} else {
				var vPadding = labelOpts.padding;
				var columnWidths = me.columnWidths = [];
				var totalWidth = labelOpts.padding;
				var currentColWidth = 0;
				var currentColHeight = 0;
				var itemHeight = fontSize + vPadding;

				helpers$1.each(me.legendItems, function(legendItem, i) {
					var boxWidth = getBoxWidth(labelOpts, fontSize);
					var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

					// If too tall, go to new column
					if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
						totalWidth += currentColWidth + labelOpts.padding;
						columnWidths.push(currentColWidth); // previous column width

						currentColWidth = 0;
						currentColHeight = 0;
					}

					// Get max width
					currentColWidth = Math.max(currentColWidth, itemWidth);
					currentColHeight += itemHeight;

					// Store the hitbox width and height here. Final position will be updated in `draw`
					hitboxes[i] = {
						left: 0,
						top: 0,
						width: itemWidth,
						height: fontSize
					};
				});

				totalWidth += currentColWidth;
				columnWidths.push(currentColWidth);
				minSize.width += totalWidth;
			}
		}

		me.width = minSize.width;
		me.height = minSize.height;
	},
	afterFit: noop$1,

	// Shared Methods
	isHorizontal: function() {
		return this.options.position === 'top' || this.options.position === 'bottom';
	},

	// Actually draw the legend on the canvas
	draw: function() {
		var me = this;
		var opts = me.options;
		var labelOpts = opts.labels;
		var globalDefaults = core_defaults.global;
		var defaultColor = globalDefaults.defaultColor;
		var lineDefault = globalDefaults.elements.line;
		var legendWidth = me.width;
		var lineWidths = me.lineWidths;

		if (opts.display) {
			var ctx = me.ctx;
			var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);
			var labelFont = helpers$1.options._parseFont(labelOpts);
			var fontSize = labelFont.size;
			var cursor;

			// Canvas setup
			ctx.textAlign = 'left';
			ctx.textBaseline = 'middle';
			ctx.lineWidth = 0.5;
			ctx.strokeStyle = fontColor; // for strikethrough effect
			ctx.fillStyle = fontColor; // render in correct colour
			ctx.font = labelFont.string;

			var boxWidth = getBoxWidth(labelOpts, fontSize);
			var hitboxes = me.legendHitBoxes;

			// current position
			var drawLegendBox = function(x, y, legendItem) {
				if (isNaN(boxWidth) || boxWidth <= 0) {
					return;
				}

				// Set the ctx for the box
				ctx.save();

				var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
				ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
				ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
				ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
				ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
				ctx.lineWidth = lineWidth;
				ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

				if (ctx.setLineDash) {
					// IE 9 and 10 do not support line dash
					ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
				}

				if (opts.labels && opts.labels.usePointStyle) {
					// Recalculate x and y for drawPoint() because its expecting
					// x and y to be center of figure (instead of top left)
					var radius = boxWidth * Math.SQRT2 / 2;
					var centerX = x + boxWidth / 2;
					var centerY = y + fontSize / 2;

					// Draw pointStyle as legend symbol
					helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
				} else {
					// Draw box as legend symbol
					if (lineWidth !== 0) {
						ctx.strokeRect(x, y, boxWidth, fontSize);
					}
					ctx.fillRect(x, y, boxWidth, fontSize);
				}

				ctx.restore();
			};
			var fillText = function(x, y, legendItem, textWidth) {
				var halfFontSize = fontSize / 2;
				var xLeft = boxWidth + halfFontSize + x;
				var yMiddle = y + halfFontSize;

				ctx.fillText(legendItem.text, xLeft, yMiddle);

				if (legendItem.hidden) {
					// Strikethrough the text if hidden
					ctx.beginPath();
					ctx.lineWidth = 2;
					ctx.moveTo(xLeft, yMiddle);
					ctx.lineTo(xLeft + textWidth, yMiddle);
					ctx.stroke();
				}
			};

			// Horizontal
			var isHorizontal = me.isHorizontal();
			if (isHorizontal) {
				cursor = {
					x: me.left + ((legendWidth - lineWidths[0]) / 2) + labelOpts.padding,
					y: me.top + labelOpts.padding,
					line: 0
				};
			} else {
				cursor = {
					x: me.left + labelOpts.padding,
					y: me.top + labelOpts.padding,
					line: 0
				};
			}

			var itemHeight = fontSize + labelOpts.padding;
			helpers$1.each(me.legendItems, function(legendItem, i) {
				var textWidth = ctx.measureText(legendItem.text).width;
				var width = boxWidth + (fontSize / 2) + textWidth;
				var x = cursor.x;
				var y = cursor.y;

				// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
				// instead of me.right and me.bottom because me.width and me.height
				// may have been changed since me.minSize was calculated
				if (isHorizontal) {
					if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
						y = cursor.y += itemHeight;
						cursor.line++;
						x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) + labelOpts.padding;
					}
				} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
					x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
					y = cursor.y = me.top + labelOpts.padding;
					cursor.line++;
				}

				drawLegendBox(x, y, legendItem);

				hitboxes[i].left = x;
				hitboxes[i].top = y;

				// Fill the actual label
				fillText(x, y, legendItem, textWidth);

				if (isHorizontal) {
					cursor.x += width + labelOpts.padding;
				} else {
					cursor.y += itemHeight;
				}

			});
		}
	},

	/**
	 * @private
	 */
	_getLegendItemAt: function(x, y) {
		var me = this;
		var i, hitBox, lh;

		if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
			// See if we are touching one of the dataset boxes
			lh = me.legendHitBoxes;
			for (i = 0; i < lh.length; ++i) {
				hitBox = lh[i];

				if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
					// Touching an element
					return me.legendItems[i];
				}
			}
		}

		return null;
	},

	/**
	 * Handle an event
	 * @private
	 * @param {IEvent} event - The event to handle
	 */
	handleEvent: function(e) {
		var me = this;
		var opts = me.options;
		var type = e.type === 'mouseup' ? 'click' : e.type;
		var hoveredItem;

		if (type === 'mousemove') {
			if (!opts.onHover && !opts.onLeave) {
				return;
			}
		} else if (type === 'click') {
			if (!opts.onClick) {
				return;
			}
		} else {
			return;
		}

		// Chart event already has relative position in it
		hoveredItem = me._getLegendItemAt(e.x, e.y);

		if (type === 'click') {
			if (hoveredItem && opts.onClick) {
				// use e.native for backwards compatibility
				opts.onClick.call(me, e.native, hoveredItem);
			}
		} else {
			if (opts.onLeave && hoveredItem !== me._hoveredItem) {
				if (me._hoveredItem) {
					opts.onLeave.call(me, e.native, me._hoveredItem);
				}
				me._hoveredItem = hoveredItem;
			}

			if (opts.onHover && hoveredItem) {
				// use e.native for backwards compatibility
				opts.onHover.call(me, e.native, hoveredItem);
			}
		}
	}
});

function createNewLegendAndAttach(chart, legendOpts) {
	var legend = new Legend({
		ctx: chart.ctx,
		options: legendOpts,
		chart: chart
	});

	core_layouts.configure(chart, legend, legendOpts);
	core_layouts.addBox(chart, legend);
	chart.legend = legend;
}

var plugin_legend = {
	id: 'legend',

	/**
	 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
	 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
	 * the plugin, which one will be re-exposed in the chart.js file.
	 * https://github.com/chartjs/Chart.js/pull/2640
	 * @private
	 */
	_element: Legend,

	beforeInit: function(chart) {
		var legendOpts = chart.options.legend;

		if (legendOpts) {
			createNewLegendAndAttach(chart, legendOpts);
		}
	},

	beforeUpdate: function(chart) {
		var legendOpts = chart.options.legend;
		var legend = chart.legend;

		if (legendOpts) {
			helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

			if (legend) {
				core_layouts.configure(chart, legend, legendOpts);
				legend.options = legendOpts;
			} else {
				createNewLegendAndAttach(chart, legendOpts);
			}
		} else if (legend) {
			core_layouts.removeBox(chart, legend);
			delete chart.legend;
		}
	},

	afterEvent: function(chart, e) {
		var legend = chart.legend;
		if (legend) {
			legend.handleEvent(e);
		}
	}
};

var noop$2 = helpers$1.noop;

core_defaults._set('global', {
	title: {
		display: false,
		fontStyle: 'bold',
		fullWidth: true,
		padding: 10,
		position: 'top',
		text: '',
		weight: 2000         // by default greater than legend (1000) to be above
	}
});

/**
 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
 */
var Title = core_element.extend({
	initialize: function(config) {
		var me = this;
		helpers$1.extend(me, config);

		// Contains hit boxes for each dataset (in dataset order)
		me.legendHitBoxes = [];
	},

	// These methods are ordered by lifecycle. Utilities then follow.

	beforeUpdate: noop$2,
	update: function(maxWidth, maxHeight, margins) {
		var me = this;

		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
		me.beforeUpdate();

		// Absorb the master measurements
		me.maxWidth = maxWidth;
		me.maxHeight = maxHeight;
		me.margins = margins;

		// Dimensions
		me.beforeSetDimensions();
		me.setDimensions();
		me.afterSetDimensions();
		// Labels
		me.beforeBuildLabels();
		me.buildLabels();
		me.afterBuildLabels();

		// Fit
		me.beforeFit();
		me.fit();
		me.afterFit();
		//
		me.afterUpdate();

		return me.minSize;

	},
	afterUpdate: noop$2,

	//

	beforeSetDimensions: noop$2,
	setDimensions: function() {
		var me = this;
		// Set the unconstrained dimension before label rotation
		if (me.isHorizontal()) {
			// Reset position before calculating rotation
			me.width = me.maxWidth;
			me.left = 0;
			me.right = me.width;
		} else {
			me.height = me.maxHeight;

			// Reset position before calculating rotation
			me.top = 0;
			me.bottom = me.height;
		}

		// Reset padding
		me.paddingLeft = 0;
		me.paddingTop = 0;
		me.paddingRight = 0;
		me.paddingBottom = 0;

		// Reset minSize
		me.minSize = {
			width: 0,
			height: 0
		};
	},
	afterSetDimensions: noop$2,

	//

	beforeBuildLabels: noop$2,
	buildLabels: noop$2,
	afterBuildLabels: noop$2,

	//

	beforeFit: noop$2,
	fit: function() {
		var me = this;
		var opts = me.options;
		var display = opts.display;
		var minSize = me.minSize;
		var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
		var fontOpts = helpers$1.options._parseFont(opts);
		var textSize = display ? (lineCount * fontOpts.lineHeight) + (opts.padding * 2) : 0;

		if (me.isHorizontal()) {
			minSize.width = me.maxWidth; // fill all the width
			minSize.height = textSize;
		} else {
			minSize.width = textSize;
			minSize.height = me.maxHeight; // fill all the height
		}

		me.width = minSize.width;
		me.height = minSize.height;

	},
	afterFit: noop$2,

	// Shared Methods
	isHorizontal: function() {
		var pos = this.options.position;
		return pos === 'top' || pos === 'bottom';
	},

	// Actually draw the title block on the canvas
	draw: function() {
		var me = this;
		var ctx = me.ctx;
		var opts = me.options;

		if (opts.display) {
			var fontOpts = helpers$1.options._parseFont(opts);
			var lineHeight = fontOpts.lineHeight;
			var offset = lineHeight / 2 + opts.padding;
			var rotation = 0;
			var top = me.top;
			var left = me.left;
			var bottom = me.bottom;
			var right = me.right;
			var maxWidth, titleX, titleY;

			ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour
			ctx.font = fontOpts.string;

			// Horizontal
			if (me.isHorizontal()) {
				titleX = left + ((right - left) / 2); // midpoint of the width
				titleY = top + offset;
				maxWidth = right - left;
			} else {
				titleX = opts.position === 'left' ? left + offset : right - offset;
				titleY = top + ((bottom - top) / 2);
				maxWidth = bottom - top;
				rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
			}

			ctx.save();
			ctx.translate(titleX, titleY);
			ctx.rotate(rotation);
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';

			var text = opts.text;
			if (helpers$1.isArray(text)) {
				var y = 0;
				for (var i = 0; i < text.length; ++i) {
					ctx.fillText(text[i], 0, y, maxWidth);
					y += lineHeight;
				}
			} else {
				ctx.fillText(text, 0, 0, maxWidth);
			}

			ctx.restore();
		}
	}
});

function createNewTitleBlockAndAttach(chart, titleOpts) {
	var title = new Title({
		ctx: chart.ctx,
		options: titleOpts,
		chart: chart
	});

	core_layouts.configure(chart, title, titleOpts);
	core_layouts.addBox(chart, title);
	chart.titleBlock = title;
}

var plugin_title = {
	id: 'title',

	/**
	 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
	 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
	 * the plugin, which one will be re-exposed in the chart.js file.
	 * https://github.com/chartjs/Chart.js/pull/2640
	 * @private
	 */
	_element: Title,

	beforeInit: function(chart) {
		var titleOpts = chart.options.title;

		if (titleOpts) {
			createNewTitleBlockAndAttach(chart, titleOpts);
		}
	},

	beforeUpdate: function(chart) {
		var titleOpts = chart.options.title;
		var titleBlock = chart.titleBlock;

		if (titleOpts) {
			helpers$1.mergeIf(titleOpts, core_defaults.global.title);

			if (titleBlock) {
				core_layouts.configure(chart, titleBlock, titleOpts);
				titleBlock.options = titleOpts;
			} else {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		} else if (titleBlock) {
			core_layouts.removeBox(chart, titleBlock);
			delete chart.titleBlock;
		}
	}
};

var plugins = {};
var filler = plugin_filler;
var legend = plugin_legend;
var title = plugin_title;
plugins.filler = filler;
plugins.legend = legend;
plugins.title = title;

/**
 * @namespace Chart
 */


core_controller.helpers = helpers$1;

// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
core_helpers(core_controller);

core_controller._adapters = core_adapters;
core_controller.Animation = core_animation;
core_controller.animationService = core_animations;
core_controller.controllers = controllers;
core_controller.DatasetController = core_datasetController;
core_controller.defaults = core_defaults;
core_controller.Element = core_element;
core_controller.elements = elements;
core_controller.Interaction = core_interaction;
core_controller.layouts = core_layouts;
core_controller.platform = platform;
core_controller.plugins = core_plugins;
core_controller.Scale = core_scale;
core_controller.scaleService = core_scaleService;
core_controller.Ticks = core_ticks;
core_controller.Tooltip = core_tooltip;

// Register built-in scales

core_controller.helpers.each(scales, function(scale, type) {
	core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
});

// Load to register built-in adapters (as side effects)


// Loading built-in plugins

for (var k in plugins) {
	if (plugins.hasOwnProperty(k)) {
		core_controller.plugins.register(plugins[k]);
	}
}

core_controller.platform.initialize();

var src = core_controller;
if (typeof window !== 'undefined') {
	window.Chart = core_controller;
}

// DEPRECATIONS

/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Chart
 * @deprecated since version 2.8.0
 * @todo remove at version 3
 * @private
 */
core_controller.Chart = core_controller;

/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Legend
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */
core_controller.Legend = plugins.legend._element;

/**
 * Provided for backward compatibility, not available anymore
 * @namespace Chart.Title
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */
core_controller.Title = plugins.title._element;

/**
 * Provided for backward compatibility, use Chart.plugins instead
 * @namespace Chart.pluginService
 * @deprecated since version 2.1.5
 * @todo remove at version 3
 * @private
 */
core_controller.pluginService = core_controller.plugins;

/**
 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
 * effect, instead simply create/register plugins via plain JavaScript objects.
 * @interface Chart.PluginBase
 * @deprecated since version 2.5.0
 * @todo remove at version 3
 * @private
 */
core_controller.PluginBase = core_controller.Element.extend({});

/**
 * Provided for backward compatibility, use Chart.helpers.canvas instead.
 * @namespace Chart.canvasHelpers
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */
core_controller.canvasHelpers = core_controller.helpers.canvas;

/**
 * Provided for backward compatibility, use Chart.layouts instead.
 * @namespace Chart.layoutService
 * @deprecated since version 2.7.3
 * @todo remove at version 3
 * @private
 */
core_controller.layoutService = core_controller.layouts;

/**
 * Provided for backward compatibility, not available anymore.
 * @namespace Chart.LinearScaleBase
 * @deprecated since version 2.8
 * @todo remove at version 3
 * @private
 */
core_controller.LinearScaleBase = scale_linearbase;

/**
 * Provided for backward compatibility, instead we should create a new Chart
 * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
 * @deprecated since version 2.8.0
 * @todo remove at version 3
 */
core_controller.helpers.each(
	[
		'Bar',
		'Bubble',
		'Doughnut',
		'Line',
		'PolarArea',
		'Radar',
		'Scatter'
	],
	function(klass) {
		core_controller[klass] = function(ctx, cfg) {
			return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
				type: klass.charAt(0).toLowerCase() + klass.slice(1)
			}));
		};
	}
);

return src;

})));
</script>
    <script type="text/javascript" charset="utf-8">/*!
 * chartjs-plugin-annotation.js
 * http://chartjs.org/
 * Version: 0.5.7X001 @blab+
 *
 * Copyright 2016 Evert Timberg
 * Released under the MIT license
 * https://github.com/chartjs/Chart.Annotation.js/blob/master/LICENSE.md
 * https://github.com/chartjs/chartjs-plugin-annotation/blob/1ab782afce943456f958cac33f67edc5d6eab278/README.md
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
module.exports = function(Chart) {
	var chartHelpers = Chart.helpers;

	var helpers = require('./helpers.js')(Chart);
	var events = require('./events.js')(Chart);

	var annotationTypes = Chart.Annotation.types;

	function setAfterDataLimitsHook(axisOptions) {
		helpers.decorate(axisOptions, 'afterDataLimits', function(previous, scale) {
			if (previous) previous(scale);
			helpers.adjustScaleRange(scale);
		});
	}

	function draw(drawTime) {
		return function(chartInstance, easingDecimal) {
			var defaultDrawTime = chartInstance.annotation.options.drawTime;

			helpers.elements(chartInstance)
				.filter(function(element) {
					return drawTime === (element.options.drawTime || defaultDrawTime);
				})
				.forEach(function(element) {
					element.transition(easingDecimal).draw();
				});
		};
	}

	return {
		beforeInit: function(chartInstance) {
			var chartOptions = chartInstance.options;

			// Initialize chart instance plugin namespace
			var ns = chartInstance.annotation = {
				elements: {},
				options: helpers.initConfig(chartOptions.annotation || {}),
				onDestroy: [],
				firstRun: true,
				supported: false
			};

			// Add the annotation scale adjuster to each scale's afterDataLimits hook
			chartInstance.ensureScalesHaveIDs();
			if (chartOptions.scales) {
				ns.supported = true;
				chartHelpers.each(chartOptions.scales.xAxes, setAfterDataLimitsHook);
				chartHelpers.each(chartOptions.scales.yAxes, setAfterDataLimitsHook);
			}
		},
		beforeUpdate: function(chartInstance) {
			var ns = chartInstance.annotation;

			if (!ns.supported) {
				return;
			}

			if (!ns.firstRun) {
				ns.options = helpers.initConfig(chartInstance.options.annotation || {});
			} else {
				ns.firstRun = false;
			}

			var elementIds = [];

			// Add new elements, or update existing ones
			ns.options.annotations.forEach(function(annotation) {
				var id = annotation.id || helpers.objectId();
				
				// No element with that ID exists, and it's a valid annotation type
				if (!ns.elements[id] && annotationTypes[annotation.type]) {
					var cls = annotationTypes[annotation.type];
					var element = new cls({
						id: id,
						options: annotation,
						chartInstance: chartInstance,
					});
					element.initialize();
					ns.elements[id] = element;
					annotation.id = id;
					elementIds.push(id);
				} else if (ns.elements[id]) {
					// Nothing to do for update, since the element config references
					// the same object that exists in the chart annotation config
					elementIds.push(id);
				}
			});

			// Delete removed elements
			Object.keys(ns.elements).forEach(function(id) {
				if (elementIds.indexOf(id) === -1) {
					ns.elements[id].destroy();
					delete ns.elements[id];
				}
			});
		},
		afterScaleUpdate: function(chartInstance) {
			helpers.elements(chartInstance).forEach(function(element) {
				element.configure();
			});
		},
		beforeDatasetsDraw: draw('beforeDatasetsDraw'),
		afterDatasetsDraw: draw('afterDatasetsDraw'),
		afterDraw: draw('afterDraw'),
		afterInit: function(chartInstance) {
			// Detect and intercept events that happen on an annotation element
			var watchFor = chartInstance.annotation.options.events;
			if (chartHelpers.isArray(watchFor) && watchFor.length > 0) {
				var canvas = chartInstance.chart.canvas;
				var eventHandler = events.dispatcher.bind(chartInstance);
				events.collapseHoverEvents(watchFor).forEach(function(eventName) {
					chartHelpers.addEvent(canvas, eventName, eventHandler);
					chartInstance.annotation.onDestroy.push(function() {
						chartHelpers.removeEvent(canvas, eventName, eventHandler);
					});
				});
			}
		},
		destroy: function(chartInstance) {
			var deregisterers = chartInstance.annotation.onDestroy;
			while (deregisterers.length > 0) {
				deregisterers.pop()();
			}
		}
	};
};

},{"./events.js":4,"./helpers.js":5}],3:[function(require,module,exports){
module.exports = function(Chart) {
	var chartHelpers = Chart.helpers;
	
	var AnnotationElement = Chart.Element.extend({
		initialize: function() {
			this.hidden = false;
			this.hovering = false;
			this._model = chartHelpers.clone(this._model) || {};
			this.setDataLimits();
		},
		destroy: function() {},
		setDataLimits: function() {},
		configure: function() {},
		inRange: function() {},
		getCenterPoint: function() {},
		getWidth: function() {},
		getHeight: function() {},
		getArea: function() {},
		draw: function() {}
	});

	return AnnotationElement;
};

},{}],4:[function(require,module,exports){
module.exports = function(Chart) {
	var chartHelpers = Chart.helpers;
	var helpers = require('./helpers.js')(Chart);

	function collapseHoverEvents(events) {
		var hover = false;
		var filteredEvents = events.filter(function(eventName) {
			switch (eventName) {
				case 'mouseenter':
				case 'mouseover':
				case 'mouseout':
				case 'mouseleave':
					hover = true;
					return false;

				default:
					return true;
			}
		});
		if (hover && filteredEvents.indexOf('mousemove') === -1) {
			filteredEvents.push('mousemove');
		}
		return filteredEvents;
	}

	function dispatcher(e) {
		var ns = this.annotation;
		var elements = helpers.elements(this);
		var position = chartHelpers.getRelativePosition(e, this.chart);
		var element = helpers.getNearestItems(elements, position);
		var events = collapseHoverEvents(ns.options.events);
		var dblClickSpeed = ns.options.dblClickSpeed;
		var eventHandlers = [];
		var eventHandlerName = helpers.getEventHandlerName(e.type);
		var options = (element || {}).options;

		// Detect hover events
		if (e.type === 'mousemove') {
			if (element && !element.hovering) {
				// hover started
				['mouseenter', 'mouseover'].forEach(function(eventName) {
					var eventHandlerName = helpers.getEventHandlerName(eventName);
					var hoverEvent = helpers.createMouseEvent(eventName, e); // recreate the event to match the handler
					element.hovering = true;
					if (typeof options[eventHandlerName] === 'function') {
						eventHandlers.push([ options[eventHandlerName], hoverEvent, element ]);
					}
				});
			} else if (!element) {
				// hover ended
				elements.forEach(function(element) {
					if (element.hovering) {
						element.hovering = false;
						var options = element.options;
						['mouseout', 'mouseleave'].forEach(function(eventName) {
							var eventHandlerName = helpers.getEventHandlerName(eventName);
							var hoverEvent = helpers.createMouseEvent(eventName, e); // recreate the event to match the handler
							if (typeof options[eventHandlerName] === 'function') {
								eventHandlers.push([ options[eventHandlerName], hoverEvent, element ]);
							}
						});
					}
				});
			}
		}

		// Suppress duplicate click events during a double click
		// 1. click -> 2. click -> 3. dblclick
		//
		// 1: wait dblClickSpeed ms, then fire click
		// 2: cancel (1) if it is waiting then wait dblClickSpeed ms then fire click, else fire click immediately
		// 3: cancel (1) or (2) if waiting, then fire dblclick 
		if (element && events.indexOf('dblclick') > -1 && typeof options.onDblclick === 'function') {
			if (e.type === 'click' && typeof options.onClick === 'function') {
				clearTimeout(element.clickTimeout);
				element.clickTimeout = setTimeout(function() {
					delete element.clickTimeout;
					options.onClick.call(element, e);
				}, dblClickSpeed);
				e.stopImmediatePropagation();
				e.preventDefault();
				return;
			} else if (e.type === 'dblclick' && element.clickTimeout) {
				clearTimeout(element.clickTimeout);
				delete element.clickTimeout;
			}
		}

		// Dispatch the event to the usual handler, but only if we haven't substituted it
		if (element && typeof options[eventHandlerName] === 'function' && eventHandlers.length === 0) {
			eventHandlers.push([ options[eventHandlerName], e, element ]);
		}

		if (eventHandlers.length > 0) {
			e.stopImmediatePropagation();
			e.preventDefault();
			eventHandlers.forEach(function(eventHandler) {
				// [handler, event, element]
				eventHandler[0].call(eventHandler[2], eventHandler[1]);
			});
		}
	}

	return {
		dispatcher: dispatcher,
		collapseHoverEvents: collapseHoverEvents
	};
};

},{"./helpers.js":5}],5:[function(require,module,exports){
function noop() {}

function elements(chartInstance) {
	// Turn the elements object into an array of elements
	var elements = chartInstance.annotation.elements;
	return Object.keys(elements).map(function(id) {
		return elements[id];
	});
}

function objectId() {
	return Math.random().toString(36).substr(2, 6);
}

function isValid(rawValue) {
	if (rawValue === null || typeof rawValue === 'undefined') {
		return false;
	} else if (typeof rawValue === 'number') {
		return isFinite(rawValue);
	} else {
		return !!rawValue;
	}
}

function decorate(obj, prop, func) {
	var prefix = '$';
	if (!obj[prefix + prop]) {
		if (obj[prop]) {
			obj[prefix + prop] = obj[prop].bind(obj);
			obj[prop] = function() {
				var args = [ obj[prefix + prop] ].concat(Array.prototype.slice.call(arguments));
				return func.apply(obj, args);
			};
		} else {
			obj[prop] = function() {
				var args = [ undefined ].concat(Array.prototype.slice.call(arguments));
				return func.apply(obj, args);
			};
		}
	}
}

function callEach(fns, method) {
	fns.forEach(function(fn) {
		(method ? fn[method] : fn)();
	});
}

function getEventHandlerName(eventName) {
	return 'on' + eventName[0].toUpperCase() + eventName.substring(1);
}

function createMouseEvent(type, previousEvent) {
	try {
		return new MouseEvent(type, previousEvent);
	} catch (exception) {
		try {
			var m = document.createEvent('MouseEvent');
			m.initMouseEvent(
				type,
				previousEvent.canBubble,
				previousEvent.cancelable,
				previousEvent.view,
				previousEvent.detail,
				previousEvent.screenX,
				previousEvent.screenY,
				previousEvent.clientX,
				previousEvent.clientY,
				previousEvent.ctrlKey,
				previousEvent.altKey,
				previousEvent.shiftKey,
				previousEvent.metaKey,
				previousEvent.button,
				previousEvent.relatedTarget
			);
			return m;
		} catch (exception2) {
			var e = document.createEvent('Event');
			e.initEvent(
				type,
				previousEvent.canBubble,
				previousEvent.cancelable
			);
			return e;
		}
	}
}

module.exports = function(Chart) {
	var chartHelpers = Chart.helpers;

	function initConfig(config) {
		config = chartHelpers.configMerge(Chart.Annotation.defaults, config);
		if (chartHelpers.isArray(config.annotations)) {
			config.annotations.forEach(function(annotation) {
				annotation.label = chartHelpers.configMerge(Chart.Annotation.labelDefaults, annotation.label);
			});
		}
		return config;
	}

	function getScaleLimits(scaleId, annotations, scaleMin, scaleMax) {
		var ranges = annotations.filter(function(annotation) {
			return !!annotation._model.ranges[scaleId];
		}).map(function(annotation) {
			return annotation._model.ranges[scaleId];
		});

		var min = ranges.map(function(range) {
			return Number(range.min);
		}).reduce(function(a, b) {
			return isFinite(b) && !isNaN(b) && b < a ? b : a;
		}, scaleMin);

		var max = ranges.map(function(range) {
			return Number(range.max);
		}).reduce(function(a, b) {
			return isFinite(b) && !isNaN(b) && b > a ? b : a;
		}, scaleMax);

		return {
			min: min,
			max: max
		};
	}

	function adjustScaleRange(scale) {
		// Adjust the scale range to include annotation values
		var range = getScaleLimits(scale.id, elements(scale.chart), scale.min, scale.max);
		if (typeof scale.options.ticks.min === 'undefined' && typeof scale.options.ticks.suggestedMin === 'undefined') {
			scale.min = range.min;
		}
		if (typeof scale.options.ticks.max === 'undefined' && typeof scale.options.ticks.suggestedMax === 'undefined') {
			scale.max = range.max;
		}
		if (scale.handleTickRangeOptions) {
			scale.handleTickRangeOptions();
		}
	}

	function getNearestItems(annotations, position) {
		var minDistance = Number.POSITIVE_INFINITY;

		return annotations
			.filter(function(element) {
				return element.inRange(position.x, position.y);
			})
			.reduce(function(nearestItems, element) {
				var center = element.getCenterPoint();
				var distance = chartHelpers.distanceBetweenPoints(position, center);

				if (distance < minDistance) {
					nearestItems = [element];
					minDistance = distance;
				} else if (distance === minDistance) {
					// Can have multiple items at the same distance in which case we sort by size
					nearestItems.push(element);
				}

				return nearestItems;
			}, [])
			.sort(function(a, b) {
				// If there are multiple elements equally close,
				// sort them by size, then by index
				var sizeA = a.getArea(), sizeB = b.getArea();
				return (sizeA > sizeB || sizeA < sizeB) ? sizeA - sizeB : a._index - b._index;
			})
			.slice(0, 1)[0]; // return only the top item
	}

	return {
		initConfig: initConfig,
		elements: elements,
		callEach: callEach,
		noop: noop,
		objectId: objectId,
		isValid: isValid,
		decorate: decorate,
		adjustScaleRange: adjustScaleRange,
		getNearestItems: getNearestItems,
		getEventHandlerName: getEventHandlerName,
		createMouseEvent: createMouseEvent
	};
};


},{}],6:[function(require,module,exports){
// Get the chart variable
var Chart = require('chart.js');
Chart = typeof(Chart) === 'function' ? Chart : window.Chart;

// Configure plugin namespace
Chart.Annotation = Chart.Annotation || {};

Chart.Annotation.drawTimeOptions = {
	afterDraw: 'afterDraw',
	afterDatasetsDraw: 'afterDatasetsDraw',
	beforeDatasetsDraw: 'beforeDatasetsDraw'
};

Chart.Annotation.defaults = {
	drawTime: 'afterDatasetsDraw',
	dblClickSpeed: 350, // ms
	events: [],
	annotations: []
};

Chart.Annotation.labelDefaults = {
	backgroundColor: 'rgba(0,0,0,0.8)',
	fontFamily: Chart.defaults.global.defaultFontFamily,
	fontSize: Chart.defaults.global.defaultFontSize,
	fontStyle: 'bold',
	fontColor: '#fff',
	xPadding: 6,
	yPadding: 6,
	cornerRadius: 6,
	position: 'center',
	xAdjust: 0,
	yAdjust: 0,
	enabled: false,
	content: null
};

Chart.Annotation.Element = require('./element.js')(Chart);

Chart.Annotation.types = {
	line: require('./types/line.js')(Chart),
	box: require('./types/box.js')(Chart)
};

var annotationPlugin = require('./annotation.js')(Chart);

module.exports = annotationPlugin;
Chart.pluginService.register(annotationPlugin);

},{"./annotation.js":2,"./element.js":3,"./types/box.js":7,"./types/line.js":8,"chart.js":1}],7:[function(require,module,exports){
// Box Annotation implementation
module.exports = function(Chart) {
	var helpers = require('../helpers.js')(Chart);
	
	var BoxAnnotation = Chart.Annotation.Element.extend({
		setDataLimits: function() {
			var model = this._model;
			var options = this.options;
			var chartInstance = this.chartInstance;

			var xScale = chartInstance.scales[options.xScaleID];
			var yScale = chartInstance.scales[options.yScaleID];
			var chartArea = chartInstance.chartArea;

			// Set the data range for this annotation
			model.ranges = {};
			
			if (!chartArea) {
				return;
			}
			
			var min = 0;
			var max = 0;
			
			if (xScale) {
				min = helpers.isValid(options.xMin) ? options.xMin : xScale.getPixelForValue(chartArea.left);
				max = helpers.isValid(options.xMax) ? options.xMax : xScale.getPixelForValue(chartArea.right);

				model.ranges[options.xScaleID] = {
					min: Math.min(min, max),
					max: Math.max(min, max)
				};
			}

			if (yScale) {
				min = helpers.isValid(options.yMin) ? options.yMin : yScale.getPixelForValue(chartArea.bottom);
				max = helpers.isValid(options.yMax) ? options.yMax : yScale.getPixelForValue(chartArea.top);

				model.ranges[options.yScaleID] = {
					min: Math.min(min, max),
					max: Math.max(min, max)
				};
			}
		},
		configure: function() {
			var model = this._model;
			var options = this.options;
			var chartInstance = this.chartInstance;

			var xScale = chartInstance.scales[options.xScaleID];
			var yScale = chartInstance.scales[options.yScaleID];
			var chartArea = chartInstance.chartArea;

			// clip annotations to the chart area
			model.clip = {
				x1: chartArea.left,
				x2: chartArea.right,
				y1: chartArea.top,
				y2: chartArea.bottom
			};

			var left = chartArea.left, 
				top = chartArea.top, 
				right = chartArea.right, 
				bottom = chartArea.bottom;

			var min, max;

			if (xScale) {
				min = helpers.isValid(options.xMin) ? xScale.getPixelForValue(options.xMin) : chartArea.left;
				max = helpers.isValid(options.xMax) ? xScale.getPixelForValue(options.xMax) : chartArea.right;
				left = Math.min(min, max);
				right = Math.max(min, max);
			}

			if (yScale) {
				min = helpers.isValid(options.yMin) ? yScale.getPixelForValue(options.yMin) : chartArea.bottom;
				max = helpers.isValid(options.yMax) ? yScale.getPixelForValue(options.yMax) : chartArea.top;
				top = Math.min(min, max);
				bottom = Math.max(min, max);
			}

			// Ensure model has rect coordinates
			model.left = left;
			model.top = top;
			model.right = right;
			model.bottom = bottom;

			// Stylistic options
			model.borderColor = options.borderColor;
			model.borderWidth = options.borderWidth;
			model.backgroundColor = options.backgroundColor;
		},
		inRange: function(mouseX, mouseY) {
			var model = this._model;
			return model &&
				mouseX >= model.left && 
				mouseX <= model.right && 
				mouseY >= model.top && 
				mouseY <= model.bottom;
		},
		getCenterPoint: function() {
			var model = this._model;
			return {
				x: (model.right + model.left) / 2,
				y: (model.bottom + model.top) / 2
			};
		},
		getWidth: function() {
			var model = this._model;
			return Math.abs(model.right - model.left);
		},
		getHeight: function() {
			var model = this._model;
			return Math.abs(model.bottom - model.top);
		},
		getArea: function() {
			return this.getWidth() * this.getHeight();
		},
		draw: function() {
			var view = this._view;
			var ctx = this.chartInstance.chart.ctx;

			ctx.save();

			// Canvas setup
			ctx.beginPath();
			ctx.rect(view.clip.x1, view.clip.y1, view.clip.x2 - view.clip.x1, view.clip.y2 - view.clip.y1);
			ctx.clip();

			ctx.lineWidth = view.borderWidth;
			ctx.strokeStyle = view.borderColor;
			ctx.fillStyle = view.backgroundColor;

			// Draw
			var width = view.right - view.left,
				height = view.bottom - view.top;
			ctx.fillRect(view.left, view.top, width, height);
			ctx.strokeRect(view.left, view.top, width, height);

			ctx.restore();
		}
	});

	return BoxAnnotation;
};

},{"../helpers.js":5}],8:[function(require,module,exports){
// Line Annotation implementation
module.exports = function(Chart) {
	var chartHelpers = Chart.helpers;
	var helpers = require('../helpers.js')(Chart);

	var horizontalKeyword = 'horizontal';
	var verticalKeyword = 'vertical';

	var LineAnnotation = Chart.Annotation.Element.extend({
		setDataLimits: function() {
			var model = this._model;
			var options = this.options;

			// Set the data range for this annotation
			model.ranges = {};
			model.ranges[options.scaleID] = {
				min: options.value,
				max: options.endValue || options.value
			};
		},
		configure: function() {
			var model = this._model;
			var options = this.options;
			var chartInstance = this.chartInstance;
			var ctx = chartInstance.chart.ctx;

			var scale = options.scaleID && chartInstance.scales[options.scaleID];
  		var xScale = options.xScaleID && chartInstance.scales[options.xScaleID];
			var yScale = options.yScaleID && chartInstance.scales[options.yScaleID];

			var pixel, endPixel;
			var chartArea = chartInstance.chartArea;


			if (scale) {
				pixel = helpers.isValid(options.value) ? scale.getPixelForValue(options.value) : NaN;
				endPixel = helpers.isValid(options.endValue) ? scale.getPixelForValue(options.endValue) : pixel;
			  if (isNaN(pixel)) {
				  return;
			  }
			} else if (xScale && yScale) {
			  pixel = {
			    x:helpers.isValid(options.xMin) ? xScale.getPixelForValue(options.xMin) : NaN,
			    y:helpers.isValid(options.yMin) ? yScale.getPixelForValue(options.yMin) : NaN
			  }
			  endPixel = {
			    x:helpers.isValid(options.xMax) ? xScale.getPixelForValue(options.xMax) : NaN,
			    y:helpers.isValid(options.yMax) ? yScale.getPixelForValue(options.yMax) : NaN			  
			  }
			  if (isNaN(pixel.x)) {
				  return;
			  }
			} 
			// clip annotations to the chart area
			model.clip = {
				x1: chartArea.left-5,
				x2: chartArea.right+5,
				y1: chartArea.top-5,
				y2: chartArea.bottom+5
			};


			if (this.options.mode == horizontalKeyword) {
				model.x1 = chartArea.left;
				model.x2 = chartArea.right;
				model.y1 = pixel;
				model.y2 = endPixel;
			} else if (this.options.mode == verticalKeyword) {
				model.y1 = chartArea.top;
				model.y2 = chartArea.bottom;
				model.x1 = pixel;
				model.x2 = endPixel;
			} else if (xScale && yScale) {
				model.x1 = pixel.x;
				model.x2 = endPixel.x;
				model.y1 = pixel.y;
				model.y2 = endPixel.y;
			} else return;

			model.line = new LineFunction(model);
			model.mode = options.mode;

			// Figure out the label:
			model.labelBackgroundColor = options.label.backgroundColor;
			model.labelFontFamily = options.label.fontFamily;
			model.labelFontSize = options.label.fontSize;
			model.labelFontStyle = options.label.fontStyle;
			model.labelFontColor = options.label.fontColor;
			model.labelXPadding = options.label.xPadding;
			model.labelYPadding = options.label.yPadding;
			model.labelCornerRadius = options.label.cornerRadius;
			model.labelPosition = options.label.position;
			model.labelXAdjust = options.label.xAdjust;
			model.labelYAdjust = options.label.yAdjust;
			model.labelEnabled = options.label.enabled;
			model.labelContent = options.label.content;

			ctx.font = chartHelpers.fontString(model.labelFontSize, model.labelFontStyle, model.labelFontFamily);
			var textWidth = ctx.measureText(model.labelContent).width;
			var textHeight = ctx.measureText('M').width;
			var labelPosition = calculateLabelPosition(model, textWidth, textHeight, model.labelXPadding, model.labelYPadding);
			model.labelX = labelPosition.x - model.labelXPadding;
			model.labelY = labelPosition.y - model.labelYPadding;
			model.labelWidth = textWidth + (2 * model.labelXPadding);
			model.labelHeight = textHeight + (2 * model.labelYPadding);

			model.borderColor = options.borderColor;
			model.borderWidth = options.borderWidth;
			model.borderDash = options.borderDash || [];
			model.borderDashOffset = options.borderDashOffset || 0;
		},
		inRange: function(mouseX, mouseY) {
			var model = this._model;
			
			return (
				// On the line
				model.line &&
				model.line.intersects(mouseX, mouseY, this.getHeight())
			) || (
				// On the label
				model.labelEnabled &&
				model.labelContent &&
				mouseX >= model.labelX && 
				mouseX <= model.labelX + model.labelWidth && 
				mouseY >= model.labelY && 
				mouseY <= model.labelY + model.labelHeight
			);
		},
		getCenterPoint: function() {
			return {
				x: (this._model.x2 + this._model.x1) / 2,
				y: (this._model.y2 + this._model.y1) / 2
			};
		},
		getWidth: function() {
			return Math.abs(this._model.right - this._model.left);
		},
		getHeight: function() {
			return this._model.borderWidth || 1;
		},
		getArea: function() {
			return Math.sqrt(Math.pow(this.getWidth(), 2) + Math.pow(this.getHeight(), 2));
		},
		draw: function() {
			var view = this._view;
			var ctx = this.chartInstance.chart.ctx;

			if (!view.clip) {
				return;
			}

			ctx.save();

			// Canvas setup
			ctx.beginPath();
			ctx.rect(view.clip.x1, view.clip.y1, view.clip.x2 - view.clip.x1, view.clip.y2 - view.clip.y1);
			ctx.clip();

			ctx.lineWidth = view.borderWidth;
			ctx.strokeStyle = view.borderColor;

			if (ctx.setLineDash) {
				ctx.setLineDash(view.borderDash);
			}
			ctx.lineDashOffset = view.borderDashOffset;

			// Draw
			ctx.beginPath();
			ctx.moveTo(view.x1, view.y1);
			ctx.lineTo(view.x2, view.y2);
			ctx.stroke();

			if (view.labelEnabled && view.labelContent) {
				ctx.beginPath();
				ctx.rect(view.clip.x1, view.clip.y1, view.clip.x2 - view.clip.x1, view.clip.y2 - view.clip.y1);
				ctx.clip();

				ctx.fillStyle = view.labelBackgroundColor;
				// Draw the tooltip
				chartHelpers.drawRoundedRectangle(
					ctx,
					view.labelX, // x
					view.labelY, // y
					view.labelWidth, // width
					view.labelHeight, // height
					view.labelCornerRadius // radius
				);
				ctx.fill();

				// Draw the text
				ctx.font = chartHelpers.fontString(
					view.labelFontSize,
					view.labelFontStyle,
					view.labelFontFamily
				);
				ctx.fillStyle = view.labelFontColor;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(
					view.labelContent,
					view.labelX + (view.labelWidth / 2),
					view.labelY + (view.labelHeight / 2)
				);
			}

			ctx.restore();
		}
	});

	function LineFunction(view) {
		// Describe the line in slope-intercept form (y = mx + b).
		// Note that the axes are rotated 90° CCW, which causes the
		// x- and y-axes to be swapped.
		var m = (view.x2 - view.x1) / (view.y2 - view.y1);
		var b = view.x1 || 0;

		this.m = m;
		this.b = b;

		this.getX = function(y) {
			// Coordinates are relative to the origin of the canvas
			return m * (y - view.y1) + b;
		};

		this.getY = function(x) {
			return ((x - b) / m) + view.y1;
		};

		this.intersects = function(x, y, epsilon) {
			epsilon = epsilon || 0.001;
			var dy = this.getY(x),
				dx = this.getX(y);
			return (
				(!isFinite(dy) || Math.abs(y - dy) < epsilon) &&
				(!isFinite(dx) || Math.abs(x - dx) < epsilon)
			);
		};
	}

	function calculateLabelPosition(view, width, height, padWidth, padHeight) {
		var line = view.line;
		var ret = {}, xa = 0, ya = 0;

		switch (true) {
			// top align
			case view.mode == verticalKeyword && view.labelPosition == "top":
				ya = padHeight + view.labelYAdjust;
				xa = (width / 2) + view.labelXAdjust;
				ret.y = view.y1 + ya;
				ret.x = (isFinite(line.m) ? line.getX(ret.y) : view.x1) - xa;
			break;

			// bottom align
			case view.mode == verticalKeyword && view.labelPosition == "bottom":
				ya = height + padHeight + view.labelYAdjust;
				xa = (width / 2) + view.labelXAdjust;
				ret.y = view.y2 - ya;
				ret.x = (isFinite(line.m) ? line.getX(ret.y) : view.x1) - xa;
			break;

			// left align
			case view.mode == horizontalKeyword && view.labelPosition == "left":
				xa = padWidth + view.labelXAdjust;
				ya = -(height / 2) + view.labelYAdjust;
				ret.x = view.x1 + xa;
				ret.y = line.getY(ret.x) + ya;
			break;

			// right align
			case view.mode == horizontalKeyword && view.labelPosition == "right":
				xa = width + padWidth + view.labelXAdjust;
				ya = -(height / 2) + view.labelYAdjust;
				ret.x = view.x2 - xa;
				ret.y = line.getY(ret.x) + ya;
			break;

			// center align
			default:
				ret.x = ((view.x1 + view.x2 - width) / 2) + view.labelXAdjust;
				ret.y = ((view.y1 + view.y2 - height) / 2) + view.labelYAdjust;
		}

		return ret;
	}

	return LineAnnotation;
};

},{"../helpers.js":5}]},{},[6]);
</script>
    <script type="text/javascript" charset="utf-8">/* https://github.com/sgratzl/chartjs-chart-error-bars */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('chart.js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'chart.js'], factory) :
  (global = global || self, factory(global.ChartErrorBars = {}, global.Chart));
}(this, function (exports, Chart) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var allModelKeys = ['xMin', 'xMax', 'yMin', 'yMax'];
  function modelKeys(horizontal) {
    return horizontal ? allModelKeys.slice(0, 2) : allModelKeys.slice(2);
  }
  function isSameArray(a, b) {
    return a.length === b.length && a.every(function (v, i) {
      return v === b[i];
    });
  }
  function commonDataLimits(isHorizontal, extraCallback, ignoreIdCheck) {
    var _this = this;

    var chart = this.chart;

    var matchID = function matchID(meta) {
      return isHorizontal ? meta.xAxisID === _this.id : meta.yAxisID === _this.id;
    }; // First Calculate the range


    this.min = null;
    this.max = null;

    var _modelKeys = modelKeys(isHorizontal),
        _modelKeys2 = _slicedToArray(_modelKeys, 2),
        minKey = _modelKeys2[0],
        maxKey = _modelKeys2[1]; // Regular charts use x, y values
    // For the boxplot chart we have rawValue.min and rawValue.max for each point


    chart.data.datasets.forEach(function (d, i) {
      var meta = chart.getDatasetMeta(i);

      if (!chart.isDatasetVisible(i) || !ignoreIdCheck && !matchID(meta)) {
        return;
      }

      d.data.forEach(function (rawValue, j) {
        var value = _this.getRightValue(rawValue);

        if (isNaN(value) || meta.data[j].hidden) {
          return;
        }

        var vMin = rawValue[minKey];

        if (Array.isArray(vMin)) {
          vMin = vMin.reduce(function (acc, v) {
            return Math.min(acc, v);
          }, value);
        } else if (typeof vMin !== 'number') {
          vMin = value;
        }

        if (!isNaN(vMin) && (_this.min === null || vMin < _this.min)) {
          _this.min = vMin;
        }

        var vMax = rawValue[maxKey];

        if (Array.isArray(vMax)) {
          vMax = vMax.reduce(function (acc, v) {
            return Math.max(acc, v);
          }, value);
        } else if (typeof vMin !== 'number') {
          vMax = value;
        }

        if (!isNaN(vMax) && (_this.max === null || vMax > _this.max)) {
          _this.max = vMax;
        }

        if (extraCallback) {
          extraCallback(rawValue, isHorizontal);
        }
      });
    });

    if (this.min == null) {
      this.min = 0;
    }

    if (this.max == null) {
      this.max = 0;
    }
  }

  var defaults = {
    errorBarLineWidth: [[1, 3]],
    errorBarColor: [['#2c2c2c', '#1f1f1f']],
    errorBarWhiskerLineWidth: [[1, 3]],
    errorBarWhiskerRatio: [[0.2, 0.25]],
    errorBarWhiskerSize: [[20, 24]],
    errorBarWhiskerColor: [['#2c2c2c', '#1f1f1f']]
  };
  var styleKeys = Object.keys(defaults);
  function transitionErrorBarHelper(obj) {
    if (!obj) {
      return {};
    }

    var r = {};
    allModelKeys.forEach(function (key) {
      r[key] = obj[key];
    });
    return r;
  }
  function transitionErrorBar(start, startBak, view, model, ease) {
    allModelKeys.forEach(function (key) {
      var m = model[key];

      if (!Array.isArray(m)) {
        // primitive are alrady handled
        return;
      }

      if (!view.hasOwnProperty(key)) {
        view[key] = m.slice();
        return;
      }

      var v = view[key];

      if (!startBak.hasOwnProperty(key)) {
        start[key] = v.slice();
      }

      var s = start[key];

      if (isSameArray(s, m)) {
        return;
      }

      var common = Math.min(m.length, s.length);
      v = view[key] = new Array(common);

      for (var i = 0; i < common; ++i) {
        v[i] = s[i] + (m[i] - s[i]) * ease;
      }
    });
  }

  function resolve(inputs, context, index) {
    for (var i = 0; i < inputs.length; ++i) {
      var value = inputs[i];

      if (value === undefined) {
        continue;
      }

      if (context !== undefined && typeof value === 'function') {
        value = value(context);
      }

      if (index !== undefined && Array.isArray(value)) {
        // use mod to repeat the value and not returning undefined
        value = value[index % value.length];
      }

      if (value !== undefined) {
        return value;
      }
    }
  }
  /**
   * @param {number} index
   */


  function updateErrorBarElement(controller, elem, index) {
    var dataset = controller.getDataset();
    var custom = elem.custom || {};

    var options = controller._elementOptions(); // Scriptable options


    var context = {
      chart: controller.chart,
      dataIndex: index,
      dataset: dataset,
      datasetIndex: controller.index
    };
    styleKeys.forEach(function (item) {
      elem._model[item] = resolve([custom[item], dataset[item], options[item]], context, index);
    });
  }

  function resolveMulti(vMin, vMax) {
    var vMinArr = Array.isArray(vMin) ? vMin : [vMin];
    var vMaxArr = Array.isArray(vMax) ? vMax : [vMax];

    if (vMinArr.length === vMaxArr.length) {
      return vMinArr.map(function (v, i) {
        return [v, vMaxArr[i]];
      });
    }

    var max = Math.max(vMinArr.length, vMaxArr.length);
    return Array(max).map(function (_, i) {
      return [vMinArr[i % vMinArr.length], vMaxArr[i % vMaxArr.length]];
    });
  }

  function resolveOption(val, index) {
    if (!Array.isArray(val)) {
      return val;
    }

    return val[index % val.length];
  }

  function calcuateHalfSize(total, view, i) {
    var ratio = resolveOption(view.errorBarWhiskerRatio, i);

    if (total != null && ratio > 0) {
      return total * ratio * 0.5;
    }

    var size = resolveOption(view.errorBarWhiskerSize, i);
    return size * 0.5;
  }
  /**
   * @param {number} vMin
   * @param {number} vMax
   * @param {CanvasRenderingContext2D} ctx
   */


  function drawErrorBarVertical(view, vMin, vMax, ctx) {
    ctx.save();
    ctx.translate(view.x, 0);

    if (vMin == null) {
      vMin = view.y;
    }

    if (vMax == null) {
      vMax = view.y;
    }

    var bars = resolveMulti(vMin, vMax);
    bars.reverse().forEach(function (_ref, j) {
      var _ref2 = _slicedToArray(_ref, 2),
          mi = _ref2[0],
          ma = _ref2[1];

      var i = bars.length - j - 1;
      var halfWidth = calcuateHalfSize(view.width, view, i); // center line

      ctx.lineWidth = resolveOption(view.errorBarLineWidth, i);
      ctx.strokeStyle = resolveOption(view.errorBarColor, i);
      ctx.beginPath();
      ctx.moveTo(0, mi);
      ctx.lineTo(0, ma);
      ctx.stroke(); // whisker

      ctx.lineWidth = resolveOption(view.errorBarWhiskerLineWidth, i);
      ctx.strokeStyle = resolveOption(view.errorBarWhiskerColor, i);
      ctx.beginPath();
      ctx.moveTo(-halfWidth, mi);
      ctx.lineTo(halfWidth, mi);
      ctx.moveTo(-halfWidth, ma);
      ctx.lineTo(halfWidth, ma);
      ctx.stroke();
    });
    ctx.restore();
  }
  /**
   * @param {number} vMin
   * @param {number} vMax
   * @param {CanvasRenderingContext2D} ctx
   */


  function drawErrorBarHorizontal(view, vMin, vMax, ctx) {
    ctx.save();
    ctx.translate(0, view.y);

    if (vMin == null) {
      vMin = view.x;
    }

    if (vMax == null) {
      vMax = view.x;
    }

    var bars = resolveMulti(vMin, vMax);
    bars.reverse().forEach(function (_ref3, j) {
      var _ref4 = _slicedToArray(_ref3, 2),
          mi = _ref4[0],
          ma = _ref4[1];

      var i = bars.length - j - 1;
      var halfHeight = calcuateHalfSize(view.height, view, i); // center line

      ctx.lineWidth = resolveOption(view.errorBarLineWidth, i);
      ctx.strokeStyle = resolveOption(view.errorBarColor, i);
      ctx.beginPath();
      ctx.moveTo(mi, 0);
      ctx.lineTo(ma, 0);
      ctx.stroke(); // whisker

      ctx.lineWidth = resolveOption(view.errorBarWhiskerLineWidth, i);
      ctx.strokeStyle = resolveOption(view.errorBarWhiskerColor, i);
      ctx.beginPath();
      ctx.moveTo(mi, -halfHeight);
      ctx.lineTo(mi, halfHeight);
      ctx.moveTo(ma, -halfHeight);
      ctx.lineTo(ma, halfHeight);
      ctx.stroke();
    });
    ctx.restore();
  }

  function renderErrorBar(view, ctx) {
    if (view.xMin != null || view.xMax != null) {
      drawErrorBarHorizontal(view, view.xMin, view.xMax, ctx);
    }

    if (view.yMin != null || view.yMax != null) {
      drawErrorBarVertical(view, view.yMin, view.yMax, ctx);
    }
  }
  /**
   * @param {number} vMin
   * @param {number} vMax
   * @param {CanvasRenderingContext2D} ctx
   */

  function drawErrorBarArc(view, vMin, vMax, ctx) {
    ctx.save();
    ctx.translate(view.x, view.y); // move to center

    if (vMin == null) {
      vMin = view.outerRadius;
    }

    if (vMax == null) {
      vMax = view.outerRadius;
    }

    var angle = (view.startAngle + view.endAngle) / 2;
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle); // perpendicular

    var v = {
      x: -sinAngle,
      y: cosAngle
    };
    var length = Math.sqrt(v.x * v.x + v.y * v.y);
    v.x /= length;
    v.y /= length;
    var bars = resolveMulti(vMin, vMax);
    bars.reverse().forEach(function (_ref5, j) {
      var _ref6 = _slicedToArray(_ref5, 2),
          mi = _ref6[0],
          ma = _ref6[1];

      var i = bars.length - j - 1;
      var minCos = mi * cosAngle;
      var minSin = mi * sinAngle;
      var maxCos = ma * cosAngle;
      var maxSin = ma * sinAngle;
      var halfHeight = calcuateHalfSize(null, view, i);
      var eX = v.x * halfHeight;
      var eY = v.y * halfHeight; // center line

      ctx.lineWidth = resolveOption(view.errorBarLineWidth, i);
      ctx.strokeStyle = resolveOption(view.errorBarColor, i);
      ctx.beginPath();
      ctx.moveTo(minCos, minSin);
      ctx.lineTo(maxCos, maxSin);
      ctx.stroke(); // whisker

      ctx.lineWidth = resolveOption(view.errorBarWhiskerLineWidth, i);
      ctx.strokeStyle = resolveOption(view.errorBarWhiskerColor, i);
      ctx.beginPath();
      ctx.moveTo(minCos + eX, minSin + eY);
      ctx.lineTo(minCos - eX, minSin - eY);
      ctx.moveTo(maxCos + eX, maxSin + eY);
      ctx.lineTo(maxCos - eX, maxSin - eY);
      ctx.stroke();
    });
    ctx.restore();
  }

  function renderErrorBarArc(view, ctx) {
    if (view.yMin != null || view.yMax != null) {
      drawErrorBarArc(view, view.yMin, view.yMax, ctx);
    }
  }

  Chart.defaults.global.elements.rectangleWithErrorBar = _objectSpread2({}, Chart.defaults.global.elements.rectangle, {}, defaults);
  var RectangleWithErrorBar = Chart.elements.RectangleWithErrorBar = Chart.elements.Rectangle.extend({
    transition: function transition(ease) {
      var startBak = transitionErrorBarHelper(this._start);
      var r = Chart.elements.Rectangle.prototype.transition.call(this, ease);
      var model = this._model;
      var start = this._start;
      var view = this._view; // No animation -> No Transition

      if (!model || ease === 1) {
        return r;
      }

      transitionErrorBar(start, startBak, view, model, ease);
      return r;
    },
    draw: function draw() {
      Chart.elements.Rectangle.prototype.draw.call(this);
      renderErrorBar(this._view, this._chart.ctx);
    }
  });

  Chart.defaults.global.elements.pointWithErrorBar = _objectSpread2({}, Chart.defaults.global.elements.point, {}, defaults);
  var PointWithErrorBar = Chart.elements.PointWithErrorBar = Chart.elements.Point.extend({
    transition: function transition(ease) {
      var startBak = transitionErrorBarHelper(this._start);
      var r = Chart.elements.Point.prototype.transition.call(this, ease);
      var model = this._model;
      var start = this._start;
      var view = this._view; // No animation -> No Transition

      if (!model || ease === 1) {
        return r;
      }

      transitionErrorBar(start, startBak, view, model, ease);
      return r;
    },
    draw: function draw() {
      Chart.elements.Point.prototype.draw.call(this);
      renderErrorBar(this._view, this._chart.ctx);
    }
  });

  Chart.defaults.global.elements.arcWithErrorBar = _objectSpread2({}, Chart.defaults.global.elements.arc, {}, defaults);
  var ArcWithErrorBar = Chart.elements.ArcWithErrorBar = Chart.elements.Arc.extend({
    transition: function transition(ease) {
      var startBak = transitionErrorBarHelper(this._start);
      var r = Chart.elements.Arc.prototype.transition.call(this, ease);
      var model = this._model;
      var start = this._start;
      var view = this._view; // No animation -> No Transition

      if (!model || ease === 1) {
        return r;
      }

      transitionErrorBar(start, startBak, view, model, ease);
      return r;
    },
    draw: function draw() {
      Chart.elements.Arc.prototype.draw.call(this);
      renderErrorBarArc(this._view, this._chart.ctx);
    }
  });

  function calculateScale(model, data, scale, horizontal, reset) {
    var keys = modelKeys(horizontal);
    var base = scale.getBasePixel();
    keys.forEach(function (key) {
      var v = data[key];

      if (Array.isArray(v)) {
        model[key] = v.map(function (d) {
          return reset ? base : scale.getPixelForValue(d);
        });
      } else if (typeof v === 'number') {
        model[key] = reset ? base : scale.getPixelForValue(v);
      }
    });
  }

  function calculateErrorBarValuesPixels(controller, model, index, reset) {
    var data = controller.getDataset().data[index];

    if (!data) {
      return;
    }

    var scale = controller._getValueScale();

    calculateScale(model, data, scale, scale.isHorizontal(), reset);
  }
  function calculateErrorBarValuesPixelsScatter(controller, model, index, reset) {
    var data = controller.getDataset().data[index];

    if (!data) {
      return;
    }

    var meta = controller.getMeta();
    calculateScale(model, data, controller.getScaleForId(meta.xAxisID), true, reset);
    calculateScale(model, data, controller.getScaleForId(meta.yAxisID), false, reset);
  }
  function calculateErrorBarValuesPixelsPolar(controller, arc, model, index, reset) {
    var data = controller.getDataset().data[index];

    if (!data) {
      return;
    }

    var chart = controller.chart;
    var scale = chart.scale;
    var animationOpts = chart.options.animation;

    var toAngle = function toAngle(v) {
      var valueRadius = scale.getDistanceFromCenterForValue(v);
      var resetRadius = animationOpts.animateScale ? 0 : valueRadius;
      return reset ? resetRadius : arc.hidden ? 0 : valueRadius;
    };

    modelKeys(false).forEach(function (key) {
      // y variant
      var v = data[key];

      if (Array.isArray(v)) {
        model[key] = v.map(toAngle);
      } else if (typeof v === 'number') {
        model[key] = toAngle(v);
      }
    });
  }

  function reverseOrder(v) {
    return Array.isArray(v) ? v.slice().reverse() : v;
  }

  function generateTooltip(horizontal) {
    var _this = this;

    var keys = modelKeys(horizontal);
    return function (item, data) {
      var base = Chart.defaults.global.tooltips.callbacks.label.call(_this, item, data);
      var v = data.datasets[item.datasetIndex].data[item.index];

      if (v == null || keys.every(function (k) {
        return v[k] == null;
      })) {
        return base;
      }

      return "".concat(base, " (").concat(reverseOrder(v[keys[0]]), " .. ").concat(v[keys[1]], ")");
    };
  }
  function generateTooltipScatter(item, data) {
    var v = data.datasets[item.datasetIndex].data[item.index];

    var subLabel = function subLabel(base, horizontal) {
      var keys = modelKeys(horizontal);

      if (v == null || keys.every(function (k) {
        return v[k] == null;
      })) {
        return base;
      }

      return "".concat(base, " [").concat(reverseOrder(v[keys[0]]), " .. ").concat(v[keys[1]], "]");
    };

    return "(".concat(subLabel(item.xLabel, true), ", ").concat(subLabel(item.yLabel, false), ")");
  }
  function generateTooltipPolar(item, data) {
    var base = Chart.defaults.polarArea.tooltips.callbacks.label.call(this, item, data);
    var v = data.datasets[item.datasetIndex].data[item.index];
    var keys = modelKeys(false);

    if (v == null || keys.every(function (k) {
      return v[k] == null;
    })) {
      return base;
    }

    return "".concat(base, " [").concat(reverseOrder(v[keys[0]]), " .. ").concat(v[keys[1]], "]");
  }

  var defaults$1 = {
    scales: {
      yAxes: [{
        type: 'linearWithErrorBars'
      }]
    },
    tooltips: {
      callbacks: {
        label: generateTooltip(false)
      }
    }
  };
  var horizontalDefaults = {
    scales: {
      xAxes: [{
        type: 'linearWithErrorBars'
      }]
    },
    tooltips: {
      callbacks: {
        label: generateTooltip(true)
      }
    }
  };
  Chart.defaults.barWithErrorBars = Chart.helpers.configMerge(Chart.defaults.bar, defaults$1);
  Chart.defaults.horizontalBarWithErrorBars = Chart.helpers.configMerge(Chart.defaults.horizontalBar, horizontalDefaults);

  if (Chart.defaults.global.datasets && Chart.defaults.global.datasets.bar) {
    Chart.defaults.global.datasets.barWithErrorBars = _objectSpread2({}, Chart.defaults.global.datasets.bar);
  }

  if (Chart.defaults.global.datasets && Chart.defaults.global.datasets.horizontalBar) {
    Chart.defaults.global.datasets.horizontalBarWithErrorBars = _objectSpread2({}, Chart.defaults.global.datasets.horizontalBar);
  }

  var barWithErrorBars = {
    dataElementType: Chart.elements.RectangleWithErrorBar,
    _elementOptions: function _elementOptions() {
      return this.chart.options.elements.rectangleWithErrorBar;
    },

    /**
     * @private
     */
    _updateElementGeometry: function _updateElementGeometry(elem, index, reset) {
      var _Chart$controllers$ba;

      updateErrorBarElement(this, elem, index);

      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      (_Chart$controllers$ba = Chart.controllers.bar.prototype._updateElementGeometry).call.apply(_Chart$controllers$ba, [this, elem, index, reset].concat(args));

      calculateErrorBarValuesPixels(this, elem._model, index, reset);
    }
  };
  /**
   * This class is based off controller.bar.js from the upstream Chart.js library
   */

  var BarWithErrorBars = Chart.controllers.barWithErrorBars = Chart.controllers.bar.extend(barWithErrorBars);
  var HorizontalBarWithErrorBars = Chart.controllers.horizontalBarWithErrorBars = Chart.controllers.horizontalBar.extend(barWithErrorBars);

  var defaults$2 = {
    scales: {
      yAxes: [{
        type: 'linearWithErrorBars'
      }]
    },
    tooltips: {
      callbacks: {
        label: generateTooltip(false)
      }
    }
  };
  Chart.defaults.lineWithErrorBars = Chart.helpers.configMerge(Chart.defaults.line, defaults$2);

  if (Chart.defaults.global.datasets && Chart.defaults.global.datasets.line) {
    Chart.defaults.global.datasets.lineWithErrorBars = _objectSpread2({}, Chart.defaults.global.datasets.line);
  }

  var lineWithErrorBars = {
    dataElementType: Chart.elements.PointWithErrorBar,
    _elementOptions: function _elementOptions() {
      return this.chart.options.elements.pointWithErrorBar;
    },
    updateElement: function updateElement(point, index, reset) {
      var _Chart$controllers$li;

      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      (_Chart$controllers$li = Chart.controllers.line.prototype.updateElement).call.apply(_Chart$controllers$li, [this, point, index, reset].concat(args));

      updateErrorBarElement(this, point, index);
      calculateErrorBarValuesPixelsScatter(this, point._model, index, reset);
    }
  };
  var LineWithErrorBars = Chart.controllers.lineWithErrorBars = Chart.controllers.line.extend(lineWithErrorBars);

  var defaults$3 = {
    scales: {
      xAxes: [{
        type: 'linearWithErrorBars'
      }],
      yAxes: [{
        type: 'linearWithErrorBars'
      }]
    },
    tooltips: {
      callbacks: {
        label: generateTooltipScatter
      }
    }
  };
  Chart.defaults.scatterWithErrorBars = Chart.helpers.configMerge(Chart.defaults.scatter, defaults$3);

  if (Chart.defaults.global.datasets && Chart.defaults.global.datasets.scatter) {
    Chart.defaults.global.datasets.scatterWithErrorBars = _objectSpread2({}, Chart.defaults.global.datasets.scatter);
  }

  var ScatterithErrorBars = Chart.controllers.scatterWithErrorBars = LineWithErrorBars;

  var defaults$4 = {
    scale: {
      type: 'radialLinearWithErrorBars'
    },
    tooltips: {
      callbacks: {
        label: generateTooltipPolar
      }
    }
  };
  Chart.defaults.polarAreaWithErrorBars = Chart.helpers.configMerge(Chart.defaults.polarArea, defaults$4);

  if (Chart.defaults.global.datasets && Chart.defaults.global.datasets.polarArea) {
    Chart.defaults.global.datasets.polarAreaWithErrorBars = _objectSpread2({}, Chart.defaults.global.datasets.polarArea);
  }

  var superClass = Chart.controllers.polarArea.prototype;
  var polarAreaWithErrorBars = {
    dataElementType: Chart.elements.ArcWithErrorBar,
    _elementOptions: function _elementOptions() {
      return this.chart.options.elements.arcWithErrorBar;
    },
    _getPatchedDataset: function _getPatchedDataset() {
      var dataset = superClass.getDataset.call(this);
      return _objectSpread2({}, dataset, {
        // inline d.v
        data: dataset.data.map(function (d) {
          return d != null && typeof d.y === 'number' ? d.y : d;
        })
      });
    },
    _withPatching: function _withPatching(f) {
      try {
        this.getDataset = this._getPatchedDataset.bind(this);
        return f();
      } finally {
        delete this.getDataset;
      }
    },
    updateElement: function updateElement(arc, index, reset) {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      this._withPatching(function () {
        var _superClass$updateEle;

        return (_superClass$updateEle = superClass.updateElement).call.apply(_superClass$updateEle, [_this, arc, index, reset].concat(args));
      });

      updateErrorBarElement(this, arc, index);
      calculateErrorBarValuesPixelsPolar(this, arc, arc._model, index, reset);
    },
    countVisibleElements: function countVisibleElements() {
      var _this2 = this;

      return this._withPatching(function () {
        return superClass.countVisibleElements.call(_this2);
      });
    },
    _computeAngle: function _computeAngle(index) {
      var _this3 = this;

      return this._withPatching(function () {
        return superClass._computeAngle.call(_this3, index);
      });
    }
  };
  var PolarAreaWithErrorBars = Chart.controllers.polarAreaWithErrorBars = Chart.controllers.polarArea.extend(polarAreaWithErrorBars);

  var linearWithErrorBarsOptions = Chart.helpers.merge({}, [Chart.scaleService.getScaleDefaults('linear')]);
  var LinearWithErrorBarsScale = Chart.scaleService.getScaleConstructor('linear').extend({
    determineDataLimits: function determineDataLimits() {
      commonDataLimits.call(this, this.isHorizontal()); // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

      this.handleTickRangeOptions();
    }
  });
  Chart.scaleService.registerScaleType('linearWithErrorBars', LinearWithErrorBarsScale, linearWithErrorBarsOptions);

  var logarithmicWithErrorBarsOptions = Chart.helpers.merge({}, [Chart.scaleService.getScaleDefaults('logarithmic')]);
  var LogarithmicWithErrorBarsScale = Chart.scaleService.getScaleConstructor('logarithmic').extend({
    determineDataLimits: function determineDataLimits() {
      var _this = this;

      // Add whitespace around bars. Axis shouldn't go exactly from min to max
      this.minNotZero = null;
      commonDataLimits.call(this, this.isHorizontal(), function (v, isHorizontal) {
        var value = isHorizontal ? v.xMin : v.yMin;

        if (typeof value === 'number' && value !== 0 && (_this.minNotZero === null || value < _this.minNotZero)) {
          _this.minNotZero = value;
        }
      }); // Common base implementation to handle ticks.min, ticks.max

      this.handleTickRangeOptions();
    }
  });
  Chart.scaleService.registerScaleType('logarithmicWithErrorBars', LogarithmicWithErrorBarsScale, logarithmicWithErrorBarsOptions);

  var radialLinearWithErrorBarsOptions = Chart.helpers.merge({}, [Chart.scaleService.getScaleDefaults('radialLinear')]);
  var RadialLinearWithErrorBarsScale = Chart.scaleService.getScaleConstructor('radialLinear').extend({
    determineDataLimits: function determineDataLimits() {
      commonDataLimits.call(this, false, null, true);
      this.handleTickRangeOptions();
    }
  });
  Chart.scaleService.registerScaleType('radialLinearWithErrorBars', RadialLinearWithErrorBarsScale, radialLinearWithErrorBarsOptions);

  exports.ArcWithErrorBar = ArcWithErrorBar;
  exports.BarWithErrorBars = BarWithErrorBars;
  exports.HorizontalBarWithErrorBars = HorizontalBarWithErrorBars;
  exports.LineWithErrorBars = LineWithErrorBars;
  exports.LinearWithErrorBarsScale = LinearWithErrorBarsScale;
  exports.LogarithmicWithErrorBarsScale = LogarithmicWithErrorBarsScale;
  exports.PointWithErrorBar = PointWithErrorBar;
  exports.PolarAreaWithErrorBars = PolarAreaWithErrorBars;
  exports.RadialLinearWithErrorBarsScale = RadialLinearWithErrorBarsScale;
  exports.RectangleWithErrorBar = RectangleWithErrorBar;
  exports.ScatterithErrorBars = ScatterithErrorBars;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
</script>
    <script type="text/javascript" charset="utf-8">/*!
 * chartjs-chart-matrix v0.1.3
 * https://github.com/kurkle/chartjs-chart-matrix#readme
 * (c) 2019 Jukka Kurkela
 * Released under the MIT license
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('chart.js')) :
typeof define === 'function' && define.amd ? define(['chart.js'], factory) :
(global = global || self, factory(global.Chart));
}(this, function (Chart) { 'use strict';

Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;

var resolve = Chart.helpers.options.resolve;

var Controller = Chart.DatasetController.extend({

	dataElementType: Chart.elements.Rectangle,

	update: function(reset) {
		var me = this;
		var meta = me.getMeta();
		var data = meta.data || [];
		var i, ilen;

		me._xScale = me.getScaleForId(meta.xAxisID);
		me._yScale = me.getScaleForId(meta.yAxisID);

		for (i = 0, ilen = data.length; i < ilen; ++i) {
			me.updateElement(data[i], i, reset);
		}
	},

	updateElement: function(item, index, reset) {
		var me = this;
		var dataset = me.getDataset();
		var datasetIndex = me.index;
		var value = dataset.data[index];
		var xScale = me._xScale;
		var yScale = me._yScale;
		var options = me._resolveElementOptions(item, index);
		var x = reset ? xScale.getBasePixel() : xScale.getPixelForValue(value, index, datasetIndex);
		var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(value, index, datasetIndex);
		var h = options.height;
		var w = options.width;
		var halfH = h / 2;
		var halfW = w / 2;

		item._xScale = xScale;
		item._yScale = yScale;
		item._options = options;
		item._datasetIndex = datasetIndex;
		item._index = index;

		item._model = {
			x: x+halfW,
			base: y - h,
			y: y,
			width: w,
			height: h,
			backgroundColor: options.backgroundColor,
			borderColor: options.borderColor,
			borderSkipped: options.borderSkipped,
			borderWidth: options.borderWidth
		};

		item.pivot();
	},

	draw: function() {
		var me = this;
		var data = me.getMeta().data || [];
		var i, ilen;

		for (i = 0, ilen = data.length; i < ilen; ++i) {
			data[i].draw();
		}
	},

	/**
	 * @private
	 */
	_resolveElementOptions: function(rectangle, index) {
		var me = this;
		var chart = me.chart;
		var datasets = chart.data.datasets;
		var dataset = datasets[me.index];
		var options = chart.options.elements.rectangle;
		var values = {};
		var i, ilen, key;

		// Scriptable options
		var context = {
			chart: chart,
			dataIndex: index,
			dataset: dataset,
			datasetIndex: me.index
		};

		var keys = [
			'backgroundColor',
			'borderColor',
			'borderSkipped',
			'borderWidth',
			'width',
			'height'
		];

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];
			values[key] = resolve([
				dataset[key],
				options[key]
			], context, index);
		}

		return values;
	}

});

Chart.controllers.matrix = Controller;
Chart.defaults.matrix = {
	hover: {
		mode: 'nearest',
		intersect: true
	},
	tooltips: {
		mode: 'nearest',
		intersect: true
	},
	scales: {
		xAxes: [{
			type: 'linear'
		}],
		yAxes: [{
			type: 'linear'
		}]
	},
	elements: {
		rectangle: {
			borderSkipped: false,
			width: 20,
			height: 20
		}
	}
};

}));
</script>
    <script type="text/javascript" charset="utf-8">/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license MIT license
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}

</script>
    <script type="text/javascript" charset="utf-8">/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v0.7.31
   Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
   MIT License *//*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://faisalman.github.io/ua-parser-js
   Source : https://github.com/faisalman/ua-parser-js */
/////////////////////////////////////////////////////////////////////////////////

function UAParserInit(window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.31',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major',
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded',
        UA_MAX_LENGTH = 275;

    var AMAZON  = 'Amazon',
        APPLE   = 'Apple',
        ASUS    = 'ASUS',
        BLACKBERRY = 'BlackBerry',
        BROWSER = 'Browser',
        CHROME  = 'Chrome',
        EDGE    = 'Edge',
        FIREFOX = 'Firefox',
        GOOGLE  = 'Google',
        HUAWEI  = 'Huawei',
        LG      = 'LG',
        MICROSOFT = 'Microsoft',
        MOTOROLA  = 'Motorola',
        OPERA   = 'Opera',
        SAMSUNG = 'Samsung',
        SONY    = 'Sony',
        XIAOMI  = 'Xiaomi',
        ZEBRA   = 'Zebra',
        FACEBOOK   = 'Facebook';

    ///////////
    // Helper
    //////////

    var extend = function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        enumerize = function (arr) {
            var enums = {};
            for (var i=0; i<arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
            }
            return enums;
        },
        has = function (str1, str2) {
            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        },
        lowerize = function (str) {
            return str.toLowerCase();
        },
        majorize = function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined;
        },
        trim = function (str, len) {
            if (typeof(str) === STR_TYPE) {
                str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
            }
    };

    ///////////////
    // Map helper
    //////////////

    var rgxMapper = function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length === 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length === 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length === 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        strMapper = function (str, map) {

            for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
    };

    ///////////////
    // String map
    //////////////

    // Safari < 3.0
    var oldSafariMap = {
            '1.0'   : '/8',
            '1.2'   : '/1',
            '1.3'   : '/3',
            '2.0'   : '/412',
            '2.0.2' : '/416',
            '2.0.3' : '/417',
            '2.0.4' : '/419',
            '?'     : '/'
        },
        windowsVersionMap = {
            'ME'        : '4.90',
            'NT 3.11'   : 'NT3.51',
            'NT 4.0'    : 'NT4.0',
            '2000'      : 'NT 5.0',
            'XP'        : ['NT 5.1', 'NT 5.2'],
            'Vista'     : 'NT 6.0',
            '7'         : 'NT 6.1',
            '8'         : 'NT 6.2',
            '8.1'       : 'NT 6.3',
            '10'        : ['NT 6.4', 'NT 10.0'],
            'RT'        : 'ARM'
    };

    //////////////
    // Regex map
    /////////////

    var regexes = {

        browser : [[

            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
            ], [VERSION, [NAME, 'Chrome']], [
            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       // Microsoft Edge
            ], [VERSION, [NAME, 'Edge']], [

            // Presto based
            /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
            ], [NAME, VERSION], [
            /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, OPERA+' Mini']], [
            /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
            ], [VERSION, [NAME, OPERA]], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,      // Lunascape/Maxthon/Netfront/Jasmine/Blazer
            // Trident based
            /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,               // Avant/IEMobile/SlimBrowser
            /(ba?idubrowser)[\/ ]?([\w\.]+)/i,                                  // Baidu Browser
            /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i,
                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
            /(weibo)__([\d\.]+)/i                                               // Weibo
            ], [NAME, VERSION], [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
            ], [VERSION, [NAME, 'UC'+BROWSER]], [
            /\bqbcore\/([\w\.]+)/i                                              // WeChat Desktop for Windows Built-in Browser
            ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [
            /micromessenger\/([\w\.]+)/i                                        // WeChat
            ], [VERSION, [NAME, 'WeChat']], [
            /konqueror\/([\w\.]+)/i                                             // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
            ], [VERSION, [NAME, 'IE']], [
            /yabrowser\/([\w\.]+)/i                                             // Yandex
            ], [VERSION, [NAME, 'Yandex']], [
            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [
            /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
            ], [VERSION, [NAME, FIREFOX+' Focus']], [
            /\bopt\/([\w\.]+)/i                                                 // Opera Touch
            ], [VERSION, [NAME, OPERA+' Touch']], [
            /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [
            /dolfin\/([\w\.]+)/i                                                // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [
            /coast\/([\w\.]+)/i                                                 // Opera Coast
            ], [VERSION, [NAME, OPERA+' Coast']], [
            /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [
            /fxios\/([-\w\.]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, FIREFOX]], [
            /\bqihu|(qi?ho?o?|360)browser/i                                     // 360
            ], [[NAME, '360 '+BROWSER]], [
            /(oculus|samsung|sailfish)browser\/([\w\.]+)/i
            ], [[NAME, /(.+)/, '$1 '+BROWSER], VERSION], [                      // Oculus/Samsung/Sailfish Browser
            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [
            /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
            /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i            // QQBrowser/Baidu App/2345 Browser
            ], [NAME, VERSION], [
            /(metasr)[\/ ]?([\w\.]+)/i,                                         // SouGouBrowser
            /(lbbrowser)/i                                                      // LieBao Browser
            ], [NAME], [

            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
            ], [[NAME, FACEBOOK], VERSION], [
            /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
            /(chromium|instagram)[\/ ]([-\w\.]+)/i                              // Chromium/Instagram
            ], [NAME, VERSION], [
            /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA']], [

            /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
            ], [VERSION, [NAME, CHROME+' Headless']], [

            / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
            ], [[NAME, CHROME+' WebView'], VERSION], [

            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
            ], [VERSION, [NAME, 'Android '+BROWSER]], [

            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /version\/([\w\.]+) .*mobile\/\w+ (safari)/i                        // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [
            /version\/([\w\.]+) .*(mobile ?safari|safari)/i                     // Safari & Safari Mobile
            ], [VERSION, NAME], [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
            ], [NAME, [VERSION, strMapper, oldSafariMap]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
            ], [VERSION, [NAME, FIREFOX+' Reality']], [
            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i                                              // Links
            ], [NAME, VERSION]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i                     // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [

            /\b(aarch64|arm(v?8e?l?|_?64))\b/i                                 // ARM64
            ], [[ARCHITECTURE, 'arm64']], [

            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i                                   // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [

            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i                            // PowerPC
            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, lowerize]]
        ],

        device : [[

            //////////////////////////
            // MOBILES & TABLETS
            // Ordered by popularity
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
            /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
            /samsung[- ]([-\w]+)/i,
            /sec-(sgh\w+)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

            // Apple
            /\((ip(?:hone|od)[\w ]*);/i                                         // iPod/iPhone
            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
            /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [

            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
            /(?:huawei|honor)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

            // Xiaomi
            /\b(poco[\w ]+)(?: bui|\))/i,                                       // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i                        // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [

            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

            // Realme
            /\b(rmx[12]\d{3})(?: bui|;|\))/i
            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [

            // Google
            /(pixel c)\b/i                                                      // Google Pixel C
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i                         // Google Pixel
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [

            // Sony
            /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi)( bui|\))/i,                                         // Kindle Fire without Silk
            /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i                                                    // BlackBerry 10
            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

            // HTC
            /(nexus 9)/i                                                        // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [

            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, MOBILE]], [

            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
            /(asus)-?(\w+)/i,                                                   // Asus
            /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,                                          // Lenovo
            /(jolla)/i,                                                         // Jolla
            /(oppo) ?([\w ]+) bui/i                                             // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /(archos) (gamepad2?)/i,                                            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(nook)[\w ]+build\/(\w+)/i,                                        // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,                                   // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,                                  // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,                                      // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,                                    // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i                                   // Vodafone
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(surface duo)/i                                                    // Surface Duo
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
            /(u304aa)/i                                                         // AT&T
            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
            /\bsie-(\w*)/i                                                      // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
            /\b(rct\w+) b/i                                                     // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
            /\b(venue[\d ]{2,7}) b/i                                            // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
            /\b(q(?:mv|ta)\w+) b/i                                              // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i                       // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
            /\b(tm\d{3}\w+) b/i
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
            /\b(k88) b/i                                                        // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
            /\b(nx\d{3}j) b/i                                                   // ZTE Nubia
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
            /\b(gen\d{3}) b.+49h/i                                              // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
            /\b(zur\d{3}) b/i                                                   // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
            /\b((zeki)?tb.*\b) b/i                                              // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i                                // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
            /\b(ns-?\w{0,9}) b/i                                                // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
            /\b((nxa|next)-?\w{0,9}) b/i                                        // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [
            /\b(lvtel\-)?(v1[12]) b/i                                           // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
            /\b(ph-1) /i                                                        // Essential PH-1
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [
            /\b(v(100md|700na|7011|917g).*\b) b/i                               // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
            /\b(trio[-\w\. ]+) b/i                                              // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
            /\btu_(1491) b/i                                                    // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
            /(shield[\w ]+) b/i                                                 // Nvidia Shield Tablets
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
            /(sprint) (\w+)/i                                                   // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i             // Zebra
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

            ///////////////////
            // CONSOLES
            ///////////////////

            /(ouya)/i,                                                          // Ouya
            /(nintendo) ([wids3utch]+)/i                                        // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
            /droid.+; (shield) bui/i                                            // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
            /(playstation [345portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [

            ///////////////////
            // SMARTTVS
            ///////////////////

            /smart-tv.+(samsung)/i                                              // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [
            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i        // LG SmartTV
            ], [[VENDOR, LG], [TYPE, SMARTTV]], [
            /(apple) ?tv/i                                                      // Apple TV
            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /droid.+aft(\w)( bui|\))/i                                          // Fire TV
            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [
            /(bravia[\w- ]+) bui/i                                              // Sony
            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i               // HbbTV devices
            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i                   // SmartTV from Unidentified Vendors
            ], [[TYPE, SMARTTV]], [

            ///////////////////
            // WEARABLES
            ///////////////////

            /((pebble))app/i                                                    // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
            /droid.+; (glass) \d/i                                              // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [
            /droid.+; (wt63?0{2,3})\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
            /(quest( 2)?)/i                                                     // Oculus Quest
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [

            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [

            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i           // Android Phones from Unidentified Vendors
            ], [MODEL, [TYPE, MOBILE]], [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors
            ], [MODEL, [TYPE, TABLET]], [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
            ], [[TYPE, TABLET]], [
            /(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i              // Unidentifiable Mobile
            ], [[TYPE, MOBILE]], [
            /(android[-\w\. ]{0,9});.+buil/i                                    // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, EDGE+'HTML']], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i                                       // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows
            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows) nt 6\.2; (arm)/i,                                        // Windows RT
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,            // Windows Phone
            /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [
            /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [

            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,              // iOS
            /cfnetwork\/.+darwin/i
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i                             // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86)/i                              // Android-x86
            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,                                      // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,                                     // Tizen/KaiOS
            /\((series40);/i                                                    // Series 40
            ], [NAME, VERSION], [
            /\(bb(10);/i                                                        // BlackBerry 10
            ], [VERSION, [NAME, BLACKBERRY]], [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i         // Symbian
            ], [VERSION, [NAME, 'Symbian']], [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ], [VERSION, [NAME, FIREFOX+' OS']], [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i                              // WebOS
            ], [VERSION, [NAME, 'webOS']], [

            // Google Chromecast
            /crkey\/([\d\.]+)/i                                                 // Google Chromecast
            ], [VERSION, [NAME, CHROME+'cast']], [
            /(cros) [\w]+ ([\w\.]+\w)/i                                         // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)

            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,                                           // Mint
            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,                                         // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,                                                // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i                                                    // Haiku
            ], [NAME, VERSION], [
            /(sunos) ?([\w\.\d]*)/i                                             // Solaris
            ], [[NAME, 'Solaris'], VERSION], [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,                                  // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX
            /(unix) ?([\w\.]*)/i                                                // UNIX
            ], [NAME, VERSION]
        ]
    };

    /////////////////
    // Constructor
    ////////////////

    var UAParser = function (ua, extensions) {

        if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
        }

        var _ua = ua || ((typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;

        this.getBrowser = function () {
            var _browser = {};
            _browser[NAME] = undefined;
            _browser[VERSION] = undefined;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser.major = majorize(_browser.version);
            return _browser;
        };
        this.getCPU = function () {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function () {
            var _device = {};
            _device[VENDOR] = undefined;
            _device[MODEL] = undefined;
            _device[TYPE] = undefined;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            return _device;
        };
        this.getEngine = function () {
            var _engine = {};
            _engine[NAME] = undefined;
            _engine[VERSION] = undefined;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function () {
            var _os = {};
            _os[NAME] = undefined;
            _os[VERSION] = undefined;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            return _os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return _ua;
        };
        this.setUA = function (ua) {
            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

    ///////////
    // Export
    //////////

    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (typeof(define) === FUNC_TYPE && define.amd) {
            define(function () {
                return UAParser;
            });
        } else if (typeof window !== UNDEF_TYPE) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

}
UAParserInit(typeof window === 'object' ? window : this);


</script>
    <script type="text/javascript" charset="utf-8">/**
 * Module exports.
 */
function InspectInit() {

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @license MIT (© Joyent)
 */
/* legacy: obj, showHidden, depth, colors*/

function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeNoColor(str, styleType) {
  return str;
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isUndefined(arg) {
  return arg === void 0;
}

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isNull(arg) {
  return arg === null;
}

function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwn(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  try {
    if (ctx.showHidden && Object.getOwnPropertyNames) {
      keys = Object.getOwnPropertyNames(value);
    }
  } catch (e) {
    // ignore
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (Array.isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = { value: void 0 };
  try {
    // ie6 › navigator.toString
    // throws Error: Object doesn't support this property or method
    desc.value = value[key];
  } catch (e) {
    // ignore
  }
  try {
    // ie10 › Object.getOwnPropertyDescriptor(window.location, 'hash')
    // throws TypeError: Object doesn't support this action
    if (Object.getOwnPropertyDescriptor) {
      desc = Object.getOwnPropertyDescriptor(value, key) || desc;
    }
  } catch (e) {
    // ignore
  }
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwn(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
return inspect
}

window.inspect =InspectInit();

</script>
    <script type="text/javascript" charset="utf-8">/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  OJ=exports.stringify;
  JO=exports.parse;
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));


</script>
    <script type="text/javascript" charset="utf-8">var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')
else console.log('HTTP Browser Module Ver. 1.1.3 initialized.');

Utils = {
  addCSS : function (styles) {
    var styleSheet = document.createElement("style")
    styleSheet.type = "text/css"
    styleSheet.innerText = styles
    document.head.appendChild(styleSheet)    
  },
  
  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  beep : function (duration,volume,frequency,type) {
    if (!Utils.audioCtx) Utils.audioCtx=new(window.AudioContext || window.webkitAudioContext)();
    
    var oscillator = Utils.audioCtx.createOscillator();
    var gainNode = Utils.audioCtx.createGain();
    duration=duration||10;
    volume=volume||100;
    frequency=frequency||1000;
    type=type||'sine';
    oscillator.connect(gainNode);
    gainNode.connect(Utils.audioCtx.destination);

    gainNode.gain.value = volume;
    oscillator.frequency.value = frequency;
    oscillator.type = type;


    oscillator.start();

    setTimeout(
      function() {
        oscillator.stop();
      },
      duration
    );
    
    oscillator.onended = function () {
        Utils.audioCtx.close();
        Utils.audioCtx=null;
    };
  },

  BrowserVersion :(function(){
      var ua= navigator.userAgent, tem, 
      M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
      }
      if(M[1]=== 'Chrome'){
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
      }
      M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
      if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
      return {name:M[0],version:M[1]};
    })(),

  /** Change CSS 
   *
   */
  changeCSS: function changeCSS(theClass,element,value) {
     var cssRules;

     for (var S = 0; S < document.styleSheets.length; S++) {
	   try {
	     document.styleSheets[S].insertRule(theClass+' { '+element+': '+value+'; }',
                                            document.styleSheets[S][cssRules].length);
	   } catch(err) {
	     try{
           document.styleSheets[S].addRule(theClass,element+': '+value+';');
	     } catch(err){
		     try{
			   if (document.styleSheets[S]['rules']) {
			     cssRules = 'rules';
			    } else if (document.styleSheets[S]['cssRules']) {
			     cssRules = 'cssRules';
			    } else {
			     //no rules found... browser unknown
			    }

			    for (var R = 0; R < document.styleSheets[S][cssRules].length; R++) {
			      if (document.styleSheets[S][cssRules][R].selectorText == theClass) {
				    if(document.styleSheets[S][cssRules][R].style[element]){
				      document.styleSheets[S][cssRules][R].style[element] = value;
				      break;
				    }
			      }
		        }
		     } catch (err){}
	     }
	   }
    }
  },
  
  copy : function (o) {
    // recursively copy objects
    var _o,p;
    if (Utils.isTypedArray(o)) return o.slice();
    else if (Utils.isArray(o)) {
      if (typeof o[0] != 'object') return o.slice();
      else return o.map(function (e) {
            if (typeof e == 'object') return Utils.copy(e);
              else return e;
            });
      
    } else if (Utils.isObject(o)) {
      if (o instanceof Date) return o;
      _o={};
      for(p in o) _o[p]=(typeof o[p]=='object'?Utils.copy(o[p]):o[p]);
      return _o;
    } 
    else if (Utils.isString(o)) 
      return o.slice();
    else return o;
  
  },

  deserialize : function (data) {
    return JSONfn.deserialize(data)
  },

  DataSize : {
    Int8:1,
    Uint8:1,
    Int16:2,
    Uint16:2,
    Int32:4,
    Uint32:4,
    Float32:4,
    Float64:4,
    Boolean:1,
    Number:8,  
  },
  
  empty : function (v) {
    if (v == undefined) return true;
    if (Utils.isString(v)) return v=='';
    if (Utils.isArray(v)) return v.length==0;
    if (Utils.isObject(v)) return Object.keys(v).length==0;
    return false    
  },
  
  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  eraseCookie:function eraseCookie(name) {   
      document.cookie = name+'=; Max-Age=-99999999;';  
  },



  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  getCookie:function getCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for(var i=0;i < ca.length;i++) {
          var c = ca[i];
          while (c.charAt(0)==' ') c = c.substring(1,c.length);
          if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
      }
      return Utils.sessionCache[name]; // fallback 
  },

  getCookieObject:function (name,def) {
      var nameEQ = name + "=";
      try {
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
          var c = ca[i];
          while (c.charAt(0)==' ') c = c.substring(1,c.length);
          if (c.indexOf(nameEQ) == 0) return JSONfn.parse(c.substring(nameEQ.length,c.length));
        }
        return def;
      } catch (e) {
      console.log(e)
        return def;
      }
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*[a-zA-Z0-9_]*\([^\)]+\))/)[1];
    }
  },
  
  inspect : inspect,
  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isArrayArrayArray: function isArrayArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]) &&
                Utils.isArray(o[0][0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isBufferArray : function (o) {
    return (typeof ArrayBuffer != 'undefined' && o instanceof ArrayBuffer) ||
           (typeof SharedArrayBuffer != 'undefined' && o instanceof SharedArrayBuffer) ||
           (typeof Buffer != 'undefined' && o instanceof Buffer)
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isMatrix: function isMatrix(o,noarray,notypedarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (!notypedarray && Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isMatrixTA: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return Math.MatrixTA && Math.MatrixTA.isMatrix(o)
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isBoolean (o) {
      return typeof o == "boolean"
  },
  isString: function isString(o) {
      return typeof o == "string"
  },
  isStruct: function isStruct(o) {
      return !Utils.isArray(o) && Utils.isObject(o)
  },
  isTypedArray: function isTypedArray(o) {
      return o && Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray,notypedarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (!notypedarray && Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },
  isVectorTA: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return Math.VectorTA && Math.VectorTA.isVector(o)
  },
  isVol3: function isVol3(o) {
    if (o==_ || o ==null) return false;
    else return Math.Vol3 && Math.Vol3.isVol(o)
  },

  // Toplevel entry for loading JS/JSON/JSOB/CSV files
  // If url is a function, native/wex file dialog is used;
  // otherwise the data is loaded directly, and if this fails
  // the native file dialog is used.
  load : function (url,mimetype,cb) {
    var text;
    if (typeof url == 'function') {
      cb = url;
      // use native or wex file dialog
      return Common.loadFile(function (text,file) {
        if (!mimetype && file.match(/\.json$/)) mimetype='JSON';
        if (!mimetype && file.match(/\.js/)) mimetype='JS';
        if (!mimetype && file.match(/\.csv/)) mimetype='CSV';
        switch (mimetype && mimetype.replace(/application\//,'')) {
          case 'JSON':
            cb (Utils.ofJSON(text))
            break;
        }
      });
    }
    function filedia(e,process) {
        popup.confirm({
          content : url+':<br>\n'+e+'<br>\n',
        },function (reply)  {            
            if (!reply.proceed) return;
            Common.loadFile(function (data) {
              if (!data) return;
              cb(process(data));
            },false)
        });      
    }
    if (typeof mimetype == 'function') cb=mimetype,mimetype=null;
    if (!mimetype && url.match(/\.json$/)) mimetype='JSON';
    if (!mimetype && url.match(/\.js/)) mimetype='JS';
    if (!mimetype && url.match(/\.csv/)) mimetype='CSV';
    switch (mimetype && mimetype.replace(/application\//,'')) {
      case 'JSON':
        if (cb) return Utils.loadFile(url,function (text,err) {
          if (!err) cb(Utils.ofJSON(text));
          else filedia(err,Utils.ofJSON);
        });
        else return Utils.ofJSON(Utils.loadFile(url));
      case 'JSOB':
        if (cb) return Utils.loadFile(url,function (text,err) {
          if (!err) cb(Utils.ofString(text));
          else filedia(err,Utils.ofString);
        });
        else return Utils.ofString(Utils.loadFile(url));
      case 'CSV':
        if (cb) return Utils.loadFile(url,function (text,err) {
          if (!err) cb(Utils.ofCSV(text));
          else filedia(err,Utils.ofCSV);
        });
        else {
          text =Utils.loadFile(url,null,true);
          if (typeof text != 'string') return text;
          else return Utils.ofCSV(text);
        }
      case 'JS': 
      default:
        return Utils.loadScript(url);
        break; 
    };

  },
  
  // loading js(plugin) via wex file API and compiling code using Function
  loadc : function(url) {
    function compile(code,context,data) {
      // contruct functional scope
      // console.log(code);
      var pars = Object.keys(context),
          args = pars.map(function (key) { return context[key] });
      pars.unshift('__dummy');
      if (data!==undefined) { pars.push('__data'); args.push(data) };
      pars.push(code);
      var foo = new (Function.prototype.bind.apply(Function,pars));
      return foo.apply(this,args);
    }
    console.log('loadc '+url);
    var URL=DB.dirname(document.URL.replace(/\?[^$]+/,''))
    Utils.read(URL+'/'+url,'text',function (a,b) {
      compile(a,{Utils:Utils});
    })
  },
  
  loadFile: function (url,cb) {
    var result,error,_cb=cb;
    if (!_cb) _cb=function (_result,_error) { result=_result; error=_error; }; 
    try {
      // print(url+params)
      var request = new XMLHttpRequest();
      request.open("GET",url, cb);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                _cb(allText);
            } else _cb(null,'GET from '+url+' failed (status)');
        }
      }
      request.onerror = function (err) {
        _cb(null,'GET from '+url+' failed (error)')
      }
      request.send(null);
    } catch (e) {
      _cb(null,e)
    }
    return error||result;
  },

  loadScript: function (filename) {
    var fileref = document.createElement('script');
    fileref.setAttribute("type", "text/javascript");
    fileref.setAttribute("src", filename);
    if (typeof fileref != "undefined")
        document.getElementsByTagName("head")[0].appendChild(fileref)
  },
 
  list : function (pat,callback) {
    var path = PATH.dirname(pat);
    if (path=='' && pat[0]=='/') path='/';
    var _pat  = PATH.basename(pat);
    if (_pat) _pat=_pat.replace(/\./g,'\\.').replace(/\*/g,'.+')+'$';
    else _pat='.+$';
    _pat=RegExp(_pat);
    var list = FS.list(path||'.');
    list.dirs=list.dirs.filter(function (entry) {
      return entry.name!='..' && _pat.test(entry.name);  // TBC
    });
    list.files=list.files.filter(function (entry) {
      return _pat.test(entry.name);  // TBC
    });
    list=list.dirs.concat(list.files).map(function (entry) { return entry.name });
    if (callback) list.forEach(callback);
    return list;
  },
 
  name: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^function[ ]*([a-zA-Z0-9_]*)\([^\)]+\)/)[1];
    }
  },

  ofCSV : function (source,sep,convert) {
    if (typeof sep == 'boolean') { convert=sep; sep=undefined };
    try {
      Papa.parse(source,{
        skipEmptyLines: true,
        dynamicTyping: true,
        complete: function(results) {
          data=results.data;
          if (convert) { // first line must be header
            header=data.shift();
            data=data.map(function (row) {
              var r={};
              header.forEach(function (col,i) { r[col]=row[i] });
              return r; 
            }) 
          }
        }
      });
      if (data && data[0].length==1) data=data.map(function (row) { return row[0] });
      return data;
    } catch (e) {
      return e;
    }
  },
  
  ofJSON : function (source) {
    return JSONfn.parse(source,{});
  },
  
  ofNUMPY : function (source,to) {
    var buf = source;
    var array = {
      magic : buf.toString('utf8',0,6),
      major : buf.readUInt8(6),
      minor : buf.readUInt8(7),
      headerLength : buf.readInt16LE(8),
    }
    var desc = buf.toString('utf8',10,10+array.headerLength);
    desc=desc.replace(/'shape'[ ]*:/,'shape:Tuple');
    with({
      False:false,
      Tuple:function () {
        return Array.from(arguments)
      }}) { eval('array.dict = '+desc) };
    array.dataspace=array.dict.shape;
    switch (array.dict.descr) {
      case '<i2':
        array.datatype='Int16';
        data=buf.slice(10+array.headerLength);
        array.data=new Int16Array(new Uint8Array(data).buffer);
        break;
     case '<i4':
        array.datatype='Int32';
        data=buf.slice(10+array.headerLength);
        array.data=new Int32Array(new Uint8Array(data).buffer);
        break;
     case '<f4':
        array.datatype='Float32';
        data=buf.slice(10+array.headerLength);
        array.data=new Float32Array(new Uint8Array(data).buffer);
        break;
     case '<f8':
        array.datatype='Float64';
        data=buf.slice(10+array.headerLength);
        array.data=new Float64Array(new Uint8Array(data).buffer);
        break;
    }
    switch (to) {
      case 'MatrixTA':
      default:
        if (Math.MatrixTA)
          return Math.MatrixTA({data:array.data,dataspace:array.dataspace,datatype:array.datatype});
        else
          return array;
        break;      
    }
    
  },
  /** Convert agent text sources to agent code in JSOB format
   *
   */
  ofString : function (source) {
    var code;
    try {
      // execute script in private context
      eval('code = '+source);
    } catch (e) { console.log(e,source); };
    return code; 
  },

  ofYAML: function (text) {
    return YAML.eval(text);
  },

  parseUrl : function (url) {
    if (!url) return {};
    url = url.replace(/#[^$]+$/,'');
    var queryString = url.substring( url.indexOf('?') + 1 );
    if (queryString == url) return {};
    var params = {}, queries, temp, i, l;

    // Split into key/value pairs
    queries = queryString.split("&");

    // Convert the array of strings into an object
    for ( i = 0, l = queries.length; i < l; i++ ) {
        temp = queries[i].split('=');
        if (temp[1]==undefined) temp[1]='true';
        params[temp[0]] = temp[1].replace('%20',' ');
    }

    return params;
  },

  protect : function (func,arguments,verbose) {
    try {
      return func.apply(this,arguments||[]);
    } catch (e) {
      if (verbose) console.log(e.stack || e.toString());
      return e;
    }
  },
  // read file from local filesystem via wex server
  // relative paths are relativ to current workdir
  read : async function (path,mimetype,cb) {
    path=path.replace(/^file:\/\//,'');
    if (!mimetype && path.match(/\.json$/)) mimetype='text';
    if (!mimetype && path.match(/\.js/)) mimetype='text';
    if (!mimetype && path.match(/\.csv/)) mimetype='text';
    if (!mimetype && path.match(/\.yaml/)) mimetype='text';
    if (!mimetype && path.match(/\.png|\.jpg/)) mimetype='binary';
    if (/image/.test(mimetype)) mimetype='binary';
    var dir,file;
    if (path[0]=='/') { dir=PATH.dirname(path);file=PATH.basename(path) }
    else { dir=Config.workdir; file=path };
    if (cb)
      FS.load(dir,file,mimetype, function (result) {
        var data;
        if (result && result.reply) data=result.reply;
        cb(data);
      })
    else return new Promise(function (resolve) {
      FS.load(dir,file,mimetype, function (result) {
        var data;
        if (result && result.reply) data=result.reply;
        resolve(data);
      })
    })
  },
  
  // iter an object path with patterns (wildcards, e.g., a*/key/*)
  resolve : function (o,path) {
    if (typeof path == 'string') {
      path=path.split('/');
      if (path[0]=='') path.shift();
    }
    var next = path.shift();
    if (!next) return o;
    if (typeof o == 'object') {
      if (/^[^\*]+$/.test(next)) {
        if (o[next]) return resolve(o[next],path);
      } else {
        var r = RegExp(next.replace(/\*/g,'.+'))
        var keys = Object.keys(o);
        var result =[];
        for(var i in keys) {
          if (r.test(keys[i])) result.push(resolve(o[keys[i]],path.slice()))
        }
        if (result.length==1) return result[0];
        else if (result.length>1) return result;
      }
    }
  },
  
  save : function (path,data,mimetype) {
    if (!mimetype && path.match(/\.json$/)) mimetype='JSON';
    if (!mimetype && path.match(/\.csv/)) mimetype='CSV';
    switch (mimetype && mimetype.replace(/application\//,'')) {
      case 'JSON':
        if (typeof data == 'object') data=JSONfn.stringify(data);
        break;
    }
    return Common.saveFile(data,path);
  },

  serialize : function (data) {
    return JSONfn.serialize(data)
  },

  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },


  /** Cookie Management
   *
   */
  sessionCache : {},

  setCookie:function setCookie(name,value,days) {
      var expires = "";
      if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days*24*60*60*1000));
          expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
      Utils.sessionCache[name]=value; // fallback if cookies are denied
  },

  setCookieObject:function (name,obj,days) {
      var expires = "";
      var value = JSONfn.stringify(obj);
      if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days*24*60*60*1000));
          expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
  },
  
  stamp : function (extended) {
      function datetimestamp()
      {
        var today = new Date();
        var sToday = (1900+today.getYear()).toString().padStart(2, '0');
        sToday += (today.getMonth()+1).toString().padStart(2, '0');
        sToday += today.getDate().toString().padStart(2, '0');
        sToday += '@';
        sToday += today.getHours().toString().padStart(2, '0');
        sToday += today.getMinutes().toString().padStart(2, '0');
        return sToday;
      }
      function timestamp()
      {
        var today = new Date();
        var sToday = (1900+today.getYear()).toString().padStart(2, '0');
        sToday += '/';
        sToday += (today.getMonth()+1).toString().padStart(2, '0');
        sToday += '/';
        sToday += today.getDate().toString().padStart(2, '0');
        sToday += '@';
        sToday += today.getHours().toString().padStart(2, '0');
        sToday += ':';
        sToday += today.getMinutes().toString().padStart(2, '0');
        sToday += ':';
        sToday += today.getSeconds().toString().padStart(2, '0');
        return sToday;
      }
      
      return extended?timestamp():datetimestamp()
  },
    
  stringToArrayBuffer : function (str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);

    for (var i=0, strLen=str.length; i<strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }

    return buf;
  },

  stringToUint8Array : function (str) {
    var bufView = new Uint8Array(str.length);

    for (var i=0, strLen=str.length; i<strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }

    return bufView;
  },
  
  time : function () { return Date.now() },
  
  // typeof @data = 'a[][] | {}[]
  toCSV : function (data,header,sep) {
    var result=[],quote='"',header0=header;
    if (!sep) sep=',';
    function wrap(v) {
      if (!quote) return v;
      if (typeof v==Number) return v;
      else return quote+String(v)+quote;
    }
    var d1 = typeof data[0] != 'object',    // vector, not matrix
        convert = !Utils.isArray(data[0]) && Utils.isObject(data[0]);
    if (!header0) {
      if (d1) header0=['0'];
      else if (!convert)
        header0=data[0].map(function (x,i) { return String(i) });
      else {
        header0=[];
        for (var p in data[0]) {
          header0.push(p);
        }
      }
    }
    if (header) result.push(header.join(sep));
    if (!d1) 
      for(i in data) {
        if (!convert)
          result.push(data[i].map(wrap).join(sep));
        else
          result.push(header0.map(function (col) { return data[i][col]}).map(wrap).join(sep));
      }
    else
      for(i in data) {
        result.push(wrap(data[i]));
      };
      
    return result.join('\n');
  },

  toJSON:  function (o) {
    // return self.jam.Aios.Code.minimize(
    return JSON.stringify(o)
  },

  /** Convert any object to text source in JSOB format
  *
  */
  toString : function (o) {
    var usebuffer=false;
    var p,i,keys,s='',sep,tokens;
    if (o===null) return 'null';
    else if (Utils.isArray(o)) {
      s='[';sep='';
      for(p in o) {
        s=s+sep+Utils.toString(o[p]);
        sep=',';
      }
      s+=']';
    } else if (o instanceof Buffer) {    
      s='Buffer([';sep='';
      for(i=0;i<o.length;i++) {
        s=s+sep+Utils.toString(o[i]);
        sep=',';
      }
      s+='])';  
    } else if (o instanceof Error) {    
      s='(new Error("'+o.toString()+'"))';
    } else if (Utils.isTypedArray(o)) {    
      s='(new '+Utils.TypedArrayToName(o)+'([';sep='';
      var b=Array.prototype.slice.call(o);
      for(i=0;i<b.length;i++) {
        s=s+sep+String(b[i]);
        sep=',';
      }
      s+=']))';  
    } else if (typeof o == 'object') {
      s='{';sep='';
      keys=Object.keys(o);
      for(i in keys) {
        p=keys[i];
        if (o[p]==undefined) continue;
        s=s+sep+"'"+p+"'"+':'+Utils.toString(o[p]);
        sep=',';
      }
      s+='}';
      if (o.__constructor__) s = '(function () { var o='+s+'; o.__proto__='+o.__constructor__+'.prototype; return o})()';
    } else if (typeof o == 'string')
      s="'"+
            o.toString().replace(/'/g,'\\\'')
                        .replace(/\n/g,'\\n')+
        "'"; 
    else if (typeof o == 'function') {
      s=o.toString(true);   // try minification (true) if supported by platform
      if (tokens=s.match(/function[ ]+([a-zA-Z0-9]+)[ ]*\(\)[ ]*{[^\[]*\[native code\][^}]*}/)) {
        return tokens[1];
      } else return s;
    } else if (o != undefined)
      s=o.toString();
    else s='undefined';
    return s;
  },


  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
        if (ftyp==Int8Array   || ftyp instanceof Int8Array) return 'Int8Array';
        if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return 'Uint8Array';
        if (ftyp==Int16Array  || ftyp instanceof Int16Array) return 'Int16Array';
        if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return 'Uint16Array';
        if (ftyp==Int32Array  || ftyp instanceof Int32Array) return 'Int32Array';
        if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return 'Uint32Array';
        if (ftyp==Float32Array || ftyp instanceof Float32Array) return 'Float32Array';
        if (ftyp==Float64Array || ftyp instanceof Float64Array) return 'Float64Array';
  },
  TypedArrayConstructor : function (ftyp) {
        if (ftyp==Int8Array   || ftyp instanceof Int8Array) return Int8Array;
        if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return Uint8Array;
        if (ftyp==Int16Array  || ftyp instanceof Int16Array) return Int16Array;
        if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return Uint16Array;
        if (ftyp==Int32Array  || ftyp instanceof Int32Array) return Int32Array;
        if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return Uint32Array;
        if (ftyp==Float32Array || ftyp instanceof Float32Array) return Float32Array;
        if (ftyp==Float64Array || ftyp instanceof Float64Array) return Float64Array;
  },

  title : function (text) {
    document.title = text;
  },

  uniqueID : function (length) {
    var s='',
        keys=['a','b','c','d','e','f','g','h','i','j','k','l','m','n',
              'o','p','q','r','s','t','u','v','w','x','y','z'];
    keys=keys.concat(keys,keys.map(function (k) { return k.toUpperCase() }));
    keys=keys.concat(['0','1','2','3','4','5','6','7','8','9']);
    if (typeof crypto == 'undefined') {
      for(var i=0;i<length;i++) {
        var b = (Math.random()*255)|0;
        s+= (keys[b%keys.length]);
      }
    } else {
      if (crypto.getRandomValues) { 
        var rav = new Uint8Array(length);
        crypto.getRandomValues(rav);
      }
      if (crypto.randomBytes) {
        var rav = crypto.randomBytes(length);
      } 
      for(var i=0;i<length;i++) {
        s+= (keys[rav[i]%keys.length]);
      };
    }
    return s;
  },
 
  UUIDv4 : function uuidv4() {
    if (typeof crpyto == 'undefined')
      rand=function () { return Math.floor(Math.random()*255) };
    else 
      rand=function () { return crypto.getRandomValues(new Uint8Array(1))[0] }; 
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ rand() & 15 >> c / 4).toString(16)
    );
  },
  
  write : async function (path,data,mimetype) {
    return new Promise(function (resolve) {
      FS.save(PATH.dirname(path),
              PATH.basename(path),
              data,
              mimetype,function (result) {
                resolve(result);
              });
    })
  },

  /** request
   *  typeof @options = { url:string, host: string, port:number, path:string, method:"GET"|"PUT", body?:string, headers:{} } 
   *  typeof @callback = function (err, xhr, body)
   */

  request : function (options, callback) {
    var DEFAULT_TIMEOUT = 2000;
    function is_crossDomain(url) {
      var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/


      // jQuery #8138, IE may throw an exception when accessing
      // a field from window.location if document.domain has been set
      var ajaxLocation
      try { ajaxLocation = location.href }
      catch (e) {
        // Use the href attribute of an A element since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
      }

      if (ajaxLocation.match('file:')) return true;

      var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
          , parts = rurl.exec(url.toLowerCase() )

      var result = !!(
        parts &&
        (  parts[1] != ajaxLocParts[1]
        || parts[2] != ajaxLocParts[2]
        || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
        )
      )

      //console.debug('is_crossDomain('+url+') -> ' + result)
      return result
    }

    try {
      var xhr = new XHR(),
          err,
          url = options.url || options.uri || ((options.proto?options.proto:'http')+'://'+options.host+':'+(options.port?options.port:80)+'/'+options.path),
          is_cors = is_crossDomain(url),
          supports_cors = ('withCredentials' in xhr)

      if(is_cors && !supports_cors) {
        err = new Error('Browser does not support cross-origin request: ' + options.uri)
        err.cors = 'unsupported'
        return callback(err, xhr)
      }
      options.headers = options.headers || {};
      options.timeout = options.timeout || DEFAULT_TIMEOUT;
      options.headers = options.headers || {};
      options.body    = options.body || null;

      if(is_cors) xhr.withCredentials = !! options.withCredentials;
      xhr.timeout = options.timeout;

      xhr.onopen = function () {
        for (var key in options.headers)
          xhr.setRequestHeader(key, options.headers[key])      
      }

      xhr.onload = function () {
       if(xhr.status === 0) {
          err = new Error('EREQUEST')
          callback(err, xhr)
       } 
       else callback(null,xhr,xhr.responseText)   
      }

      xhr.ontimeout = function () {
        // XMLHttpRequest timed out. Do something here.
        err = new Error('ETIMEOUT')
        err.duration = options.timeout
        callback(err,xhr, null)
      };

      xhr.onrror = function () {
        // XMLHttpRequest failed. Do something here.
        err = new Error('ESERVER')
        callback(err,xhr, null)
      };

      xhr.onreadystatechange = function () {
        if (xhr.readyState === XHR.DONE) {
          if(xhr.status === 0) {
            err = new Error('ENETWORK')
            callback(err, xhr)
          } 
        }
      };

      switch (options.method) {
        case 'GET':
        case 'get':
          xhr.open('GET', url, true /* async */);
          xhr.send()
          break;
        case 'PUT':
        case 'POST':
        case 'put':
        case 'post':
          xhr.open('POST', url, true /* async */);
          xhr.send(options.body)
          break;
      }
    } catch (e) { _log(options,e);console.log(['xhr error: ',options.host,options.path,e].join(' ')); }
  },
  
  GET: function (url,params,cb,sync) {
    var result;
    // if (sync && !cb) cb=function (_result) { result=_result }; 
    if (url.indexOf('http')!=0) url = 'http://'+url;
    try {
      if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
      } else params='';
      // print(url+params)
      var request = new XMLHttpRequest();
      request.open("GET",url+params, !sync);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                if (allText!='') result=JSONfn.parse(allText);
                else result = new Error('GET data error (empty data)');
                if (cb) cb(result);
            } else {
              result=new Error('GET from '+url+params+' failed (status '+request.status+')');
              if (cb) cb(result)
            }
        }
      }
      request.onerror = function (error) {
        if (result) return;
        result='Error: GET from '+url+params+' failed: '+error;
        if (cb) cb(result);
      }
      request.send(null);
    } catch (error) {
      result=new Error('GET from '+url+params+' failed: '+error.toString());
      if (cb) cb(result);      
    }
    return result;
  },
  
  POST: function (url,data,cb,sync){
    var result;
    // if (sync && !cb) cb=function (_result) { result=_result }; 
    if (url.indexOf('http')!=0) url = 'http://'+url;
    try {
      var request = new XMLHttpRequest();
      request.open("POST", url, !sync);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {   /*console.log(request);*/
                var allText = request.responseText;
                try {           
                  if (allText!='') result=JSONfn.parse(allText)
                  else result=new Error('POST data error (empty data)');
                } catch (e) {
                  result = new Error(e.toString());
                }
                if (cb) cb(result);
            } else {
                result = new Error('POST to '+url+' failed (status)');
                if (cb) cb(result);
            }
        }
      }
      request.onerror = function (error) {
        if (result) return;
        result = new Error('POST to '+url+' failed: '+error);
        if (cb) cb(result)
      }
      request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      request.send(JSONfn.stringify(data));
    } catch (error) {
      result=new Error('POST to '+url+' failed: '+error.toString());
      if (cb) cb(result)
    }
    return result;
  },


  version: '1.10.1'
}

Utils._init = function () {
  Object.addProperty = function (obj,name,fun) {
    if (obj.prototype[name]) return;
    obj.prototype[name]=fun;
    Object.defineProperty(obj.prototype, name, {enumerable: false});
  };

  Object.updateProperty = function (obj,name,fun) {
    obj.prototype[name]=fun;
    Object.defineProperty(obj.prototype, name, {enumerable: false});
  };

  // Array static methods extensions
  if (!Array.create) Array.create = function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    }
    
  if (!Array.matrix) Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
  // Array prototype extensions
  Object.addProperty(Array,'last',function () { return this[this.length-1] });

  // String static methods extensions
  if (!String.create) String.create = function(size,init) {
        var i, s='';
        init=init||' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
  };
  if (!String.copy) String.copy = function(src) {
        var i,dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
  }; 
  if (!String.get) String.get = function (str,index) {
        return str.charAt(index);
  }
  if (!String.hex) String.hex = function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
  }; 
  if (!String.set) String.set = function (str,index,char) {
    return str.substr(0, index) + char + str.substr(index+1)
  }
  // String prototype extensions
  Object.addProperty(String,'contains', function (el) {
    return this.includes(el)
  })
  
  Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
  });
  
  // Static Object extensions
  Object.fold = function (array) {
    // Fold an array [[a1,v1],[a2,v2],..] -> { a1:v1, a2:v2, ..}
    var o={}
    for(var i in array) o[array[i][0]]=array[i][1];
    return o; 
  }
  if (typeof assert == 'undefined') assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
  };
}

Utils._init();




</script>
    <script type="text/javascript" charset="utf-8">// A virtual JSON database file system
/* type entry = { kind:'object'|'table'|'db'|'fs'|'file'|'data'|'dir'|'matrix', 
                 data?:buffer|string,  url?:string,
                 name:string, mimetype?:string, meta?:{}, path?:string, }
   type mimetype = 
    'application/octet-stream' |
    'text/plain'
   ..

   SQL (entry='db')
      
   Hierarchical Structuring
   
   type HdFTable = Column {
    id: integer primary key,
    type: integer,
    mimetype: varchar(128),
    createTime: integer,
    lastModTime: integer,
    size: integer,
    name: varchar(512),
    parent: integer,
    meta: varchar (),
    data: blob
   } with Column.fsType = 0:directory,1:file,2:meta,3:table, (4:dataset,5:group)
     
   Meta Data for datasets (YAML format):
    dataspace :
       dimensions : [x,y,..]
    datatype : string | integer | int16 | ..
    attribute1 : ..
   
   type ProjTable = Column {
     id: varchar()|integer,
     type:integer is project or folder,    
     name: varchar(1000),
     description: varchar(1000),
     time: varchar()|integer,
     data: blob|varchar(1000000) is project or folder,
   } with Column.type = 0:directory,1:document
   
   type DocTable = Column {
     id: integer primary key,
     type:integer,
     mimetype: varchar(100),
     description: varchar(65000),
     template: varchar(65000),
     size:integer,
     time:integer,
     content:blob|varchar(1000000)
   } with Column.type = 0:directory,1:document,2:media

  
  Hierarchical DataSet Organisation
  --------------------------------- 
  
  meta data: { datatype:string,dataspace:number [], index?:number, chunk?:[] }
  type DataSetTable = Column {
     id         : integer primary key,
     type       : integer,  --  0:group, 1:direct data, 2:indirect, referenced indexed DataTable
     name       : varchar(),
     time       : integer,
     meta       : varchar(), -- YAML/JSON
     data       : blob|integer|varchar() -- DataTable name or serialized data
   }
   type DataTable = Columns {
     index      : integer primary key,
     type       : integer,  --  1:direct data, 2: indirect data, referenced indexed DataTable
     meta       : varchar(), -- optional, YAML/JSON, for chunks ?
     data       : blob,  
   }
   
  JSON API
  ========
  
  type table = {
    table : key string,
    meta?: {},
    rows : dataset|datagroup|data []
  }
  type dataset = {
    data : key string,
    meta : {},
    dataspace : number [] | [],
    datatype : datatype,
    data : []
  }
  type datagroup = {
    group : key string,
    meta? : {},
    rows : dataset | datagroup [],
  }
  
  type datatype = 'number' | 'float32' | 'float64' | 'int8' | 'int16' | 'int32' | ..
                  'json' | 'string' | 'object'
  type url = string with format "host:port" | "host:port:key1:key2:.." 
*/


DB = {
  // Multiple API views can exist for one physical SQL DB! (sql,sqlfs,sqlproj,sqldoc)
  addDB   : function (path,url,flags) {
    var db;
    var pel = path.split('/'),
        root=DB.store,
        entry;
    if (pel.length==1) entry=path;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[entry]) return new Error('EEXIST');
    if ((!url || url==':memory:') && SQL) {
      db = new SQL.Database();
      root.nodes[entry] = {
        kind  : 'db',
        db    : db,
        name  : entry,
        time  : DB.time(),
        id    : db.db,
        flags : flags||'',
        exec : {
          // TODO
          create: function () {},
          select: function () {},
        }
      }
    } else {
      var db
      if (!flags) db = DB.sql(url);
      else if (flags.indexOf('sqlproj')==0) db = DB.sqlproj(url);
      else if (flags.indexOf('sqlfs')==0)   db = DB.sqlfs(url);
      else if (flags.indexOf('sqldoc')==0)  db = DB.sqldoc(url);
      // Remote SQL DB
      root.nodes[entry] = {
        kind  : 'db',
        name  : entry,
        url   : url,
        time  : DB.time(),
        flags : flags||'',
        exec  : db,
      }
    }
    return root.nodes[entry];
  },
  
  // Add a dataset root table with sqlds API
  addDS : function (path,url,table) {
    var pel = path.split('/'),
        root=DB.store,
        node;
    if (pel.length==1) file=path;
    else {
      node=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[node]) return new Error('EEXIST');
    var db=DB.sqlds(url,table,{});
    // Remote SQL DB
    root.nodes[node] = {
        kind  : 'db',
        name  : node,
        url   : url,
        time  : DB.time(),
        flags : 'sqldataset',
        exec  : db,
      }
    return root.nodes[node];    
  },

  // add JSONfs API (local FS server)
  addFS : function (path,url,flags) {
    var pel = path.split('/'),
        root=DB.store,
        entry;
    if (pel.length==1) entry=path;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[entry]) return new Error('EEXIST');
    // Remote WEX Server
    root.nodes[entry] = {
        kind  : 'fs',
        name  : entry,
        url   : url,
        time  : DB.time(),
        flags : flags||'',
        exec  : DB.wex(url),
    }
    return root.nodes[entry];
  },
  
  addData : function (path,data,meta) {
    var pel = path.split('/'),
        root=DB.store,
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[file]) return new Error('EEXIST');
    root.nodes[file] = {
      kind : 'data',
      data : data,
      size : 0,
      time : DB.time(),
      merta : meta ||{},
      name : file,
    }
    return root.nodes[file];
  },
  
  addFile : function (path,data,mimetype) {
    var pel = path.split('/'),
        root=DB.store,
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[file]) return new Error('EEXIST');
    root.nodes[file] = {
      kind : 'file',
      data : data,
      size : data.length||0,
      time : DB.time(),
      mimetype : mimetype||(typeof data=='string'?'text/plain':'application/javascript'),
      name : file,
    }
    return root.nodes[file];
  },

  // pack generic number arrays into byte buffer (with support for array arrays)  
  array2buffer : function (array,typ,space) {
    var size=array.length,dsize=4;
    typ=typ||'uint32';
    if (!space && Utils.isArray(array[0])) {
      space=[size,array[0].length];
      if (Utils.isArray(array[0][0])) space.push(array[0][0].length);
    }
    if (space) size=space.reduce(function (a,b) { return a*b });
    if (!space) space=[size];
    switch (typ.toLowerCase()) {
        case 'number': dsize=8; break;
        case 'uint16': dsize=2; break;
        case 'uint32': dsize=4; break;
        case 'int16':  dsize=2; break;
        case 'int32':  dsize=4; break;
        case 'float32': dsize=4; break;
        case 'float64': dsize=8; break;
    }
    var b=Buffer(size*dsize);
    function set(v,off) {
      switch (typ.toLowerCase()) {
        case 'uint16':  b.writeUInt16LE(v,off); break;
        case 'uint32':  b.writeUInt32LE(v,off); break;
        case 'int16':   b.writeInt16LE(v,off); break;
        case 'int32':   b.writeInt32LE(v,off); break;
        case 'float32': b.writeFloatLE(v,off); break;
        case 'float64': 
        case 'number':
        default:
          b.writeDoubleLE(v,off); break;
      }    
    }
    var v,off=0;
    for(var i=0;i<array.length;i++) {
      switch (space.length) {
        case 1:
          v=array[i];
          set(v,off);
          off += dsize;
          break;
        case 2:
          for (var j=0;j<space[1];j++) {
            v=array[i][j];
            set(v,off);
            off += dsize;    
          }
          break;
        case 3:
          for (var j=0;j<space[1];j++) {
            for (var k=0;k<space[2];k++) {
              v=array[i][j][k];
              set(v,off);
              off += dsize;    
            }
          }
          break;
      }
    }
    return b;
  },
  
  // unpack generic number arrays from buffer (with support for array arrays)
  buffer2array : function (buffer,typ,space) {
    var dsize=4,bsize=(buffer.size||buffer.length),size,length,array=[];
    typ=typ||'uint32';
    if (buffer instanceof Array) return buffer;
    buffer=(buffer instanceof Uint8Array)?Buffer(buffer):buffer;
    if (typ=='number') dsize=8;
    else if (typ.indexOf('64')>0) dsize=8;
    else if (typ.indexOf('32')>0) dsize=4;
    else if (typ.indexOf('16')>0) dsize=2;
    else if (typ.indexOf('8')>0) dsize=1;
    typ=typ.toLowerCase();
    if (space)  size=space.reduce(function (a,b) { return a*b });
    if (!space) space=[bsize/dsize];
    if (size && (size*dsize)!=buffer.length) return new Error('EINVALID');

    function get(off) {
      switch (typ.toLowerCase()) {
        case 'uint8':   return buffer.readUInt8(off); break;
        case 'uint16':  return buffer.readUInt16LE(off); break;
        case 'uint32':  return buffer.readUInt32LE(off); break;
        case 'int8':    return buffer.readInt8(off); break;
        case 'int16':   return buffer.readInt16LE(off); break;
        case 'int32':   return buffer.readInt32LE(off); break;
        case 'float32': return buffer.readFloatLE(off); break;
        case 'float64': 
        case 'number':
        default:
          return buffer.readDoubleLE(off); break;
      }    
    }
    var v,off=0;
    for(var i=0;i<space[0];i++) {
      switch (space.length) {
        case 1:
          v=get(off);
          array[i]=v;
          off += dsize;
          break;
        case 2:
          array[i]=[];
          for (var j=0;j<space[1];j++) {
            v=get(off);
            array[i][j]=v;
            off += dsize; 
          }
          break;
        case 3:
          array[i]=[];
          for (var j=0;j<space[1];j++) {  
            array[i][j]=[];
            for (var k=0;k<space[2];k++) {
              v=get(off);
              array[i][j][k]=v;
              off += dsize;    
            }
          }
          break;
      }
    }

    return array;
  },

  basename : function (path,extension) {
    if (path[path.length-1]=='/') return '/';
    return extension?
            path.split('/').reverse()[0].replace(RegExp(extension.replace(/\./,'\\.')+'$'),'')
            :
            path.split('/').reverse()[0];
  },
  
  config : {
    // standard default ports
    ports : {
      sqldoc  : 5558, 
      sqlproj : 5550,
    }
  },
  
  delete : function (path,cb) {
    var pel = path.split('/'),
        root=DB.store, base='',
        entry;
    if (pel.length==1) return 0;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry] && root.nodes[entry].kind) {
      delete root.nodes[entry];
      return 1;
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (more.root.flags.contains('sqlproj')) {
            if (more.remains[0]=='projects') more.remains.shift();
            return more.root.exec.delete('/'+more.remains.concat([entry]).join('/'),cb);
          }
          if (more.root.flags.contains('sqldoc')) {
            return more.root.exec.delete('/'+more.remains.concat([entry]).join('/'),cb);
          }
          if (more.remains[0]=='tables') {
            result = root.exec.drop(entry);
            if (!result || result.error) return 0;
            else return 1;
          }
          break;
      }
    }
    return 0;
  },
  
  dirname : function (path) {
    var el=path.split('/');
    el.pop();
    return el.join('/');
  },
  
  error : function (result) {
    try {
      if (typeof result == 'number') return result>=0?false:new Error(result);
      if (!result) return new Error('EIO');
      if (result instanceof Error) return result;
      if (typeof XMLHttpRequestException != 'undefined' &&
          result instanceof XMLHttpRequestException) return new Error(result.message);
      if (typeof result == 'string' && result.indexOf('Error')!=-1) return new Error(result);
      if (result.error) return new Error(result.error);
      if (result.fs) result=result.fs;
      result=result[Object.keys(result)[0]];
      if (!result) return false;
      if (result.error) return new Error(result.error);
      else return false;
    } catch (e) {
      console.log(e,result);
      return e;
    }
  },
  
   
  fok : function (cb) {
    return function (result) { cb(DB.ok(result)) };
  },
  
  // Convert matrix to sql row [dataspace,datatype,layout,data]
  fromMatrix : function (mat,options) {
    options=options||{}
    if (Math.MatrixTA && mat instanceof Math.MatrixTA) {
      return Object.assign({
        dataspace:JSON.stringify(mat.dataspace),
        datatype:mat.datatype,
        layout:mat.layout,
        data:DB.toBuffer(mat)
      },options)
    }
  },
  // Convert matrix to sql row [dataspace,datatype,data]
  fromVector : function (vec,options) {
    options=options||{}
    if (Math.VectorTA && vec instanceof Math.VectorTA) {
      return Object.assign({
        dataspace:JSON.stringify(vec.dataspace),
        datatype:vec.datatype,
        layout:1,
        data:DB.toBuffer(vec)
      },options)
    }
  },
  
  init : function () {
    if (typeof SQL != 'undefined') {
      var db = new SQL.Database();
    }
  },
  
  list : function (path,root,cb) {
    var pel = path.split('/'),
        base='',head=path.charAt(0),
        result;
    root=root||DB.store;
    if (pel.length==2 && pel[0]=='' && pel[1]=='')
      return root.nodes;
    else {
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (pel.length==0 && root && root.nodes)
      return root.nodes;
    else if (root) {
      var more = { remains:pel, base:base, root:root };
      if (more.root.kind == 'db') {
        if (more.root.flags.contains('sqlproj')) {
          return more.root.exec.list('/'+more.remains.join('/'),cb);
        }
        if (more.root.flags.contains('sqldoc')) {
          return more.root.exec.list('/'+more.remains.join('/'),cb);
        }
      }
    }
    return new Error('ENOTFOUND');
  },
  
  // Resolve path and return entry descriptor
  // db:          { kind:'dir',name,time,nodes:[] } 
  // sql/tables:  { tables : [], url }  
  // sql:         { kind:'db', name, time, url, exec} 
  // fs:          { name,dir,size,time, nodes?:[] }
  // error:       null|error string
  lookup: function (path,root,cb) {
    var pel = path.split('/'),
        base='',head=path.charAt(0),
        entry, result;
    root=root||DB.store;
    if (pel.length==1) entry=pel[0];
    else if (pel.length==2 && pel[0]=='' && pel[1]=='')
      return root;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    
    if (pel.length==0 && root && root.nodes)
      return root.nodes[entry];
    else {
      pel.push(entry);
      var more = { remains:pel, base:base, root:root };
      if (more.root.kind == 'db') {
        switch (more.remains[0]) {
          case 'tables':
            if (!more.remains[1]) {
              var tables = more.root.exec.tables();
              return { tables : Utils.isArray(tables)?tables.map(function (name) {
                return {
                  name:name,
                  schema:more.root.exec.schema(name)
                }
              }):tables, url:more.root.url};
            } else if (more.remains.length==2) 
              return more.root.exec.select(more.remains[1],'*'); 
            break;
          case 'projects':
            return more.root.exec.select('ProjTable','*');
          case 'documents':
            return more;
          default:
            if (more.root.flags.contains('sqlproj')) {
              return more.root.exec.lookup('/'+more.remains.join('/'),cb);               
            }
            return more;
        }
      }  
      if (more.root.kind == 'fs' && more.root.exec) {
        if (cb) {
        
        } else {
          result = more.root.exec.lookup('/'+more.remains.join('/'));
          if (Utils.isObject(result) && result.dir) {
            result.nodes = more.root.exec.list('/'+more.remains.join('/'));
            if (result.nodes.files || result.nodes.dirs) 
              result.nodes=result.nodes.dirs.concat(result.nodes.files);
          }
        }
        return result;
      }
    }
    return new Error('ENOTFOUND');
  },
  
  mimeType: function (data) {
    if (typeof data == 'string')
      return data.replace(/[^\x20-\x7E\n\r\t\s]+/g, '').length==data.length?
              'text/plain':'application/octet-stream';
    else {
      for(var i=0;i<data.length;i++) {
        if ((data[i]<0x20 || data[i]>0x7e) && 
            data[i] != 0x0a && 
            data[i] != 0x0d && 
            data[i] != 0x09) return 'application/octet-stream'; 
      }
      return 'text/plain';
    }
  },
  
  
  mkdir : function (path,root,cb) {
    var pel = path.split('/'),
        root=root||DB.store,
        base='',
        entry;
    if (pel[0]=='') pel=pel.slice(1);
    while (pel.length) {
      base += ('/'+pel[0]);
      if (root && root.nodes[pel[0]] && root.nodes[pel[0]].kind != 'dir') {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
        break;
      } else if (!root.nodes[pel[0]]) root.nodes[pel[0]]={
        kind:'dir',
        time : Date(),
        nodes:{}
      }
      root=root.nodes[pel[0]];
      pel=pel.slice(1);
    }
    if (pel.length==0) return 1;
    
    if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc')) {
            return root.exec.mkdir('/'+more.remains.join('/'),null,cb);
          }
          break;
      }
      return 0;
    } else return 1;

  },
    
  ok : function (result) {
    if (!result) return new Error('ENOTFOUND');
    if (result instanceof Error) return result;
    if (typeof result=='string') return new Error(result);
    if (result.error) return new Error(result.error);
    if (result.fs) result=result.fs;
    result=result[Object.keys(result)[0]];
    if (!result) return new Error('EIO');
    if (result.error) return new Error(result.error);
    else if (result.result) return result.result;
    else return result;
  },
  
  // Read file or document
  // Returns: string|buffer|null 
  read : function (path,mimetype,cb) {
    var pel = path.split('/'),
        root=DB.store,base='',
        entry;
    if (pel.length==1) entry=pel[0];
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else
          break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry]) {
      return root.nodes[entry].data;
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc'))
            return root.exec.read('/'+more.remains.concat([entry]).join('/'),cb);
          if (pel[0]=='tables') {
            return root.exec.select(entry,'*',cb);
          }
          break;
        case 'fs':
          return root.exec.read('/'+more.remains.join('/'),entry,mimetype,cb);
          break;
      }
    }
    return null;
  },
  
  rename : function (path,name) {
    var entry=DB.basename(path),
        parent = DB.lookup(DB.dirname(path));
    if (parent && parent.nodes) {
      var node=parent.nodes[entry];
      if (node) {
        if (node.name) node.name=name;
        delete parent.nodes[entry];
        parent.nodes[name]=node;
        return node;
      }
    }
  },
  
  resolve : function (path) {
    var parts = path.split('/'),
        start = path.charAt(0),
        rparts = [];
    parts.forEach(function (part) {
      if (part=='.') return;
      if (part=='..' && rparts.length) return rparts.pop();
      else if (part=='..') return;
      rparts.push(part);
    });
    return rparts.length==1 && rparts[0]==''?start:rparts.join('/').replace(/\/\//g,'/');
  },
  
  save : function (path) {
    var pel = path.split('/'),
        root=DB.store,base='',
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (pel.length==0 && root && root.nodes) {
      var entry = root.nodes[file];
      if (!entry) return;
      if (entry.kind=='file')
        Common.saveFile(entry.data, entry.name, entry.mimetype);
      else if (entry.kind=='object')
        Common.saveFile(JSONfn.stringify(entry.data), entry.name, 'text/plain');
      else if (entry.kind=='db') {
        var tables = entry.exec.tables();
        var db = {
          tables : {}
        }
        for(var i in tables) {
          db.tables[tables[i]]={}
          db.tables[tables[i]].schema=entry.exec.schema(tables[i]);
          db.tables[tables[i]].rows=entry.exec.select(tables[i],'*');
        }
        Common.saveFile(JSONfn.stringify(db), entry.name, 'text/plain');        
      }
    } else {
    
    }
  },
  
  shortName: function (name,length,cache) {
    var chars = [],off=4;
    name=name.toUpperCase().replace(/\.[a-zA-Z0-9]+$/,'').replace(/[_,\.\~\- \/\°\$\%\!\&]/g,''); 
    if (name.length <= length) {
      chars=name.split('');
    } else {
      for(var i = 0; i < 4; i++)
        chars.push(name[i]);
      for(var i = 4; i < length; i++) {
        off += Math.max(1,((name.length-4)/(length-4))|0);
        chars.push(name[off]);      
      }
    }
    chars=chars.join('');
    var index=0;
    while (cache && cache[chars]) chars=chars.replace(/(..)$/,function (all,c) {
      var digits=index++;
      return String(Math.floor(digits/10))+String(digits%10);
    })
    if (cache) cache[chars]=1;
    return chars;;
  },
  
  store : {
    kind:'dir',
    name:'/',
    flags:'',
    time:Date(),
    nodes:{}
  },
    
  strict:false,
  
  time : function (format) {
    switch (format) {
      case 'milli':
      case 'ms':
        return Date.now();
      case 'YYYYMMDD':
        var today = new Date();
        return (today.getYear()+1900)+
               (today.getMonth()<9?'0'+(today.getMonth()+1):today.getMonth()+1)+
               (today.getDate()<10?'0'+today.getDate():today.getDate())
      case 'YYYYMMDD@HHMM':
        var today = new Date();
        return (today.getYear()+1900)+
               (today.getMonth()<9?'0'+(today.getMonth()+1):today.getMonth()+1)+
               (today.getDate()<10?'0'+(today.getDate()):today.getDate())+
               '@'+
               (today.getHours()<9?'0'+(today.getHours()+1):today.getHours()+1)+
               (today.getMinutes()<10?'0'+(today.getMinutes()):today.getMinutes())              
      default:
        return Date().toString();
    }
  },
  
  timeCompare : function (t1,t2) {
    if (isNaN(Number(t1))) t1=Date.parse(t1);
    if (isNaN(Number(t2))) t2=Date.parse(t2);
    t1=Number(t1); t2=Number(t2);
    return t1<t2?-1:(t1>t2?1:0);
  },
  
  toArray: function (buff,ftyp,dims,layout) {
    if (typeof ftyp=='string') {
      if (!/Array/.test(ftyp)) ftyp += 'Array';
      ftyp=Utils.TypedArrayOfName[ftyp];
      if (!ftyp) throw "DB.toArray: invalid ftyp argument"
    }
    var ta = DB.toTypedArray(buff,ftyp);
    if (!layout) layout=123;
    if (!ta) throw "DB.toArray: conversion of buffer to typedarray failed";
    if (!dims) dims=[ta.length];
    switch (dims.length) {
      case 1: return Array.prototype.slice.call(ta);
      case 2:
        var a=[];
        for(var i=0;i<dims[0];i++) {
          var row=[];
          for(var j=0;j<dims[1];j++) row[j]=ta[i*dims[1]+j];
          a.push(row);
        }
        return a;
    }
  },

  toBuffer : function (a,typ) {
    if (Utils.isBuffer(a)) return a;
    if (Utils.isArray(a)) {
      return DB.array2buffer(a,typ)
    }
    if (Utils.isTypedArray(a)) {
      return Buffer(a.buffer)
    }
    if (Utils.isMatrix(a,true)) {
      if (Utils.isTypedArray(a.data))
        return Buffer(a.data.buffer) // Matrix??
    }
    if (Utils.isVector(a,true)) {
      if (Utils.isTypedArray(a.data))
        return Buffer(a.data.buffer) // Matrix??
    }
  },
  
  // function toMatrix(buff:buffer,ftyp:function|datatype:string,dims:number[],layout)
  // function toMatrix(row:{rows:number,columns:number,datatype:string,data:buffer,layout?:number})
  toMatrix: function (buff,ftyp,dims,layout) {
    if (!Math.MatrixTA) return new Error('Math.MatrixTA not defined');
    if (typeof buff == 'object' && buff.rows && buff.columns && buff.datatype && buff.data) {
      // compact direct version
      var row=buff;   // returned from sqljson
      dims=[row.rows,row.columns];
      ftyp = Utils.TypedArrayOfName[row.datatype]||Utils.TypedArrayOfName[row.datatype+'Array'];
      var ta = DB.toTypedArray(row.data,ftyp);
      return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:row.layout});
    }
    if (!Utils.isArray(dims)) throw 'DB.toMatrix: invalid dimension array';
    if (typeof ftyp == 'string') {
      ftyp = Utils.TypedArrayOfName[ftyp]||Utils.TypedArrayOfName[ftyp+'Array'];
    }
    if (!Utils.isFunction(ftyp)) throw 'DB.toMatrix: invalid datatype or typedarray constructor';
    var ta = DB.toTypedArray(buff,ftyp);
    return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:layout});
  },
  
  toTypedArray: function (buff,ftyp) {
    var i,ta;
    if (buff.buffer instanceof ArrayBuffer) {
      switch (ftyp) {
        case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
        case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
        case Int8Array:    return new Int8Array((new Uint8Array(buff)).buffer);
        case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
        case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
        case Uint8Array:    return new Uint8Array((new Uint8Array(buff)).buffer);
        case Uint16Array:   return new Uint16Array((new Uint8Array(buff)).buffer);
        case Uint32Array:   return new Unt32Array((new Uint8Array(buff)).buffer);
      }
    } else if (typeof Uint8Array.from != 'undefined') {
      switch (ftyp) {
        case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
        case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
        case Int8Array:    return new Int8Array(Uint8Array.from(buff).buffer);
        case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
        case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
        case Uint8Array:   return new Uint8Array(Uint8Array.from(buff).buffer);
        case Uint16Array:   return new Uint16Array(Uint8Array.from(buff).buffer);
        case Uint32Array:   return new Uint32Array(Uint8Array.from(buff).buffer);
      }
    } else {
      // Fall-back conversion
      switch (ftyp) {
        case Float32Array: 
          ta=new Float32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readFloatLE(i*4);
          return ta;
        case Float64Array: 
          ta=new Float64Array(buff.length/8);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readDoubleLE(i*8);
          return ta;
        case Int8Array: 
          ta=new Int9Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt8(i*2);
          return ta;
        case Int16Array: 
          ta=new Int16Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt16LE(i*2);
          return ta;
        case Int32Array: 
          ta=new Int32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt32LE(i*4);
          return ta;
        case Uint8Array: 
          ta=new Uint9Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt8(i*2);
          return ta;
        case Uint16Array: 
          ta=new Uint16Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt16LE(i*2);
          return ta;
        case Uint32Array: 
          ta=new Uint32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt32LE(i*4);
          return ta;
      }
    }
  },
  
  toVector: function (buff,ftyp,dims,layout) {
    if (!Math.MatrixTA) return new Error('Math.VectorTA not defined');
    if (typeof buff == 'object' && buff.rows && buff.columns && buff.datatype && buff.data) {
      // compact direct version
      var row=buff;   // returned from sqljson
      dims=[row.rows,row.columns];
      ftyp = Utils.TypedArrayOfName[row.datatype]||Utils.TypedArrayOfName[row.datatype+'Array'];
      var ta = DB.toTypedArray(row.data,ftyp);
      return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:row.layout});
    }
    if (!Utils.isArray(dims)) throw 'DB.toVector: invalid dimension array';
    if (typeof ftyp == 'string') {
      ftyp = Utils.TypedArrayOfName[ftyp]||Utils.TypedArrayOfName[ftyp+'Array'];
    }
    if (!Utils.isFunction(ftyp)) throw 'DB.toVector: invalid datatype or typedarray constructor';
    var ta = DB.toTypedArray(buff,ftyp);
    return Math.VectorTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:layout});
  },
  
  toSQL: function (obj,schema) {
    var row={},meta= {},keys=Object.keys(obj),datatype,dataspace;

    for(var i in keys) {
      var key=keys[i],attr=obj[key];
      if (key=='meta') { meta.meta=attr; continue }
      if (Utils.isArray(attr) && Utils.isNumber(attr[0])) {
        datatype='Float32';
        dataspace=[attr.length]
        meta[key]={datatype:datatype,dataspace:dataspace,object:'array'}
        row[key]=DB.toBuffer(obj[key],datatype);
        continue;
      }
      if (Utils.isArray(attr) && Utils.isArray(attr[0]) && Utils.isNumber(attr[0][0])) {
        if (schema) {}
        datatype='Float32';
        dataspace=[attr.length,attr[0].length]
        meta[key]={datatype:datatype,dataspace:dataspace,object:'array'}
        row[key]=DB.toBuffer(obj[key],datatype);
        continue;
      }
    }
    row.meta=JSON.stringify(meta);
    return row;
  },
  
  // Try to convert SQL row to JS object using meta table or extended schema
  // schema|row.meta : { $col : { datatype:'float32'|'string'.., dataspace?:number [], target:'array'|'typedarray'|'matrixta'|..
  toJS: function (row,schema) {
    try {
      var meta,obj={},keys=Object.keys(row);
      if (typeof row.meta == 'string') row.meta=JSON.parse(row.meta);
      meta=row.meta;
      if (!row.meta) return row;
      for(var i in keys) {
        var key=keys[i];
        if (key=='meta') continue;
        if (row[key] instanceof Buffer && meta[key]) {
          switch (meta[key].object.toLowerCase()) {
            case 'array':
              if (meta[key].datatype && meta[key].dataspace)
                row[key]=DB.toArray(row[key],meta[key].datatype,meta[key].dataspace);
              break;
          }
        }
        if (typeof row[key] == 'string' && meta[key] && meta[key].object=='object') 
          row[key]=JSON.parse(row[key]);
           
      }
      if (row.meta.meta) row.meta=row.meta.meta;
      return row;
    } catch (e) { return e }
  },
  // Create tree representation of store
  tree : function (root,options) {
    var top={},nodes,root=root||DB.store;

    function add(node,entry) {
      if (node.kind=='dir') {
        var nodes={}
        Object.keys(node.nodes).forEach(function (name) {
              //nodes[name]=DB.tree(root.nodes[entry].nodes[name]);
          // return nodes on opening/construction of sub-tree
          nodes[name]={ _constructor:function () { 
            var _nodes=DB.tree(node.nodes[name]);
            return _nodes;
          }}
        });
        return nodes;
      }
      if (node.kind=='db') { 
        var entry={
          name:node.name,
          kind:node.kind,
          time:node.time,
        }
        if (node.exec && node.exec.tables) {
          // tables = root.nodes[entry].exec.tables();
          entry.tables={ _constructor:function () { 
            try {
              var o={},tables;
              tables = node.exec.tables();
              if (Utils.isArray(tables)) {
                  var coll = node.exec.schema(tables)
                  tables.forEach(function (name,index) {
                    var columns='?',result = coll && coll[index];
                    if (result && result.length) {
                      columns={};
                      result.forEach(function (col) {
                        var tokens = col.split(' ');
                        columns[tokens[0]]=tokens.slice(1).join(' ');
                      })
                    }
                    var rows=node.exec.count?node.exec.count(name):[];
                    o[name]= {
                      name:name,
                      kind:'table',
                      columns:columns,
                      rows:!DB.error(rows)?rows[0]:-1,
                    }
                  });
                }
                return o;
              } catch (e) {console.log(e); return o}
          }} 
        }
        // console.log(node)
        if (node.flags && node.flags.contains('sqlproj')) {
          entry.projects= { _constructor:function () { 
            var o={};
            var rows = node.exec.list('/');
            if (Utils.isArray(rows)) {
              rows.forEach(function (row,index) {
                o[row.name]= { }
              });
            }
            return o;
          }}
        }
        if (node.size != undefined)      entry.size     = node.size;
        if (node.id != undefined)        entry.id       = node.id;
        if (node.mimetype != undefined)  entry.mimetype = node.mimetype;
        if (node.url != undefined)       entry.url      = node.url;
        if (node.async != undefined)     entry.async    = node.async;
        return entry;
      }
      return {
          name:entry,
          kind:node.kind,
          time:node.time,
      }
    }
    if (root.nodes) Object.keys(root.nodes).forEach(function(entry) {
      top[entry]=add(root.nodes[entry],entry);
    }); else top=add(root);
    return top;
  },
  
  types : [
    'application/octet-stream',
    'application/javascript',
    'text/plain',  
  ],
  // return unique identifier
  unique : function (length) {
    length=length||8;
    return Math.random().toString(36).substr(2, 2+length);
  },
  wex : function (url,async) {
    return {
      lookup : function (path,cb) {
        Utils.POST('localhost:11111',{
          cmd:  'lookup',
          path:  path,
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          if (cb) cb(res.reply);
          else result=res.reply;
        },!async)
        return result;
      },
      list : function (dir,cb) {
        var result;
        Utils.POST('localhost:11111',{
          cmd:  'list',
          dir:  dir,
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          var dirs=res.reply.filter(function (entry) { return entry.dir })
                            .sort(function (a,b) { return a.name<b.name?-1:1 }),
              files=res.reply.filter(function (entry) { return !entry.dir })
                             .sort(function (a,b) { return a.name<b.name?-1:1 });
          if (cb) cb({files:files,dirs:dirs});
          else result={files:files,dirs:dirs};
        },!async);
        return result;
      },
      read:  function (dir,entry,mimetype,cb) {
        Utils.POST('localhost:11111',{
          cmd:  'load',
          dir:  dir,
          file: entry,
          mimetype:mimetype||'text',
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          if (cb) cb(res.reply);
          else result=res.reply;
        },!async)
        return result;      
      },
      url:url,
    }
  },
  
  write : function (path,data,cb) {
    var pel = path.split('/'),
        root=DB.store,base='',
        entry;
    if (pel.length==1) entry=pel[0];
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else
          break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry]) {
      root.nodes[entry].data=data;
      return data.length
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc'))
            return root.exec.write('/'+more.remains.concat([entry]).join('/'),data,cb);
          break;
      }
    }
    return -1;
  },
  
  version : '1.8.1',
}


</script>
    <script type="text/javascript" charset="utf-8">// Operational DB (SQLJSON) rights  
DB.Rights = {
  READ : 1,
  MODIFY : 2,
  CREATE : 4,
  DELETE : 8,
  TABLE  : 16,
  DATABASE : 32
}
  // SQL operations API (generic)
DB.sql  = function (url,options) { 
    var cap = options && options.capability; 
    function S(req) { if (cap) req.capability=cap; return req };
    return {
    attach : function (name,dir,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name:name,
        }},
      }), cb?DB.fok(cb):null,cb!=undefined))    
    },
    // copy an entire table from this DB to another (dst: sqljson API)
    // Hierarchical tables (e.g., sqlds) must be copied by the respective API (e.g, sqlds.copy)
    copy : function (name,dst,options,cb) {
      options=options||{};
      if (!Utils.isObject(dst)) return new Error('EINVALID');
      if (!cb) {
        var result,stat,first=1,last;
        var schema = this.schema(name);
        if (stat=DB.error(schema)) return stat;
        if (options.overwrite) {
          result = dst.drop(name);
          stat=DB.error(result);
          if (stat) return stat;
        }
        result = dst.create(name,schema);
        stat=DB.error(result);
        if (stat) return stat;
        var rows = this.count(name);
        if (DB.error(rows)) return DB.error(rows);
        rows=DB.ok(rows);
        if (options && options.rows) {
          first=options.rows[0];
          last=options.rows[1];
        } else last=rows;
        for (var i=first;i<=last;i++) {
          var data = this.select(name,'*','rowid="'+i+'"');
          if (DB.error(data)) return DB.error(data);
          if (!data.length) return Error("EEMPTY");
          result=dst.insert(name,DB.ok(data));
          stat=DB.error(result);
          if (options.progress) options.progress(i,first,last,DB.ok(result));
          if (stat) return stat;
        }
        return (last-first+1);
      }
    },
    count : function (name,count,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        select: name,
        count:count||'*'
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // create a new table (or database: {database:name},dir,url,cb}
    create: function (name,columns,cb,aux) {
      if (typeof name == 'object' && name.table) name=name.table;
      else if (typeof name == 'object' && name.database) return this.createDB(name.database,columns,cb,aux);
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        create: { table: name },
        columns:columns
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // create a new database or open if existing
    // new: support of VFS on the fly
    // new: memory db: createDB(dbname+':memory:')
    createDB: function (name,dir,url,cb) {
      var vfs;
      if (typeof url == 'function') { cb=url; url=undefined };
      if (typeof dir == 'object') {
        vfs=dir;
        dir=null;
      }
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name+'.sql':name+'.sql',
          url   : url,
          vfs   : vfs,
        } },
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    databases: function (cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        databases: {}
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    delete: function (name,where,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        delete: name,
        where:where
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    do: function (cmd,cb) {
      // TODO
    },
    drop: function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        drop: name,
        forced : ifnotexists
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    dropDB: function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        drop: { database: name },
        forced : ifnotexists
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // parse an sql query, return reply
    eval : function (query,cb) {
      var tokens = query.split(' '); // TODO:!!!
      switch (tokens[0].toLowerCase()) {
        case 'databases': return this.databases(cb);
        case 'tables': return this.tables(cb);
      }
    },
    // returns { changes: number, lastInsertROWID: number, time: number }
    insert: function (name,values,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        insert: name,
        values:values
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    // open/select a database

    open: function (name,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        open: name,
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    select: function (name,columns,where,cb) {
      var expression;
      if (where && where[0]=='?') {
        expression=where.slice(1);
        where=undefined;
      }
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        select: name,
        columns:columns,
        where:where,
        expression:expression,
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    schema: function (name, cb) {
      var matched;
      var result = DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        schema:  name
      }), cb?DB.fok(function (result) { 
        if (Utils.isError(result)) return cb(result);
        if (typeof result == 'string')
          cb((matched=result.match(/\((.+)\)$/)) && matched[1].split(','))
        else if (Array.isArray(result))
          result.forEach(function (part) { cb((matched=part.match(/\((.+)\)$/)) && matched[1].split(',')) });
        else
          cb(result)}):null,cb!=undefined));
      if (Utils.isError(result)) return result;
      if (typeof result == 'string')
        return (matched=result.match(/\((.+)\)$/)) && matched[1].split(',')
      else if (Array.isArray(result))
        return result.map(function (part) { return (matched=part.match(/\((.+)\)$/)) && matched[1].split(',') });
    },
    tables: function (cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        tables: {}
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    update: function (name,values,where,cb) {
      return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,S({
        update: name,
        values:values,
        where:where,
      }), cb?DB.fok(cb):null,cb!=undefined))
    },
    sessionID: DB.unique(),
    url : url,
  }}
  
  // complete async/promise version
  // MUST BE USED in async functions only!
DB.sqlA  = function (url,options) { var cap = options && options.capability; var self = {
    attach : async function (name,dir,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          create: { database: {
            name  : name,
            path  : dir?dir+'/'+name:name,
          } },
        }, DB.fok(resolve),true))          
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name:name,
        } },
      }, DB.fok(cb),true))    
    },
    // copy an entire table from this DB to another (dst: sqljson API)
    // Hierarchical tables (e.g., sqlds) must be copied by the respective API (e.g, sqlds.copy)
    copy : async function (name,dst,options,cb) {
      options=options||{};
      if (!Utils.isObject(dst)) return new Error('EINVALID');
      if (!cb) {
        var result,stat,first=1,last;
        var schema = await this.schema(name);
        if (stat=DB.error(schema)) return stat;
        if (options.overwrite) {
          result = await dst.drop(name,true);
          stat=DB.error(result);
          if (stat) return stat;
        }
        result = await dst.create(name,schema);
        stat=DB.error(result);
        if (stat) return stat;
        var rows = await this.count(name);
        if (DB.error(rows)) return DB.error(rows);
        rows=DB.ok(rows);
        if (options && options.rows) {
          first=options.rows[0];
          last=options.rows[1];
        } else last=rows;
        for (var i=first;i<=last;i++) {
          var data  =  await this.select(name,'*','rowid="'+i+'"');
          if (DB.error(data)) return DB.error(data);
          if (!data.length)   return Error('EEMPTY');
          result    = await dst.insert(name,DB.ok(data));
          stat      = DB.error(result);
          if (options.progress) options.progress(i,first,last,DB.ok(result));
          if (stat) return stat;
        }
        return (last-first+1);
      }
    },
    count : async function (name,count,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          select  : name,
          count   : count||'*'
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        select: name,
        count:count||'*'
      }, DB.fok(cb),true))
    },
    // create a new table (or database: {database:name},dir,url,cb}
    create: function (name,columns,cb,aux) {
      if (typeof name == 'object' && name.table) name=name.table;
      else if (typeof name == 'object' && name.database) return this.createDB(name.database,columns,cb,aux);
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          create: { table: name },
          columns:columns
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        create: { table: name },
        columns:columns
      }, DB.fok(cb),true))
    },
    // create a new database or open if existing
    // new: support of VFS on the fly
    // new: memory db: createDB(dbname+':memory:')
    createDB: async function (name,dir,url,cb) {
      var vfs;
      if (typeof url == 'function') { cb=url; url=undefined };
      if (typeof dir == 'object') {
        vfs=dir;
        dir=undefined;
      }
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          create: { database: {
            name  : name,
            path  : dir?dir+'/'+name+'.sql':name+'.sql',
            url   : url,
            vfs   : vfs,
          } },
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        create: { database: {
          name  : name,
          path  : dir?dir+'/'+name+'.sql':name+'.sql',
          url   : url,
          vfs   : vfs,
        } },
      }, DB.fok(cb),true))
    },
    databases: async function (cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          databases: {}
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        databases: {}
      }, DB.fok(cb),true))
    },
    delete: async function (name,where,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          delete: name,
          where:where
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        delete: name,
        where:where
      }, DB.fok(cb),true))
    },
    do: function (cmd,cb) {
      // TODO
    },
    drop: async function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          drop: name,
          forced : ifnotexists
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        drop: name,
        forced : ifnotexists
      }, DB.fok(cb),true))
    },
    dropDB: async function (name,ifnotexists,cb) {
      if (typeof ifnotexists=='function') { cb=ifnotexists; ifnotexists=undefined };
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          drop: { database : name },
          forced : ifnotexists
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        drop: { database : name },
        forced : ifnotexists
      }, DB.fok(cb),true))
    },
    // parse an sql query, return reply
    eval : function (query,cb) {
      var tokens = query.split(' '); // TODO:!!!
      switch (tokens[0].toLowerCase()) {
        case 'databases': return this.databases(cb);
        case 'tables': return this.tables(cb);
      }
    },
    // returns { changes: number, lastInsertROWID: number, time: number }
    insert: async function (name,values,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          insert: name,
          values:values
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        insert: name,
        values:values
      }, DB.fok(cb),true))
    },
    // open/select a database
    open: async function (name,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          open : name,
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        open : name,
      }, DB.fok(cb),true))
    },
    select: async function (name,columns,where,cb) {
      var expression;
      if (where && where[0]=='?') {
        expression=where.slice(1);
        where=undefined;
      }
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          select: name,
          columns:columns,
          where:where,
          expression:expression,
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        select: name,
        columns:columns,
        where:where,
        expression:expression,
      }, DB.fok(cb),true))
    },
    schema: async function (name, cb) {
      var matched;
      function exec(cb) {
        var result = DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          schema:  name
        }, DB.fok(function (result) { 
          if (Utils.isError(result)) return cb(result);
          if (typeof result == 'string')
            cb((matched=result.match(/\((.+)\)$/)) && matched[1].split(','))
          else if (Array.isArray(result))
            result.forEach(function (part) { cb((matched=part.match(/\((.+)\)$/)) && matched[1].split(',')) });
          else
            cb(result)}),true));      
      }
      if (!cb) return new Promise(function (resolve,reject) {
        exec(resolve);
      });
      else return exec(cb);
    },
    tables: async function (cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          tables: {}
        }, DB.fok(resolve),true))
      }); 
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        tables: {}
      }, DB.fok(cb),true))
    },
    update: async function (name,values,where,cb) {
      if (!cb) return new Promise(function (resolve,reject) {
        DB.ok(DB.sqljson(self.url+'#'+self.sessionID,{
          update: name,
          values:values,
          where:where,
        }, DB.fok(resolve),true))
      });
      else return DB.ok(DB.sqljson(this.url+'#'+this.sessionID,{
        update: name,
        values:values,
        where:where,
      }, DB.fok(cb),true))
    },
    sessionID: DB.unique(),
    url : url,
  }; return self}
   

  
  // SQLjson RPC client request (with optional access key)
  // format url = ["proto://"] ("host:port" | "host:port:K1:K2:K3:..")  
DB.sqljson = function (url,request,callback,async) {
    var proto  = url.match(/^([a-zA-Z]+):\/\//),
        tokens = url.split(':'),
        sessionID = url.match(/#([^$]+)$/);
    if (proto) proto=proto[1];
    if (sessionID) {
      sessionID=sessionID[1];
      tokens[tokens.length-1]=tokens[tokens.length-1].replace(/#[^$]+$/,'');
      request.sessionID=sessionID;
      url=url.replace(/#[^$]+$/,'');
    }
    if (tokens.length>(2+(proto?1:0))) { 
      url = tokens.slice(0,2+(proto?1:0)).join(':'); 
      request.key= tokens.slice(2+(proto?1:0)).join(':'); 
    }
    // console.log('sqljson',url,request)
    if (!async && !callback) {
      return Utils.POST(url,request,null,true);
    } else if (callback) {
      return Utils.POST(url,request, function (res) {
        // console.log(res);
        callback(res);
      },!async);
    };
  }

</script>
    <script type="text/javascript" charset="utf-8">// TODO String/Array extensions from compat

Capability = {
  /**
   *
   * typeof @port_valse = number [] 
   * typeof return = string
   */
  Port : function (port_vals) {
      if (port_vals==undefined) port_vals=[0,0,0,0,0,0];
      var port='';
      for(var i = 0; i< Capability.PORT_SIZE;i++) {
          port=port+String.fromCharCode(port_vals[i]);
      }
      return port;

  },
  /**
   *
   * typeof @obj = number | undefined
   * typeof @rights = number | undefined
   * typeof @rand = port | undefined
   * typeof function = constructor
   */
  Private : function (obj,rights,rand) {
      if (obj==undefined) {
          // Create empty private field
        return {
            prv_obj : 0,
            prv_rights : 0,
            prv_rand : Capability.Port()
        }
      } else {
        return {
          prv_obj : obj,               // Integer
          prv_rights : rights,         // Integer
          prv_rand : rand              // Port=string
        }
      }
  },

  /**
   *
   * typeof @cap_port = port
   * typeof @cap_priv = privat
   * typeof function = @constructor
   */
  Capability : function(cap_port, cap_priv) {
      if (cap_port==undefined) {
          // Create empty capability
          return {
            cap_port : Capability.Port(),
            cap_priv : Capability.Private()
          }
      } else {
          return {
            cap_port : cap_port,      // Port=string
            cap_priv : cap_priv?cap_priv:Capability.Private()
          }
      }
  },
  cap_parse : function (str,offset) {
      var cap=Capability.Capability(),
          pos=0;
      if (offset!=undefined) pos=offset;
      var pp=Capability.port_parse(str,pos);
      if (pp==undefined) return undefined;
      cap.cap_port=pp.port;
      pos=pp.pos;
      pp=Capability.prv_parse(str,pos);
      if (pp==undefined) return undefined;
      cap.cap_priv=pp.priv;
      pos=pp.pos;
      return {cap:cap,pos:pos};
  },

  cap_of_string : function (str) { var pp = Capability.cap_parse(str,0); return pp?pp.cap:undefined },

  cap_to_string : function (cap) {
      var str='';
      if (cap==undefined) return 'undefined';
      if (cap.cap_port!=undefined) str='['+Capability.port_to_string(cap.cap_port)+']'; else str = '[]';
      if (cap.cap_priv!=undefined) str=str+'('+Capability.prv_to_string(cap.cap_priv)+')'; else str=str+'()';
      return str;
  },

  /*
   ** Utils to get and set single bytes of a port
   */
  get_portbyte : function (port,i) {
      return port.charCodeAt(i); // String.fromCharCode(String.get(port,i))
  },
  set_portbyte : function (port,i,byte) {
      return String.set(port, i, (String.fromCharCode(byte)));
  },

  /*
   ** Encryption function
   */
  one_way : function (port) {
      var key = Array.create(64,0);
      var block = Array.create(48,0);
      var pubport = String.create (Capability.PORT_SIZE,'\0');
      var i, j, k;

      /*
      ** We actually need 64 bit key.
      ** Throw some zeroes in at bits 6 and 7 mod 8
      ** The bits at 7 mod 8 etc are not used by the algorithm
      */
      j=0;
      for (i = 0; i< 64; i++) {
          if ((i & 7) > 5)
              key[i] = 0;
          else {
              if ((Capability.get_portbyte(port, (j >> 3)) & (1 << (j & 7))) != 0)
                  key[i] = 1;
              else
                  key[i] = 0;
              j++;
          }
      }

      Des48.des_OWsetkey(key);
      /*
      ** Now go encrypt constant 0
      */
      block=Des48.des_OWcrypt48(block);


      /*
      ** and put the bits in the destination port
      */
      var pb = 0;

      for (i = 0; i < Capability.PORT_SIZE;i++) {
          var pbyte = 0;
          for (j = 0; j < 8; j++) {
              pbyte = pbyte | (block[pb] << j);
              pb++;
          }
          pubport=Capability.set_portbyte(pubport, i, pbyte);
      }
      return pubport;
  },

  pad : function (str,size) {
      while (str.length < (size || 2)) {str = "0" + str;}
      return str;
  },

  port_cmp : function (port1,port2) {
    return port1==port2;
  },

  port_copy : function (port) {
      return String.copy(port);
  },

  // Expected format: XX:XX:XX:XX:XX
  port_of_string : function (str,compact) {
      var tokens=str.split(':'),i,port='';
      for (i=0;i<Capability.PORT_SIZE;i++) {
          var num='0x'+tokens[i];
          port=port+String.fromCharCode(parseInt(num,16));
      }
      return port;
  },

  port_of_name : function (str) {
    var portvals = [0,0,0,0,0,0];
    for (var i=0;i<str.length;i++) {
      var d = str.charCodeAt(i);
      portvals[i % Capability.PORT_SIZE] = (portvals[i % Capability.PORT_SIZE]+d) & 0xff;
    }
    var port=""
    for (i=0;i<Capability.PORT_SIZE;i++) {
      port += String.fromCharCode(portvals[i]);
    }
    return port;
  },
  
  port_parse : function (str,pos) {
      var port='';
      var len=str.length;
      if (pos==undefined) pos=0;
      if (len<(pos+17)) return undefined;
      if (str[pos]=='[') pos++;
      for(var i=0;i<6;i++) {
          var sv='0x'+str[pos]+str[pos+1];
          port=port+String.fromCharCode(parseInt(sv));
          pos=pos+2;
          if (str[pos]==':') pos++;
      }
      if (str[pos]==']') pos++;
      return {port:port,pos:pos};
  },

  port_to_string : function (port,compact) {
      var i,str='';
      if (port) {
          for (i = 0; i < Capability.PORT_SIZE; i++) {
              var num = port.charCodeAt(i); // String.fromCharCode(String.get(port, i));
              if (!compact && i > 0) str = str + ':';
              str = str + Capability.pad(num.toString(16).toUpperCase(), 2);
          }
      } else str='undefined';
      return str;
  },

  priv2pub_cache : [],
  
  prv2pub : function  (port) {
      var putport;
      if (Capability.priv2pub_cache[port] == undefined) {
          putport=Capability.one_way(port);
          Capability.priv2pub_cache[port] = putport;
      } else putport = Capability.priv2pub_cache[port];
      return putport;
  },

  prv_cmp : function (prv1,prv2) {
   return  (prv1==undefined&&prv2==undefined) ||
           (prv1.prv_obj==prv2.prv_obj &&
            prv1.prv_rights==prv2.prv_rights &&
            Capability.port_cmp(prv1.prv_rand,prv2.prv_rand))
  },

  /**
   ** Decode a private structure (check for a valid private field)
   *
   * typeof @prv =  privat
   * typeof @rand = port
   * returns boolean
   */
  prv_decode : function  (prv,rand) {
      if (prv.prv_rights == Capability.PRV_ALL_RIGHTS)
          return Capability.port_cmp(prv.prv_rand,rand);
      else {
          var tmp_port = Capability.port_copy(rand),
              pt0 = Capability.get_portbyte(tmp_port, 0),
              pr0 = prv.prv_rights;
          tmp_port = Capability.set_portbyte(tmp_port, 0, (pt0 ^ pr0));
          tmp_port = Capability.one_way(tmp_port);
          return Capability.port_cmp(prv.prv_rand, tmp_port)
      }
  },

  /*
   ** Encode a private part from the object number, the rights field
   ** and the random port.
   ** Returns the created private structure.
   */
  prv_encode : function (obj,rights,rand) {
      var tmp_port = Capability.port_copy(rand),
          r1 = rights,
          rmask = Capability.PRV_ALL_RIGHTS;

      if (rights == Capability.PRV_ALL_RIGHTS)
          return Capability.Private(obj,r1 & rmask,tmp_port);
      else {
          var pt0 = Capability.get_portbyte(tmp_port,0);
          tmp_port = Capability.set_portbyte(tmp_port,0,pt0 ^ r1);
          tmp_port = Capability.one_way(tmp_port);
          return Capability.Private(obj,r1 & rmask,tmp_port)
      }
  },

  prv_of_string : function (str) { var pp=Capability.prv_parse(str,0); return pp?pp.priv:undefined },

  /*
   ** Return the private object number form a private structure
   */
  prv_number : function (prv) {
      return prv.prv_obj;
  },

  // Expected format: obj(right)[port]
  prv_parse : function (str,offset) {
      var priv=Capability.Private();
      var sv;
      var len=str.length,pos=offset;
      if (str[pos]=='(') pos++;
      sv='';
      while(str[pos]!='(') {
          sv=sv+str[pos];
          pos++;
      }
      priv.prv_obj=parseInt(sv);
      sv='';
      if (str[pos]=='(') pos++;
      while(str[pos]!=')') {
          sv=sv+str[pos];
          pos++;
      }
      priv.prv_rights=parseInt('0x'+sv);
      if (str[pos]==')') pos++;
      var pp=Capability.port_parse(str,pos);
      if (pp==undefined) return undefined;
      priv.prv_rand=pp.port;
      pos=pp.pos;
      return {priv:priv,pos:pos};
  },


  prv_to_string : function (priv) {
      var str='';
      if (priv==undefined) return 'undefined';
      str=priv.prv_obj;
      str=str+'('+String.hex(priv.prv_rights,2).toUpperCase()+')[';
      str=str+Capability.port_to_string(priv.prv_rand)+']';
      return str;
  },

  /** Restrict a private field (rights&mask) of a capability.
   *
   * @param {privat} priv
   * @param {number} mask rights restriction mask
   * @param {port} random secret server random port
   */
  prv_restrict: function (priv,mask,random) {
      var pr = Capability.prv_encode(priv.prv_obj,
                          priv.prv_rights & mask,
                          random);
      return pr;
  },
  /*
   ** Return the private rights field.
   */
  prv_rights: function (prv) {
      return prv.prv_rights & Capability.PRV_ALL_RIGHTS;
  },
  /*
   ** Check the private rights field: 1. Validation, 2: Required rights.
   */
  prv_rights_check : function (prv,rand,required) {
    if (!Capability.prv_decode(prv,rand)) return false;
    return (prv.prv_rights & required)==required;
  },

  /*
   * Return a new random unique port.
   *
   * Warning: the quality of the random ports are strongly
   * related to JSVMs underlying random generator.
   *
   * typeof return = port
   */
  uniqport: function () {
      var port = String.create (Capability.PORT_SIZE,0);
      var i,values;

      do {
        values = Rnd.generate({number:true,length:Capability.PORT_SIZE});
        for (i = 0; i <= (Capability.PORT_SIZE - 1); i++) 
          port = String.set(port, i, (String.fromCharCode(values[i])));
        if (Capability.uniquePorts[port]) Capability.uniquePorts[port]++;
        else Capability.uniquePorts[port]=1;
      } while (Capability.uniquePorts[port]>1);
      return port;
  },

  PORT_SIZE : 6,
  PRIVSIZE : 24,
  CAP_SIZE : 16,
  PRV_ALL_RIGHTS : 0xff,

  priv2pub_cache : [],
  uniquePorts : {},

}


Capability.Port.equal = Capability.port_cmp
Capability.Port.toString = Capability.port_to_string
Capability.Port.ofString = Capability.port_of_string
Capability.Port.ofName = Capability.port_of_name
Capability.Port.prv2pub = Capability.prv2pub
Capability.Port.random = Capability.uniqport
Capability.Port.unique = Capability.uniqport
Capability.Private.decode = Capability.prv_decode
Capability.Private.encode = Capability.prv_encode
Capability.Private.equal = Capability.prv_cmp
Capability.Private.number = Capability.prv_number
Capability.Private.ofString = Capability.prv_of_string
Capability.Private.restrict = Capability.prv_restrict
Capability.Private.rights = Capability.prv_rights
Capability.Private.rights_check = Capability.prv_rights_check
Capability.Private.toString = Capability.prv_to_string
Capability.Capability.toString = Capability.cap_to_string
Capability.Capability.ofString = Capability.cap_of_string

Crypto = (function () {
  var globalScope;
  if ("undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope) globalScope=self;
  else if ("object" == typeof window) globalScope=window;
  else if ("object" == typeof global) globalScope=global;
  
  var crypto = globalScope.crypto || globalScope.msCrypto;

  if (!crypto && typeof require != 'undefined') try { crypto=globalScope.crypto=require('require') } catch (e) {};

  var twister;

  var MersenneTwister = function(seed) {
	  if (seed == undefined) {
          /**
          ** It is not sure that Math.random is seeded randomly
          ** Thus, a combination of current system time and Math.random 
          ** is used to seed and initialize this random generator
          */
		  seed = new Date().getTime();
          seed *= Math.random()*91713;
          seed |= 0;
	  }

	  /* Period parameters */
	  this.N = 624;
	  this.M = 397;
	  this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	  this.mt = new Array(this.N); /* the array for the state vector */
	  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	  if (seed.constructor == Array) {
		  this.init_by_array(seed, seed.length);
	  }
	  else {
		  this.init_seed(seed);
	  }
  }

  /* initializes mt[N] with a seed */
  /* origin name init_genrand */
  MersenneTwister.prototype.init_seed = function(s) {
	  this.mt[0] = s >>> 0;
	  for (this.mti=1; this.mti<this.N; this.mti++) {
		  var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		  this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		  + this.mti;
		  /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		  /* In the previous versions, MSBs of the seed affect   */
		  /* only MSBs of the array mt[].                        */
		  /* 2002/01/09 modified by Makoto Matsumoto             */
		  this.mt[this.mti] >>>= 0;
		  /* for >32 bit machines */
	  }
  }

  /* initialize by an array with array-length */
  /* init_key is the array for initializing keys */
  /* key_length is its length */
  /* slight change for C++, 2004/2/26 */
  MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	  var i, j, k;
	  this.init_seed(19650218);
	  i=1; j=0;
	  k = (this.N>key_length ? this.N : key_length);
	  for (; k; k--) {
		  var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
		  this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		  + init_key[j] + j; /* non linear */
		  this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		  i++; j++;
		  if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		  if (j>=key_length) j=0;
	  }
	  for (k=this.N-1; k; k--) {
		  var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		  this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		  - i; /* non linear */
		  this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		  i++;
		  if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	  }

	  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
  }

  /* generates a random number on [0,0xffffffff]-interval */
  /* origin name genrand_int32 */
  MersenneTwister.prototype.random_int = function() {
	  var y;
	  var mag01 = new Array(0x0, this.MATRIX_A);
	  /* mag01[x] = x * MATRIX_A  for x=0,1 */

	  if (this.mti >= this.N) { /* generate N words at one time */
		  var kk;

		  if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			  this.init_seed(5489);  /* a default initial seed is used */

		  for (kk=0;kk<this.N-this.M;kk++) {
			  y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			  this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		  }
		  for (;kk<this.N-1;kk++) {
			  y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			  this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		  }
		  y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		  this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		  this.mti = 0;
	  }

	  y = this.mt[this.mti++];

	  /* Tempering */
	  y ^= (y >>> 11);
	  y ^= (y << 7) & 0x9d2c5680;
	  y ^= (y << 15) & 0xefc60000;
	  y ^= (y >>> 18);

	  return y >>> 0;
  }

  /* generates a random number on [0,0x7fffffff]-interval */
  /* origin name genrand_int31 */
  MersenneTwister.prototype.random_int31 = function() {
	  return (this.random_int()>>>1);
  }

  /* generates a random number on [0,1]-real-interval */
  /* origin name genrand_real1 */
  MersenneTwister.prototype.random_incl = function() {
	  return this.random_int()*(1.0/4294967295.0);
	  /* divided by 2^32-1 */
  }

  /* generates a random number on [0,1)-real-interval */
  MersenneTwister.prototype.random = function() {
	  return this.random_int()*(1.0/4294967296.0);
	  /* divided by 2^32 */
  }

  /* generates a random number on (0,1)-real-interval */
  /* origin name genrand_real3 */
  MersenneTwister.prototype.random_excl = function() {
	  return (this.random_int() + 0.5)*(1.0/4294967296.0);
	  /* divided by 2^32 */
  }

  /* generates a random number on [0,1) with 53-bit resolution*/
  /* origin name genrand_res53 */
  MersenneTwister.prototype.random_long = function() {
	  var a=this.random_int()>>>5, b=this.random_int()>>>6;
	  return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  function polyfill () {
    twister = new MersenneTwister(); // (Math.random()*Number.MAX_SAFE_INTEGER)|0)
    if (!crypto) crypto=globalScope.crypto={};
    crypto.getRandomValues = function getRandomValues (abv) {
      var l = abv.length
      while (l--) {
        abv[l] = Math.floor(twister.random() * 256)
      }
      return abv
    }
    if (!globalScope.Uint8Array && !Uint8Array) throw new Error('crypto.rand: No Uint8Array found!');
    if (!globalScope.Uint8Array) globalScope.Uint8Array=Uint8Array;
  }


  function randomByte (min,max) {
    if (!twister) twister = new MersenneTwister();
    return Math.floor(twister.random() * (max-min))+min;
  }

  function randomBytes (size, cb) {
    // phantomjs needs to throw
    if (size > 65536) throw new Error('requested too many random bytes')
    if (!crypto || !crypto.getRandomValues) polyfill();

    // in case browserify  isn't using the Uint8Array version
    var rawBytes = new globalScope.Uint8Array(size);
    // This will not work in older browsers.
    // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
    if (size > 0) {  // getRandomValues fails on IE if size == 0
      crypto.getRandomValues(rawBytes);
    }
    // phantomjs doesn't like a buffer being passed here
    var bytes = new Buffer(rawBytes);
    if (typeof cb === 'function') {
      cb(null, bytes)
    }

    return bytes
  } 

  return {
    randomByte:randomByte,
    randomBytes:randomBytes
  }
})();

Des48 = (function () {
  
  const des_HBS = 24;
  const des_BS = des_HBS * 2;


  /*
  ** Initial permutation,
  */

  var des_IP = [
      23, 27, 34, 44, 37, 17, 12, 42,
      3, 32, 41, 29, 20,  2,  1, 10,
      0, 28, 40,  6,  7, 11, 16,  8,
      25, 30, 14, 26, 47, 38, 19, 43,
      18,  5, 35, 39, 36, 21,  4, 45,
      24, 22, 13, 33, 31,  9, 15, 46 ];

  /*
  ** Final permutation, FP = IP^(-1)
  */

  var des_FP = [
      16, 14, 13,  8, 38, 33, 19, 20,
      23, 45, 15, 21,  6, 42, 26, 46,
      22,  5, 32, 30, 12, 37, 41,  0,
      40, 24, 27,  1, 17, 11, 25, 44,
      9, 43,  2, 34, 36,  4, 29, 35,
      18, 10,  7, 31,  3, 39, 47, 28 ];

  /*
  ** Permuted-choice 1 from the key bits
  ** to yield C and D.
  ** Note that bits 8,16... are left out:
      ** They are intended for a parity check.
  */

  var des_PC1_C = [
      57,49,41,33,25,17, 9,
      1,58,50,42,34,26,18,
      10, 2,59,51,43,35,27,
      19,11, 3,60,52,44,36 ];

  var des_PC1_D = [
      63,55,47,39,31,23,15,
      7,62,54,46,38,30,22,
      14, 6,61,53,45,37,29,
      21,13, 5,28,20,12, 4 ];


  /*
  ** Sequence of shifts used for the key schedule.
  */

  var des_shifts = [
      1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 ];



  /*
  ** Permuted-choice 2, to pick out the bits from
  ** the CD array that generate the key schedule.
  */

  var des_PC2_C = [
      14,17,11,24, 1, 5,
      3,28,15, 6,21,10,
      23,19,12, 4,26, 8,
      16, 7,27,20,13, 2 ];

  var des_PC2_D = [
      41,52,31,37,47,55,
      30,40,51,45,33,48,
      44,49,39,56,34,53,
      46,42,50,36,29,32 ];

  /*
  ** The C and D arrays used to calculate the key schedule.
  */


  var des_C = Array.create(56,0);
  // des_D = des_C[28]
  var des_D_get = function (i) {return des_C[i+28]};
  var des_D_set  =  function (i,sval) { des_C[i+28] = sval };

  /*
  ** The key schedule.
  ** Generated from the key.
  */

  var des_KS= Array.matrix(16,48,0);

  var des_OWsetkey = function(key) {
      var ks = [];
      var t = 0;
      var i,j,k;
      /*
      ** First, generate C and D by permuting
      ** the key.  The low order bit of each
      ** 8-bit char is not used, so C and D are only 28
      ** bits apiece.
      */

      for(i = 0;i < 28;i++) {

          var index1 = des_PC1_C[i] - 1;
          var index2 = des_PC1_D[i] - 1;

          des_C[i] = key[index1];
          des_D_set(i,key[index2]);
      }

      /*
      ** To generate Ki, rotate C and D according
      ** to schedule and pick up a permutation
      ** using PC2.
      */


      for (i = 0 ;i< 16;i++) {

          ks = des_KS[i];

          // rotate
          for (k = 0; k < des_shifts[i]; k++) {
              t = des_C[0];

              for (j = 0; j < 27; j++) {
                  des_C[j] = -des_C[j + 1];
              }

              des_C[27] = t;
              t = des_D_get(0);

              for (j = 0; j < 27; j++) {
                  des_D_set(j, des_D_get(j + 1));
              }
              des_D_set(27, t);
          }

          /*
           ** get Ki. Note C and D are concatenated.
           */

          for (j = 0; j < 24; j++) {
              ks[j] = des_C[des_PC2_C[j] - 1];
              ks[j + 24] = des_D_get(des_PC2_D[j] - 28 - 1);
          }

      }
  };


  /*
  ** The E bit-selection table.
  */

  var des_E = [
      22, 15, 12,  3,  8,  2, 23, 16,
      14, 13,  9, 10,  0,  1, 21, 19,
      18,  6, 11,  7, 17,  4, 20,  5,
      5, 17, 11, 13, 12, 14,  8,  7,
      19, 22, 18,  9,  3,  4,  1,  6,
      16,  2, 20, 15, 10, 23,  0, 21 ];


  /*
  ** The 8 selection functions.
  ** For some reason, they give a 0-origin
  ** index, unlike everything else.
  */

  var des_S = [
      [ 14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
      0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
      4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
      15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13 ],

      [ 15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10,
      3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5,
      0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15,
      13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9 ],

      [ 10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8,
      13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1,
      13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7,
      1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12 ],

      [ 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15,
      13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9,
      10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4,
      3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14 ],

      [ 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9,
      14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6,
      4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14,
      11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3 ],

      [ 12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11,
      10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8,
      9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6,
      4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13 ],

      [ 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1,
      13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6,
      1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2,
      6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12 ],

      [ 13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7,
      1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2,
      7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8,
      2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11 ]
      ];


  /*
  ** P is a permutation on the selected combination
  ** of the current L and key.
  */

  var des_P = [
      3, 13,  9, 12,  8, 20, 21,  7,
      5, 23, 16,  1, 14, 18,  4, 15,
      22, 10,  2,  0, 11, 19, 17,  6 ];

  var des_L = Array.create(des_BS,0);
  var des_R_get = function (i) { return des_L[(i+des_HBS)]};
  var des_R_set = function (i,sval) { des_L[i+des_HBS]= sval};
  var des_tempL = Array.create(des_HBS,0);
  var des_f = Array.create (32,0);

  /*
  ** Warning!!
  **
  ** f[] used to be HBS for some years.
  ** 21/6/1990 cbo and sater discovered that inside the loop where f is computed
  ** indices are used from 0 to 31. These overlapped the preS array which is
  ** declared hereafter on all compilers upto that point, but only those
  ** values that were not used anymore. But the values of f are only used
  ** upto HBS. Makes you wonder about the one-way property.
  ** Then came ACK, and reversed the order of the arrays in the image.
  **
  ** As a short term solution f[] was increased to 32, but in the long run
  ** someone should have a good look at our "oneway" function
  */

  /*
  ** The combination of the key and the input, before selection.
  */
  var des_preS = Array.create (48,0);

  /*
  ** The payoff: encrypt a block. (Now 48 bytes, 1 bit/byte)
  */

  var des_OWcrypt48 = function(block) {
      var ks = [];
      var t1 = 0;
      var t2 = 0;
      var i, j, k;
      /*
       ** First, permute the bits in the input
       */

      for (j = 0; j <= (des_BS - 1); j++) {
          des_L[j] = block[des_IP[j]];
      }
      /*
       ** Perform an encryption operation 16 times.
       */

      for (i = 0; i <= 15; i++) {
          ks = des_KS[i];

          /*
           ** Save the R array,
           ** which will be the new L.
           */

          for (j = 0; j < (des_HBS - 1); j++) {
              des_tempL[j] = des_R_get(j);
          }
          /*
           ** Expand R to 48 bits using the E selector;
           ** exclusive-or with the current key bits.
           */

          for (j = 0; j <= 47; j++) {
              des_preS[j] = (des_R_get(des_E[j])) ^ ks[j];
          }

          /*
           ** The pre-select bits are now considered
           ** in 8 groups of 6 bits each.
           ** The 8 selection functions map these
           ** 6-bit quantities into 4-bit quantities
           ** and the results permuted
           ** to make an f(R, K).
           ** The indexing into the selection functions
           ** is peculiar; it could be simplified by
           ** rewriting the tables.
           */

          t1 = 0;
          t2 = 0;

          for (j = 0; j <= 7; j++) {
              var sind2 =
                  ((des_preS[t1 + 0] << 5) & 0xff) +
                  ((des_preS[t1 + 1] << 3) & 0xff) +
                  ((des_preS[t1 + 2] << 2) & 0xff) +
                  ((des_preS[t1 + 3] << 1) & 0xff) +
                  ((des_preS[t1 + 4] << 0) & 0xff) +
                  ((des_preS[t1 + 5] << 4) & 0xff);

              k = des_S[j][sind2];

              des_f[t2 + 0] = (k >> 3) & 0x1;
              des_f[t2 + 1] = (k >> 2) & 0x1;
              des_f[t2 + 2] = (k >> 1) & 0x1;
              des_f[t2 + 3] = (k >> 0) & 0x1;    // 3 .. 31 !!!

              t1 = t1 + 6;
              t2 = t2 + 4;
          }

          /*
           ** The new R is L ^ f(R, K).
           ** The f here has to be permuted first, though.
           */

          for (j = 0; j < des_HBS; j++) {
              des_R_set(j, (des_L[j] ^ des_f[des_P[j]]));
          }

          /*
           ** Finally, the new L (the original R)
           ** is copied back.
           */

          for (j = 0; j < des_HBS; j++) {
              des_L[j] = des_tempL[j];
          }

      }


      /*
       ** The output L and R are reversed.
       */

      for (j = 0; j < des_HBS; j++) {
          t1 = des_L[j];
          des_L[j] = des_R_get(j);
          des_R_set(j, t1);
      }

      /*
       ** The final output
       ** gets the inverse permutation of the very original.
       */

      for (j = 0; j < des_BS; j++) {
          block[j] = des_L[des_FP[j]];
      }
      return block;
  };

  return {
      des_OWsetkey:des_OWsetkey,
      des_OWcrypt48:des_OWcrypt48
  };
})();


Rnd = {
  generate : function (options) {
  
  function numgen (options) {
    // assuming byte number range 0-255
    var arr = new Uint8Array(options.length||8);
    getRandomValues(arr);
    return arr;
  }
  
  function pwgen (options) {
    var localName, consonant, letter, vowel, pattern = options.pattern,
        char = "", n, i, validChars = [], prefix=options.prefix;
    letter = /[a-zA-Z]$/;
    vowel = /[aeiouAEIOU]$/;
    consonant = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/;
    if (options.length == null) {
      options.length = 10;
    }
    if (pattern == null) {
      pattern = /\w/;
    }
    if (prefix == null) {
      prefix = '';
    }

    // Non memorable passwords will pick characters from a pre-generated
    // list of characters
    if (!options.memorable) {
      for (i = 33; 126 > i; i += 1) {
        char = String.fromCharCode(i);
        if (char.match(pattern)) {
          validChars.push(char);
        }
      }

      if (!validChars.length) {
        throw new Error("Could not find characters that match the " +
          "password pattern " + pattern + ". Patterns must match individual " +
          "characters, not the password as a whole.");
      }
    }


    while (prefix.length < options.length) {
      if (options.memorable) {
        if (prefix.match(consonant)) {
          pattern = vowel;
        } else {
          pattern = consonant;
        }
        n = Crypto.randomByte(33,126); // rand(33, 126);
        char = String.fromCharCode(n);
      } else {
        char = validChars[rand(0, validChars.length)];
      }

      if (options.lowercase) char = char.toLowerCase();
      else if (options.uppercase) char = char.toUpperCase();
      
      if (char.match(pattern)) {
        prefix = "" + prefix + char;
      }
    }
    return prefix;
  };


  function rand(min, max) {
    var key, value, arr = new Uint8Array(max);
    getRandomValues(arr);
    for (key in arr) {
      if (arr.hasOwnProperty(key)) {
        value = arr[key];
        if (value > min && value < max) {
          return value;
        }
      }
    }
    return rand(min, max);
  }


  function getRandomValues(buf) {
    var bytes = Crypto.randomBytes(buf.length);
    buf.set(bytes);
  }
  if (options.number) 
    return numgen(options)
  else
    return pwgen(options);
}};
</script>
    <script type="text/javascript" charset="utf-8">// Code snippet

// Create a new code snippet and append it 
// Provides worker and IPC API, too (browser/nodejs)
// TODO: uniform format { cell, index, id, options }

var Editors=[];
var Consoles=[];
var Codes=[];
var Library;
var Plugins={};

var ConsoleOutput;
var ConsoleId;
var ConsoleTerminal;

// that is persistent
var Env0={}
// this is volatile
var Env={}

// Evaluators
Context={
  compile : function (code,context,data,self) { try {
    if (context) {
      var pars = Object.keys(context),
          args = pars.map(function (key) { return context[key] });
      pars.unshift('__dummy');
      if (data!==undefined) { pars.push('__data'); args.push(data) };
      pars.push(code);
      var foo = new (Function.prototype.bind.apply(Function,pars));
      return foo.apply(self,args);          
    } else {
      var foo = new Function ("return "+code)();
      return foo;
    } } catch (e) { Code.error(e) }
  },
  debug     : false,
  deserialize : function (data) {
    return JSONfn.deserialize(data)
  },
  csv       : {
    read    : async function (file,sep,convert) {
      var data = await Utils.read(file);
      return Utils.ofCSV(data,sep,convert);
    },
    write   : function (file,data,header,sep)  {
      var text = Utils.toCSV(data,header,sep);
      Utils.write(file,text);
    }
  },
  edit : function (vari) {
    var text= Code.eval(vari,Context, true);
    if (typeof text != 'string') return Code.error('edit can only process string data');
    if (text!=undefined) text=text.toString();
    else text='';
    Common.openCodeEditor({
      label: vari,
      text : text,
      callback : function (event,text) {
        if (event=='close' || event=='refresh') {
          Code.eval(vari+'="'+text+'"',Context, true);
        };
      }
    });
  },
  fs        : {
    read    : Utils.read,
    write   : Utils.write,
    list    : Utils.list,
    get workdir () {
      return FS.workdir;
    } 
  },
  json      : {
    read  : async function (path) {},
    write : function (path,data) {},
  },
  numpy    : {
    read  : async function (file,cb) {
      if (!cb) {
        var data = await Utils.read(file,'binary');
        return Utils.ofNUMPY(data);
      }
    },
    write : function (path,data) {},
  },
  of : {
    csv     : Utils.ofCSV,
    json    : Utils.ofJSON,
    yaml    : Utils.ofYAML,
  },
  load      : Utils.load,
  loadc     : Utils.loadc,
  Plot      : Plot.create,
  PlotTable : Plot.table,
  self      : Env,
  schedule : async function () {
    return new Promise(function (resolve) {
      setTimeout(function () { resolve(Code.interrupt) },0);
    });
  },
  serialize : function (data) {
    return JSONfn.serialize(data)
  },
  sleep     : async function (milli) {
    return new Promise(function (resolve,reject) {
      var id = Code.waiters.length;
      Code.waiters[id] = {
        reject  : reject,
        timer   : 
          setTimeout(function () {
            delete Code.waiters[id];
            resolve();
          },milli)
      }
    });
  },
  that      : Env0,
  to : {
    csv     : Utils.toCSV,
    json    : Utils.toJSON,
    yaml    : Utils.toYAML,
  },
}


function Scope(env) {
  Object.assign(Context,env);
  this.eval=eval;
}
Scope.prototype.run = function (script,context,terminal) {
  var exports,tokens,parameter,input,output,more,error;
  
  Context.exports=Context;
  Object.assign(context,Context);
  
  // Check for additional non-standrad statements (export, parameter, input, output) ...
  if (typeof script == 'string') {
    var meta = Code.getMeta(script);
    script=meta.script;
    console.log(script)
    // we have to create code snippet IPC channels!
    if (meta.input) {
      meta.input.forEach(function (chan) {
        if (!Code.ipc[chan]) Code.ipc[chan]=Code.channel.create();
      });
    }
    if (meta.output) {
      meta.output.forEach(function (chan) {
        if (!Code.ipc[chan]) Code.ipc[chan]=Code.channel.create();
      });
    }
  }
  if (typeof script == 'function') {
    try { with(context) { eval(script.toString()) } } catch (e) { throw e }
    return;
  } else if (Config.thisthat) {
    Context.console=console;
    Env.eval=eval;
    return (function(){
    try {
      // Experimental async/await support
      if (terminal) {
        if (error=Utils.analyze('(function () {'+script+'\n})()'))
          return context.error(error);
      } else {
        if (error=Utils.analyze('(async function () {'+script+'\n})()'))
          return context.error(error);
      }
      if (script.match(/^[ ]*\"use worker/)) {
        return Code.worker.run(Number(script.match(/^[ ]*\"use worker[ ]*([0-9]+)/)[1]||0),script,ConsoleId);
      } 
      if (script.match(/^[ ]*\"use shellworker/)) {
        return Code.shellworker.run(Number(script.match(/^[ ]*\"use shellworker[ ]*([0-9]+)/)[1]||0),script,ConsoleId);
      } 
      if (terminal) 
        return eval ('with (context) { var __error=error; try { '+script+'\n} catch (e) { __error(e) }}');
      // All blocking calls need await prefix (e.g., sleep, channel.read ...
      else if (!Config.turbo)
        return eval('with (context) { var __error=error; (async function () { try { '+script+'\n} catch (e) {'+
                    'e=e||"Interrupted.";var p; if (e.stack) {p=e.stack.match(/@file:[^>]+ > eval:([0-9]+):([0-9]+)/)}; console.log(e); if (debug) __error(e+"\\n"+e.stack); else __error(e+(p?" @"+p[1]+":"+p[2]:"")) } }).call(this)}')
      else {
        var self=this;
        function execute(code,context) {
          // contruct functional scope
          var pars = Object.keys(context),
              args = pars.map(function (key) { return context[key] });
          pars.unshift('__dummy');
          pars.push(code);
          var foo = new (Function.prototype.bind.apply(Function,pars));
          return foo.apply(self,args);
        }
        return execute ('var __error=error; (async function () { try { '+script+'\n} catch (e) {'+
                       'e=e||"Interrupted.";var p; if (e && e.stack) {p=e.stack.match(/@file:[^>]+ > Function:([0-9]+):([0-9]+)/)}; console.log(e); if (debug) __error(e+"\\n"+e.stack); else __error(e+(p?" @"+p[1]+":"+p[2]:"")) } }).call(this)',context)
      }
    } catch (e) {
      console.log(e)
      if (e.name==='SyntaxError' || e.toString().indexOf('SyntaxError')>=0) {
        try {        
          var ast = esprima.parse(script, { tolerant: true, loc:true });
          if (ast.errors && ast.errors.length>0) more = ', '+ast.errors[0];
        } catch (e) {
          if (e.lineNumber)  more = ', in line '+e.lineNumber;
        }
      }
      if (more)
        context.error(e.toString()+more)        
      else
        context.error(e)
    }
    }).call(Env);
  } else {
    if (terminal) {
      if (error=Utils.analyze('(function () {'+script+'})()'))
        return context.error(error);
    } else {
      if (error=Utils.analyze('(async function () {'+script+'})()'))
        return context.error(error);
    }
    if (script.match(/^[ ]*"use worker"/)) {
        return Code.threads.run(0,script,ConsoleId);
    } 
    try {
      if (terminal) 
        return eval ('try { with (context) {'+script+'}} catch (e) { error(e) }');
      else if (!Config.turbo)
        return eval('with (context) { var __error=error; (async function () { try { '+script+'\n} catch (e) {'+
                    'var p; if (e.stack) {p=e.stack.match(/@file:[^>]+ > eval:([0-9]+):([0-9]+)/)}; console.log(e); if (debug) __error(e+"\\n"+e.stack); else __error(e+(p?" @"+p[1]+":"+p[2]:"")) } }).call(this)}')
      else {
        var self=this;
        function execute(code,context) {
          // contruct functional scope
          var pars = Object.keys(context),
              args = pars.map(function (key) { return context[key] });
          pars.unshift('__dummy');
          pars.push(code);
          var foo = new (Function.prototype.bind.apply(Function,pars));
          return foo.apply(self,args);
        }
        return execute('var __error=error; (async function () { try { '+script+'\n} catch (e) {'+
                       'var p; if (e.stack) {p=e.stack.match(/@file:[^>]+ > Function:([0-9]+):([0-9]+)/)}; console.log(e); if (debug) __error(e+"\\n"+e.stack); else __error(e+(p?" @"+p[1]+":"+p[2]:"")) } }).call(this)',context);
      }
    } catch (e) {
      context.error(e)
      console.log(e)
    }
  }
}
// TODO: refactor code execution (independent on language)
var jsScope = new Scope({});


Code = {
  codeIndex:0,
  animate : function (callback) {
    var index = Code.animations.length;
    Code.animations[index]=callback;
    
    function loop () {
      requestAnimationFrame(function () {
        if (!Code.animations[index]) return; // killed
        var more = callback();
        if (more) requestAnimationFrame(loop);
      })
    }
    loop();    
  },
  animations:[],
  
  // Registration of user run/eval callbacks (in conjucnton with code.options.evalUser)
  callbacks : [],
  
  config : {
    // default loop/iter schedul timeout
    scheduleTimeout : 10,
  },
  
  create : function codeCreate(options,text) {
    var i = Code.codeIndex++,
        id = 'code'+i;
    if (!options) options={};
    if (!options.label) options.label=id;
    if (options.height) options.heightC=options.heightE=options.height;
    if (!options.heightC) options.heightC=100; // max. console height in lines
    if (!options.heightE) options.heightE=10;  // max. editor height in lines
    
    if (options.label.indexOf('⊠')!=-1) options.locked=true;
    
    // Construct cell DOM tree
    var cell = $('<div/>', {
      id: 'code-cell'+i,
      tabindex : "2",
      class: 'cell code_cell unselected',
    });
    $(cell).click(function () {
      $(cell).removeClass('unselected');
      if (Common.snippetSelect) {
        $(Common.snippetSelect).removeClass('selected')
        $(Common.snippetSelect).addClass('unselected')
      }
      Common.snippetSelect=cell;
      $(cell).addClass('selected');
    });
    var header = $('<div/>', {
      id: 'code-header'+i,
      tabindex : "2",
      style:"margin-left:12ex",
      class: 'snippet-label',
    }).appendTo(cell);
    $('<span id="code-label'+i+'" class="snippet-label">'+(options.label.indexOf('code')!=0?i+'. ':'')+options.label+'</span>').appendTo(header);
    $('<a class="spacer button right fa fa-folder-open" alt="Collapse" onclick="Cell.collapseCode(\''+id+'\')" title="Collapse"></a>').appendTo(header);
    $('<a class="spacer button right fa fa-user" alt="Share" onclick="Clip.share(\''+id+'\')" title="Share"></a>').appendTo(header);
    $('<a class="spacer button right fa fa-bars" alt="Setup" onclick="Common.setup(\''+id+'\')" title="Setup"></a>').appendTo(header);
    $('<a class="spacer button right fa fa-refresh" alt="Refresh" onclick="Common.refresh(\''+id+'\')" title="Setup"></a>').appendTo(header);
    $('<a class="spacer button right fa fa-sign-out" alt="Save Code" onclick="Code.save(\''+id+'\')" title="Save Code"></a>').appendTo(header);
    $('<a class="spacer button right fa fa-sign-in" alt="Load Code" onclick="Code.load(\''+id+'\')" title="Load Code"></a>').appendTo(header);
    $('<a class="spacer button right fa fa-edit" alt="Edit Code" onclick="Code.edit(\''+id+'\')" title="Edit Code"></a>').appendTo(header);

    var input = $('<div/>', {
      id: 'code-input'+id,
      class: 'input',
    }).appendTo(cell);
      var prompt_container = $('<div/>', {
        id: 'code-prompt_container'+i,
        class: 'prompt_container',
      }).appendTo(input);
        var prompt_container_input = $('<div/>', {
          id: 'code-prompt_container_input'+id,
          class: 'prompt input_prompt',
        }).appendTo(prompt_container);
        $(prompt_container_input).append('<bdi>In</bdi>&nbsp;[ ]:');
      var inner_cell = $('<div/>', {
        id: 'code-inner_cell'+i,
        class: 'inner_cell',
      }).appendTo(input);
        var ctb_hideshow = $('<div/>', {
          id: 'code-ctb_hideshow'+i,
          class: 'ctb_hideshow',
        }).appendTo(inner_cell);
          var celltoolbar = $('<div/>', {
            id: 'code-celltoolbar'+i,
            class: 'celltoolbar',
          }).appendTo(ctb_hideshow);
        var input_area2 = $('<div/>', {
          id: 'code-input_area2'+i,
          class: 'input_area2',
        }).appendTo(inner_cell);
          var textarea = $('<textarea/>', {
            id: 'code'+i,
            class: '',
          }).appendTo(input_area2);
        if (true) { // overlay must be created in advance - independent from activation
          /* Construct overlay widget */
          var overlay = $('<div/>', {
            id: 'code-overlay'+i,
            tabindex : "-1",
            style : 'min-height:100px; border:1px solid #888;',
            class: 'ext_cell_render',
          }).appendTo(inner_cell);
            cell.__overlay=overlay;
            overlay.__content={}
            overlay.__content.maintable = $('<table/>',{
              style:'width:100%',
            }).appendTo(overlay);
            overlay.__content.mainrow = $('<tr/>',{
              style:'width:100%',
            }).appendTo(overlay.__content.maintable);
            overlay.__content.left = $('<td/>',{
              style:'width:50%;padding:5px;vertical-align:top;',
            }).appendTo(overlay.__content.mainrow);
            overlay.__content.right = $('<td/>',{
              style:'width:50%;vertical-align:top;',
            }).appendTo(overlay.__content.mainrow);
            var pt = $('<div/>',{
              id : 'parametertable'+id,
              style:'padding: 10px;',
            }).appendTo(overlay.__content.right);
           function p2s (expr) {
              if (typeof expr == 'object') return expr.join(',');
              else return String(expr);
            }
            function s2p (expr,val) {
              if (typeof expr=='number')
                return Number(val);
              else if (typeof expr=='object')
                // array
                return val.split(',').map(function (v) {
                  if (!isNaN(Number(v))) return Number(v);
                  else if (v=='true'||v=='false') return v=='true'?true:false;
                  else return v;
                });
              else
                return val;         
            }
            overlay.__handler = {
              control : function (actions) {
                var meta = Code.getMeta(editor.getValue());
                overlay.__content.left.empty();
                var ct = $('<table/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(overlay.__content.left);
                var ctr1= $('<tr/>',{}).appendTo(ct);
                var ctrd1 = $('<td/>',{style:'padding:10px; white-space:nowrap;', colspan:"2"}).appendTo(ctr1);
                Object.keys(actions).forEach(function(name) {
                  var action = actions[name];
                  switch (name) {
                    case 'run':
                      var run = $('<span/>',{ class:'action fa fa-play', style:'padding-right:20px;',title:"Run" }).appendTo(ctrd1).on('click',function () {
                        overlay.__content.status.html('run');
                        action();
                      });
                      break;
                    case 'stop':
                      var stop=$('<span/>',{ class:'action fa fa-stop', style:'padding-right:20px;', title:"Stop" }).appendTo(ctrd1).on('click',function () {
                        overlay.__content.status.html('end');
                        action();                      
                      });
                      break;
                    case 'pause':
                      var pause=$('<span/>',{ class:'action fa fa-pause', style:'padding-right:20px;', title:"Pause" }).appendTo(ctrd1).on('click',action);
                      break;
                    case 'reset':
                      $('<span/>',{ class:'action fa fa-step-backward', style:'padding-right:20px;', title:"Reset" }).appendTo(ctrd1).on('click',action);
                      break;
                    default:
                      var ac = $('<span/>',{class:'action button', style:'font-size:1.0em; font-weight:bold; background:black; color:white; border: 1px solid; border-radius:5px; padding:8px; margin-right:10px;', title:name}).appendTo(ctrd1);
                      ac.on('click',action);
                      ac.html(name);                    
                  }
                });
                if (meta.imports) {
                  var ctr2M= $('<tr/>',{}).appendTo(ct);
                  var ctrdM2A = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2M).html('<i>Import</i>:');
                  var ctrdM2V = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2M).html(meta.imports.join(', '));
                }
                if (meta.exports) {
                  var ctr2E= $('<tr/>',{}).appendTo(ct);
                  var ctrdE2A = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2E).html('<i>Export</i>:');
                  var ctrdE2V = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2E).html(meta.exports.join(', '));
                }
                if (meta.input) {
                  var ctr2I= $('<tr/>',{}).appendTo(ct);
                  var ctrdI2A = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2I).html('<i>Input</i>:');
                  var ctrdI2V = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2I).html(meta.input.join(', '));
                }
                if (meta.output) {
                  var ctr2O= $('<tr/>',{}).appendTo(ct);
                  var ctrdO2A = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2O).html('<i>Output</i>:');
                  var ctrdO2V = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2O).html(meta.output.join(', '));
                }
                if (meta.description) {
                  var ctr2D= $('<tr/>',{}).appendTo(ct);
                  var ctrdD2A = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2D).html('<i>Description:</i>:');
                  var ctrdD2V = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr2D).html(meta.description);
                }
                var ctr3= $('<tr/>',{}).appendTo(ct);
                var ctrd3A = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;'}).appendTo(ctr3).html('<b>Status</b>:');
                overlay.__content.status = $('<td/>',{style:'padding:5px;padding-left:10px;padding-right:10px;color:blue;'}).appendTo(ctr3).html('');
              },
              parameter : function (parameter,callback) {
                 pt.empty();
                // parameter table
                overlay.__content.parametertable=pt;
                var rows = [], columns=[
                  { type : 'text', readOnly:true, align:'center', },
                  { type : 'text', align:'right' }
                ],
                colHeaders=['Parameter','Value'],
                colWidths=[ 200,200];
                for (var p in parameter) {
                  if (p[0]=='_') continue;
                  rows.push([p,p2s(parameter[p])]);
                }
                if (!rows.length) return;
                // Interactiv parameter table
                pt.jexcel({
                    data:rows,
                    colHeaders  : colHeaders,
                    colWidths   : colWidths,
                    columns     : columns,
                    onchange: function (obj,cell,val) {
                      var id = $(cell).prop('id').split('-').map(Number),
                          row = id[1],
                          key = rows[row][0];
                      // console.log(id,val)
                      parameter[key]=s2p(parameter[key],val);                    
                      var script = Code.setMeta(editor.getValue(),{parameter:parameter});
                      editor.setValue(script);
                      editor.refresh();
                    },
                    allowInsertRow : false,
                    allowManualInsertRow : false,
                    allowInsertColumn : false,
                    allowManualInsertColumn : false,
                    allowDeleteRow : false,
                    allowDeleteColumn : false,
                    allowComments : false,
                    hideIndex : true,
                    toolbar:[],
                    contextMenu: function(type, number, e) {
                      var id = $(e.target).prop('id').split('-').map(Number),
                          row = id[1],
                          col = id[0];
                      var items = [];
                      // console.log(row,col,rows[row][0],typeof parameter[rows[row][0]]);
                      if (col==1 && parameter['_'+rows[row][0]]) {
                        // choices
                        var choices = parameter['_'+rows[row][0]];
                        items = choices.map(function (choice) {
                          return {
                            title   : choice,
                            onclick : function () {
                              if (typeof parameter[rows[row][0]] == 'object')
                                parameter[rows[row][0]].push(choice);
                              else 
                                parameter[rows[row][0]]=choice;
                              var script = Code.setMeta(editor.getValue(),{parameter:parameter});
                              editor.setValue(script);
                              editor.refresh();
                              pt.jexcel('setValue',$(e.target),p2s(parameter[rows[row][0]]) );                                                        
                            }
                          }
                        });
                      } else if (col==1 && typeof parameter[rows[row][0]] == 'string') {
                        // support file/dir dialog selection
                        items.push({
                          title   : 'Filesystem',
                          onclick : function () {
                            FS.API.selectFile('Select a file or directory',function (file,dir) {
                              parameter[rows[row][0]]=dir=='/'?dir+file:dir+'/'+file;
                              var script = Code.setMeta(editor.getValue(),{parameter:parameter});
                              editor.setValue(script);
                              editor.refresh();
                              pt.jexcel('setValue',$(e.target),parameter[rows[row][0]] );                            
                            });
                          } 
                        });
                      }
                      return items.map(function (item) {
                        return $('<a/>').html(item.title).on('click',item.onclick);
                      })
                    },
                });
              },
              setParameter : function (attribute,value) {
                var code = editor.getValue();
                var meta = Code.getMeta(code);
                var parameter = meta.parameter;
                parameter[attribute]=value;
                var script = Code.setMeta(code,{parameter:parameter});
                editor.setValue(script);
                editor.refresh();
                var row = Object.keys(meta.parameter).indexOf(attribute);
                if (row != -1) pt.jexcel('setValue','B'+(row+1),p2s(value));        
              }
            }
          overlay.hide();
        }
    var output_wrapper = $('<div/>', {
      id: 'code-output_wrapper'+id,
      class: 'output_wrapper',
    }).appendTo(cell);
      var out_prompt_overlay = $('<div/>', {
        id: 'code-out_prompt_overlay'+id,
        class: 'out_prompt_overlay prompt button',
        title:"double click to "+(options.overlay?"flip panel view":"hide"),
      }).appendTo(output_wrapper);
      function overlayFlip(initial) {
        if (!initial && options.locked) return;
        // Code panel overlay (hides code, shows status, input, ouput, description, parameter)
        // swap code and overlay
        if (options.overlay==2) {
          overlay.show();$(input_area2).hide();
          var meta = Code.getMeta(editor.getValue());
          overlay.__handler.parameter(meta.parameter);
          if (meta.buttons && Object.keys(meta.buttons).length) {
            var buttons = {};
            for(var p in meta.buttons) buttons[p]=(function (action,foo) {
              return function () {
                Code.run(id,{action:foo+'()',
                             status:function () {
                               overlay.__content.status.html(Array.prototype.slice.call(arguments).join(', '))
                             }
                            });
              }
            })(p,meta.buttons[p]);
            overlay.__handler.control(buttons);
          } else overlay.__handler.control({
            run : function () {
              Code.run(id,{status:function () {overlay.__content.status.html(Array.prototype.slice.call(arguments).join(', '))}});
            },
            stop : function () {
              // Check for worker/shellworker
              Code.stop(id);
            },
            reset : function () {
              Cell.clearConsole(id);
            },
          });
        } else {
          overlay.hide();$(input_area2).show(); editor.refresh();
        }      
      }
      $(out_prompt_overlay).dblclick(function() {
        if (options.overlay) {
          if (options.overlay==1) options.overlay=2;
          else options.overlay=1;
          overlayFlip();
        } else Cell.collapseConsole(id);
      });
      var output = $('<div/>', {
        id: 'code-output'+i,
        class: 'output',
      }).appendTo(output_wrapper);
        var output_area = $('<div/>', {
          id: 'code-output_area'+id, // id!
          class: 'output_area',
        }).appendTo(output);
          var run_this_cell = $('<div/>', {
            id: 'code-run_this_cell'+i,
            class: 'run_this_cell',
          }).appendTo(output_area);
          var output_prompt = $('<div/>', {
            id: 'code-output_prompt'+i,
            class: 'prompt',
          }).appendTo(output_area);
          var output_subarea = $('<div/>', {
            id: 'code-output_subarea'+id, 
            class: 'output_subarea output_text output_stream output_stdout',
            style: 'max-height:'+options.heightC+'em'
          }).appendTo(output_area);
          $(output_subarea).append('<a class="spacer button right fa fa-eraser" alt="Collapse" title="collapse" onclick="Cell.clearConsole(\''+id+'\')"></a>')
        Consoles[id]=output_area;
        output_area.collapsed=false;
        var output_expander = $('<div/>', {
          id: 'code-output_expander'+id,
          class: 'btn btn-default output_collapsed',
          title:"double click to expand output",
          style:"display:none"
        }).appendTo(output);
        $(output_expander).text('. . .');  
        $(output_expander).dblclick(function() {
          Cell.collapseConsole(id);
        });
    function nbsp(spaces) {
      var sp='';
      for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
      return sp;
    }
    var std = {
      lineNum : 0,
      clear : function () {
        std.lineNum=0;
        Cell.clearConsole(id);
      },
      out: function () {
        var args=arguments,
            id = std.lineNum++,
            msg=Object.keys(args).map(function (index) { return args[index] });
        if (msg.length==1) {
          msg=msg[0]; 
          msg=(msg==undefined?'undefined':msg);
          if (typeof msg == 'object' &&
              !(msg instanceof jQuery)) msg=inspect(msg);
        } else {
          msg=msg.map(function (arg) {
            if (typeof arg=='object') return arg==undefined?'undefined':inspect(arg);
            else return arg;
          }).join(' , ');
        }
        if (msg instanceof jQuery) {
          html=msg;
        } else {
          var isHtml = msg[0]=='<' && msg[1]!='B' && msg[msg.length-1]=='>';
          if (!isHtml) msg=msg.toString().replace(/</g,'&lt;')
                                         .replace(/>/g,'&gt;')
                                         .replace(/\n/g,'<br>\n')
                                         .replace(/[ ][ ]+/g,nbsp);
          var html = isHtml?msg:'<span style="color:blue">'+msg+'</span>';
        }
        var output_textarea = $('<div/>',{
          class:'code',
          id:'code-output-line-'+id,
        });
        $(output_textarea).html(html);
        $(output_subarea).append(output_textarea);
        $(output_subarea).scrollTop($(output_subarea)[0].scrollHeight);
      },
      warn: function (msg) {
        msg=(msg==undefined?'undefined':msg);
        if (typeof msg == 'object') msg=inspect(msg);
        var html = '<span style="color:green">'+msg.toString().replace(/</g,'&lt;')
                                                              .replace(/>/g,'&gt;')+'</span>'
                                                              .replace(/\n/g,'<br>\n')
                                                              .replace(/[ ][ ]+/g,nbsp);
                                                              
        var output_textarea = $('<div/>',{
          class:'code',
          id:'code-output-line-'+(std.lineNum++),
        });
        $(output_textarea).html(html);
        $(output_subarea).append(output_textarea)
      },
      err: function (msg) {
        msg=(msg==undefined?'undefined':msg);
        if (typeof msg == 'object') msg=inspect(msg);
        var html = '<span style="color:red">'+msg.toString().replace(/</g,'&lt;')
                                                            .replace(/>/g,'&gt;')+'</span>'
                                                            .replace(/\n/g,'<br>\n')
                                                            .replace(/[ ][ ]+/g,nbsp);
        var output_textarea = $('<div/>',{
          class:'code',
          id:'code-output-line-'+(std.lineNum++),
        });
        $(output_textarea).html(html);
        $(output_subarea).append(output_textarea)
      },
      printf : function () {
        return std.out(sprintf.apply(this,arguments));
      },
      update : function () {
        var args=arguments,
            msg=Object.keys(args).map(function (index) { return args[index] }),
            id = msg.shift();
        if (id==undefined) {
          id = std.lineNum++;
          var output_textarea = $('<div/>',{
            class:'code',
            id:'code-output-line-'+id,
          });
          $(output_textarea).html('');
          $(output_subarea).append(output_textarea);
          $(output_subarea).scrollTop($(output_subarea)[0].scrollHeight);
          return id;      
        }
        if (msg.length==1) {
          msg=msg[0]; 
          msg=(msg==undefined?'undefined':msg);
          if (typeof msg == 'object') msg=inspect(msg);
        } else {
          msg=msg.map(function (arg) {
            if (typeof arg=='object') return arg==undefined?'undefined':inspect(arg);
            else return arg;
          }).join(' , ');
        }
        var isHtml = msg[0]=='<' && msg[msg.length-1]=='>';
        if (!isHtml) msg=msg.toString().replace(/\n/g,'<br>\n').replace(/[ ][ ]+/g,nbsp);
        var html = isHtml?msg:'<span style="color:blue">'+msg+'</span>';

        var output_textarea = $('#code-output-line-'+id);
        $(output_textarea).html(html);
        $(output_subarea).append(output_textarea);
        $(output_subarea).scrollTop($(output_subarea)[0].scrollHeight);      
      },
    }

    var editor=CodeMirror.fromTextArea(textarea[0], {
      lineWrapping  : true,
      lineNumbers   : true,
      smartIndent   : false,
      mode          : options.mode||'javascript',
      index         : id,
      extraKeys: {
        "Ctrl-Enter": function(instance) { 
            Code.run(id);
        },      
        "Tab": function(cm){
          var s = cm.getSelection();
          if (!s) cm.replaceSelection("  " , "end");
          else {
            cm.replaceSelection(s.split('\n').map(function (line) { return "  "+line}).join('\n'), "end");
          }
        },
        "Shift-Tab": function(cm){
          var s = cm.getSelection();
          if (s.length) {
            cm.replaceSelection(s.split('\n').map(function (line) { return line.replace(/^  /,'') }).join('\n'), "end");
          }

        }
      },
      panel:'<a class="spacer button right fa fa-folder-open" alt="Collapse" title="Collapse" onclick="Cell.collapseEditor(\''+id+'\')"></a>'+
            '<a class="spacer button right fa fa-refresh" alt="Refresh" title="Collapse" onclick="Cell.refresh(\''+id+'\')"></a>'+
            '<a class="spacer button right fa fa-step-forward" alt="Run" title="Run code" onclick="Code.run(\''+id+'\')"></a>',

    });
    editor.parameter = function (op,a,v) {
      // console.log(op,a,v);
      if (op=='set' && overlay && overlay.__handler) {
        overlay.__handler.setParameter(a,v);
      } else if (op == 'get') {
        
      }
    }
    cell.options=options;
    cell.index=i;
    
    if (options.overlay) {
      if (options.overlay===true) options.overlay=1;
    }
    Codes[id]=cell;
    Editors[id]=editor;
    editor.options=options;
    if (options.collapsed==undefined) options.collapsed=false;
    editor.run=function (context) {
      context=context||{status:std.out};
      if (Config.clearAuto) Cell.clearConsole(id);
      if (options.evalUser && Code.callbacks[options.evalUser])
        Code.callbacks[options.evalUser](editor.getValue(),Object.assign({
            clear:std.clear,
            error:std.err,
            id:id,
            iter:Code.iter,
            job:Code.job,
            label:options.label,
            later:Code.later,
            loop:Code.loop,
            print:std.out,
            printf:std.printf,
            printi:std.update,
            stop:Common.stopAll,
            time:Date.now,
      },context),id);
      else if (options.eval) options.eval(editor.getValue(),Object.assign({
            clear:std.clear,
            error:std.err,
            id:id,
            iter:Code.iter,
            job:Code.job,
            label:options.label,
            later:Code.later,
            loop:Code.loop,
            print:std.out,
            printf:std.printf,
            printi:std.update,
            stop:Common.stopAll,
            time:Date.now,
      },context));
    }
    if (text) editor.setValue(text);
    function refresh() {
      // hitting hard!
      // force recalculation of line wrapping (avoid line breaking glitches)
      editor.setOption('lineWrapping',false);
      editor.setOption('lineWrapping',true);
      editor.refresh();    
    }
    setTimeout(function() {
      $('#CodeMirror-scroll'+id).attr('style','max-height:'+(options.heightE*1.2)+'em');
      if (options.run) editor.run();
      if (options.collapsed) 
        setTimeout(function () { options.collapsed=false; Cell.collapseEditor(id) },1);
      editor.refresh();
      // console.log(options.overlay);
      if (options.overlay) overlayFlip(true);
    },1);
    editor.fullRefresh=refresh;
    if (Common.snippetSelect) {
      var index;
      $(cell).insertAfter(Common.snippetSelect);
      Common.snippets.forEach(function (entry,i) { if (entry.cell===Common.snippetSelect) index=i });
      Common.snippets=Common.snippets.slice(0,index+1)
                                     .concat({code:editor,id:id,i:i,cell:cell,options:options})
                                     .concat(Common.snippets.slice(index+1));
    } else {
      $('#content').append(cell);
      Common.snippets.push({code:editor,id:id,i:i,cell:cell,options:options});
    }
  },
  
  // Modify content of code snippt in separate editor window 
  edit : function (id) {
    var editor = Editors[id];
    if (!editor) return Code.error('Code.edit: unknown editor '+id);
    if (editor.options.locked) return;
    Common.openCodeEditor({
      label: editor.options.label,
      text : editor.getValue(),
      callback : function (event,text) {
        if (event=='close' || event=='refresh') editor.setValue(text);
      }
    });
  },
  
  eval : function (code,context,terminal) {
    return jsScope.run(code,context || {},terminal)
  },
  
  error : function () {  
    var args=arguments,
        msg=Object.keys(args).map(function (index) { return args[index] });
    function nbsp(spaces) {
      var sp='';
      for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
      return sp;
    }
    if (ConsoleTerminal) return ConsoleTerminal.error.apply(null,msg);
    if (msg.length==1) msg=msg[0]; else msg=msg.join(' , ');
    msg=(msg==undefined?'undefined':msg);
    if (typeof msg == 'object') msg=inspect(msg);
    var html = '<span style="color:red">'+msg.toString().replace(/\n/g,'<br>\n').replace(/[ ][ ]+/g,nbsp)+'</span>';
    var output_textarea = $('<div/>',{
      class:'code',
    });
    $(output_textarea).html(html);
    ConsoleOutput.append(output_textarea)
  },
  format_error: function (e) {
    var msg=e.toString();
    if (e.stack) var p=e.stack.match(/@file:[^>]+ > Function:([0-9]+):([0-9]+)/);
    if (p) msg += (' @'+p[1]+":"+p[2]);
    if (typeof debug != 'undefined' && debug && e.stack) msg += (' :'+e.stack);
    return msg 
  },
  get: function (id) {
    var editor = Editors[id];
    if (!editor) return Code.error('Code.get: unknown editor '+id);
    if (Editors[id])
      return Editors[id].getValue()
  },
  // get parameter of code snippet (including parameter table update, too, if any)
  getParameter: function (id,parameter) {
    var editor = Editors[id];
    if (!editor) return Code.error('Code.getParameter: unknown editor '+id);
    if (editor.options.locked) return;
    var meta = Code.getMeta(editor.getValue());
    return meta && meta.parameter && meta.parameter[parameter];
  },
  insert: function loadCode(id) {
    Common.loadFile(function (text) {
      var lines = Editors[id].getValue().split('\n'),
          cursor = Editors[id].getCursor();
      lines = lines.slice(0,cursor.line+1).concat(text.split('\n')).concat(lines.slice(cursor.line+1,lines.length));
      Editors[id].setValue(lines.join('\n'));
    })
  },

  ipc : {},   // code block snippet IPC channels connecting code blocks
  
  kill: function (id) {
    if (Code.tasks[id]) {
      clearInterval(Code.tasks[id]);
      Code.tasks[id]=null;
    }
  },
  interrupt : false,
  iter : async function (array,callback,final,async) {
    var counter=0,format_error=Code.format_error;
    if (typeof final=='boolean' || typeof final=='string') async=final;
    var timeout=Code.config.scheduleTimeout;
    if (!async) {
      for(counter in array) {
        try {
          callback(array[counter],counter,array);
        } catch (e) {
          if (typeof error != 'undefined') error(format_error(e));
          else Code.error(format_error(e));   
          break;     
        }
      }
      if (typeof final=='function') final(counter); 
    }
    else if (async === true) {
      var id=Code.tasks.length;
      var timer=setTimeout(handler,timeout)
      async function handler() {
        if (Code.tasks[id]==undefined) return;
        try {
          var res=await callback(array[counter],counter,array);
        } catch (e) {
          if (typeof error != 'undefined') error(format_error(e));
          else Code.error(format_error(e));
          res=e;
        }
        counter++;
        if (res instanceof Error || counter==array.length) {
          delete Code.tasks[id];
          if (typeof final=='function') 
            try { 
              final(counter,array);
            } catch (e) {
              if (typeof error != 'undefined') error(format_error(e));
              else Code.error(format_error(e));
            } 
        } else {
          timer=setTimeout(handler,timeout);
        }
      }
      Code.tasks[id]=timer;
      return id;
    } else if (async=='schedule'||async=='await') {
      Code.tasks[id]=Math.random();
      async function run (resolve) {
        var res=true;
        while(res) {
          try {
            var res=await callback(array[counter],counter,array);
          } catch (e) {
            if (typeof error != 'undefined') error(e);
            else Code.error(e);
            res=e;
          }
          counter++;
          if (res instanceof Error || counter==array.length) {
            delete Code.tasks[id];
            if (typeof final=='function') 
              try { 
                final(counter,array);
              } catch (e) {
                if (typeof error != 'undefined') error(format_error(e));
                else Code.error(format_error(e));
              } 
            if (resolve) resolve();
            return;
          } else {
            res=await Code.schedule(timeout);
            if (!res) {
              // interrupted
              console.log('loop.interrupt');
              Code.error('Interrupted.');
              delete Code.tasks[id];
              if (resolve) resolve();
              return;
            }
          }
        }
      }
      if (async=='await')
        return new Promise(function (resolve,reject) {
          run(resolve);
        });
      else return run();
    }
  },
  job : function (callback,arg0,arg1,arg2,arg3) {
    var self=this;
    Code.jobs.push(function () {
      setTimeout(function () {
        Code.jobs.shift();
        try {
          callback.call(self,arg0,arg1,arg2,arg3);
        } catch (e) {
          if (typeof error != 'undefined') error(e);
          else Code.error(e);
        }
        if (Code.jobs.length) {
          var next = Code.jobs[0];
          next.call(self);
        }
      },0);
    });
    if (Code.jobs.length==1) (Code.jobs[0])();
  },
  jobs:[],
  // typeof callback = functuion (counter) -> boolean
  later : function (timeout,callback,final) {
    var counter=0,id=Code.tasks.length,self=this,format_error=Code.format_error;;
    if (typeof timeout == 'function') {
      return setTimeout(timeout,0);
    }
    async function handler () {
      if (Code.tasks[id]==undefined) return;
      try {
        var res= await callback.call(self,counter,counter);
      } catch (e) {
        if (typeof error != 'undefined') error(format_error(e));
        else Code.error(format_error(e));
        res=0;
      }
      counter++;
      if (!res) {
        delete Code.tasks[id];
        if (typeof final=='function') 
          try {
            final(counter,counter);
          } catch (e) {
            if (typeof error != 'undefined') error(format_error(e));
            else Code.error(format_error(e));
          }
      } else {
        timer = setTimeout(handler,timeout);
      }
    }
    var timer = setTimeout(handler,timeout);
    Code.tasks[id]=timer;
    return id;
  },
  load: function loadCode(id) {
    var editor = Editors[id];
    if (!editor) return Code.error('Code.load: unknown editor '+id);
    if (editor.options.locked) return;
    Common.loadFile(function (text) {
      editor.setValue(text);
    })
  },
  // typeof callback = functuion (counter) -> boolean
  loop : async function (callback,final,async) {
    var counter=0,format_error=Code.format_error;;
    if (typeof final=='boolean' || typeof final=='string') async=final;
    var timeout=Code.config.scheduleTimeout;
    if (!async) {
      while (callback(counter,counter++)) {};
      if (typeof final=='function') final(0,counter,counter); 
    }
    else if (async==true) {
      var id=Code.tasks.length;
      var timer=setTimeout(handler,timeout)
      async function handler() {
        if (Code.tasks[id]==undefined) return;
        try {
          var res=await callback(counter,counter);
        } catch (e) {
          if (typeof error != 'undefined') error(format_error(e));
          else Code.error(format_error(e));
          res=0;
        }
        counter++;
        if (!res) {
          delete Code.tasks[id];
          if (typeof final=='function') 
            try { 
              final(counter,counter);
            } catch (e) {
              if (typeof error != 'undefined') error(format_error(e));
              else Code.error(format_error(e));
            } 
        } else {
          timer=setTimeout(handler,timeout);
        }
      }
      Code.tasks[id]=timer;
      return id;
    } else if (async=='schedule'||async=='await') {
      Code.tasks[id]=Math.random();
      async function run(resolve) {
        var res=true;
        while(res) {
          try {
            var res=await callback(counter);
          } catch (e) {
            if (typeof error != 'undefined') error(format_error(e));
            else Code.error(format_error(e));
            res=false;
          }
          counter++;
          if (res) {
            res=await Code.schedule(timeout);
            if (!res) {
              // interrupted
              console.log('loop.interrupt');
              Code.error('Interrupted.');
              delete Code.tasks[id];
              return;
            }
          }
        }
        delete Code.tasks[id];
        if (typeof final=='function') 
          try { 
            final(counter,counter);
          } catch (e) {
            if (typeof error != 'undefined') error(format_error(e));
            else Code.error(format_error(e));
          } 
        return true;
      }
      if (async=='await')
        return new Promise(function (resolve,reject) {
          run(resolve);
        });
      else return run();
    }
     
  },
  print : function () {  
    var args=arguments,html,
        msg=Object.keys(args).map(function (index) { return args[index] });
    if (ConsoleTerminal) return ConsoleTerminal.print.apply(null,msg);
    function nbsp(spaces) {
      var sp='';
      for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
      return sp;
    }
    msg = msg.map(function (arg) {
      if (typeof arg == 'object' && 
          !(arg instanceof jQuery)) return inspect(arg);
      else return arg;    
    });
    if (msg.length==1) msg=msg[0]; else msg=msg.join(' , ');
    msg=(msg==undefined?'undefined':msg);
    if (msg instanceof jQuery) {
      isHtml=true;
    } else {
      msg = msg.toString();
      var isHtml = msg[0]=='<' && msg[1]!='B' && msg[msg.length-1]=='>';
    }
    if (isHtml) {
      html=msg;
    } else {
      if (msg.length > 4000) msg=msg.substring(0,2000)+'\n..\n'+msg.substring(2000);
      msg = msg.replace(/</g,'&lt;')
               .replace(/>/g,'&gt;')
               .replace(/\n/g,'<br>\n')
               .replace(/[ ][ ]+/g,nbsp);
      html = '<span style="color:blue">'+msg+'</span>';
    }
    var output_textarea = $('<div/>',{
      class:'code',
    });
    $(output_textarea).html(html);
    ConsoleOutput.append(output_textarea)
    ConsoleOutput.scrollTop(ConsoleOutput[0].scrollHeight);
  },
  
  printi : function () {
    var args=arguments,output_textarea,
        msg=Object.keys(args).map(function (index) { return args[index] }),
        id = msg.shift();

    if (!$('#code-output-line-'+id)[0]) {
      output_textarea = $('<div/>',{
        class:'code',
        id:'code-output-line-'+id,
      });
    }
    function nbsp(spaces) {
      var sp='';
      for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
      return sp;
    }
    if (msg.length==1) {
      msg=msg[0]; 
      msg=(msg==undefined?'undefined':msg);
      if (typeof msg == 'object') msg=inspect(msg);
    } else {
      msg=msg.map(function (arg) {
        if (typeof arg=='object') return arg==undefined?'undefined':inspect(arg);
        else return arg;
      }).join(' , ');
    }
    var isHtml = msg[0]=='<' && msg[msg.length-1]=='>';
    if (!isHtml) msg=msg.toString().replace(/\n/g,'<br>\n').replace(/[ ][ ]+/g,nbsp);
    var html = isHtml?msg:'<span style="color:blue">'+msg+'</span>';

    if (!output_textarea) output_textarea = $('#code-output-line-'+id);
    $(output_textarea).html(html);
    ConsoleOutput.append(output_textarea);
    ConsoleOutput.scrollTop(ConsoleOutput[0].scrollHeight);
  },
  
  run: function run(id,context) {
    ConsoleOutput=$('#code-output_subarea'+id);
    ConsoleId=id;
    Code.interrupt=false;
    Code.RunIndex++;
    $('#code-prompt_container_input'+id).html('<bdi>In</bdi>&nbsp;['+Code.RunIndex+']:');
    Editors[id].run(context);
  },
  
  RunIndex : 0,
  save: function (id) {
    var editor = Editors[id];
    if (!editor) return Code.error('Code.save: unknown editor '+id);
    if (editor.options.locked) return;
    Common.saveFile(
      editor.getValue(),
      id,
      ''
    )
  },
  schedule : async function (timeout) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        var interrupt=Code.interrupt;
        resolve(!interrupt);
      },timeout||Code.config.scheduleTimeout);
    });
  },
  set: function (id,tex) {
    if (Editors[id])
      return Editors[id].setValue(text)
  },
  // Set parameter of code snippet (including parameter table update, too, if any)
  setParameter: function (id,parameter,value) {
    var editor = Editors[id];
    if (!editor) return Code.error('Code.setParameter: unknown editor '+id);
    if (editor.options.locked) return;
    if (editor.parameter)
      return editor.parameter('set',parameter,value);
  },
  sleep : async function (milli) {
    return new Promise(function (resolve,reject) {
      setTimeout(function () {
        resolve(Code.interrupt);
      },milli);
    });
  },
  status : function () {
    var id=$(ConsoleOutput).prop('id').replace('code-output_subarea',''),
        args=arguments,html,
        msg=Object.keys(args).map(function (index) { return args[index] }),
        overlay=Codes[id] && Codes[id].__overlay;
    console.log(id,overlay);
    if (ConsoleTerminal) return ConsoleTerminal.print.apply(null,msg);
    function nbsp(spaces) {
      var sp='';
      for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
      return sp;
    }
    msg = msg.map(function (arg) {
      if (typeof arg == 'object' && 
          !(arg instanceof jQuery)) return inspect(arg);
      else return arg;    
    });
    if (msg.length==1) msg=msg[0]; else msg=msg.join(' , ');
    msg=(msg==undefined?'undefined':msg);
    if (msg instanceof jQuery) {
      isHtml=true;
    } else {
      msg = msg.toString();
      var isHtml = msg[0]=='<' && msg[1]!='B' && msg[msg.length-1]=='>';
    }
    if (isHtml) {
      html=msg;
    } else {
      if (msg.length > 4000) msg=msg.substring(0,2000)+'\n..\n'+msg.substring(2000);
      msg = msg.replace(/</g,'&lt;')
               .replace(/>/g,'&gt;')
               .replace(/\n/g,'<br>\n')
               .replace(/[ ][ ]+/g,nbsp);
      html = '<span style="color:blue">'+msg+'</span>';
    }
    if (overlay.__content && overlay.__content.status)
      overlay.__content.status.html(html);
    else {
      var output_textarea = $('<div/>',{
        class:'code',
      });
      $(output_textarea).html(html);
      ConsoleOutput.append(output_textarea)
      ConsoleOutput.scrollTop(ConsoleOutput[0].scrollHeight);    
    }
  },
  // stop all, cancel all pending operations
  stop : function (id) {
    if (id!=undefined) {
      // specific worker or shellworker?
      var script = Editors[id].getValue();
      if (script.match(/^[ ]*\"use worker/)) {
        return Code.worker.stop(Number(script.match(/^[ ]*\"use worker[ ]*([0-9]+)/)[1]||0));
      } 
      if (script.match(/^[ ]*\"use shellworker/)) {
        return Code.shellworker.stop(Number(script.match(/^[ ]*\"use shellworker[ ]*([0-9]+)/)[1]||0));
      }       
    }
    for(var i in Code.tasks) {
      if (!Code.tasks[i]) continue; 
      clearInterval(Code.tasks[i]);
    }
    for(var i in Code.ipc) {
      if (!Code.ipc[i]) continue;
      Code.ipc[i].cancel();
    }
    for(var i in Code.waiters) {
      if (!Code.waiters[i]) continue;
      if (Code.waiters[i].timer)  clearInterval(Code.waiters[i].timer);
      if (Code.waiters[i].reject) Code.waiters[i].reject(); 
    }
    Code.tasks=[];
    Code.ipc=[];
    Code.waiters=[];
    Code.interrupt=true;
  },
  
  // started background tasks (later, loop, ..); timer references
  tasks:[],
  
  // suspended code blocks (sleep, ..), promise rejections
  waiters : [],

  
  getMeta : function (script) {
    if (/^code[0-9]+$/.test(script)) {
      var editor = Editors[script];
      if (!editor) return;
      script=editor.getValue(script);
    }
    var repl,imports,exports,tokens,parameter,input,output,description;
    // Code block export of variables (shared code block snippet environment)
    // must be last statement!
    // each export requires a local avriable reference, but
    // variables can be imported and exported, in this case
    // no variable declaration is requied! 
    if (tokens=script.match(/export[ ]*{[ ]*([^}]+)}/)) {
      script=script.replace(/export[ ]*{([^}]+)}/,'');    
      exports = [];
      tokens[1].split(',').forEach(function (exporting) {
        exporting = exporting.trim();
        if (!exporting) return;
        script += ('exports["'+exporting.trim()+'"]='+exporting.trim()+';');
        exports.push(exporting);
      })
    }
    // import creates local variables referencing values of shared exports object
    if (tokens=script.match(/import[ ]*{[ ]*([^}]+)}/)) {
      imports = [];
      tokens[1].split(',').forEach(function (importing) {
        importing = importing.trim();
        if (!importing) return;
        imports.push(importing);
      })
      var init=[];
      var repl = ('var '+imports.map(function (key) {
        return key+'=exports.'+key
      }).join(',')+';');
      script=script.replace(/import[ ]*{([^}]+)}/,repl);    
    }
    // a descriptive text display by an optional code overlay
    if (tokens=script.match(/description[ ]*{[ ]*([^}]+)}/)) {
      description = tokens[1];
      script=script.replace(/description[ ]*{([^}]+)}/,'// '+description);    
    }
    // Code block parameter that can be configured by an optional code overlay
    if (tokens=script.match(/parameter[ ]*({[^}]+})/)) {
      var parameter;
      // TODO: detect invalid syntax, e.g. { x[1,2],y:[1,2] }
      try { eval('parameter='+tokens[1]) } catch (e) { console.log(e); parameter={}; };
      
      script=script.replace(/parameter[ ]*{([^}]+)}/,'var '+Object.keys(parameter).map(function (key) {
        return key+'='+JSON.stringify(parameter[key]);
      }).concat([
        'parameter={'+Object.keys(parameter).map(function (key) {
          return 'set '+key+'(v) { var key="'+key+'"; Code.setParameter(id,key,v) }'
        }).join(',')+'}'
      ]).join(',')+';');
      // console.log(script)
    }
    // Code block buttons that can be used by an optional code overlay
    // button { name:callback, .. }
    if (tokens=script.match(/button[ ]*{([^}]+)}/)) {
      var buttons={}
      tokens[1].split(',').forEach(function (av) {
        var avl = av.split(':');
        if (avl.length==2) buttons[avl[0].trim()]=avl[1].trim();
      });
      script=script.replace(/button[ ]*{([^}]+)}/,'if (typeof action != "undefined") eval(action);');
      
    }
    // Input data channels shared between code blocks
    if (input=script.match(/input[ ]*{[ ]*([^}]+)}/)) {
      if (input[1]!=' ') {
        input=input[1].split(',').map(function(s) { return s.trim() });
        repl=[];
        input.forEach(function (chan) {
          repl.push('var '+chan+'= { pop : async function () { return Code.ipc.'+chan+'.receive() }}');
        })
        script=script.replace(/input[ ]*{[ ]*([^}]+)}/,repl.join('\n'));
      } else { script=script.replace(/input[ ]*{[ ]*([^}]+)}/,''); input=null };
    }
    // Output data channels shared between code blocks
    if (output=script.match(/output[ ]*{[ ]*([^}]+)}/)) {
      if (output[1]!=' ') {
        output=output[1].split(',').map(function(s) { return s.trim() });
        repl=[];
        output.forEach(function (chan) {
          repl.push('var '+chan+'={push:function (data) { Code.ipc.'+chan+'.send(data)}};');
        })
        script=script.replace(/output[ ]*{([^}]+)}/,repl);
      } else { script=script.replace(/output[ ]*{([^}]+)}/,''); output = null };
    }
    return {
      script  : script,
      imports : imports,
      exports : exports,
      input   : input,
      output  : output,
      parameter : parameter,
      buttons : buttons,
      description : description,
    }
  },
  setMeta : function (script, meta) {
    if (/^code[0-9]+$/.test(script)) {
      var editor = Editors[script];
      if (!editor) return;
      script=editor.getValue(script);
    }
    var plist=[];
    function wrap(v) { 
      if (typeof v == 'string') return '"'+v+'"';
      else if (typeof v == 'object') return '['+v.map(wrap).join(',')+']';
      else return v; 
    }; 
    // script must be original code, not transforenmd by getMeta!
    if (meta.parameter) {
      for(var p in meta.parameter) plist.push(p+':'+wrap(meta.parameter[p]));
      script=script.replace(/parameter {([^}]+)}/,'parameter {'+plist.join(',' )+'}');
    }
    return script;
  },

  version : '1.13.2',

}

Code.typeof = function (o) {
  var ti=typeof o;
  switch (ti) {
    case 'number':
    case 'boolean':
    case 'string':
      return ti;
    case 'undefined':
      return '*';
    case 'function':
      ti=o.toString().match(/^function[ ]*\(([^\)]+)\)/);
      if (ti) {
        ti=ti[1].split(',');
        return 'function ('+(ti.map(function (id) { return '@'+id }).join(','))+')';
      } else return 'function'
    case 'object':
      if (Utils.isArray(o)) {
        if (o.length) return Code.typeof(o[0])+'[]';
        else return '[]';
      } else {
        ti=[];
        for(var p in o) {
          ti.push (' '+p+':'+Code.typeof(o[p]));
        }
        return '{'+ti.join(',')+'}';
      }      
  }
}




jQuery.fn.redraw = function() {
    this.css('display', 'none'); 
    var temp = this[0].offsetHeight;
    this.css('display', '');
    temp = this[0].offsetHeight;
};


</script>
    <script type="text/javascript" charset="utf-8">/////////////// WORKER ////////////////////

// !!!!!
// Code.worker: WorkBook WEB Worker inside Browser accessd by WorkBook
// Code.shellworker: Remote Worker serviced by worksh (worksh -p NNN) and accessed by Workbook
var WebWorker = Worker;

Code.worker = {
  commID:0,
  workerID: 0,
  // create a workbook worker loop for code snippet execution (optional id)
  create : function (id,options) {
    options=options||{}
    if (typeof id == 'string') id=id.replace('worker','');
    // Internal id is a number, extern id is tagged (worker#)
    if (Workers[id]) {
      Code.worker.kill(id);
    } else {
      id=Code.worker.workerID++;
    }
    var environment = {
      this:{},
      that:{},
      BrowserVersion:BrowserVersion,
      Utils:Utils,
      Barrier   : Code.barrier.shared,
      Semaphore : Code.semaphore.shared,
      fs        : {
        read    : Utils.read,
        write   : Utils.write,
        get workdir () {
          return FS.workdir;
        } 
      },
      Config : Config,
      FS : FS,
      PATH : PATH,
      Group : Group,
      of : {
        csv     : Utils.ofCSV,
        json    : Utils.ofJSON,
        yaml    : Utils.ofYAML,
      },
      schedule : async function () {
        return new Promise(function (resolve) {
          setTimeout(function () {
            var interrupt=Code.interrupt;
            resolve(!interrupt);
          },1);
        });
      },
      sleep     : async function (milli) {
        return new Promise(function (resolve,reject) {
          var id = Code.waiters.length;
          Code.waiters[id] = {
            reject  : reject,
            timer   : 
              setTimeout(function () {
                delete Code.waiters[id];
                resolve();
              },milli)
          }
        });
      },
      to : {
        csv     : Utils.toCSV,
        json    : Utils.toJSON,
        yaml    : Utils.toYAML,
      },
      DB:DB,
      __toinit : {
        InspectInit     : InspectInit,
        BufferInit      : BufferInit,
        BufferArrayInit : BufferArray.init,
        BufferObjectsInit : BufferObjects.init,
        BufferSegmentInit : BufferSegment.init,
        PapaInit        : Papa.init,
        SprintfInit     : SprintfInit,
        UtilsInit       : Utils._init,
        CodeInit        : function () { self.Code=Code },
        FileInit        : function () { FS.wsconn=null; FS.connect() },
        Signature       : Signature,
        GroupInit       : function () { Group(self) },
      },
      JSONfn:JSONfn,
      URL:DB.dirname(document.URL.replace(/\?[^$]+/,'')),
      __init:function () {
        _=undefined;
        for (var p in __toinit) {
          switch (p) {
            case 'SprintfInit': sprintf=__toinit[p](); break;
            case 'InspectInit': inspect=__toinit[p](); break;
            default:__toinit[p](self)
          }
        }
        window={};
        load=function (url) {
          self.Utils=Utils;
          console.log('Loading script '+URL+'/'+url);
          try {
            importScripts(URL+'/'+url);
          } catch (e) {
            // mimetype issue?
            if (!/\.js$/.test(url)) try {
              url += '.js'; 
              console.log('Loading script '+URL+'/'+url);
              importScripts(URL+'/'+url);            
            } catch (e) {
              console.log('load error: '+e)
            }
          }
        }
        function compile(code,context,data) {
          // contruct functional scope
          // console.log(code);
          var pars = Object.keys(context),
              args = pars.map(function (key) { return context[key] });
          pars.unshift('__dummy');
          if (data!==undefined) { pars.push('__data'); args.push(data) };
          pars.push(code);
          var foo = new (Function.prototype.bind.apply(Function,pars));
          return foo.apply(self,args);
        }
        loadc=function(url,callback) {
          fs.read(URL+'/'+url,'text',function (a,b) {
            compile(a,{Utils:Utils});
            if (callback) callback()
          })
        }
      }
    }
    if (options.environment) {
      for(var p in options.environment) environment[p]=options.environment[p];
    } 
    if (options.init) {
      for(var p in options.init) environment.__toinit[p]=options.init[p];
    } 
    var channelA = Code.channel.create(0),  /* generic master-worker channel (extern) */
        channelB = Code.channel.create(0);  /* rpc reply channel (intern) */
    function workerFunction(id) {
      var self = this;
      // coldstart envrionment
      var Console='';
      var Env = {
        clear : function () {
          self.postMessage({command:'clear',console:Console}) 
        },
        Code : {
          channel : {
            channelID:0,
            channels:[],
            create : function (depth,remoteid) {
              var id = Env.Code.channel.channelID++;
              var chan = {
                waiters : [],
                queue : [],
                idn : id,
                id : 'channel'+id,
                cancel : function () {
                  this.waiters.forEach(function (waiter) {
                    waiter(null);
                  })
                  this.waiters=[];
                },
                enqueue : function (data) {
                  if (this.queue.length==0 && this.waiters.length) {
                    var wakeup = this.waiters.shift();
                    wakeup(data);
                  } else this.queue.push(data);
                },
                // Client API
                destroy : function () {
                  chan.cancel();
                  delete Env.Code.channel.channels[id];
                },
                send: function (data) {
                  if (this.forward) {
                    this.forward(data);
                  } else if (this.queue.length==0 && this.waiters.length) {
                    var wakeup = this.waiters.shift();
                    wakeup(data);
                  } else this.queue.push(data);
                },
                receive : function () {
                  var self=this;
                  if (this.queue.length) return this.queue.shift();
                  // needs await prefix before receive in async function (Code.run)
                  return new Promise(function (resolve) {         
                    self.waiters.push(function (_data) {
                      resolve(_data);
                    });
                  })
                },
              }
              Env.Code.channel.channels[id]=chan;
              return chan;
            },
          },
          interrupt:false,
          kill : function (id) {
            if (id==undefined) {
              // kill them all
              for(var id in Env.Code.tasks) {
                clearInterval(Env.Code.tasks[id]);
                Env.Code.tasks[id]=null;              
              }
            } else if (Env.Code.tasks[id]) {
              clearInterval(Env.Code.tasks[id]);
              Env.Code.tasks[id]=null;
            }
          },
          loop : function () { Env.loop.apply(null,arguments) },
          print : function () { Env.print.apply(null,arguments) },
          stop : function () {
            Code.interrupt=true;
            for(var i in Code.tasks) Code.kill(i);
          },
          tasks: [],
          waiters : [],
        },
        compile : function (code,context,data) {
          if (context) {
            var pars = Object.keys(context),
                args = pars.map(function (key) { return context[key] });
            pars.unshift('__dummy');
            if (data!==undefined) { pars.push('__data'); args.push(data) };
            pars.push(code);
            var foo = new (Function.prototype.bind.apply(Function,pars));
            return foo.apply(self,args);          
          } else {
            var foo = new Function ("return "+code)();
            return foo;
          }
        },
        deserialize : function (data) {
          return JSONfn.deserialize(data)
        },
        emit : function (ev,arg) {
          // Send a user event to main thread
          self.postMessage({command:'event',event:ev,data:arg});
        },
        error: function () { 
          self.postMessage({command:'error',error:toString(Array.prototype.slice.call(arguments)),console:this.Console||Console}) 
        },
        __handler:[],
        iter : function (array,callback,final,async) {
          var counter=0;
          if (typeof final=='boolean') async=final;
          if (!async) {
            for(counter in array) {
              callback(array[counter],counter);
            }
            if (typeof final=='function') final(counter); 
          }
          else {
            var id=Env.Code.tasks.length;
            var timer=setInterval(function () {
              try {
                res=callback(array[counter],counter);
              } catch (e) {
                Env.error(e);
                res=e;
              }
              counter++;
              if (res instanceof Error || counter==array.length) {
                clearInterval(timer); 
                Env.Code.tasks[id]=null;
                if (typeof final=='function') final(counter); 
              }
            },timeout)
            Env.Code.tasks[id]=timer;
            return id;
          }
        },
        kill: function () {
          self.close() 
        },
        later : function (timeout,callback,final) {
          var counter=0,id=Env.Code.tasks.length,self=this;
          if (typeof timeout == 'function') {
            return setTimeout(timeout,0);
          }
          var timer=setInterval(function () {
            try {
              var res=callback.call(self,counter,counter);
            } catch (e) {
              Env.error(e);
              res=0;
            }
            counter++;
            if (!res) {
              clearInterval(timer); 
              Env.Code.tasks[id]=null;
              if (typeof final=='function') 
              try {
                final(counter,counter);
              } catch (e) {
                Env.error(e);
              }
            }
          },timeout)
          Env.Code.tasks[id]=timer;
          return id;
        },
        loop : function (callback,final,async) {
          var counter=0;
          if (typeof final=='boolean') async=final;
          if (!async) {
            while (callback(counter,counter++)) {};
            if (typeof final=='function') final(0,counter,counter); 
          }
          else {
            var id=Env.Code.tasks.length;
            var timeout=1;
            var timer=setInterval(function () {
              try {
                var res=callback(counter,counter);
              } catch (e) {
                Env.error(e);
                res=0;
              }
              counter++;
              if (!res) {
                clearInterval(timer); 
                Env.Code.tasks[id]=null;
                if (typeof final=='function') final(counter,counter); 
              }
            },timeout)
            Env.Code.tasks[id]=timer;
            return id;
          }
        },

        off : function (ev) {
          delete Env.__handler[ev]
        },

        on : function (ev,handler) {
          Env.__handler[ev]=handler;
        },
        
        Plot : function (data,options) {
          if (options.update==undefined && options.id==undefined) options.id=id+'-'+(Env.Plots++);
          self.postMessage({command:'Plot',data:toString([data,options]),console:Console});
          // reference id for plot updates
          return 'plot'+options.id;
        },
  
        Plots : 0 ,
        
        PlotTable : function (table,options) {
          options=options||{};
          if (options.id==undefined) options.id=id+'-'+(Env.Plots++);
          self.postMessage({command:'Plot',data:toString({table:table,id:options.id}),console:Console})
          return 'plot'+options.id;
        },
        
        print: function () { 
          var args=arguments,html,
              msg=Object.keys(args).map(function (index) { return args[index] });
          function nbsp(spaces) {
            var sp='';
            for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
            return sp;
          }
          if (msg.length==1) msg=msg[0]; else msg=msg.join(' , ');
          msg=(msg==undefined?'undefined':msg);
          if (typeof msg == 'object') msg=inspect(msg);

          msg = msg.toString();
          var isHtml = msg[0]=='<' && msg[1]!='B' && msg[msg.length-1]=='>';
          if (isHtml) {
            html=msg;
          } else {
            if (msg.length > 4000) msg=msg.substring(0,2000)+'\n..\n'+msg.substring(2000);
            msg = msg.replace(/</g,'&lt;')
                     .replace(/>/g,'&gt;')
                     .replace(/\n/g,'<br>\n')
                     .replace(/[ ][ ]+/g,nbsp);
            html = '<span style="color:blue">'+msg+'</span>';
          }
          self.postMessage({command:'print',data:html,console:this.Console||Console}) 
        },
        
        printi: function () { 
          var args=arguments,html,
              msg=Object.keys(args).map(function (index) { return args[index] }),
              id = msg.shift();
          if (id==undefined) return Math.random().toString(36).substr(2, 16);
          function nbsp(spaces) {
            var sp='';
            for(var i=0;i<spaces.length;i++) sp += '&nbsp;';
            return sp;
          }
          if (msg.length==1) msg=msg[0]; else msg=msg.join(' , ');
          msg=(msg==undefined?'undefined':msg);
          if (typeof msg == 'object') msg=inspect(msg);

          msg = msg.toString();
          var isHtml = msg[0]=='<' && msg[1]!='B' && msg[msg.length-1]=='>';
          if (isHtml) {
            html=msg;
          } else {
            if (msg.length > 4000) msg=msg.substring(0,2000)+'\n..\n'+msg.substring(2000);
            msg = msg.replace(/</g,'&lt;')
                     .replace(/>/g,'&gt;')
                     .replace(/\n/g,'<br>\n')
                     .replace(/[ ][ ]+/g,nbsp);
            html = '<span style="color:blue">'+msg+'</span>';
          }
          self.postMessage({command:'printi',id:id,data:html,console:this.Console||Console}) 
        },
 
        receive : async function () { return Env.Code.channel.channels[0].receive() },

        _rpcID  : 0,
        _rpcCallbacks:[],
        rpc: async function (op,request,callback,event) {
          var id = Env._rpcID++;
          if (callback) {
            Env._rpcCallbacks[id]=callback;
            // if event == undefined  then the reply is returned immediately (once)
            // if event != undefined then the reply is returned if the event occurs (one ore more times)
            if (event) self.postMessage({command:'rpc',call:op,request:toString(request),id:id,event:event});
            else self.postMessage({command:'rpc',call:op,request:toString(request),id:id});
          } else if (!event) {
            return new Promise(function (resolve,reject) {
              Env._rpcCallbacks[id]=resolve;
              self.postMessage({command:'rpc',call:op,request:toString(request),id:id});
            });
          }
        },

        send  : function (data) { self.postMessage({ command:'send', data:toString(data) }) },

        serialize : function (data) {
          return JSONfn.serialize(data)
        },
        
        status : function () { self.postMessage({ command:'pstatus', data:toString(Array.prototype.slice.call(arguments)) }) },
        
        time : Date.now,
        
        Table : function () {
          self.postMessage({command:'Table',data:toString(Array.prototype.slice.call(arguments)),console:Console})
        },
        
        toString : toString,
        
        write : function (key,val) { 
          self.postMessage({command:'write',key:key,data:toString(val),console:Console});
        },

        /*this : {},*/
        that : {},
        threadID: id,
        verbose : 0,
      };
      Env.sleep = function (time) {
        return new Promise(function (resolve) { setTimeout(function () { resolve(Date.now());}, time)});
      }
      Env.exports=Env;
      var channelA = Env.Code.channel.create(0);  /* generic worker-master channel 0 (extern) */
      function isArray(o) {
        if (o==undefined || o ==null) return false;
        else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
      }
      function isObject(o) {
        return typeof o == "object";
      }
      function isTypedArray(o) {
        return isObject(o) && o.buffer instanceof ArrayBuffer
      }

      function TypedArrayToName(ftyp) {
        if (ftyp==Int8Array   || ftyp instanceof Int8Array) return 'Int8Array';
        if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return 'Uint8Array';
        if (ftyp==Int16Array  || ftyp instanceof Int16Array) return 'Int16Array';
        if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return 'Uint16Array';
        if (ftyp==Int32Array  || ftyp instanceof Int32Array) return 'Int32Array';
        if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return 'Uint32Array';
        if (ftyp==Float32Array || ftyp instanceof Float32Array) return 'Float32Array';
        if (ftyp==Float64Array || ftyp instanceof Float64Array) return 'Float64Array';
        return ftyp.toString()
      }
      
      function ofString(source,mask) {
        var code;
        mask=mask||{}
        try {
          // execute script in private context
          with (mask) {
            eval('"use strict"; code = '+source);
          }
        } catch (e) { console.log(e) };
        return code; 
      }
      function toString(o) {
        var usebuffer=false;
        var p,i,keys,s='',sep,tokens;
        if (o===null) return 'null';
        else if (isArray(o)) {
          s='[';sep='';
          for(p in o) {
            s=s+sep+toString(o[p]);
            sep=',';
          }
          s+=']';
        } else if (typeof Buffer != 'undefined' && o instanceof Buffer) {    
          s='Buffer([';sep='';
          for(i=0;i<o.length;i++) {
            s=s+sep+toString(o[i]);
            sep=',';
          }
          s+='])';  
        } else if (o instanceof Error) {    
          s='(new Error("'+o.toString()+'"))';
        } else if (isTypedArray(o)) {    
          s='(new '+TypedArrayToName(o)+'([';sep='';
          var b=Array.prototype.slice.call(o);
          for(i=0;i<b.length;i++) {
            s=s+sep+String(b[i]);
            sep=',';
          }
          s+=']))';  
        } else if (typeof o == 'object') {
          s='{';sep='';keys=Object.keys(o);
          for(i in keys) {
            p=keys[i];
            if (o[p]==undefined) continue;
            s=s+sep+"'"+p+"'"+':'+toString(o[p]);
            sep=',';
          }
          s+='}';
          if (o.__constructor__) s = '(function () { var o='+s+'; o.__proto__='+o.__constructor__+'.prototype; return o})()';
        } else if (typeof o == 'string')
          /* TODO: JSON */
          s="'"+
            o.toString().replace(/'/g,'\\\'')
                        .replace(/\n/g,'\\n')+
            "'"; 
        else if (typeof o == 'function') {
          s=o.toString(true);   // try minification (true) if supported by platform
          if (tokens=s.match(/function[ ]+([a-zA-Z0-9]+)[ ]*\(\)[ ]*{[^\[]*\[native code\][^}]*}/)) {
            return tokens[1];
          } else return s;
        } else if (o != undefined)
          s=o.toString();
        else s='undefined';
        return s;
      }
      var self=this;
      function compile(code,context,data) {
        // contruct functional scope
        // console.log(code);
        Code.interrupt=false;
        var pars = Object.keys(context),
            args = pars.map(function (key) { return context[key] });
        pars.unshift('__dummy');
        if (data!==undefined) { pars.push('__data'); args.push(data) };
        pars.push(code);
        var foo = new (Function.prototype.bind.apply(Function,pars));
        return foo.apply(self,args);
      }

      function execute (code,_console) {
        var exports;
        if (typeof code == 'string' && (exports=code.match(/export {([^}]+)}/))) {
          code=code.replace(/export {([^}]+)}/,'');       
          exports[1].split(',').forEach(function (exporting) {
            code += ('exports["'+exporting.trim()+'"]='+exporting.trim()+';');
          })
        }
        return compile('var __error=error,__print=print,__printi=printi,__status=status;  (async function () { var Console="'+(_console||'')+
                       '";var print=__print.bind({Console:Console}), printi=__printi.bind({Console:Console}), status=__status.bind({Console:Console}), error=__error.bind({Console:Console}); if (verbose) print("Run in worker #'+
                       id+'")\ntry {'+code+'} catch (e) {__error.call({Console:"'+(_console||'')+'"},e.toString(),e.stack)}}).call(this)',Env);
      }
      function expression (code,_console) {
        // execute command (line), send result to parent process (print result via reply message)
        var result;
        result = compile ('try { var __error=error; var Console="'+_console+
                          '";\n'+
                          code+
                          '} catch (e) { __error(e.toString(),e.stack) }',Env);  
        return result;
      }
      /* evaluate an expression (not a function) */
      function evali (code,assign,_console) {
        // execute command (line), send result to parent process (print result via reply message)
        var result;
        result = compile ('try { var __error=error; var Console="'+_console+
                          '";\n'+
                          (assign?assign+'=':'')+
                          code+
                          '} catch (e) { __error(e.toString(),e.stack) }',Env);  
        return result;
      }
      /* evaluate a function with optional data (function can be asynchronous, but rpc-op is synch.) */
      function evalf (code,data,assign,_console,_id) {
        // execute function with arguments (data,ports), optional assignment of result, and send result to parent process via evals message
        // support shareable data
        var result,isasync=/^[ ]*async[ ]+function/.test(code);
        if (data==undefined) data=null;
        result = compile ('try { var __result=true,__error=error,__print=print,__printi=printi,__status=status; var Console="'+_console+
                         '";'+
                         (assign?
                           (isasync? '(async function () { '+
                                     'var print=__print.bind({Console:Console}), printi=__printi.bind({Console:Console}),status=__status.bind({Console:Console}),error=__error.bind({Console:Console}); '+ 
                                     assign+' = await '
                           : assign+' = ')
                         : (isasync? '(async function () { '+
                                     'var print=__print.bind({Console:Console}), printi=__printi.bind({Console:Console}),status=__status.bind({Console:Console}),error=__error.bind({Console:Console}); try { __result=await ' 
                            : '__result=')
                         )+
                         '('+
                         code+
                         ')(__data)'+
                         (isasync && !assign?'} catch (e) {__error(e.toString(),e.stack)};if (__result===undefined) __result=null;self.postMessage({command:"evals",status:toString(__result),id:'+_id+'});'
                          :'')+
                         (isasync? '})()'
                          : '')+
                         '} catch (e) { console.log(e); __error(e.toString(),e.stack) }; return __result',Env,data);
        return result;      
      }
      // Proecss messages from master
      self.onmessage = function(e) {
        var o,data,key,reply;
        try {
          var message = e.data;
          switch (message.command) {
            case 'environment':
              data = ofString(message.data,Env);
              for(key in data) {
                if (key=='this' || key=='that') continue;
                Env[key]=data[key];
              }
              if (typeof Env.__init == 'function') {
                with (Env) { eval ('__init()') }
              }
              self.FS=Env.FS;
              self.PATH=Env.PATH;
              Env.print('Worker #'+id+': got environment');
              break;
            case 'execute':
              // execute script
              // console.log(e.data)
              execute(message.code,message.console);
              break;
            case 'eval':
              var result = expression(message.code,message.console);
              if (result===undefined) result=null;
              if (message.code[message.code.length-1]!=';')
                self.postMessage({command:'print',data:toString([result]),console:e.data.console});
              break;
            case 'evali':
              // execute statement or expression (line), return result to parent process via evals message
              var result = expression(message.code,message.assign,message.console);
              if (result===undefined) result=null;
              self.postMessage({command:'evals',status:toString(result),id:message.id});
              break;
            case 'evalf':
              var result = evalf(message.code,message.data, message.assign,message.console,message.id);
              if (!/^[ ]*async[ ]+function/.test(message.code)) {
                if (result===undefined) result=null;            
                self.postMessage({command:'evals',status:toString(result),id:message.id});
              }
              break;
            case 'event':
              if (Env.__handler[message.event]) {
                with (Env) { Env.__handler[message.event](ofString(message.data,Env)); }
              }
              break;
            case 'monitor':
              // get the signature of an object for monitoring
              function signature (data,level) {
                var sig = typeof data;
                if (sig == 'object') {
                  if (isArray(data)) {
                    sig=[];
                    if (level && data.length && data[0]!=undefined) sig = [signature(data[0],level-1)];
                  } else {
                    sig={}
                    if (level) Object.keys(data).map(function (key) {
                      sig[key]=signature(data[key],level-1);
                    });
                  }
                }
                return sig;
              }
              data=compile('return '+message.key,Env);
              reply = {
                command : 'monitor',
                data : {
                  typ     : typeof data,
                  sig     : signature(data,message.level||1),
                }
              }
              // Env.print(reply);
              self.postMessage(reply);
              break;
            case 'read':
            case 'reads':
              data=compile('return '+message.key,Env);
              if (data===undefined) data=null;
              reply={
                command : message.command,
                data    : Env.Utils.toString(data), 
              };
              self.postMessage(reply);            
              break;
            case 'rpc':
              // reply for an rcp request
              data = ofString(message.reply);
              if (Env._rpcCallbacks[message.id]) {
                var handler = Env._rpcCallbacks[message.id];
                if (!message.event && !message.more) delete Env._rpcCallbacks[message.id];
                /* TODO */
                handler(data)
              }
              break;
            case 'send':
              /* channel communication */
              data = ofString(message.data,Env);
              if (Code.channel.channels[data.channelid])
                Code.channel.channels[data.channelid].enqueue(data.data);
              break;
            case 'share':
              // get root destination object (this,...)
              // (eval(root))[key]=message.data;
              // Env.print(message);
              if (message.eval) {
                evalf(message.eval,message.data,message.key,message.console);
              } else {
                var parts = message.key.split('.'),
                    key  = parts.pop(),
                    root = parts.join('.');
                var rootObj=compile('return '+root, Env);
                rootObj[key]=message.data;
              }
              break;
            case 'signal':
              if (message.signal=='SIGINT') Env.Code.stop();
              Env.print('Got signal '+message.signal);
              break;
            case 'status':
              self.postMessage({command:'status',status:Env.Utils.toString(['Worker #'+id+' is alive!']),commid:e.data.commid});            
              break;
            case 'write':
              compile(message.key+'='+message.data+';', Env);
              break;
            case 'console':
            case 'data':
            case 'commid':
              break;
            default:
              Env.error('Worker #'+id+': Invalid request '+message.command);            
          }
        } catch (e) {
          Env.error(e.toString(),e.stack.toString());            
        }
      }
      self.postMessage({command:'event',event:'ready'+id});
      Env.print('Worker #'+id+' started.');
    }
    var dataObj = '(' + workerFunction.toString() + ')('+id+');'; // here is the trick to convert the above fucntion to string
    var blob;
    try {
        blob = new Blob([dataObj.replace('"use strict";', '')], {type: 'application/javascript'});
    } catch (e) { 
        // Backwards-compatibility
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(dataObj.replace('"use strict";', ''));
        blob = blob.getBlob();
    }

    var blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
        type: 'application/javascript; charset=utf-8'
    });

    var worker = new WebWorker(blobURL); // spawn new worker

    console.log('Worker '+id+' started.');

    // Process messages from worker
    worker.onmessage = function(e) {
      var _console = ConsoleOutput;
      worker.stats.recv++;
      // console.log('[Worker'+id+']', e.data); // message received from worker
      var message = e.data;
      if (message.console && message.console.indexOf('code')==0) ConsoleOutput=$(message.console);
      if (message.console && message.console.indexOf('#')==0) ConsoleOutput=$(message.console);
      switch (message.command) {
        case 'clear':
          Cell.clearConsole(message.console.match(/(code[0-9]+)$/)[1]);
          break;
        case 'error':
          Code.error.apply(null,Utils.ofString(message.error));
          break;
        case 'evals':
          /* reply for a rpc */
          channelB.enqueue(Utils.ofString(message.status));
          break;
        case 'event':
          Code.worker.emit(message.event,message.data);
          break;
        case 'monitor':
          channelB.enqueue(Utils.isObject(message.data)?message.data:Utils.ofString(message.data));
          break;
        case 'Plot':
          var data = Utils.ofString(message.data);
          if (data && data[1] && data[1].clear && message.console) 
            Cell.clearConsole(data.console.match(/(code[0-9]+)$/)[1]);
          if (Utils.isArray(data))
                Plot.create.apply(null,data);
              else if (data.table) 
                Plot.table(data.table,{id:data.id}); 
          break;
        case 'print':
          if (message.console && message.console.indexOf('terminal')==0) Terminals[message.console].env.print(message.data);
          else Code.print(message.data);
          break;
        case 'printi':
          Code.printi(message.id,message.data);
          break;
        case 'pstatus':
          var args = Utils.ofString(message.data);
          Code.status.apply(null,args);
          break;
        case 'read':
        case 'reads':
          /* reply for a rpc */
          channelB.enqueue(Utils.ofString(message.data));
          break;
        case 'rpc':
          if (!options.rpc) worker.postMessage({command:'rpc',reply:Utils.toString({error:"ENORPC"})});
          var request = Utils.ofString(message.request);
          // console.log('RPC',message)
          if (!options.rpc[message.call]) worker.postMessage({command:'rpc',reply:Utils.toString({error:"ENOTEXIST"}),id:message.id});
          try {
            if (!message.event) {
              // synchronous request with immediate reply
              var reply = options.rpc[message.call](request);
              worker.postMessage({command:'rpc',reply:Utils.toString(reply),id:message.id})
            } else {
              // install asynchronous background event emitter
              options.rpc[message.call](request,message.event,function (reply,more) {
                worker.postMessage({command:'rpc',reply:Utils.toString(reply),id:message.id,event:message.event,more:more})
              });
            }
          } catch (e) {
            worker.postMessage({command:'rpc',reply:Utils.toString({error:e.toString()}),id:message.id})
          }
          break;
        case 'send':
         /* explicit channel communication */
          var c=message.channelid==undefined?channelA:Code.channel.channels[message.channelid];
          if (c) c.enqueue(Utils.ofString(message.data));
          break;
        case 'status':
          /* reply for a rpc */
          channelB.enqueue(Utils.ofString(message.status));
          break;
        case 'Table':
          Table.apply(null,Utils.ofString(message.data));
          break;
        case 'write':
          try { jsScope.run(message.key+'='+message.data,{error:Code.error},true) } catch (err) { console.log(err) };
          break;
      }
      ConsoleOutput=_console;
    };
    worker.stats={
      recv:0,
      send:0,
    }
    // Send environment
    worker.postMessage({command:'environment',data:Utils.toString(environment)}); // Send data to our worker. 
    worker.stats.send++;
    worker.channelA=channelA;
    worker.channelB=channelB;
    Workers[id] = worker;
    worker.cancel = function () {
      channelA.cancel();
      channelB.cancel();
    };
    /* generic comm. channel */
    worker.receive = async function () {
      return channelA.receive();
    };
    /* sync. request reply channel */
    worker.reply = async function (cb) {
      return channelB.receive(cb);
    };
    worker.run = function (code,console) {
      if (console && console.match(/^code/)) console='#code-output_subarea'+console;
      worker.postMessage({command:'execute',code:code.toString(),console:console});
    };
    worker.send = function (data) {
      worker.stats.send++;
      worker.postMessage({command:'send',data:Utils.toString(data)});
    };
    worker.state=1;
    // prelimenary ready event handler
    Code.worker.on('ready'+id,function () {
      worker.state=2;
      Code.worker.off('ready'+id);
    });
    return 'worker'+id;  
  },
  
  // cancel receiving channel waiters
  cancel : function (id) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return error('receive: No such worker #'+id);
    var worker=Workers[id];
    return worker.cancel();
  },

  // Emit main-thread event ot from worker
  emit : function (ev,data) {
    if (typeof Code.worker.handlers[ev] == 'function') {
      Code.worker.handlers[ev](data);
      if (!isNaN(Number(ev))) delete Code.worker.handlers[ev];
    } else if (typeof Code.worker.handlers[ev] == 'object') {
      for(var i in Code.worker.handlers[ev]) {
        if (!Code.worker.handlers[ev]) break; // event handler removed by handler?
        if (Code.worker.handlers[ev][i]) Code.worker.handlers[ev][i](data);
      }
      if (!isNaN(Number(ev))) delete Code.worker.handlers[ev];
    }
  },

  // Send event signal to worker
  emitTo : function (id,ev,data) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('emitTo: No such worker #'+id);
    var worker=Workers[id];
    worker.postMessage({command:'event',event:ev,data:data});  
  },

  // Evalue an expression or statement on worker (with optional target assignment) and wait for result (true if assign)
  eval : async function (id,code,assign,cb) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return;
    if (typeof assign == 'function') { cb=assign; assign=undefined };
    var worker=Workers[id];
    var console=ConsoleId;
    if (console && console.match(/^code/)) console='#code-output_subarea'+console;
    // wait for reply
    worker.postMessage({command:'evali',code:code,assign:assign,id:id,console:console});
    return worker.reply(cb);
  },
  // Evaluate a function (with optional target assignment) on worker and wait for result (true if assign)
  // function can be asynchronous contanining await statements (returns always true, but supports sync. assign)!
  evalf : async function (id,fun,data,shared,assign,cb) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return;
    if (typeof assign == 'function') { cb=assign; assign=undefined };
    var console=ConsoleId;
    if (console && console.match(/^code/)) console='#code-output_subarea'+console;
    var worker=Workers[id];
    // wait for reply
    worker.postMessage({command:'evalf',code:fun.toString(),data:data,assign:assign,id:id,console:console},shared); 
    return worker.reply(cb);
  },

  get : function (id) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('get: No such worker #'+id);
    return Workers[id];
  },
  
  handlers : {},

  kill : function (id) {
    if (typeof id == 'string') id=id.replace('worker','');
    var worker=Workers[id];
    if (!worker) return Code.error('kill: No such worker #'+id);
    if (worker.state==-1) return;
    worker.terminate();
    worker.state=-1;
    Code.print('Killed worker #'+id);
    delete Workers[id];
  },
  
  // Create an auto data monitor for a remote objects.
  // All scalar values are returned as a copy, all objects are iterated until a given depth.
  // The level parameters defines the maximal depth of the monitor object iterator.
  // All attribute values below this depth will always be returned as a data copy!
  // reading an object is an asynchronous function returning a promise for that can be waited for:
  // (await mon.x.y).a
  // Waiting for a promise is only possible on object endpoints (depth!)
    
  monitor : async function (id,key,level,verbose) {
    if (typeof id == 'string') id=id.replace('worker','');
      var o;
      level=level||1;
      // print('Monitor',key);
      var signature = await Code.worker.signature(id,key,level);
      if (verbose) Code.print(signature);
      function construct(key,sig,level) {
        var o,selector = {}
        if (verbose) Code.print('construct',key,sig,level)
        switch (typeof sig) {
          case 'object':
            if (Utils.isArray(sig)) {
              if (verbose) Code.print('construct []',key)
              selector=function (name) {
                if (name==[]) {
                  // get all elements
                  if (verbose) Code.print(id,key)
                  return Code.worker.read(id,key)                                
                } else if (name!='length' && name != 'then') {
                  name='['+name+']';
                  if (verbose) Code.print(id,key,name)
                  return Code.worker.read(id,key+name)
                } else if (name != 'then') {
                  if (verbose) Code.print(id,key,name)
                  return Code.worker.read(id,key+'.'+name)                
                }
              }
            
            } else Object.keys(sig).forEach(function (name) {        
              // print('selector',key,name,sig[name],level)
              switch (sig[name]) {
                case 'number':
                case 'string':
                case 'boolean':
                  selector[name]=function () { return Code.worker.read(id,key+'.'+name)};
                  break;
                default:            
                  if (typeof sig[name]=='object') {
                    if (Utils.isArray(sig[name])) {
                      if (level && sig[name].length && typeof sig[name][0]!='string') {
                        // TODO: should arrays be indexed? only for object arrays???
                        // how get we the length of an array?
                        // TODO: select all elements selector!?!?  array[[]]!!! DONE
                        var next =  construct(key+'.'+name,[],0 /* stop here definetely */);
                        selector[name]=function () { return next };                       
                      } else {
                        if (verbose) Code.print('construct []',key,name)
                        selector[name]=function () { 
                          if (verbose) Code.print(id,key,name)
                          return Code.worker.read(id,key+'.'+name)
                        }
                      }
                    } else if (level) {
                      var next =  construct(key+'.'+name,sig[name],level-1);
                      selector[name]=function () { return next };
                    } else selector[name]=function () {
                      if (verbose) Code.print(id,key,name)
                      return Code.worker.read(id,key+'.'+name) 
                    };
                  }
              }   
            });
            // print(selector)
            o = new Proxy({},{
              get : function (target,name) {
                if (verbose) Code.print('get',key,name,typeof name,selector)
                if (typeof selector == 'function') return selector(name); 
                if (!selector[name]) return;
                return selector[name]();
              },
              set : function (target,name,val) {
                if (verbose) Code.print('set',key,name)
                return Code.worker.write(id,key+'.'+name,val)
              }
            });
            return o;
            break;
        }
    }
    return construct(key,signature.sig,level-1);
  },
  
  off : function (ev,f) {
    if (!Code.worker.handlers[ev]) return;
    if (f) {
      if (typeof Code.worker.handlers[ev]=='function' && f===Code.worker.handlers[ev])
        delete Code.worker.handlers[ev]; 
      else if (typeof Code.worker.handlers[ev]=='object') {
        for(var i in Code.worker.handlers[ev])
          if (f===Code.worker.handlers[ev][i]) delete Code.worker.handlers[ev][i]; 
      }
    } else delete Code.worker.handlers[ev];  
  },
  
  on : function (ev,handler) {
    if (Code.worker.handlers[ev]) {
      if (typeof Code.worker.handlers[ev]=='function')
        Code.worker.handlers[ev]=[handler,Code.worker.handlers[ev]];
      else Code.worker.handlers[ev].unshift(handler);
    } else Code.worker.handlers[ev]=handler;
  },
  
  // Read data from worker (sync/async)
  read : async function (id,key,cb) {
    if (typeof id == 'string') id=id.replace('worker','');
    var dst;
    if (!Workers[id]) return Code.error('read: No such worker #'+id);
    var commid=Code.worker.commID++;
    if (typeof cb == 'string') {
      dst=cb;
      cb=function (res) {
        try {
          jsScope.run(dst+'='+res,{});
        } catch (e) { console.log(e) }
      }
      return Workers[id].reply(cb);
    } else {
      Workers[id].postMessage({command:dst?'reads':'read',key:key,commid:commid});
      return Workers[id].reply(cb);
    }
  },

  // wait for worker to be started and ready to receive messages
  ready : async function (id,cb) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('read: No such worker #'+id);
    var worker=Workers[id];
    if (worker.state==2) {
      if (cb) return cb(true);
      else return true;
    }
    if (cb) Code.worker.on('ready'+id,cb);
    else {
      // needs await prefix before receive in async function (Code.run)
      return new Promise(function (resolve) { 
        Code.worker.on('ready'+id,function () {
          // console.log('ShellWorker ready event',id);
          worker.state=2;
          Code.worker.off('ready'+id);
          resolve(true);
        });
      });
    }  
  },

  receive : function (id) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('receive: No such worker #'+id);
    var worker=Workers[id];
    return worker.receive();
  },

  // code can be script text or a synchronous function called with an optional argument
  // The argument is passed serialised embedded in the script code. 
  // no reply is returned
  run : function (id,code,arg) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('run: No such worker #'+id);
    var worker=Workers[id];
    if (typeof code == 'function') {
      var console=ConsoleId;
      if (console && console.match(/^code/)) console='#code-output_subarea'+console;
      if (arg==undefined)
        worker.postMessage({command:'execute',code:'var ret=('+code.toString()+').call(this); if(ret instanceof Promise) ret.catch(error);',console:console});
      else
        worker.postMessage({command:'execute',code:'var ret=('+code.toString()+').call(this,'+JSON.stringify(arg)+'); if(ret instanceof Promise) ret.catch(error);',console:console});
    } else {
      var console=arg==undefined?ConsoleId:arg;
      if (console && console.match(/^code/)) console='#code-output_subarea'+console;
      return worker.postMessage({command:'execute',code:code.toString(),console:console});
    }
  },

  // listen on multiple worker channelAs in parallel
  // returns the data from the first ready channel
  select : async function (workerIDs) {
    var workers = workerIDs.map(function (id) {
      if (typeof id == 'string') id=id.replace('worker','');
      if (!Workers[id]) throw ('Code.worker.select: Invalid worker id '+id);
      return Workers[id] 
    });
    return new Promise(function (resolve,reject) {
      function handler(data) {
        workers.forEach(function (w) { w.channelA.off('receive') }) 
        resolve(data)  
      }
      workers.forEach(function (w) { w.channelA.on('receive',handler) })
    })
  },

  // Send raw data to worker (no string serialization) with optional code evaluation (i.e., desserialization)
  // Transferrable objects (buffer objects, shared arrays, typedarrays with shared arrays)
  share : function (id,key,data,eval) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return;
    var worker=Workers[id];
    if (!eval && typeof data == 'object' && typeof data.__share == 'function') {
      var share = data.__share();  // remote: key=eval(data)
      data=share.data;
      eval=share.eval;
    }
    // console.log({command:'share',key:key,data:data,eval:eval});
    worker.postMessage({command:'share',key:key,data:data,eval:eval?eval.toString():undefined});
    return;
  },

  send : function (id,data) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('sned: No such worker #'+id);
    var worker=Workers[id];
    worker.postMessage({command:'send',data:Utils.toString({data:data, channelid:0})});  
  },

  signal : function (id,signal,data) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('signal: No such worker #'+id);
    var worker=Workers[id];
    worker.postMessage({command:'signal',signal:signal,data:data});  
  },

  // GET A REMOT OBJECT SIGNATURE UP TO DEPTH LEVEL
  signature : async function (id,key,level,cb)  {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('signature: No such worker #'+id);
    Workers[id].postMessage({command:'monitor',key:key,level:level||1});
    return Workers[id].reply(cb);
  },
  
  status : function (id,cb) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('status: No such worker #'+id);
    if (typeof cb != 'function') return Code.error('status: Requires callback handler!');
    var worker=Workers[id];
    var commid=Code.worker.commID++;
    worker.postMessage({command:'status',status:1,commid:commid});
    return worker.reply();
  },

  statistics : function (id) {
    var worker=Workers[id];
    return worker.stats;
  },

  stop : function (id) {
    Code.worker.signal(id,'SIGINT');  
  },
  
  write : function (id,key,val) {
    if (typeof id == 'string') id=id.replace('worker','');
    if (!Workers[id]) return Code.error('Code.worker.write: unknown worker');
    var worker=Workers[id];
    return worker.postMessage({command:'write',key:key,data:Utils.toString(val)});  
  },
  
  version : '1.13.1'
  
}


// Universial Channel IPC Object (superclass, only two end-points)
// Requires message wrapping for webworker/remote sharing 
// blocking code operations using async/await
Code.channel = {
  channelID:0,
  channels:[],
  create : function () {
    var id = Code.channel.channelID++;
    var chan = {
      waiters   : [],
      handlers : {},
      queue     : [],
      idn       : id,
      id        : 'channel'+id,
      cancel : function () {
        this.waiters.forEach(function (waiter) {
          waiter(null);
        })
        this.waiters=[];
        this.queue=[];
      },
      destroy : function () {
        chan.cancel();
        delete Code.channels[id];
      },
      // enqueue received data
      enqueue: function (data) {
        if (this.queue.length==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else if (this.handlers.receive) {
          this.handlers.receive(data);
        } else this.queue.push(data);
      },
      on : function (ev,handler) { this.handlers[ev]=handler },
      off : function (ev) { delete this.handlers[ev] },
      // client API
      send: function (data) {
        if (this.forward) {
          this.forward(data);
        } else if (this.queue.length==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else this.queue.push(data);
      },
      receive : async function (cb) {
        var self=this;
        if (cb) {
          if (this.queue.length) return cb(this.queue.shift());
          else return this.waiters.push(cb);
        }
        if (this.queue.length) return this.queue.shift();
        // needs await prefix before receive in async function (Code.run)
        return new Promise(function (resolve,reject) {         
          self.waiters.push(function (_data) {
            if (_data===undefined) reject(); // interrupted
            else resolve(_data);
          });
        })
      },
      receiver : function (cb) {
        this.handlers.receive=cb;
      }
    }
    Code.channel.channels[id]=chan;
    return chan;
  }
}
// Message channel between web workers (or worker <-> main)
// Uses channel pairs.
Code.msgchannel = {
  channelID:0,
  channels:[],
  create : async function (worker1,name1,worker2,name2) {
    var id = Code.msgchannel.channelID++,
        typ1 = worker1==undefined || worker1=='main'?'main':/^shellworker/.test(worker1)?'shell':'web',
        typ2 = worker2==undefined || worker2=='main'?'main':/^shellworker/.test(worker2)?'shell':'web',
        channel,
        msgchannel=new MessageChannel();;
        
    if (typ1=='shell' || typ2=='shell') return Code.error('Code.msgchannel.create: ShellWorker are not supported by this module.');
    if (typ1=='main' || typ2=='main') {
      // master-worker channel
      channel = Code.channel.create();
      msgchannel.port1.onmessage = function(event) {
        // Received data message; forward to this side channel
        channel.enqueue(event.data); 
      };
      channel.forward = function (data) {
        // send on private channel
        msgchannel.port1.postMessage(data);
      };
      if (typ1=='web') {
        await Code.worker.evalf(worker1,function (data) {
          var port = data.port, channel = Code.channel.create();
          channel.forward = function (data) {
            port.postMessage(data);
          };
          data.port.onmessage = function (event) {
            channel.enqueue(event.data); 
          };
          return channel;
        },{port:msgchannel.port2},[msgchannel.port2],name1);
      }
      if (typ2=='web') {
        await Code.worker.evalf(worker2,function (data) {
          var port = data.port, channel = Code.channel.create();
          channel.forward = function (data) {
            port.postMessage(data);
          };
          data.port.onmessage = function (event) {
            channel.enqueue(event.data); 
          };
          return channel;
        },{port:msgchannel.port2},[msgchannel.port2],name2);
      }
    } else {
      // worker-worker channel
        await Code.worker.evalf(worker1,function (data) {
          var port = data.port, channel = Code.channel.create();
          channel.forward = function (data) {
            port.postMessage(data);
          };
          data.port.onmessage = function (event) {
            channel.enqueue(event.data); 
          };
          return channel;
        },{port:msgchannel.port1},[msgchannel.port1],name1);
        await Code.worker.evalf(worker2,function (data) {
          var port = data.port, channel = Code.channel.create();
          channel.forward = function (data) {
            port.postMessage(data);
          };
          data.port.onmessage = function (event) {
            channel.enqueue(event.data); 
          };
          return channel;
        },{port:msgchannel.port2},[msgchannel.port2],name2);
    }
    return channel; // returns channel if worker1=="main"
  }
}
Code.barrier = {
  // can only be used in workers
  shared : function Barrier (sab,N,offset,id) {
    var self={}
    offset=offset||0;
    if (typeof sab == 'number') { N=sab; sab=null }
    var LOCKED=1, UNLOCKED=0;
    if (!sab) sab=new SharedArrayBuffer(16);
    if (id==undefined) id = Utils.uniqueID(16);
    self.__id=id;
    self._mu  = new Int32Array(sab,offset,4);
    if (N != undefined) {
      self._mu[1]=0;
      self._mu[2]=LOCKED;
      self._mu[3]=N;
    } else {
      N=self._mu[3];
    }
    self.lock = function () {
      for(;;) {
        if (Atomics.compareExchange(self._mu, 0, UNLOCKED, LOCKED) == UNLOCKED) {
          return;
        }
        Atomics.wait(self._mu, 0, LOCKED);
      }
    }
    self.unlock = function () {
      if (Atomics.compareExchange(self._mu, 0, LOCKED, UNLOCKED) != LOCKED) {
        throw new Error("Barrier.Lock is in inconsistent state: unlock on unlocked Mutex.");
      }
      if (Atomics.notify) Atomics.notify(self._mu, 0,1);
      else Atomics.wake(self._mu, 0,1);  // old comp.
    }
    self.join = function () {
      self.lock()
      if (Atomics.load(self._mu,1)<(N-1)) {
        Atomics.add(self._mu, 1, 1);
        Atomics.store(self._mu, 2, LOCKED);
        self.unlock()
        if (Atomics.load(self._mu,2)==LOCKED) 
          Atomics.wait(self._mu, 2, LOCKED);
        Atomics.sub(self._mu, 1, 1);
        return;
      } else {
        // release barrier; start down protocol
        Atomics.store(self._mu, 2, UNLOCKED);
        for(var i=N-1;i>=1;i--) {
          if (Atomics.notify) Atomics.notify(self._mu, 2, 1);
          else Atomics.wake(self._mu, 2, 1);  // old comp.   
          // Atomics.wait(self._mu, 1, i);
          while (Atomics.load(self._mu, 1)==i) {}       
        }
        self.unlock()
        return
      }
    }
    self.level = function () { return self._mu[1] },
    self.__share = function () { return {
      data : {
        offset : offset,
        id : id,
        barrier:Utils.serialize({
          Barrier : Barrier
        }),
        sab:sab
      },
      eval : function (data) {
        var barrier = Utils.deserialize(data.barrier)
        return barrier.Barrier(data.sab,data.offset,data.id)
      }
    }}
    return self
  }
}
Code.mutex = {
  // only sharable between workers; Requires 4 bytes
  shared : function Mutex (sab,offset,id) {
    var self={}
    offset=offset||0;
    var LOCKED=1, UNLOCKED=0;
    if (!sab) sab=new SharedArrayBuffer(4);
    if (id==undefined) id = Utils.uniqueID(16);
    self.__id=id;
    self._mu  = new Int32Array(sab,offset,1);
    self.lock = function () {
      for(;;) {
        if (Atomics.compareExchange(self._mu, 0, UNLOCKED, LOCKED) == UNLOCKED) {
          return;
        }
        Atomics.wait(self._mu, 0, LOCKED);
      }
    }
    self.unlock = function () {
      if (Atomics.compareExchange(self._mu, 0, LOCKED, UNLOCKED) != LOCKED) {
        throw new Error("Mutex is in inconsistent state: unlock on unlocked Mutex.");
      }
      if (Atomics.notify) Atomics.notify(self._mu, 0,1);
      else Atomics.wake(self._mu, 0,1);  // old comp.
    }
    self.__share = function () { return {
      data : {
        mutex:Utils.serialize({
          Mutex : Mutex
        }),
        offset : offset,
        id : id,
        sab:sab
      },
      eval : function (data) {
        var mutex = Utils.deserialize(data.mutex)
        return mutex.Mutex(data.sab,data.offset,data.id)
      }
    }}
    return self
  }
}

Code.semaphore = {
  semaphoreID:0,
  semaphores:[],
  // only main thread 
  create : function (init) {
    var id = Code.semaphore.semaphoreID++;
    var sem = {
      waiters   : [],
      idn       : id,
      id        : 'semaphore'+id,
      counter   : init,
      cancel : function () {
        this.waiters.forEach(function (waiter) {
          waiter();
        })
        this.waiters=[];
      },
      destroy : function () {
        this.cancel();
        delete Code.semaphores[id];
      },
      // client API
      release: function (data) {
        if (this.forward) {
          this.forward();
        } else if (this.counter==0 && this.waiters.length) {
          var wakeup = this.waiters.shift();
          wakeup(data);
        } else this.counter++;
      },
      acquire : async function (cb) {
        var self=this;
        if (cb) {
          if (this.counter) { this.counter--; return cb()}
          else return this.waiters.push(cb);
        }
        if (this.counter) return --this.counter;
        // needs await prefix before receive in async function (Code.run)
        return new Promise(function (resolve) {         
          self.waiters.push(function (_data) {
            resolve();
          });
        })
      },
    }
    Code.semaphore.semaphores[id]=sem;
    return sem;
  },
  // Only sharable between workers! Requires 16 bytes
  shared : function Semaphore (sab,init,offset,id) {
    var self={}
    offset=offset||0;
    if (typeof sab == 'number') { init=sab; sab=null }
    var LOCKED=1, UNLOCKED=0;
    if (!sab) sab=new SharedArrayBuffer(16);
    if (id==undefined) id = Utils.uniqueID(16);
    self.__id=id;
    self._mu  = new Int32Array(sab,offset,4);
    if (init!= undefined) {
      self._mu[1] = init; 
      if (init==0) self._mu[2]=LOCKED;
      else self._mu[2]=UNLOCKED;
    }
    self.lock = function () {
      for(;;) {
        if (Atomics.compareExchange(self._mu, 0, UNLOCKED, LOCKED) == UNLOCKED) {
          return;
        }
        Atomics.wait(self._mu, 0, LOCKED);
      }
    }
    self.unlock = function () {
      if (Atomics.compareExchange(self._mu, 0, LOCKED, UNLOCKED) != LOCKED) {
        throw new Error("Semaphore.Lock is in inconsistent state: unlock on unlocked Mutex.");
      }
      if (Atomics.notify) Atomics.notify(self._mu, 0, 1);
      else Atomics.wake(self._mu, 0, 1);  // old comp.
    }
    self.acquire = function () {
      for(;;) {
        self.lock()
        // print('acquire='+self._mu[1]);
        if (self._mu[1]==0) {
          Atomics.store(self._mu, 2, LOCKED);
          self.unlock()
          Atomics.wait(self._mu, 2, LOCKED);
          continue;
        } else {
          self._mu[1]--;
          self.unlock()
          return
        }
      }    
    }
    self.release = function () {
      self.lock()
      // print('release='+self._mu[1]);
      if (self._mu[1]==0) {
        self._mu[1]++;
        Atomics.store(self._mu, 2, UNLOCKED);
        if (Atomics.notify) Atomics.notify(self._mu, 2, 1);
        else Atomics.wake(self._mu, 2,1);  // old comp.
      } else {
        self._mu[1]++;
      }
      self.unlock()  
    }
    self.level = function () { return self._mu[1] },
    self.__share = function () { return {
      data : {
        offset : offset,
        id : id,
        sema:Utils.serialize({
          Semaphore : Semaphore
        }),
        sab:sab
      },
      eval : function (data) {
        var sema = Utils.deserialize(data.sema)
        return sema.Semaphore(data.sab,null,data.offset,data.id)
      }
    }}
    return self
  }
}

// call with await prefix
Code.sleep = function (time) {
  return new Promise(function (resolve) { setTimeout(function () { resolve(Date.now());}, time)});
}

</script>
    <script type="text/javascript" charset="utf-8">// Remote Worker Processes API (worksh workers)
ShellWorker = {
  commID  : 0,
  workerID: 0,
  workers : [],
  handlers : [],
  wsconn : [],
  
  // Support http and ws communication
  // Support ws only!!
  create : async function (url,id,options) {
    var id,
        urlparts=url.split(':'),
        proto=url.match(/^(http|ws)/)[1],
        port=urlparts[2],
        key=urlparts[3],
        url0=urlparts.slice(0,3).join(':'),
        worker  = {state:0};
    url=url0;
    var channelA = Code.channel.create(0),  /* generic master-worker channel (extern) */
        channelB = Code.channel.create(0);  /* rpc reply channel (intern) */
    if (!url || !ShellWorker.wsconn[url]) return Code.error('No WebSocket connection to shell '+url);
    if (id!=undefined && ShellWorker.workers[id]) {
       Code.print('ShellWorker #'+id+': Killing previous instance ...');
      await ShellWorker.kill(id,true);
    } else if (id==undefined) id = ShellWorker.workerID++;
    ShellWorker.workers[id] = worker ;
    // proto ws
    // Initally use worksh proxy; after worker is created try to connect to worker directly (two-stage process)
    // Prinmary and secondary message channels
    // Direct worker communication is used by IPC only (e.g., msgchannel)
    worker.id=id;
    worker.stats = {
      forward:0,
      trans:0,
      recv:0,
      send:0,
      priv : {
        forward:0,
        send:0,
        error:0,
      }
    }
    worker.channelA=channelA;
    worker.channelB=channelB;
    worker.sendToProxy = ShellWorker.wsconn[url].send.bind(worker); 
    worker.trans = ShellWorker.wsconn[url].trans.bind(worker); 
    worker.forward = ShellWorker.wsconn[url].forward.bind(worker); 
    worker.kill = async function (immediate,cb) {
      // console.log('kill',id,immediate);
      // kill is directed to proxy!
      worker.sendToProxy({
        command   : 'kill',
        immediate : immediate,
        handle    : worker.handle,
        workerid  : id,
      });
      return;
    };
    /* cancel waiting receivers (locally) */
    worker.cancel = function () {
      channelA.cancel();
      channelB.cancel();
    };
    /* generic comm. channel */
    worker.receive = async function () {
      return channelA.receive();
    };
    /* sync. request reply channel */
    worker.reply = async function (cb) {
      return channelB.receive(cb);
    };
    worker.run = function (code,console) {
      if (console && console.match(/^code/)) console='#code-output_subarea'+console;
      worker.forward({command:'execute',code:code.toString(),console:console});
    };
    worker.send = function (data) {
      worker.forward({command:'forward',data:data});
    };
    worker.url=url;
    Code.shellworker.on('port'+id,function (port) {
      /* Direct worker ws service port */
      worker.wsurl=worker.url.replace(/[0-9]+$/,port);
      worker.wsport=port;
      /* open private worker message channel */
      var connection = new WebSocket(worker.wsurl);
      connection.onopen = function () {
        Code.print('ShellWorker #'+id+': Switched to private worker channel '+worker.wsurl);
        worker.wsconn={
          connection : connection,
          forward : function (data) {
            worker.stats.priv.forward++;
            connection.send(JSON.stringify(data));
          },
          send : function (data) {
            worker.stats.priv.send++;
            connection.send(JSON.stringify(data));
          }
        };
      }
      connection.onmessage = ShellWorker.wsconn[url].connection.onmessage.bind({worker:worker});
      connection.onclose = function () {
        Code.print('ShellWorker # '+id+': Private WS connection closed!');
        worker.stats.priv.closed=1;
      }
      connection.onerror = function () {
        Code.print('ShellWorker # '+id+': Private WS connection error!');
        worker.stats.priv.error++;
      }
      ShellWorker.off('port'+id);
    });
    Code.shellworker.on('ready'+id,function (rid) {
      worker.state=2;
      worker.remoteID=rid;
      ShellWorker.off('ready'+id);
    });
    var reply = await worker.trans({
      command   : 'create',
      workerid  : id,
    });
    if (Utils.isError(reply)) {
      Code.error('Remote worker '+id+' not created.',reply);        
    } else {
      worker.state=1;
      worker.handle=reply.handle;
    }
    return 'shellworker'+id;
  },
  
  // master-worker message channel (mulitplexed by shell proxy server, shared by all workers)!!
  // url = PROTO://HOST:PORT[:KEY]
  connect : async function (url,callback) {
    // WebSocket
    var resolve,
        urlparts=url.split(':'),
        proto=url.match(/^(http|ws)/)[1],
        port=urlparts[2],
        key=urlparts[3],
        url0=urlparts.slice(0,3).join(':');
    // url=url.slice(0,2).join(':');
    url=url0;
    if (ShellWorker.wsconn[url]) {
      // update key? 
      ShellWorker.wsconn[url].key=key;
      return;
    }
    var connection = new WebSocket(url+(key?'?key='+key:''))
    connection.onopen = function () {
      Code.print('['+url+'] ShellWorker.wscon open: '+url);
      var wsconn = {
        connection  : connection,
        url   : url,
        key   : key,
        send : function (data,cb) {
          // support message multiplexer; select this worker.id
          data.workerid=this.id;
          // data.key=wsconn.key;
          this.stats.send++;
          connection.send(JSON.stringify(data));
        },
        // trans with be bound (this) to the worker on worker creation
        trans : function (data,cb) {
          // support message multiplexer; select this worker.id
          data.workerid=this.id;
          // data.key=wsconn.key;
          connection.send(JSON.stringify(data));
          // wait for reply
          this.stats.trans++;
          return this.reply(cb);       
         },
        forward : function (data) {
          data.workerid = this.workerid;
          data.handle   = this.handle;
          // data.key      = wsconn.key;
          this.stats.forward++;
          connection.send(JSON.stringify(data));
        }
      }
      ShellWorker.wsconn[url]=wsconn;
      if (resolve) resolve(ShellWorker.wsconn[url]);
      else if (callback) callback(ShellWorker.wsconn[url]);
      resolve=null;
      callback=null;
    }
    connection.onerror = function (error) {
      Code.print('['+url+'] ShellWorker.wsconn error: '+error.type)
      if (resolve) resolve();
      else if (callback) callback();
      resolve=null;
      callback=null;      
    }
    connection.onmessage = function (e) { try {
      var data,message;
      // console.log('onmessage',e.data);
      // Deserialize data
      if (e.data) message=Utils.ofString(e.data);
      // console.log('onmessage',waiters.length,data)
      if (!message) return;
      var _console = ConsoleOutput;
      if (message.console && message.console.indexOf('code')==0) ConsoleOutput=$(message.console);
      if (message.console && message.console.indexOf('#')==0) ConsoleOutput=$(message.console);
      var worker = this.worker || (message.workerid!=undefined?ShellWorker.workers[message.workerid]:undefined);
      worker.stats.recv++;
      switch (message.command) {
        case 'clear':
          Cell.clearConsole(message.console.match(/(code[0-9]+)$/)[1]);
          break;
        case 'error':
          Code.error.apply(null,message.error);
          break;
        case 'evals':
          /* reply for a rpc */
          if (worker) worker.channelB.enqueue(message.status);
          break;
        case 'event':
          Code.shellworker.emit(message.event,message.data);
          break;
        case 'monitor':
          if (worker) worker.channelB.enqueue(message.data);
          // Code.shellworker.emit(message.commid,Utils.isObject(message.data)?message.data:Utils.ofString(message.data));
          break;
        case 'Plot':
          var data = message.data;  // already deserialized above?
          if (typeof data=='string') data=Utils.ofString(data);
          if (data && data[1] && data[1].clear && message.console) 
            Cell.clearConsole(data.console.match(/(code[0-9]+)$/)[1]);
          if (Utils.isArray(data))
                Plot.create.apply(null,data);
              else if (data.table) 
                Plot.table(data.table,{id:data.id}); 
          break;
        case 'print':
          if (message.console && message.console.indexOf('terminal')==0) Terminals[message.console].env.print.apply(null,message.data);
          else Code.print.apply({Console:message.console},message.data);
          break;
        case 'printi':
          Code.printi.apply({Console:message.console},[message.id].concat(message.data));
          break;
        case 'pstatus':
          var args = message.data;
          Code.status.apply(null,args);
          break;
        case 'read':
        case 'reads':
          /* reply for a rpc */
          if (worker) worker.channelB.enqueue(message.data);
          break;
        case 'send':
          var data = message.data;  // already deserialized above?
          if (typeof data=='string') data=Utils.ofString(data);
         /* explicit channel communication */
          var c=message.id==undefined?worker.channelA:Code.channel.channels[message.id];
          if (c) c.enqueue(data); // already deserialized above!
          break;
        case 'status':
          /* reply for a rpc */
          if (worker) worker.channelB.enqueue(message.status);
          break;
        case 'Table':
          var data = message.data;  // already deserialized above?
          if (typeof data=='string') data=Utils.deserialize(data);
          Table.apply(null,data); // already deserialized above!
          break;
        case 'write':
          try { jsScope.run(message.key+'='+message.data,{error:Code.error},true) } catch (err) { console.log(err) };
          break;
      }
      ConsoleOutput=_console;
    } catch (e) { console.log(e,message) } }
    connection.onclose = function () {
      Code.print('['+url+'] ShellWorker.wsconn.disconnected');
      ShellWorker.wsconn[url]=null;
    }
    if (!callback) return new Promise(function (_resolve) {
      resolve=_resolve;
    });
  },
  
  // cancel receiving channel waiters
  cancel : function (id) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return;
    var worker=ShellWorker.workers[id];
    return worker.cancel();
  },

  // main thread events or from worker
  emit : function (ev,data) {
    // console.log('emit',ev,data,ShellWorker.handlers[ev] && ShellWorker.handlers[ev].toString());
    if (ShellWorker.handlers[ev]) {
      ShellWorker.handlers[ev](data);
      if (!isNaN(Number(ev))) delete ShellWorker.handlers[ev];
    }  
  },

  // Send event signal to worker
  emitTo : function (id,ev,data) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return;
    if (typeof assign == 'function') { cb=assign; assign=undefined };
    var console=ConsoleId,
        worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;

    send({command:'emit',event:ev,data:data});  
  },

  // Evalue an expression on worker and wait for ersult
  eval : async function (id,code,assign,cb) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return;
    if (typeof assign == 'function') { cb=assign; assign=undefined };
    var console=ConsoleId,
        worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;

    if (console && console.match(/^code/)) console='#code-output_subarea'+console;
    // wait for reply
    send({command:'evali',code:code,id:id,console:console});
    return worker.reply(cb);
  },

  // Evalue a function 8with optional target assignment) on worker and wait for result
  evalf : async function (id,fun,data,assign,cb) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return;
    if (typeof assign == 'function') { cb=assign; assign=undefined };
    var worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;

    var console=ConsoleId;
    if (console && console.match(/^code/)) console='#code-output_subarea'+console;
    // wait for reply
    send({command:'evalf',code:fun.toString(),data:data,assign:assign,id:id,console:console}); 
    return worker.reply(cb);
  },

  get :  function (id) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('get: No such worker #'+id);
    return ShellWorker.workers[id]
  },
  
  kill : async function (id,immediate) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('kill: No such worker #'+id);
    var worker=ShellWorker.workers[id];
    // worker.send({eval:'kill()'});
    worker.kill(immediate);
    ShellWorker.workers[id]=null;
    // wait for shutdown!
    return new Promise(function (resolve) {
      setTimeout(function () {
        // close all connections
        if (worker.wsconn) worker.wsconn.connection.close();
        worker.state=-1;
        resolve();
      },100);    
    });
  },

  // Create an auto data monitor for a remote objects.
  // All scalar values are returned as a copy, all objects are iterated until a given depth.
  // The level parameters defines the maximal depth of the monitor object iterator.
  // All attribute values below this depth will always be returned as a data copy!
  // reading an object is an asynchronous function returning a promise for that can be waited for:
  // (await mon.x.y).a
  // Waiting for a promise is only possible on object endpoints (depth!)
    
  monitor : async function (worker,key,level,verbose) {
    if (typeof worker == 'string') worker=worker.replace('shellworker','');
    if (!ShellWorker.workers[worker]) return Code.error('monitor: No such shellworker #'+worker);
    var o;
    level=level||1;
    // print('Monitor',key);
    var signature = await Code.shellworker.signature(worker,key,level);
    if (verbose) Code.print(signature);
    function construct(key,sig,level) {
      var o,selector = {}
      if (verbose) Code.print('construct',key,sig,level)
      switch (typeof sig) {
        case 'object':
          if (Utils.isArray(sig)) {
            if (verbose) Code.print('construct []',key)
            selector=function (name) {
              if (name==[]) {
                // get all elements
                if (verbose) Code.print(worker,key)
                return Code.shellworker.read(worker,key)                                
              } else if (name!='length' && name != 'then') {
                name='['+name+']';
                if (verbose) Code.print(worker,key,name)
                return Code.shellworker.read(worker,key+name)
              } else if (name != 'then') {
                if (verbose) Code.print(worker,key,name)
                return Code.shellworker.read(worker,key+'.'+name)                
              }
            }
          
          } else Object.keys(sig).forEach(function (name) {        
            // print('selector',key,name,sig[name],level)
            switch (sig[name]) {
              case 'number':
              case 'string':
              case 'boolean':
                selector[name]=function () { return Code.shellworker.read(worker,key+'.'+name)};
                break;
              default:            
                if (typeof sig[name]=='object') {
                  if (Utils.isArray(sig[name])) {
                    if (level && sig[name].length && typeof sig[name][0]!='string') {
                      // TODO: should arrays be indexed? only for object arrays???
                      // how get we the length of an array?
                      // TODO: select all elements selector!?!?  array[[]]!!! DONE
                      var next =  construct(key+'.'+name,[],0 /* stop here definetely */);
                      selector[name]=function () { return next };                       
                    } else {
                      if (verbose) Code.print('construct []',key,name)
                      selector[name]=function () { 
                        if (verbose) Code.print(worker,key,name)
                        return Code.shellworker.read(worker,key+'.'+name)
                      }
                    }
                  } else if (level) {
                    var next =  construct(key+'.'+name,sig[name],level-1);
                    selector[name]=function () { return next };
                  } else selector[name]=function () {
                    if (verbose) Code.print(worker,key,name)
                    return Code.shellworker.read(worker,key+'.'+name) 
                  };
                }
            }   
          });
          // print(selector)
          o = new Proxy({},{
            get : function (target,name) {
              if (verbose) Code.print('get',key,name,typeof name,selector)
              if (typeof selector == 'function') return selector(name); 
              if (!selector[name]) return;
              return selector[name]();
            },
            set : function (target,name,val) {
              if (verbose) Code.print('set',key,name)
              return Code.shellworker.write(worker,key+'.'+name,val)
            }
          });
          return o;
          break;
      }
    }
    return construct(key,signature.sig,level-1);
  },

  off : function (ev) {
    delete ShellWorker.handlers[ev];  
  },

  on : function (ev,handler) {
    ShellWorker.handlers[ev]=handler;
  },
  
  // wait for worker to be started and ready to receive messages
  ready : async function (id,cb) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    var worker=ShellWorker.workers[id];
    if (!worker) return Code.error('ready: invalid shellworker '+id);
    if (worker.state==2) {
      if (cb) return cb(true);
      else return true;
    }
    if (cb) ShellWorker.on('ready'+id,cb);
    else {
      // needs await prefix before receive in async function (Code.run)
      return new Promise(function (resolve) { 
        ShellWorker.on('ready'+id,function (rid) {
          // console.log('ShellWorker ready event',id);
          worker.state=2;
          worker.remoteID=rid;
          ShellWorker.off('ready'+id);
          resolve(true);
        });
      });
    }  
  },
  
  read : async function (id,key,cb) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('read: No such worker #'+id);
    var dst,
        worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;
    if (typeof cb == 'string') {
      dst=cb;
      cb=function (res) {
        try {
          jsScope.run(dst+'='+res,{});
        } catch (e) { console.log(e) }
      }
    }
    send({command:dst?'reads':'read',key:key});
    return worker.reply(cb);
  },
  
  receive : async function (id,cb) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('receive: No such worker #'+id);
    var worker=ShellWorker.workers[id];
    return worker.receive(cb);
  },
  
  remoteID :  function (id) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('remoteID: No such worker #'+id);
    return ShellWorker.workers[id].remoteID
  },

  run : async function (id,code,arg) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('run: No such worker #'+id);
    var worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;

    if (typeof code == 'function') {
      var console=ConsoleId;
      if (console && console.match(/^code/)) console='#code-output_subarea'+console;
      if (arg==undefined)
        send({command:'execute',code:'var ret=('+code.toString()+').call(this); if(ret instanceof Promise) ret.catch(error);',console:console});
      else
        send({command:'execute',code:'var ret=('+code.toString()+').call(this,'+JSON.stringify(arg)+'); if(ret instanceof Promise) ret.catch(error);',console:console});
    } else {
      var console=arg==undefined?ConsoleId:arg;
      if (console && console.match(/^code/)) console='#code-output_subarea'+console;
      send({command:'execute',code:code.toString(),console:console});
    }
  },

  send : function (id,data) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('send: No such worker #'+id);
    var worker=ShellWorker.workers[id],
        send = (worker.wsconn && worker.wsconn.send) || worker.send;
    // _send: forward send message to worker (otheriwse it is handled by wss service loop)
    send({command:'_send',data:Utils.toString(data)});  
  },

  // Share between shell workers only!
  // Browser cannot share anything with shell workers, hence a sharable object must be implemented
  // on one worker and replicated on other workers.
  // Supported object classes (kind): segment, object (segment), channel, matrix 
  share : async function (workers, kind, segment, var1, var2, var3) {
    switch (kind) {
      case 'segment':
        var key=segment,size=var1,assign=var2;
        break;
      case 'object':
        var typ=var1,elements=var3?var2:null,assign=elements?var3:var2;
        break;
      case 'matrix':
        var options=var1;
        break;
    }
    /*TODO*/
  },

  signal : function (id,signal) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('signal: No such worker #'+id);
    var worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;
    /* kill signals must be sent always to the proxy (killing of worker) -> kill() */
    send({command:'signal',signal:signal});  
  },

  // GET A REMOT OBJECT SIGNATURE UP TO DEPTH LEVEL
  signature : async function (id,key,level,cb)  {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('signature: No such shellworker #'+id);
    var worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;

    send({command:'monitor',key:key,level:level||1});
    return worker.reply(cb);
  },
 
  statistics : function (id) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    var worker=ShellWorker.workers[id];
    return worker.stats;
  },
  
  stop : function (id) {
    ShellWorker.signal(id,'SIGINT');  
  },
  
  write : async function (id,key,val) {
    if (typeof id == 'string') id=id.replace('shellworker','');
    if (!ShellWorker.workers[id]) return Code.error('write: No such worker #'+id);
    var worker=ShellWorker.workers[id],
             /* secondary direct conn.    / primary proxied connection */
        send = (worker.wsconn && worker.wsconn.send) || worker.send;
    return send({command:'write',key:key,data:JSONfn.serialize(val)});
  },

  version : '1.12.1',
}

// WebSocket Channel between shell workers
// TODO: mixed web/shell worker connectivity via ws channels
Code.wschannel = {
  channelID:0,
  channels:[],
  // Create channel pair
  create : async function (worker1,name1,worker2,name2) {
    var id = Code.wschannel.channelID++,
        typ1 = worker1==undefined || worker1=='main'?'main':/^shellworker/.test(worker1)?'shell':'web',
        typ2 = worker2==undefined || worker2=='main'?'main':/^shellworker/.test(worker2)?'shell':'web',
        channel;
    function connectFromMain(workerUrl,name,channel) {
      // Connect to worker service endpoint and create a private connection for this channel
      Code.print('Code.wschannel.create: '+workerUrl)
      var connection = new WebSocket(workerUrl);
      connection.onopen = function () {
        // attach a channel pair endpoint
        connection.send(JSON.stringify({
          command:'channel',
          assign :name,
        }));
      };
      channel.forward = function (data) {
        connection.send(JSON.stringify({
          command:'send',
          data : data,
        }))
      }
      connection.onmessage = function (e) {
        var message;
        // console.log('onmessage',e.data);
        if (e.data) message=JSON.parse(e.data);
        // console.log('onmessage',waiters.length,data)
        if (!message) return;
        switch (message.command) {
          case 'send':
            channel.enqueue(message.data);
            break;
        }
      }    
    }
    if (typ1=='main' || typ2 == 'main') {
      // create channel pair endpoint for main loop
      channel = Code.channel.create();
    } else {
      // TODO create channel on worker
      // Only one worker creates the channel (master)
      if (typ1=='shell') {
        if (!ShellWorker.get(worker1)) return Code.error('Code.wschannel.create: Unknown worker A ('+worker1+')');
        if (!ShellWorker.get(worker2)) return Code.error('Code.wschannel.create: Unknown worker B ('+worker2+')');
        var workerobj = ShellWorker.get(worker2);
        Code.shellworker.evalf(worker1,async function (data) {
          var channel = await Code.wschannel.create(data.workerUrl,data.name);
          channel.tag='left';
          console.log(channel);
          return channel;
        },{workerUrl:workerobj.wsurl,name:name2},name1);
      }
    }
    if (channel && typ1=='shell') {
      // main - shell worker
      var workerobj = ShellWorker.get(worker1);
      connectFromMain(workerobj.wsurl,name1,channel);
    }
    if (channel && typ2=='shell') {
      // main - shell worker
      var workerobj = ShellWorker.get(worker2);
      connectFromMain(workerobj.wsurl,name2,channel);
    }
    return channel; // returns channel if worker1=="main"
  }

}

Code.shellworker = ShellWorker;
</script>
    <script type="text/javascript" charset="utf-8">// Worker Class (Code.worker and Code.shellworker wrapper)
function WorkerInit(module) {
  var __shells={};

  function Worker(url,id,options) {
    var self=this;
    if (!(this instanceof Worker)) return new Worker(url,id,options);
    
    options=options||{}
    if (/http\:|https\:|ws\:/.test(url)) this.url=url;
    else if (typeof url != 'object') this.id=this.url;
    if (typeof options=='object') this.options=options;
    else if (typeof id=='object') this.options=id;
    else if (typeof url=='object') this.options=url;
    if (typeof id=='number' || typeof id=='string') this.id=id;
    return new Promise(async function (resolve,reject) {
      try { await self.init(); } catch (e) { reject(e) }
      resolve(self);
    });
  }
  Worker.prototype.init = async function () {
    if (this.url==undefined) {
      this.worker = Code.worker.create(this.id,this.options);
    } else if (/http\:|https\:|ws\:/.test(this.url)) {
      // Remote Code.shellworker
      // 1. Connect to shell
      await Code.shellworker.connect(this.url);
      // 2. Create worker
      this.shellworker = await Code.shellworker.create(this.url,this.id,this.options);
    }
  }
  Worker.prototype.cancel = function () {
    if (this.worker!=undefined) return Code.worker.cancel(this.worker);
    else return Code.shellworker.cancel(this.shellworker);
  }
  Worker.prototype.emit = function (ev,data) {
    if (this.worker!=undefined) return Code.worker.emit(this.worker,ev,data);
    else return Code.shellworker.emit(this.shellworker,ev,data);
  }
  Worker.prototype.eval = function (fun,data,shared,assign) {
    if (this.worker!=undefined) return Code.worker.evalf(this.worker,fun,data,shared,assign);
    else return Code.shellworker.evalf(this.shellworker,fun,data,shared,assign);
  }
  Worker.prototype.name = function () { return this.worker||this.shellworker }

  Worker.prototype.kill = function () {
    if (this.worker!=undefined) return Code.worker.kill(this.worker);
    else return Code.shellworker.kill(this.shellworker);
  }
  Worker.prototype.monitor = function (key,level,verbose) {
    if (this.worker!=undefined) return Code.worker.monitor(this.worker,key,level,verbosen);
    else return Code.shellworker.monitor(this.shellworker,key,level,verbose);

  }
  Worker.prototype.ready = async function () {
    if (this.worker!=undefined) return Code.worker.ready(this.worker);
    else return Code.shellworker.ready(this.shellworker);
  }
  Worker.prototype.read = function (key) {
    if (this.worker!=undefined) return Code.worker.read(this.worker,key);
    else return Code.shellworker.read(this.shellworker,key);
  }
  Worker.prototype.receive = function () {
    if (this.worker!=undefined) return Code.worker.receive(this.worker);
    else return Code.shellworker.receive(this.shellworker);
  }
  Worker.prototype.run = function (code,console) {
    if (this.worker!=undefined) return Code.worker.run(this.worker,code,console);
    else return Code.shellworker.run(this.shellworker,code,console);
  }
  Worker.prototype.send = function (data) {
    if (this.worker!=undefined) return Code.worker.send(this.worker,data);
    else return Code.shellworker.send(this.shellworker,data);
  }
  Worker.prototype.share = function (key,data,eval) {
    if (this.worker!=undefined) return Code.worker.share(this.worker,key,data,eval);
  }
  Worker.prototype.signal = function (signal,data) {
    if (this.worker!=undefined) return Code.worker.signal(this.worker,signal,data);
    else return Code.shellworker.signal(this.shellworker,signal,data);
  }
  Worker.prototype.status = function () {
    if (this.worker!=undefined) return Code.worker.status(this.worker);
    else return Code.shellworker.status(this.shellworker);
  }
  Worker.prototype.write = function (key,val) {
    if (this.worker!=undefined) return Code.worker.write(this.worker,key,val);
    else return Code.shellworker.write(this.shellworker,key,val);
  }

  if (typeof module == 'object') module.exports = Worker;
  else if (typeof window == 'object') {
    window.GenericWorker=Worker;
  }
  if (typeof Context == 'object') Context.Worker = Worker;
}
WorkerInit()


</script>
    <script type="text/javascript" charset="utf-8">FileDialog = {
  locked : false,
  lock : function () {
    if (FileDialog.locked) return false;
    FileDialog.locked=true;
    return true;
  },
  unlock : function () { FileDialog.locked=false },
  refreshFileDialog : function (handle) {
    var lastselect;
    console.log('refreshFileDialog',handle.dir);
    handle.list(handle.dir, function (res) {
      if (Utils.isError(res)) {
        return handle.onerror(res);
      }
      var input=$('#fileDialogListFileName');
      if (res && res.status==0) {
        var list = $('#fileDialogList');
        list.empty();
        var entries=res.dirs;
        if (handle.mode=='Open' || handle.mode=='Load') entries=entries.concat(res.files);
        $('#fileDialogListLabel').html(handle.dir);
        entries.forEach(function (entry) {
          if (entry.name[0]=='.' && entry.name!='..') return;
          var listentry = $('<p/>',{
            class:'nav-entry '+(entry.dir?'nav-entry-directory':'nav-entry-file'),
            style:'cursor: pointer'
          }).append('<span>'+entry.name+'</span>').appendTo(list);
          if (entry.dir)
            listentry.bind('click',function () {
              if (entry.name=='..')
                handle.dir = handle.dir.replace(/(\/[^\/]+)$/,'');
              else
                handle.dir += ((handle.dir=='/'?'':'/')+entry.name);
              handle.dir=handle.dir||'/'; 
              handle.selected=entry.name;
              FileDialog.refreshFileDialog(handle);
            });
          else {
            listentry.bind('click',function () {
              if (lastselect) $(lastselect).removeClass('nav-selected');
              $(listentry).addClass('nav-selected');
              lastselect=listentry;
              handle.selected=entry.name;
              input.val(entry.name);
            });
          }
          return entry;
        })
      }
    })  
  },
  dialog : function (title, mode, dir, filename, fs, callback) {
    if (!FileDialog.lock()) return;
    var handle={selected:filename, dir:dir, mode:mode, list:fs.list};
    var html='<div><b>'+title+
             '</b><br><hr><div style="word-wrap: break-word;"id="fileDialogListLabel"></div>';
    html += '<input id="fileDialogListFileName" style="width:97%; height-max:400px; margin-top:5px;" value="'+filename+'">';
    html += '<div id="fileDialogList">';
    html += '</div></div>';
    var input,options
    handle.onerror=function (err) {
      // Fallback: Browser file dialog
      console.log('dialog',err);
      options.close();
      FileDialog.unlock();
      if (callback) callback(null,null,err);
    };
    setTimeout(function () { FileDialog.refreshFileDialog(handle); input=$('#fileDialogListFileName'); },1);
    popup.custom(options={content:html,default_btns:{ok:mode}},function (reply) {
      FileDialog.unlock();
      if (reply.proceed) {
        filename=input.val();
        if (callback) callback(handle.dir,filename);
      }
    });
  },
}


if (!Config.wex) Config.wex={http:'http://localhost:11111', ws:'ws://localhost:11112'};

// FS APi using the WEX server
FS = {
  // connect to wex via WebSockets
  connect : function () {
    if (FS.wsconn) return;
    var waiters=[];
    var connection = new WebSocket(FS.urlWS)
    connection.onopen = function () {
      console.log('FS.ws.wex.connopen',FS.urlWS);
      FS.wsconn={
        connection  : connection,
        trans : async function (data,cb,sync) {
          // console.log('FS.wsconn.trans',data);
          if (!sync) {
            waiters.push(cb);
            connection.send(JSONfn.stringify(data));
          } else return new Promise(function (resolve) {
            if (cb) waiters.push(function (reply) { resolve(cb(reply)) });
            else waiters.push(resolve);
            connection.send(JSONfn.stringify(data));
          })
        }
      }
    }
    connection.onerror = function (error) {
      console.log('FS.ws.wex error',error)
    }
    connection.onmessage = function (e) {
      var data;
      if (e.data) data=JSON.parse(e.data);
      if (waiters.length) {
        var next = waiters.shift();
        next(data);
      } // no waiter!? discard reply
    }
    connection.onclose = function () {
      console.log('FS.wsconn.disconnected');
      FS.wsconn=null;
    }
  },
  list : async function (dir,cb) {
    var result;
    function handler (response) {
      if (Utils.isError(response)) {
        if (cb) cb(response);
        return;        
      }
      if (!Utils.isObject(response) || response.status!=0) {
        result=response;
        if (cb) cb(result);
        return;
      }
      var dirs=response.reply.filter(function (entry) { return entry.dir })
                             .sort(function (a,b) { return a.name<b.name?-1:1 }),
          files=response.reply.filter(function (entry) { return !entry.dir })
                              .sort(function (a,b) { return a.name<b.name?-1:1 });
      result = {dirs:dirs,files:files,status:response.status};
      if (cb) cb(result);
    }
    if (FS.wsconn) FS.wsconn.trans({
        command:  'list',
        dir:  dir,
    },handler,!cb);
    else {
      if (cb) {
        Utils.POST(FS.url,{
          command:  'list',
          dir:  dir,
        },handler,false);
      } else {
        return new Promise (function (resolve,reject) {
          cb=resolve;
          Utils.POST(FS.url,{
            command:  'list',
            dir:  dir,
          },handler,false);      
        })
      }
    }
    return result;
  },
  load : async function(dir,file,mimetype,cb) { 
    var result;
    if (typeof mimetype == 'function') { cb=mimetype; mimetype='text' };
    if (mimetype != 'binary') mimetype='text';

    function handler(response) {
      if (Utils.isError(response)) {
        if (cb) cb(response);
        return response;        
      }
      if (!Utils.isObject(response) || response.status!=0) {
        result=response;
        if (cb) cb(result);
        return response;
      }
      result=response;
      if (mimetype=='binary' && typeof result.reply=='string') result.reply=Buffer.from(result.reply,'binary');
      if (cb) cb(result);  
      else return response;        
    } 
    if (FS.wsconn) return FS.wsconn.trans({
      command:  'load',
      dir:  dir,
      file: file,
      mimetype : mimetype,
    },handler,!cb);
    else {
      if (cb) Utils.POST(FS.url,{
        command:  'load',
        dir:  dir,
        file: file,
        mimetype : mimetype,
      },handler,false);
      else return new Promise (function (resolve,reject) {
        cb=resolve;
        Utils.POST(FS.url,{
          command:  'load',
          dir:  dir,
          file: file,
          mimetype : mimetype,
        },handler,false);      
      })
    }
    return result;
  },
  save : async function(dir,file,data,mimetype,cb) { 
    var result;
    if (typeof mimetype == 'function') { cb=mimetype; mimetype='text' };
    if (mimetype != 'binary') mimetype='text';
    function handler(response) {
      if (Utils.isError(response)) {
        if (cb) cb(response);
        return response;
      }
      result=response;
      if (cb) cb(result);
      else return result;      
    }
    // console.log(data.length);
    if (FS.wsconn) return FS.wsconn.trans({
      command:  'save',
      dir   : dir,
      file  : file,
      data  : data,
      mimetype : mimetype,
    },handler,!cb);
    else {
      if (cb) Utils.POST(FS.url,{
        command:  'save',
        dir   : dir,
        file  : file,
        data  : data,
        mimetype : mimetype||'text',
      },handler,false);
      else return new Promise (function (resolve,reject) {
        cb=resolve;
        Utils.POST(FS.url,{
          command:  'save',
          dir   : dir,
          file  : file,
          data  : data,
          mimetype : mimetype,
        },handler,false)
      })
    }
    return result;
  },
  shell : async function (exec,dir,cb) {
    var result;
    function handler(response) {
      result=response;
      if (cb) cb(result);
    }    
    if (FS.wsconn) FS.wsconn.trans({
          command:  'shell',
          exec:  exec,
          dir:   FS.workdir,
    },handler,!cb)
    else {
      if (cb) Utils.POST(FS.url,{
          command:  'shell',
          exec:  exec,
          dir:   FS.workdir,
      },handler,false);
      else return new Promise (function (resolve,reject) {
        cb=resolve;
        Utils.POST(FS.url,{
          command:  'shell',
          exec:  exec,
          dir:   FS.workdir,
        },handler,false);
      })
    }
    return result;
  },
  
  wsconn : null,
  url : Config.wex.url||Config.wex.http,
  urlWS : Config.wex.ws,
  workdir : Config.workdir||'/',
  workdirs : [],

  // GUI API
  API : {     
    loadFile: function loadFile(mimetype,callback,workdirCustom) {
      if (typeof callback == 'string') { workdirCustom=callback; callback=undefined; }
      var api = FS, workdir=(workdirCustom?FS.workdirs[workdirCustom]||FS.workdir1:FS.workdir1)||FS.workdir;
      FileDialog.dialog('Open','Open',
        workdir,'',api,function (dir,filename,err) {
        if (err) {
          console.log('FS.loadFile',err);
          if (callback) callback(err);
          return;
        }
        if (workdirCustom) FS.workdirs[workdirCustom]=dir;
        else FS.workdir1=dir;
        api.load(dir,filename,mimetype, function (result) {
          if (Utils.isError(result) || result.status!=0) return;
          if (callback) callback(result.reply,filename,dir);        
        });
      });
    },

    saveFile: function saveFile(data, filename, mimetype, callback, workdirCustom) {
      if (typeof callback == 'string') { workdirCustom=callback; callback=undefined; }
      var api = FS, workdir=(workdirCustom?FS.workdirs[workdirCustom]||FS.workdir1:FS.workdir1)||FS.workdir;
      FileDialog.dialog('Save','Save',
        workdir,filename,api,function (dir,filename,err) {
        if (err) {
          console.log('FS.saveFile',err);
          if (callback) callback(err);
          return;
        }
        if (workdirCustom) FS.workdirs[workdirCustom]=dir;
        else FS.workdir1=dir;
        api.save(dir,filename,data,mimetype, function (stat) {
          if (callback) callback(stat,filename,dir);        
        })
      });
    },

    importFile: function importFile(mimetype,callback) {
      var api = FS;
      FileDialog.dialog('Load Data','Load',
        FS.workdir2||FS.workdir,'',api,function (dir,filename) {
        FS.workdir2=dir;
        api.load(dir,filename,mimetype, function (result) {
          if (Utils.isError(result) || result.status!=0) return;
          if (callback) callback(result.reply,filename,dir);        
        });
      });
    },

    exportFile:function exportFile(data, filename, mimetype, callback) {
      var api = FS;
      FileDialog.dialog('Save Data','Save',
        FS.workdir2||FS.workdir,filename,api,function (dir,filename) {
        FS.workdir2=dir;
        api.save(dir,filename,data,mimetype, function (stat) {
          if (callback) callback(stat,filename,dir);        
        });
      });
    },

    selectDirectory: function selectFile(title,callback, workdirCustom) {
      if (typeof callback == 'string') { workdirCustom=callback; callback=undefined; }
      var api = FS, workdir=(workdirCustom?FS.workdirs[workdirCustom]||FS.workdir2||FS.workdir1:FS.workdir2)||FS.workdir;;
      FileDialog.dialog(title||'Select Directory','Open',
        workdir,'',api,function (dir,filename) {
        if (workdirCustom) FS.workdirs[workdirCustom]=dir;
        else FS.workdir2=dir;
        if (callback) callback(filename,dir);
      });
    },
    selectFile: function selectFile(title,callback, workdirCustom) {
      if (typeof callback == 'string') { workdirCustom=callback; callback=undefined; }
      var api = FS, workdir=(workdirCustom?FS.workdirs[workdirCustom]||FS.workdir2||FS.workdir1:FS.workdir2)||FS.workdir;;
      FileDialog.dialog(title||'Select File','Open',
        workdir,'',api,function (dir,filename) {
        if (workdirCustom) FS.workdirs[workdirCustom]=dir;
        else FS.workdir2=dir;
        if (callback) callback(filename,dir);
      });
    },
  },
  version : '1.2.5',
}

PATH = {
  basename : function (path,extension) {
    if (path[path.length-1]=='/') return '/';
    return extension?
            path.split('/').reverse()[0].replace(RegExp(extension.replace(/\./,'\\.')+'$'),'')
            :
            path.split('/').reverse()[0];
  },
  dirname : function (path) {
    var el=path.split('/');
    el.pop();
    return el.join('/');
  },
  
  extension : function (file) {
    return file.replace(/^[^\.]+\./,'');
  }
}
// wsvg2 API
SVG = {
  toPNG : async function(data,options,cb) { 
    var result;
    function handler(response) {
      if (response && response.status==0) {
        result=Buffer(response.reply.data);
      } else result=Error(response.status);
      if (cb) cb(result);
    }    
    if (cb) Utils.POST(SVG.url,{
      command:  'toPng',
      data     : data,
      options  : options,
      mimetype : 'text',
      },handler,false);
    else return new Promise (function (resolve,reject) {
      cb=resolve;
      Utils.POST(SVG.url,{
        command:  'toPng',
        data     : data,
        options  : options,
        mimetype : 'text',
      },handler,false)
    })
  },
  toPDF : async function(data,options,cb) { 
    var result;
    function handler(response) {
      if (response && response.status==0) {
        result=Buffer(response.reply.data);
      } else result=Error(response.status);
      if (cb) cb(result);
    }    
    if (cb) Utils.POST(SVG.url,{
      command:  'toPDF',
      data     : data,
      options  : options,
      mimetype : 'text',
      },handler,false);
    else return new Promise (function (resolve,reject) {
      cb=resolve;
      Utils.POST(SVG.url,{
        command:  'toPDF',
        data     : data,
        options  : options,
        mimetype : 'text',
      },handler,false)
    })
  },
  toEPS : async function(data,options,cb) { 
    var result;
    function handler(response) {
      if (response && response.status==0) {
        result=Buffer(response.reply.data);
      } else result=Error(response.status);
      if (cb) cb(result);
    }    
    if (cb) Utils.POST(SVG.url,{
      command:  'toEPS',
      data     : data,
      options  : options,
      mimetype : 'text',
      },handler,false);
    else return new Promise (function (resolve,reject) {
      cb=resolve;
      Utils.POST(SVG.url,{
        command:  'toEPS',
        data     : data,
        options  : options,
        mimetype : 'text',
      },handler,false)
    })
  },
  options : function (width,height,scale) {
    var dpi=144;
    scale = scale||1;
    return { 
      background  : 'white', 
      scale       : scale, 
      border      : 0, 
      dpi         : dpi, 
      width       : width, 
      height      : height 
    }
  },
  url : 'ag-0.de:11112'
  // url : ''
}

// Native node-webkit API using nodejs fs

if (typeof "require" != 'undefined') {
  try {
    var fs = require('fs');
    FS.connect = function () {};
    FS.list = function (dir,cb) {
      try {
        var result,files,response;
        dir=dir.replace(/^~/,process.env.HOME);
        if (process.env.WINE && !/^[A-Z]:/.test(dir)) dir = 'Z:'+dir; 
        // console.log(dir)
        files = fs.readdirSync(dir);
        files = files.map(function (entry) {
          try {
            var stat=fs.statSync(dir+'/'+entry);
            return {name:entry,dir:stat.isDirectory(),size:stat.size,time:stat.mtime};
          } catch (e)  { console.log(e.toString())};
        }).filter(function (entry) { return entry });
        response = [{name:'..',dir:true}].concat(files);
        var dirs=response.filter(function (entry) { return entry.dir })
                               .sort(function (a,b) { return a.name<b.name?-1:1 }),
            files=response.filter(function (entry) { return !entry.dir })
                                .sort(function (a,b) { return a.name<b.name?-1:1 });
        result = {dirs:dirs,files:files,status:0};
        console.log(result)
        if (cb) cb(result);
        return result;
      } catch (e) { 
        result = {status:-1}
        if (cb) cb(result);
        return result;
      }
    }
    FS.load = function(dir,file,mimetype,cb) { 
      try {
        var result,data;
        dir=dir.replace(/^~/,process.env.HOME);
        if (process.env.WINE && !/^[A-Z]:/.test(dir)) dir = 'Z:'+dir; 
        // console.log(dir)
        if (mimetype.indexOf('text')==0) {
          data=fs.readFileSync(dir+'/'+file,'utf8');
        } else if (mimetype.indexOf('binary')!=-1) {
          data=fs.readFileSync(dir+'/'+file,'binary');
        }
        result={reply:data,status:0};
        if (cb) cb(result);
        return result;
      } catch (e) { 
        result = {status:-1}
        if (cb) cb(result);
        return result;
      }    
    }
    FS.save = function(dir,file,data,mimetype,cb) { 
      try {
       var result;
        dir=dir.replace(/^~/,process.env.HOME);
        if (process.env.WINE && !/^[A-Z]:/.test(dir)) dir = 'Z:'+dir; 
        if (mimetype.indexOf('text')==0) {
          fs.writeFileSync(dir+'/'+file,data,'utf8',{});
        } else if (mimetype.indexOf('binary')!=-1) {
          fs.writeFileSync(dir+'/'+file,Buffer(data),'binary',{});
        }
        result={status:0}
        if (cb) cb(result);
        return result;
      } catch (e) { 
        result = {status:-1}
        if (cb) cb(result);
        return result;
      }    
    }
    console.log('Native FS API connected.');
  } catch (e) {
    console.log(e.toString());
  }
}
if (Config.workdir && FS.connect) {
  // Try to connect to wex server via websockets
  FS.connect();
}

</script>
    <script type="text/javascript" charset="utf-8">// Univesrsal WebSocket Group Communication
// With Proxy Server Support
//  Implements OO WS, HTTP, and Group APIs

function Group(root) {
  //////////////////////////// WebSockets WS /////////////////////
  var ws = {}

  // WebSocket Client API
  ws.client = function (options) {
    if(!(this instanceof ws.client)) return new ws.client(options)
    this.options=options||{};
    this.state='READY';
    this.queue=[];
    this.waiters=[];
    this.receivers=[];
    this.handlers=[];
  }

  ws.client.prototype.connect = async function (url) {
    var self=this,err
    this.url=url;
    if (this.state!='READY') return 'EBUSY';
    this.state = "CONNECTING";
    return new Promise(function (resolve,reject) {
      try {
        var socket=new WebSocket(url, self.options.protocols);
        self.socket=socket;
        var onmessage=function (message) {
          console.log(message)
          if (!message) {
            self.state='CLOSED';
            self.emit('close');
            // call data handlers with null argument?
          }
          var data=message.data;
          if (!self.options.binary && !self.options.text) data=Utils.deserialize(data);
          if (self.receivers.length) {
            for(var i in self.receivers) self.receivers[i](data);
          } else if (self.waiters.length) {
            var next = self.waiters.pop();
            next(data)
          } else self.queue.push(data);
        }
        var onclose=function () {
          self.state='CLOSED';
          // call data handlers with null argument?    
          if (self.handlers.close) self.handlers.close.call(self);
        }
        var onerror=function (event) {
          self.error=event.message||event.code;
          if (self.state=='CONNECTING') reject(event.message,event.code);
          else self.state='CLOSED'; // TODO ??
          self.emit('error',self.error)
          self.emit('close')
        }
        var onopen=function () {
          self.state='OPEN';
          resolve(self.state);
        }
        if (socket.on) socket.on('message',onmessage);
        else socket.onmessage=onmessage; 
        if (socket.on) socket.on('close',onclose);
        else socket.onclose=onclose;
        if (socket.on) socket.on('error',onerror);
        else socket.onerror=onerror;
        if (socket.on) socket.on('open',onopen);
        else socket.onopen=onopen;

      } catch (e) { self.error=e;self.state='READY'; resolve(e) }
    });
  }

  ws.client.prototype.disconnect = function () {
    if (this.state=='OPEN') {
      this.socket.close();
      this.state='CLOSED';
    } else return 'ENOPEN';
  }
  ws.client.prototype.emit = function (event,data) {
    if (this.handlers[event]) {
      if (typeof this.handlers[event]=='function') this.handlers[event](data);
      else for(var i in this.handlers[event]) this.handlers[event][i](data);
    }
  }
  ws.client.prototype.on = function (event,handler) {
    if (!this.handlers[event]) this.handlers[event]=handler;
    else this.handlers[event].push(handler);
  }

  ws.client.prototype.receive = async function () {
    var self=this;
    if (this.state!='OPEN') return 'ENOPEN';
    if (this.queue.length) {
      var data = this.queue.pop();
      return data;
    } else return new Promise(function (resolve,reject) {
      self.waiters.push(resolve);
    });
  }

  ws.client.prototype.receiver = async function (handler) {
    this.receivers.push(handler);
  }

  ws.client.prototype.send = function (data) {
    if (!this.options.binary && !this.options.text && typeof data=='object') data=Utils.serialize(data); 
    if (this.state=='OPEN') return this.socket.send(data);
    else return 'ENOPEN';
  }

  //////////////////// HTTP (Synchronous) ///////////////////
  var http = {}

  http.client = function (options) {
    if (!(this instanceof http.client)) return new http.client(options);  
  }

  http.client.prototype.get = async function (url,params,mimetype) {
      var result, proto;
      if (typeof document == 'object') proto=document.URL.replace(/:\/\/.+$/,'');
      else if (typeof URL == 'string') proto=URL.replace(/:\/\/.+$/,'');
      else if (typeof self == 'object') proto=self.location.toString().replace(/:\/\/.+$/,'');
      if (proto=='file') proto='http';
      // if (sync && !cb) cb=function (_result) { result=_result }; 
      if (url.indexOf('http')!=0) url = proto+'://'+url;
      return new Promise(function (resolve) {
        try {
          if (params) {
            params='/?'+Object.keys(params).map(function (key) { return escape(key)+'='+escape(params[key]) }).join('&');
          } else params='';
          // print(url+params)
          var request = new XMLHttpRequest();
          request.open("GET",url+params);
          request.onreadystatechange = function () {
            if(request.readyState === 4)
            {
                if(request.status === 200 || request.status == 0)
                {
                  if (request.responseText.length==0) resolve(Error("ENETWORK"));
                  else {
                    if (mimetype && mimetype.indexOf('json')!=-1) {try { resolve(JSON.parse(request.responseText)) } catch (e) { resolve (e) }}
                    else resolve(request.responseText);
                  }
                } else {
                  result=new Error('ENETWORK');
                  resolve(result)
                }
            }
          }
          request.onerror = function (error) {
            resolve (error)
          }
          request.send(null);
        } catch (error) {
          resolve (error)
        }
     })
  }

  http.client.prototype.put = async function (url,params,data,mimetype) {
      var result, proto;
      if (typeof document == 'object') proto=document.URL.replace(/:\/\/.+$/,'');
      else if (typeof URL == 'string') proto=URL.replace(/:\/\/.+$/,'');
      else if (typeof self == 'object') proto=self.location.toString().replace(/:\/\/.+$/,'');
      if (proto=='file') proto='http';
      // if (sync && !cb) cb=function (_result) { result=_result }; 
      if (url.indexOf('http')!=0) url = proto+'://'+url;
      return new Promise(function (resolve) {
        try {
          if (params) {
            params='/?'+Object.keys(params).map(function (key) { return escape(key)+'='+escape(params[key]) }).join('&');
          } else params='';
          // print(url+params)
          var request = new XMLHttpRequest();
          request.open("POST",url+params);
          request.onreadystatechange = function () {
            if(request.readyState === 4)
            {
                if(request.status === 200 || request.status == 0)
                {
                    if (request.responseText.length==0) resolve(Error("ENETWORK"));
                    else if (typeof data=='object') resolve(Utils.deserialize(request.responseText));
                    else resolve(request.responseText);
                } else {
                  result=new Error('ENETWORK');
                  resolve(result)
                }
            }
            console.log(request.readyState,request.status)
          }
          request.onerror = function (error) {
            resolve (error)
          }
          request.send(typeof data=='object'?Utils.serialize(data):data);
        } catch (error) {
          resolve (error)
        }
     })
  }

  /////////////////// ROUTE and GROUP Proxy API ///////////////////
  var group = {}

  group.client = function (url,options) {
    if (!(this instanceof group.client)) return new group.client(url,options);
    options=options||{}
    this.hs = http.client()
    this.router = url;
    this.host   = url.replace(/:[0-9]+$/,"")
    this.id = options.id||Utils.UUIDv4()
  }

  group.client.prototype.request = async function (request) {
    var reply = await this.hs.put(this.router,null,request)
    return reply
  }

  // Ping group router proxy
  group.client.prototype.ping = async function  () {
    var rpc = {
      cmd : "ping",
      peerid : this.id
    }
    var result = await this.request(rpc)
    return result 
  }
  // Get members of a group
  group.client.prototype.ask = async function (groupid) {
    var rpc = {
      cmd : "group:ask",
      groupid : groupid
    }
    var result = await this.request(rpc);
    console.log(result)
    if (Utils.isError(result)) return result;
    else if (result.status != "OK") return Error(result.status);
    else return result.members;
  }

  // Join a group
  group.client.prototype.join = async function (groupid) {
    var rpc = {
      cmd : "group:join",
      groupid : groupid,
      peerid : this.id,
    }
    var result = await this.request(rpc);
    if (Utils.isError(result)) return result;
    else return result.status;
  }

  // Unjoin a group
  group.client.prototype.unjoin = async function (groupid) {
    var rpc = {
      cmd : "group:unjoin",
      groupid : groupid,
      peerid  : this.id
    }
    var result = await this.request(rpc);
    if (Utils.isError(result)) return result;
    else return result.status;
  }


  // Create a group
  group.client.prototype.create = async function (groupid) {
    var rpc = {
      cmd : "group:create",
      groupid : groupid,
      peerid  : self.id
    }
    var result = await this.request(rpc);
    if (Utils.isError(result)) return result;
    else return result.status;
  }
  // Delete a group
  group.client.prototype.delete = async function (groupid) {
    var rpc = {
      cmd : "group:delete",
      groupid : groupid,
      peerid  : this.id
    }
    var result = await this.request(rpc);
    if (Utils.isError(result)) return result;
    else return result.status;
  }

  // Connect to router and create a communication port
  group.client.prototype.connect = async function () {
    // 1. Regsiter a new peer port and get WS URL
    var rpc = {
      cmd     : "peer:port",
      host    : this.host,
      peerid  : this.id
    }
    var result = await this.request(rpc)
    // print(inspect(result))
    if (Utils.isError(result)) return result;
    if (result.status == "OK") {
      var handler,
          wsc = new ws.client(),
          status = await wsc.connect(result.wsurl);
      // print ('wsc:connect:',status,err);
      if (Utils.isError(status)) return status;
      // Install a receiver coroutine
      wsc.receiver(function (data,err) {
        // print('received:',type(data),data,err)
        if (err == null && data) {
          var rpc = data
          // print(rpc)
          if (rpc.cmd == "data") {
            if (handler._receiver) handler._receiver(rpc.data);
            else if (handler.inWaiting.length > 0) {
              var next = handler.inWaiting.pop()
              next(rpc.data)
            } else handler.inQueue.push(rpc.data);          
          }
        }
        if (err != null) {
          // endpoint disconnected?
          console.log("route.socket: endpoint (router) disconnected")
          handler.state="CLOSED"
        }
      })
      // register our ws channel by sending out peerid
      var status = wsc.send({
        cmd     : "self",
        peerid  : this.id
      })
      // print('self',status)
      // Return a port socket handler
      handler = {
        inWaiting : [],
        inQueue   : [],
        peerid    : this.id,
        close     : function () {
          wsc.close()
        },
        connect   : async function (peerid,bidir) {
          var dir = "UNIDIR";
          if (bidir) dir="BIDIR";
          return wsc.send({
            cmd       : 'peer+',
            peerid    : peerid,
            direction : dir
          })
        },
        disconnect : async function (peerid) {
          return wsc.send({
            cmd       : 'peer-',
            peerid    : peerid
          })
        },
        receiver : function (callback) {
          handler._receiver=callback;
        },
        // Read from input data queue
        read : async function () {
          return new Promise(function (resolve) {
            if (handler.inQueue.length) {
              return handler.inQueue.pop()
            } else {
              handler.inWaiting.push(resolve);
            }
          })
        },
        // Write to output data queue
        write : function (data,peerid) {
          wsc.send({
            cmd   : 'data',
            from  : this.id,
            to    : peerid,
            data  : data
          })
        },
        state : "OPEN"
      }
      return handler
    } else {
      return result.status
    }
  }
  root.ws=ws;
  root.http0http;
  root.group=group;
}
Group(window)


</script>
    <script type="text/javascript" charset="utf-8">/*
** Smart exploring type interface and signature generator of arbitrary objects and functions
**
** Version 1.2.1
*/
function Signature(exports) {
  var _ =undefined;

  var Test = {
    isArray: function isArray(o) {
      if (o==_ || o ==null) return false;
      else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
    },
    isArrayArray: function isArrayArray(o) {
      if (o==_ || o ==null) return false;
      else return Utils.isArray(o) &&
                  Utils.isArray(o[0]);
    },
    isArrayArrayArray: function isArrayArrayArray(o) {
      if (o==_ || o ==null) return false;
      else return Utils.isArray(o) &&
                  Utils.isArray(o[0]) &&
                  Utils.isArray(o[0][0]);
    },
    isBuffer: function isBuffer(o) {
      if (o==_ || o ==null) return false;
      else return o instanceof Buffer;
    },
    isEmpty: function isEmpty(o) {
      for(var prop in o) {
         if (o[prop]!=undefined) return false;
      }
      return true;  
    },
    isError : function (o) {
      return o instanceof Error
    },
    isFunction: function isFunction(o) {
        return typeof o == "function";
    },
    isMatrix: function isMatrix(o,noarray) {
      if (o==_ || o ==null) return false;
      else return (!noarray && Utils.isArray(o) &&
                   Utils.isArray(o[0])) ||
                  (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                  (Math.Matrix && Math.Matrix.isMatrix(o))
                  ;
    },
    isObj: function isObj(o) {
        return typeof o == "object";
    },
    isObject: function isObject(o) {
        return typeof o == "object";
    },
    isRegex: function isRegex(o) {
        return o instanceof RegExp;
    },
    isString: function isString(o) {
        return typeof o == "string" || (typeof o == "object" && o.constructor === String);
    },
    isNumber: function isNumber(o) {
        return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
    },
    isBoolean: function isBoolean (o) {
        return typeof o == "boolean"
    },
    isString: function isString(o) {
        return typeof o == "string"
    },
    isStruct: function isStruct(o) {
        return o && !Utils.isArray(o) && Utils.isObject(o)
    },
    isTypedArray: function isTypedArray(o) {
        return o && Utils.isObject(o) && o.buffer instanceof ArrayBuffer
    },
    isVector: function isVector(o,noarray) {
      if (o==_ || o ==null) return false;
      else return (!noarray && Utils.isArray(o)) ||
                  (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                  (Math.Vector && Math.Vector.isVector(o))
                  ;
    },
  }
  var NL = '\n';

  // Detect circular references by an object/function cache
  var Cache = [],CacheMap=[];
  function CacheLookup (obj) {
    for(var i in Cache) if (Cache[i]===obj) return true;
    return false;
  }
  function RefName(obj) {
    for(var i in CacheMap) if (CacheMap[i].f===obj) return CacheMap[i].key;
    return '';
  }
  function sigArray (a,indent,left,structure) {
    var rowTypes,
        rowType0 = signature(a[0],indent+2,0),
        rowType1 = signature(a[a.length-1],indent+2,0);  // best hope assumption: if first and last element are equal=>mono
    // Try to get type set for polysorted arrays!!!!
    if (structure || a.length<1000) {
      rowTypes=[];
      var _C=Cache,_CM=CacheMap;
      for(var i in a) {
        Cache = [],CacheMap=[];
        var sig = signature(a[i],indent+2,0,structure);
        if (rowTypes.indexOf(sig)==-1) rowTypes.push(sig);
      }
      Cache = _C,CacheMap=_CM;
    }
    if (structure) {
      return '['+NL+rowTypes.join(','+NL)+']'
    }
    if (rowTypes) {
      if (rowTypes.length==1)
        return rowTypes[0]+(rowTypes[0][rowTypes[0].length-1]==']'?'':' ')+'['+(a.length?a.length:'')+']';
      else if (rowTypes.length>1)
        return '('+rowTypes.join('|')+')['+(a.length?a.length:'')+']';
      else
        return '['+(a.length?a.length:'')+']';
    }
    else {
      return (rowType0==rowType1 && a.length?rowType0+(rowType0[rowType0.length-1]==']'?'':' '):
              "'a ")+ '['+(a.length?a.length:'')+']'; 
    }           
  }

  function sigTypedArray (ta,indent,left) {
    var con=ta.constructor.name;
    return con+' ['+ta.length+']';
  }

  function sigFunction (f,indent) {
    var space=Array(indent).join(' '),
        spaces=function (s) { return space+' '+s };
    // try to extract function parameter list
    var code=f.toString(),
        attributes=Object.keys(f),
        native = /\[native code\]/.test(f),
        tokens=code.match(/[ ]*function[ ]*([^\( ]+)?[ ]*\(([^\)]*)\)/),
        name=tokens && tokens[1] && tokens[1].trim(),
        parameter=tokens && tokens[2]&&tokens[2].replace(/\/\*[^\*]*\*\//,'');
    if (name) CacheMap.push({key:name,f:f});
    if (attributes.length) {
      attributes = attributes.map(function (key) {
        return (name?name+'.':'')+key+' : '+signature(f[key],(indent||0)+2,0);
      });
    }
    if (native) {
      // extended native?
      return 'native function'+(name?' '+name:'')+(attributes.length?NL+attributes.map(spaces).join(NL):'');
    }
    var retType='',
        retIdOrExpr = code.match(/return[ ]*[a-zA-Z0-9$!_\-\.\(\{\[]+/);  // return <identifier>|<expr>
    //if (retIdOrExpr && ['if','for','function','while','do','switch','case'].indexOf(retIdOrExpr[1])==-1)
    //  retType="'a";
    return 'function'+
           (name?' '+name:'')+
           (parameter || (!parameter && retType)?' ('+parameter.split(',').map(function (s) { return s.length?'@'+s.trim():''}).join(',')+')':'')+
           (retType?' -> '+retType:'')+(attributes.length?NL+attributes.map(spaces).join(NL):'');
  }

  function sigMatrix (m,indent,left) {
    var con=Math.MatrixTA && Math.MatrixTA.isMatrix(m)?'MatrixTA':'Matrix';
    return m.datatype+' '+con+' '+m.dataspace.slice().reverse().map(function (s) { return '['+s+']'}).join('');
  }

  function sigObject (o,indent,left,structure) {
    if (o==null) return 'null';
    var space0=Array(left==0?0:indent).join(' '),
        space=Array(indent).join(' '),
        spaces=function (s) { return space+' '+s },
        keys = Object.keys(o),
        lines=[];
    for(var i in keys) {
      var key=keys[i];
      lines.push(key+' : '+signature(o[key],indent+2,0));
    }
    return space0+'{'+NL+lines.map(spaces).join(','+NL)+NL+space+'}';
  }

  function signature (obj,indent,left,structure) {
    var ref,
        space=Array(left==0?0:indent).join(' '),
        typ=typeof obj;
    switch (typ) {
      case 'string':
      case 'number':
      case 'boolean':
      case 'undefined':
        return space+typ;
      case 'function':
        if (CacheLookup(obj)!=false) return '[circular reference]'+(RefName(obj)? ' = '+RefName(obj):'');
        Cache.push(obj);
        return space+sigFunction(obj,indent,left);
      case 'object':
        if (CacheLookup(obj)!=false) return '[circular reference]'+(RefName(obj)? ' = '+RefName(obj):'');
        Cache.push(obj);
        if (Test.isTypedArray(obj)) return space+sigTypedArray(obj);
        if (Test.isBuffer(obj)) return space+'Buffer('+obj.length+')'; 
        if (Test.isMatrix(obj,true)) return space+sigMatrix(obj,indent,left);
        if (Test.isArray(obj)) return space+sigArray(obj,indent,left,structure);
        if (signature.instances) {
          for(var i in signature.instances) {
            if (obj instanceof signature.instances[i]) return signature.instances[i].name+ ' object';
          }
        }
        return sigObject(obj,indent||0,left,structure);
    }
  }

  signature.register=function(instance) {
    if (!signature.instances) signature.instances=[instance];
    else signature.instances.push(instance);
  }

  // Global API; Main entry point!

  var typeOf = function typeOf (o) {
    Cache=[];CacheMap=[];
    var sig=signature(o);
    Cache=[];CacheMap=[];
    return sig;
  }

  // Print interface of object constructor function and prototypes
  function interface(constructor,indent) {
    function constrRetFix(s,ret) {
      var lines = s.split(NL);
      lines[0]  = lines[0].replace(/[ ]*\->[^$]+/,'')+' -> '+ret;
      return lines.join(NL);
    }
    var space=Array(indent).join(' '),
        spaces=function (s) { return space+' '+s },
        name = constructor.name,
        sig  = constrRetFix(signature(constructor,0,indent+2),name+' object'),
        prototypes = [];
    if (!name) {
      name = constructor.toString().match(/^[ ]*function[ ]*([a-zA-Z_0-9]+)/);
      if (name) name=name[1];
    }
    Cache=[];CacheMap=[];
    if (name) CacheMap.push({key:name,f:constructor});
    if (constructor.prototype) {
      var keys=Object.keys(constructor.prototype);
      if (keys.length==0 && ([] instanceof constructor)) keys=Object.getOwnPropertyNames([].__proto__); // native constructor
      for(var i in keys) {
        var key=keys[i];
        if (!constructor.prototype.__lookupGetter__(key)) {
          
          if (!key || typeof constructor.prototype[key] == 'undefined') continue;
          if (constructor.prototype[key]  === constructor) {
            continue;
          }
          CacheMap.push({key:name+'.'+key,f:constructor.prototype[key]});
          prototypes.push('method '+signature(constructor.prototype[key],0,indent)
                                    .replace(/function[ ]*([^ \(]*)/,'function '+(name?name+'.':'')+key+' ')
                                    .replace(/\[circular reference\][ ]*(=[^$]+)?/,'function reference '+(name?name+'.':'')+key+' = '+RefName(constructor.prototype[key]))
                        );
        } else {
          // a getter that fails to evaluate
          prototypes.push('method getter '+(name?name+'.':'')+key);
        }
      }
    }    
    Cache=[];CacheMap=[];
    return 'constructor '+sig+
            (prototypes.length?NL+prototypes.map(spaces).join(NL):'')
  }



  // Print a structure interface; expand object arrays; summarize numeric arrays and buffers and TA
  function structure(obj,indent) {
    Cache=[];CacheMap=[];
    var strut=signature(o,0,0,true);
    Cache=[];CacheMap=[];
    return strut;
  }

  typeOf.signature=signature;
  typeOf.interface=interface;
  typeOf.structure=structure;

  Object.assign(exports, {
    interface:interface,
    signature:signature,
    structure:structure,
    test:Test,
    typeOf:typeOf,
  });
}
if (typeof module != 'undefined') { module.exports={}; Signature(module.exports) }
else if (typeof WorkerGlobalScope != 'undefined' && self instanceof WorkerGlobalScope) Signature(self);
else if (typeof window != 'undefined') Signature(window);
else if (typeof global != 'undefined') Signature(global);

</script>
    <script type="text/javascript" charset="utf-8">Windows = []
WBox = {
  id : 0,
  emit : function (ev,arg1,arg2) {
    if (handlers[ev]) WBox.handlers[ev](arg1,arg2);
  },
  handlers : [],
  root : function (options) {
    options=options||{};
    var i = WBox.id++,
        id = 'wbox'+i;
    var style = {
      width   : "100%",
      "min-height"  : "100%",
      "background-color"  : "#EEE",
      // "border"  : "1px solid black",
    }
    for(var p in options) {
      if (['title','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    var root = $('<div/>',{
      style : WBox.toCSS(style),
      class : 'wbox wbox-root',
    });
    var win = {
      index : i,
      id : id,
      root : root,
      options:options,
    }
    Windows[id]=win;
    return id;
  },
  
  layout : function (id) {
    var win = Windows[id];
    if (!win) return; 
    var content = win.root,
        width=$('body').width(),
        height=$('body').height()-30;
    
  },
  
  close : function (id) {
    var win = Windows[id];
    if (!win) return; 
    win.panel.close();
    $('#content').removeClass('hidden');
  },
  
  show : function (id) {
    var win = Windows[id];
    if (!win) return; 
    // hide content book
    var content = win.root,
        width,height;
    if (win.options.width) width=win.options.width+30;
    else width=$('body').width();
    if (win.options.height) height=win.options.height+30;
    else height=$('body').height()-30;
    if (typeof Common != 'undefined' && Common.openWin) {
      if (!win.options.width) $('#content').addClass('hidden');
      var panel = Common.openWin(content,{
        title   : (win.options.title||'Window')+' '+win.index,
        height  : height,
        width   : width,
        position : {
          my: "left-top", at: "left-top",
          offsetX : 0,
          offsetY : 0,
        },
        onresize  : function () { WBox.emit('resize',id) },
        onclosed   : function () { if (!win.options.width) $('#content').removeClass('hidden'); },
      });
      
      win.panel=panel;
    } else {
      // webwork.html?
      var overlay = $('#overlay');
      if (overlay[0]) {
        overlay.html(content);
        overlay.show()
      }
    }
    win.height=height; win.width=width;
  },
  
  toCSS : function (o) {
    return Object.keys(o).map(function (style) {
      return style+':'+o[style];
    }).join(';');
  },
  
  
  // Widgets
  
  button : function (options) {
    options=options||{};
    var style = {
      margin  : '2px',
      width   : 'auto',
      height  : 'auto',
      "font-weight" : '500',
    };
    for(var p in options) {
      if (['align','icon','label','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    if (options.align=='center')  {
      style.display='flex';
      style['justify-content']='center';
      if (style.margin) style.margin='auto';
    }
    var cls = 'wbox';
    var cell = $('<button/>',{
      style:WBox.toCSS(style),
      class : cls,
    });
    if (options.icon) cell.html('<span class="fa fa-'+options.icon+'"></span>');
    else if (options.label) cell.html(options.label);
    cell.click(function () {
      if (options.callback) options.callback(self);
    })
    var self = WBox.Widget({
      type  : 'button',
      cell  : cell,
      style : style,
      options : options,
    })
    return self;
  },
  
  checkbox : function (options) {
    // <input type="checkbox" id="example1">
    // <label for="example1">This is a checkbox</label> 
    options=options||{};
    var id = options.id || Utils.uniqueID(8),
    style = {
      margin  : '5px',
      width   : 'auto',
      height  : 'auto',
      "margin-left": '10px',
      "font-weight" : '500',
      display: "flex",
      "align-items": "center",
      };
    for(var p in options) {
      if (['icon','label','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox';
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    var input = $('<input/>',{
      class : cls,
      id    : id,
      type  : 'checkbox',
    });
    input.click(function () {
      self.checked=!self.checked;
      if (options.callback) options.callback(self.checked,self);
    })
    var label = $('<label/>',{
      class : cls,
      "for"  : id,
    });
    label.html(options.label);
    cell.append(input)
    cell.append(label)
    if (options.checked==undefined) options.checked=false;
    else input.prop('checked',options.checked);
    var self = WBox.Widget({
      type  : 'checkbox',
      input  : input,
      label : label,
      cell  : cell,
      options : options,
      checked : options.checked,
    })
    return self;
    
  },
  
  // typeof @options = {fields:string [],..}
  input : function (options) {
    // <div class="field-row-stacked" style="width: 200px">
    //   <label for="text22">Address (Line 1)</label>
    //   <input id="text22" type="text" />
    // </div>
    // <div class="field-row-stacked" style="width: 200px">
    //   <label for="text23">Address (Line 2)</label>
    //   <input id="text23" type="text" />
    // </div>  
    options=options||{};
    var id = options.id || Utils.uniqueID(8),
        opt,
        style={},
        stylel={'font-weight':'500'},
        stylei={},
        fields=[],values=[],single;
    for(var p in options) {
      if (p.indexOf('label-')==0) {
        opt=p.replace('label-','');
        stylel[opt]=options[p];
      }
      if (p.indexOf('input-')==0) {
        opt=p.replace('input-','');
        stylei[opt]=options[p];
      }
    }
    var cell = $('<div/>',{
      style : '',
      class : 'wbox',
    });
    if (typeof options.fields != 'object') throw "EINVALID";
    single=options.fields.length==1 && !options.vertical;
    for(var i in options.fields) (function (i) {
      style={"margin":"5px"};
      if (options.width) style.width=options.width;
      var div = $('<div/>',{
        style : WBox.toCSS(style),
        class : single?'field-row':'field-row-stacked',
      });
      var label = $('<label/>',{
        style : WBox.toCSS(stylel),
        for : id +'-'+i
      })
      label.html(options.fields[i]);
      var input = $('<input/>',{
        type : 'text',
        style : WBox.toCSS(stylei),
        id   : id +'-'+i
      });
      input.on('change',function () {
        values[i]=this.value;
        if (options.callback) options.callback(i,this.value);
      });
      div.append(label);
      div.append(input);
      cell.append(div);
      fields.push(div);
      values.push('');
    })(i)
    var self = WBox.Widget({
      type  : 'input',
      fields  : fields,
      values  : values,
      cell  : cell,
      options : options,
    })
    return self;
  },
  
  radiobuttons : function (options) {
    // <div class="field-row">
    //  <input id="radio5" type="radio" name="first-example">
    //  <label for="radio5">Yes</label>
    //</div>
    //<div class="field-row">
    //  <input id="radio6" type="radio" name="first-example">
    //  <label for="radio6">No</label>
    //</div>
    options=options||{};
    var id = options.id || Utils.uniqueID(8),
    style = {
      margin  : '5px',
      width   : 'auto',
      height  : 'auto',
      "margin-left": '10px',
      "font-weight" : '500',
      };
    for(var p in options) {
      if (['label','value','options','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox';
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    if (options.label) {
      var label = $('<div/>',{
        class : 'wbox field-row',
        style : 'font-family: Roboto, Arial; font-weight:500; margin-bottom:5px;',
      });
      label.html(options.label);
      cell.append(label);    
    }
    for(var i in options.options) (function (i) {
      var row = $('<div/>',{
        style : '',
        class : 'field-row',
      });
      var inp = $('<input/>',{
        class : cls,
        id    : id+'-'+i,
        type  : 'radio',
        name  : id,
      });
      if (options.value == options.options[i]) inp.prop('checked','true');
      row.append(inp);
      inp.on('change',function () {
        self.value      = options.options[i];
        self.valueIndex = i;
        if (options.callback) options.callback(self.value,self.valueIndex,self);
      });
      var label = $('<label/>',{
        class : cls,
        style : 'margin-left:5px',
        "for" : id+'-'+i,
      });
      label.html(options.options[i]);
      row.append(label);
      cell.append(row);
    })(i);
    options.value = options.value || options.options[0];
    var self = WBox.Widget({
      type  : 'radiobuttons',
      cell  : cell,
      options : options,
      value   : options.value,
      valueIndex : options.options.indexOf(options.value),
    })
    return self;    
  },
  
  // typeof @options = {label,options,value?,callback?}
  select : function (options) {
    // <select>
    //  <option>5 - Incredible!</option>
    // </select>
    options=options||{};
    var id = options.id || Utils.uniqueID(8),
        style = {
      margin  : '5px',
      width   : 'auto',
      height  : 'auto',
      "font-weight" : '500',
      display: "flex",
      "align-items": "center",
      };
    for(var p in options) {
      if (['label','label-width','value','options','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox';
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    var sel = $('<select/>',{
      class : cls,    
      id    : id,
    });
    for(var i in options.options) {
      var opt = $('<option/>',{
        class : cls,
      });
      if (options.value == options.options[i]) opt.prop('selected','true');
      opt.html(options.options[i]);
      sel.append(opt);
    }
    var label = $('<label/>',{
      class : cls,
      style : 'margin:5px; margin-right:10px; font-weight:500;'+
              (options['label-width']?'width:'+options['label-width']+';':''),
      "for" : id,
    });
    label.html(options.label);
    cell.append(label);
    cell.append(sel);
    sel.on('change',function () {
      if (options.callback) options.callback(this.value);
      self.value      = this.value;
      self.valueIndex = options.options.indexOf(this.value);
    });
    options.value = options.value || options.options[0];
    var self = WBox.Widget({
      type  : 'select',
      sel   : sel,
      label : label,
      cell  : cell,
      options : options,
      value   : options.value,
      valueIndex : options.options.indexOf(options.value),
    })
    return self;    
  },
  
  tabs : function (options) {
    // <section class="tabs" style="max-width: 500px">
    //   <menu role="tablist" aria-label="Sample Tabs">
    //     <button role="tab" aria-selected="true" aria-controls="tab-A">Tab A</button>
    //     <button role="tab" aria-controls="tab-B">Tab B</button>
    //     <button role="tab" aria-controls="tab-C">Tab C</button>
    //    </menu>
    //   <article role="tabpanel" id="tab-A">
    //   </article>
    //   <article role="tabpanel" hidden id="tab-B">

    options=options||{};
    if (options.selected==undefined) options.selected=0;
    var id = options.id || Utils.uniqueID(8),
        tabs = [], buts=[],
        style = {
        };
    for(var p in options) {
      if (['tabs','label','selected','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox tabs';
    var cell = $('<section/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    var menu = $('<menu/>',{
      role : 'tablist',
      'aria-label': options.label||'Navigation',
    });
    
    cell.append(menu);
    for(var i in options.tabs) (function (i) {
      var but = $('<button/>',{
        role : 'tab',
        "aria-controls":id+'-tab-'+i
      });
      var tab = $('<article/>',{
        role : 'tabpanel',
        id   : id+'-tab-'+i,
      });
      but.html(options.tabs[i]);
      but.on('click',function () {
        buts[self.selected].removeAttr('aria-selected');
        buts[i].attr('aria-selected','true');
        tabs[self.selected].attr('hidden','true');
        tabs[i].removeAttr('hidden');
        self.selected=i;
      })
      menu.append(but);
      cell.append(tab);
      tabs.push(tab);
      buts.push(but);
      if (options.selected==i) {
        but.attr('aria-selected','true');
      } else {
        tab.attr('hidden','true');      
      }
    })(i)
    var self = WBox.Widget({
      type  : 'tabs',
      cell  : cell,
      tabs  : tabs,
      options : options,
      selected : options.selected,
    })
    return self;    
  },
  
  table : function (rows,options) {
    var cells = [];
    options=options||{};
    var style = {
      margin  : '5px',
      width   : 'auto',
      height  : 'auto',
    };
    for(var p in options) {
      if (['align','callback','width'].indexOf(p)==-1) style[p]=options[p];
    }
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : '',
    });
    style = {
      'margin':'5px',
      "text-align":'left',
    }
    if (!options.background) {
      style.background='white';
      style['box-shadow']='inset 1px 1px 3px #999;'; 
    }
    if (options.align!='center') style.padding= '10px';
    else style.margin='auto';
    if (options.width) style.width=options.width;
    var table = $('<table/>',{
      style:WBox.toCSS(style),
      class : 'wbox table',
    });
    table.appendTo(cell);
    var cells = rows.map(function (row) {
      var tr = $('<tr/>',{
        style:'',
        class : '',
      });
      tr.appendTo(table);
      return row.map(function (col) {
        var td = $('<td/>',{
          style:'',
          class : '',
        });
        if (typeof col == 'string')
          col=WBox.p(col);
        td.appendTo(tr)
        col.cell.appendTo(td);
        return col;
      });
    });
    var self = WBox.Widget({
      type  : 'table',
      cell  : cell,
      cells : cells,
      options : options,
    })
    self.set = function (row,col,val) {
      cells[row][col].cell.html(val);
    }
    return self;    
  },

  label : function (options) {
    var style = {
      "margin-top"  : '5px',
      "margin-bottom" :'5px',
      "margin-left" : '0px',
      width   : options.width||'auto',
      height  : options.height||'auto',
      "font-weight" : 'bold',
    };
    for(var p in options) {
      if ([''].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox';
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    var label = $('<div/>',{
      class : 'wbox field-row',
      style : 'font-family: Roboto, Arial; font-size:inherit; margin-bottom:5px;',
    });
    label.html(options.text||options.label);
    cell.append(label);    
    var self = WBox.Widget({
      type  : 'label',
      cell  : cell,
      style : style,
      options : options,
    })
    return self;      
  },

  b : function (text) {
    return WBox.p(text,{"font-weight":"bold"});
  },

  p : function (text,options) {
    options=options||{}
    var style = {
      "margin"  : '5px',
    };
    for(var p in options) {
      if ([''].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox';
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    cell.html(text);    
    var self = WBox.Widget({
      type  : 'p',
      cell  : cell,
      style : style,
      options : options,
    })
    return self;      
  },
  
  text : function (options) {
    options=options||{};
    var style = {
      margin  : '5px',
      width   : options.width||'auto',
      height  : options.height||'100px',
      "font-weight" : '500',
      overflow : 'auto',
      background:'white',
    };
    for(var p in options) {
      if (['align'].indexOf(p)==-1) style[p]=options[p];
    }
    if (options.align=='center')  {
      // style.display='flex';
      // style['justify-content']='left';
      if (style.margin) style.margin='auto';
      style['text-align']='left';
    }
    var cls = 'wbox';
    var cell = $('<div/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    var self = WBox.Widget({
      type  : 'text',
      cell  : cell,
      style : style,
      options : options,
    })
    var initialScroll=true;
    self.add=function (line) {
      var scrollBottom=false,
          el = $('<div/>',{
            style:WBox.toCSS({
             'margin-left':'3px;',
            'margin-right':'3px',
            'font-size':'inherit',
            'font-family':'inherit',
          })}).html(line);
      if (options.scrollAuto && 
          ((initialScroll && cell.scrollTop() == 0) ||
           (cell.scrollTop()+cell.height()) == cell[0].scrollHeight)) {
        scrollBottom=true;
        initialScroll=false;
      }
      el.appendTo(cell);
      if (scrollBottom) cell.scrollTop(1E9);
    }
    self.clear=function () {
      cell.empty();
    }
    if (options.lines) options.lines.forEach(self.add);
    return self;    
  },
  
  tree : function (options) {
    // <ul class="tree-view">
    //   <li>A1</li>
    //   <li>A2</li>
    //   <li>
    //     A3
    //     <ul>
    //       <li>B1</li>
    //       <li>B2</li>
    //       <li>B3</li>
    //     </ul>
    //   </li>
    //   <li>
    //     <details open>
    //       <summary>A4</summary>
    //       <ul>
    //         <li>C1</li>
    options=options||{};
    if (options.tree==undefined) throw "EINVALID";
    var id = options.id || Utils.uniqueID(8),
        tree = [],
        style = {
          width:'100%',
        };
    for(var p in options) {
      if (['tree','label','callback'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox tree-view';
    var cell = $('<ul/>',{
      style : WBox.toCSS(style),
      class : cls,
    });
    var self = WBox.Widget({
      type  : 'tree',
      cell  : cell,
      options : options,
    })
  
    function iter(node,list,path,level) {
      for(p in node) (function (p) {
        var handler;
        if (typeof node[p]=='string' ||
            typeof node[p]=='number' ||
            typeof node[p]=='boolean') {
          var item = $('<li/>',{
          
          });
          list.append(item);
          if (node[p]) item.html(p+'='+String(node[p]));
          else item.html(p);
          handler = {
              item    : item,
              path    : path+'/'+p,
          }
          if (options.select) item.on('click',function () {
            options.select(node,p,handler);
          });
        } else if (!Utils.isArray(node[p]) && Utils.isObject(node[p])) {
          var item = $('<li/>',{
          
          });
          list.append(item);
          var details = $('<details/>',{
            // "open":"true"
          });
          item.append(details);
          var summary = $('<summary/>',{
          
          });
          summary.html(p);
          details.append(summary);
          var list2 = $('<ul/>',{
          
          });
          details.append(list2);

          // if (options.dynamic)
          handler = {
              item    : item,
              path    : path+'/'+p,
              add     : function add (node) { iter(node,list2,path+'/'+p) },
              remove  : function remove () { /*TODO*/ },
              replace : function replace (node) { list2.empty(), iter(node,list2,path+'/'+p); }
            };
          if (options.open) summary.on('click',function () {
            if (!details.attr('open'))
              options.open(node,p,handler);
          });
          if (options.close) summary.on('click',function () {
            if (details.attr('open'))
              options.close(node,p,handler);
          });
          
          if (level==1) iter({},list2,path+'/'+p);
          else iter(node[p],list2,path+'/'+p);
        }
      })(p);
    }
    iter(options.tree,cell,'',options.dynamic?1:undefined)
    return self;
  },
  
  // scrollable view container
  view : function (options) {
    options=options||{};
    if (!options.align) options.align=[];
    else if (typeof options.align == 'string') options.align=[options.align];
    var style = {
      // display : 'inline-block',
      "font-size":"inherit",
      overflow : 'auto',
      display  : 'block',
    };
    for(var p in options) {
      if (['align'].indexOf(p)==-1) style[p]=options[p];
    }
    if (options.align=='center')  {
      style["margin-left"]='auto';
      style["margin-right"]='auto';
    }
    if (!style.width) style.width="120%";
    if (!style.height) style.height="auto";
    var cls = 'wbox view';
    var cell = $('<div/>',{
      style:WBox.toCSS(style),
      class : cls,
    });
    var self = WBox.Widget({
      type  : 'view',
      cell  : cell,
      style : style,
      options : options,
      elements : [],
    })
    return self;
  
  },
  
  vspace : function (height) {
    if (!isNaN(Number(height))) height+='px';
    var cell = $('<div/>',{
      style:'height:'+height,
      class : "",
    });
    var self = WBox.Widget({
      type  : 'vspace',
      cell  : cell,
      style : {height:height},
      options : {height:height},
      elements : [],
    })
    return self;  
  },
  
  hbox : function (options,columns) {
    options=options||{};
    if (!options.align) options.align=[];
    else if (typeof options.align == 'string') options.align=[options.align];
    var style = {
      width   : '100%',
      height  : 'auto',
      // display : 'inline-block',
      "font-size":"inherit",
    };
    for(var p in options) {
      if (['align'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox hbox';
    var cell = $('<table/>',{
      style:WBox.toCSS(style),
      class : cls,
    });
    var row = $('<tr/>',{
      class : 'wbox',
    });
    cell.append(row);
    var self = WBox.Widget({
      type  : 'hbox',
      cell  : cell,
      row   : row,
      style : style,
      options : options,
      elements : [],
    })
    if (columns) self.add(columns);
    return self;
  },
  
  vbox : function (options,rows) {
    options=options||{};
    if (!options.align) options.align=[];
    else if (typeof options.align == 'string') options.align=[options.align];
    var style = {
      height   : 'auto', // '100%',
      width  : 'auto',
      // display : 'inline-block',
      "font-size":"inherit",
    };
    for(var p in options) {
      if (['align'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox vbox';
    var cell = $('<table/>',{
      style:WBox.toCSS(style),
      class : cls,
    });
    var self = WBox.Widget({
      type  : 'vbox',
      cell  : cell,
      style : style,
      options : options,
      elements : [],
    })
    if (rows) rows.forEach(function (row) {
      self.add(row)
    })
    return self;
  },

  grid : function (options) {
    options=options||{};
    if (!options.align) options.align=[];
    else if (typeof options.align == 'string') options.align=[options.align];
    var style = {
      width   : '100%',
      height  : 'auto',
      // display : 'inline-block',
      "font-size":"inherit",
    };
    for(var p in options) {
      if (['align'].indexOf(p)==-1) style[p]=options[p];
    }
    var cls = 'wbox grid';
    var cell = $('<table/>',{
      style:WBox.toCSS(style),
      class : cls,
    });
    var self = WBox.Widget({
      type  : 'grid',
      cell  : cell,
      style : style,
      options : options,
      elements : [],
    })
    return self;  
  },
  
  
  Widget : function (widget) {
    if (!(this instanceof WBox.Widget)) return new WBox.Widget(widget);
    for(var p in widget) this[p]=widget[p];
  },
  
  version : '0.7.1',
  
}

WBox.Widget.prototype.add = function (widget) {
  var style={};
  if (typeof widget == 'string') widget=WBox.p(widget);
  switch (this.type) {
    case 'hbox':
      if (this.options.align && this.options.align.indexOf('top')!=-1)
        style['vertical-align']='top';
      if (Utils.isArray(widget)) {
        if (!this.options.merged) {
          for(var i in widget) {
            var td = $('<td/>',{
              class : 'wbox',
              style : WBox.toCSS(style),
            });
            td.append(widget[i].cell);
            this.row.append(td);
            this.elements.push(widget[i]);
         }
       } else {
          var td = $('<td/>',{
            class : 'wbox',
            style : WBox.toCSS(style),
          });
          this.row.append(td);
          for(var i in widget) {
            td.append(widget[i].cell);
          }
       }
      } else {
        var td = $('<td/>',{
          class : 'wbox',
          style : WBox.toCSS(style),
        });
        td.append(widget.cell);
        this.row.append(td);
        this.elements.push(widget);
      }
      break;
    case 'vbox':
      style.width='1%'; // full width hack!!! TODO TBC
      if (Utils.isArray(widget)) for(var i in widget) {
        var tr = $('<tr/>',{
          class : 'wbox',        
        });
        if (widget[i].options && widget[i].options.align && widget[i].options.align.indexOf('center')!=-1)
          style['text-align']='center';
        else
          delete style['text-align'];
        var td = $('<td/>',{
          class : 'wbox',
          style : WBox.toCSS(style),
        });
        td.append(widget[i].cell);
        tr.append(td);
        this.cell.append(tr);
        this.elements.push(widget[i]);
      } else {
        if (widget.options && widget.options.align && widget.options.align.indexOf('center')!=-1)
          style['text-align']='center';
        else
          delete style['text-align'];
        var tr = $('<tr/>',{
          class : 'wbox',        
        });
        var td = $('<td/>',{
          class : 'wbox',
          style : WBox.toCSS(style),
        });
        td.append(widget.cell);
        tr.append(td);
        this.cell.append(tr);
        this.elements.push(widget);
      }
      break;
    case 'grid':
      if (!Utils.isArray(widget)) return Code.error('wbox.add: Only rows (widget array) can be added to a grid');
      var tr = $('<tr/>',{
        class : 'wbox',        
      });
      for(var i in widget) {
        var td = $('<td/>',{
          class : 'wbox',
        });
        td.append(widget[i].cell);
        tr.append(td);
      }
      this.cell.append(tr);
      break;
    case 'view':
      if (Utils.isArray(widget)) for(var i in widget) {
        this.cell.append(widget[i].cell);
      } else {
        this.cell.append(widget.cell);
      }
      if (this.options.scrollAuto) {
        this.cell.scrollTop(1E6);
      }
      break;
  }
}
WBox.Widget.prototype.clear = function () {
  this.cell.empty()
}
WBox.Widget.prototype.remove = function (index) {
  if (index==-1) {
    // last element
    this.cell.children().last().remove();
  } else if (index<0) {
    var cl = this.cell.children();
    if (cl[cl.length+index]) cl[cl.length+index].remove();
  } else {
    var cl = this.cell.children();
    if (cl[index]) cl[index].remove();  
  }
}
WBox.Widget.prototype.replace = function (index,widget) {
  switch (this.type) {
    case 'view':
      if (index==-1) {
        // last element
        $(this.cell.children().last()).replaceWith(widget.cell);
      } else if (index<0) {
        var cl = this.cell.children();
        if (cl[cl.length+index]) $(cl[cl.length+index]).replaceWith(widget.cell);
      } else {
        var cl = this.cell.children();
        if (cl[index]) $(cl[index]).replaceWith(widget.cell);  
      }
      break;
  }
}

// Chat dialogue
// { width?, height?, border?, .., history?:{} [], callback? }
// post(string|{text:string,left?=true,right?=true}|..)
// ask({text:string,input=true,callback?,timeout?:number})
// ask({text:string,choices:string[],callback?,timeout?:number})
WBox.chat = function (options) {
  var style = {
    width : '300px',
    height : '200px',
    margin : '10px',
    background : 'white',
    scrollAuto : true,
    "font-family":'Sans',
    "font-size":"16px",
  }, timer, queue=[], busy=false;
  for(var p in options) {
    if (['callback','history'].indexOf(p)==-1) style[p]=options[p];
  }
  var widget = WBox.view(style);
  function ask(question) {
    if (!question) return;
    if (busy) return queue.push(question);
    busy=true;
    function finish(answer) {
      if (timer) clearTimeout(timer);
      timer=null;
      widget.remove(-1);
      busy=false;      
      if (question.input && answer) {
        add({
          text:question.text,
          left:true,
        })
        add({
          text:answer,
          right:true,
        });
      }
      if (question.choices) {
        widget.remove(-1);
        if (answer) add({
          text:answer,
          right:true,
        });              
      }
      if (question.callback) question.callback(answer);
      if (options.callback) options.callback(question,answer);
      if (queue.length) ask(queue.shift());
    }
    if (question.input) {
      widget.add(WBox.input({
        fields : [question.text],
        values : [''],
        vertical : true,
        "font-size":style["font-size"],
        'input-border' : '1px solid #888',
        callback : function (field,value) {
          finish(value)
        }        
      }));
      timer=setTimeout(function () {
        finish()
      },options.timeout||10000);
    }
    if (question.choices) {
      var buttons = question.choices.map(function (choice,index) {
        return WBox.button({
          label:choice,
          'min-width':'0',
          "font-size":style["font-size"],
          callback:function () {
            finish(choice);
          }
        })
      });
      var qtext = WBox.label({
        label:question.text,
        "font-size":style["font-size"],
      })
      widget.add(qtext);
      widget.add(WBox.hbox({merged:true},buttons));
      timer=setTimeout(function () {
        finish()
      },options.timeout||10000);
    }
    widget.cell.scrollTop(1E6);
  }
  function add(post) {
    if (busy) return queue.push({post:post});
    if (typeof post == 'string') 
      widget.add(WBox.p(post,{
        width:'90%',
        "text-align":'right',
        'margin-top':'10px',
        "font-family":style['font-family']||'Sans',
        "font-size":style["font-size"],
        'border':post.border,
        'border-radius':post['border-radius'],
      }));
    else if (post.type=='text'||post.text) {
      widget.add(WBox.p(post.text,{
        width:'90%',
        "text-align":post.left?'left':post.right?'right':'center',
        'margin-top':'10px',
        "font-family":style['font-family']||'Sans',
        "font-size":style["font-size"],
        'border':post.border,
        'border-radius':post['border-radius'],
      }));
    }
    widget.cell.scrollTop(1E6);
  }
  if (options.history) {
    options.history.forEach(add);
    setTimeout(function () {widget.cell.scrollTop(1E6);},100)
  }
  return {
    ask:ask,
    add:add,
    cell:widget.cell,
    post:add,
  }
}
</script>
    <script type="text/javascript" charset="utf-8">var Http = {}

function HttpInit() {
  function parseUrl(url) {
    if (!isNaN(Number(url)) || url=='*') return {
      proto:  undefined,
      host:   undefined,
      port:   url,
      path:   '',
      params:  undefined,
    }
    function toParams (avl) {
      var params = {};
      avl.forEach(function (av) {
        var parts=av.split('=');
        params[parts[0]]=parts[1];
      })
      return params;
    }
    var tokens = url.match(/((file|http|https|udp|tcp):\/\/)?([a-zA-Z0-9_\.\-]+):(\[?[0-9]+\]?|\*)(\/[^\?]+)?(\?.+$)?/)
    if (!tokens) {
      tokens   = url.match(/((file|http|https|udp|tcp):\/\/)?([a-zA-Z0-9_\.\-]*)(\/[^\?]*)?(\?.+$)?/);
      return  {
        proto:  tokens[2],
        host:   tokens[3],
        port:   undefined,
        path:   tokens[4]||'',
        params:  tokens[5] && toParams(tokens[5].replace(/^\?/,'').split('&')),
      }
    } else return  {
      proto:  tokens[2],
      host:   tokens[3],
      port:   tokens[4] && Number(tokens[4]),
      path:   tokens[5]||'',
      params:  tokens[6] && toParams(tokens[6].replace(/^\?/,'').split('&')),
    }
  }

  function parseQueryString( url ) {
      var queryString = url.substring( url.indexOf('?') + 1 );
      if (queryString == url) return [];
      var params = {}, queries, temp, i, l;
      // Split into key/value pairs
      queries = queryString.split("&");
      // Convert the array of strings into an object
      for ( i = 0, l = queries.length; i < l; i++ ) {
          temp = queries[i].split('=');
          if (temp[1]==undefined) temp[1]='true';
          params[temp[0]] = temp[1].replace('%20',' ');
      }
      return params;
  }
  var http = {
    request : function (options,callback) {
      var request = new XMLHttpRequest();
      // TODO options.headers
      request.open(options.method,options.proto+'://'+options.host+
                                  (options.port?':'+options.port:'')+
                                  (options.path && options.path.length && options.path[0]!='/'?'/':'')+
                                  options.path);
      var ons={},on = function (ev,handler) {
        ons[ev]=handler;
      }
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
              if (ons.data) ons.data(request.responseText);
              if (ons.end) ons.end();
            } else {
              if (ons.error) ons.error(request.status); 
            }
        }
      }
      request.onerror = function (error) {
        if (ons.error) ons.error(request.status); 
      }
      
      var req = {
        on : on,
        end : function () {
          request.send(null);
        },
        write : function (data) {
          request.send(data);
        },
        setNoDelay : function () {
        
        },
        setEncoding : function (enc) {
        
        },
      }
      if (callback) callback(req);
      return req
    }
  }
  function reply(response,body,mimetype,proto) {
    header={'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': 'true',
            'Content-Type': mimetype?mimetype:'text/plain'};

    if (proto=='http'||proto=='https') response.writeHead(200,header);
    response.write(body);
    response.end();
  }

  Http.get = async function (url,callback,mimetype) {
    var ishttps= url.match(/https:/)!=null;
    url=url.replace(/^http[s]*:\/\//,'');
    if (typeof callback=='string') { mimetype=callback;callback=null};
    function exec(url,callback) {
      var parts = parseUrl(url),
          path  = parts.path,
          host  = parts.host,
          port  = parts.port||(ishttps?'443':'80'),
          options = {
            proto : ishttps?'https':'http',
            host: host,
            port: port,
            path: path,
            method: 'GET',
            keepAlive: true,
            headers: {
                // 'Content-Type': 'application/x-www-form-urlencoded',
            }          
          }
      var req = http.request(options, function(res) {
          res.setEncoding('utf8');
          var data='';
          res.on('data', function (chunk) {
            data += chunk;
            // console.log('Response: ' + chunk);
          });
          res.on('end', function () {
            try {
              var result=mimetype=='json'?JSONfn.parse(data):data;
              // console.log('GET: ',result);
            } catch (e) { result=e; }
            callback(result);
          });
      });
      req.on('error',function (err) {
        // console.log(err)
        callback(null,err);
      });
      req.setNoDelay();
      // get_req.write();
      req.end();
    }
    if (callback) {
      exec(url,callback);
    } else return new Promise(function (resolve,reject) {
      exec(url,resolve)
    })
  }
  Http.put = async function (url,data,callback,mimetype) {
    var ishttps= url.match(/https:/)!=null;
    url=url.replace(/^http[s]*:\/\//,'');
    if (typeof callback=='string') { mimetype=callback;callback=null};
    function exec(url,callback) {
      var parts = parseUrl(url),
          path  = parts.path,
          host  = parts.host,
          port  = parts.port||(ishttps?'443':'80'),
          options = {
            proto : ishttps?'https':'http',
            host: host,
            port: port,
            path: path,
            method: 'POST',
            keepAlive: true,
            headers: {
                // 'Content-Type': 'application/x-www-form-urlencoded',
            }          
          }
      var req = http.request(options, function(res) {
          res.setEncoding('utf8');
          var data='';
          res.on('data', function (chunk) {
            data += chunk;
            // console.log('Response: ' + chunk);
          });
          res.on('end', function () {
            try {
              var result=mimetype=='json'?JSONfn.parse(data):data;
              // console.log('GET: ',result);
            } catch (e) { result=e; }
            callback(result);
          });
      });
      req.on('error',function (err) {
        // console.log(err)
        callback(null,err);
      });
      req.setNoDelay();
      req.write(mimetype=='json'?JSONfn.stringify(data):data);
      req.end();
    }
    if (callback) {
      exec(url,callback);
    } else return new Promise(function (resolve,reject) {
      exec(url,resolve)
    })

  }
}
HttpInit();

</script>
    <script type="text/javascript">
    </script>
    <script type="text/javascript">
        // http://www.squarefree.com/shell/shell.html
        var
        histList = [""],
        histPos = 0,
        fontSize = 0.8,
        _scope = {
          Array:Array,
          Buffer:Buffer,
          CSP:CSP,
          ML:ML,
          Math:Math,
          Utils:Utils,
        },
        _win, // a top-level context
        question,
        _in,
        _out,
        tooManyMatches = null,
        lastError = null;
        
        function refocus()
        {
          _in.blur(); // Needed for Mozilla to scroll correctly.
          _in.focus();
        }
        
        function init()
        {
          _in = document.getElementById("input");
          _out = document.getElementById("output");
          ConsoleOutput=_out;
          _win = window;
        
          /*make saome globals*/
          window.keys = shellCommands.keys;
          window.later = shellCommands.later;
          window.loop = shellCommands.loop;
          window.time = shellCommands.time;
          window.process = process;
          
          if (opener && !opener.closed)
          {
            _win = opener;
          }
        
          initTarget();
        
          recalculateInputHeight();
          refocus();
          
          codes = shellCommands.codes();
          console.log(codes)
          var i=1;
          for(var code in codes) {
            document.getElementById('code'+i).innerHTML = code; // codes[code].replace(/\..+$/,'');
            i++; 
          }
          for (;i<10;i++) document.getElementById('code'+i).style.display = "none";
          Code.print = function (msg) {
          // console.log(msg)
            if (typeof msg == 'object') {
              msg=inspect(msg);
              printHtml('<span class="print">'+msg+'</span>');
            } else printHtml(msg, "print")
          }
          Code.error = function (msg) {
            if (typeof msg == 'object') {
              msg=inspect(msg);
              printHtml('<span>'+msg+'</span>');
            } else printHtml(msg, "error")
          }
          if (Config.script) {
            console.log(Config.script);
            loadScript(Config.script,function () {
              console.log('Script '+Config.script+' loaded.');
            });
          }
          document.addEventListener('click', function enableNoSleep() {
            try {
              document.removeEventListener('click', enableNoSleep, false);
              var noSleep = new NoSleep();
              noSleep.enable();
              _win.print('Disabled Screensaver!');
            } catch (e) { console.log(e) }
          }, false);
        }
        
        function initTarget()
        {
          _win.Shell = window;
          _win.print = shellCommands.print;
          _win.printf = function () { shellCommands.print(sprintf.apply(this,arguments)) };
        }
        
        
        // Unless the user is selected something, refocus the textbox.
        // (requested by caillon, brendan, asa)
        function keepFocusInTextbox(e)
        {
          var g = e.srcElement ? e.srcElement : e.target; // IE vs. standard
        
          while (!g.tagName)
            g = g.parentNode;
          var t = g.tagName.toUpperCase();
          if (t=="A" || t=="INPUT")
            return;
        
          if (window.getSelection) {
            // Mozilla
            if (String(window.getSelection()))
              return;
          }
          else if (document.getSelection) {
            // Opera? Netscape 4?
            if (document.getSelection())
              return;
          }
          else {
            // IE
            if ( document.selection.createRange().text )
              return;
          }
        
          refocus();
        }
        
        function inputKeydown(e) {
          // Use onkeydown because IE doesn't support onkeypress for arrow keys
        
          //alert(e.keyCode + " ^ " + e.keycode);
        
          if (e.shiftKey && e.keyCode == 13) { // shift-enter
            // don't do anything; allow the shift-enter to insert a line break as normal
          } else if (e.keyCode == 13) { // enter
            // execute the input on enter
            try { go(); } catch(er) { alert(er); };
            setTimeout(function() { _in.value = ""; }, 0); // can't preventDefault on input, so clear it later
          } else if (e.keyCode == 38) { // up
            // go up in history if at top or ctrl-up
            if (e.ctrlKey || caretInFirstLine(_in))
              hist(true);
          } else if (e.keyCode == 40) { // down
            // go down in history if at end or ctrl-down
            if (e.ctrlKey || caretInLastLine(_in))
              hist(false);
          } else if (e.keyCode == 9) { // tab
            tabcomplete();
            setTimeout(function() { refocus(); }, 0); // refocus because tab was hit
          } else { }
        
          setTimeout(recalculateInputHeight, 0);
        
          //return true;
        };
        
        function caretInFirstLine(textbox)
        {
          // IE doesn't support selectionStart/selectionEnd
          if (textbox.selectionStart == undefined)
            return true;
        
          var firstLineBreak = textbox.value.indexOf("\n");
        
          return ((firstLineBreak == -1) || (textbox.selectionStart <= firstLineBreak));
        }
        
        function caretInLastLine(textbox)
        {
          // IE doesn't support selectionStart/selectionEnd
          if (textbox.selectionEnd == undefined)
            return true;
        
          var lastLineBreak = textbox.value.lastIndexOf("\n");
        
          return (textbox.selectionEnd > lastLineBreak);
        }
        
        function recalculateInputHeight()
        {
          var rows = _in.value.split(/\n/).length
            + 1 // prevent scrollbar flickering in Mozilla
            + (window.opera ? 1 : 0); // leave room for scrollbar in Opera
        
          if (_in.rows != rows) // without this check, it is impossible to select text in Opera 7.60 or Opera 8.0.
            _in.rows = rows;
        }
        
        function loadScript(url, callback){
        
            var script = document.createElement("script")
            script.type = "text/javascript";
        
            if (script.readyState){  //IE
                script.onreadystatechange = function(){
                    if (script.readyState == "loaded" ||
                            script.readyState == "complete"){
                        script.onreadystatechange = null;
                        if (callback) callback();
                    }
                };
            } else {  //Others
                script.onload = function(){
                    if (callback) callback();
                };
            }
        
            script.src = url;
            document.getElementsByTagName("head")[0].appendChild(script);
        }
        
        function loadText(url,callback){
            // read text from URL location
            console.log('loadText',document.URL,url);
            var request = new XMLHttpRequest();
        
            request.open('GET', url, true);
            request.send(null);
            request.onreadystatechange = function () {
                if (request.readyState === 4) {
                  callback( request.responseText );
                }
            }
        }
        function println(s, type)
        {
          if (typeof s == 'object') s=inspect(s);
          if((s=String(s)))
          {
            var newdiv = document.createElement("div");
            newdiv.appendChild(document.createTextNode(s));
            newdiv.className = type;
            _out.appendChild(newdiv);
            return newdiv;
          }
        }
        function printHtml(html, type)
        {
          {
            var newdiv = $("<div/>",{class:type});
            $(html).appendTo(newdiv);
            $(_out).append(newdiv);
            return newdiv;
          }
        }
        
        function printWithRunin(h, s, type)
        {
          var div = println(s, type);
          var head = document.createElement("strong");
          head.appendChild(document.createTextNode(h + ": "));
          div.insertBefore(head, div.firstChild);
        }
        
        function iter (a,func) {
          for(var p in a) func(a[p])
        }
        
        var shellCommands = {
        load : function load(url)
        {
          var s = _win.document.createElement("script");
          s.type = "text/javascript";
          s.src = url;
          _win.document.getElementsByTagName("head")[0].appendChild(s);
          println("Loading " + url + "...", "message");
        },
        
        get clear ()
        {
          var CHILDREN_TO_PRESERVE = 1;
          while (_out.childNodes[CHILDREN_TO_PRESERVE])
            _out.removeChild(_out.childNodes[CHILDREN_TO_PRESERVE]);
        },
        
        code : function code(index) {
          if (location.href.split('?').length==1) return;
          var params = location.href.split('?')[1].split('&');
          var data = {},i=1, file;
          
          for (var x in params)
          {
            if (params[x].split('=')[0]=='size') {
              fontSize=Number(params[x]);
              document.getElementsByTagName('body')[0].style.fontSize=params[x].split('=')[1]+'px';
              continue;
            }
            var tokens=params[x].split('=');
            if (tokens[0]=='title') continue;
            data[tokens[0]] = tokens[1];
            if (i==index) file=data[tokens[0]];
            i++;
          }  
          if (file) {
            loadText('code/'+file,function (text) {
              go(text)
            }); 
          } 
        },
        
        codes : function codes() {
          if (location.href.split('?').length==1) return;
          var params = location.href.split('?')[1].split('&');
          var data = {};
          
          for (var x in params)
          {
            if (params[x].split('=')[0]=='size') {
              fontSize=Number(params[x]);
              document.getElementsByTagName('body')[0].style.fontSize=params[x].split('=')[1]+'px';
              continue;
            }
            var tokens=params[x].split('=');
            if (tokens[0]=='title') {
              document.getElementById('title').innerHTML='WorkBook Live: '+tokens[1];
            } else
              data[tokens[0]] = tokens[1];
          }  
          return data;
        },
        
        compile : Context.compile,
        
        fontSize : function (delta) {
          fontSize += Number(delta);
          $('body').css('font-size',fontSize+'em');
        },
        
        keys : function (o) {
          return Object.keys(o)
        },
        
        loadData : function () {
          var datavar = prompt('Data target variable?');
          var binary=false;
          function cb(data) {
            go(datavar+'='+data+';',true);
            
          }
          var input = document.createElement('input');
          input.type = 'file';
          input.onchange = function (e) { 
            // getting a hold of the file reference
            var file = e.target.files[0]; 

            // setting up the reader
            var reader = new FileReader();
            if (binary)
              reader.readAsArrayBuffer(file);
            else  
              reader.readAsText(file,'UTF-8');

             // here we tell the reader what to do when it's done reading...
             reader.onload = function (readerEvent) {
                var content = readerEvent.target.result; // this is the content!
                // console.log( content );
                if (binary)
                  cb(new Uint8Array(content),input.files[0].name);
                else
                  cb(content,input.files[0].name)
             }
          }
          input.click();
        },
        
        get help ()
        {
        
        
          println([ "Features: autocompletion of property names with Tab,", 
                    "Features: multiline input with Shift+Enter, input history with (Ctrl+) Up/Down",      
                    "Functions: ans, print(string), inspect(object), props(object), ",
                    "Functions: blink(node), clear, load(scriptURL), scope(object)"].join('\n'),'print');
        
        },

        later : function (timeout,callback,final) {
          var counter=0;
          var timer=setInterval(function () {
            try {
              var res=callback.call(self,counter,counter);
            } catch (e) {
              if (typeof error != 'undefined') printError(e);
              else Code.error(e);
              res=0;
            }
            counter++;
            if (!res) {
              clearInterval(timer); 
              if (typeof final=='function') 
              try {
                final(counter,counter);
              } catch (e) {
                if (typeof error != 'undefined') printError(e);
                else printError(e);
              }
            }
          },timeout)
        },
        
        loop : function (callback,final,async) {
          var counter=0;
          if (typeof final=='boolean') async=final;
          if (!async) {
            while (callback(counter,counter++)) {};
            if (typeof final=='function') final(0,counter,counter); 
          }
          else {
            var timeout=1;
            var timer=setInterval(function () {
              try {
                var res=callback(counter,counter);
              } catch (e) {
                printError(e);
                res=0;
              }
              counter++;
              if (!res) {
                clearInterval(timer); 
                if (typeof final=='function') final(counter,counter); 
              }
            },timeout)
          }
        },

        print : function print() {
          var line=[];
          for(var i in arguments) {
            if (typeof arguments[i] == 'object') arguments[i]=inspect(arguments[i]);
            line.push(arguments[i]);
          }
          println(line.join(' , '), "print"); 
        },
        
        printf : function () { shellCommands.print(sprintf.apply(this,arguments)) },
        
        Table : function (data,options) {
          options=options||{};
          var table='<div style="margin:10px"><table style="border:1px solid; border-collapse: collapse; border-spacing: 0;">';
          if (Utils.isMatrix(data)) {
          } else if (Utils.isArray(data) && Utils.isObject(data[0])) {
            options.head=true;
            var head=Object.keys(data[0]);
            data=[head].concat(data.map(function (row) {
              return head.map(function (key) { return row[key] })
            }));
          } else return new Error('Table: Invalid data');
          if (Utils.isArray(options)) options={head:options};
          if (options.tiles && options.tiles.colors) {
            // display data table entries with coloted graphic tiles
            var colors = options.tiles.colors;
            var size = options.tiles.size||16;
            data.forEach(function (row,rowi) {
              table += '<tr style="padding:8px;">';
              row.forEach (function (col) {
                if (options.tiles.split) {
                  // <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
                  var parts = col.split(options.tiles.split);
                  if (parts.length==2) {
                    table += ('<td style="padding:5px;width:1em;background:white' +
                            '">'+
                            '<svg width="'+size+'" height="'+size+'">'+
                            '<polygon points="0,0 '+size+',0 0,'+size+'" style="fill:'+colors[parts[0]]+'"/>'+
                            '<polygon points="'+size+',0 '+size+','+size+' 0,'+size+'" style="fill:'+colors[parts[1]]+'"/>'+
                            '</svg>'+ 
                            '</td>');          
                  }
                } else {
                  table += ('<td style="padding:5px;width:1em;background:white' +
                            '">'+
                            '<svg width="'+size+'" height="'+size+'">'+
                            '<rect width="'+size+'" height="'+size+'" style="fill:'+colors[col]+'"/>'+
                            '</svg>'+ 
                            '</td>');
                }
              });
              table += '</tr>';
            });
          }
          else data.forEach(function (row,rowi) {
            if (options.head && rowi==0)
              table += '<tr style="padding:8px; font-weight:bold; '+
                       (options.highlight?'background:black;color:white':'')+
                       '">';
            else
              table += '<tr style="padding:8px;'+
                       (options.highlight && (rowi+(options.head?0:1))%options.highlight==0?'background:#ddd;':'')+
                       '">';
            row.forEach(function (col) {
              table += ('<td style="padding:5px;'+(options.head && rowi==0?'border-bottom:1px solid;':'') +
                        (options.size?'font-size:'+options.size+'px;':'')+
                        '">'+
                         col+
                         '</td>');
            });
            table += '</tr>';
          });
          table += ('</table></div>');
          printHtml(table,'print');
        },
        
        Plot : function (data,options) {
          var newdiv = $("<div/>",{
            class:'print',
          });
          Plot(newdiv,data,options);
          $(_out).append(newdiv);  
        },
        
        time : function () { return Date.now() },
        // the normal function, "print", shouldn't return a value
        // (suggested by brendan; later noticed it was a problem when showing others)
        pr : function pr(s)
        {
          shellCommands.print(s); // need to specify shellCommands so it doesn't try window.print()!
          return s;
        },
        
        props : function props(e, onePerLine)
        {
          if (e === null) {
            println("props called with null argument", "error");
            return;
          }
        
          if (e === undefined) {
            println("props called with undefined argument", "error");
            return;
          }
        
          var ns = ["Methods", "Fields", "Unreachables"];
          var as = [[], [], []]; // array of (empty) arrays of arrays!
          var p, j, i; // loop variables, several used multiple times
        
          var protoLevels = 0;
        
          for (p = e; p; p = p.__proto__)
          {
            for (i=0; i<ns.length; ++i) as[i][protoLevels] = [];
            ++protoLevels;
          }
        
          for(var a in e)
          {
            // Shortcoming: doesn't check that VALUES are the same in object and prototype.
        
            var protoLevel = -1;
            try
            {
              for (p = e; p && (a in p); p = p.__proto__)
                ++protoLevel;
            }
            catch(er) { protoLevel = 0; } // "in" operator throws when param to props() is a string
        
            var type = 1;
            try
            {
              if ((typeof e[a]) == "function")
                type = 0;
            }
            catch (er) { type = 2; }
        
            as[type][protoLevel].push(a);
          }
        
          function times(s, n) { return n ? s + times(s, n-1) : ""; }
        
          for (j=0; j<protoLevels; ++j)
            for (i=0;i<ns.length;++i)
              if (as[i][j].length)
                printWithRunin(
                  ns[i] + times(" of prototype", j),
                  (onePerLine ? "\n\n" : "") + as[i][j].sort().join(onePerLine ? "\n" : ", ") + (onePerLine ? "\n\n" : ""),
                  "propList"
                );
        },
        
        blink : function blink(node)
        {
          if (!node)                     throw("blink: argument is null or undefined.");
          if (node.nodeType == null)     throw("blink: argument must be a node.");
          if (node.nodeType == 3)        throw("blink: argument must not be a text node");
          if (node.documentElement)      throw("blink: argument must not be the document object");
        
          function setOutline(o) {
            return function() {
              if (node.style.outline != node.style.bogusProperty) {
                // browser supports outline (Firefox 1.1 and newer, CSS3, Opera 8).
                node.style.outline = o;
              }
              else if (node.style.MozOutline != node.style.bogusProperty) {
                // browser supports MozOutline (Firefox 1.0.x and older)
                node.style.MozOutline = o;
              }
              else {
                // browser only supports border (IE). border is a fallback because it moves things around.
                node.style.border = o;
              }
            }
          }
        
          function focusIt(a) {
            return function() {
              a.focus();
            }
          }
        
          if (node.ownerDocument) {
            var windowToFocusNow = (node.ownerDocument.defaultView || node.ownerDocument.parentWindow); // Moz vs. IE
            if (windowToFocusNow)
              setTimeout(focusIt(windowToFocusNow.top), 0);
          }
        
          for(var i=1;i<7;++i)
            setTimeout(setOutline((i%2)?'3px solid red':'none'), i*100);
        
          setTimeout(focusIt(window), 800);
          setTimeout(focusIt(_in), 810);
        },
        
        scope : function scope(sc)
        {
          if (!sc) sc = {};
          _scope = sc;
          println("Scope is now " + sc + ".  If a variable is not found in this scope, window will also be searched.  New variables will still go on window.", "message");
        },
        
        mathHelp : function mathHelp()
        {
          printWithRunin("Math constants", "E, LN2, LN10, LOG2E, LOG10E, PI, SQRT1_2, SQRT2", "propList");
          printWithRunin("Math methods", "abs, acos, asin, atan, atan2, ceil, cos, exp, floor, log", "propList");
          printWithRunin("Math methods", "max, min, pow, random, round, sin, sqrt, tan", "propList");
        },
        
        ans : undefined
        };
        
        
        function hist(up)
        {
          // histList[0] = first command entered, [1] = second, etc.
          // type something, press up --> thing typed is now in "limbo"
          // (last item in histList) and should be reachable by pressing
          // down again.
        
          var L = histList.length;
        
          if (L == 1)
            return;
        
          if (up)
          {
            if (histPos == L-1)
            {
              // Save this entry in case the user hits the down key.
              histList[histPos] = _in.value;
            }
        
            if (histPos > 0)
            {
              histPos--;
              // Use a timeout to prevent up from moving cursor within new text
              // Set to nothing first for the same reason
              setTimeout(
                function() {
                  _in.value = '';
                  _in.value = histList[histPos];
                  var caretPos = _in.value.length;
                  if (_in.setSelectionRange)
                    _in.setSelectionRange(caretPos, caretPos);
                },
                0
              );
            }
          }
          else // down
          {
            if (histPos < L-1)
            {
              histPos++;
              _in.value = histList[histPos];
            }
            else if (histPos == L-1)
            {
              // Already on the current entry: clear but save
              if (_in.value)
              {
                histList[histPos] = _in.value;
                ++histPos;
                _in.value = "";
              }
            }
          }
        }
        
        function tabcomplete()
        {
          /*
           * Working backwards from s[from], find the spot
           * where this expression starts.  It will scan
           * until it hits a mismatched ( or a space,
           * but it skips over quoted strings.
           * If stopAtDot is true, stop at a '.'
           */
          function findbeginning(s, from, stopAtDot)
          {
            /*
             *  Complicated function.
             *
             *  Return true if s[i] == q BUT ONLY IF
             *  s[i-1] is not a backslash.
             */
            function equalButNotEscaped(s,i,q)
            {
              if(s.charAt(i) != q) // not equal go no further
                return false;
        
              if(i==0) // beginning of string
                return true;
        
              if(s.charAt(i-1) == '\\') // escaped?
                return false;
        
              return true;
            }
        
            var nparens = 0;
            var i;
            for(i=from; i>=0; i--)
            {
              if(s.charAt(i) == ' ')
                break;
        
              if(stopAtDot && s.charAt(i) == '.')
                break;
        
              if(s.charAt(i) == ')')
                nparens++;
              else if(s.charAt(i) == '(')
                nparens--;
        
              if(nparens < 0)
                break;
        
              // skip quoted strings
              if(s.charAt(i) == '\'' || s.charAt(i) == '\"')
              {
                //dump("skipping quoted chars: ");
                var quot = s.charAt(i);
                i--;
                while(i >= 0 && !equalButNotEscaped(s,i,quot)) {
                  //dump(s.charAt(i));
                  i--;
                }
                //dump("\n");
              }
            }
            return i;
          }
        
          // XXX should be used more consistently (instead of using selectionStart/selectionEnd throughout code)
          // XXX doesn't work in IE, even though it contains IE-specific code
          function getcaretpos(inp)
          {
            if(inp.selectionEnd != null)
              return inp.selectionEnd;
        
            if(inp.createTextRange)
            {
              var docrange = _win.Shell.document.selection.createRange();
              var inprange = inp.createTextRange();
              if (inprange.setEndPoint)
              {
                inprange.setEndPoint('EndToStart', docrange);
                return inprange.text.length;
              }
            }
        
            return inp.value.length; // sucks, punt
          }
        
          function setselectionto(inp,pos)
          {
            if(inp.selectionStart) {
              inp.selectionStart = inp.selectionEnd = pos;
            }
            else if(inp.createTextRange) {
              var docrange = _win.Shell.document.selection.createRange();
              var inprange = inp.createTextRange();
              inprange.move('character',pos);
              inprange.select();
            }
            else { // err...
            /*
              inp.select();
              if(_win.Shell.document.getSelection())
                _win.Shell.document.getSelection() = "";
                */
            }
          }
            // get position of cursor within the input box
            var caret = getcaretpos(_in);
        
            if(caret) {
              //dump("----\n");
              var dotpos, spacepos, complete, obj;
              //dump("caret pos: " + caret + "\n");
              // see if there's a dot before here
              dotpos = findbeginning(_in.value, caret-1, true);
              //dump("dot pos: " + dotpos + "\n");
              if(dotpos == -1 || _in.value.charAt(dotpos) != '.') {
                dotpos = caret;
                //dump("changed dot pos: " + dotpos + "\n");
              }
        
              // look backwards for a non-variable-name character
              spacepos = findbeginning(_in.value, dotpos-1, false);
              //dump("space pos: " + spacepos + "\n");
              // get the object we're trying to complete on
              if(spacepos == dotpos || spacepos+1 == dotpos || dotpos == caret)
              {
                // try completing function args
                if(_in.value.charAt(dotpos) == '(' ||
         (_in.value.charAt(spacepos) == '(' && (spacepos+1) == dotpos))
                {
                  var fn,fname;
          var from = (_in.value.charAt(dotpos) == '(') ? dotpos : spacepos;
                  spacepos = findbeginning(_in.value, from-1, false);
        
                  fname = _in.value.substr(spacepos+1,from-(spacepos+1));
                  //dump("fname: " + fname + "\n");
                  try {
                    with(_win.Shell._scope)
                      with(_win)
                        with(Shell.shellCommands)
                          fn = eval(fname);
                  }
                  catch(er) {
                    //dump('fn is not a valid object\n');
                    return;
                  }
                  if(fn == undefined) {
                     //dump('fn is undefined');
                     return;
                  }
                  if(fn instanceof Function)
                  {
                    // Print function definition, including argument names, but not function body
                    if(!fn.toString().match(/function .+?\(\) +\{\n +\[native code\]\n\}/))
                      println(fn.toString().match(/function .+?\(.*?\)/), "tabcomplete");
                  }
        
                  return;
                }
                else
                  obj = _win;
              }
              else
              {
                var objname = _in.value.substr(spacepos+1,dotpos-(spacepos+1));
                //dump("objname: |" + objname + "|\n");
                try {
                  with(_win.Shell._scope)
                    with(_win)
                        obj = eval(objname);
                }
                catch(er) {
                  printError(er);
                  return;
                }
                if(obj == undefined) {
                  // sometimes this is tabcomplete's fault, so don't print it :(
                  // e.g. completing from "print(document.getElements"
                  // println("Can't complete from null or undefined expression " + objname, "error");
                  return;
                }
              }
              //dump("obj: " + obj + "\n");
              // get the thing we're trying to complete
              if(dotpos == caret)
              {
                if(spacepos+1 == dotpos || spacepos == dotpos)
                {
                  // nothing to complete
                  //dump("nothing to complete\n");
                  return;
                }
        
                complete = _in.value.substr(spacepos+1,dotpos-(spacepos+1));
              }
              else {
                complete = _in.value.substr(dotpos+1,caret-(dotpos+1));
              }
              //dump("complete: " + complete + "\n");
              // ok, now look at all the props/methods of this obj
              // and find ones starting with 'complete'
              var matches = [];
              var bestmatch = null;
              for(var a in obj)
              {
                //a = a.toString();
                //XXX: making it lowercase could help some cases,
                // but screws up my general logic.
                if(a.substr(0,complete.length) == complete) {
                  matches.push(a);
                  ////dump("match: " + a + "\n");
                  // if no best match, this is the best match
                  if(bestmatch == null)
                  {
                    bestmatch = a;
                  }
                  else {
                    // the best match is the longest common string
                    function min(a,b){ return ((a<b)?a:b); }
                    var i;
                    for(i=0; i< min(bestmatch.length, a.length); i++)
                    {
                      if(bestmatch.charAt(i) != a.charAt(i))
                        break;
                    }
                    bestmatch = bestmatch.substr(0,i);
                    ////dump("bestmatch len: " + i + "\n");
                  }
                  ////dump("bestmatch: " + bestmatch + "\n");
                }
              }
              bestmatch = (bestmatch || "");
              ////dump("matches: " + matches + "\n");
              var objAndComplete = (objname || obj) + "." + bestmatch;
              //dump("matches.length: " + matches.length + ", tooManyMatches: " + tooManyMatches + ", objAndComplete: " + objAndComplete + "\n");
              if(matches.length > 1 && (tooManyMatches == objAndComplete || matches.length <= 10)) {
        
                printWithRunin("Matches: ", matches.join(', '), "tabcomplete");
                tooManyMatches = null;
              }
              else if(matches.length > 10)
              {
                println(matches.length + " matches.  Press tab again to see them all", "tabcomplete");
                tooManyMatches = objAndComplete;
              }
              else {
                tooManyMatches = null;
              }
              if(bestmatch != "")
              {
                var sstart;
                if(dotpos == caret) {
                  sstart = spacepos+1;
                }
                else {
                  sstart = dotpos+1;
                }
                _in.value = _in.value.substr(0, sstart)
                          + bestmatch
                          + _in.value.substr(caret);
                setselectionto(_in,caret + (bestmatch.length - complete.length));
              }
            }
        }
        
        function printQuestion(q)
        {
          println(q, "input");
        }
        
        function printAnswer(a)
        {
          if (a !== undefined) {
            println(a, "normalOutput");
            shellCommands.ans = a;
          }
        }
        
        function printError(er)
        {
          var lineNumberString;
        
          lastError = er; // for debugging the shell
          if (er.name)
          {
            // lineNumberString should not be "", to avoid a very wacky bug in IE 6.
            lineNumberString = (er.lineNumber != undefined) ? (" on line " + er.lineNumber + ": ") : ": ";
            println(er.name + lineNumberString + er.message, "error"); // Because IE doesn't have error.toString.
          }
          else
            println(er, "error"); // Because security errors in Moz /only/ have toString.
        }
        
        function go(s,silent)
        {
          _in.value = question = s ? s : _in.value;
        
          if (question == "")
            return;
        
          if (!silent) {
            histList[histList.length-1] = question;
            histList[histList.length] = "";
            histPos = histList.length - 1;
          }
          // Unfortunately, this has to happen *before* the JavaScript is run, so that
          // print() output will go in the right place.
          _in.value='';
          recalculateInputHeight();
          if (!silent) printQuestion(question);
        
          if (_win.closed) {
            printError("Target window has been closed.");
            return;
          }
          
          try { ("Shell" in _win) }
          catch(er) {
            printError("The JavaScript Shell cannot access variables in the target window.  The most likely reason is that the target window now has a different page loaded and that page has a different hostname than the original page.");
            return;
          }
        
          if (!("Shell" in _win))
            initTarget(); // silent
          if (question.match(/;[\s\n]*$/)) silent=true;
          // Evaluate Shell.question using _win's eval (this is why eval isn't in the |with|, IIRC).
          //_win.location.href = "javascript:try{ Shell.printAnswer(eval('with(Shell._scope) with(Shell.shellCommands) {' + Shell.question + String.fromCharCode(10) + '}')); } catch(er) { Shell.printError(er); }; setTimeout(Shell.refocus, 0); void 0";
          try{ (silent?function () {}:printAnswer)(eval('with(_scope) with(shellCommands) {' + question + String.fromCharCode(10) + '}')); } catch(er) { printError(er); }; 
          setTimeout(refocus, 0);
        }
    </script>

    <style type="text/css">
        body { 
          color: black;   
          counter-reset: inputCounter; 
          font-size: clamp(18px,4vw,48px); 
          margin:0; 
        }
        html {
            width: 99%;
            height: 100%;
            margin: 0; /* Space from this element (entire page) and others*/
            padding: 15px; /*space from content and border*/
            border: solid #888;
            border-width: 0px;
            display:block;
            box-sizing: border-box;
            overflow-x:hidden;
        }
        html * {max-height:1000000px;}
        #output { white-space: pre-wrap; margin:0; padding:5px; } /* Preserve line breaks, but wrap too if browser supports it */
        h1 { font: bold 1.5em Arial; }
        h3 { margin-top: 0; margin-bottom: 0em; }
        h3 + span { margin: 0; }
        
        form { margin: 0; padding: 0; } /* disable auto.text sizing in mobile browsers */
        #input { 
          font-size:1.2em;
          width: -webkit-calc(100% - 19px);
          width:    -moz-calc(100% - 19px);
          width:         calc(100% - 19px);  
          border: none; 
          padding: 5px; 
          margin:5px;
          overflow: auto; 
          cursor: pointer; 
          border: 1px solid #888;
          border-radius: 5px;
          height: auto;
        }
        .input { padding: 5px; color: blue; background: white; font: inherit; font-family: 'mono'; font-weight: bold; 
                 font-size:1.2em !important; margin-top: .5em; overflow:auto; 
                 border: 1px solid #888;
                 border-radius:5px;
                 background: white;/* background: #E6E6FF; */ }
        
        .normalOutput {  font-family: 'mono'; font-size:1.2em; padding: 5px; color: black; background: white; word-wrap: break-word; }
        .print { font-family: 'mono'; font-size:1.2em; padding: 5px; color: brown; background: white; word-wrap: break-word; }
        .error { font-family: 'mono'; font-size:1.2em; padding: 5px; color: red; background: white; word-wrap: break-word; }
        .warning { font-family: 'mono'; font-size:1.2em; padding: 5px; color: green; background: white; word-wrap: break-word; }
        .propList { color: green; background: white; white-space: normal; }
        .message { color: green; background: white; }
        .tabcomplete { color: purple; background: white; }
        .button {
          font: bold 1.2em Arial;
          text-decoration: none;
          background-color: #EEEEEE;
          color: #333333;
          padding: 2px 6px 2px 6px;
          margin: 2px;
          border-top: 2px solid #888;
          border-right: 2px solid #888;
          border-bottom: 2px solid #888;
          border-left: 2px solid #888;
          border-radius: 5px;
        }
        /* jquery-ui */

        .ui-tooltip {
	        padding: 8px;
	        position: absolute;
	        z-index: 9999;
	        max-width: 300px
            border-radius: 5px;
            background-color:#eee;
        }

        body .ui-tooltip {
	        border-width: 2px
          border-radius: 5px;
          background-color:#eee;   
        }

    </style>
</head>

<body onload="init()">
  <div style="margin:10px">
  <span>
<h1 id="title">Web WorkShell Live</h1>
<a href="javascript:;" class="button" onclick="shellCommands.clear">CLEAR</a>&nbsp;<a href="javascript:;" class="button" onclick="shellCommands.loadData()">LOAD</a>&nbsp;<a href="javascript:;" class="button" onclick="shellCommands.fontSize(0.1)">+</a><a href="javascript:;" class="button" onclick="shellCommands.fontSize(-0.1)">-</a>&nbsp;<a href="javascript:;" class="button" onclick="shellCommands.code(1)" id="code1"></a><a href="javascript:;" class="button" onclick="shellCommands.code(2)" id="code2"></a><a href="javascript:;" class="button" onclick="shellCommands.code(3)" id="code3"></a><a href="javascript:;" class="button" onclick="shellCommands.code(4)" id="code4"></a><a href="javascript:;" class="button" onclick="shellCommands.code(5)" id="code5"></a><a href="javascript:;" class="button" onclick="shellCommands.code(6)" id="code6"></a><a href="javascript:;" class="button" onclick="shellCommands.code(7)" id="code7"></a><a href="javascript:;" class="button" onclick="shellCommands.code(8)" id="code8"></a><a href="javascript:;" class="button" onclick="shellCommands.code(9)" id="code9"></a>
</span>
  </div>
  <div id="output" style="margin-top:-2em">
  </div>
  <div><textarea id="input" class="input" wrap="off" onkeydown="inputKeydown(event)" rows="1" spellcheck="false"></textarea></div>
  <div id="overlay" style="width:100%;height:100%; position:absolute; top:0; left:0; display:none; background:white;">
</div></body>
</html>

