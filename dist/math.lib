var CoreModule = {};
CoreModule['com/io']='com/io';
CoreModule['com/pwgen']='com/pwgen.lw';
CoreModule['assert']='os/assert';
CoreModule['crypto']='os/crypto.rand';
CoreModule['events']='os/events';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['util']='util';
CoreModule['http']='http';
CoreModule['deasync']='deasync';
CoreModule['os']='os';
CoreModule['net']='net';
CoreModule['fs']='fs';
CoreModule['stream']='';
CoreModule['url']='';
CoreModule['zlib']='';
CoreModule['child_process']='';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
var Fs = require("fs");
if (typeof __dirname == 'undefined') __dirname = '';
if (typeof __filename == 'undefined') __filename = 'plugins/math/math.js';
//From compat.js
var any = undefined;
var empty = null;
var none = null;
var _ = undefined;
var int = function (v) {return v|0};
var div = function (a,b) {return a/b|0};
var print = function (msg) {console.log(msg)};
if (typeof global == 'undefined') global={};
PATH=[process.cwd(),".","/home/sbosse/proj/workbook/src",""];
function _isdir(path) {
  var stats=Fs.statSync(path);
  return stats && stats.isDirectory()};
function _search(index,file) {
  if (PATH.length==index) return file;
  var path=PATH[index];
  if (Fs.existsSync(path+"/"+file+".js")) return path+"/"+file+".js";
  else if (Fs.existsSync(path+"/"+file) && !_isdir(path+"/"+file)) return path+"/"+file;
  else return _search(index+1,file);
 }
var __library=arguments&&arguments[3];
function Require(modupath) { 
  var file,filepath;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}; var module={exports:exports};
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,global,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,global,process);
  else { try { file=_search(0,modupath); module = require(file)}
  catch (e) { var more="";
   if ((e.name==="SyntaxError"||e.name==="TypeError") && file) {
      var src=Fs.readFileSync(file,"utf8");
      var Esprima = Require("parser/esprima");
      try {
        var ast = Esprima.parse(src, { tolerant: true, loc:true });
        if (ast.errors && ast.errors.length>0) more = ", "+ast.errors[0];
      } catch (e) {
        if (e.lineNumber) more = ", in line "+e.lineNumber;
      }
   }
   console.log("Require import of "+modupath+" ("+file+") failed: "+e+more);
   // if (e.stack) console.log(e.stack);
   throw e; // process.exit(-1);
  }}
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
FilesEmbedded=global.FilesEmbedded = {};
FileEmbedd=global.FileEmbedd = function (path,format) {};
FileEmbedded=global.FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='node';

BundleModuleCode['com/io']=function (module,exports,global,process){
/**
 **      ==================================
 **      OOOO   OOOO OOOO  O      O   OOOO
 **      O   O  O    O     O     O O  O   O
 **      O   O  O    O     O     O O  O   O
 **      OOOO   OOOO OOOO  O     OOO  OOOO
 **      O   O     O    O  O    O   O O   O
 **      O   O     O    O  O    O   O O   O
 **      OOOO   OOOO OOOO  OOOO O   O OOOO
 **      ==================================
 **      BSSLAB, Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR.
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2020 BSSLAB
 **    $CREATED:     sbosse on 3/28/15.
 **    $VERSION:     1.7.1X
 **
 **    $INFO:
 *
 * This module encapsulates all IO operations (except networking) supporting
 * node.js applications.
 *
 **    $ENDOFINFO
 */

if (global.TARGET=='node')  { 

 /*
  ************
  ** Node.js
  ************
  */
 var util = require('util');
 var GetEnv = Require('os/getenv');
 var Base64 = Require('os/base64');
 var Fs = require('fs');
 var os = require('os');
 var child = require('child_process');

 var stderr_fun = function (str) { process.stderr.write(str); };
 var stdout_fun = function (str) { process.stdout.write(str); };

 /*
  ** node.js specific
  */

 var tracefile = undefined;
 var tracing = true;

 /**
 * Open a module and append all exported properties to the current global object.
 * (top-level scope)
 */
 global.open = function(name,as) {
   var module = Require(name);
   for (var p in module) {
     global[p] = module[p];
   };
   if (as) global[as]=module;
 }

/*
 ** node.js
 */
var io = {
    checkOptions : function(options,defaultOptions) {
      return Object.assign({}, defaultOptions||{}, options) },
      
    checkOption : function (option,defaultOption) { 
      return option==undefined? defaultOption:option },

    config: {
        columns:undefined,
        rows:undefined
    },
    /**************
     ** FILE IO
     ***************/
    /**
     *
     * @param fd
     */
    close: function (fd) {
        Fs.closeSync(fd);
    },
    /**
     *
     * @param path
     */
    exists: function (path) {
        return Fs.existsSync(path);
    },
    /**
     *
     * @param path
     */
    file_exists: function (path) {
        return Fs.existsSync(path);
    },
    /** Search a file by iterating global PATH variable.
     *
     * @param name  File name or partial (relative) path
     */
    file_search: function (name) {
        // Expecting global PATH variable !?
        if (this.file_exists(name)) return name; 
        else if (typeof PATH !== 'undefined') {
          for (var p in PATH) {
            if (this.file_exists(PATH[p]+'/'+name)) return (PATH[p]+'/'+name);
          }
          return undefined;
        } else return undefined;
    },
    /**
     *
     * @param path
     * @returns {number}
     */
    file_size: function (path) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            return stat.size;
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param timekind a c m
     * @returns {number}
     */
    file_time: function (path,timekind) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            switch (timekind) {
                case 'a': return stat.atime.getTime()/1000;
                case 'c': return stat.ctime.getTime()/1000;
                case 'm': return stat.mtime.getTime()/1000;
                default: return stat.mtime.getTime()/1000;
            }
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param mode
     * @returns {*}
     */
    open: function (path, mode) {
        return Fs.openSync(path, mode);
    },
    /**
     *
     * @param fd
     * @param len
     * @param foff
     */
    read: function (fd, len, foff) {
        // TODO
    },
    /**
     *
     * @param path
     * @returns {string|undefined}
     */
    read_file: function (path) {
        try {
            return Fs.readFileSync(path,'utf8');
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    read_file_bin: function (path) {
        try {
            return Fs.readFileSync(path);
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param fd
     */
    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {number}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return Fs.readSync(fd, buf, boff, len, foff);
    },
    /**
     *
     * @param fd
     */
    sync: function (fd) {
        Fs.fsyncSync(fd);
    },
    
    time: function () {
      return Date.now()
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {number}
     */
    write: function (fd, data, foff) {
        return Fs.writeSync(fd, data, foff);
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {number}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return Fs.writeSync(fd, buf, bpos, blen, foff);
    },
    /**
     *
     * @param path
     * @param {string} buf
     */
    write_file: function (path,str) {
        try {
            Fs.writeFileSync(path, str, 'utf8');
            return str.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param path
     * @param buf
     * @returns {*}
     */
    write_file_bin: function (path,buf) {
        try {
            Fs.writeFileSync(path, buf, 'binary');
            return buf.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param fd
     * @param {string} str
     * @returns {number}
     */
    write_line: function (fd, str) {
        return Fs.writeSync(fd, str+NL);
    },

    /****************
     ** CONSOLE IO
     ****************/
    /**
     *
     * @param msg
     */
    debug: function (msg) {
        console.error('Debug: ' + msg);
    },
    /**
     *
     * @param msg
     */
    err: function (msg) {
        console.error('Error: ' + msg);
        throw Error(msg);
    },
    /**
     *
     * @param msg
     */
    fail: function (msg) {
        console.error('Fatal Error: ' + msg);
        process.exit(0);
    },
    /**
     *
     * @param obj
     */
    inspect: function (obj,depth) {return util.inspect(obj,{showHidden: false, 
                                                            depth: depth?depth:2})},

    /**
     * 
     */
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (!e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        if (where==undefined) this.out(e);
        else this.out(where+': '+e);
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
     /**
     *
     * @param e
     * @param where
     */
    sprintstack: function (e) {
        var str='';
        if (e==_ || !e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .replace(/^Object.eval\s*\(/gm, '')
            .split('\n');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                if (str!='') str += '\n';
                str += '  at '+line;
            }
        }
        return str;
    },
   /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    /**
     *
     * @param msg
     */
    out: function (msg) {
        console.warn(msg)
    },
    /**
     *
     * @param msg
     */
    warn: function (msg) {
        console.warn('Warning: ' + msg);
    },
    /**
     *
     * @param fun
     */
    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    /**
     *
     * @param fun
     */
    set_stdout: function(fun) {
        stdout_fun=fun;
    },
    /**
     *
     * @param msg
     */
    stderr: function (msg) {
        stderr_fun(msg);
    },
    /**
     *
     * @param msg
     */
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            Fs.writeSync(tracefile, '[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        tracefile = Fs.openSync(path, 'w+');
        if (tracefile != undefined) this.tracing = false;
    },

    /**************
     ** Process control
     ***************/
    exit: function (n) {
        process.exit(n);
    },
    /**
     *
     * @returns {*} RSS HEAP in kBytes {data,heap}
     */
    mem: function () {
        var mem = process.memoryUsage();
        return {data:(mem.rss/1024)|0,heap:(mem.heapUsed/1024)|0};
    },
    /****************************
     ** Environment and Arguments
     ****************************/
    getenv: function (name, def) {
        return GetEnv(name, def);
    },
    workdir: function () {
        return this.getenv('PWD','');
    },

    /**
     *  @return {string []}
     */
    getargs: function () {
        return process.argv;
    },

    sleep: function(delay) {
      var start = new Date().getTime();
      while (new Date().getTime() < start + delay);
    },
    
    /**
     *  Process management
     */
    fork: child.fork,
    exec: child.exec,
    spawn: child.spawn,

    /**
     * OS
     */
    hostname: os.hostname

  };
} else {
 /*
  ************
  ** Browser
  ************
  */
  var tracing = true;
  var stderr_fun = function (str) { console.log(str); };
  var stdout_fun = function (str) { console.log(str); };
  var args=[];

  /**
  * Open a module and append all exported properties to the current global object.
  * (top-level scope)
  */
  global.open = function(name,as) {
    var module = Require(name);
    for (var p in module) {
      global[p] = module[p];
    };
    if (as) global[as]=module;
  }
  
  var io = {
    /*
    ************
    ** Browser
    ************
    */
    /*
     ** FILE IO
     * TODO WebStorage
     */
    close: function (fd) {
        return;
    },
    exists: function (path) {
        return false;
    },
    open: function (path, mode) {
        var fd = Fs.openSync(path, mode);
        return fd;
    },

    read: function (fd, len, foff) {
        // TODO
    },
    read_file: function (path) {
        return '';
    },

    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {*}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return -1;
    },
    sync: function (fd) {
        return;
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {*}
     */
    write: function (fd, data, foff) {
        return -1;
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {*}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return -1;
    },

    /*
     ** CONSOLE IO
     */
    debug: function (msg) {
        stderr_fun('Debug: ' + msg);
    },
    err: function (msg) {
        stderr_fun('Error: ' + msg);
        throw Error(msg);
    },
    fail: function (msg) {
        stderr_fun('Fatal Error: ' + msg);
    },
    inspect: function (obj) {
        return;
    },
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        stderr_fun('Stack Trace');
        stderr_fun('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                stderr_fun(line);
            }
        }
        stderr_fun('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (where==undefined) stderr_fun(e);
        else stderr_fun(where+': '+e);
    },
    /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    out: function (msg) {
        stdout_fun(msg)
    },
    warn: function (msg) {
        stderr_fun('Warning: ' + msg);
    },


    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    set_stdout: function(fun) {
        stdout_fun=fun;
    },

    stderr: function (msg) {
        stderr_fun(msg);
    },
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            this.log('[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        return undefined;
    },

    exit: function (n) {
        return;
    },
    getenv: function (name, def) {
        return def;
    },
    workdir: function () {
        return '';
    },
    /**
     *  @return {string []}
     */
    getargs: function () {
        return args;
    },
    set_args: function (argv) {
        args=argv;
    },
    inspect: function (o) {return '?'}
  };
}  
module.exports = io;
};
BundleModuleCode['os/getenv']=function (module,exports,global,process){
var util = require("util");
var url = require("url");

var fallbacksDisabled = false;

function _value(varName, fallback) {
  var value = process.env[varName];
  if (value === undefined) {
    if (fallback === undefined) {
      throw new Error('GetEnv.Nonexistent: ' + varName + ' does not exist ' +
                      'and no fallback value provided.');
    }
    if (fallbacksDisabled) {
      throw new Error('GetEnv.DisabledFallbacks: ' + varName + ' relying on fallback ' + 
                      'when fallbacks have been disabled');
    }
    return '' + fallback;
  }
  return value;
}

var convert = {
  string: function(value) {
    return '' + value;
  },
  int: function(value) {
    var isInt = value.match(/^-?\d+$/);
    if (!isInt) {
      throw new Error('GetEnv.NoInteger: ' + value + ' is not an integer.');
    }

    return +value;
  },
  float: function(value) {
    var isInfinity = (+value === Infinity || +value === -Infinity);
    if (isInfinity) {
      throw new Error('GetEnv.Infinity: ' + value + ' is set to +/-Infinity.');
    }

    var isFloat = !(isNaN(value) || value === '');
    if (!isFloat) {
      throw new Error('GetEnv.NoFloat: ' + value + ' is not a number.');
    }

    return +value;
  },
  bool: function(value) {
    var isBool = (value === 'true' || value === 'false');
    if (!isBool) {
      throw new Error('GetEnv.NoBoolean: ' + value + ' is not a boolean.');
    }

    return (value === 'true');
  },
  url: url.parse
};

function converter(type) {
  return function(varName, fallback) {
    if(typeof varName == 'string') { // default
      var value = _value(varName, fallback);
      return convert[type](value);
    } else { // multibert!
      return getenv.multi(varName);
    }
  };
};

var getenv = converter('string');

Object.keys(convert).forEach(function(type) {
  getenv[type] = converter(type);
});

getenv.array = function array(varName, type, fallback) {
  type = type || 'string';
  if (Object.keys(convert).indexOf(type) === -1) {
    throw new Error('GetEnv.ArrayUndefinedType: Unknown array type ' + type);
  }
  var value = _value(varName, fallback);
  return value.split(/\s*,\s*/).map(convert[type]);
};

getenv.multi = function multi(spec) {
  var key, value;
  var result = {};
  for(var key in spec) {
    var value = spec[key];
    if(util.isArray(value)) { // default value & typecast
      switch(value.length) {
        case 1: // no default value
        case 2: // no type casting
          result[key] = getenv(value[0], value[1]); // dirty, when case 1: value[1] is undefined
        break;
        case 3: // with typecast
          result[key] = getenv[value[2]](value[0], value[1]);
          break;
        default: // wtf?
          throw('getenv.multi(): invalid spec');
          break;
      }
    } else { // value or throw
      result[key] = getenv(value);
    }
  }
  return result;
};

getenv.disableFallbacks = function() {
  fallbacksDisabled = true;
};

getenv.enableFallbacks = function() {
  fallbacksDisabled = false;
};

module.exports = getenv;
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['plugins/math/math.js']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.28.2X
 **
 **    $INFO:
 **
 **  Extended math Library
 **
 **    $ENDOFINFO
 */

if (typeof Utils == 'undefined') Require('plugins/com/utils')
var MatrixTA = Require('plugins/math/matrixTA')
  MatrixTA.EVD = Require('plugins/math/matrixTA-EVD');
  MatrixTA.SVD = Require('plugins/math/matrixTA-SVD');
  
var VectorTA = Require('plugins/math/vectorTA')
var Matrix  = Require('plugins/math/matrix')
var Vector  = Require('plugins/math/vector')
var Line    = Require('plugins/math/line')
var Plane   = Require('plugins/math/plane')
var Stats   = Require('plugins/math/stats')
var DWT     = Require('plugins/math/dwt5')
var Numeric = Require('plugins/math/numeric')
var Regression  = Require('plugins/math/regression')
var Polyfit     = Require('plugins/math/polyfit')
var Smoothers   = Require('plugins/math/smoothers')
var LinLogReg   = Require('plugins/ml/reg')
Require('plugins/math/matja')

// Generic array vector & matrix modules
Math.Line     = Line;
Math.Matrix   = Matrix;
Math.Plane    = Plane;
Math.Vector   = Vector;
Math.DWT      = DWT;
Math.numeric  = Numeric;
Math.regression = {
  polyfit : Polyfit,
  linlog  : LinLogReg,
  regression : Regression,
  smoothers : Smoothers,
};
Math.statistics = Stats;

// Typedarray vector & matrix modules
Math.MatrixTA = MatrixTA;
Math.VectorTA = VectorTA;

var FFT     = Require('plugins/math/fft')
Math.FFT    = FFT;
var CONV    = Require('plugins/math/conv')
Math.Convolution = CONV;

Math.version  = '1.28.2X'

var none = null;

// Dynamic array method extensions (more extension in MatrixTA!)
Object.addProperty(Array,'abs', function () {
  return this.map(Math.abs)
})
Object.addProperty(Array,'add', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b+v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b+v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]+v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]+v })});
  }
})
Object.addProperty(Array,'contains', function (elements,test,single) {
  if (Utils.isArray(elements) && !single)  {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (this[i]==elements[j]) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (test(this[i],elements[j])) return true;  
      } 
  
  } else {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        if (this[i]==elements) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        if (test(this[i],elements)) return true;  
      } 
  }
  return false;
})
Object.addProperty(Array,'div', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b[j][i] })});
  }
})
if (!Array.prototype.flat) {
  Object.addProperty(Array,'flat', function flat () {
    var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

    return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
      if (Array.isArray(cur)) {
        acc.push.apply(acc, flat.call(cur, depth - 1));
      } else {
        acc.push(cur);
      }
      return acc;
    }, []) : Array.prototype.slice.call(this);
  })
}

Object.addProperty(Array,'head', function (num) {
  return this.slice(0,num||1);
})

Object.addProperty(Array,'index', function (offset) {
  offset=offset||0;
  return this.map(function (v,i) { return i+offset });
})

Object.addProperty(Array,'mul', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b*v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b*v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]*v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]*v })});
  }
})

if (!Array.prototype.includes) {
  Object.addProperty(Array,'includes', function (r,e) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var t = Object(this),
            n = t.length >>> 0;
        if (0 === n) return !1;
        var i, o, a = 0 | e,
            u = Math.max(0 <= a ? a : n - Math.abs(a), 0);
        for (; u < n;) {
            if ((i = t[u]) === (o = r) || "number" == typeof i && "number" == typeof o && isNaN(i) && isNaN(o)) return !0;
            u++
        }
        return !1
    });
};
Object.addProperty(Array,'intersect', function (second) {
  var result=[];
  for(var i=0;i<this.length;i++) {
    for(var j=0;j<second.length;j++)
      if (Math.equal(this[i],second[j])) result.push(this[i]);
  }
  return result;
})

Object.addProperty(Array,'loop', function (callback,tmo) {
  var self=this;
  Code.later(tmo||1,function (id,index) {
    callback(self[index],index);
    return index<(self.length-1);
  })
})

Object.addProperty(Array,'match', function (test) {
  if (test.length != this.length) return false;
  for(var i=0;i<this.length;i++) if (this[i]!=test[i]) return false;
  return true;
})

Object.addProperty(Array,'pad', function (size,v,left) {
  v=v||0;
  if (size<this.length) return this.slice();
  var ext = Array.init(size-this.length,v);
  if (!left) return this.concat(ext);
  else return ext.concat(this);
})

Object.addProperty(Array,'sample', function (frag,filter) {
  var m = Math.floor(this.length/frag),
      i,
      fn,
      s=0,
      res=[];
  filter=filter||'mean';
  switch (filter) {
    case 'mean':
      fn=function (a,b,i) {
        if (i!=frag-1) return a+b;
        else return (a+b)/frag;
      };
      break;
    case 'peak':
      fn=function (a,b,i) {
        return a>b?a:b;
      };
      break;
  }
  for(i=0;i<m;i++) {
    s=this.slice(i*frag,i*frag+frag).reduce(fn);
    res.push(s);
  }
  return res;
})

Object.addProperty(Array,'shuffle', function () {
  var array=this;
  for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;  
});

Object.addProperty(Array,'split', function (frag) {
  var rows = this.length/frag,
      cols = frag,
      j,
      mat=[];
  for(j=0;j<rows;j++) {
    mat.push(this.slice(j*cols,j*cols+cols));
  }
  return mat;
})

Object.addProperty(Array,'subtract', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b[j][i] })});
  }
})
Object.addProperty(Array,'tail', function (num) {
  return this.slice(this.length-(num||1));
})
Object.addProperty(Array,'toObject', function (keys) {
  var o={};
  for(var i=0;i<this.length;i++) {
    var key = keys?keys[i]||String(i):String(i);
    o[key]=this[i];
  }
  return o;
})
Object.addProperty(Array,'without', function (without) {
  if (Utils.isArray(without)) {
    return this.filter(function (el) {
      var found=false;
      for(var i=0;i<without.length;i++) 
        found = found  | Math.equal(el,without[i])
      return !found; 
    });
  } else return this.filter(function (el) { return !Math.equal(el,without) });
})

// Static array method extensions

// Simple array array matrix
Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
Array.matrix3d =  function (n,m,k,init) {
    var x,y,z,mat;
    mat=new Array(n);
    for(x=0;x<n;x++) {
      mat[x]=new Array(m);
      for(y=0;y<m;y++) {
        mat[x][y]=new Array(k);
        if (init!=undefined) {
          if (typeof init == 'function')
            for(var z=0;z<k;z++) mat[x][y][z]=init(x,y,z);
          else
            for(var z=0;z<k;z++) mat[x][y][z]=init; 
        }  
      }
    }
    return mat;
  };
Array.random = function (n,a,b) {
  var res=[];
  a=a||0;
  b=b||1;
  for(var i=0;i<n;i++) res.push(Math.random()*(b-a)+a);
  return res;
}

Array.sequence = function (a,b,step) {
  var res=[], preci=1;
  step=step||1;
  if (step < 1) {
    preci = Math.ceil(Math.log10(1/step))
    for(var i=a;i<=b;i += step) res.push(Math.precision(i,preci));
  } else for(var i=a;i<=b;i += step) res.push(i);
  return res;
}

// Transpose matrix (array of arrays) by swapping rows and columns
Array.transpose = function (matrix) {
  var t=[];
  for (var i=0;i<matrix[0].length;i++) {
    var row=[];
    for(var j=0;j<matrix.length;j++) {
      row.push(matrix[j][i]);
    }
    t.push(row);
  }
  return t;
}  
// Simple array vectorA
Array.vector = function (cols,init) {
    if (init==undefined) init=0;
    var row=[];
    for(var j=0;j<cols;j++) row.push(typeof init == 'function'?init(j):init);
    return row;
  };
Array.init=Array.vector;

// Dynamic Object method extensions

Object.addProperty(Object,'toArray', function () {
  var self=this;
  return Object.keys(this).map(function (key) {
    return self[key]
  })
})


// Angle of line (p1,p2)  or delty vector
// +---------X
// |    270
// | 180 *  0
// |    90 
// Y
Math.angle = function (p1,p2) {
  var pd=[],i=0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') {
        if (i==0) dx=(p1[p]-p2[p]);
        else if (i==1) dy=(p1[p]-p2[p]);
        i++;
      }
  } else { 
    for(var p in p1) {
        if (i==0) dx=p1[p];
        else if (i==1) dy=p1[p];
        i++;    
    }
  }
  var theta = Math.atan2(dy, dx); // range (-PI, PI]
  theta *= 180 / Math.PI;
  if (theta < 0) theta = 360 + theta; // range [0, 360)
  return theta;
}
// mass of center of (optionally weighted) points
// typeof @pts = {x:numebr,y:number,weight?:number } | number [x,y] []
Math.center = function (pts) {
  var n,center,weight,totalmass=0,totalx=0,totaly=0;
  for (var i in pts)
  {
    n=pts[i]; if (n.length==2) n={x:n[0],y:n[1]};
    weight=(n.weight==undefined?1:n.weight);
    totalmass += weight;
    totalx += (n.x*weight);
    totaly += (n.y*weight);
  }
  center = {x:totalx/totalmass,y:totaly/totalmass}
  return center;
}

// Coding and Decoding

// Multi-level: Math.code(['A','B','C'],{A:1,B:2,C:4}) -> 7
// One-hot:     Math.code('A',['A','B','C']) -> [1,0,0]
Math.code = function (list,codes) {
  var y=0;
  if (typeof list == 'string' && Utils.isArray(codes)) {
    // One-hot
    var width = codes.length,
        index = codes.indexOf(list);
    y=[];
    for(var i=0;i<width;i++) y.push(i==index?1:0);
    return y;
  }
  // Multi-level
  if (!Utils.isArray(list)) list=[list];
  for(var i=0;i<list.length;i++) {
    if (list[i]!=undefined) y += (codes[list[i]]); 
  }
  return y; 
}
Math.contains = function (a,element) {
  if (Utils.isArray(a)) {
    return a.contains(element,Math.equal,true);
  } else if (Uitls.isObject(a)) {
    
  } else if (typeof a == 'string') {
    return a.indexOf(String(element))!=-1
  } 
}
// Returns dataspace and datatype of numerical objects
Math.dataspace = function (o) {
  if (Utils.isArrayArrayArray(o)) return [o.length,o[0].length,o[0][0].length];
  else if (Utils.isArrayArray(o)) return [o.length,o[0].length];
  else if (Utils.isArray(o))  return [o.length].concat(Math.dataspace(o[0]));
  else if (Math.Matrix.isMatrix(o)) return [o.rows,o.columns];
  else if (Math.MatrixTA.isMatrix(o)) return [o.rows,o.columns];
  else if (Utils.isBuffer(o)) return [o.length];
  return [];
}
Math.datatype = function (o,sig) {
  if (Utils.isArrayArray(o)) return Math.datatype(o[0][0],sig)+(sig?' [][]':'');
  else if (Utils.isArray(o))  return Math.datatype(o[0],sig)+(sig?' []':'');
  else if (Math.Matrix.isMatrix(o)) return Math.datatype(o.data[0][0],sig)+(sig?' Matrix':'');
  else if (Math.MatrixTA.isMatrix(o)) return o.datatype+(sig?' MatrixTA':'');
  else if (Utils.isBuffer(o)) return 'Buffer';
  else if (typeof o == 'object') return '{'+Object.keys(o).map(function (key) {
    return key+':'+Math.datatype(o[key],sig)
  }).join(',')+'}';
  return typeof o;
}

// Multi-level: Math.decode(7,{A:1,B:2,C:4}) -> ['A','B','C']
// One-hot:     Math.decode([1,0,0],['A','B','C'])
Math.decode = function (value, codes,mutual) {
  var list=[],y=value;
  if (Utils.isArray(value) && Utils.isArray(codes)) {
    // One-hot
    return codes[value.indexOf(value.max())]
  }
  // Multi-level
  if (mutual == undefined) {
    var sum=0;
    Object.keys(codes).forEach(function (code,index) {
      if (codes[code] & sum) mutual=true;
      if (codes[code]==0) mutual=true;
      sum += codes[code];
    })
  }
  Object.keys(codes).forEach(function (code) {
    if (mutual || y<0 || codes[code]<0) {
      if (y==codes[code]) list.push(code) 
    } 
    else 
    if ((y & codes[code]) ||
        y==codes[code]) list.push(code);
  })
  return list; 
}

// API changed! h/points swapped!
Math.derivative = function (data,order,h,points) {
  // https://math.stackexchange.com/questions/302160/correct-way-to-calculate-numeric-derivative-in-discrete-time
  var result;
  data=data.data||data; // comp. with Matrix
  order=order||1;
  points=points||2;
  h=h||1;
  if (Utils.isArray(data)) {
    result=[];
    switch (order) {
      case 1:
        switch (points) {
          case 1:
            for(var i=0; i<(data.length-1); i++) {
              result.push((data[i+1]-data[i])/h);
            }
            break;
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-data[i-1])/(2*h));
            }
            break;
          case 3:
            for(var i=2; i<(data.length-3); i++) {
              result.push((data[i-2]-8*data[i-1]+8*data[i+1]-data[i+2])/(12*h));
            }
            break;
        }
        break;
       case 2:
        switch (points) {
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-2*data[i]+data[i-1])/(h*h));
            }
            break;
        }
        break;
    }
  }
  return result;
} 
Math.delta = function (p1,p2) {
  var pd=p1.length?[]:{};
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') pd[p]=p1[p]-p2[p];
  } 
  return pd;
}
Math.distance = function (p1,p2) {
  var y=1;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') y+=Math.pow(p1[p]-p2[p],2);
  } else {
    for(var p in p1) 
      if (typeof p1[p] == 'number') y+=Math.pow(p1[p],2);
  }
  return Math.sqrt(y) 
}
Math.deviation = function (values) {
  // d3.deviation comp. via variance (n-1)
  var v = Math.variance(values);
  return v ? Math.sqrt(v) : v;
}
Math.equal = function (a,b) {
    var i;
    if (Utils.isNumber(a) && Utils.isNumber(b)) return a==b;
    else if (Utils.isArray(a) && Utils.isArray(b)) {
      if (a.length!=b.length) return false;
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isObject(a) && Utils.isObject(b)) {
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isString(a) && Utils.isString(b))
      return (a.length==b.length && a==b)
    return false;
  }
Math.frac = function (x,frac) {
  if (frac<=1) {
    frac=(1/frac)|0;
    return Math.round(x*frac)/frac;
  } else {
    return Math.floor(x-(x%frac));
  }
}
Math.id = function (x) { return x }
Math.int = function (x) { return x|0 }
Math.decr = function (x) { return x-1 }
Math.incr = function (x) { return x+1 }

// Find and return nearest point in a point series {x=index in points,y=best value}
Math.nearest = function (points,valu,epsilon,test) {
  var best;
  if (!test) {
    for(var i in points) {
      if (epsilon==undefined) { // find any nearest value
        if (best==undefined ||
            Math.abs(points[i]-valu)<Math.abs(points[best]-valu))
          best=i;
      } else {
        if ((best!=undefined && Math.abs(points[i]-valu)<Math.abs(points[best]-valu))||
            (Math.abs(points[i]-valu) <= epsilon)) best=i;
      }
    }
  }
  if (best!=undefined) return {x:best,y:points[best]}
}

Math.precision = function (number, precision) {
  var factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
}
// generate gaussian noise (Standard Normal variate using Box-Muller transform)
// https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
Math.random.gaussian = function (min,max,skew) {
    min=min||0;
    max=max||1;
    skew=skew||1;
    var u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    var num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) num = Math.random.gaussian(min, max, skew); // resample between 0 and 1 if out of range
    num = Math.pow(num, skew); // Skew
    num *= max - min; // Stretch to fill range
    num += min; // offset to min
    return num;
}
// uniform distribution
Math.random.int = function (n) {
  return (Math.random()*n)|0
}
Math.random.range = function(min,max) {
  return min+Math.random()*(max-min)
}
Math.random.interval = function(min,max) {
  return Math.round(min+Math.random()*(max-min))
}
Math.random.noise = function(val,eps,relative) {
  return relative?val+Math.random.gaussian(-Math.abs(val*eps),Math.abs(val*eps)):val+Math.random.gaussian(-eps,eps);
}
Math.random.frac = function (a,b,frac) {
    var r,n,p,i,keys,k;
    if (Utils.isArray(a)) {
      n = a.length;
      if (n>0)
        return a[Math.random.int(n)];  
      else
        return none;
    } else if (Utils.isObject(a)) {
      keys=Object.keys(a);
      n = keys.length;
      if (n>0)
        return a[keys[Math.random.int(n)]];  
      else
        return none;
    } else if (b==undefined) {b=a;a=0}; 
    if (!frac ||frac==1)
      return Math.random.interval(a,b);
    else {
      r=Math.random.range(a,b);
      return ((r/frac)|0)*frac;
    }
}

// Random selection (one or multiple samples from collection / array / object)
Math.random.select = function (o,samples) {
  var r,n,p,i,keys,k;
  if (samples) {
    var A=[],index;
    var data = Utils.isArray(o)?o:Utils.isObject(o)?Object.keys(o):[];
    function shuffle(array) {
      var m = array.length, t, i;
      // While there remain elements to shuffle
      while (m) {
        // Pick a remaining element
        i = Math.floor(Math.random() * m--);
        // And swap it with the current element.
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }
      return array;
    }
    index=Array(data.length).fill().map(function (x,i) { return i });
    index=shuffle(index);
    for(var i=0;i<samples;i++) {
      A.push(data[index[i]]);
    }
    if (Utils.isArray(o)) return A;
    else if (Utils.isObject(o)) {
      return A.map(function (key) { o[key] });
    }
  }
  if (Utils.isArray(o)) {
    n = o.length;
    if (n>0)
      return o[Math.random.int(n)];  
    else
      return none;
  } else if (Utils.isObject(o)) {
    keys=Object.keys(o);
    n = keys.length;
    if (n>0)
      return o[keys[Math.random.int(n)]];  
    else
      return none;
  }
}

Math.pulse = function (length,off,on,pulses) {
  var v = Array.init(length,off);
  if (!Utils.isMatrix(pulses)) pulses=[pulses];
  pulses.forEach(function (pulse) {
    if (Utils.isArray(pulse) && pulse.length==2) 
      for(var i=pulse[0];i<=pulse[1];i++) v[i]=on;
  });
  return v;
}

// Reshape an array or a matrix
Math.reshape = function (array, rows, cols ) {
  var dims = cols!=undefined?[rows,cols]:[rows];
  function _reshape (array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array
    var tmpArray2
    // for each dimensions starting by the last one and ignoring the first one
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex]
      tmpArray2 = []

      // aggregate the elements of the current tmpArray in elements of the requested size
      var length = tmpArray.length / size
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size))
      }
      // set it as the new tmpArray for the next loop turn or for return
      tmpArray = tmpArray2
    }

    return tmpArray
  }
  function _flatten (array) {
    var flat = []

    array.forEach(function callback (value) {
      if (Array.isArray(value)) {
        value.forEach(callback) // traverse through sub-arrays recursively
      } else {
        flat.push(value)
      }
    })
    return flat
  }
  return _reshape(_flatten(array),dims)
  
}

Math.scale = function (vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return scala.shift+(vrow-scala.off)*scala.k
    else if (scala.length)
      return scala[0].shift+(vrow-scala[0].off)*scala[0].k;
    else
      return scala.shift+(vrow-scala.off[0])*scala.k[0];
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off)*scala.k })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return scala[i].shift+(col-scala[i].off)*scala[i].k })
  else
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off[i])*scala.k[i] })
}

// Compute scaling descriptor for a given data set -> [0,1]
// Target output range of scaled data: [shift+0,shift+1] with shift=shift||0;
Math.scale0 = function (data,shift) {
  var min=data.min(),
      max=data.max();
  shift=shift||0;
  return {
    k:(1-shift)/(max-min),
    off:min,
    shift:shift,
    min:min,
    max:max
  }
}
Math.scale1 = function (min,max,shift) {
  shift=shift||0;
  return {
    k:(1-shift)/(max-min),
    off:min,
    shift:shift,
    min:min,
    max:max
  }
}


// Returns a number sequence set
Math.sequence = Array.sequence;

// Math core extensions
Math.signal = {
  energy: function (data) {
    if (Utils.isArray(data)) {
      var s=0;
      data.forEach(function (v) {
        s+= Math.pow(v,2);
      });
      return s/data.length;
    }
  },
  filter : {
    boxcar : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||3;
      switch (points) {
        case 3:
          for(var i=1;i<array.length-1;i++) result.push(
            (array[i-1]+array[i]+array[i+1])/3
          );
          return result;
          break;
      }
    },
    lowpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.z == undefined) state.z=0;
      t=(1-k)*x+state.z*k;
      y=t;
      state.z=t;
      return y;
    },
    highpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.y == undefined) state.y=0;
      if (state.x == undefined) state.x=0;
      // t=(1-k)*x+state.z*(-k);
      t=k*(state.y+x-state.x);
      y=t;
      state.y=t;
      state.x=x;
      return y;    
    },
    // Function constructors
    lowPass : function (k,state) {
      return function (x) { return Math.signal.filter.lowpass(x,k,state) }
    },
    highPass : function (k,state) {
      return function (x) { return Math.signal.filter.highpass(x,k,state) }
    },
    triangular : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||5;
      switch (points) {
        case 5:
          for(var i=2;i<array.length-2;i++) result.push(
            (array[i-2]+2*array[i-1]+3*array[i]+2*array[i+1]+array[i+2])/9
          );
          return result;
          break;
      }
    },
    
  },
  meanAbsoluteDeviation: function(data) {
    var mean = Math.signal.mean(data);
       return Math.signal.mean(data.map(function(num) {
         return Math.abs(num - mean);
       }));
  },
  mean:function (data) { return data.mean() },
  peak: function (data) {
    if (Utils.isArray(data)) {
      return Math.max(Math.abs(data.max()),Math.abs(data.min()));
    }  
  },
  rms: function (data) {
    return Math.sqrt(data.map(Math.sq).sum()/data.length)
  },
  sample : function (data,frag,filter) {
    return data.sample(frag,filter)
  },
  standardDeviation: function(data) {
    return Math.sqrt(Math.signal.variance(data));
  },
  variance: function (data) {
    if (Utils.isArray(data)) {
      return data.variance()
    }
  },
}

Math.sq = function (x) { return x*x }

Math.variance = function (values) {
  var count = 0;
  var delta;
  var mean = 0;
  var sum = 0;
  for (var value of values) {
    if (value != null && (value = +value) >= value) {
      delta = value - mean;
      mean += delta / ++count;
      sum += delta * (value - mean);
    }
  }
  if (count > 1) return sum / (count - 1);
}

Math.window = {
  // window functions returning mask array of width w
  // https://github.com/scijs/window-function
  
  //////////////// WINDOWS ////////////////
  gaussian : function (w,sigma) {
    var res=[];
    sigma=sigma||0.4;
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i-nm12)/sigma/nm12,
          h=Math.exp(-0.5*f*f);
      res.push(h)
    }
    return res;
  },
  
  hamming : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 0.54 - 0.46 * Math.cos(Math.PI*2*i/(w-1));
      res.push(h)
    }
    return res;
  },
  
  hann: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      var t = -0.9999999+2*(i/(w+1));
      var h = Math.sqrt(2)/2 * (1+Math.cos(t*Math.PI)) / 
              Math.sqrt(1+Math.pow(Math.cos(t*Math.PI),2) ) * (
              Math.abs(t)<1?1:0);
      res.push(h)
    }
    return res;
  },
  
  rect: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      res.push(1)
    }
    return res;
  },
  
  triangular : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 1 - Math.abs( 2 * (i - 0.5*(w-1)) / w );
      res.push(h)
    }
    return res;
  },
  
  welch : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i - nm12)/nm12,
          h = 1 - f*f  ;
      res.push(h)
    }
    return res;
  },
  
  /////////////////////// MASKING /////////////////////  
  mask: function (data,off,width,win,arg) {
    var mask = (win||Math.window.hann)(width,arg);
    var res=[];
    for(var i=0;i<width;i++) res.push(data[off+i]*mask[i]);
    return res;
  },
  

}
Math.zip = function (v1,v2) {
  if (typeof v1[0]=='number' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return [row,v2[index]]
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return row.concat(v2[index])
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return row.concat([v2[index]])
    })
  if (typeof v1[0]=='number' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return [row].concat(v2[index])
    })
  
} 
if (typeof module != 'undefined') module.exports=Math
if (typeof window != 'undefined') console.log('Math '+Math.version+' loaded.');
};
BundleModuleCode['plugins/com/utils']=function (module,exports,global,process){
var fs      = require('fs');
var http    = require('http');
var deasync = require('deasync');
var util    = require('util');

var https;
try { https=require('https') } catch (e) {};

JSONfn = Require('plugins/com/jsonfn');

if (typeof print == 'undefined') print=console.log;

function POST(url, data, cb) {
  var params,headers;
  if (data && data.params && data.data != undefined) {
    params=data.params;
    headers=data.headers;
    data=data.data;
  }
  var ishttps= url.match(/https:/);
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  var post_data = typeof data == 'string'?data:JSONfn.stringify(data);

  var post_options = {
      host: host,
      port: port,
      path: '/'+path+params,
      method: 'POST',
      keepAlive: true,
      headers: headers || {
          'Content-Type': 'application/json', // ?? 'application/x-www-form-urlencoded',
          // 'Content-Length': Buffer.byteLength(post_data)
          // 'Content-Length': post_data.length,
      }
  };
  // console.log('POST', post_options,post_data)
  var post_req = (ishttps?https:http).request(post_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('POST: ',result);
        } catch (e) { print(data); result=e; }
        if (cb) cb(result);
      });
  });
  post_req.on('error',function (err) {
    if (cb) cb(err); else console.log(url,err)
  });
  post_req.setNoDelay();
  // console.log('POST: ',post_data);
  // post the data
  post_req.write(post_data);
  post_req.end();
}
var POSTsync = deasync(function(url,data,cb) {
  POST(url,data,function (result) {
    cb(null,result);
  })
})

function GET(url,params, cb) {
  var ishttps= url.match(/https:/)!=null;
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  path += params; 
  // print(host,path,port,ishttps)
  var get_options = {
      host: host,
      port: port,
      path: path,
      method: 'GET',
      keepAlive: true,
      headers: {
          // 'Content-Type': 'application/x-www-form-urlencoded',
      }
  };
  // console.log('GET', post_options,post_data)
  var get_req = (ishttps?https:http).request(get_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('GET: ',result);
        } catch (e) { result=e; }
        if (cb) cb(result);
      });
  });
  get_req.on('error',function (err) {
    // console.log(err)
    if (cb) cb(err); else console.log(url,err);
  });
  get_req.setNoDelay();
  // get_req.write();
  get_req.end();
}
var GETsync = deasync(function(url,params,cb) {
  GET(url,params,function (result) {
    cb(null,result)
  })
})

Common = {
  existFile: function (file) {
    try {
      var stat=fs.statSync(file);
      return stat?true:false;
    } catch (e) {
      return false;
    }
  },
  loadFile: function (file,callback) {
    try {
      var text = fs.readFileSync(file,'utf8');
      // var data = JSONfn.parse(text);
      if (callback) return callback(text);
      else return text;
    } catch (e) {
      if (callback) return callback(data);
      else return e
    }
  },
  saveFile: function (data,file,mimetype) {
    try {
      var data = typeof data=='string'?data:JSONfn.stringify(data);
      return fs.writeFileSync(file,data,'utf8');
    } catch (e) {
      return e
    }
  }
}

Utils = {

  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  format : function (args) {
    // format array of arguments like console.log
    var s='',sep='';
    for(var i in args) {
      switch (typeof args[i]) {
        case 'number':
        case 'string':
        case 'boolean':
          s += (sep+args[i]);
          break;
        case'function':
          s += (sep+'[Function]');
          break;
        case'object':
          s += (sep+util.inspect(args[i]));
          break;
      }
      sep = ' ';
    }
    return s;
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*\([^\)]+\))/)[1];
    }
  },

  inspect : Require('util').inspect,

  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isArrayArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]) &&
                Utils.isArray(o[0][0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isMatrix: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return (Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isNumber(o) {
      return typeof o == "boolean"
  },
  isString: function isNumber(o) {
      return typeof o == "string"
  },
  isTypedArray: function isTypedArray(o) {
      return Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },

  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },

  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
    if (ftyp==Int8Array) return 'Int8Array';
    if (ftyp==Uint8Array) return 'Uint8Array';
    if (ftyp==Int16Array) return 'Int16Array';
    if (ftyp==UInt16Array) return 'Uint16Array';
    if (ftyp==Int32Array) return 'Int32Array';
    if (ftyp==UInt32Array) return 'Uint32Array';
    if (ftyp==Float32Array) return 'Float32Array';
    if (ftyp==Float64Array) return 'Float64Array';
  },

  GET: function (url,params,cb) {
    if (!cb) return GETsync(url,params);
    else return GET(url,params,cb);
  },
  
  POST: function (url,data,cb,sync){
    if (!cb) return POSTsync(url,data);
    else return POST(url,data,cb);
  },

  version: '1.2.4'
}


Object.addProperty = function (obj,name,fun) {
  if (obj.prototype[name]) return;
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

Object.updateProperty = function (obj,name,fun) {
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

// Array static methods extensions
if (!Array.create) Array.create = function(length,init) {
      var arr = [], i = length;
      while (i--) {
        arr[i] = init;
      }
      return arr;
  }

if (!Array.matrix) Array.matrix = function (rows,cols,init) {
  if (init==undefined) init=0;
  var mat=[];
  for(var i=0;i<rows;i++) {
    var row=[];
    for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
    mat.push(row);
  }
  return mat;
};

// Array prototype extensions
Object.addProperty(Array,'last',function () { return this[this.length-1] });

// String static methods extensions
if (!String.create) String.create = function(size,init) {
      var i, s='';
      init=init||' ';
      for(i=0;i<size;i++) s=s+init;
      return s;
};
if (!String.copy) String.copy = function(src) {
      var i,dst='';
      for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
      return dst;
}; 
if (!String.get) String.get = function (str,index) {
      return str.charAt(index);
}
if (!String.hex) String.hex = function (n,len) {
      // format a hexadecimal number with 'len' figures.
      switch (len) {
          case 2: return (((n>>4) & 0xf).toString(16))+
                          ((n&0xf).toString(16));
          case 4: return (((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 6: return (((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 8: return (((n>>28) & 0xf).toString(16)+
                          ((n>>24) & 0xf).toString(16)+
                          ((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          default: return 'format_hex??';
      }
}; 
if (!String.set) String.set = function (str,index,char) {
  return str.substr(0, index) + char + str.substr(index+1)
}
// String prototype extensions
Object.addProperty(String,'contains', function (el) {
  return this.includes(el)
})
Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
});


};
BundleModuleCode['plugins/com/jsonfn']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));


};
BundleModuleCode['plugins/math/matrixTA']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2021 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.8.2X
 **
 **    $INFO:
 **
 **  Numerical Matrix Module associated with typed arrays, but with generic array compatibility. 
 **  A matrix provides a wrapper and multi-dimensional array view for one-dimensional byte arrays (typed arrays using buffers).
 **
 **    $ENDOFINFO
 */

var version = "1.8.2X"

var utils  =  Require('plugins/math/matrixTA-utils');
var Vector =  Require('plugins/math/vectorTA');

var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

integer = function (v)  { return Math.floor(v) }
divide = function (a,b) { return Math.floor(a/b) }


var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString,
    TypedArrayOfName = Utils.TypedArrayOfName;


function todo (what) { throw ("Not implemented: Matrix."+what) }
function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(name+'must be a number');
  }
}
function transpose (layout) {
  switch (layout) {
    case 12: return 21;
    case 21: return 12;
  }
}
/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

// Most generic versions - always overwrite (polyfill/vector definitions)
Object.updateProperty(Array,'get', function (i,j,k) {
  if (k!=undefined)
   return this[i][j][k];
  else if (j!=undefined)
   return this[i][j];
  else
   return this[i];
})
Object.updateProperty(Array,'getRow', function (i) {
 return this[i];
})

Object.updateProperty(Array,'info', function () {
  var rows,columns,levels;
  if (isArrayArrayArray(this)) levels=this.length,rows=this[0].length,columns=this[0][0].length;
  else if (isArrayArray(this)) rows=this.length,columns=this[0].length;
  else columns=this.length;
  if (levels) return {
    dtn:'Array',
    size:levels*rows*columns,
    levels:levels,
    rows:rows,
    columns:columns,
    dims:3,
    offset:0,
  }; else if (rows) return {
    dtn:'Array',
    size:rows*columns,
    rows:rows,
    columns:columns,
    dims:2,
    offset:0,
  }; else return {
    dtn:'Array',
    size:columns,
    columns:columns,
    dims:1,
    offset:0,
  }
})


Object.updateProperty(Array,'mapRow', function (i,f) {
 return this[i].map(f);
})

Object.updateProperty(Array,'max', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] > m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] > m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.max.apply(null, this) // vector
  else   // matrix
    return Math.max.apply(null,this.map(function (row) { return Math.max.apply(null, row) }))
})


Object.updateProperty(Array,'mean', function () {
  if (typeof this[0] == 'number')
    return this.sum()/this.length // vector
  else   // matrix
    return this.sum()/(this.length*this[0].length)
})

// this and b can be vectors or matrix objects
// returns always a matrix
Object.updateProperty(Array,'merge', function (b,align) {
  var a=this;
  if (!b || a.length!=b.length) throw "array.merge: length mismatch";
  if (align && align.indexOf('c')==0) {
    // columns alignment ab
    if (Utils.isArray(a[0]))
      return a.map(function (row,index) {
        return Utils.isArray(row)?row.concat(b[index]):[row,b[index]];
      });
    else // a is vector
      return a.map(function (row,index) {
        return Utils.isArray(row)?[row].concat(b[index]):[row,b[index]];
      })
  } else if (!align || align.indexOf('r')==0) {
    // row alignment a
    //               b
    if (!Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b).map(function (row) { return [row] });
    else if (Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b.map(function (row) { return [row] }));
    else if (!Utils.isArray(a[0]) && Utils.isArray(b[0])) return a.map(function (row) { return [row] }).concat(b);
    else return a.concat(b);
  }
})

Object.updateProperty(Array,'min', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] < m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] < m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.min.apply(null, this) // vector
  else    // matrix
    return Math.min.apply(null,this.map(function (row) { return Math.min.apply(null, row) }))
})


Object.updateProperty(Array,'pluck', function (key) {
  var collection=this;
  return collection.map(function(object) {
    return object == null ? undefined : object[key];
  });
})

Object.updateProperty(Array,'print', function (format) {
  var i,j,k,s='',sep='', info=this.info();
  if (!format) format = '%4.2f';
  switch (info.dims) {
    case 1:
      for(j=0;j<info.columns;j++) {
        if (j!=0) s = s + '\n';
        s = s + sprintf(format,this[j]) ;
      }
      break;
    case 2:
      for(j=0;j<info.rows;j++) {
        sep = '';
        if (j!=0) s = s + '\n';
        for (i=0;i<info.columns;i++) {
          s = s + sep + sprintf(format,this[j][i]) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<info.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(j=0;j<info.rows;j++) {
          sep = '';
          if (j!=0) s = s + '\n';
          for (i=0;i<info.columns;i++) {
            s = s + sep + sprintf(format,this[k][j][i]) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
})

Object.updateProperty(Array,'sub', function (i /*row/col*/,j /*col?*/) {
  var res;
  if (typeof i == 'number') res = this[i];
  else if (isArray(i) && i.length==2) res = this.slice(i[0],i[1]+1);
  else res=this;
  if (!isArrayArray(res)) {
    if (typeof j == 'number') res = res[j];
    else if (isArray(j) && j.length==2) res = res(j[0],j[1]+1);
  } else if (isArray(res)) {
    if (typeof j == 'number') 
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a[j]]:a).concat([b[j]]) });
    else if (isArray(j) && j.length==2)
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a.slice(j[0],j[1]+1)]:a)
                .concat([b.slice(j[0],j[1]+1)]) });
  }
  return res;
})

Object.updateProperty(Array,'set', function (a,b,c,d) {
  if (d!=undefined)
   return this[a][b][c]=d;
  else if (c!=undefined)
   return this[a][b]=c;
  else
   return this[a]=b;
})

Object.updateProperty(Array,'setRow', function (i,row) {
 return this[i]=row;
})

Object.updateProperty(Array,'sum', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a+b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a+b })
    }).reduce(function (a,b) { return a+b })
})

// [][] -> [] == flat
Object.updateProperty(Array,'unwrap', function () {
  return this.flat();
})

Object.updateProperty(Array,'variance', function () {
  // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
  var sigma1=0,sigma2=0,n=0;
  if (typeof this[0] == 'number') {
    for(var i=0;i<this.length;i++) {
      sigma1 += (this[i]*this[i]);
      sigma2 += this[i];
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/this.length)/this.length);
  } else {  // matrix
    for(var i=0;i<this.length;i++) {
      for(var j=0;j<this[i].length;j++) {
        sigma1 += (this[i][j]*this[i][j]);
        sigma2 += this[i][j];
        n++;
      }
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/n)/n);
  }
})

// [] -> [][]
Object.updateProperty(Array,'wrap', function () {
  return this.map(function (row) { return [row] });
})



/****************** MATRIX ***************************/
// Matrix object based on typed arrays!
// Supports mixed mode typed arrays and generic arrays!
// {type:function,dtn:string} specifies data type
//
// dataspace : [levels,rows,columns]
// Usage:
// Matrix(columns:number)
// Matrix(rows:number,columns:number)
// Matrix(rows:number,columns:number,levels:number)
// Matrix(rows:number,columns:number,options:{dtn:string})
// Matrix([])
// Matrix([][])
// Matrix([][][])
// Matrix({data:buffer|typedarray,rows:numner,columns:number,dtn:..})
//
// typeof return = Matrix

function Matrix (a,b,c,d) {
  var self = this;
  var rows,columns,levels,dims=2,dtn,dt=Matrix.options.dt,data,
      layout=12,size,transpose;
  var options = isObject(d)?d:(isObject(c)?c:(isObject(b)?b:{}));
  this.tag='MatrixTA';
  if (!(this instanceof Matrix)) return new Matrix(a,b,c,d);
  if (isNumber(a) && isNumber(b)) {
    // Create new empty matrix (2/3 dims)
    rows=a;
    columns=b;
    if (isNumber(c)) levels=c;
    dims=levels?3:2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    size=rows*columns;
    if (levels) size *= levels;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (dt.name=='Array')
      data=new Array(rows).fill(null).map(function (row) { return new Array(columns).fill(0) });
    else
      data=new dt(size);
  } 
  else if (isNumber(a)) {
    // Create a new empty matrix vector (rows=1)
    rows=1;
    columns=a;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    size=columns;
    data=new dt(size);
  } 
  else if (isArrayArray(a)) {
    if (options.datatype) options.dtn=options.datatype+'Array';
    rows=a.length;
    columns=a[0].length;
    if (isArrayArrayArray(a)) levels=rows,rows=a[0].length,columns=a[0][0].length;
    size=rows*columns;
    if (levels) size *= levels;
    dims=levels?3:2;
    if (options.type) dt=options.type;
    if (options.dtn)  {
      dt=TypedArrayOfName[options.dtn];
    }
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(size);
      switch (layout) {
        case 12:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[coli+rowi*columns]=col;
            })
          });
          break;
        case 21:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[rowi+coli*rows]=col;   // TBCHECK!
            })
          });
          break;
      }
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isArray(a)) {
    // Vector 
    rows=1;
    columns=a.length;
    size=columns;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=[a];
    }
  } else if (a instanceof Matrix) {
    if (options.transpose) {
      // transposeView !
      rows=a.columns;
      columns=a.rows;
      levels=a.levels;
      size=a.size;
      dims=a.dims;
      transpose=true;
      data=a.data;
      dtn=a.dtn;
      switch (a.layout) {
        case 12: layout=21; break;
        case 21: layout=12; break;
        case 123: layout=321; break;
        case 321: layout=123; break;
      }
    } else {
      // Copy
      rows=options.rows||a.rows;
      columns=options.columns||a.columns;
      levels=options.levels||a.levels;
      dims=a.dims;
      size=rows*columns;
      if(levels) size*=levels;
      transpose=false;
      scale=options.scale;
      if ((options.dtn && options.dtn != a.dtn) || size != a.size) {
        // convert or resize dtn
        dtn = options.dtn;
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      } else {
        dtn=a.dtn;
        if (dtn != 'Array')
          data=a.data.slice();
        else {
          // TODO dims=3
          data=a.data.map(function (row) { return row.slice() });
        }
      }
      if (a.scale) this.scale=a.scale;
      if (a.complex) this.complex=a.complex;
      layout=a.layout;
    }
  } else if (isObject(a) && a.data) {
    // Partial matrix object
      if (a.dataspace) {
        if (a.dataspace.length==1)
          a.rows=1,a.columns=a.dataspace[0];
        else if (a.dataspace.length==2) 
          a.rows=a.dataspace[0],
          a.columns=a.dataspace[1];
        else if (a.dataspace.length==3) 
          a.levels=a.dataspace[0],
          a.rows=a.dataspace[1],
          a.columns=a.dataspace[2];
      }
      if (a.datatype) a.dtn=a.datatype+'Array';
      rows=a.rows||(a.y && a.x);
      columns=a.columns||a.y||a.x;
      levels=a.levels||a.z;
      size=a.size||((rows?rows:1)*(columns?columns:1)*(levels?levels:1));
      dims=a.dims||(levels?3:(rows?2:1));
      layout=a.layout||(levels?123:(rows?12:1));
      dtn=a.dtn;
      data=a.data;
  }
  if (levels) this.levels=levels;   // z
  this.rows=rows;                   // x
  this.columns=columns;             // x/y
  this.size=size;
  this.layout=layout;
  this.data=data;
  this.dims=dims;
  this.dataspace=levels?[levels,rows,columns]:[rows,columns];
  this.length=levels?levels:(rows?rows:columns);
  
  this.dtn=dtn||dt.name;
  this.datatype=this.dtn.replace(/Array/,'');
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  // get/set index order: 
  // 1. column(x)
  // 2. row(x),column(y)
  // 3. row(x),column(y),level(z)
  

  if (Matrix.options.compatLayout) {
    // Old WRONG layouts; but needed for backward compatibility! Enabled with Matrx.options.compatLayout=true;
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (column,row)   { return this.data[row][column] };
          this.set=function (column,row,v) { this.data[row][column]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[row][column][level] };
          this.set=function (row,column,level,v) { this.data[row][column][level]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 12:
        // x=row,y=column
        this.index = function (x,y)   { return x*self.columns+y}
        this.get = function (x,y)     { return this.data[x*this.columns+y] }
        this.set = function (x,y,v)   { return this.data[x*this.columns+y]=v }
        break;
      case 21:
        // x=row,y=column      
        this.index = function (x,y)   { return y*this.rows+x }
        this.get = function (x,y)     { return this.data[y*this.rows+x] }
        this.set = function (x,y,v)   { return this.data[y*this.rows+x]=v }
        break;
      case 123:
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+y*self.columns+x*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[z+y*this.levels*this.rows+x*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+y*this.levels*this.rows+x*this.levels]=v }
        break;
      case 321:
        // x=row,y=column,z=level
        // TBC
        this.index = function (x,y,z) { return x+y*self.rows+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[x+y*this.rows+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[x+y*self.rows+z*this.columns*this.rows]=v }
        break;
    }

  } else {
    // New correct layouts!
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (row,column)   { return this.data[column][row] };
          this.set=function (row,column,v) { this.data[column][row]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[level][row][column] };
          this.set=function (row,column,level,v) { this.data[level][row][column]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // C0,C1,..
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 21:
        // C0:R0R1..RM,C1:R0R1..RM,..
        // x=row,y=column
        this.index = function (x,y)   { return x+y*self.rows}
        this.get = function (x,y)     { return this.data[x+y*this.rows] }
        this.set = function (x,y,v)   { return this.data[x+y*this.rows]=v }
        break;
      case 12:
        // R0:C0C1..CN,R1:C0C1..CN,..
        // x=row,y=column      
        this.index = function (x,y)   { return y+x*this.columns }
        this.get = function (x,y)     { return this.data[y+this.columns*x] }
        this.set = function (x,y,v)   { return this.data[y+this.columns*x]=v }
        break;
      case 321:
        // C0: R0:L0L1..LO,R1:L0L1..LO,..
        // C1: ..
        // x=row,y=column,z=level
        // TBC??
        this.index = function (x,y,z) { return z+x*self.levels+y*this.levels*this.rows }
        this.get = function (x,y,z)   { return this.data[z+x*self.levels+y*this.levels*this.rows] }
        this.set = function (x,y,z,v) { return this.data[z+x*self.levels+y*this.levels*this.rows]=v }
        break;
      case 312:
        // RGB format!!!!!
        // R0: C0:L0L1..LO,C1:L0L1..LO,..
        // R1: ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+x*self.levels*this.columns+y*this.levels }
        this.get = function (x,y,z)   { return this.data[z+x*self.levels*this.columns+y*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+x*self.levels*this.columns+y*this.levels]=v }
        break;
      case 123:
        // Z0: R0:C0C1..CN,R1:C0C1..CN,.. 
        // Z1; ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return y+x*self.columns+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[y+x*self.columns+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[y+x*self.columns+z*this.columns*this.rows]=v }
        break;
    }
  }
  this.__constructor__='Math.MatrixTA';
}



Matrix.options = {
  // Degault TA change must be applied to dt (and dtn)!
  dt : Float32Array,
  dtn : 'Float32Array',
  compatLayout : false,   // old wrong matrix layout for backward compatibility
}


/******** STATIC MEMBERS ********/
Matrix.abs = function (m) {
  return Matrix.clone(m).abs();
}

Matrix.add = function (m,v) {
  return Matrix.clone(m).add(v);
}

Matrix.clone = function (src) {
  return Matrix(src);
}

Matrix.columnVector = function (array) {
  return Matrix(array)
}

// Return an (typed)array
Matrix.checkArray = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof _MatrixConstructor) return arrayOrMatrix.data;
  else return arrayOrMatrix;
}

// Return a Matrix
Matrix.checkMatrix = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof Matrix) return arrayOrMatrix;
  else return Matrix(arrayOrMatrix);
}

Matrix.checkMatrixSize = function (matrix1,matrix2) {
  if (matrix1.dims != matrix2.dims) return false;
  if (matrix1.rows != matrix2.rows ||
      matrix1.columns != matrix2.columns ||
      matrix1.levels != matrix2.levels ) return false;
}

Matrix.cos = function (m) {
  return Matrix.clone(m).cos();
}

Matrix.diag = function (array,rows,columns) {
  if (!rows) rows=array.length;
  if (!columns) columns=rows;
  if (rows!=columns) Matrix.error("Not a square matrix",'diag');
  return Matrix(rows,columns).fill(function (i,j) {
    return i==j?array[i]:0;
  })
}

Matrix.div = function (m,v) {
  return Matrix.clone(m).div(v);
}

Matrix.empty = function (rows,columns) {
  return Matrix(rows,columns);
}

Matrix.error = function (what,where,ref) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.errorRange = function (what,where,ref) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

Matrix.eye = function (rows,columns,val,options) {
  if (!val) val=1;
  if (!columns) columns=rows;
  return Matrix(rows,columns,options).fill(function (i,j) {
    return i==j?val:0;
  });
}
 
Matrix.exp = function (m) {
  return Matrix.clone(m).exp();
}

Matrix.isMatrix = function (o) {
  return (o instanceof Matrix)
}

// Identity matrix (squared)
Matrix.I = function (n,options) { return Matrix.eye(n,n,1,options) };

Matrix.max =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','max');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
    case 3:
      break;
  }
  return result;
}

Matrix.min =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','min');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, levels, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
  }
  return result;
}


Matrix.mod = function (m,v) {
  return Matrix.clone(m).mod(v);
}

Matrix.mul = function (m,v) {
  return Matrix.clone(m).mul(v);
}

Matrix.neg = function (m) {
  return Matrix.clone(m).neg();
}

Matrix.ones = function (rows,columns) {
  return Matrix(rows,columns).fill(1);
}

Matrix.rand = function (rows, columns, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return rng();
  });
}

Matrix.randInt = function (rows, columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}

Matrix.sin = function (m) {
  return Matrix.clone(m).sin();
}

Matrix.sub = function (m,v) {
  return Matrix.clone(m).sub(v);
}

Matrix.zero = function (rows,columns) {
  return Matrix(columns,rows).fill(0);
}

Matrix.version = version;

/********* INSTANCE MEMBERS *********/


Matrix.prototype.abs = function (v) {
  this.eval(Math.abs);
  return this; 
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.add = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] += v.data[i];
    return result;
  } else result.eval(function (x) {return x+v});
  return result; 
}

// Apply a function to all elements AND update the elements by the return value of f!
Matrix.prototype.apply = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        this.set(j,f.call(this,this.get(j),j))
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          this.set(i,j,f.call(this,this.get(i,j),i,j))
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            this.set(i,j,k,f.call(this,this.get(i,j,k),i,j,k))
      return this;
  }
}

// Iterate over all elements of matrix and apply function to matrix elements (w/o matrix update)
Matrix.prototype.forEach = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        f.call(this,this.get(j),j)
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          f.call(this,this.get(i,j),i,j)
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            f.call(this,this.get(i,j,k),i,j,k)
      return this;
  }
}

Matrix.prototype.checkMatrixDims = function(dims) {
  if (this.dims != dims) this.errorRange('Matrix has not expected dimension '+dims);
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkColumnIndex = function(index, outer) {
  var max = outer ? this.columns : this.columns - 1;
  if (index < 0 || index > max) this.errorRange('Column index out of range');
}


/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkRowIndex = function(index, outer) {
  var max = outer ? this.rows : this.rows - 1;
  if (index < 0 || index > max)
    this.errorRange('Row index out of range');
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkRowVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.columns) 
    this.errorRange(
      'vector size must be the same as the number of columns'
    );
  
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkColumnVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.rows) 
    this.errorRange('vector size must be the same as the number of rows');
  
  return vector;
}

Matrix.prototype.checkIndices = function(rowIndices, columnIndices) {
  return {
    row: this.checkRowIndices(rowIndices),
    column: this.checkColumnIndices(columnIndices)
  };
}

Matrix.prototype.checkRowIndices = function(rowIndices) {
  var self=this;
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= self.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

Matrix.prototype.checkColumnIndices = function(columnIndices) {
  var self=this;
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= self.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

Matrix.prototype.checkRange = function(startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 4) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= this.rows ||
    endRow < 0 ||
    endRow >= this.rows ||
    startColumn < 0 ||
    startColumn >= this.columns ||
    endColumn < 0 ||
    endColumn >= this.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

Matrix.prototype.clone = function () {
  return Matrix(this);
}


// Return array or vector
Matrix.prototype.col = function (index,asVector) {
  var col=[];
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 2: col=this.data.pluck(index); break;
        case 3: throw new Error ('EINVALID');
      }
    default:
      switch (this.dims) {
        case 2: for(var i=0;i<this.rows;i++) col.push(this.get(i,index)); break;
        case 3: throw new Error ('EINVALID');
      }
  }
  return asVector?Math.VectorTA(col,{dtn:this.dtn}):col;
}

Matrix.prototype.getCol = Matrix.prototype.col;
Matrix.prototype.pluck = Matrix.prototype.col;

/** Copy (1) a sorurce array (vector) into this matrix (row/column w or w/o subrange), or (2) create a copy of this matrix (empty argument list)
 *
 * copy()
 * copy([a,b]|[],[v1,v2,...])
 * copy(number,[a,b]|[],[v1,v2,...])
 * copy([a,b]|[],number,[v1,v2,...])
 * copy(number,number,[a,b]|[],[v1,v2,...])
 * ..
 */
 
Matrix.prototype.copy = function (a,b,c,d) {
  var x,y,z,rx,ry,rz,i,j,k,src;

  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;

  if (isArray(d)) src=d;
  if (isVector(d)) src=d;
  
  if (!src && !d && (isArray(c) || isVector(c))) src=c,rz=undefined;
  if (!src && !c && (isArray(b) || isVector(b))) src=b,ry=undefined;
  if (!src && !a && (isArray(a) || isVector(a))) src=a,rx=[0,this.columns-1];  // 1-dim only
    
  if (isVector(src)) src=src.data;
  if (!src) return Matrix({
    rows:this.rows,
    columns:this.columns,
    levels:this.levels,
    dtn:this.dtn,
    layout:this.layout,
    data:this.data.slice()
  })
  
  if (!src) throw "Matrix.copy: no source array provided";
  if (rx && rx.length==0) rx=[0,this.rows-1];
  if (ry && ry.length==0) ry=[0,this.columns-1];
  if (rz && rz.length==0) rz=[0,this.levels-1];
  if (rx && (rx[1]-rx[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (ry && (ry[1]-ry[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (rz && (rz[1]-rz[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
   
  switch (this.dims) {
    case 1:
      for(x=rx[0];x<rx[1];x++) this.data[x]=src[x-rx[0]];
      break;
    case 2:
      if (rx && j != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j)]=src[x-rx[0]];
      else if (i != undefined && ry)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y)]=src[y-ry[0]];
      else todo('copy 2'); 
      break;   
    case 3:
      if (rx && j != undefined && k != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j,k)]=src[x-rx[0]];
      else if (ry && i != undefined && k != undefined)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y,k)]=src[y-ry[0]];
      else if (rz && i != undefined && j != undefined)
        for(z=rz[0];z<=rz[1];z++) 
          this.data[this.index(i,j,z)]=src[z-rz[0]];
      else todo('copy 3');    
      break;
  }
  return this;
}

/** Convert size using a data filter.
 ** The target size must be provided.
 *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
 */

Matrix.prototype.convert = function (a,b,c,d) {
  var i,j,k,l,p,v,m,ni,nj,nk,filter;
  
  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isString(b)) filter=b;
  if (isString(c)) filter=c;
  if (isString(d)) filter=d;
  if (!filter) filter='mean';

  if (!i) throw "Matrix.convert: no target size (number, first dim.)";
  if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";
    
  if (!k) k= {datatype:this.datatype,layout:this.layout}
  else l= {datatype:this.datatype,layout:this.layout}
  m = Matrix(i,j,k,l);
      
  if (typeof filter != 'function') switch (filter) {
    case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
    case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
    case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
    case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
    case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
    case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
    default:          filter = function () { return 0 }
  }
  switch (this.dims) {
    case 1:
      ni=Math.floor(this.columns/m.columns);
      for(i=0;i<m.columns;i++) {
        v=this.data[i*ni]; 
        for(p=1;p<ni;p++) {
          v=filter(v,this.data[i*ni+p],p,ni);
        }
        m.data[i]=v;
      }
      break;
    case 2:
      // TBC
      ni=Math.floor(this.rows/m.rows);
      nj=Math.floor(this.columns/m.columns);
      for(i=0;i<m.rows;i++) {
        for(j=0;j<m.columns;j++) {
          for(p=0;p<ni;p++) {
            for(q=0;q<nj;q++) {
              if (p==0 && q==0) 
                v=this.get(i*ni,j*nj);
              else
                v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
            }
          }
          m.set(i,j,v);
        }
      }
      break;
  }
  return m;
}


Matrix.prototype.cos = function (v) {
  this.eval(Math.cos);
  return this; 
}

Matrix.prototype.diag = function (v) {
  // TODO Vector
  var a = [];
  if (this.rows!=this.columns) return;
  for(var i=0;i<this.rows;i++) a.push(this.data[i+i*this.i]);
  return a; 
}

Matrix.prototype.dim = function () {
  switch (this.dims) {
    case 1: return [this.columns];
    case 2: return [this.rows,this.columns];
    case 3: return [this.rows,this.columns,this.levels];
  }
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.div = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] /= v.data[i];
    return result;
  } else result.eval(function (x) {return x/v});
  return result; 
}

Matrix.prototype.divide = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)/b);
    case 2: return this.set(a,b,this.get(a,b)/c);
    case 3: return this.set(a,b,c,this.get(a,b,c)/d);
  }
}

Matrix.prototype.error = function (what,where) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.prototype.errorRange = function (what,where) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

// Evaluate all elements x of matrix by applying function f(x)
Matrix.prototype.eval = function (f) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            this.set(i,f(this.get(i)))
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              this.set(i,j,f(this.get(i,j)))
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                this.set(i,j,k,f(this.get(i,j,k)))
          break;
      }
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i]);
  }
  return this;
}

Matrix.prototype.exp = function (v) {
  this.eval(Math.exp);
  return this; 
}

Matrix.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
    switch (this.dims) {
      case 1:
        for(i=0; i < this.columns; i++) 
          this.set(i,valueOrFunction(i.j))
        return this;
      case 2:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            this.set(i,j,valueOrFunction(i,j))
        return this;
      case 3:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            for(k=0; k < this.levels; k++) 
              this.set(i,j,k,valueOrFunction(i,j,k))
        return this;
    }
  } else this.data.fill(valueOrFunction);
  return this;
}

 
// x += delta
Matrix.prototype.incr = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)+b);
    case 2: return this.set(a,b,this.get(a,b)+c);
    case 3: return this.set(a,b,c,this.get(a,b,c)+d);
  }
}

Matrix.prototype.info = function () {
  var o = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    layout:this.layout,
    dims:this.dims,
    dataspace:this.dataspace,
    datatype:this.datatype,
  }
  if (this.rows) o.rows=this.rows;
  if (this.levels) o.levels=this.levels;
  if (this.scaler) o.scaler=this.scaler;
  if (this.complex) o.complex=true;
  return o;
}


Matrix.prototype.isColumnVector = function () {
   return this.columns === 1;
}

Matrix.prototype.isEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isEchelonForm = false;
        checked = true;
      }
    }
    i++;
  }
  return isEchelonForm;
}

Matrix.prototype.isReducedEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isReducedEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isReducedEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isReducedEchelonForm = false;
        checked = true;
      }
    }
    for (var k = j + 1; k < this.rows; k++) {
      if (this.get(i, k) !== 0) {
        isReducedEchelonForm = false;
      }
    }
    i++;
  }
  return isReducedEchelonForm;
}
Matrix.prototype.isRowVector = function () {
   return this.rows === 1;
}

Matrix.prototype.isSquare = function () {
  return this.rows==this.columns
}

Matrix.prototype.isSymmetric = function () {
  if (this.isSquare()) {
        for (var i = 0; i < this.rows; i++) {
          for (var j = 0; j <= i; j++) {
            if (this.get(i, j) !== this.get(j, i)) {
              return false;
            }
          }
        }
        return true;
      }
  return false;
}

/** Iterate over matrix elements
 * Parameter arrays specify iteration ranges, FORALL='*' specifies a target vector range
 * iter(function (@elem,@index,@array))
 * iter(number [],function)
 * iter(number [],number [],function)
 * iter(number [],number [],number [],function)
 * Examples: 
 *  m.iter(FORALL,[],[],f)   <=> for all x-vectors with y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([], FORALL,[],f)  <=> for all y-vectors with x in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([],[],[],f)       <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter(f)                <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *
 *
 */
  
Matrix.prototype.iter = function (a,b,c,d) {
  var func,rx,ry,rz,x,y,z,
      self=this;
  if (isFunction(a)) func=a;
  else if (isFunction(b)) func=b;
  else if (isFunction(c)) func=c;
  else if (isFunction(d)) func=d;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;
  if (isString(a)) rx=a;
  if (isString(b)) ry=b;
  if (isString(c)) rz=c;
  if (!func) throw "Matrx.iter: no function supplied";
  if (!rx && !ry && !rz) // linear iteration over all elements
    return this.data.forEach(func);
  switch (this.dims) {
    case 1: break;
  // TODO
      todo('iter 1')
    case 2: break;
  // TODO
      todo('iter 2')
    case 3:
      if (isArray(rx) && rx.length==0) rx=[0,this.rows];
      if (isArray(ry) && ry.length==0) ry=[0,this.columns];
      if (isArray(rz) && rz.length==0) rz=[0,this.levels];
      if (rz == FORALL) {
        for(x=rx[0];x<rx[1];x++) {
          for(y=ry[0];y<ry[1];y++) {
            func(x,y,this.subMatrixRange(x,y,ALL))
          }
        }
      } else if (rx==FORALL) {
  // TODO
        todo('iter 3.ryx=FORALL')
      
      } else if (ry==FORALL) {
  // TODO
        todo('iter 3.ry=FORALL')
      
      } else {
        // single data cell iteration
  // TODO
        todo('iter 3')
      }
  }
  // TODO
  return this;
}

Matrix.prototype.map = function (f,asArray) {
  var res,i,j,k;
  switch (this.dims) {
    case 1:
      res = Matrix(this.columns,{dtn:asArray?'Array':this.dtn});
      for(j=0;j<this.columns;j++)
        res.set(j,f(this.get(j),j));
      break;
    case 2:
      res = Matrix(this.rows,this.columns,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          res.set(i,j,f(this.get(i,j),i,j));
      break;
    case 3:
      res = Matrix(this.rows,this.columns,this.levels,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          for(k=0;k<this.levels;k++)
            res.set(i,j,k,f(this.get(i,j,k),i,j,k));
      break;
  }
  return res;
}


// Row mapping function
Matrix.prototype.mapRow = function (f) {
  var res=[];
  for(var row=0;row<this.rows;row++) {
    res.push(f(this.getRow(row),row));
  }
  return res;
}

/** Return minimum and maximum value of the matrix
 *
 */
Matrix.prototype.minmax = function () {
  var d0=Number.MAX_VALUE,d1=Number.MIN_VALUE;
  for (i = 0;i < this.size; i++) {
    d0=Math.min(d0,this.data[i]);
    d1=Math.max(d1,this.data[i]);    
  }
  return { min:d0, max:d1 };
}

Matrix.prototype.mapToArray = function (f) {
  var res = new Array(this.size);
  for(var i=0;i<this.rows;i++)
    for(var j=0;j<this.columns;j++)
      res[i*this.columns+j]=f?f(this.get(i,j),i,j):this.get(i,j);
  return res;
}

Matrix.prototype.mapToArrayArray = function (f) {
  var res = new Array(this.rows);
  for(var i=0;i<this.rows;i++) {
    res[i]=new Array(this.columns);
    for(var j=0;j<this.columns;j++)
      res[i][j]=f?f(this.get(i,j),i,j):this.get(i,j);
  }
  return res;
}

Matrix.prototype.mapToArrayArrayArray = function (f) {
  var res = new Array(this.levels);
  for(var i=0;i<this.levels;i++) {
    res[i]=new Array(this.rows);
    for(var j=0;j<this.rows;j++) {
      res[i][j]=new Array(this.columns);
      for(var k=0;k<this.columns;k++) {
        res[i][j][k]=f?f(this.get(i,j,k),i,j,k):this.get(i,j,k);
      }
    }
  }
  return res;
}

// x *= k
Matrix.prototype.multiply = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)*b);
    case 2: return this.set(a,b,this.get(a,b)*c);
    case 3: return this.set(a,b,c,this.get(a,b,c)*d);
  }
}

Matrix.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Matrix.prototype.mod = function (v) {
  this.eval(function (x) {return x%v});
  return this; 
}

/**
     * Returns the matrix product between this and other
     * @param {Matrix} other
     * @return {Matrix}
     */
Matrix.prototype.mmul = function (other) {
  this.checkMatrixDims(2);
  other = Matrix.checkMatrix(other);
  if (this.columns !== other.rows) {
    // eslint-disable-next-line no-console
    console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
  }

  var m = this.rows;
  var n = this.columns;
  var p = other.columns;

  var result = Matrix(m, p, {dtn:this.dtn});

  var Bcolj = new Array(n);
  for (var j = 0; j < p; j++) {
    for (var k = 0; k < n; k++) {
      Bcolj[k] = other.get(k, j);
    }
    for (var i = 0; i < m; i++) {
      var s = 0;
      for (k = 0; k < n; k++) {
        s += this.get(i, k) * Bcolj[k];
      }
      result.set(i, j, s);
    }
  }
  return result;
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.mul = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] *= v.data[i];
    return result;
  } else result.eval(function (x) {return x*v});
  return result; 
}

Matrix.prototype.neg = function (v) {
  this.eval(function (x) {return -x});
  return this; 
}

Matrix.prototype.prod = function (v) {
  var i,j,k,v = 1;
  // Comp. mode
  switch (this.dtn+this.dims) {
    case 'Array1':
      for (i = 0; i < this.columns; i++) {
          v *= this.data[i];
      }
      break;
    case 'Array2':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          v *= this.data[i][j];
        }
      }
      break;
    case 'Array3':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          for (k = 0; k < this.levels; k++) {
            v *= this.data[i][j][k];
          }
        }
      }
      break;
    default:
      for (i = 0; i < this.size; i++) v *= this.data[i];
  }
  return v;
}

Matrix.prototype.print = function (format) {
  var i,j,k,s='',sep='';
  if (!format) format = '%4.2f';
  switch (this.dims) {
    case 1:
      for(i=0;i<this.columns;i++) {
        if (i!=0) s = s + '\n';
        s = s + sprintf(format,this.get(i)) ;
      }
      break;
    case 2:
      for(i=0;i<this.rows;i++) {
        sep = '';
        if (i!=0) s = s + '\n';
        for (j=0;j<this.columns;j++) {
          s = s + sep + sprintf(format,this.get(i,j)) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<this.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(i=0;i<this.rows;i++) {
          sep = '';
          if (i!=0) s = s + '\n';
          for (j=0;j<this.columns;j++) {
            s = s + sep + sprintf(format,this.get(i,j,k)) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
}

/** Reduce dimension: Linear matrix data reduction applying a function (a,b) -> c to all elements.
 *  Returns a scalar value or any other object accumulated by the supplied function
 */
Matrix.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

// Return array or vector (layout=12: matrix view if !copy)
Matrix.prototype.row = function (index,asVector,copy) {
  this.checkMatrixDims(2);
  this.checkRowIndex(index);
  var row,data,i,j;
  switch (this.dtn) {
    case 'Array':
      if (this.layout==12) {
        if (!asVector)
          return this.data[index];
        else
          return Vector(this.data[index]);
      } else {
        // transposed view
        if (!asVector) {
          row = new Array(this.columns);
          if (this.rows==1) return this.data;
          for (i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
        } else {
          if (this.rows==1) return this.data;
          row= Vector(this.columns,{dtn:this.dtn});
          for (i = 0; i < this.columns; i++) {
            row.set(i, this.get(index, i));
          };
        }  
      }
      break;
    default:
      // With advanced slicing
      if (!asVector) {
        row = new Array(this.columns);
        if (this.rows==1) return this.data;
        for (i = 0; i < this.columns; i++) {
          row[i] = this.get(index, i);
        }
      } else if (this.layout == 12) {
        if (copy) {
          data = this.data.slice(index*this.columns,(index+1)*this.columns);
          row= Vector({dtn:this.dtn,data:data,columns:this.columns});
        } else {
          row= Vector({dtn:this.dtn,data:this.data,offset:index*this.columns,columns:this.columns});
        }
      } else {
        if (this.rows==1) return this.data;
        row= Vector(this.columns,{dtn:this.dtn});
        for (i = 0; i < this.columns; i++) {
          row.set(i, this.get(index, i));
        };
      }   
  }
  
  return row;
}
Matrix.prototype.getRow=Matrix.prototype.row;

/** resize matrix (only modifying meta data - not buffer data)
 *  TODO: offset
 */
Matrix.prototype.resize = function (options) {
  for(var p in options) {
    switch (p) {
      case 'rows':
      case 'columns':
      case 'levels':
        this[p]=options[p];
        break;
      case 'offset':
        // TODO
        break;
    }
  }
  this.size=this.columns*(this.rows?this.rows:1)*(this.levels?this.levels:1);
  this.length=this.rows?this.rows:this.columns;
  return this
}


Matrix.prototype.reverseRow = function (row) {
  var t,len=this.columns;
  for(var i=0;i<(len/2)|0;i++) {
    t=this.get(row,i);
    this.set(row,i,this.get(row,len-i-1));
    this.set(row,len-i-1,t);
  }
  return this; 
}

/** Scale (and/or adjust offset optionally of) all matrix elements -= offset *= k
 * scale(k)
 * scale(k,inplace:boolean)
 * scale(k,offset)
 * scale(k,offset,inplace:boolean)
 */
 
Matrix.prototype.scale = function (a,b,c) {
  var m,k=1,offset,inplace=false;
  if (isNumber(a)) k=a;
  if (isBoolean(b)) inplace=b;
  else if (isBoolean(c)) inplace=c;
  if (isNumber(b)) offset=b;
  else if (isNumber(c)) offset=c;
  
  m = inplace?this:this.copy();
  if (k!=1) {
    if (offset)
      for(var i=0;i<m.data.length;i++) m.data[i]=(m.data[i]-offset)*k;
    else
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]*k;
  } else if (offset) {
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]-offset;  
  }
  return m;
}

/*
Return a new matrix based on a selection of rows and columns
selection(rowIndices: Array<number>, columnIndices: Array<number>): Matrix
Parameters
rowIndices (Array<number>) The row indices to select. Order matters and an index can be more than once.
columnIndices (Array<number>) The column indices to select. Order matters and an index can be use more than once.
Returns 
Matrix: The new matrix 
*/
Matrix.prototype.selection = function (rowIndices,columnIndices) {
  this.checkMatrixDims(2);
  var newMatrix = Matrix(rowIndices.length,columnIndices.length,{dtn:this.dtn});
  for (var i = 0; i < rowIndices.length; i++) {
    var rowIndex = rowIndices[i];
    for (var j = 0; j < columnIndices.length; j++) {
      var columnIndex = columnIndices[j];
      newMatrix.set(i,j, this.get(rowIndex, columnIndex));
    }
  }
  return newMatrix;
}


// Set a row of the matrix
Matrix.prototype.setRow = function (row,data) {
  data=Matrix.checkArray(data);
  for(var i=0;i<this.columns;i++) {
     this.set(row,i,data[i]); 
  }
}

// Slice of data in major dimension
Matrix.prototype.slice = function (i,offset) {
  var rows,columns,levels;
  switch (this.dims) {
    case 1:
      return Matrix(this,{columns:i,offset:offset,slice:true});
      break;
    case 2:
    case 3:
      return Matrix(this,{rows:i,offset:offset,slice:true});
      break;
  }
}

Matrix.prototype.sin = function () {
  this.eval(Math.sin);
  return this;
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Matrix.prototype.size = function () {
  return  this.size;
}


// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.sub = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] -= v.data[i];
    return result;
  } else result.eval(function (x) {return x-v});
  return result; 
}


/** Return a sub-matrix (2 dims only)
 *
 */
Matrix.prototype.subMatrix = function (startRow, endRow, startColumn, endColumn) {
  this.checkMatrixDims(2);
  this.checkRange(startRow, endRow, startColumn, endColumn);
  var newMatrix = Matrix(endRow - startRow + 1, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = startRow; i <= endRow; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      newMatrix.set(i - startRow,j - startColumn, this.get(i, j));
    }
  }
  return newMatrix;
}

/** Return a sub-matrix (1-3 dims)
 *
 * rx:row,ry:column,rz?:level
 */
Matrix.prototype.subMatrixRange = function (rx,ry,rz) {
  var i,j,i0,i1,x0,x1,y0,y1,z0,z1,res;
  switch (this.dims) {
    case 1:
      // simple case, return sliced array
      x0=0,x1=this.i-1;
      if (isRange(rx)) x0=rx[0],x1=rx[1];
      else throw "Matrix.subMatrixRange: no range";
      var i0=x0,i1=i0+1+x1;
      return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
    case 2:
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    case 3:
      if ((isAll(rz) || (isRange(rz)) && isNumber(rx) && isNumber(ry) && this.layout==123)) {
        // simple case, return sliced array (1-dim matrix)
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        var i0=this.index(rx,ry,z0),i1=i0+1+z1;
        return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
      } else if (isNumber(rz)) {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=rz;
        res = Matrix(x1-x0+1,y1-y0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            res.set(i,j, this.get(i,j,z0));
        return res;
      } 
      else todo('subMatrixRange 3.rx/ry')
  }
}

Matrix.prototype.subMatrixRow = function (indices, startColumn, endColumn) {
  this.checkMatrixDims(2);
  if (startColumn === undefined) startColumn = 0;
  if (endColumn === undefined) endColumn = this.columns - 1;
  if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(indices.length, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      if (indices[i] < 0 || indices[i] >= this.rows) {
        throw new RangeError('Row index out of range: '+indices[i]);
      }
      newMatrix.set(i, j - startColumn, this.get(indices[i], j));
    }
  }
  return newMatrix;
}

Matrix.prototype.subMatrixColumn = function (indices, startRow, endRow) {
  this.checkMatrixDims(2);
  if (startRow === undefined) startRow = 0;
  if (endRow === undefined) endRow = this.rows - 1;
  if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(endRow - startRow + 1, indices.length, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startRow; j <= endRow; j++) {
      if (indices[i] < 0 || indices[i] >= this.columns) {
        throw new RangeError('Column index out of range: '+indices[i]);
      }
      newMatrix.set(j - startRow, i, this.get(j, indices[i]));
    }
  }
  return newMatrix;
}


Matrix.prototype.subRowVector = function (vector) {
  this.checkMatrixDims(2);
  vector = this.checkRowVector(vector);
  for (var i = 0; i < this.rows; i++) {
    for (var j = 0; j < this.columns; j++) {
      this.set(i, j, this.get(i, j) - vector[j]);
    }
  }
  return this;
}

Matrix.prototype.setSubMatrix = function (matrix, startRow, startColumn) {
  matrix = this.checkMatrix(matrix);
  this.checkMatrixDims(2);
  matrix.checkMatrixDims(2);
  var endRow = startRow + matrix.rows - 1;
  var endColumn = startColumn + matrix.columns - 1;
  this.checkRange(startRow, endRow, startColumn, endColumn);
  for (var i = 0; i < matrix.rows; i++) {
    for (var j = 0; j < matrix.columns; j++) {
      this.set(startRow + i,startColumn + j) = matrix.get(i, j);
    }
  }
  return this;
}

Matrix.prototype.sum = function (by) {
  var i,j,k,v=0;
  switch (by) {
    case 'row':
      return this.sumByRow();
    case 'column':
      return this.sumByColumn();
    default:
      switch (this.dtn+this.dims) {
        case 'Array1':
          for (i = 0; i < this.columns; i++) {
              v += this.data[i];
          }
          break;
        case 'Array2':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              v += this.data[i][j];
            }
          }
          break;
        case 'Array3':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              for (k = 0; k < this.levels; k++) {
                v += this.data[i][j][k];
              }
            }
          }
          break;
        default:
          for (i = 0; i < this.size; i++) v += this.data[i];
      }
      return v;
  }
}

Matrix.prototype.sumByRow = function () {
  var sum = Matrix.zeros(this.rows, 1);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.sumByColumn = function() {
  var sum = Matrix.zeros(1, this.columns);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.toCsv = function (sep) {
  sep=sep||',';
  switch (this.dims) {
    case 1: return Array.from(this.data).join('\n');
    case 2: return this.mapToArrayArray().map(function (row) {
      return row.join(sep);
    }).join('\n');
  }
}

Matrix.prototype.toArray = function (rx,ry,rz) {
  switch (this.dims) {
    case 1: return Array.from(this.data);
    case 2: return this.mapToArrayArray();
    case 3: return this.mapToArrayArrayArray();
  }
}

Matrix.prototype.toJson = function () {
  return JSON.stringify(this.toArray());
}

Matrix.prototype.transpose = function () {
  utils.checkMatrixDims(this,2);
  if (!Matrix.native || this.rows != this.columns) {
    var result = Matrix(this.columns, this.rows);
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          result.set(j, i, this.get(i, j));
        }
    }
    return result;
  } else if (Matrix.native) {
    /* Native BLAS support */
    var res = Matrix(this.rows,this.columns,{dtn:this.dtn});
    if (this.dtn == 'Float32Array')
      Matrix.native.blas.stran_(Buffer(this.data.buffer),
                                Buffer(res.data.buffer),
                                Matrix.native.intPtr(this.rows),
                                Matrix.native.intPtr(this.columns));
    return res;
  }
}

Matrix.prototype.transposeView = function () {
  utils.checkMatrixDims(this,2);
  var res = Matrix(this,{transpose:true});
  return res;
}

Matrix.ALL=ALL;
Matrix.FOREACH=FOREACH;
Matrix.FORALL=FORALL;
Matrix.utils = utils;

module.exports = Matrix 
};
BundleModuleCode['plugins/math/matrixTA-utils']=function (module,exports,global,process){
// Matrix Utility Functions
// TypedArray version
// Ver. 1.3.1

'use strict';

function checkMatrixDims(matrix, dims) {
  if (matrix.dims != dims) throw new Error('Matrix has not expected dimension '+dims);
}
/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  var max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  var max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns'
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices)
  };
}

function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= matrix.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= matrix.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function getRange(from, to) {
  var arr = new Array(to - from + 1);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = from + i;
  }
  return arr;
}

function sumByRow(matrix) {
  var sum = Matrix.zeros(matrix.rows, 1);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  var sum = Matrix.zeros(1, matrix.columns);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumAll(matrix) {
  var i,j,k,v = 0;
  // Comp. mode
  switch (matrix.dtn) {
    case 'Array':
      for (i = 0; i < matrix.rows; i++) {
        for (j = 0; j < matrix.columns; j++) {
          v += matrix.data[i][j];
        }
      }
      break;
    default:
      for (i = 0; i < matrix.size; i++) v += matrix.data[i];
  }
  return v;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}

function getFilled2DArray(rows,columns,init) {
  var a = Array(rows);
  for(var i = 0;i < rows; i++) {
    a[i]=Array(columns).fill(init)
  }
  return a;
}

function hypotenuse(a, b) {
  var r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}

// function squaredEuclidean(p: number[], q: number[])
function squaredEuclidean(p, q) {
  var d = 0;
  for (var i = 0; i < p.length; i++) {
    d += (p[i] - q[i]) * (p[i] - q[i]);
  }
  return d;
}

// function euclidean(p: number[], q: number[]) 
function euclidean(p, q) {
  return Math.sqrt(squaredEuclidean(p, q));
}

var defaultOptions = {
  distanceFunction: squaredEuclidean
}
// function nearestVector(listVectors: Matrix, vector: number[],  options = defaultOptions)
function nearestVector(
  listVectors,
  vector,
  options
) {
  options=checkOptions(options,{distanceFunction: squaredEuclidean});
  const distanceFunction = checkOption(
    options.distanceFunction, defaultOptions.distanceFunction);
  const similarityFunction = checkOption(
    options.similarityFunction, defaultOptions.similarityFunction);

  let vectorIndex = -1;
  if (typeof similarityFunction === 'function') {
    // maximum similarity
    let maxSim = Number.MIN_VALUE;
    for (let j = 0; j < listVectors.rows; j++) {
      const sim = similarityFunction(vector, listVectors.getRow(j));
      if (sim > maxSim) {
        maxSim = sim;
        vectorIndex = j;
      }
    }
  } else if (typeof distanceFunction === 'function') {
    // minimum distance
    let minDist = Number.MAX_VALUE;
    for (let i = 0; i < listVectors.rows; i++) {
      const dist = distanceFunction(vector, listVectors.getRow(i));
      if (dist < minDist) {
        minDist = dist;
        vectorIndex = i;
      }
    }
  } else {
    throw new Error("A similarity or distance function it's required");
  }

  return vectorIndex;
}

// function findNearestVector(  vectorList: Matrix,  vector: Vector,  options: IOptions = defaultOptions) 
function findNearestVector(
  vectorList,
  vector,
  options
) {
  const index = nearestVector(vectorList, vector, options);
  return vectorList[index];
}

module.exports = {
  checkMatrixDims:checkMatrixDims,
  checkRowIndex:checkRowIndex,
  checkRowVector:checkRowVector,
  checkColumnIndex:checkColumnIndex,
  checkColumnVector:checkColumnVector,
  checkIndices:checkIndices,
  checkRowIndices:checkRowIndices,
  checkColumnIndices:checkColumnIndices,
  checkRange:checkRange,
  euclidean:euclidean,
  findNearestVector:findNearestVector,findNearestVector,
  getFilled2DArray:getFilled2DArray,
  getRange:getRange,
  hypotenuse:hypotenuse,
  nearestVector:nearestVector,nearestVector,
  sumByRow:sumByRow,
  sumByColumn:sumByColumn,
  sumAll:sumAll,
  squaredEuclidean:squaredEuclidean,
}
};
BundleModuleCode['plugins/math/vectorTA']=function (module,exports,global,process){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.6.1X
 **
 **    $INFO:
 ** 
 **   Vector module supporting typed and generic arrays.
 **   
 ** 
 **    $ENDOFINFO
 */

var isArray = Utils.isArray,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isString = Utils.isString,
    TypedArrayOfName = Utils.TypedArrayOfName;

/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

Object.addProperty(Array,'get', function (i) {
  return this[i];
})
Object.addProperty(Array,'set', function (a,b) {
  this[a]=b;
})

  
Object.addProperty(Array,'print', function (format) {
  var i,s='',sep='', columns=this.length,complex=isArray(this[0]);
  if (!format) format = '%4.2f';
  for(i=0;i<columns;i++) {
    if (i!=0) s = s + '\n';
    if (complex) 
      s = s + sprintf(format,this[i][0]) + ',' +
              sprintf(format,this[i][1]);
    else
      s = s + sprintf(format,this[i]) ;
  }    
  return s;
})


Object.addProperty(Array,'info', function () {
  return {
    dtn:'Array',
    size:this.length,
    columns:this.length,
    offset:0,
  }
})

Object.addProperty(Array,'unique', function () {
  var array=this;
  var length = array ? array.length : 0;
  function baseUniq(array) {
    var index = -1,
        length = array.length,
        seen,
        result = [];

    seen = result;
    outer:
    while (++index < length) {
      var value = array[index];
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === value) {
          continue outer;
        }
      }
      result.push(value);
    }
    return result;
  }
  if (!length) {
    return [];
  }
  return baseUniq(array);
})

Object.addProperty(Array,'min', function () {
  return Math.min.apply(null, this) 
})

Object.addProperty(Array,'max', function () {
  return Math.max.apply(null, this) 
})


Object.addProperty(Int16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Int32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float64Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})

/********************* STRING Conversion ******************************/
function toUTF8Array(str) {
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 
                      0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            charcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)
            utf8.push(0xf0 | (charcode >>18), 
                      0x80 | ((charcode>>12) & 0x3f), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}

function fromUTF8Array(data) { // array of bytes
    var str = '', i;
    for (i = 0; i < data.length; i++) {
        var value = data[i];
        if (value < 0x80) {
            str += String.fromCharCode(value);
        } else if (value > 0xBF && value < 0xE0) {
            str += String.fromCharCode((value & 0x1F) << 6 | data[i + 1] & 0x3F);
            i += 1;
        } else if (value > 0xDF && value < 0xF0) {
            str += String.fromCharCode((value & 0x0F) << 12 | (data[i + 1] & 0x3F) << 6 | data[i + 2] & 0x3F);
            i += 2;
        } else {
            // surrogate pair
            var charCode = ((value & 0x07) << 18 | (data[i + 1] & 0x3F) << 12 | (data[i + 2] & 0x3F) << 6 | data[i + 3] & 0x3F) - 0x010000;

            str += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00); 
            i += 3;
        }
    }
    return str;
}

var complex = {
  //-------------------------------------------------
  // Add two complex numbers
  //-------------------------------------------------
  add : function (a, b)
  {
      return [a[0] + b[0], a[1] + b[1]];
  },

  //-------------------------------------------------
  // Subtract two complex numbers
  //-------------------------------------------------
  subtract : function (a, b)
  {
      return [a[0] - b[0], a[1] - b[1]];
  },

  //-------------------------------------------------
  // Multiply two complex numbers
  //
  // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
  //-------------------------------------------------
  multiply : function (a, b) 
  {
      return [(a[0] * b[0] - a[1] * b[1]), 
              (a[0] * b[1] + a[1] * b[0])];
  },

  //-------------------------------------------------
  // Calculate |a + bi|
  //
  // sqrt(a*a + b*b)
  //-------------------------------------------------
  magnitude : function (offset,c) 
  {
      return Math.sqrt(c[offset]*c[offset] + c[offset+1]*c[offset+1]); 
  },
  
  phase : function (offset,c) 
  {
      return c[offset]!=0?Math.atan(c[offset+1]/c[offset])*180/Math.PI:(c[offset+1]>0?90:-90); 
  }

}

/*********** VECTOR ************/
function Vector(a,b) {
  var self = this;
  var i,columns,size,offset=0,dim=1,dtn,dt=Vector.options.dt,data;
  
  if (!(this instanceof Vector)) return new Vector(a,b);
  var options=isObject(b)?b:{};
  this.tag='VectorTA';
  
  if (isNumber(a)) {
    // Create a new empty vector (rows=1)
    columns=a;
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    size=columns;
    if (options.complex) size *=2;
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(size);
  } else if (isArray(a)) {
    size=columns=a.length;
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isObject(a)) {
    // partial object
    columns=a.columns;
    size=a.size||columns;
    scale=options.scale;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && a.dtn != options.dtn) {
      // convert dtn
      if (isArray(a.data) && !scale)
        data=new dt(a.data);
      else {
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      }
      dtn=options.dtn;
    } else {
      dtn=a.dtn;
      data=a.data;
      offset=a.offset;
    }
    if (a.scale) this.scale=a.scale;
    if (a.complex) this.complex=a.complex;
  } else if (isString(a)) {
    columns=a.length;
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(toUTF8Array(a));
  }
  
  this.columns=columns;
  this.size=this.length=size;
  this.layout=1;
  this.data=data;
  this.dims=dim;
  this.offset=offset;
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  this.dtn=dtn||dt.name;
  
  if (this.dtn=='Array') this._arrayFix();

  this.__constructor__='Math.VectorTA';
}
Vector.options = {
  dt : Float32Array,
  dtn : 'Float32Array'
}

/********* STATIC MEMBERS *********/
Vector.abs = function (m) {
  return Vector.clone(m).abs();
}

Vector.add = function (m,v) {
  return Vector.clone(m).add(v);
}

Vector.clone = function (src) {
  return Vector(src);
}

Vector.checkVector = function (o) {
  if (o instanceof Vector) return o;
  else return Vector(o);
}

Vector.cos = function (m) {
  return Vector.clone(m).cos();
}

Vector.div = function (m,v) {
  return Vector.clone(m).div(v);
}

Vector.empty = function (columns) {
  return Vector(columns);
}

Vector.exp = function (m) {
  return Vector.clone(m).exp();
}

Vector.init = function (columns,valueOrCallback) {
  return Vector(columns).fill(valueOrCallback);
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.max =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]= Math.max(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.min =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]=Math.min(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.mod = function (m,v) {
  return Vector.clone(m).mod(v);
}

Vector.mul = function (m,v) {
  return Vector.clone(m).mul(v);
}

Vector.neg = function (m) {
  return Vector.clone(m).neg();
}

Vector.ones = function (columns) {
  return Vector(columns).fill(1);
}

Vector.rand = function (columns, rng) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns).fill(function () {
    return rng();
  });
}

Vector.randInt = function (columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}

Vector.sin = function (m) {
  return Vector.clone(m).sin();
}

Vector.sub = function (m,v) {
  return Vector.clone(m).sub(v);
}

Vector.zero = function (columns) {
  return Vector(columns).fill(0);
}



/********* INSTANCE MEMBERS *********/
// Fix some prototype methods for generic array data content
Vector.prototype._arrayFix = function () {
  var self=this;
  this.get=function (column)   { return self.data[self.offset+column] };
  this.set=function (column,v) { self.data[self.offset+column]=v };
}

Vector.prototype.abs = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.abs(this.data[i]);
  return this; 
}

Vector.prototype.add = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]+=v;
  return this; 
}

Vector.prototype.apply = function (f) {
  for(var i=0; i < this.columns; i++) 
    f.call(this,i)
}

Vector.prototype.clone = function () {
  return Vector(this);
}

Vector.prototype.cos = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.cos(this.data[i]);
  return this; 
}

Vector.prototype.div = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]/=v;
  return this; 
}

Vector.prototype.divide = function (column,k) {
  return this.data[column] /= k;
}

// Evaluate all elements x of matrix by applying function f(x)
Vector.prototype.eval = function (f) {
  var i;
  switch (this.dtn) {
    case 'Array':
      for(i=0; i < this.columns; i++) 
        this.set(i,f(this.get(i)))
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i],i);
  }
  return this;
}

Vector.prototype.exp = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.exp(this.data[i]);
  return this; 
}

Vector.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
      for(var i=0;i<this.columns;i++) {
        this.data[i]=valueOrFunction(i);
      } 
  } else this.data.fill(valueOrFunction);
  return this;
}

Vector.prototype.filter = function (f,asArray) {
  var i,j=0,res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(i=0;i<this.columns;i++) {
    v=f(this.data[i],i);
    if (v) res.data[j]=this.data[i],j++;
  }
  return j<this.columns?res.slice(j):res;
}

Vector.prototype.get = function (column) {
  return this.data[this.offset+column];
}

Vector.prototype.imag = function (i) {
  if (this.complex) return this.get(i*2+1);
}

Vector.prototype.incr = function (column,delta) {
  return this.data[column] += delta;
}

Vector.prototype.info = function () {
  var i = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    offset:this.offset,
  }
  if (this.scaler) i.scaler=this.scaler;
  if (this.complex) i.complex=true;
  return i;
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.prototype.magnitude = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.magnitude(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.map = function (f,asArray) {
  var res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(var i=0;j<this.columns;i++)
    res.data[i]=f(this.data[i],i);
  return res;
}

Vector.prototype.multiply = function (column,k) {
  return this.data[column] *= k;
}

Vector.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Vector.prototype.mod = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=this.data[i]%v;
  return this; 
}

Vector.prototype.mul = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]*=v;
  return this; 
}

Vector.prototype.neg = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]=-this.data[i];
  return this; 
}

Vector.prototype.pad = function (n,v,left) { 
  var ext = Vector.init(n,v); 
  if (!left) ext.data.set(this.data);
  else ext.data.set(this.data,this.length);
  return ext;
}

Vector.prototype.phase = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.phase(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.prod = function (v) {
  var i,j,v = 1;
  for (i = 0; i < this.size; i++) v *= this.data[i];
  return v;
}

Vector.prototype.print = function (format,transpose) {
  var j, s='';
  if (!format) format = '%4.2f';
  if (!this.complex)
    for(j=0;j<this.columns;j++) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + sprintf(format,this.data[j]) ;
    }
  else
    for(j=0;j<this.columns;j=j+2) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + '('+sprintf(format,this.data[j])+','+sprintf(format,this.data[j+1])+')' ;
    }
  
  return s;
}

Vector.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

Vector.prototype.real = function (i) {
  if (this.complex) return this.get(i*2);
}

Vector.prototype.resize = function (options) {
  if ((options.offset && (options.columns+options.offset) > this.columns) ||
      !options.columns) throw new Error('Vecotr.resize: invalid argument(s)');
  this.columns=options.columns;
  if (options.offset) this.offset=options.offset;
  this.size=this.length=this.columns;
  if (options.slice) 
    this.data=options.offset?this.data.slice(options.offset,options.columns+offset):
                             this.data.slice(0,options.columns);
  return this;
}

Vector.prototype.set = function (column,val) {
  this.data[this.offset+column]=val;
  return this;
}

Vector.prototype.sin = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.sin(this.data[i]);
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Vector.prototype.size = function () {
  return  this.size;
}

/** Return new vecotr with sliced data
 *
 */
Vector.prototype.slice = function (columns,offset) {
  return Vector(this,{columns:columns,offset:offset,slice:true});
}

Vector.prototype.sub = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]-=v;
  return this; 
}

Vector.prototype.subRange = function (columns,offset) {
  offset=checkOption(offset,0);
  var res=Vector({columns:columns,data:this.data.slice(offset,columns+offset),dtn:this.dtn});
  return res;
}

Vector.prototype.sum = function () {
  var sum=0;
  for(var i=0;i<this.size;i++) sum += this.data[i];
  return sum
}

Vector.prototype.toArray = function () {
  if (!this.complex) return Array.prototype.slice.call(this.data);
}

module.exports = Vector;
};
BundleModuleCode['plugins/math/matrixTA-EVD']=function (module,exports,global,process){
// Matrix EigenvalueDecomposition
// TypedArray version 
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function EigenvalueDecomposition(matrix, options) {
  if (!(this instanceof EigenvalueDecomposition)) return new EigenvalueDecomposition(matrix,options);
  options=checkOptions(options);
  var assumeSymmetric = checkOption(options.assumeSymmetric,false);

  matrix = Matrix.checkMatrix(matrix);
  if (!matrix.isSquare()) {
    throw new Error('EigenvalueDecomposition: Matrix is not a square matrix');
  }

  var n = matrix.columns;
  var V = Matrix(n, n);
  var d = new Array(n);
  var e = new Array(n);
  var value = matrix;
  var i, j;

  var isSymmetric = false;
  if (assumeSymmetric) {
    isSymmetric = true;
  } else {
    isSymmetric = matrix.isSymmetric();
  }

  if (isSymmetric) {
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        V.set(i,j, value.get(i, j));
      }
    }
    tred2(n, e, d, V);
    tql2(n, e, d, V);
  } else {
    var H = Matrix(n, n);
    var ort = new Array(n);
    for (j = 0; j < n; j++) {
      for (i = 0; i < n; i++) {
        H.set(i,j,  value.get(i, j));
      }
    }
    orthes(n, H, ort, V);
    hqr2(n, e, d, V, H);
  }

  this.n = n;
  this.e = e;
  this.d = d;
  this.V = V;
}

EigenvalueDecomposition.prototype = {
  /**
   *
   * @return {Array<number>}
   */
  get realEigenvalues() {
    return this.d;
  },

  /**
   *
   * @return {Array<number>}
   */
  get imaginaryEigenvalues() {
    return this.e;
  },

  /**
   *
   * @return {Matrix}
   */
  get eigenvectorMatrix() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    var n = this.n;
    var e = this.e;
    var d = this.d;
    var X = new Matrix(n, n);
    var i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i,j,0);
      }
      X.set(i,i,d[i]);
      if (e[i] > 0) {
        X.set(i,i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i,i - 1,e[i]);
      }
    }
    return X;
  },
}

function tred2(n, e, d, V) {
  var f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1,j);
        V.set(i,j, 0);
        V.set(j,i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j,i,f);
        g = e[j] + V.get(j,j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k,j) * d[k];
          e[k] += V.get(k,j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.incr(k,j, -(f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1,j);
        V.set(i,j,0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1,i, V.get(i,i));
    V.set(i,i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k,i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k,i + 1) * V.get(k,j);
        }
        for (k = 0; k <= i; k++) {
          V.incr(k,j, -(g * d[k]));
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k,i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
    V.set(n - 1,j, 0);
  }

  V.set(n - 1,n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  var f = 0;
  var tst1 = 0;
  var eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      iter = 0;
      do {
        iter = iter + 1;

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k,i + 1);
            V.set(k,i + 1, s * V.get(k,i) + c * h);
            V.set(k,i, c * V.get(k,i) - s * h);
          }
        }

        p = -s * s2 * c3 * el1 * e[l] / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j,i);
        V.set(j,i, V.get(j,k));
        V.set(j,k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  var low = 0;
  var high = n - 1;
  var f, g, h, i, j, m;
  var scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i,m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i,m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i,j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.incr(i,j, -(f * ort[i]));
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i,j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.incr(i,j, -(f * ort[j]));
        }
      }

      ort[m] = scale * ort[m];
      H.set(m,m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i,j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m,m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i,m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i,j);
        }

        g = g / ort[m] / H.get(m,m - 1);
        for (i = m; i <= high; i++) {
          V.incr(i,j, g * ort[i]);
        }
      }
    }
  }
}


function hqr2(nn, e, d, V, H) {
  var n = nn - 1;
  var low = 0;
  var high = nn - 1;
  var eps = Number.EPSILON;
  var exshift = 0;
  var norm = 0;
  var p = 0;
  var q = 0;
  var r = 0;
  var s = 0;
  var z = 0;
  var iter = 0;
  var i, j, k, l, m, t, w, x, y;
  var ra, sa, vr, vi;
  var notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i,i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i,j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1,l - 1)) + Math.abs(H.get(l,l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l,l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.incr(n,n,exshift);
      d[n] = H.get(n,n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n,n - 1) * H.get(n - 1,n);
      p = (H.get(n - 1,n - 1) - H.get(n,n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.incr(n,n,exshift);
      H.incr(n - 1,n - 1,exshift);
      x = H.get(n,n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n,n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1,j);
          H.set(n - 1,j, q * z + p * H.get(n,j));
          H.set(n,j, q * H.get(n,j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i,n - 1);
          H.set(i,n - 1, q * z + p * H.get(i,n));
          H.set(i,n, q * H.get(i,n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i,n - 1);
          V.set(i,n - 1, q * z + p * V.get(i,n));
          V.set(i,n,  q * V.get(i,n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n,n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1,n - 1);
        w = H.get(n,n - 1) * H.get(n - 1,n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.incr(i,i, -x);
        }
        s = Math.abs(H.get(n,n - 1)) + Math.abs(H.get(n - 1,n - 2));
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.incr(i,i, -s);
          }
          exshift += s;
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m,m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1,m) + H.get(m,m + 1);
        q = H.get(m + 1,m + 1) - z - r - s;
        r = H.get(m + 2,m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m,m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1,m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1,m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i,i - 2, 0);
        if (i > m + 2) {
          H.set(i,i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k,k - 1);
          q = H.get(k + 1,k - 1);
          r = notlast ? H.get(k + 2,k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k,k - 1, -s * x);
          } else if (l !== m) {
            H.set(k,k - 1, -H.get(k,k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k,j) + q * H.get(k + 1,j);
            if (notlast) {
              p = p + r * H.get(k + 2,j);
              H.incr(k + 2,j, -(p * z));
            }

            H.incr(k,j, -(p * x));
            H.incr(k + 1,j, -(p * y));
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i,k) + y * H.get(i,k + 1);
            if (notlast) {
              p = p + z * H.get(i,k + 2);
              H.incr(i,k + 2, -(p * r));
            }

            H.incr(i,k, -p);
            H.incr(i,k + 1, -(p * q));
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i,k) + y * V.get(i,k + 1);
            if (notlast) {
              p = p + z * V.get(i,k + 2);
              V.incr(i,k + 2 , -(p * r));
            }

            V.incr(i,k,-p);
            V.incr(i,k + 1,-(p * q));
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n,n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i,i, -p);
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i,j) * H.get(j,n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i,n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i,n, t);
            H.set(i + 1,n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z);
          }

          t = Math.abs(H.get(i,n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n, t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n,n - 1)) > Math.abs(H.get(n - 1,n))) {
        H.set(n - 1,n - 1, q / H.get(n,n - 1));
        H.set(n - 1,n, -(H.get(n,n) - p) / H.get(n,n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1,n), H.get(n - 1,n - 1) - p, q);
        H.set(n - 1,n - 1, cdivres[0]);
        H.set(n - 1,n,  cdivres[1]);
      }

      H.set(n,n - 1,  0);
      H.set(n,n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i,j) * H.get(j,n - 1);
          sa = sa + H.get(i,j) * H.get(j,n);
        }

        w = H.get(i,i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi
            );
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(i + 1,n - 1,(-ra - w * H.get(i,n - 1) + q * H.get(i,n)) / x);
              H.set(i + 1,n, (-sa - w * H.get(i,n) - q * H.get(i,n - 1)) / x);
            } else {
              cdivres = cdiv(-r - y * H.get(i,n - 1), -s - y * H.get(i,n), z, q);
              H.set(i + 1,n - 1, cdivres[0]);
              H.set(i + 1,n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i,n - 1)), Math.abs(H.get(i,n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n - 1, t);
              H.divide(j,n, t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i,j,  H.get(i,j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i,k) * H.get(k,j);
      }
      V.set(i,j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  var r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}

module.exports = EigenvalueDecomposition
};
BundleModuleCode['plugins/math/matrixTA-SVD']=function (module,exports,global,process){
// Matrix SingularValueDecomposition
// TypedArray version
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function SingularValueDecomposition(matrix, options) {
  if (!(this instanceof SingularValueDecomposition)) return new SingularValueDecomposition(matrix,options);
  options=checkOptions(options);
  var value = Matrix.checkMatrix(matrix);

  var m = value.rows;
  var n = value.columns;

  var computeLeftSingularVectors = checkOption(options.computeLeftSingularVectors,true)
  var computeRightSingularVectors = checkOption(options.computeRightSingularVectors,true)
  var autoTranspose = checkOption(options.autoTranspose,false)

  var wantu = Boolean(computeLeftSingularVectors);
  var wantv = Boolean(computeRightSingularVectors);

  var swapped = false;
  var a;
  if (m < n) {
    if (!autoTranspose) {
      a = value.clone();
      // eslint-disable-next-line no-console
      console.warn(
        'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
      );
    } else {    
      a = value.transpose();
      m = a.rows;
      n = a.columns;
      swapped = true;
      var aux = wantu;
      wantu = wantv;
      wantv = aux;
    }
  } else {
    a = value.clone();
  }

  var nu = Math.min(m, n);
  var ni = Math.min(m + 1, n);
  var s = new Array(ni);
  var U = Matrix(m, nu, {dtn:value.dtn}); 
  var V = Matrix(n, n,  {dtn:value.dtn});  

  var e = new Array(n);
  var work = new Array(m);

  var si = new Array(ni);
  for (var i = 0; i < ni; i++) si[i] = i;

  var nct = Math.min(m - 1, n);
  var nrt = Math.max(0, Math.min(n - 2, m));
  var mrc = Math.max(nct, nrt);
  
  for (var k = 0; k < mrc; k++) {
    if (k < nct) {
      s[k] = 0;
      for (var i = k; i < m; i++) {
        s[k] = hypotenuse(s[k], a.get(i,k));
      }
      if (s[k] !== 0) {
        if (a.get(k,k) < 0) {
          s[k] = -s[k];
        }
        for (var i = k; i < m; i++) {
          a.divide(i,k,s[k]);
        }
        a.incr(k,k,1);
      }
      s[k] = -s[k];
    }

    for (var j = k + 1; j < n; j++) {
      if (k < nct && s[k] !== 0) {
        var t = 0;
        for (var i = k; i < m; i++) {
          t += a.get(i,k) * a.get(i,j);
        }
        t = -t / a.get(k,k);
        for (var i = k; i < m; i++) {
          a.incr(i,j, t * a.get(i,k));
        }
      }
      e[j] = a.get(k,j);
    }
    
    if (wantu && k < nct) {
      for (var i = k; i < m; i++) {
        U.set(i,k, a.get(i,k));
      }
    }
    
    if (k < nrt) {
      e[k] = 0;
      for (var i = k + 1; i < n; i++) {
        e[k] = hypotenuse(e[k], e[i]);
      }
      if (e[k] !== 0) {
        if (e[k + 1] < 0) {
          e[k] = 0 - e[k];
        }
        for (var i = k + 1; i < n; i++) {
          e[i] /= e[k];
        }
        e[k + 1] += 1;
      }
      e[k] = -e[k];
      if (k + 1 < m && e[k] !== 0) {
        for (var i = k + 1; i < m; i++) {
          work[i] = 0;
        }
        for (var i = k + 1; i < m; i++) {
          for (var j = k + 1; j < n; j++) {
            work[i] += e[j] * a.get(i,j);
          }
        }
        for (var j = k + 1; j < n; j++) {
          var t = -e[j] / e[k + 1];
          for (var i = k + 1; i < m; i++) {
            a.incr(i,j, t * work[i]);
          }
        }
      }
      if (wantv) {
        for (var i = k + 1; i < n; i++) {
          V.set(i,k, e[i]);
        }
      }
    }
  }

  var p = Math.min(n, m + 1);
  if (nct < n) {
    s[nct] = a.get(nct,nct);
  }
  if (m < p) {
    s[p - 1] = 0;
  }
  if (nrt + 1 < p) {
    e[nrt] = a.get(nrt,p - 1);
  }
  e[p - 1] = 0;

  if (wantu) {
    for (var j = nct; j < nu; j++) {
      for (var i = 0; i < m; i++) {
        U.set(i,j, 0);
      }
      U.set(j,j, 1);
    }
    for (var k = nct - 1; k >= 0; k--) {
      if (s[k] !== 0) {
        for (var j = k + 1; j < nu; j++) {
          var t = 0;
          for (var i = k; i < m; i++) {
            t += U.get(i,k) * U.get(i,j);
          }
          t = -t / U.get(k,k);
          for (var i = k; i < m; i++) {
            U.incr(i,j, t * U.get(i,k));
          }
        }
        for (var i = k; i < m; i++) {
          U.set(i,k, -U.get(i,k));
        }
        U.incr(k,k,1); // = 1 + U[k][k];
        for (var i = 0; i < k - 1; i++) {
          U.set(i,k,0);
        }
      } else {
        for (var i = 0; i < m; i++) {
          U.set(i,k,0);
        }
        U.set(k,k,1);
      }
    }
  }

  if (wantv) {
    for (var k = n - 1; k >= 0; k--) {
      if (k < nrt && e[k] !== 0) {
        for (var j = k + 1; j < n; j++) {
          var t = 0;
          for (var i = k + 1; i < n; i++) {
            t += V.get(i,k) * V.get(i,j);
          }
          t = -t / V.get(k + 1,k);
          for (var i = k + 1; i < n; i++) {
            V.incr(i,j, t * V.get(i,k));
          }
        }
      }
      for (var i = 0; i < n; i++) {
        V.set(i,k,0);
      }
      V.set(k,k, 1);
    }
  }
  
  var pp = p - 1;
  var iter = 0;
  var eps = Number.EPSILON;
  
  while (p > 0) {
    var k, kase;
    for (k = p - 2; k >= -1; k--) {
      if (k === -1) {
        break;
      }
      const alpha =
        Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
      if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
        e[k] = 0;
        break;
      }
    }
    if (k === p - 2) {
      kase = 4;
    } else {
      var ks;
      for (ks = p - 1; ks >= k; ks--) {
        if (ks === k) {
          break;
        }
        var t =
          (ks !== p ? Math.abs(e[ks]) : 0) +
          (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
        if (Math.abs(s[ks]) <= eps * t) {
          s[ks] = 0;
          break;
        }
      }
      if (ks === k) {
        kase = 3;
      } else if (ks === p - 1) {
        kase = 1;
      } else {
        kase = 2;
        k = ks;
      }
    }

    k++;

    switch (kase) {
      case 1: {
        var f = e[p - 2];
        e[p - 2] = 0;
        for (var j = p - 2; j >= k; j--) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          if (j !== k) {
            f = -sn * e[j - 1];
            e[j - 1] = cs * e[j - 1];
          }
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,p - 1);
              V,set(i,p - 1, -sn * V.get(i,j) + cs * V.get(i,p - 1));
              V.set(i,j, t);
            }
          }
        }
        break;
      }
      case 2: {
        var f = e[k - 1];
        e[k - 1] = 0;
        for (var j = k; j < p; j++) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          f = -sn * e[j];
          e[j] = cs * e[j];
          if (wantu) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U[i][k - 1];
              U.set(i,k - 1, -sn * U.get(i,j) + cs * U.get(i,k - 1));
              U.set(i,j,t);
            }
          }
        }
        break;
      }
      case 3: {
        const scale = Math.max(
          Math.abs(s[p - 1]),
          Math.abs(s[p - 2]),
          Math.abs(e[p - 2]),
          Math.abs(s[k]),
          Math.abs(e[k])
        );
        const sp = s[p - 1] / scale;
        const spm1 = s[p - 2] / scale;
        const epm1 = e[p - 2] / scale;
        const sk = s[k] / scale;
        const ek = e[k] / scale;
        const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
        const c = sp * epm1 * (sp * epm1);
        var shift = 0;
        if (b !== 0 || c !== 0) {
          if (b < 0) {
            shift = 0 - Math.sqrt(b * b + c);
          } else {
            shift = Math.sqrt(b * b + c);
          }
          shift = c / (b + shift);
        }
        var f = (sk + sp) * (sk - sp) + shift;
        var g = sk * ek;
        for (var j = k; j < p - 1; j++) {
          var t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          var cs = f / t;
          var sn = g / t;
          if (j !== k) {
            e[j - 1] = t;
          }
          f = cs * s[j] + sn * e[j];
          e[j] = cs * e[j] - sn * s[j];
          g = sn * s[j + 1];
          s[j + 1] = cs * s[j + 1];
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,j + 1);
              V.set(i,j + 1, -sn * V.get(i,j) + cs * V.get(i,j + 1));
              V.set(i,j, t);
            }
          }
          t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          cs = f / t;
          sn = g / t;
          s[j] = t;
          f = cs * e[j] + sn * s[j + 1];
          s[j + 1] = -sn * e[j] + cs * s[j + 1];
          g = sn * e[j + 1];
          e[j + 1] = cs * e[j + 1];
          if (wantu && j < m - 1) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U.get(i,j + 1);
              U.set(i,j + 1,  -sn * U.get(i,j) + cs * U.get(i,j + 1));
              U.set(i,j, t);
            }
          }
        }
        e[p - 2] = f;
        iter = iter + 1;
        break;
      }
      case 4: {
        if (s[k] <= 0) {
          s[k] = s[k] < 0 ? -s[k] : 0;
          if (wantv) {
            for (var i = 0; i <= pp; i++) {
              V.set(i,k, -V.get(i,k));
            }
          }
        }
        while (k < pp) {
          if (s[k] >= s[k + 1]) {
            break;
          }
          var t = s[k];
          s[k] = s[k + 1];
          s[k + 1] = t;
          if (wantv && k < n - 1) {
            for (var i = 0; i < n; i++) {
              t = V.get(i,k + 1);
              V.set(i,k + 1, V.get(i,k));
              V.set(i,k, t);
            }
          }
          if (wantu && k < m - 1) {
            for (var i = 0; i < m; i++) {
              t = U.get(i,k + 1);
              U.set(i,k + 1,  U.get(i,k));
              U.set(i,k, t);
            }
          }
          k++;
        }
        iter = 0;
        p--;
        break;
      }
      // no default
    }
  }

  if (swapped) {
    var tmp = V;
    V = U;
    U = tmp;
  }

  this.m = m;
  this.n = n;
  this.s = s;
  this.U = U;
  this.V = V;

    
}

SingularValueDecomposition.prototype = {
  /**
   *
   * @return {number}
   */
  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  },

  /**
   *
   * @return {number}
   */
  get norm2() {
    return this.s[0];
  },

  /**
   *
   * @return {number}
   */
  get rank() {
    var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    var r = 0;
    var s = this.s;
    for (var i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  },

  /**
   *
   * @return {Array<number>}
   */
  get diagonal() {
    return this.s;
  },

  /**
   *
   * @return {number}
   */
  get threshold() {
    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
  },

  /**
   *
   * @return {Matrix}
   */
  get leftSingularVectors() {
    if (!Matrix.isMatrix(this.U)) {
      this.U = new Matrix(this.U);
    }
    return this.U;
  },

  /**
   *
   * @return {Matrix}
   */
  get rightSingularVectors() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    return Matrix.diag(this.s);
  }
}
  /**
   * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
   * var svd = SingularValueDecomposition(A);
   * var x = svd.solve(b);
   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
   * @return {Matrix} - The vector x
   */
SingularValueDecomposition.prototype.solve = function(value) {
  var Y = value;
  var e = this.threshold;
  var scols = this.s.length;
  var Ls = Matrix.zeros(scols, scols);

  for (var i = 0; i < scols; i++) {
    if (Math.abs(this.s[i]) <= e) {
      Ls.set(i,i, 0);
    } else {
      Ls.set(i,i, 1 / this.s[i]);
    }
  }

  var U = this.U;
  var V = this.rightSingularVectors;

  var VL = V.mmul(Ls);
  var vrows = V.rows;
  var urows = U.length;
  var VLU = Matrix.zeros(vrows, urows);

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < scols; k++) {
        sum += VL.get(i,k) * U.get(j,k);
      }
      VLU.set(i,j, sum);
    }
  }

  return VLU.mmul(Y);
}

  /**
   *
   * @param {Array<number>} value
   * @return {Matrix}
   */
SingularValueDecomposition.prototype.solveForDiagonal = function (value) {
  return this.solve(Matrix.diag(value));
}

  /**
   * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
   * var svd = SingularValueDecomposition(A);
   * var inverseA = svd.inverse();
   * @return {Matrix} - The approximation of the inverse of the matrix
   */
SingularValueDecomposition.prototype.inverse = function () {
  var V = this.V;
  var e = this.threshold;
  var vrows = V.rows;
  var vcols = V.columns;
  var X = Matrix(vrows, this.s.length, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < vcols; j++) {
      if (Math.abs(this.s[j]) > e) {
        X.set(i,j, V.get(i,j) / this.s[j]);
      } else {
        X.set(i,j, 0);
      }
    }
  }

  var U = this.U;

  var urows = U.rows;
  var ucols = U.columns;
  var Y = Matrix(vrows, urows, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < ucols; k++) {
        sum += X.get(i,k) * U.get(j,k);
      }
      Y.set(i,j, sum);
    }
  }

  return Y;
}

module.exports = SingularValueDecomposition;
};
BundleModuleCode['plugins/math/matrix']=function (module,exports,global,process){
/* Matrix array objects
** Version 1.3.4
*/
var version = "1.3.4"
var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;

function Matrix(elements,options,aux) {
  if (!(this instanceof Matrix)) return new Matrix(elements,options,aux);
  options=options||{};
  this.tag='Matrix';
  var space=[];
  if (Utils.isNumber(elements)) space.push(elements);
  if (Utils.isNumber(options)) space.push(options);  
  if (Utils.isNumber(aux)) space.push(aux);
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.data=Array(space[0]).fill(0);
    if (space.length>1) for(var i=0;i<space[0];i++) this.data[i]=Array(space[1]).fill(0);
    if (space.length>2) for(var i=0;i<space[0];i++) 
                          for(var j=0;j<space[1];j++) this.data[i][j]=Array(space[2]).fill(0);
    
  } else  
    this.setData(elements,options.reference);
  this.__constructor__='Math.Matrix';
};

Matrix.version=version;

Matrix.create = Matrix
// var $M = Matrix.create;

Matrix.isMatrix = function (o) {
  return o instanceof Matrix
}

Matrix.I = function(n) {
  var els = [], i = n, j;
  while (i--) { j = n;
    els[i] = [];
    while (j--) {
      els[i][j] = (i === j) ? 1 : 0;
    }
  }
  return Matrix.create(els);
};

Matrix.Init = function(rows,columns,callback) {
  var els = [], i = rows, j;
  while (i--) { j = columns;
    els[i] = [];
    if (typeof callback == 'function')
    while (j--) {
      els[i][j] = callback(i,j);
    }
    else
    while (j--) {
      els[i][j] = callback; // constant value
    }
  }
  return Matrix.create(els);
};

Matrix.Diagonal = function(elements) {
  var i = elements.length;
  var M = Matrix.I(i);
  while (i--) {
    M.data[i][i] = elements[i];
  }
  return M;
};

Matrix.Rotation = function(theta, a) {
  if (!a) {
    return Matrix.create([
      [Math.cos(theta),  -Math.sin(theta)],
      [Math.sin(theta),   Math.cos(theta)]
    ]);
  }
  var axis = a.dup();
  if (axis.data.length !== 3) { return null; }
  var mod = axis.modulus();
  var x = axis.data[0]/mod, y = axis.data[1]/mod, z = axis.data[2]/mod;
  var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
  // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
  // That proof rotates the co-ordinate system so theta becomes -theta and sin
  // becomes -sin here.
  return Matrix.create([
    [ t*x*x + c, t*x*y - s*z, t*x*z + s*y ],
    [ t*x*y + s*z, t*y*y + c, t*y*z - s*x ],
    [ t*x*z - s*y, t*y*z + s*x, t*z*z + c ]
  ],{reference:true});
};

Matrix.RotationX = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  1,  0,  0 ],
    [  0,  c, -s ],
    [  0,  s,  c ]
  ],{reference:true});
};
Matrix.RotationY = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c,  0,  s ],
    [  0,  1,  0 ],
    [ -s,  0,  c ]
  ],{reference:true});
};
Matrix.RotationZ = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c, -s,  0 ],
    [  s,  c,  0 ],
    [  0,  0,  1 ]
  ],{reference:true});
};

Matrix.Random = function(n, m) {
  return Matrix.Zero(n, m).map(
    function() { return Math.random(); }
  );
};

Matrix.Zero = function(n, m) {
  var els = [], i = n, j;
  while (i--) { j = m;
    els[i] = [];
    while (j--) {
      els[i][j] = 0;
    }
  }
  return Matrix.create(els,{reference:true});
};

Matrix.prototype = {

  add: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x + M[i][j]; });
  },

  addColumn : function (index,data) {
    var T = this, cols = T.data[0].length;
    if (index==cols) {
      // simple, append on right side
      T.data.forEach(function (row,i) {
        row.push(data[i])
      })
    }
    return T;
  },
  
  apply: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        this.data[i][j]=fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  augment: function(matrix) {
    if (this.data.length === 0) { return this.dup(); }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    var T = this.dup(), cols = T.data[0].length;
    var i = T.data.length, nj = M[0].length, j;
    if (i !== M.length) { return null; }
    while (i--) { j = nj;
      while (j--) {
        T.data[i][cols + j] = M[i][j];
      }
    }
    return T;
  },

  canMultiplyFromLeft: function(matrix) {
    if (this.data.length === 0) { return false; }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    // this.columns should equal matrix.rows
    return (this.data[0].length === M.length);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b,c,d) {
    var i,j,k,p,v,m,ni,nj,nk,filter;

    if (isNumber(a)) i=a;
    if (isNumber(b)) j=b;
    if (isNumber(c)) k=c;
    if (isString(b)) filter=b;
    if (isString(c)) filter=c;
    if (isString(d)) filter=d;
    if (!filter) filter='mean';

    if (!i) throw "Matrix.convert: no target size (number, first dim.)";
    if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";

    m = Matrix(i,j,k);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.rows/m.rows);
    nj=Math.floor(this.columns/m.columns);
    for(i=0;i<m.rows;i++) {
      for(j=0;j<m.columns;j++) {
        for(p=0;p<ni;p++) {
          for(q=0;q<nj;q++) {
            if (p==0 && q==0) 
              v=this.get(i*ni,j*nj);
            else
              v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
          }
        }
        m.set(i,j,v);
      }
    }
    return m;
  },

  col: function(j,asVector) {
    if (this.data.length === 0) { return null; }
    if (j >= this.data[0].length) { return null; }
    var col = [], n = this.data.length;
    for (var i = 0; i < n; i++) { col.push(this.data[i][j]); }
    return asVector?Math.Vector.create(col):col;
  },

  cols: function() {
    if (this.data.length === 0) { return 0; }
    return this.data[0].length;
  },

  derivative : function (order,points,h) {
    // TODO >1dim return Matrix.create(Math.derivative(this.data,order,points,h),{reference:true});
  },
  
  determinant: function() {
    if (this.data.length === 0) { return 1; }
    if (!this.isSquare()) { return null; }
    var M = this.toRightTriangular();
    var det = M.data[0][0], n = M.data.length;
    for (var i = 1; i < n; i++) {
      det = det * M.data[i][i];
    }
    return det;
  },

  diagonal: function() {
    if (!this.isSquare) { return null; }
    var els = [], n = this.data.length;
    for (var i = 0; i < n; i++) {
      els.push(this.data[i][i]);
    }
    return Math.Vector.create(els);
  },

  dimensions: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return {rows: this.data.length, cols: cols};
  },

  dup: function() {
    return Matrix.create(this.data);
  },

  // row,col
  e: function(i,j) {
    if (i < 1 || i > this.data.length || j < 1 || j > this.data[0].length) { return null; }
    return this.data[i-1][j-1];
  },

  eql: function(matrix) {
    var M = matrix.data || matrix;
    if (!M[0] || typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0 || M.length === 0) {
      return this.data.length === M.length;
    }
    if (this.data.length !== M.length) { return false; }
    if (this.data[0].length !== M[0].length) { return false; }
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j] - M[i][j]) > Math.precision) { return false; }
      }
    }
    return true;
  },

  get: function (i,j) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j];    
  },

  get rows () {
    return this.data.length;
  },
  get columns () {
    return this.data[0].length;
  },

  indexOf: function(x) {
    if (this.data.length === 0) { return null; }
    var index = null, ni = this.data.length, i, nj = this.data[0].length, j;
    for (i = 0; i < ni; i++) {
      for (j = 0; j < nj; j++) {
        if (this.data[i][j] === x) { return {i: i+1, j: j+1}; }
      }
    }
    return null;
  },

  inspect: function() {
    var matrix_rows = [];
    var n = this.data.length;
    if (n === 0) return '[]';
    for (var i = 0; i < n; i++) {
      matrix_rows.push(Math.Vector.create(this.data[i]).inspect());
    }
    return matrix_rows.join('\n');
  },

  inverse: function() {
    if (this.data.length === 0) { return null; }
    if (!this.isSquare() || this.isSingular()) { return null; }
    var n = this.data.length, i= n, j;
    var M = this.augment(Matrix.I(n)).toRightTriangular();
    var np = M.data[0].length, p, els, divisor;
    var inverse_elements = [], new_element;
    // Matrix. is non-singular so there will be no zeros on the
    // diagonal. Cycle through rows from last to first.
    while (i--) {
      // First, normalise diagonal elements to 1
      els = [];
      inverse_elements[i] = [];
      divisor = M.data[i][i];
      for (p = 0; p < np; p++) {
        new_element = M.data[i][p] / divisor;
        els.push(new_element);
        // Shuffle off the current row of the right hand side into the results
        // array as it will not be modified by later runs through this loop
        if (p >= n) { inverse_elements[i].push(new_element); }
      }
      M.data[i] = els;
      // Then, subtract this row from those above it to give the identity matrix
      // on the left hand side
      j = i;
      while (j--) {
        els = [];
        for (p = 0; p < np; p++) {
          els.push(M.data[j][p] - M.data[i][p] * M.data[j][i]);
        }
        M.data[j] = els;
      }
    }
    return Matrix.create(inverse_elements);
  },

  isSameSizeAs: function(matrix) {
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0) { return M.length === 0; }
    return (this.data.length === M.length &&
        this.data[0].length === M[0].length);
  },

  isSingular: function() {
    return (this.isSquare() && this.determinant() === 0);
  },

  isSquare: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return (this.data.length === cols);
  },

  iter: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  loop: function(fn, context, tmo) {
    var tmo=typeof context=='number'?context:(tmo||1);
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    var timer = setInterval(tmo,function () {
      if (i<ni) { 
        if (j<nj) {
          fn.call(context, this.data[i][j], i, j);
          j++;
        } else j = 0,i++;
      } else clearInterval(timer);
    });
    return this;
  },
  
  max: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] > m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) > Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  map: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        els[i][j] = fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  mapRow : function (f) {
    var res=[];
    for(var row=0;row<this.rows;row++) {
      res.push(f(this.data[row],row));
    }
    return res;
  },

  min: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] < m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) < Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minor: function(a, b, c, d) {
    if (this.data.length === 0) { return null; }
    var elements = [], ni = c, i, nj, j;
    var rows = this.data.length, cols = this.data[0].length;
    while (ni--) { i = c - ni - 1;
      elements[i] = [];
      nj = d;
      while (nj--) { j = d - nj - 1;
        elements[i][j] = this.data[(a+i-1)%rows][(b+j-1)%cols];
      }
    }
    return Matrix.create(elements);
  },

  multiply: function(matrix) {
    if (this.data.length === 0) { return null; }
    if (!matrix.data) {
      return this.map(function(x) { return x * matrix; });
    }
    var returnVector = matrix.modulus ? true : false;
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.canMultiplyFromLeft(M)) { return null; }
    var i = this.data.length, nj = M[0].length, j;
    var cols = this.data[0].length, c, elements = [], sum;
    while (i--) { j = nj;
      elements[i] = [];
      while (j--) { c = cols;
        sum = 0;
        while (c--) {
          sum += this.data[i][c] * M[c][j];
        }
        elements[i][j] = sum;
      }
    }
    var M = Matrix.create(elements);
    return returnVector ? M.col(0,true) : M;
  },

  print : function () {
    return this.data.print()
  },
  
  rank: function() {
    if (this.data.length === 0) { return 0; }
    var M = this.toRightTriangular(), rank = 0;
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(M.data[i][j]) > Math.precision) { rank++; break; }
      }
    }
    return rank;
  },

  resize : function (options) {
    var space=this.dataspace,
        new_space=[],
        offset=[];
    if (Utils.isArray(options)) { // [row0,col0,row1,col1]
      switch (options.length) {
        case 2:
          new_space=[options[1]-options[0]];
          offset=[options[0]];
          break;
        case 4:
          new_space=[options[2]-options[0], options[3]-options[1]];
          offeset=[options[0],options[1]];
          break;
      }
    } else for(var p in options) {
      switch (p) {
        case 'rows':    new_space[0]=options[p]; break;
        case 'columns': new_space[1]=options[p]; break;
        case 'levels':  new_space[3]=options[p]; break;
        case 'dataspace': new_space=dataspace; break;
        case 'offset':
          offset=options[p];
          break;
      }
    }
    if (typeof offset == 'number') offset=[offset];
    // TODO
    switch (new_space.length) {
      case 0:
        // shrink rows
        if (offset.length==1) {
          return this.slice(offset[0]);        
        }
        break;
      case 1:
        // shrink/expand rows
        if (new_space[0]<space[0]) {
          offset=offset[0]||0;
          return this.slice(offset,offset+new_space[0]);
        }
        break;   
     
    }
    return new Error('ENOTSUPPORTED');
  },
  
  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  row: function(i,asVector) {
    if (i >= this.data.length) { return null; }
    return asVector?Math.Vector.create(this.data[i]):this.data[i];
  },

  snapTo: function(x) {
    return this.map(function(p) {
      return (Math.abs(p - x) <= Math.precision) ? x : p;
    });
  },

  set: function (i,j,v) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j]=v;    
  },

  setData: function(els,ref) {
    var i, j, elements = els.data || els;
    this.datatype='number';
    this.dataspace=Math.dataspace(elements);
    if (ref) { this.data=els; return this};
    if (elements[0] && typeof(elements[0][0]) !== 'undefined') {
      i = elements.length;
      this.data = [];
      while (i--) { j = elements[i].length;
        this.data[i] = [];
        while (j--) {
          this.data[i][j] = elements[i][j];
        }
      }
      return this;
    }
    var n = elements.length;
    this.data = [];
    for (i = 0; i < n; i++) {
      this.data.push([elements[i]]);
    }
    return this;
  },
  
  // Slice of data in major dimension
  slice : function (a,b,inplace) {
    if (b==undefined) b=this.rows;
    return inplace?
            Matrix(this.data.slice(a,b))
            : Matrix(this.data.slice(a,b).map(function (row) { return row.slice() }));
  },
  
  subMatrix : function (startRow, endRow, startColumn, endColumn) {
    var data = [];
    switch (this.dataspace.length) {
      case 1:
        for(var i=startRow;i<=endRow;i++) {
          data.push(this.data[i]);
        }
        return Vector(data);
        break;
      case 2:
        for(var i=startRow;i<endRow;i++) {
          var row=[];
          for(var j=startColumn;j<=endColumn;j++) {
            row.push(this.data[i][j]);
          }
          data.push(row);
        }
        return Matrix(data);
        break;
    }
  },
  
  // rx:rows,ry:columns,rz:levels
  subMatrixRange : function (rx,ry,rz) {
    var data=[];
    function copy(x) { return x.slice() }
    if (this.dataspace.length!=2) throw "subMatrixRange: dim not supported"
    if (isNumber(rx) && isAll(ry)) {
      return Matrix([this.data[rx].slice()]);
    } else if (isRange(rx) && isAll(ry)) {
      return Matrix(this.data.slice(rx[0],rx[1]+1).map(copy)); 
    } else {
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    }
  },
  
  
  subtract: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x - M[i][j]; });
  },

  toArray : function () { return this.data },
  
  toRightTriangular: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var M = this.dup(), els;
    var n = this.data.length, i, j, np = this.data[0].length, p;
    for (i = 0; i < n; i++) {
      if (M.data[i][i] === 0) {
        for (j = i + 1; j < n; j++) {
          if (M.data[j][i] !== 0) {
            els = [];
            for (p = 0; p < np; p++) { els.push(M.data[i][p] + M.data[j][p]); }
            M.data[i] = els;
            break;
          }
        }
      }
      if (M.data[i][i] !== 0) {
        for (j = i + 1; j < n; j++) {
          var multiplier = M.data[j][i] / M.data[i][i];
          els = [];
          for (p = 0; p < np; p++) {
            // Elements with column numbers up to an including the number of the
            // row that we're subtracting can safely be set straight to zero,
            // since that's the point of this routine and it avoids having to
            // loop over and correct rounding errors later
            els.push(p <= i ? 0 : M.data[j][p] - M.data[i][p] * multiplier);
          }
          M.data[j] = els;
        }
      }
    }
    return M;
  },

  trace: function() {
    if (this.data.length === 0) { return 0; }
    if (!this.isSquare()) { return null; }
    var tr = this.data[0][0], n = this.data.length;
    for (var i = 1; i < n; i++) {
      tr += this.data[i][i];
    }
    return tr;
  },
  
  transpose: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var rows = this.data.length, i, cols = this.data[0].length, j;
    var elements = [], i = cols;
    while (i--) { j = rows;
      elements[i] = [];
      while (j--) {
        elements[i][j] = this.data[j][i];
      }
    }
    return Matrix.create(elements);
  },
};

Matrix.prototype.toUpperTriangular = Matrix.prototype.toRightTriangular;
Matrix.prototype.det = Matrix.prototype.determinant;
Matrix.prototype.tr = Matrix.prototype.trace;
Matrix.prototype.rk = Matrix.prototype.rank;
Matrix.prototype.inv = Matrix.prototype.inverse;
Matrix.prototype.x = Matrix.prototype.multiply;
Matrix.prototype.pluck = Matrix.prototype.col;

module.exports = Matrix;
};
BundleModuleCode['plugins/math/vector']=function (module,exports,global,process){
/*
** Vector array objects
**
** Ver. 1.4.1
*/
var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;
    
var Vector = function(elements,options) {
  if (!(this instanceof Vector)) return new Vector(elements,options);
  options=options||{};
  var space=[];
  this.tag='Vector';
  if (typeof elements == 'number') space.push(elements);
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.columns=space[0];
    this.data=Array(space[0]).fill(0);
  } else {
    this.columns=elements.length;
    this.setData(elements,options.reference);
  }
  this.__constructor__='Math.Vector';
};

Vector.isVector = function (o) {
  return o instanceof Vector
}

Vector.create = Vector

// var $V = Vector.create;
Vector.Init = function(n,valueOrCallback) {
  var elements = [],i=0;
  if (typeof valueOrCallback == 'function')
    while (i<n) { elements.push(valueOrCallback(i)); i++; }
  else
    while (i<n) { elements.push(valueOrCallback); i++; }
  return Vector.create(elements);
};

Vector.Random = function(n) {
  var elements = [];
  while (n--) { elements.push(Math.random()); }
  return Vector.create(elements);
};

Vector.Sequence = function(a,b,step) {
  if (!step) step=1;
  var elements = [];
  var i=a;
  while (i<b) { 
    elements.push(i);
    i += step; 
  }
  return Vector.create(elements);
};

Vector.Zero = function(n) {
  var elements = [];
  while (n--) { elements.push(0); }
  return Vector.create(elements);
};

Vector.prototype = {
  e: function(i) {
    return (i < 1 || i > this.data.length) ? null : this.data[i-1];
  },


  add: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x + V[i-1]; });
  },

  angleFrom: function(vector) {
    var V = vector.data || vector;
    var n = this.data.length, k = n, i;
    if (n !== V.length) { return null; }
    var dot = 0, mod1 = 0, mod2 = 0;
    // Work things out in parallel to save time
    this.each(function(x, i) {
      dot += x * V[i-1];
      mod1 += x * x;
      mod2 += V[i-1] * V[i-1];
    });
    mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
    if (mod1*mod2 === 0) { return null; }
    var theta = dot / (mod1*mod2);
    if (theta < -1) { theta = -1; }
    if (theta > 1) { theta = 1; }
    return Math.acos(theta);
  },

  cross: function(vector) {
    var B = vector.data || vector;
    if (this.data.length !== 3 || B.length !== 3) { return null; }
    var A = this.data;
    return Vector.create([
      (A[1] * B[2]) - (A[2] * B[1]),
      (A[2] * B[0]) - (A[0] * B[2]),
      (A[0] * B[1]) - (A[1] * B[0])
    ]);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b) {
    var i,p,v,m,ni,filter;

    if (isNumber(a)) i=a;
    if (isString(b)) filter=b;
    if (!filter) filter='mean';

    if (!i) throw "Vector.convert: no target size (number, first dim.)";

    m = Vector(i);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.columns/m.columns);
    for(i=0;i<m.columns;i++) {
        v=this.data[i*ni]; 
        for(p=1;p<ni;p++) {
          v=filter(v,this.data[i*ni+p],p,ni);
        }
        m.data[i]=v;
    }
    return m;
  },

  derivative : function (order,points,h) {
    return Vector.create(Math.derivative(this.data,order,points,h),{reference:true});
  },

  dimensions: function() {
    return this.data.length;
  },

  distanceFrom: function(obj) {
    if (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    var V = obj.data || obj;
    if (V.length !== this.data.length) { return null; }
    var sum = 0, part;
    this.each(function(x, i) {
      part = x - V[i-1];
      sum += part * part;
    });
    return Math.sqrt(sum);
  },

  dot: function(vector) {
    var V = vector.data || vector;
    var i, product = 0, n = this.data.length;
    if (n !== V.length) { return null; }
    while (n--) { product += this.data[n] * V[n]; }
    return product;
  },

  dup: function() {
    return Vector.create(this.data);
  },

  eql: function(vector) {
    var n = this.data.length;
    var V = vector.data || vector;
    if (n !== V.length) { return false; }
    while (n--) {
      if (Math.abs(this.data[n] - V[n]) > Math.precision) { return false; }
    }
    return true;
  },

  forEach: function(fn, context) {
    var n = this.data.length;
    for (var i = 0; i < n; i++) {
      fn.call(context, this.data[i], i+1);
    }
  },
  
  get : function (i) { return this.data[i] },

  indexOf: function(x) {
    var index = null, n = this.data.length;
    for (var i = 0; i < n; i++) {
      if (index === null && this.data[i] === x) {
        index = i + 1;
      }
    }
    return index;
  },

  inspect: function() {
    return '[' + this.data.join(', ') + ']';
  },

  isParallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (angle <= Math.precision);
  },

  isAntiparallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (Math.abs(angle - Math.PI) <= Math.precision);
  },

  isPerpendicularTo: function(vector) {
    var dot = this.dot(vector);
    return (dot === null) ? null : (Math.abs(dot) <= Math.precision);
  },

  liesOn: function(line) {
    return line.contains(this);
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  get length () {
    return this.data.length
  },
  
  map: function(fn, context) {
    var elements = [];
    this.each(function(x, i) {
      elements.push(fn.call(context, x, i));
    });
    return Vector.create(elements);
  },

  max: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] > m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) > Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  min: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] < m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    var m = 0, i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) < Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  modulus: function() {
    return Math.sqrt(this.dot(this));
  },

  multiply: function(k) {
    return this.map(function(x) { return x*k; });
  },

  pad : function (n,v,left) {
    return Vector(this.data.pad(n,v,left));
  },

  print : function () {
    return this.data.print()
  },

  reflectionIn: function(obj) {
    if (obj.anchor) {
      // obj is a plane or line
      var P = this.data.slice();
      var C = obj.pointClosestTo(P).data;
      return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
    } else {
      // obj is a point
      var Q = obj.data || obj;
      if (this.data.length !== Q.length) { return null; }
      return this.map(function(x, i) { return Q[i-1] + (Q[i-1] - x); });
    }
  },

  rotate: function(t, obj) {
    var V, R = null, x, y, z;
    if (t.determinant) { R = t.data; }
    switch (this.data.length) {
      case 2:
        V = obj.data || obj;
        if (V.length !== 2) { return null; }
        if (!R) { R = Math.Matrix.Rotation(t).data; }
        x = this.data[0] - V[0];
        y = this.data[1] - V[1];
        return Vector.create([
          V[0] + R[0][0] * x + R[0][1] * y,
          V[1] + R[1][0] * x + R[1][1] * y
        ]);
        break;
      case 3:
        if (!obj.direction) { return null; }
        var C = obj.pointClosestTo(this).data;
        if (!R) { R = Math.Matrix.Rotation(t, obj.direction).data; }
        x = this.data[0] - C[0];
        y = this.data[1] - C[1];
        z = this.data[2] - C[2];
        return Vector.create([
          C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
          C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
          C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
        ]);
        break;
      default:
        return null;
    }
  },

  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  set : function (i,v) { return this.data[i]=v },

  setData: function(els,ref) {
    this.datatype='number';
    this.dataspace=[els.length];
    if (ref) { this.data=(els.data || els); return this};
    this.data = (els.data || els).slice();
    return this;
  },
  
  snapTo: function(x) {
    return this.map(function(y) {
      return (Math.abs(y - x) <= Math.precision) ? x : y;
    });
  },

  subtract: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x - V[i-1]; });
  },

  toArray : function () { return this.data },

  to3D: function() {
    var V = this.dup();
    switch (V.data.length) {
      case 3: break;
      case 2: V.data.push(0); break;
      default: return null;
    }
    return V;
  },

  toDiagonalMatrix: function() {
    return Math.Matrix.Diagonal(this.data);
  },

  toUnitVector: function() {
    var r = this.modulus();
    if (r === 0) { return this.dup(); }
    return this.map(function(x) { return x/r; });
  },


};

Vector.prototype.x = Vector.prototype.multiply;
Vector.prototype.each = Vector.prototype.forEach;
Vector.prototype.sample = function (frag,filter) { return Vector(this.data.sample(frag,filter)) };

Vector.i = Vector.create([1,0,0]);
Vector.j = Vector.create([0,1,0]);
Vector.k = Vector.create([0,0,1]);

module.exports = Vector;
};
BundleModuleCode['plugins/math/line']=function (module,exports,global,process){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 

var Line = function(anchor, direction) {
  if (!(this instanceof Line)) return new Line(anchor, direction);
  this.setVectors(anchor, direction);
};

Line.prototype = {
  eql: function(line) {
    return (this.isParallelTo(line) && this.contains(line.anchor));
  },

  dup: function() {
    return Line.create(this.anchor, this.direction);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Line.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.direction);
  },

  isParallelTo: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }
    var theta = this.direction.angleFrom(obj.direction);
    return (Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    if (obj.direction) {
      // obj is a line
      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }
      var N = this.direction.cross(obj.direction).toUnitVector().data;
      var A = this.anchor.data, B = obj.anchor.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, D = this.direction.data;
      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
      if (modPA === 0) return 0;
      // Assumes direction vector is normalized
      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
      var sin2 = 1 - cosTheta*cosTheta;
      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
    }
  },

  contains: function(obj) {
    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }
    var dist = this.distanceFrom(obj);
    return (dist !== null && dist <= Math.precision);
  },

  positionOf: function(point) {
    if (!this.contains(point)) { return null; }
    var P = point.data || point;
    var A = this.anchor.data, D = this.direction.data;
    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  intersects: function(obj) {
    if (obj.normal) { return obj.intersects(this); }
    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Math.precision);
  },

  intersectionWith: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }
    if (!this.intersects(obj)) { return null; }
    var P = this.anchor.data, X = this.direction.data,
        Q = obj.anchor.data, Y = obj.direction.data;
    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
    var XdotX = X1*X1 + X2*X2 + X3*X3;
    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
  },

  pointClosestTo: function(obj) {
    if (obj.start && obj.end) {
      // obj is a line segment
      var P = obj.pointClosestTo(this);
      return (P === null) ? null : this.pointClosestTo(P);
    } else if (obj.direction) {
      // obj is a line
      if (this.intersects(obj)) { return this.intersectionWith(obj); }
      if (this.isParallelTo(obj)) { return null; }
      var D = this.direction.data, E = obj.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
      // Create plane containing obj and the shared normal and intersect this
      // with it Thank you:
      // http://www.cgafaq.info/wiki/Line-line_distance
      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];
      var P = Math.Plane.create(obj.anchor, N);
      return P.intersectionWith(this);
    } else {
      // obj is a point
      var P = obj.data || obj;
      if (this.contains(P)) { return Vector.create(P); }
      var A = this.anchor.data, D = this.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
      var k = this.distanceFrom(P) / V.modulus();
      return Vector.create([
        P[0] + V.data[0] * k,
        P[1] + V.data[1] * k,
        (P[2] || 0) + V.data[2] * k
      ]);
    }
  },

  // Returns a copy of the line rotated by t radians about the given line. Works
  // by finding the argument's closest point to this line's anchor point (call
  // this C) and rotating the anchor about C. Also rotates the line's direction
  // about the argument's. Be careful with this - the rotation axis' direction
  // affects the outcome!
  rotate: function(t, line) {
    // If we're working in 2D
    if (typeof(line.direction) === 'undefined') { line = Line.create(line.to3D(), Vector.k); }
    var R = Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, D = this.direction.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Line.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
    ]);
  },

  reverse: function() {
    return Line.create(this.anchor, this.direction.x(-1));
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, D = this.direction.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the line's direction vector to its anchor, then mirror that in the plane
      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
      var Q = obj.pointClosestTo([AD1, AD2, AD3]).data;
      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
      return Line.create(newA, newD);
    } else if (obj.direction) {
      // obj is a line - reflection obtained by rotating PI radians about obj
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point - just reflect the line's anchor in it
      var P = obj.data || obj;
      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
    }
  },

  setVectors: function(anchor, direction) {
    // Need to do this so that line's properties are not references to the
    // arguments passed in
    anchor = Vector.create(anchor);
    direction = Vector.create(direction);
    if (anchor.data.length === 2) {anchor.data.push(0); }
    if (direction.data.length === 2) { direction.data.push(0); }
    if (anchor.data.length > 3 || direction.data.length > 3) { return null; }
    var mod = direction.modulus();
    if (mod === 0) { return null; }
    this.anchor = anchor;
    this.direction = Vector.create([
      direction.data[0] / mod,
      direction.data[1] / mod,
      direction.data[2] / mod
    ]);
    return this;
  }
};

Line.create = Line;

Line.X = Line.create(Vector.Zero(3), Vector.i);
Line.Y = Line.create(Vector.Zero(3), Vector.j);
Line.Z = Line.create(Vector.Zero(3), Vector.k);


module.exports = Line;
};
BundleModuleCode['plugins/math/plane']=function (module,exports,global,process){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 
var Line   = Require('plugins/math/line') 

var Plane = function(anchor, v1, v2) {
  if (!(this instanceof Plane)) return  new Plane(anchor, v1, v2);
  this.setVectors(anchor, v1, v2);
};

Plane.prototype = {
  eql: function(plane) {
    return (this.contains(plane.anchor) && this.isParallelTo(plane));
  },

  dup: function() {
    return Plane.create(this.anchor, this.normal);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Plane.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.normal);
  },

  isParallelTo: function(obj) {
    var theta;
    if (obj.normal) {
      // obj is a plane
      theta = this.normal.angleFrom(obj.normal);
      return (Math.abs(theta) <= Math.precision || Math.abs(Math.PI - theta) <= Math.precision);
    } else if (obj.direction) {
      // obj is a line
      return this.normal.isPerpendicularTo(obj.direction);
    }
    return null;
  },

  isPerpendicularTo: function(plane) {
    var theta = this.normal.angleFrom(plane.normal);
    return (Math.abs(Math.PI/2 - theta) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (this.intersects(obj) || this.contains(obj)) { return 0; }
    if (obj.anchor) {
      // obj is a plane or line
      var A = this.anchor.data, B = obj.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
    }
  },

  contains: function(obj) {
    if (obj.normal) { return null; }
    if (obj.direction) {
      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));
    } else {
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
      return (diff <= Math.precision);
    }
  },

  intersects: function(obj) {
    if (typeof(obj.direction) === 'undefined' && typeof(obj.normal) === 'undefined') { return null; }
    return !this.isParallelTo(obj);
  },

  intersectionWith: function(obj) {
    if (!this.intersects(obj)) { return null; }
    if (obj.direction) {
      // obj is a line
      var A = obj.anchor.data, D = obj.direction.data,
          P = this.anchor.data, N = this.normal.data;
      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);
    } else if (obj.normal) {
      // obj is a plane
      var direction = this.normal.cross(obj.normal).toUnitVector();
      // To find an anchor point, we find one co-ordinate that has a value of
      // zero somewhere on the intersection, and remember which one we picked
      var N = this.normal.data, A = this.anchor.data,
          O = obj.normal.data, B = obj.anchor.data;
      var solver = Matrix.Zero(2,2), i = 0;
      while (solver.isSingular()) {
        i++;
        solver = Matrix.create([
          [ N[i%3], N[(i+1)%3] ],
          [ O[i%3], O[(i+1)%3]  ]
        ]);
      }
      // Then we solve the simultaneous equations in the remaining dimensions
      var inverse = solver.inverse().data;
      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
      var intersection = [
        inverse[0][0] * x + inverse[0][1] * y,
        inverse[1][0] * x + inverse[1][1] * y
      ];
      var anchor = [];
      for (var j = 1; j <= 3; j++) {
        // This formula picks the right element from intersection by cycling
        // depending on which element we set to zero above
        anchor.push((i === j) ? 0 : intersection[(j + (5 - i)%3)%3]);
      }
      return Line.create(anchor, direction);
    }
  },

  pointClosestTo: function(point) {
    var P = point.data || point;
    var A = this.anchor.data, N = this.normal.data;
    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
  },

  rotate: function(t, line) {
    var R = t.determinant ? t.data : Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, N = this.normal.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Plane.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
    ]);
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, N = this.normal.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the plane's normal to its anchor, then mirror that in the other plane
      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
      var Q = obj.pointClosestTo([AN1, AN2, AN3]).data;
      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
      return Plane.create(newA, newN);
    } else if (obj.direction) {
      // obj is a line
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point
      var P = obj.data || obj;
      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
    }
  },

  setVectors: function(anchor, v1, v2) {
    anchor = Vector.create(anchor);
    anchor = anchor.to3D(); if (anchor === null) { return null; }
    v1 = Vector.create(v1);
    v1 = v1.to3D(); if (v1 === null) { return null; }
    if (typeof(v2) === 'undefined') {
      v2 = null;
    } else {
      v2 = Vector.create(v2);
      v2 = v2.to3D(); if (v2 === null) { return null; }
    }
    var A1 = anchor.data[0], A2 = anchor.data[1], A3 = anchor.data[2];
    var v11 = v1.data[0], v12 = v1.data[1], v13 = v1.data[2];
    var normal, mod;
    if (v2 !== null) {
      var v21 = v2.data[0], v22 = v2.data[1], v23 = v2.data[2];
      normal = Vector.create([
        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
      ]);
      mod = normal.modulus();
      if (mod === 0) { return null; }
      normal = Vector.create([normal.data[0] / mod, normal.data[1] / mod, normal.data[2] / mod]);
    } else {
      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
      if (mod === 0) { return null; }
      normal = Vector.create([v1.data[0] / mod, v1.data[1] / mod, v1.data[2] / mod]);
    }
    this.anchor = anchor;
    this.normal = normal;
    return this;
  }
};

Plane.create = Plane


Plane.XY = Plane.create(Vector.Zero(3), Vector.k);
Plane.YZ = Plane.create(Vector.Zero(3), Vector.i);
Plane.ZX = Plane.create(Vector.Zero(3), Vector.j);
Plane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;

Plane.fromPoints = function(points) {
  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);
  for (i = 0; i < np; i++) {
    P = Vector.create(points[i]).to3D();
    if (P === null) { return null; }
    list.push(P);
    n = list.length;
    if (n > 2) {
      // Compute plane normal for the latest three points
      A = list[n-1].data; B = list[n-2].data; C = list[n-3].data;
      N = Vector.create([
        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
      ]).toUnitVector();
      if (n > 3) {
        // If the latest normal is not (anti)parallel to the previous one, we've
        // strayed off the plane. This might be a slightly long-winded way of
        // doing things, but we need the sum of all the normals to find which
        // way the plane normal should point so that the points form an
        // anticlockwise list.
        theta = N.angleFrom(prevN);
        if (theta !== null) {
          if (!(Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision)) { return null; }
        }
      }
      totalN = totalN.add(N);
      prevN = N;
    }
  }
  // We need to add in the normals at the start and end points, which the above
  // misses out
  A = list[1].data; B = list[0].data; C = list[n-1].data; D = list[n-2].data;
  totalN = totalN.add(Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).toUnitVector()).add(Vector.create([
    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),
    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),
    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])
  ]).toUnitVector());
  return Plane.create(list[0], totalN);
};
};
BundleModuleCode['plugins/math/stats']=function (module,exports,global,process){
// https://github.com/simple-statistics/simple-statistics

'use strict';

var exports = module.exports;
function log2(n) {
  return Math.log(n) / Math.log(2);
}

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0,
            sumY = 0,
            sumXX = 0,
            sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    } else if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0],
        // store the mode as we find new modes
        value = NaN,
        // store how many times we've seen the mode
        maxSeen = 0,
        // how many times the current candidate for the mode
        // has been seen
        seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(nlog(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, min is
        // undefined and is thus made the minimum element in the array
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, max is
        // undefined and is thus made the maximum element in the array
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    // The mad of nothing is null
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // chose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample.slice(), randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0,
        lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix.length - 1) {
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "geometricMean requires only positive numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.2174396181152126432e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Infinity;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    "1": {
        "0.995": 0,
        "0.99": 0,
        "0.975": 0,
        "0.95": 0,
        "0.9": 0.02,
        "0.5": 0.45,
        "0.1": 2.71,
        "0.05": 3.84,
        "0.025": 5.02,
        "0.01": 6.63,
        "0.005": 7.88
    },
    "2": {
        "0.995": 0.01,
        "0.99": 0.02,
        "0.975": 0.05,
        "0.95": 0.1,
        "0.9": 0.21,
        "0.5": 1.39,
        "0.1": 4.61,
        "0.05": 5.99,
        "0.025": 7.38,
        "0.01": 9.21,
        "0.005": 10.6
    },
    "3": {
        "0.995": 0.07,
        "0.99": 0.11,
        "0.975": 0.22,
        "0.95": 0.35,
        "0.9": 0.58,
        "0.5": 2.37,
        "0.1": 6.25,
        "0.05": 7.81,
        "0.025": 9.35,
        "0.01": 11.34,
        "0.005": 12.84
    },
    "4": {
        "0.995": 0.21,
        "0.99": 0.3,
        "0.975": 0.48,
        "0.95": 0.71,
        "0.9": 1.06,
        "0.5": 3.36,
        "0.1": 7.78,
        "0.05": 9.49,
        "0.025": 11.14,
        "0.01": 13.28,
        "0.005": 14.86
    },
    "5": {
        "0.995": 0.41,
        "0.99": 0.55,
        "0.975": 0.83,
        "0.95": 1.15,
        "0.9": 1.61,
        "0.5": 4.35,
        "0.1": 9.24,
        "0.05": 11.07,
        "0.025": 12.83,
        "0.01": 15.09,
        "0.005": 16.75
    },
    "6": {
        "0.995": 0.68,
        "0.99": 0.87,
        "0.975": 1.24,
        "0.95": 1.64,
        "0.9": 2.2,
        "0.5": 5.35,
        "0.1": 10.65,
        "0.05": 12.59,
        "0.025": 14.45,
        "0.01": 16.81,
        "0.005": 18.55
    },
    "7": {
        "0.995": 0.99,
        "0.99": 1.25,
        "0.975": 1.69,
        "0.95": 2.17,
        "0.9": 2.83,
        "0.5": 6.35,
        "0.1": 12.02,
        "0.05": 14.07,
        "0.025": 16.01,
        "0.01": 18.48,
        "0.005": 20.28
    },
    "8": {
        "0.995": 1.34,
        "0.99": 1.65,
        "0.975": 2.18,
        "0.95": 2.73,
        "0.9": 3.49,
        "0.5": 7.34,
        "0.1": 13.36,
        "0.05": 15.51,
        "0.025": 17.53,
        "0.01": 20.09,
        "0.005": 21.96
    },
    "9": {
        "0.995": 1.73,
        "0.99": 2.09,
        "0.975": 2.7,
        "0.95": 3.33,
        "0.9": 4.17,
        "0.5": 8.34,
        "0.1": 14.68,
        "0.05": 16.92,
        "0.025": 19.02,
        "0.01": 21.67,
        "0.005": 23.59
    },
    "10": {
        "0.995": 2.16,
        "0.99": 2.56,
        "0.975": 3.25,
        "0.95": 3.94,
        "0.9": 4.87,
        "0.5": 9.34,
        "0.1": 15.99,
        "0.05": 18.31,
        "0.025": 20.48,
        "0.01": 23.21,
        "0.005": 25.19
    },
    "11": {
        "0.995": 2.6,
        "0.99": 3.05,
        "0.975": 3.82,
        "0.95": 4.57,
        "0.9": 5.58,
        "0.5": 10.34,
        "0.1": 17.28,
        "0.05": 19.68,
        "0.025": 21.92,
        "0.01": 24.72,
        "0.005": 26.76
    },
    "12": {
        "0.995": 3.07,
        "0.99": 3.57,
        "0.975": 4.4,
        "0.95": 5.23,
        "0.9": 6.3,
        "0.5": 11.34,
        "0.1": 18.55,
        "0.05": 21.03,
        "0.025": 23.34,
        "0.01": 26.22,
        "0.005": 28.3
    },
    "13": {
        "0.995": 3.57,
        "0.99": 4.11,
        "0.975": 5.01,
        "0.95": 5.89,
        "0.9": 7.04,
        "0.5": 12.34,
        "0.1": 19.81,
        "0.05": 22.36,
        "0.025": 24.74,
        "0.01": 27.69,
        "0.005": 29.82
    },
    "14": {
        "0.995": 4.07,
        "0.99": 4.66,
        "0.975": 5.63,
        "0.95": 6.57,
        "0.9": 7.79,
        "0.5": 13.34,
        "0.1": 21.06,
        "0.05": 23.68,
        "0.025": 26.12,
        "0.01": 29.14,
        "0.005": 31.32
    },
    "15": {
        "0.995": 4.6,
        "0.99": 5.23,
        "0.975": 6.27,
        "0.95": 7.26,
        "0.9": 8.55,
        "0.5": 14.34,
        "0.1": 22.31,
        "0.05": 25,
        "0.025": 27.49,
        "0.01": 30.58,
        "0.005": 32.8
    },
    "16": {
        "0.995": 5.14,
        "0.99": 5.81,
        "0.975": 6.91,
        "0.95": 7.96,
        "0.9": 9.31,
        "0.5": 15.34,
        "0.1": 23.54,
        "0.05": 26.3,
        "0.025": 28.85,
        "0.01": 32,
        "0.005": 34.27
    },
    "17": {
        "0.995": 5.7,
        "0.99": 6.41,
        "0.975": 7.56,
        "0.95": 8.67,
        "0.9": 10.09,
        "0.5": 16.34,
        "0.1": 24.77,
        "0.05": 27.59,
        "0.025": 30.19,
        "0.01": 33.41,
        "0.005": 35.72
    },
    "18": {
        "0.995": 6.26,
        "0.99": 7.01,
        "0.975": 8.23,
        "0.95": 9.39,
        "0.9": 10.87,
        "0.5": 17.34,
        "0.1": 25.99,
        "0.05": 28.87,
        "0.025": 31.53,
        "0.01": 34.81,
        "0.005": 37.16
    },
    "19": {
        "0.995": 6.84,
        "0.99": 7.63,
        "0.975": 8.91,
        "0.95": 10.12,
        "0.9": 11.65,
        "0.5": 18.34,
        "0.1": 27.2,
        "0.05": 30.14,
        "0.025": 32.85,
        "0.01": 36.19,
        "0.005": 38.58
    },
    "20": {
        "0.995": 7.43,
        "0.99": 8.26,
        "0.975": 9.59,
        "0.95": 10.85,
        "0.9": 12.44,
        "0.5": 19.34,
        "0.1": 28.41,
        "0.05": 31.41,
        "0.025": 34.17,
        "0.01": 37.57,
        "0.005": 40
    },
    "21": {
        "0.995": 8.03,
        "0.99": 8.9,
        "0.975": 10.28,
        "0.95": 11.59,
        "0.9": 13.24,
        "0.5": 20.34,
        "0.1": 29.62,
        "0.05": 32.67,
        "0.025": 35.48,
        "0.01": 38.93,
        "0.005": 41.4
    },
    "22": {
        "0.995": 8.64,
        "0.99": 9.54,
        "0.975": 10.98,
        "0.95": 12.34,
        "0.9": 14.04,
        "0.5": 21.34,
        "0.1": 30.81,
        "0.05": 33.92,
        "0.025": 36.78,
        "0.01": 40.29,
        "0.005": 42.8
    },
    "23": {
        "0.995": 9.26,
        "0.99": 10.2,
        "0.975": 11.69,
        "0.95": 13.09,
        "0.9": 14.85,
        "0.5": 22.34,
        "0.1": 32.01,
        "0.05": 35.17,
        "0.025": 38.08,
        "0.01": 41.64,
        "0.005": 44.18
    },
    "24": {
        "0.995": 9.89,
        "0.99": 10.86,
        "0.975": 12.4,
        "0.95": 13.85,
        "0.9": 15.66,
        "0.5": 23.34,
        "0.1": 33.2,
        "0.05": 36.42,
        "0.025": 39.36,
        "0.01": 42.98,
        "0.005": 45.56
    },
    "25": {
        "0.995": 10.52,
        "0.99": 11.52,
        "0.975": 13.12,
        "0.95": 14.61,
        "0.9": 16.47,
        "0.5": 24.34,
        "0.1": 34.28,
        "0.05": 37.65,
        "0.025": 40.65,
        "0.01": 44.31,
        "0.005": 46.93
    },
    "26": {
        "0.995": 11.16,
        "0.99": 12.2,
        "0.975": 13.84,
        "0.95": 15.38,
        "0.9": 17.29,
        "0.5": 25.34,
        "0.1": 35.56,
        "0.05": 38.89,
        "0.025": 41.92,
        "0.01": 45.64,
        "0.005": 48.29
    },
    "27": {
        "0.995": 11.81,
        "0.99": 12.88,
        "0.975": 14.57,
        "0.95": 16.15,
        "0.9": 18.11,
        "0.5": 26.34,
        "0.1": 36.74,
        "0.05": 40.11,
        "0.025": 43.19,
        "0.01": 46.96,
        "0.005": 49.65
    },
    "28": {
        "0.995": 12.46,
        "0.99": 13.57,
        "0.975": 15.31,
        "0.95": 16.93,
        "0.9": 18.94,
        "0.5": 27.34,
        "0.1": 37.92,
        "0.05": 41.34,
        "0.025": 44.46,
        "0.01": 48.28,
        "0.005": 50.99
    },
    "29": {
        "0.995": 13.12,
        "0.99": 14.26,
        "0.975": 16.05,
        "0.95": 17.71,
        "0.9": 19.77,
        "0.5": 28.34,
        "0.1": 39.09,
        "0.05": 42.56,
        "0.025": 45.72,
        "0.01": 49.59,
        "0.005": 52.34
    },
    "30": {
        "0.995": 13.79,
        "0.99": 14.95,
        "0.975": 16.79,
        "0.95": 18.49,
        "0.9": 20.6,
        "0.5": 29.34,
        "0.1": 40.26,
        "0.05": 43.77,
        "0.025": 46.98,
        "0.01": 50.89,
        "0.005": 53.67
    },
    "40": {
        "0.995": 20.71,
        "0.99": 22.16,
        "0.975": 24.43,
        "0.95": 26.51,
        "0.9": 29.05,
        "0.5": 39.34,
        "0.1": 51.81,
        "0.05": 55.76,
        "0.025": 59.34,
        "0.01": 63.69,
        "0.005": 66.77
    },
    "50": {
        "0.995": 27.99,
        "0.99": 29.71,
        "0.975": 32.36,
        "0.95": 34.76,
        "0.9": 37.69,
        "0.5": 49.33,
        "0.1": 63.17,
        "0.05": 67.5,
        "0.025": 71.42,
        "0.01": 76.15,
        "0.005": 79.49
    },
    "60": {
        "0.995": 35.53,
        "0.99": 37.48,
        "0.975": 40.48,
        "0.95": 43.19,
        "0.9": 46.46,
        "0.5": 59.33,
        "0.1": 74.4,
        "0.05": 79.08,
        "0.025": 83.3,
        "0.01": 88.38,
        "0.005": 91.95
    },
    "70": {
        "0.995": 43.28,
        "0.99": 45.44,
        "0.975": 48.76,
        "0.95": 51.74,
        "0.9": 55.33,
        "0.5": 69.33,
        "0.1": 85.53,
        "0.05": 90.53,
        "0.025": 95.02,
        "0.01": 100.42,
        "0.005": 104.22
    },
    "80": {
        "0.995": 51.17,
        "0.99": 53.54,
        "0.975": 57.15,
        "0.95": 60.39,
        "0.9": 64.28,
        "0.5": 79.33,
        "0.1": 96.58,
        "0.05": 101.88,
        "0.025": 106.63,
        "0.01": 112.33,
        "0.005": 116.32
    },
    "90": {
        "0.995": 59.2,
        "0.99": 61.75,
        "0.975": 65.65,
        "0.95": 69.13,
        "0.9": 73.29,
        "0.5": 89.33,
        "0.1": 107.57,
        "0.05": 113.14,
        "0.025": 118.14,
        "0.01": 124.12,
        "0.005": 128.3
    },
    "100": {
        "0.995": 67.33,
        "0.99": 70.06,
        "0.975": 74.22,
        "0.95": 77.93,
        "0.9": 82.36,
        "0.5": 99.33,
        "0.1": 118.5,
        "0.05": 124.34,
        "0.025": 129.56,
        "0.01": 135.81,
        "0.005": 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z,
        tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI$1) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the cumulative distribution function of the normal distribution.
 * It is used to find the probability that a statistic is observed below,
 * above, or between values on the standard normal distribution, and by
 * extension, any normal distribution.
 *
 * The probabilities are calculated using the
 * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).
 * The table used is the cumulative, and not cumulative from 0 to mean
 * (even though the latter has 5 digits precision, instead of 4).
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return +(1 - standardNormalTable[index]).toFixed(4);
    }
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'"
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}


// More statistics: enrtopy ...

// Finds element with highest occurrence in a list
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;
  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}
exports.mostCommon = mostCommon;

// Probe for a value
function probe(value, list) {
  var occurrences = list.filter(function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probe = probe;
/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probeEps(value, list, eps) {
  var occurrences = list.filter(function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probeEps = probeEps;


exports.unique = function (list) { return list.unique() };
function uniqueSorted (array) {
  var set = array.unique().sort(function (a,b) { return a<b?-1:1 });
  return set;
}
function uniqueEps(array,eps) {
  var result=[];
  array.forEach(function (x) {
    var found;
    if (!result.length) result.push(x);
    else {
      result.forEach(function (y) {
        if (found) return;
        found = Math.abs(x-y)<=eps;
      }); 
      if (!found) result.push(x);
    }
  });
  return result;
}
exports.uniqueEps = uniqueEps;

// Entropy of data vectors
function entropy(vals) {
  var uniqueVals = vals.unique();
  var probs = uniqueVals.map(function(x) {
    return probe(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropy = entropy;

function entropyEps(vals,eps) {
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probeEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropyEps = entropyEps;

// Entropy of target variable partitioned feature vector
function entropyT(data,featureIndex,targetIndex,targets) {
  var en = 0;
  var col =  pluck(data,featureIndex);
  var uniqueVals = unique(col);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2==v) cn++,frac[targets.indexOf(data[row][targetIndex])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyT = entropyT;

function entropyTEps(data,feature,target,targets,eps) {
  var en = 0;
  var col =  pluck(data,feature);
  var uniqueVals = uniqueEps(col,eps);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2>=v-eps && v2<=v+eps) cn++,frac[targets.indexOf(data[row][target])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyTEps = entropyTEps;


function gainEps(data,feature,target,targets,eps) {
  var et = entropy(data.pluck(target));
  return et/entropyTEps(data,feature,target,targets,eps)
}


function maxGainEps(data,features,target,targets,eps) {
  var maxgain=max(features, function(feature,index) {
    var g = gainEps(data,feature,target,targets,selectEps(eps,index));
    return g;
  });
  return maxgain;
}

function distribution (table) {
  var d={};
  table.forEach(function (row) {
    if (Utils.isArray(row)) row.forEach(function (v) { 
      if (d[v]==undefined) d[v]=1; else d[v]++ });
    else { if (d[row]==undefined) d[row]=1; else d[row]++ };
  })
  return d;
}
function histogram (vector,delta,min,max) {
  if (min==undefined) min=vector.min();
  if (max==undefined) max=vector.max();
  var n = Math.ceil((max-min)/delta);
  var h = Array.init(n);
  for(var i=0;i<vector.length;i++) {
    var chan=Math.floor((vector[i]-min)/delta);
    h[chan]++;
  }
  return h;
}

exports.BayesianClassifier = BayesianClassifier;
exports.PerceptronModel = PerceptronModel;
exports.addToMean = addToMean;
exports.average = mean;
exports.averageSimple = meanSimple;
exports.bayesian = BayesianClassifier;
exports.bernoulliDistribution = bernoulliDistribution;
exports.binomialDistribution = binomialDistribution;
exports.bisect = bisect;
exports.chiSquaredDistributionTable = chiSquaredDistributionTable;
exports.chiSquaredGoodnessOfFit = chiSquaredGoodnessOfFit;
exports.chunk = chunk;
exports.ckmeans = ckmeans;
exports.combinations = combinations;
exports.combinationsReplacement = combinationsReplacement;
exports.combineMeans = combineMeans;
exports.combineVariances = combineVariances;
exports.cumulativeStdNormalProbability = cumulativeStdNormalProbability;
exports.distribution = distribution;
exports.epsilon = epsilon;
exports.equalIntervalBreaks = equalIntervalBreaks;
exports.erf = errorFunction;
exports.errorFunction = errorFunction;
exports.extent = extent;
exports.extentSorted = extentSorted;
exports.factorial = factorial;
exports.gamma = gamma;
exports.gammaln = gammaln;
exports.geometricMean = geometricMean;
exports.harmonicMean = harmonicMean;
exports.histogram = histogram;
exports.interquartileRange = interquartileRange;
exports.inverseErrorFunction = inverseErrorFunction;
exports.iqr = interquartileRange;
exports.kde = kernelDensityEstimation;
exports.kernelDensityEstimation = kernelDensityEstimation;
exports.linearRegression = linearRegression;
exports.linearRegressionLine = linearRegressionLine;
exports.mad = medianAbsoluteDeviation;
exports.max = max;
exports.maxSorted = maxSorted;
exports.mean = mean;
exports.meanSimple = meanSimple;
exports.median = median;
exports.medianAbsoluteDeviation = medianAbsoluteDeviation;
exports.medianSorted = medianSorted;
exports.min = min;
exports.minSorted = minSorted;
exports.mode = mode;
exports.modeFast = modeFast;
exports.modeSorted = modeSorted;
exports.numericSort = numericSort;
exports.perceptron = PerceptronModel;
exports.permutationTest = permutationTest;
exports.permutationsHeap = permutationsHeap;
exports.poissonDistribution = poissonDistribution;
exports.probit = probit;
exports.product = product;
exports.quantile = quantile;
exports.quantileRank = quantileRank;
exports.quantileRankSorted = quantileRankSorted;
exports.quantileSorted = quantileSorted;
exports.quickselect = quickselect;
exports.rSquared = rSquared;
exports.rms = rootMeanSquare;
exports.rootMeanSquare = rootMeanSquare;
exports.sample = sample;
exports.sampleCorrelation = sampleCorrelation;
exports.sampleCovariance = sampleCovariance;
exports.sampleKurtosis = sampleKurtosis;
exports.sampleSkewness = sampleSkewness;
exports.sampleStandardDeviation = sampleStandardDeviation;
exports.sampleVariance = sampleVariance;
exports.sampleWithReplacement = sampleWithReplacement;
exports.shuffle = shuffle;
exports.shuffleInPlace = shuffleInPlace;
exports.sign = sign;
exports.standardDeviation = standardDeviation;
exports.standardNormalTable = standardNormalTable;
exports.subtractFromMean = subtractFromMean;
exports.sum = sum;
exports.sumNthPowerDeviations = sumNthPowerDeviations;
exports.sumSimple = sumSimple;
exports.tTest = tTest;
exports.tTestTwoSample = tTestTwoSample;
exports.uniqueCountSorted = uniqueCountSorted;
exports.uniqueSorted = uniqueSorted;
exports.variance = variance;
exports.zScore = zScore;


// Full statistical analysis of a data set
function analysis (data,options) {
  var i,numeric,column;
  options=options||{};
  function analize(column,options) {
    var numeric=options.numeric;
    if (numeric == undefined) {
        numeric = data.filter(function (row) {
        return isNaN(Number(row))
      }).length==0; 
    }
    if (numeric) {
      return {
        mean:mean(column),
        median:median(column),
        medianAbsoluteDeviation:medianAbsoluteDeviation(column),
        min:min(column),
        max:max(column),
        rootMeanSquare:rootMeanSquare(column),
        standardDeviation:standardDeviation(column),
        sum:sum(column),
        uniqueCountSorted:uniqueCountSorted(column),
        variance:variance(column),
      }
    } else {
      return {
        distribution:distribution(column),
        entropy:entropy(column),
        mostCommon:mostCommon(column),
        unique:uniqueSorted(column),
      }
    }
  }
  if (Utils.isMatrix(data)) {
    return data[0].map(function (x,i) {
      return analize(data.pluck(i),{
        numeric:typeof options.numeric == 'boolean'?options.numeric:
                (Utils.isArray(options.numeric)?options.numeric[i]:undefined)
      });
    })
  } else
    return analize(data,options); // todo: matrix
}
exports.analysis = analysis;

};
BundleModuleCode['plugins/math/dwt5']=function (module,exports,global,process){
/* https://github.com/Symmetronic/discrete-wavelets */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.wt = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /**
     * Antisymmetric padding.
     */
    var ANTISYMMETRIC_PADDING = 'antisymmetric';
    /**
     * Returns a single value of antisymmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function antisymmetricPadding$$1(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        var dirChanges = Math.floor(index / data.length);
        var sign = (dirChanges % 2 === 0) ? -1 : 1;
        return sign * symmetricPadding(data, index, inverse);
    }

    /**
     * Constant padding.
     */
    var CONSTANT_PADDING = 'constant';
    /**
     * Returns a single value of constant padding.
     * @param  data    Input values.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function constantPadding(data, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine constant padding for data of zero length.');
        }
        /* Determine constant padding. */
        return (!inverse)
            ? data[data.length - 1]
            : data[0];
    }

    /**
     * Periodic padding.
     */
    var PERIODIC_PADDING = 'periodic';
    /**
     * Returns a single value of periodic padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function periodicPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine periodic padding for data of zero length.');
        }
        /* Determine periodic padding. */
        return (!inverse)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Reflect padding.
     */
    var REFLECT_PADDING = 'reflect';
    /**
     * Returns a single value of reflect padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function reflectPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine reflect padding for data of zero length.');
        }
        /* Return constant value for data of length one. */
        if (data.length === 1)
            return data[0];
        /* Determine reflect padding. */
        var dirChanges = Math.floor(index / (data.length - 1));
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % (data.length - 1) + 1]
            : data[data.length - 2 - (index % (data.length - 1))];
    }

    /**
     * Smooth padding.
     */
    var SMOOTH_PADDING = 'smooth';
    /**
     * Returns a single value of smooth padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function smoothPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine smooth padding for data of zero length.');
        }
        /* Determine line equation. */
        var end = data.length - 1;
        var offset = (inverse) ? data[0] : data[end];
        var slope = (inverse)
            ? (data.length === 1) ? data[0] : data[0] - data[1]
            : (data.length === 1) ? -data[0] : data[end] - data[end - 1];
        return offset + (index + 1) * slope;
    }

    /**
     * Symmetric padding.
     */
    var SYMMETRIC_PADDING = 'symmetric';
    /**
     * Returns a single value of symmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function symmetricPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine symmetric padding for data of zero length.');
        }
        /* Determine symmetric padding. */
        var dirChanges = Math.floor(index / data.length);
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Zero padding.
     */
    var ZERO_PADDING = 'zero';
    /**
     * Returns a single value of zero padding.
     * @return         Single padding value.
     */
    function zeroPadding() {
        return 0;
    }

    /**
     * Supported signal extension modes.
     */
    var PADDING_MODES = {
        antisymmetric: ANTISYMMETRIC_PADDING,
        constant: CONSTANT_PADDING,
        periodic: PERIODIC_PADDING,
        reflect: REFLECT_PADDING,
        smooth: SMOOTH_PADDING,
        symmetric: SYMMETRIC_PADDING,
        zero: ZERO_PADDING,
        modes: [
            ZERO_PADDING,
            CONSTANT_PADDING,
            SYMMETRIC_PADDING,
            PERIODIC_PADDING,
            SMOOTH_PADDING,
            REFLECT_PADDING,
            ANTISYMMETRIC_PADDING,
        ],
    };

    // SOURCE: https://github.com/PyWavelets/pywt/blob/master/pywt/_extensions/c/wavelets_coeffs.template.h
    /**
     * Haar wavelet scaling numbers.
     */
    var HaarWavelet = [
        1 / Math.SQRT2,
        1 / Math.SQRT2
    ];
    /**
     * Daubechies 2 scaling numbers.
     */
    var Db2Wavelet = [
        (1 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 - Math.sqrt(3)) / (4 * Math.SQRT2),
        (1 - Math.sqrt(3)) / (4 * Math.SQRT2)
    ];
    /**
     * Daubechies 3 scaling numbers.
     */
    var Db3Wavelet = [
        3.326705529500826159985115891390056300129233992450683597084705e-01,
        8.068915093110925764944936040887134905192973949948236181650920e-01,
        4.598775021184915700951519421476167208081101774314923066433867e-01,
        -1.350110200102545886963899066993744805622198452237811919756862e-01,
        -8.544127388202666169281916918177331153619763898808662976351748e-02,
        3.522629188570953660274066471551002932775838791743161039893406e-02
    ];
    /**
     * Daubechies 4 scaling numbers.
     */
    var Db4Wavelet = [
        2.303778133088965008632911830440708500016152482483092977910968e-01,
        7.148465705529156470899219552739926037076084010993081758450110e-01,
        6.308807679298589078817163383006152202032229226771951174057473e-01,
        -2.798376941685985421141374718007538541198732022449175284003358e-02,
        -1.870348117190930840795706727890814195845441743745800912057770e-01,
        3.084138183556076362721936253495905017031482172003403341821219e-02,
        3.288301166688519973540751354924438866454194113754971259727278e-02,
        -1.059740178506903210488320852402722918109996490637641983484974e-02
    ];
    /**
     * Daubechies 5 scaling numbers.
     */
    var Db5Wavelet = [
        1.601023979741929144807237480204207336505441246250578327725699e-01,
        6.038292697971896705401193065250621075074221631016986987969283e-01,
        7.243085284377729277280712441022186407687562182320073725767335e-01,
        1.384281459013207315053971463390246973141057911739561022694652e-01,
        -2.422948870663820318625713794746163619914908080626185983913726e-01,
        -3.224486958463837464847975506213492831356498416379847225434268e-02,
        7.757149384004571352313048938860181980623099452012527983210146e-02,
        -6.241490212798274274190519112920192970763557165687607323417435e-03,
        -1.258075199908199946850973993177579294920459162609785020169232e-02,
        3.335725285473771277998183415817355747636524742305315099706428e-03
    ];
    /**
     * Daubechies 6 scaling numbers.
     */
    var Db6Wavelet = [
        1.115407433501094636213239172409234390425395919844216759082360e-01,
        4.946238903984530856772041768778555886377863828962743623531834e-01,
        7.511339080210953506789344984397316855802547833382612009730420e-01,
        3.152503517091976290859896548109263966495199235172945244404163e-01,
        -2.262646939654398200763145006609034656705401539728969940143487e-01,
        -1.297668675672619355622896058765854608452337492235814701599310e-01,
        9.750160558732304910234355253812534233983074749525514279893193e-02,
        2.752286553030572862554083950419321365738758783043454321494202e-02,
        -3.158203931748602956507908069984866905747953237314842337511464e-02,
        5.538422011614961392519183980465012206110262773864964295476524e-04,
        4.777257510945510639635975246820707050230501216581434297593254e-03,
        -1.077301085308479564852621609587200035235233609334419689818580e-03
    ];
    /**
     * Daubechies 7 scaling numbers.
     */
    var Db7Wavelet = [
        7.785205408500917901996352195789374837918305292795568438702937e-02,
        3.965393194819173065390003909368428563587151149333287401110499e-01,
        7.291320908462351199169430703392820517179660611901363782697715e-01,
        4.697822874051931224715911609744517386817913056787359532392529e-01,
        -1.439060039285649754050683622130460017952735705499084834401753e-01,
        -2.240361849938749826381404202332509644757830896773246552665095e-01,
        7.130921926683026475087657050112904822711327451412314659575113e-02,
        8.061260915108307191292248035938190585823820965629489058139218e-02,
        -3.802993693501441357959206160185803585446196938467869898283122e-02,
        -1.657454163066688065410767489170265479204504394820713705239272e-02,
        1.255099855609984061298988603418777957289474046048710038411818e-02,
        4.295779729213665211321291228197322228235350396942409742946366e-04,
        -1.801640704047490915268262912739550962585651469641090625323864e-03,
        3.537137999745202484462958363064254310959060059520040012524275e-04
    ];
    /**
     * Daubechies 8 scaling numbers.
     */
    var Db8Wavelet = [
        5.441584224310400995500940520299935503599554294733050397729280e-02,
        3.128715909142999706591623755057177219497319740370229185698712e-01,
        6.756307362972898068078007670471831499869115906336364227766759e-01,
        5.853546836542067127712655200450981944303266678053369055707175e-01,
        -1.582910525634930566738054787646630415774471154502826559735335e-02,
        -2.840155429615469265162031323741647324684350124871451793599204e-01,
        4.724845739132827703605900098258949861948011288770074644084096e-04,
        1.287474266204784588570292875097083843022601575556488795577000e-01,
        -1.736930100180754616961614886809598311413086529488394316977315e-02,
        -4.408825393079475150676372323896350189751839190110996472750391e-02,
        1.398102791739828164872293057263345144239559532934347169146368e-02,
        8.746094047405776716382743246475640180402147081140676742686747e-03,
        -4.870352993451574310422181557109824016634978512157003764736208e-03,
        -3.917403733769470462980803573237762675229350073890493724492694e-04,
        6.754494064505693663695475738792991218489630013558432103617077e-04,
        -1.174767841247695337306282316988909444086693950311503927620013e-04
    ];
    /**
     * Daubechies 9 scaling numbers.
     */
    var Db9Wavelet = [
        3.807794736387834658869765887955118448771714496278417476647192e-02,
        2.438346746125903537320415816492844155263611085609231361429088e-01,
        6.048231236901111119030768674342361708959562711896117565333713e-01,
        6.572880780513005380782126390451732140305858669245918854436034e-01,
        1.331973858250075761909549458997955536921780768433661136154346e-01,
        -2.932737832791749088064031952421987310438961628589906825725112e-01,
        -9.684078322297646051350813353769660224825458104599099679471267e-02,
        1.485407493381063801350727175060423024791258577280603060771649e-01,
        3.072568147933337921231740072037882714105805024670744781503060e-02,
        -6.763282906132997367564227482971901592578790871353739900748331e-02,
        2.509471148314519575871897499885543315176271993709633321834164e-04,
        2.236166212367909720537378270269095241855646688308853754721816e-02,
        -4.723204757751397277925707848242465405729514912627938018758526e-03,
        -4.281503682463429834496795002314531876481181811463288374860455e-03,
        1.847646883056226476619129491125677051121081359600318160732515e-03,
        2.303857635231959672052163928245421692940662052463711972260006e-04,
        -2.519631889427101369749886842878606607282181543478028214134265e-04,
        3.934732031627159948068988306589150707782477055517013507359938e-05
    ];
    /**
     * Daubechies 10 scaling numbers.
     */
    var Db10Wavelet = [
        2.667005790055555358661744877130858277192498290851289932779975e-02,
        1.881768000776914890208929736790939942702546758640393484348595e-01,
        5.272011889317255864817448279595081924981402680840223445318549e-01,
        6.884590394536035657418717825492358539771364042407339537279681e-01,
        2.811723436605774607487269984455892876243888859026150413831543e-01,
        -2.498464243273153794161018979207791000564669737132073715013121e-01,
        -1.959462743773770435042992543190981318766776476382778474396781e-01,
        1.273693403357932600826772332014009770786177480422245995563097e-01,
        9.305736460357235116035228983545273226942917998946925868063974e-02,
        -7.139414716639708714533609307605064767292611983702150917523756e-02,
        -2.945753682187581285828323760141839199388200516064948779769654e-02,
        3.321267405934100173976365318215912897978337413267096043323351e-02,
        3.606553566956169655423291417133403299517350518618994762730612e-03,
        -1.073317548333057504431811410651364448111548781143923213370333e-02,
        1.395351747052901165789318447957707567660542855688552426721117e-03,
        1.992405295185056117158742242640643211762555365514105280067936e-03,
        -6.858566949597116265613709819265714196625043336786920516211903e-04,
        -1.164668551292854509514809710258991891527461854347597362819235e-04,
        9.358867032006959133405013034222854399688456215297276443521873e-05,
        -1.326420289452124481243667531226683305749240960605829756400674e-05
    ];

    /**
     * Mapping of wavelet type keys to scaling numbers.
     */
    var ScalingNumbers = {
        'db1': HaarWavelet,
        'db2': Db2Wavelet,
        'db3': Db3Wavelet,
        'db4': Db4Wavelet,
        'db5': Db5Wavelet,
        'db6': Db6Wavelet,
        'db7': Db7Wavelet,
        'db8': Db8Wavelet,
        'db9': Db9Wavelet,
        'db10': Db10Wavelet,
        'D2': HaarWavelet,
        'D4': Db2Wavelet,
        'D6': Db3Wavelet,
        'D8': Db4Wavelet,
        'D10': Db5Wavelet,
        'D12': Db6Wavelet,
        'D14': Db7Wavelet,
        'D16': Db8Wavelet,
        'D18': Db9Wavelet,
        'D20': Db10Wavelet,
        'haar': HaarWavelet,
    };

    /**
     * Calculates the element-wise sum of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Element-wise sum.
     */
    function add(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate element-wise sum. */
        return a.map(function (value, index) { return value + b[index]; });
    }
    /**
     * Asserts if approximation and detail coefficients are valid or throws an
     * error if they are invalid.
     * @param  approx Approximation coefficients.
     * @param  detail Detail coefficients.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidApproxDetail(approx, detail) {
        /* Check if coefficients have equal length. */
        if (approx.length !== detail.length) {
            throw new Error('Approximation and detail coefficients must have equal length.');
        }
        /* Check for coefficients of zero length. */
        if (approx.length === 0) {
            throw new Error('Approximation and detail coefficients must not have zero length.');
        }
        return true;
    }
    /**
     * Asserts if coefficients are valid or throws an error if they are invalid.
     * @param  coeffs Coefficients to test.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidCoeffs(coeffs) {
        /* Check if at least an array of approximation coefficients is given. */
        if (coeffs.length < 1) {
            throw new Error('Invalid coefficients. Array length must not be zero.');
        }
        return true;
    }
    /**
     * Asserts if wavelet filters are valid or throws an error if they are invalid.
     * @param  filters Wavelet filters to test.
     * @return         True if the wavelet filters are valid, otherwise throws an error.
     */
    function assertValidFilters(filters) {
        /* Check if high-pass and low-pass filters have equal length. */
        if (filters.high.length !== filters.low.length) {
            throw new Error('High-pass and low-pass filters have to have equal length.');
        }
        /* Check if filter length is larger than or equal to two. */
        if (filters.low.length < 2) {
            throw new Error('Wavelet filter length has to be larger than or equal to two.');
        }
        return true;
    }
    /**
     * Determines a wavelet basis from a wavelet type or basis.
     * @param  wavelet Wavelet type or basis.
     * @return         Wavelet basis.
     */
    function basisFromWavelet(wavelet) {
        return (typeof wavelet !== 'string')
            ? wavelet
            : waveletFromScalingNumbers(ScalingNumbers[wavelet]);
    }
    /**
     * Creates an array and populates it.
     * @param  length   Length of the array.
     * @param  populate Function to populate the array.
     * @return          Populated array with specified length.
     */
    function createArray(length, populate) {
        if (populate === void 0) { populate = 0; }
        /* Check for non-integer length. */
        if (!Number.isInteger(length)) {
            throw new Error('Length has to be an integer.');
        }
        /* Check for length less than zero. */
        if (length < 0) {
            throw new Error('Length must not be smaller than zero.');
        }
        /* Create and populate array. */
        return Array.apply(null, Array(length)).map(function (_, index) {
            return (typeof populate === 'function')
                ? populate(index)
                : populate;
        });
    }
    /**
     * Calculates the dot product of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Dot product.
     */
    function dot(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate dot product. */
        return a.reduce(function (dot, value, index) { return dot + value * b[index]; }, 0);
    }
    /**
     * Multiplies an array with a scalar value.
     * @param  scalar Scalar value.
     * @param  array  Array of numbers.
     * @return        Array multiplied with scalar value.
     */
    function mulScalar(scalar, array) {
        return array.map(function (value) { return scalar * value; });
    }
    /**
     * Returns a single padding element.
     * @param  data    Input data.
     * @param  index   Index of padding element.
     * @param  inverse True if the padding direction is inversed.
     * @param  mode    Signal extension mode.
     * @return         Single padding element.
     */
    function padElement(data, index, inverse, mode) {
        switch (mode) {
            case PADDING_MODES.antisymmetric:
                return antisymmetricPadding$$1(data, index, inverse);
            case PADDING_MODES.constant:
                return constantPadding(data, inverse);
            case PADDING_MODES.periodic:
                return periodicPadding(data, index, inverse);
            case PADDING_MODES.reflect:
                return reflectPadding(data, index, inverse);
            case PADDING_MODES.smooth:
                return smoothPadding(data, index, inverse);
            case PADDING_MODES.symmetric:
                return symmetricPadding(data, index, inverse);
            case PADDING_MODES.zero:
                return zeroPadding();
            default:
                throw new Error('Unknown signal extension mode: "' + mode + '"');
        }
    }
    /**
     * Determines the padding widths.
     * @param  dataLength   Length of signal.
     * @param  filterLength Length of filter.
     * @return              Padding widths.
     */
    function padWidths(dataLength, filterLength) {
        /* Check for valid data length. */
        if (dataLength <= 0) {
            throw new Error('Cannot determine padding widths for data of length less than or equal to zero.');
        }
        /* Check for valid filter length. */
        if (filterLength < 2) {
            throw new Error('Cannot determine padding widths for filter of length less than two.');
        }
        /* Determine padding widths. */
        return [
            filterLength - 2,
            ((dataLength + filterLength) % 2 === 0)
                ? filterLength - 2
                : filterLength - 1
        ];
    }
    /**
     * Determines a wavelet basis from scaling numbers.
     * @param  scalingNumbers Wavelet scaling numbers.
     * @return                Wavelet basis.
     */
    function waveletFromScalingNumbers(scalingNumbers) {
        /* Check if length is larger than or equal to two. */
        if (scalingNumbers.length < 2) {
            throw new Error('Scaling numbers length has to be larger than or equal to two.');
        }
        /* Determine wavelet numbers. */
        var waveletNumbers = scalingNumbers.slice() // Copy array
            .reverse()
            .map(function (value, index) { return (index % 2 === 0) ? value : -value; });
        /* Determine wavelet basis. */
        return {
            dec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers
            },
            rec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers.slice()
            },
        };
    }

    /**
     * Default padding mode to use.
     */
    var DEFAULT_PADDING_MODE = PADDING_MODES.symmetric;
    /**
     * Collection of methods for Discrete Wavelet Transform (DWT).
     */
    var DiscreteWavelets = /** @class */ (function () {
        function DiscreteWavelets() {
        }
        /**
         * Single level Discrete Wavelet Transform.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @return         Approximation and detail coefficients as result of the transform.
         */
        DiscreteWavelets.dwt = function (data, wavelet, mode) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.dec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Add padding. */
            data = this.pad(data, padWidths(data.length, filterLength), mode);
            /* Initialize approximation and detail coefficients. */
            var approx = [];
            var detail = [];
            /* Calculate coefficients. */
            for (var offset = 0; offset + filterLength <= data.length; offset += 2) {
                /* Determine slice of values. */
                var values = data.slice(offset, offset + filterLength);
                /* Calculate approximation coefficients. */
                approx.push(dot(values, filters.low));
                /* Calculate detail coefficients. */
                detail.push(dot(values, filters.high));
            }
            /* Return approximation and detail coefficients. */
            return [approx, detail];
        };
        /**
         * Calculates the energy as sum of squares of an array of data or
         * coefficients.
         * @param  values Array of data or coefficients.
         * @return        Energy of values as the sum of squares.
         */
        DiscreteWavelets.energy = function (values) {
            var energy = 0;
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var value = values_1[_i];
                if (!Array.isArray(value))
                    energy += Math.pow(value, 2);
                else
                    energy += this.energy(value);
            }
            return energy;
        };
        /**
         * Single level inverse Discrete Wavelet Transform.
         * @param  approx  Approximation coefficients. If undefined, it will be set to an array of zeros with length equal to the detail coefficients.
         * @param  detail  Detail coefficients. If undefined, it will be set to an array of zeros with length equal to the approximation coefficients.
         * @param  wavelet Wavelet to use.
         * @return         Approximation coefficients of previous level of transform.
         */
        DiscreteWavelets.idwt = function (approx, detail, wavelet) {
            /* Fill empty array with zeros. */
            if (approx === undefined && detail !== undefined) {
                approx = createArray(detail.length, 0);
            }
            if (detail === undefined && approx !== undefined) {
                detail = createArray(approx.length, 0);
            }
            /* Check if some coefficients are undefined. */
            if (approx === undefined || detail === undefined) {
                throw new Error('Coefficients must not be undefined.');
            }
            assertValidApproxDetail(approx, detail);
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.rec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Initialize transform. */
            var coeffLength = approx.length;
            var pad = createArray(filterLength + (coeffLength - 1) * 2, 0);
            /* Perform inverse Discrete Wavelet Transform. */
            for (var i = 0; i < coeffLength; i++) {
                var offset = 2 * i;
                /* Calculate values. */
                var values = pad.slice(offset, offset + filterLength);
                values = add(values, mulScalar(approx[i], filters.low));
                values = add(values, mulScalar(detail[i], filters.high));
                /* Update values. */
                pad.splice.apply(pad, __spreadArrays([offset, filterLength], values));
            }
            /* Remove padding. */
            return pad.slice(filterLength - 2, pad.length - (filterLength - 2));
        };
        /**
         * Determines the maximum level of useful decomposition.
         * @param  dataLength Length of input data.
         * @param  wavelet    Wavelet to use.
         * @return            Maximum useful level of decomposition.
         */
        DiscreteWavelets.maxLevel = function (dataLength, wavelet) {
            /* Check for non-integer length. */
            if (!Number.isInteger(dataLength)) {
                throw new Error('Length of data is not an integer. This is not allowed.');
            }
            /* Check for invalid input. */
            if (dataLength < 0) {
                throw new Error('Data length cannot be less than zero.');
            }
            /* Return zero for data of zero length. */
            if (dataLength === 0)
                return 0;
            /* Determine wavelet basis. */
            var waveletBasis = basisFromWavelet(wavelet);
            /* Determine length of filter. */
            var filterLength = waveletBasis.dec.low.length;
            // SOURCE: https://pywavelets.readthedocs.io/en/latest/ref/dwt-discrete-wavelet-transform.html#maximum-decomposition-level-dwt-max-level-dwtn-max-level
            return Math.max(0, Math.floor(Math.log2(dataLength / (filterLength - 1))));
        };
        /**
         * Extends a signal with a given padding mode.
         * @param  data      Input data.
         * @param  padWidths Widths of padding at front and back.
         * @param  mode      Signal extension mode.
         * @return           Data with padding.
         */
        DiscreteWavelets.pad = function (data, padWidths$$1, mode) {
            /* Check for undefined data. */
            if (!data) {
                throw new Error('Cannot add padding to empty data.');
            }
            /* Initialize. */
            var front = padWidths$$1[0];
            var back = padWidths$$1[1];
            /* Add padding. */
            return createArray(front, function (index) {
                return padElement(data, (front - 1 - index), true, mode);
            })
                .concat(data)
                .concat(createArray(back, function (index) {
                return padElement(data, index, false, mode);
            }));
        };
        
        /**
         *  Expand each row of the data matrix (returned, e.g., by wavedec) with respect
         *  to the widest row. Mode specifies the interpolation function (default: 'step').
         */
        DiscreteWavelets.expand = function (data, mode) {
          var len=0,dataX=[];
          for(var row in data) len=Math.max(len,data[row].length); 
          switch (mode) {
            case 'step':
            default:
              // simple; extend each data point
              for(row in data) {
                if (data[row].length!=len) {
                  var frag=Math.floor(len/data[row].length);
                  dataX[row]=[];
                  for(var col=0; col < data[row].length; col++) {
                    dataX[row].push(Array.init(frag,data[row][col]));
                  }
                  dataX[row]=dataX[row].flat();
                } else dataX.push(data[row]);
              }
          }
          return dataX;
        };
        
        /**
         * 1D wavelet decomposition. Transforms data by calculating multi-level coefficients from
         * input data.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @param  level   Decomposition level. Defaults to level calculated by maxLevel function.
         * @return         Coefficients as result of the transform.
         */
        DiscreteWavelets.wavedec = function (data, wavelet, mode, level) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine decomposition level. */
            if (level === undefined)
                level = this.maxLevel(data.length, wavelet);
            if (level < 0) {
                throw new Error('Decomposition level must not be less than zero');
            }
            /*  Initialize transform. */
            var coeffs = [];
            var approx = data;
            /* Transform. */
            for (var l = 1; l <= level; l++) {
                /* Perform single level transform. */
                var approxDetail = this.dwt(approx, wavelet, mode);
                approx = approxDetail[0];
                var detail = approxDetail[1];
                /* Prepend detail coefficients. */
                coeffs.unshift(detail);
            }
            /* Prepend last approximation. */
            // coeffs.unshift(approx);
            /* Return coefficients. */
            return coeffs.reverse();
        };
        /**
         * 1D wavelet reconstruction. Inverses a transform by calculating input data
         * from coefficients.
         * @param  coeffs  Coefficients as result of a transform.
         * @param  wavelet Wavelet to use.
         * @return         Input data as result of the inverse transform.
         */
        DiscreteWavelets.waverec = function (coeffs, wavelet) {
            /* Check if coefficients are valid. */
            assertValidCoeffs(coeffs);
            /* Determine wavelet. */
            wavelet = basisFromWavelet(wavelet);
            /* Initialize transform. */
            var approx = coeffs[0];
            /* Transform. */
            for (var i = 1; i < coeffs.length; i++) {
                /* Initialize detail coefficients. */
                var detail = coeffs[i];
                // TODO: Check if problem of different coefficient lengths because of padding can be solved in a more elegant way.
                if (approx.length === detail.length + 1) {
                    approx = approx.slice(0, approx.length - 1);
                }
                /* Calculate previous level of approximation. */
                approx = this.idwt(approx, detail, wavelet);
            }
            /* Return data. */
            return approx;
        };
        /**
         * Contains static information about the signal extension modes.
         */
        DiscreteWavelets.Modes = PADDING_MODES;
        return DiscreteWavelets;
    }());

    return DiscreteWavelets;

})));
//# sourceMappingURL=discrete-wavelets.umd.js.map
};
BundleModuleCode['plugins/math/numeric']=function (module,exports,global,process){
// https://github.com/sloisel/numeric

"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
};
BundleModuleCode['plugins/math/regression']=function (module,exports,global,process){
// https://github.com/Tom-Alexander/regression-js
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.regression = mod.exports;
  }
})(this, function (module) {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

  /**
  * Determine the coefficient of determination (r^2) of a fit from the observations
  * and predictions.
  *
  * @param {Array<Array<number>>} data - Pairs of observed x-y values
  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
  *
  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
  */
  function determinationCoefficient(data, results) {
    var predictions = [];
    var observations = [];

    data.forEach(function (d, i) {
      if (d[1] !== null) {
        observations.push(d);
        predictions.push(results[i]);
      }
    });

    var sum = observations.reduce(function (a, observation) {
      return a + observation[1];
    }, 0);
    var mean = sum / observations.length;

    var ssyy = observations.reduce(function (a, observation) {
      var difference = observation[1] - mean;
      return a + difference * difference;
    }, 0);

    var sse = observations.reduce(function (accum, observation, index) {
      var prediction = predictions[index];
      var residual = observation[1] - prediction[1];
      return accum + residual * residual;
    }, 0);

    return 1 - sse / ssyy;
  }

  /**
  * Determine the solution of a system of linear equations A * x = b using
  * Gaussian elimination.
  *
  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
  * @param {number} order - How many degrees to solve for
  *
  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
  */
  function gaussianElimination(input, order) {
    var matrix = input;
    var n = input.length - 1;
    var coefficients = [order];

    for (var i = 0; i < n; i++) {
      var maxrow = i;
      for (var j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (var k = i; k < n + 1; k++) {
        var tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (var _j = i + 1; _j < n; _j++) {
        for (var _k = n; _k >= i; _k--) {
          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
        }
      }
    }

    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
      var total = 0;
      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
        total += matrix[_k2][_j2] * coefficients[_k2];
      }

      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
    }

    return coefficients;
  }

  /**
  * Round a number to a precision, specificed in number of decimal places
  *
  * @param {number} number - The number to round
  * @param {number} precision - The number of decimal places to round to:
  *                             > 0 means decimals, < 0 means powers of 10
  *
  *
  * @return {numbr} - The number, rounded
  */
  function round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
  * The set of all fitting methods
  *
  * @namespace
  */
  var methods = {
    linear: function linear(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = 0;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          len++;
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      var run = len * sum[2] - sum[0] * sum[0];
      var rise = len * sum[3] - sum[0] * sum[1];
      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [gradient, intercept],
        r2: round(determinationCoefficient(data, points), options.precision),
        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
      };
    },
    exponential: function exponential(data, options) {
      var sum = [0, 0, 0, 0, 0, 0];

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
      var coeffA = round(a, options.precision);
      var coeffB = round(b, options.precision);
      var predict = function predict(x) {
        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    logarithmic: function logarithmic(data, options) {
      var sum = [0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      var coeffB = round(a, options.precision);
      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    power: function power(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
      var a = (sum[2] - b * sum[0]) / len;
      var coeffA = round(Math.exp(a), options.precision);
      var coeffB = round(b, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'x^' + coeffB,
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    polynomial: function polynomial(data, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var len = data.length;
      var k = options.order + 1;

      for (var i = 0; i < k; i++) {
        for (var l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        var c = [];
        for (var j = 0; j < k; j++) {
          for (var _l = 0; _l < len; _l++) {
            if (data[_l][1] !== null) {
              b += Math.pow(data[_l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      var coefficients = gaussianElimination(rhs, k).map(function (v) {
        return round(v, options.precision);
      });

      var predict = function predict(x) {
        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      var string = [];
      for (var _i = 0; _i <coefficients.length; _i++) {
        if (_i > 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*Math.pow(x,' + _i + '))');
        } else if (_i === 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*x)');
        } else if (coefficients[_i] !== 0) {
          string.push('('+coefficients[_i]+')');
        }
      }
      string=string.join('+');

      return {
        string: string,
        points: points,
        predict: predict,
        equation: [].concat(_toConsumableArray(coefficients)),
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    }
  };

  function createWrapper() {
    var reduce = function reduce(accumulator, name) {
      return _extends({
        _round: round
      }, accumulator, _defineProperty({}, name, function (data, supplied) {
        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
      }));
    };

    return Object.keys(methods).reduce(reduce, {});
  }

  module.exports = createWrapper();
});
};
BundleModuleCode['plugins/math/polyfit']=function (module,exports,global,process){
// Requirement: https://github.com/sloisel/numeric/blob/master/src/numeric.js

var numeric = Require('plugins/math/numeric')

// Find the best-fit curve for an nth order polynomial.
function polyfit(xArray, yArray, order) {

  if (xArray.length <= order) console.warn("Warning: Polyfit may be poorly conditioned.")

  var xMatrix = []
  var yMatrix = numeric.transpose([yArray])

  for (var i = 0; i < xArray.length; i++) {

    var temp = []

    for (var j = 0; j <= order; j++) {

      temp.push(Math.pow(xArray[i], j))

    }

    xMatrix.push(temp)

  }

  var xMatrixT = numeric.transpose(xMatrix)

  var dot1 = numeric.dot(xMatrixT, xMatrix)
  var dot2 = numeric.dot(xMatrixT, yMatrix)

  var dotInv = numeric.inv(dot1)

  var coefficients = numeric.dot(dotInv, dot2)

  return coefficients.unwrap().reverse()

}

// Predict y given x.
function predict(x, coefficients) {

  var prediction = 0

  for (var i = 0; i < coefficients.length; i++) {

    prediction += coefficients[i] * Math.pow(x, i)

  }

  return prediction

}

// Evaluate model accuracy.
function rSquared(x, y, coefficients) {

  var regressionSquaredError = 0
  var totalSquaredError = 0

  var yMean = y.reduce((a, b) => a + b) / y.length

  for (var i = 0; i < x.length; i++) {

    regressionSquaredError += Math.pow(y[i] - predict(x[i], coefficients), 2)
    totalSquaredError += Math.pow(y[i] - yMean, 2)

  }

  return 1 - (regressionSquaredError / totalSquaredError)

}

module.exports = polyfit
};
BundleModuleCode['plugins/math/smoothers']=function (module,exports,global,process){
/*********************/
/* Helper Functions. */
/* http://madrury.github.io/smoothers */
/*********************/
var numeric = Require('plugins/math/numeric')

/* Compute the dot product of two vectors. */
var dot = function(v1, v2) {
    var s = 0;
    for(var i = 0; i < v1.length; i++) {
        s += v1[i] * v2[i];
    }
    return s
}

/* Construct a linear function given a slope and an intercept. */
var linear_function = function(m, b) {
    return function(x) {
        return b + m * x;
    }
}

/* Compute the weighted mean of x with weights w.  Weights may be
   un-normalized.
*/
var wmean = function(x, w) {
    var r = [];
    for(i = 0; i < x.length; i++) {
        r.push(x[i]*w[i]);
    }
    return r.sum() / w.sum();
}

/* The sum of squared errors of a data set when making a prediction equal
   to the mean.
*/
var sum_of_squared_errors = function(xs) {
    return xs.map(x => x - xs.mean()).map(x => x*x).reduce((a, b) => a + b, 0);
}

/* Fit a simple linear regression on data (ys, xs).

   This returns a linear function, i.e. the prediction function from the
   fit linear regression.
*/
var linear_regressor = function(xs, ys) {
    var xmean = xs.mean();
    var ymean = ys.mean();
    var xymean = (Math.zip(xs, ys).map(p => p[0]*p[1])).mean();
    var xsqmean = (Math.zip(xs, xs).map(p => p[0]*p[1])).mean();
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var intercept = ymean - beta * xmean;
    return linear_function(beta, intercept);
};

/* Simple linear regression with sample weights. */
var weighted_linear_regressor = function(xs, ys, ws) {
    var xmean = wmean(xs, ws);
    var ymean = wmean(ys, ws);
    var xymean = wmean(Math.zip(xs, ys).map(p => p[0]*p[1]), ws);
    var xsqmean = wmean(Math.zip(xs, xs).map(p => p[0]*p[1]), ws);
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var betaz = ymean - beta * xmean;
    return linear_function(beta, betaz)
};

/* Given a function from numbers to numbers, return one that maps arrays to
   arrays through mapping.
*/
var vectorize = function(f) {
    return function(arr) {
        return arr.map(f)
    }
}

/* Undo a zip operation */
var unzip = function(ps, i) {
    return ps.map(p => p[i]);
}

/* Sort ordered pairs of x, y data by x. */
var sort_data = function(xs, ys) {
    var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
    var xsort = unzip(psort, 0);
    var ysort = unzip(psort, 1);
    return [xsort, ysort];
}


/*******************************************/
/* Ridge Regression with Basis Expansions. */
/*******************************************/

/* Fit a ridge regression to data X and response ys with regularization
   strength lambda.

   This returns an object containing the data needed to score the fitted
   regression:
   
   {
       "betas": <array of standardized parameter estiamtes>,
       "Xsd": <standardizer data for X>,
       "ysd": <standardizer data for y>
   }
*/
var fit_ridge_regression = function(X, ys, lambda) {
    /* Construct a square matrix of size n with lambdas along the main
       diagonal, and a zero in the (0, 0) position.  This type of matrix is
       useful in ridge regression.
    */
    var make_ridge_shrinkage_matrix = function(n, lambda) {
        var shrink_matrix = numeric.diag(numeric.rep([n + 1], lambda));
        /* Dont shrink the linear term in basis expansion regressions. */
        shrink_matrix[0][0] = 0;
        return shrink_matrix
    }

    /* Compute the translation and scale factors necessary to standardize the
      columns of a matrix.

      This returns an object with two attributes:

      { "mean": [<array of translation factors>],
        "sd": [<array of scale factors>] }
    */
    var compute_matrix_standardization = function(X) {
        var standardization = {"mean": [], "sd": []};
        /* It is easier to iterate over the rows of a matrix than the columns. */
        var Xt = numeric.transpose(X);
        for(var i = 0; i < Xt.length; i++) {
            var standardized_row = compute_vector_standardization(Xt[i]);
            standardization.mean.push(standardized_row.mean);
            standardization.sd.push(standardized_row.sd);
        }
        return standardization;
    }

    /* Compute the translation and scale factor necessary to standardize a
      vector.

      This returns an object with two attributes:

      {"mean": <mean of vector>, "sd": <standard deviation of vector>}
    */
    var compute_vector_standardization = function(v) {
        var mean = v.mean();
        var sd = Math.deviation(v);
        return {'mean': mean, 'sd': sd}
    }

    var X_standardization = compute_matrix_standardization(X);
    var Xsd = standardize_matrix(X, X_standardization);
    var y_standardization = compute_vector_standardization(ys);
    var ysd = standardize_vector(ys, y_standardization);
    // Compute the regression.
    var Xsdt = numeric.transpose(Xsd);
    var XtX = numeric.dot(Xsdt, Xsd);
    var Xty = numeric.dot(Xsdt, ysd);
    var shrink_matrix = make_ridge_shrinkage_matrix(X[0].length, lambda);
    var betas = numeric.solve(numeric.add(XtX, shrink_matrix), Xty);

    return {
        "betas": betas,
        "Xsd": X_standardization,
        "ysd": y_standardization
    }
}

/* Apply standardization data to a matrix.  Returns a standardized version
   of the matrix, i.e. a matrix with standardized columns.
*/
var standardize_matrix = function(X, standardization) {
    /* It is easier to iterate over the rows of a matrix than the columns. */
    var Xt = numeric.transpose(X);
    var S = []
    for(var i = 0; i < Xt.length; i++) {
        var row_standardization = {
            "mean": standardization.mean[i],
            "sd": standardization.sd[i]
        };
        var standardized_row = standardize_vector(Xt[i], row_standardization);
        S.push(standardized_row);
    }
    return numeric.transpose(S);
}

/* Apply standardization data to a vector. */
var standardize_vector = function(v, standardization) {
    return v.map(x => (x - standardization.mean) / standardization.sd)
}


/* Basies for fitting basis expansion models. 

   A basis is a linearly independent sequence of functions [f_1, f_2, ..., f_k].
   A basis expansion is a transformation of a vector v into a matrix..  The
   columns of the basis expanded matrix are created by mapping each of the
   functions in the basis expansion over the vector in turn.
*/
var basies = {

    /* Polynomial basis expansion.

         x -> [1, x, x^2, ...]
    */
    polynomial_basis: function(d) {
        var basis = [];
        function push(i) {
          basis.push(function (x) { return  Math.pow(x, i) })
        }
        for(var i = 1; i <= d; i++) {
          push(i)
        }
        return basis;
    },

    /* Piecewise linear spline basis.

       This basis depends on a sequence of knots: k_1, k_2, ...
       The basis expansion is given by the sequence of functions
       x -> max(0, x - k_i).

       Models fit using a PL basis expansion as predictors result in piecewise
       linear prediction functions.
    */
    pl_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        function push(i) {
          basis.push(function (x) { return  Math.max(x - knots[i], 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis;
    },

    /* Quadratic spline basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a quadratic spline basis expansion as predictors reult
       in a peicewise quadratic prediction function.
    */ 
    quadratic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        function push(i) {
          basis.push(function (x) { return  Math.pow(x - knots[i], 2)*((x - knots[i]) >= 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a cubic spline basis expansion as predictors reult
       in a peicewise cubic prediction function.
    */ 
    cubic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        basis.push(x => x*x*x);
        function push(i) {
          basis.push(function (x) { return  Math.max(Math.pow(x - knots[i], 3), 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Natural cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a natural cubic spline basis expansion as predictors
       reult in a peicewise cubic prediction function, but with the extra
       feature that the function is linear outside of the leftmost and
       rightmost knots.
    */ 
    natural_cubic_spline_basis: function(knots) {
        n_knots = knots.length;
        var basis = [];
        basis.push(x => x);
        var ppart = (t => Math.max(t, 0))
        var cube = (t => t*t*t);
        var d = function(knot_idx) {
            return function(x) {
                return (
                    // Sure would be nice if this was scheme.
                    (cube(ppart(x - knots[knot_idx], 0)) 
                        - cube(ppart(x - knots[n_knots - 1], 0)))
                    / (knots[n_knots - 1] - knots[knot_idx]));
            };
        };
        function push(k) {
          basis.push(function (x) { return  d(k)(x) - d(n_knots - 2)(x) })
        }
        for(var k = 0; k < n_knots - 2; k++) {
          push(k)
        }
        return basis
    }
}

/* Construct a regression operator given a basis of functions, and a
   regularization strength.

   This constructs a function witht he following signature:
       (xs, ys) => (x => _)
   I.e. a function that consumes data, and returns a prediction function.
   The prediction function is constructed by fitting a ridge regression
   on the data (xs, ys) after applying the given basis expansion.
*/
var make_basis_expansion_regression = function(basis, lambda) {
    /* Map a basis expansion across a vector. The result is a vector. */
    var evaluate_basis_expansion = function(basis, xs) {
        return xs.map(x => basis.map(s => s(x)))
    }

    return function(xs, ys) {
        var X = evaluate_basis_expansion(basis, xs);
        var ridge = fit_ridge_regression(X, ys, lambda);
        var smooth_value = function(newx) {
            // There is a small hack here.  After getting the basis
            // expansion, we have a vector.  We immediately wrap this in a
            // list, creating a one row matrix.  This allows us to use
            // standardize_matrix, avoiding duplication of some logic.
            var basis_expansion = [basis.map(s => s(newx))]
            var standardized_basis_expansion = 
                standardize_matrix(basis_expansion, ridge.Xsd)[0];

            return (
                numeric.dot(ridge.betas, standardized_basis_expansion) * ridge.ysd.sd
                + ridge.ysd.mean); 
        }
        return Object.assign(vectorize(smooth_value),{parameter:ridge});
    };
}

/* Consume a basis expansion representing a spline basis, and return a function
   that consumes a object of parameters (the only parameter being the number of
   knots), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_spline_regression = function(spline_basis_function) {

    return function(parameters) {
        var n = Number(parameters["n"]);
        var knots = make_knots(n);
        var sp = spline_basis_function(knots);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(sp, lambda);
    }
}

/* Make a set of equally spaced knots in the interval [0, 1] */
var make_knots = function(n) {
    return numeric.linspace(0, 1, n + 2).slice(1, n + 1);
}

/* Consume a basis expansion representing a polynomial basis, and return a
   function that consumes a object of parameters (the only parameter being the
   degree), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_polynomial_regression = function(polynomial_basis_function) {
    return function(parameters) {
        var d = Number(parameters["degree"]);
        var p = polynomial_basis_function(d);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(p, lambda);
    }
}


/********************/
/* Regression Trees */
/********************/

/* Construct a function that fits regression trees of a specified depth.

   Returns a function ((xs, ys) => (x => _)) that fits a regression tree
   to the supplied xs, ys data.
*/
var make_regression_tree = function(parameters) {
    var depth = Number(parameters["depth"]);
    return function(xs, ys) {
        /* We sort the data once up front, it will stay sorted as we
           decend the tree.
        */
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var tree = fit_regression_tree(xsorted, ysorted, depth);
        var regression_tree_predict_pointwise = function(x) {
            return score_regression_tree(x, tree);
        }
        var fs = vectorize(regression_tree_predict_pointwise);
        fs.tree=tree;
        return fs;
    }
}

/* Fit a regression tree to data of a specified depth.

   Returns a simple object (informally of type tree) representing a fit
   regression tree.  A tree object has the following shape.

    {
        "is_leaf": <boolean: is this tree a lead node?>,
        "value": <float: The value to predict in this node, if a leaf>,
        "left_child_condition": <function: f(x) answers "is x in the reigon
                                 defined by the left child node>
        "left_child": <tree: A fit regression tree to those xs, ys in the left
                       child>,
        "right_child": <tree: A fit regression tree to those xs, ys in the
                        right child>,
    }

    The field "value" is only defined for leaf nodes.  The fields
    "left_child_condition", "left_child", and "right_child" are only defined if
    *not* a lead node.
*/
var fit_regression_tree = function(xs, ys, depth) {
    if(depth === 0 || ys.length <= 1) {
        /* Base case step. */
        var tree = make_tree_object();
        tree.is_leaf = true;
        tree.value = ys.mean();
        return tree;
    } else {
        /* Recursive step. */
        var split = compute_split_point(xs, ys);
        var condition = function(x) {return x <= split}
        var ps = Math.zip(xs, ys);
        var left_data = ps.filter(p => condition(p[0]));
        var right_data = ps.filter(p => !condition(p[0]));
        /* Construct and return the tree */
        var tree = make_tree_object();
        tree.left_child_condition = condition;
        tree.left_child = fit_regression_tree(
            unzip(left_data, 0), unzip(left_data, 1), depth - 1);
        tree.right_child = fit_regression_tree(
            unzip(right_data, 0), unzip(right_data, 1), depth - 1);
        return tree;
    }
}


/* Construct an empty tree object. */
var make_tree_object = function() {
    return {
        "is_leaf": false,
        "left_child_condition": null,
        "left_child": null,
        "right_child": null,
        "value": null
    }
}

/* Compute the optimal split point in data xs, ys.

   The split point is the midpoint between two data points, so that grouping
   the ys data into those left of and right of the split point produces the
   least total varaince.

   Note: This function assumes that the xs, ys data is sorted in increasing
         xs order.
*/
var compute_split_point = function(xs, ys) {
    var best_sosd = Infinity;
    var best_split = null;
    for(var i = 1; i <= ys.length - 1; i++) {
        var left_ys = ys.slice(0, i);
        var right_ys = ys.slice(i, ys.length);
        var this_sosd = sum_of_squared_errors(left_ys) + 
                        sum_of_squared_errors(right_ys);
        if(this_sosd <= best_sosd) {
            best_sosd  = this_sosd;
            best_split = (xs[i-1] + xs[i]) / 2;
        }
    }
    return best_split;
}

/* Generate a predictor from a regression tree at a point x */
var score_regression_tree = function(x, tree) {
    if(tree.is_leaf == true) {
        return tree.value;
    } else {
        if(tree.left_child_condition(x)) {
            return score_regression_tree(x, tree.left_child);
        } else {
            return score_regression_tree(x, tree.right_child);
        }
    }
}


/*********************/
/* Gradient Boosting */
/*********************/

/* Construct a function that fits a gradient boosted regression.

   Returns a function ((xs, ys) => (x => _)) that fits a gradient booster
   to the supplied xs, ys data.
*/
var make_boosted_model = function(parameters) {
    var learning_rate = Number(parameters["learning_rate"]);
    var n_trees = Number(parameters["n_trees"]);
    var tree_depth = Number(parameters["tree_depth"]);
    return function(xs, ys) {
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var booster = fit_boosted_model(xs, ys, n_trees, learning_rate, tree_depth);
        var boosted_model_predict_pointwise = function(x) {
            return score_boosted_model(x, booster);
        }
        return vectorize(boosted_model_predict_pointwise);
    }
}

/* Fit a gradient boosted regression to data of a specified depth.

   Returns a simple object (informally of type booster) representing a fit
   boosted model.  A booster object has the following shape.

   {
       "intercept": <The mean of the training data, used as the 0'th
                     boosting stage>,
       "trees": [<Array of tree objects, the boosting stages>],
       "learning_rate": <The learning rate of the boosted model>
   }
*/
var fit_boosted_model = function(xs, ys, n_trees, learning_rate, tree_depth) {
    var boosted_model = new_boosted_model();
    boosted_model.learning_rate = learning_rate;
    var working_ys = ys.slice(); // Copy.
    /* Fit the first stage */
    boosted_model.intercept = ys.mean();
    working_ys = working_ys.map(y => y - boosted_model.intercept);
    /* Boost */
    for(var i = 0; i <= n_trees; i++) {
        var tree = fit_regression_tree(xs, working_ys, tree_depth);
        working_ys = 
            Math.zip(xs, working_ys)
              .map(p => p[1] - learning_rate * score_regression_tree(p[0], tree));
        boosted_model.trees.push(tree);
    }
    return boosted_model;
}

/* Construct a booster object. */
var new_boosted_model = function() {
    return {"intercept": null, "trees": [], "learning_rate": null};
}

/* Make predictions on a new datapoint from a booster object. */
var score_boosted_model = function(x, booster) {
    var y_hat = booster.intercept;
    for(var i = 0; i < booster.trees.length; i++) {
        y_hat += booster.learning_rate * score_regression_tree(x, booster.trees[i]);
    }
    return y_hat;
}

/************************/
/* Smoothing Algorithms */
/************************/

/* A namespace for scatterplot smoother objects.

  Each smoother object has three attributes:

    - label: A short description of the smoother.  Appears in a select input
      field.
    - smoother: A smoother function.  Each smoother function has the form

          parameters => ((xs, ys) => (x => _))

      where parameters is a dictionary containing the values of huperparameters
      for the smoother, and xs, ys are equal length vectors of x-coordinates
      and y-coordinates of data points to be smoothed.
    - parameters: Configuration objects for hyperparameters.  These are used
      to populate input slider elements in the user interface.
*/
var smoothers = {

    /* Trivial global mean smoother.

    Simply return the mean of the y values as the smoothed data.

    Hyperparamters: None
    */
    "smooth-type-mean": {

        "label": "Constant Mean",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var mean = ys.mean();
                return vectorize(x => mean)
            }
        },

        "parameters": []
    },

    /* Running mean smoother. 

    The smoothed value y at a given x is the mean value of the y data for
    those data with the closest k x data.

    Hyperparameters:
        k: Number of data points included in each side of the symmetric nbhd.
    */
    "smooth-type-runmean": {

        "label": "Running Mean",
    
        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var xysorted = sort_data(xs, ys), xsort = xysorted[0], ysort = xysorted[1];
                var mean_of_symm_nbrd = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length - 1, pos_in_array + k)
                    ];
                    return (ysort.slice(cutoffs[0], cutoffs[1])).mean();
                };
                return vectorize(mean_of_symm_nbrd);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 1, "max": 20, "step": 1, "default": 2}
        ]
    },

    /* Simple linear regression smoother. 
    
    Hyperparameters:
        None.
    */
    "smooth-type-linreg": {

        "label": "Linear Regression",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var linreg = linear_regressor(xs, ys);
                return vectorize(linreg);
            };
        },

        "parameters": []

    },

    /* Gaussian kernel smoother.

    Hyperparmeters:
        lambda: Width of the gaussian kernel.
    */
    "smooth-type-gaussk": {

        "label": "Gaussian Kernel Smoother",

        "smoother": function(parameters) {
            var lambda = Number(parameters["lambda"]);
            return function(xs, ys) {
                var gauss_kern_smooth = function(x) {
                    var ds = xs.map(function(xi) {return x - xi;});
                    var ws = ds.map(function(di) {return Math.exp(-di*di/lambda);});
                    var normc = ws.sum(); 
                    var normws = ws.map(function(wi) {return wi / normc;});
                    return (Math.zip(normws, ys).map(function(p) {return p[0]*p[1]})).sum();
                };
                return vectorize(gauss_kern_smooth)
            };
        },

        "parameters": [
            {"label": "Width of Kernel", "name": "lambda",
             "min": .001, "max": .05, "step": .001, "default": .01}
        ]

    },

    /* Running line smoother.

       To calculate the smoothed value of y at a given x, we first take
       together the k data points closest to x.  Then fit a simple linear
       regression to these k data points.  The smoothed value of y is the value
       f(x), where f is the prediction function of this linear regression.

    Hyperparameters:
        k: The number of neighbours to consider when fitting the local linear
           regressions.
    */
    "smooth-type-runline": {

        "label": "Running Line",

        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
                var xsort = psort.map(function(p) {return p[0]});
                var ysort = psort.map(function(p) {return p[1]});
                var loc_lin_approx = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    // TODO: Check that you lined up the fenceposts.
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length, pos_in_array + k)
                    ];
                    var locx =  xsort.slice(cutoffs[0], cutoffs[1]);
                    var locy =  ysort.slice(cutoffs[0], cutoffs[1]);
                    return linear_regressor(locx, locy)(newx);
                }
                return vectorize(loc_lin_approx);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 2, "max": 20, "step": 1, "default": 2}
        ]

    },

    /* Ridge regression with a polynomial basis expansion.

    Hyperparameters:
        degree: The maximum degree of polynomial in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-polyreg": {
    
        "label": "Polynomial Ridge Regression",

        "smoother": make_polynomial_regression(basies.polynomial_basis),

        "parameters": [
            {"label": "Polynomial Degree", "name": "degree",
             "min": 1, "max": 20, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ]

    },

    /* Ridge regression with a piecewise linear basis expansion.

    Hyperparameters:
        n: The number of knots to use in the PL basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-pl": {

        "label": "Piecewise Linear Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.pl_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .1, "step": .0001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise quadratic basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
     */
    "smooth-type-quad": {

        "label": "Quadratic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.quadratic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise cubic (unrestricted) basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-spline": {

        "label": "Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a natural cubic spline basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-natural-spline": {

        "label": "Natural Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.natural_cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 3},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Regression tree smoother.

    Hyperparameters:
        depth: The maximum depth in the fit tree.  The final tree has 2**depth
               leaf nodes.
    */
    "smooth-type-regression-tree": {
    
        "label": "Regression Tree",

        "smoother": make_regression_tree,

        "parameters": [
            {"label": "Maximum Tree Depth", "name": "depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },

    /* Gradient boosting to minimize the sum of squared errors.

    Hyperparameters:
        n_trees: The number of boosting stages.
        learning_rate: Learning rate.
        tree_depth: The maximum depth of the individual trees.
    */
    "smooth-type-boosting": {
    
        "label": "Gradient Boosting Regression",

        "smoother": make_boosted_model,

        "parameters": [
            {"label": "Number of Boosting Stages", "name": "n_trees",
             "min": 0, "max": 250, "step": 1, "default": 5},
            {"label": "Learning Rate", "name": "learning_rate",
             "min": 0, "max": 1, "step": 0.01, "default": 0.05},
            {"label": "Maximum Tree Depth", "name": "tree_depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },
/*
    // Locally weighted linear regression smoother.
    "smooth-type-loess": function(xs, ys) {
        var k = 5
        var loess = function(x) {
            // Sort by increasing absolute distance from x.
            var psort = d3.zip(xs, ys).sort(function(a, b) {
                return Math.abs(x - a[0]) - Math.abs(x - b[0])}
            );
            var xsort = psort.map(function(p) {return p[0]}).slice(0, 7);
            var ysort = psort.map(function(p) {return p[1]}).slice(0, 7);
            var nearest_nbrs = psort.slice(0, 7);
            var ds = nearest_nbrs.map(function(p) {return Math.abs(p[0] - x)});
            var dsmax = d3.max(ds);
            var ws = ds.map(function(d) {
                return Math.pow(1 - d*d*d, 3) / (dsmax * dsmax * dsmax)
            });
            return weighted_linear_regressor(xsort, ysort, ws)(x);
        };
        return vectorize(loess)
    },
*/
};

// fourier-polynomial.js
//
// A class modeling a fourier polynomial (finite degree).

var FourierPolynomial = function(cs) {
  
  var _coefs = cs

  return {
  
    get degree() {
      return _coefs.length - 1
    },

    // The maximum possible value obtained by the polynomial
    get pmax() {
      var s, i
      s = 0
      for(i = 0; i < _coefs.length; i++) {
        s += Math.abs(_coefs[i])
      }
      return s
    },

    // Evaluate the polynomial at a number after shifting by a given 
    // phase.
    _eval: function(x, phase) {
      var acc, i
      phase = phase || 0
      acc = 0
      for(i = 0; i <= this.degree; i++) {
        acc += _coefs[i] * Math.sin(2 * i * Math.PI * (x - phase))
      }
      return acc
    },

    // Evaluate teh polynomial at an array after shifting a given 
    // pahse.
    eval: function(xs, phase) {
      that = this
      var ys = xs.map(function(x) {return that._eval(x, phase)})
      that = null // Destruct
      return ys
    },

  }
}

var _runif = function(low, high) {
    return (high - low) * Math.random() + low
}

var randomPolynomial = function(degree) {
    var coefs = []
    for(var i = 0; i <= degree; i++) {
        coefs.push(_runif(-1, 1))
    }
    //coefs = coefs.sort(function(a, b) {return b - a})
    console.log(coefs)
    return new FourierPolynomial(coefs)
}

module.exports = smoothers;

};
BundleModuleCode['plugins/ml/reg']=function (module,exports,global,process){
/* https://github.com/chen0040/js-regression */
var jsregression = jsregression || {};

(function (jsr) {
    'use strict';
	var LinearRegression = function (config) {
        config = config || {};
        
        if (!config.iterations) {
            config.iterations = 1000;
        }
        if (!config.alpha) {
            config.alpha = 0.001;
        }
        if (!config.lambda) {
            config.lambda = 0.0;
        }
        if(!config.trace) {
            config.trace = false;
        }
        
        this.iterations = config.iterations;
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.costThres = config.cost||0;
        this.errorThres = config.error||0;
        this.trace = config.trace;
        this.dynamic = config.dynamic;  // dynamic alpha rate
    };
    
    LinearRegression.prototype.fit = function (data) {
        var N = data.length, X = [], Y = [];
        this.dim = data[0].length;

    
        for (var i=0; i < N; ++i) {
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j) {
                x_i.push(row[j]);
            }
            Y.push(y_i);
            X.push(x_i);
        }
        
        this.theta = [];
        
        for (var d = 0; d < this.dim; ++d) {
            this.theta.push(0.0);
        }
        
        var cost,lastCost=0, lastVx, lastTheta, alpha=this.alpha;
        for (var k = 0; k < this.iterations; ++k) {
            var Vx = this.grad(X, Y, this.theta);
            
            for(var d = 0; d < this.dim; ++d) {
                this.theta[d] = this.theta[d] - alpha * Vx[d];
                if (isNaN(this.theta[d])) 
                 throw Error ('LinearRegression.fit: parameter overflow, probably alpha rate to high! (alpha:'+alpha+', step:'+k+')')
            }
            
            if (this.errorThres && this.error(X,Y,this.theta) < this.errorThres) break;
            if (this.costThres && this.cost(X,Y,this.theta) < this.costThres) break;
            if (this.dynamic) {
              // experimental dynamic aloha rate adaptation
              if (lastVx) {
                var gMax=0, gradVx = lastVx.map(function (vx,index) {
                  var g = Math.abs(Vx[index]/vx);
                  gMax = Math.max(gMax,g)
                  return g
                })
                // if some gradVx > XX then lower alpha
                if (gMax > 2) {
                  alpha /= 2;
                } else if (gMax < 1 && (1-gMax) < 0.01) alpha *= 2;
              }
              lastVx = Vx.slice();
              lastTheta = this.theta.slice();
              // console.log(alpha,Vx);
            }
            if(this.trace) {
                console.log('theta: ',this.theta)
                console.log('cost at iteration ' + k + ': ' + cost+' alpha:'+alpha);
            }
        }
        
        return {
            theta: this.theta,
            dim: this.dim,
            cost: this.cost(X, Y, this.theta),
            error: this.error(X, Y, this.theta),
            iterations : k,
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        };
    };
    
    LinearRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        
        var Vtheta = [];
        
        for(var d = 0; d < this.dim; ++d){
            var g = 0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var y_i = Y[i];
                
                var predicted = this.h(x_i, theta);
                
                g += (predicted - y_i) * x_i[d];  
            }
            
            g = (g + this.lambda * theta[d]) / N;
            
            Vtheta.push(g);
        }
        
        return Vtheta;
    };
    
    LinearRegression.prototype.h = function(x_i, theta) {
        var predicted = 0.0;
        for(var d = 0; d < this.dim; ++d) {
            predicted += x_i[d] * theta[d];
        }
        return predicted;
    }
    
    LinearRegression.prototype.cost = function(X, Y, theta) {
      
        var N = X.length;
        var cost = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            cost += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        for(var d = 0; d < this.dim; ++d) {
            cost += this.lambda * theta[d] * theta[d];
        }
        
        return cost / (2.0 * N);
    };

    LinearRegression.prototype.error = function(X, Y, theta) {
      
        var N = X.length;
        var err = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            err += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        
        return err / (N);
    };
    
    LinearRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        // x is a row vector
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    };

    LinearRegression.prototype.toFunction = function () {
      var self=this, foo;
      var fcode = 'foo=function (x) { return '
      fcode += (self.theta.map(function (p,index) {
        var xx=[]; for (var i=0;i<index;i++) xx.push('x');
        return self.theta[index]+(xx.length?'*'+xx.join('*'):'');
      }).join('+'))
      fcode += '}';
      eval(fcode);
      return foo
    }
    
    jsr.LinearRegression = LinearRegression;
    
    var LogisticRegression = function(config) {
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    }
    
    LogisticRegression.prototype.fit = function(data) {
        this.dim = data[0].length;
        var N = data.length;
        
        var X = [];
        var Y = [];
        for(var i=0; i < N; ++i){
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j){
                x_i.push(row[j]);
            }
            X.push(x_i);
            Y.push(y_i);
        }
        
        this.theta = [];
        for(var d = 0; d < this.dim; ++d){
            this.theta.push(0.0);
        }
        
        for(var iter = 0; iter < this.iterations; ++iter){
            var theta_delta = this.grad(X, Y, this.theta);
            for(var d = 0; d < this.dim; ++d){
                this.theta[d] = this.theta[d] - this.alpha * theta_delta[d];        
            }
        }
        
        this.threshold = this.computeThreshold(X, Y);
        
        return {
            theta: this.theta,
            threshold: this.threshold,
            cost: this.cost(X, Y, this.theta),
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        }
    };
    
    LogisticRegression.prototype.computeThreshold = function(X, Y){
        var threshold=1.0, N = X.length;
        
        for (var i = 0; i < N; ++i) {
            var prob = this.transform(X[i]);
            if(Y[i] == 1 && threshold > prob){
                threshold = prob;
            }
        }
        
        return threshold;
    }
    
    LogisticRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        var Vx = [];
        for(var d = 0; d < this.dim; ++d) {
            var sum = 0.0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var predicted = this.h(x_i, theta);
                sum += ((predicted - Y[i]) * x_i[d] + this.lambda * theta[d]) / N;
            }    
            Vx.push(sum);
        }
        
        return Vx;
        
    }
    
    LogisticRegression.prototype.h = function(x_i, theta) {
        var gx = 0.0;
        for(var d = 0; d < this.dim; ++d){
            gx += theta[d] * x_i[d];
        }
        return 1.0 / (1.0 + Math.exp(-gx));
    }
    
    LogisticRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    }
    
    LogisticRegression.prototype.cost = function(X, Y, theta) {
        var N = X.length;
        var sum = 0;
        for(var i = 0; i < N; ++i){
            var y_i = Y[i];
            var x_i = X[i];
            sum += - (y_i * Math.log(this.h(x_i, theta)) + (1-y_i) * Math.log(1 - this.h(x_i, theta))) / N;
        }
        
        for(var d = 0; d < this.dim; ++d) {
            sum += (this.lambda * theta[d] * theta[d]) / (2.0 * N);
        }
        return sum;
    };
    
    jsr.LogisticRegression = LogisticRegression;
    
    var MultiClassLogistic = function(config){
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    };
    
    MultiClassLogistic.prototype.fit = function(data, classes) {
        this.dim = data[0].length;
        var N = data.length;
        
        if(!classes){
            classes = [];
            for(var i=0; i < N; ++i){
                var found = false;
                var label = data[i][this.dim-1];
                for(var j=0; j < classes.length; ++j){
                    if(label == classes[j]){
                        found = true;
                        break;
                    }
                }
                if(!found){
                    classes.push(label);
                }
            }
        }
        
        this.classes = classes;
        
        this.logistics = {};
        var result = {};
        for(var k = 0; k < this.classes.length; ++k){
            var c = this.classes[k];
            this.logistics[c] = new jsr.LogisticRegression({
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations
            });
            var data_c = [];
            for(var i=0; i < N; ++i){
                var row = [];
                for(var j=0; j < this.dim-1; ++j){
                    row.push(data[i][j]);
                }
                row.push(data[i][this.dim-1] == c ? 1 : 0);
                data_c.push(row);
            }
            result[c] = this.logistics[c].fit(data_c);
        }
        return result;
    };
    
    MultiClassLogistic.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        
        
        var max_prob = 0.0;
        var best_c = '';
        for(var k = 0; k < this.classes.length; ++k) {
            var c = this.classes[k];
            var prob_c = this.logistics[c].transform(x);
            if(max_prob < prob_c){
                max_prob = prob_c;
                best_c = c;
            }
        }
        
        return best_c;
    }
    
    
    
    jsr.MultiClassLogistic = MultiClassLogistic;

})(jsregression);

var module = module || {};
if(module) {
	module.exports = jsregression;
}
};
BundleModuleCode['plugins/math/matja']=function (module,exports,global,process){
// MatLab math compatibility and related extensions
Math.gaussian = function (x,pos,wid) {
  if(typeof(x)==='number' && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //numerator
    var num = Math.pow((x-pos),2)
    //Divison
    var res = num/den;
    //Exponent of total result
    var result = Math.exp(-res)
    return result;
  }
  else if(Utils.isArrayArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function (row) { return  row.map(function (element) { return  element - pos})});
    //numerator
     var num = sub.map(function (row) { return row.map(function (element) { return Math.pow(element,2) }) });
    //Division
    var res = num.map(function (row) { return row.map(function (element) { return element/den }) });
    //Exponent of result
    var result = res.map(function (row) { return row.map(function (element) { return Math.exp(-element) }) });
    return result;
  }
  else if(Utils.isArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function(value) {
      return value - pos;
    });
    //numerator
    var num = sub.map(function (num,i) { return Math.pow(num,2) });
    ////Division
    var res = num.map(function(value) {
      return value/den;
    });
    //Exponent of result
    var result = res.map(function(value) {
      return Math.exp(-value);
    });
    return result;
  }
  else {
    throw 'EINVALID'
  } 
}


Math.sign = function (x) { return x<0?-1:x>0?1:0 }

// Sequence of numbers (discrete number ranges)
// [first:increment:second]
$S = function (first,incrementOrSecond,second) {
  if (second==undefined) return Math.sequence(first,incrementOrSecond);
  else return Math.sequence(first,second,incrementOrSecond);
}

// Right-hand side array selector
// A(first:last)
$RS = function (A,first,last) {
  if (Utils.isArray(A)) return A.slice(first,last+1)
}
// Left-hand side array selector
// A(first:last) = B
$WS = function (A,first,last,B) {
  if (Utils.isArray(A) && Utils.isArray(B)) 
    for(var i=0;i<last-first+1;i++) A[first+i]=B[i];
}

};
BundleModuleCode['plugins/math/fft']=function (module,exports,global,process){
/**
 * Fast Fourier Transform module
 * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)
 */
 
/* Version 1.3.1 */

(function() {
  var FFT= function (n,n2) { if (!(this instanceof FFT)) return new FFT(n,n2); this.init(n,n2) };           // top-level namespace
  var _root = this;  // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FFT=FFT;
  } else {
    window.FFT = FFT;
  }

  FFT.prototype = {
    init : function(n,n2) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        this._n = n;
        this._n2 = n2;
        this._initArray();
        this._makeBitReversalTable();
        this._makeCosSinTable();
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // 1D-FFT
    fft1d : function(re, im) {
      if (Utils.isArray(re))
        this.fft(re, im, 1);
      else if (Math.Vector.isVector(re)) 
        this.fft(re.data,im.data,1);
      else if (Math.VectorTA.isVector(re)) 
        this.fft(re.data,im.data,1);      
    },
    // 1D-IFFT
    ifft1d : function(re, im) {
      var k = 1/this._n;
      this.fft(re, im, -1);
      for(var i=0; i<this._n; i++) {
        re[i] *= k;
        im[i] *= k;
      }
    },
    // 2D-FFT
    fft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      if (Utils.isArray(re) && !Utils.isArrayArray(re)) {
        // x-axis
        for(var y=0; y<this._n; y++) {
          i = y*this._n;
          for(var x1=0; x1<this._n; x1++) {
            tre[x1] = re[x1 + i];
            tim[x1] = im[x1 + i];
          }
          this.fft1d(tre, tim);
          for(var x2=0; x2<this._n; x2++) {
            re[x2 + i] = tre[x2];
            im[x2 + i] = tim[x2];
          }
        }
        // y-axis
        for(var x=0; x<this._n; x++) {
          for(var y1=0; y1<this._n; y1++) {
            i = x + y1*this._n;
            tre[y1] = re[i];
            tim[y1] = im[i];
          }
          this.fft1d(tre, tim);
          for(var y2=0; y2<this._n; y2++) {
            i = x + y2*this._n;
            re[i] = tre[y2];
            im[i] = tim[y2];
          }
        }
      } else if (Utils.isArrayArray(re) || Math.Matrix.isMatrix(re)) {
        // TODO
      } else if (Math.MatrixTA.isMatrix(re)) {
        // TODO
      }
    },
    // 2D-IFFT
    ifft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<this._n; y++) {
        i = y*this._n;
        for(var x1=0; x1<this._n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        this.ifft1d(tre, tim);
        for(var x2=0; x2<this._n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<this._n; x++) {
        for(var y1=0; y1<this._n; y1++) {
          i = x + y1*this._n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        this.ifft1d(tre, tim);
        for(var y2=0; y2<this._n; y2++) {
          i = x + y2*this._n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // core operation of FFT
    fft : function(re, im, inv) {
      var d, h, ik, m, tmp, wr, wi, xr, xi,
          n4 = this._n >> 2;
      // bit reversal
      for(var l=0; l<this._n; l++) {
        m = this._bitrev[l];
        if(l < m) {
          tmp = re[l];
          re[l] = re[m];
          re[m] = tmp;
          tmp = im[l];
          im[l] = im[m];
          im[m] = tmp;
        }
      }
      // butterfly operation
      for(var k=1; k<this._n; k<<=1) {
        h = 0;
        d = this._n/(k << 1);
        for(var j=0; j<k; j++) {
          wr = this._cstb[h + n4];
          wi = inv*this._cstb[h];
          for(var i=j; i<this._n; i+=(k<<1)) {
            ik = i + k;
            xr = wr*re[ik] + wi*im[ik];
            xi = wr*im[ik] - wi*re[ik];
            re[ik] = re[i] - xr;
            re[i] += xr;
            im[ik] = im[i] - xi;
            im[i] += xi;
          }
          h += d;
        }
      }
    },
    // returns spectrum of signal array
    signalSpectrum : function (data,islog,norm,scale) {
      var re=data.slice(),
          im = data.map(function () { return 0 });
      this.fft1d(re,im);
      return this.spectrum(re,im,islog,norm,scale).slice(0,data.length/2);
    },
    // returns shifted spectrum array of signal input array
    signalSpectrumWindow : function (data,islog,norm,scale) {
      var res=[];
      for(var off=0;off<(data.length-this._n);off++) {
        var re = data.slice(off,off+this._n),
            im = re.map(function () { return 0 });
        this.fft1d(re,im);
        res.push(this.spectrum(re,im,islog,norm,scale).slice(0,this._n/2)); 
      }
      return res;
    },
    // returns amplitude spectrum array from re/im fft output
    spectrum : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
     // returns phase spectrum
    phase : function (re,im,islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          n2 = this._n*(this._n2||1),
          log = Math.log,
          atan = Math.atan;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(atan(im[i]/re[i]));
        } else {
          spectrum[i] = atan(im[i]/re[i]);
        }
      }
      return spectrum;
    },
    // returns power spectrum
    power : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log((re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = (re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
    // initialize the array (supports TypedArray)
    _initArray : function() {
      if(typeof Uint8Array !== 'undefined') {
				if(this._n<=256)
                                        this._bitrev = new Uint8Array(this._n);
				else if(this._n<=65536)
					this._bitrev = new Uint16Array(this._n);
				else
					this._bitrev = new Uint32Array(this._n);
      } else {
        this._bitrev = [];
      }
      if(typeof Float64Array !== 'undefined') {
        this._cstb = new Float64Array(this._n*1.25);
      } else {
        this._cstb = [];
      }
    },
    // zero padding
    _paddingZero : function() {
      // TODO
    },
    // makes bit reversal table
    _makeBitReversalTable : function() {
      var i = 0,
          j = 0,
          k = 0;
      this._bitrev[0] = 0;
      while(++i < this._n) {
        k = this._n >> 1;
        while(k <= j) {
          j -= k;
          k >>= 1;
        }
        j += k;
        this._bitrev[i] = j;
      }
    },
    // makes trigonometiric function table
    _makeCosSinTable : function() {
      var n2 = this._n >> 1,
          n4 = this._n >> 2,
          n8 = this._n >> 3,
          n2p4 = n2 + n4,
          t = Math.sin(Math.PI/this._n),
          dc = 2*t*t,
          ds = Math.sqrt(dc*(2 - dc)),
          c = this._cstb[n4] = 1,
          s = this._cstb[0] = 0;
      t = 2*dc;
      for(var i=1; i<n8; i++) {
        c -= dc;
        dc += t*c;
        s += ds;
        ds -= t*s;
        this._cstb[i] = s;
        this._cstb[n4 - i] = c;
      }
      if(n8 !== 0) {
        this._cstb[n8] = Math.sqrt(0.5);
      }
      for(var j=0; j<n4; j++) {
        this._cstb[n2 - j]  = this._cstb[j];
      }
      for(var k=0; k<n2p4; k++) {
        this._cstb[k + n2] = -this._cstb[k];
      }
    }
  };
}).call(this);

/**
 * Spatial Frequency Filtering
 * High-pass/Low-pass/Band-pass Filter
 * Windowing using hamming window
 */
(function() {
  var FrequencyFilter={};  // top-level namespace
  var _root = this;     // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FrequencyFilter=FrequencyFilter;
  } else if(typeof exports !== 'undefined') {
    FrequencyFilter = exports;   // for CommonJS
  } else {
    FrequencyFilter = _root.FrequencyFilter = {};
  }

  // core operations
  var _n = 0;
  var core = {
    init : function(n) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        _n = n;
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // swaps quadrant
    swap : function(re, im) {
      var xn, yn, i, j, k, l, tmp,
          len = _n >> 1;
      for(var y=0; y<len; y++) {
        yn = y + len;
        for(var x=0; x<len; x++) {
          xn = x + len;
          i = x + y*_n;
          j = xn + yn*_n;
          k = x + yn*_n;
          l = xn + y*_n;
          tmp = re[i];
          re[i] = re[j];
          re[j] = tmp;
          tmp = re[k];
          re[k] = re[l];
          re[l] = tmp;
          tmp = im[i];
          im[i] = im[j];
          im[j] = tmp;
          tmp = im[k];
          im[k] = im[l];
          im[l] = tmp;
        }
      }
    },
    // applies High-Pass Filter
    HPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Low-Pass Filter
    LPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r > radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Band-Pass Filter
    BPF : function(re, im, radius, bandwidth) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius || r > (radius + bandwidth)) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // windowing using hamming window
    windowing : function(data, inv) {
      var len = data.length,
          pi = Math.PI,
          cos = Math.cos;
      for(var i=0; i<len; i++) {
        if(inv === 1) {
          data[i] *= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        } else {
          data[i] /= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        }
      }
    }
  };
  // aliases (public APIs)
  var apis = ['init', 'swap', 'HPF', 'LPF', 'BPF', 'windowing'];
  for(var i=0; i<apis.length; i++) {
    FrequencyFilter[apis[i]] = core[apis[i]];
  }
}).call(this);

/**
 * FFT Power Spectrum Viewer
 */
(function() {
  var SpectrumViewer={};  // top-level namespace
  var _root = this;    // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.SpectrumViewer=SpectrumViewer;
  } else if(typeof exports !== 'undefined') {
    SpectrumViewer = exports;   // for CommonJS
  } else {
    SpectrumViewer = _root.SpectrumViewer = {};
  }

  // core operations
  var _context = null,
      _n = 0,
      _img = null,
      _data = null;
  var core = {
    init : function(context) {
      _context = context;
      _n = context.canvas.width,
      _img = context.getImageData(0, 0, _n, _n);
      _data = _img.data;
    },
    // renders FFT power spectrum on the canvas
    render : function(re, im, islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = _n*_n,
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(Math.sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      for(var j=0; j<n2; j++) {
        spectrum[j] = spectrum[j]*255*imax;
      }
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x=0; x<_n; x++) {
          val = spectrum[i + x];
          p = (i << 2) + (x << 2);
          _data[p] = 0;
          _data[p + 1] = val;
          _data[p + 2] = val >> 1;
        }
      }
      _context.putImageData(_img, 0, 0);
    }
  };
  // aliases (public APIs)
  SpectrumViewer.init = core.init;
  SpectrumViewer.render = core.render;
}).call(this);
};
BundleModuleCode['plugins/math/conv']=function (module,exports,global,process){
/*
** Convolution and correlation of vectors and matrix objects
** using FFT
*/
function setup(a,b) {
  var N = a.length,
      M = Math.pow(2,Math.ceil(Math.log2(N))),
      N2  = M*2;
  var data1 = a.data?a.toArray():a,
      data2 = b.data?b.toArray():b;
  if (N!=M) {
    data1=data1.pad(M);
    data2=data2.pad(M);
  }
  var fft   = Math.FFT.FFT(N2);
  var re1   = data1.pad(N2,0);
  var im1   = Array.init(re1.length);
  fft.fft1d(re1,im1);
  var re2   = data2.pad(N2,0);
  var im2   = Array.init(re2.length);
  fft.fft1d(re2,im2);
  return {
    fft:fft,
    reA:re1,
    imA:im2,
    reB:re2,
    imB:im2
  }
}
Convolution = {
  convolute1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('convolute: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB);
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.add(im).slice(0,N),
          ca = Convolution.correlate1d(a,a), // ??
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.add(im).slice(0,N)
  },
  correlate1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('correlate: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB.mul(-1));
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.sub(im).slice(0,N),
          ca = Convolution.correlate1d(a,a),
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.sub(im).slice(0,N)
  }
}

module.exports = Convolution;
};

var Base64=Require('os/base64');
module.exports = Require('plugins/math/math.js');
if (typeof window != 'undefined') for(var p in module.exports) window[p]=module.exports[p];
return module.exports;
