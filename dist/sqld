#!/usr/bin/node
var CoreModule = {};
CoreModule['crypto']='crypto';
CoreModule['util']='util';
CoreModule['http']='http';
CoreModule['fs']='fs';
CoreModule['stream']='stream';
CoreModule['url']='url';
CoreModule['os']='os';
CoreModule['net']='net';
CoreModule['zlib']='zlib';
CoreModule['path']='path';
CoreModule['dgram']='dgram';
CoreModule['child_process']='child_process';
CoreModule['events']='events';
CoreModule['string_decoder']='string_decoder';
CoreModule['assert']='assert';
CoreModule['buffer']='buffer';

module.paths.push(process.env.HOME+"/.node_modules"); //append custom path to NODE_PATH
module.paths.push(process.env.HOME+"/node_modules"); //append custom path to NODE_PATH
module.paths.push(process.env.PWD); //append custom path to NODE_PATH
var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
var Fs = require("fs");
PATHS=[process.cwd(),".","/home/sbosse/proj/workbook/src"];
function _isdir(path) {
  var stats=Fs.lstatSync(path);
  return stats.isDirectory()};
function _search(index,file) {
  if (PATHS.length==index) return file;
  var path=PATHS[index];
  if (Fs.existsSync(path+"/"+file+".js")) return path+"/"+file+".js";
  else if (Fs.existsSync(path+"/"+file) && !_isdir(path+"/"+file)) return path+"/"+file;
  else return _search(index+1,file);
 }
global.Require=function(modupath) { 
  var file,filepath;
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}; var module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports);
  else { try {  file=_search(0,modupath); module = require(file)}
  catch (e) { var more="";
   if ((e.name==="SyntaxError"||e.name==="TypeError") && file) {
      var src=Fs.readFileSync(file,"utf8");
      var Esprima = Require("parser/esprima");
      try {
        var ast = Esprima.parse(src, { tolerant: true, loc:true });
        if (ast.errors && ast.errors.length>0) more = ", "+ast.errors[0];
      } catch (e) {
        if (e.lineNumber) more = ", in line "+e.lineNumber;
      }
   }
   console.log("Require import of "+modupath+" ("+file+") failed: "+e+more);
   // if (e.stack) console.log(e.stack);
   throw e; // process.exit(-1);
  }}
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
global.FilesEmbedded = {};
global.FileEmbedd = function (path,format) {};
global.FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
Import = function (files,exports) {
  new Function("SourceMap", "exports", function() {
   var code = files.map(function(file) {
     return FileEmbedded(file, "utf8");
   });
   return code.join("\n\n");
 }())({}, exports);
}
global.Import = Import;
global.TARGET='node';

BundleModuleCode['com/io']=function (module,exports){
/**
 **      ==================================
 **      OOOO   OOOO OOOO  O      O   OOOO
 **      O   O  O    O     O     O O  O   O
 **      O   O  O    O     O     O O  O   O
 **      OOOO   OOOO OOOO  O     OOO  OOOO
 **      O   O     O    O  O    O   O O   O
 **      O   O     O    O  O    O   O O   O
 **      OOOO   OOOO OOOO  OOOO O   O OOOO
 **      ==================================
 **      BSSLAB, Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR.
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2020 BSSLAB
 **    $CREATED:     sbosse on 3/28/15.
 **    $VERSION:     1.7.1X
 **
 **    $INFO:
 *
 * This module encapsulates all IO operations (except networking) supporting
 * node.js applications.
 *
 **    $ENDOFINFO
 */

if (global.TARGET=='node')  { 

 /*
  ************
  ** Node.js
  ************
  */
 var util = require('util');
 var GetEnv = Require('os/getenv');
 var Base64 = Require('os/base64');
 var Fs = require('fs');
 var os = require('os');
 var child = require('child_process');

 var stderr_fun = function (str) { process.stderr.write(str); };
 var stdout_fun = function (str) { process.stdout.write(str); };

 /*
  ** node.js specific
  */

 var tracefile = undefined;
 var tracing = true;

 /**
 * Open a module and append all exported properties to the current global object.
 * (top-level scope)
 */
 global.open = function(name,as) {
   var module = Require(name);
   for (var p in module) {
     global[p] = module[p];
   };
   if (as) global[as]=module;
 }

/*
 ** node.js
 */
var io = {
    checkOptions : function(options,defaultOptions) {
      return Object.assign({}, defaultOptions||{}, options) },
      
    checkOption : function (option,defaultOption) { 
      return option==undefined? defaultOption:option },

    config: {
        columns:undefined,
        rows:undefined
    },
    /**************
     ** FILE IO
     ***************/
    /**
     *
     * @param fd
     */
    close: function (fd) {
        Fs.closeSync(fd);
    },
    /**
     *
     * @param path
     */
    exists: function (path) {
        return Fs.existsSync(path);
    },
    /**
     *
     * @param path
     */
    file_exists: function (path) {
        return Fs.existsSync(path);
    },
    /** Search a file by iterating global PATH variable.
     *
     * @param name  File name or partial (relative) path
     */
    file_search: function (name) {
        // Expecting global PATH variable !?
        if (this.file_exists(name)) return name; 
        else if (typeof PATH !== 'undefined') {
          for (var p in PATH) {
            if (this.file_exists(PATH[p]+'/'+name)) return (PATH[p]+'/'+name);
          }
          return undefined;
        } else return undefined;
    },
    /**
     *
     * @param path
     * @returns {number}
     */
    file_size: function (path) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            return stat.size;
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param timekind a c m
     * @returns {number}
     */
    file_time: function (path,timekind) {
        var stat = Fs.statSync(path);
        if (stat != undefined)
            switch (timekind) {
                case 'a': return stat.atime.getTime()/1000;
                case 'c': return stat.ctime.getTime()/1000;
                case 'm': return stat.mtime.getTime()/1000;
                default: return stat.mtime.getTime()/1000;
            }
        else
            return -1;
    },
    /**
     *
     * @param path
     * @param mode
     * @returns {*}
     */
    open: function (path, mode) {
        return Fs.openSync(path, mode);
    },
    /**
     *
     * @param fd
     * @param len
     * @param foff
     */
    read: function (fd, len, foff) {
        // TODO
    },
    /**
     *
     * @param path
     * @returns {string|undefined}
     */
    read_file: function (path) {
        try {
            return Fs.readFileSync(path,'utf8');
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param path
     * @returns {*}
     */
    read_file_bin: function (path) {
        try {
            return Fs.readFileSync(path);
        } catch (e) {
            return undefined;
        }
    },
    /**
     *
     * @param fd
     */
    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {number}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return Fs.readSync(fd, buf, boff, len, foff);
    },
    /**
     *
     * @param fd
     */
    sync: function (fd) {
        Fs.fsyncSync(fd);
    },
    
    time: function () {
      return Date.now()
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {number}
     */
    write: function (fd, data, foff) {
        return Fs.writeSync(fd, data, foff);
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {number}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return Fs.writeSync(fd, buf, bpos, blen, foff);
    },
    /**
     *
     * @param path
     * @param {string} buf
     */
    write_file: function (path,str) {
        try {
            Fs.writeFileSync(path, str, 'utf8');
            return str.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param path
     * @param buf
     * @returns {*}
     */
    write_file_bin: function (path,buf) {
        try {
            Fs.writeFileSync(path, buf, 'binary');
            return buf.length;
        } catch (e) {
            return -1;
        }
    },
    /**
     *
     * @param fd
     * @param {string} str
     * @returns {number}
     */
    write_line: function (fd, str) {
        return Fs.writeSync(fd, str+NL);
    },

    /****************
     ** CONSOLE IO
     ****************/
    /**
     *
     * @param msg
     */
    debug: function (msg) {
        console.error('Debug: ' + msg);
    },
    /**
     *
     * @param msg
     */
    err: function (msg) {
        console.error('Error: ' + msg);
        throw Error(msg);
    },
    /**
     *
     * @param msg
     */
    fail: function (msg) {
        console.error('Fatal Error: ' + msg);
        process.exit(0);
    },
    /**
     *
     * @param obj
     */
    inspect: function (obj,depth) {return util.inspect(obj,{showHidden: false, 
                                                            depth: depth?depth:2})},

    /**
     * 
     */
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (!e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        if (where==undefined) this.out(e);
        else this.out(where+': '+e);
        this.out('Stack Trace');
        this.out('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                this.out(line);
            }
        }
        this.out('--------------------------------');
    },
     /**
     *
     * @param e
     * @param where
     */
    sprintstack: function (e) {
        var str='';
        if (e==_ || !e.stack) e=new Error(e);
        var stack = e.stack //.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .replace(/^Object.eval\s*\(/gm, '')
            .split('\n');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                if (str!='') str += '\n';
                str += '  at '+line;
            }
        }
        return str;
    },
   /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    /**
     *
     * @param msg
     */
    out: function (msg) {
        console.warn(msg)
    },
    /**
     *
     * @param msg
     */
    warn: function (msg) {
        console.warn('Warning: ' + msg);
    },
    /**
     *
     * @param fun
     */
    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    /**
     *
     * @param fun
     */
    set_stdout: function(fun) {
        stdout_fun=fun;
    },
    /**
     *
     * @param msg
     */
    stderr: function (msg) {
        stderr_fun(msg);
    },
    /**
     *
     * @param msg
     */
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            Fs.writeSync(tracefile, '[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        tracefile = Fs.openSync(path, 'w+');
        if (tracefile != undefined) this.tracing = false;
    },

    /**************
     ** Process control
     ***************/
    exit: function (n) {
        process.exit(n);
    },
    /**
     *
     * @returns {*} RSS HEAP in kBytes {data,heap}
     */
    mem: function () {
        var mem = process.memoryUsage();
        return {data:(mem.rss/1024)|0,heap:(mem.heapUsed/1024)|0};
    },
    /****************************
     ** Environment and Arguments
     ****************************/
    getenv: function (name, def) {
        return GetEnv(name, def);
    },
    workdir: function () {
        return this.getenv('PWD','');
    },

    /**
     *  @return {string []}
     */
    getargs: function () {
        return process.argv;
    },

    sleep: function(delay) {
      var start = new Date().getTime();
      while (new Date().getTime() < start + delay);
    },
    
    /**
     *  Process management
     */
    fork: child.fork,
    exec: child.exec,
    spawn: child.spawn,

    /**
     * OS
     */
    hostname: os.hostname

  };
} else {
 /*
  ************
  ** Browser
  ************
  */
  var tracing = true;
  var stderr_fun = function (str) { console.log(str); };
  var stdout_fun = function (str) { console.log(str); };
  var args=[];

  /**
  * Open a module and append all exported properties to the current global object.
  * (top-level scope)
  */
  global.open = function(name,as) {
    var module = Require(name);
    for (var p in module) {
      global[p] = module[p];
    };
    if (as) global[as]=module;
  }
  
  var io = {
    /*
    ************
    ** Browser
    ************
    */
    /*
     ** FILE IO
     * TODO WebStorage
     */
    close: function (fd) {
        return;
    },
    exists: function (path) {
        return false;
    },
    open: function (path, mode) {
        var fd = Fs.openSync(path, mode);
        return fd;
    },

    read: function (fd, len, foff) {
        // TODO
    },
    read_file: function (path) {
        return '';
    },

    read_line: function (fd) {
        // TODO
    },
    /**
     *
     * @param fd
     * @param buf
     * @param boff
     * @param len
     * @param [foff]
     * @returns {*}
     */
    read_buf: function (fd, buf, boff, len, foff) {
        return -1;
    },
    sync: function (fd) {
        return;
    },
    /**
     *
     * @param fd
     * @param data
     * @param [foff]
     * @returns {*}
     */
    write: function (fd, data, foff) {
        return -1;
    },
    /**
     *
     * @param fd
     * @param buf
     * @param bpos
     * @param blen
     * @param [foff]
     * @returns {*}
     */
    write_buf: function (fd, buf, bpos, blen, foff) {
        return -1;
    },

    /*
     ** CONSOLE IO
     */
    debug: function (msg) {
        stderr_fun('Debug: ' + msg);
    },
    err: function (msg) {
        stderr_fun('Error: ' + msg);
        throw Error(msg);
    },
    fail: function (msg) {
        stderr_fun('Fatal Error: ' + msg);
    },
    inspect: function (obj) {
        return;
    },
    stacktrace: function () {
        var e = new Error('dummy');
        var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n');
        stderr_fun('Stack Trace');
        stderr_fun('--------------------------------');
        for(var i in stack) {
            if (i>0) {
                var line = stack[i];
                if(line.indexOf('Module.',0)>=0) break;
                stderr_fun(line);
            }
        }
        stderr_fun('--------------------------------');
    },
    /**
     *
     * @param e
     * @param where
     */
    printstack: function (e,where) {
        if (where==undefined) stderr_fun(e);
        else stderr_fun(where+': '+e);
    },
    /**
     *
     * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
     */
    log: function (condmsg) {
        if (condmsg != true) console.warn(condmsg);
    },
    out: function (msg) {
        stdout_fun(msg)
    },
    warn: function (msg) {
        stderr_fun('Warning: ' + msg);
    },


    set_stderr: function(fun) {
        stderr_fun=fun;
    },
    set_stdout: function(fun) {
        stdout_fun=fun;
    },

    stderr: function (msg) {
        stderr_fun(msg);
    },
    stdout: function (msg) {
        stdout_fun(msg);
    },

    /** Write a message with a time stamp written to the trace file.
     *
     * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
     */
    trace: function (condmsg) {
        if (condmsg != true && tracefile != undefined) {
            var date = new Date();
            var time = date.getTime();
            this.log('[' + time + '] ' + condmsg + '\n');
        }
    },
    tracing: tracing,
    /**
     *
     * @param {string} path
     */
    trace_open: function (path) {
        return undefined;
    },

    exit: function (n) {
        return;
    },
    getenv: function (name, def) {
        return def;
    },
    workdir: function () {
        return '';
    },
    /**
     *  @return {string []}
     */
    getargs: function () {
        return args;
    },
    set_args: function (argv) {
        args=argv;
    },
    inspect: function (o) {return '?'}
  };
}  
module.exports = io;
};
BundleModuleCode['os/getenv']=function (module,exports){
var util = require("util");
var url = require("url");

var fallbacksDisabled = false;

function _value(varName, fallback) {
  var value = process.env[varName];
  if (value === undefined) {
    if (fallback === undefined) {
      throw new Error('GetEnv.Nonexistent: ' + varName + ' does not exist ' +
                      'and no fallback value provided.');
    }
    if (fallbacksDisabled) {
      throw new Error('GetEnv.DisabledFallbacks: ' + varName + ' relying on fallback ' + 
                      'when fallbacks have been disabled');
    }
    return '' + fallback;
  }
  return value;
}

var convert = {
  string: function(value) {
    return '' + value;
  },
  int: function(value) {
    var isInt = value.match(/^-?\d+$/);
    if (!isInt) {
      throw new Error('GetEnv.NoInteger: ' + value + ' is not an integer.');
    }

    return +value;
  },
  float: function(value) {
    var isInfinity = (+value === Infinity || +value === -Infinity);
    if (isInfinity) {
      throw new Error('GetEnv.Infinity: ' + value + ' is set to +/-Infinity.');
    }

    var isFloat = !(isNaN(value) || value === '');
    if (!isFloat) {
      throw new Error('GetEnv.NoFloat: ' + value + ' is not a number.');
    }

    return +value;
  },
  bool: function(value) {
    var isBool = (value === 'true' || value === 'false');
    if (!isBool) {
      throw new Error('GetEnv.NoBoolean: ' + value + ' is not a boolean.');
    }

    return (value === 'true');
  },
  url: url.parse
};

function converter(type) {
  return function(varName, fallback) {
    if(typeof varName == 'string') { // default
      var value = _value(varName, fallback);
      return convert[type](value);
    } else { // multibert!
      return getenv.multi(varName);
    }
  };
};

var getenv = converter('string');

Object.keys(convert).forEach(function(type) {
  getenv[type] = converter(type);
});

getenv.array = function array(varName, type, fallback) {
  type = type || 'string';
  if (Object.keys(convert).indexOf(type) === -1) {
    throw new Error('GetEnv.ArrayUndefinedType: Unknown array type ' + type);
  }
  var value = _value(varName, fallback);
  return value.split(/\s*,\s*/).map(convert[type]);
};

getenv.multi = function multi(spec) {
  var key, value;
  var result = {};
  for(var key in spec) {
    var value = spec[key];
    if(util.isArray(value)) { // default value & typecast
      switch(value.length) {
        case 1: // no default value
        case 2: // no type casting
          result[key] = getenv(value[0], value[1]); // dirty, when case 1: value[1] is undefined
        break;
        case 3: // with typecast
          result[key] = getenv[value[2]](value[0], value[1]);
          break;
        default: // wtf?
          throw('getenv.multi(): invalid spec');
          break;
      }
    } else { // value or throw
      result[key] = getenv(value);
    }
  }
  return result;
};

getenv.disableFallbacks = function() {
  fallbacksDisabled = true;
};

getenv.enableFallbacks = function() {
  fallbacksDisabled = false;
};

module.exports = getenv;
};
BundleModuleCode['os/base64']=function (module,exports){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['com/path']=function (module,exports){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['com/sprintf']=function (module,exports){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['plugins/sql/sqld.js']=function (module,exports){
// SQLjson server
// sqld <path/to/db/file>:<port> <path/to/dir>:<port>:<key>? [ <path/to/db/file>:<port> ]
// user better-sqlite3
// npm install better-sqlite3@2.1.0

process.noDeprecation = true

var sqljson = Require('plugins/sql/sqljsonrpc.js')


process.argv.shift()
process.argv.shift()

var options = {
  mode : 'server',
  server : [],
  verbose : 0,
  daemon : false, // starts only a JSONrpc server; no data bases opened initially
  version : '1.9.1'
}

process.argv.forEach(function (arg) {
  switch (arg) {
    case '-v': options.verbose++; break;
    case '-h': options.mode='help'; break;
    case '-d': options.daemon=true; break;
    case '-V': print(sqljson.version); break;
    default:
      var tokens = arg.split(':');
      if (tokens.length==2) {
        options.server.push({db:tokens[0],port:Number(tokens[1])});
      } else if (tokens.length>2) {
        // with key XXXXX
        key=tokens.slice(2);
        options.server.push({db:tokens[0],port:Number(tokens[1]),key:key});        
      }
  }
});
console.log("[SQLD] Version "+options.version);
if (options.mode=='help') 
  return console.log('sqld [-v -h -d] <path/to/db/file>[,<path/to/db>]:<port>[:<key>]\n   <path/to/dir>:<port>[:<key>]\n   [ <path/to/db/file>[,<path/to/db>]:<port>[:<key>]]');

options.server.forEach (function (server) {
  server.dbs = sqljson.server({
      path:server.db,
      daemon:options.daemon,
      url:'http://localhost:'+server.port,
      verbose:options.verbose,
      key:server.key
    }).start();
});
};
BundleModuleCode['plugins/sql/sqljsonrpc.js']=function (module,exports){
/*
USES: sqlite3 (https://github.com/JoshuaWise/better-sqlite3)

NEW Compact JSON RPC Format with Command Interpreter / Server and Local Client API
----------------------------------------------------------------------------------

type SQLoperation =
 { 
   create : { table:string | database: string },
   columns : string [] | [string,SQLColumnType] [] | { $attr:$type } ,
   primarykey? : string,
 } |
 { delete : table string,
   where? : where string,
   callback?: function,
 }  |
 { drop : { table:string | database?:string },
   forced?:boolean,
 }  |
 { insert : table string,
   values : SQLtype [] | { $col : SQLDataType } | []  { $col : SQLDataType }
   encodee? : { $column : $type } 
 }  |
 { select : table string,
   columns? : '*'| string [],
   count? : '*' | string,
   where? : where string,
   callback?: function,
   decode? : { $column : $type },
   exclude? : { $column: conditional expression string,
 }  |
 { tables : []
 }  |
 { schema : table : string
 }  |
 { update : table string,
   values : SQLtype [] | { $col : SQLDataType } | []  { $col : SQLDataType }
   where? : string,
   encode? : { $column : datatype } 
 }  
type SQLcommand = 
 { loop : {
   vars : {},
   init? : [],
   cond : string,
   make : [],
   finalize? : [],
   error? : [],
   result ? : string, 
 }} |
 { ifthen : expression string,
   vars? : {},
   make : [],
   otherwise? : [],
   result ? : string,
   raise? : string,
 } |
 { find : expression string,
   source : string,
   target : string
 } |
 { assign : code string } |
 { incr : string } |
 { result : string | {} } |
 
 
type SQLDataType = number | string | boolean | Buffer
type SQLColumnType = 'INT' | 'FLOAT' | 'VARCHAR($n)' | 'BLOB' 
type datatype = 'float32' | 'float64' | 'int32' | 'uint32' | .. 
type where string = "id = N [ or N ..]" | "id in (N,N,..)" | "idlist([N,N,..])" | "idlist($var)"

*/

var version   = '1.8.1'
var http      = require('http')
var inspect   = require('util').inspect;
var JSONfn    = (typeof Require != 'undefined'?Require:require)('jsonfn');
var Database  
try { Database = require('sqlite3') } catch (e) { Database = require('better-sqlite3') };
var vDatabase = Require('plugins/sql/sqlvfs');
var vDatabase2 = Require('plugins/sql/sqlvfs2');
var fs        = require('fs');
var path      = require('path');
Require("cap.js");

// Operational SQLJSON rights  
var Rights = {
  READ : 1,
  MODIFY : 2,
  CREATE : 4,
  DELETE : 8,
  TABLE  : 16,
  DATABASE : 32
};

var handles = [],urls=[];

/*  typeof @url = "<proto>://<domain>:<ipport>" | "<domain>:<ipport>" | 
*                 "<name>:<ipport>" | "<ip>:<ipport>" | "<ip>:<portname>" | "<ipport>"
 *  and @ipport = (1-65535) | "*" 
 *  and @port = string 
 */
function parseUrl(url) {
  if (!isNaN(Number(url)) || url=='*') return {
    proto:  undefined,
    address:   undefined,
    port:   url,
    param:  undefined,
    value:  undefined    
  }
  var tokens = url.match(/((http|udp|tcp|ws):\/\/)?([a-zA-Z0-9_\.\-]+):(\[?[a-zA-Z0-9]+\]?|\*)(\?([a-zA-z0-9]+)=([a-zA-Z0-9:]+))?/)
  if (!tokens)
    tokens   = url.match(/((http|udp|tcp|ws):\/\/)?([a-zA-Z0-9_\.\-]+)/);
  return  {
    proto:  tokens[2],
    address:   tokens[3],
    port:   tokens[4],
    param:  tokens[6],
    value:  tokens[7]
  }
}
var time = function () { return Math.floor(Date.now()/1000) }


// Support for multi-db mode
function sqlServer (options) {
  if (!(this instanceof sqlServer)) return new sqlServer(options);
  if (!options) options={};
  if (!options.path) options.path='/tmp/db.sql';
  else if (fs.existsSync(options.path) && fs.statSync(options.path).isDirectory()) 
    options._path=options.path; // save a root directory
  this.db={}; this.current='void';
  this.sessions={};
  this.options=options;
  if (options.verbose) console.log('sqlServer',options);
  if (!options.daemon) {
    if (options.path.split(',').length>1) {
      // multi-db mode
      var dbL = options.path.split(',');
      for(var i in dbL) {
        this.attach(Object.assign(options,{path:dbL[i]}));
      }
    } else {
      this.attach(options);
    }
  }
  if (options.key) {
    if (options.key.length==1) {
      // Create capability-based protection
      this.privport = Capability.Port.ofName(options.key[0]);
      this.pubport  = Capability.prv2pub(this.privport);
      var zeroport = Capability.Port(),
          fullcap  = Capability.Capability(zeroport,Capability.Private(0,0xff,this.pubport));
      this.log('SUPERCAP('+path.basename(options.path)+')='+Capability.Capability.toString(fullcap));
    }
  }
  this.open=true;
  if (options.url) { urls[options.url]=this; this.url=options.url };
  this.options.bidirectional=true;
  this.log('SQLJSON-RPC Ver. '+version);
  this.log('Current data base: '+this.current);
}

sqlServer.prototype.array2buffer = function (array,typ) {
    var b=Buffer(array.length*4);
    typ=typ||'uint32';
    for(var i=0;i<array.length;i++) {
      switch (typ) {
        case 'uint16':  b.writeUInt16LE(array[i],i*2); break;
        case 'uint32':  b.writeUInt32LE(array[i],i*4); break;
        case 'float32': b.writeFloat32(array[i],i*4); break;
        case 'float64': b.writeFloat64(array[i],i*8); break;
      }
    }
    return b;
  }

sqlServer.prototype.attach = function (options) {
console.log('attach',options)
  var dbname = options.path.match(/([a-zA-Z0-9_\-]+)\.[^$]+$/),
      exists = fs.existsSync(options.path);
  try {
    if (dbname) dbname=dbname[1];
    else dbname = path.basename(options.path);

    if (this.options.verbose) console.log('sqlServer.attach',options.path,dbname);

    if (this.db[dbname]) {
      this.current=dbname;
      if (this.session) this.session.current=this.current; 
      return false;
    }
    // TODO: memory db new DB('npathdbname.sql',{memory:true})
    if (options.vfs) 
      this.db[dbname] = new vDatabase2(options.vfs,options);      
    else if (exists && fs.statSync(options.path).isDirectory()) 
      this.db[dbname] = new vDatabase(options.path);  
    else if (options.memory) // options.path: filename.sql!!
      this.db[dbname] = new Database(options.path,{memory:true});
    else 
      this.db[dbname] = new Database(options.path);
    
    this.db[dbname].pragma('synchronous = '+(options.synchronous||0));
    this.db[dbname]._path=options.path;
    this.db[dbname]._privport=this.privport;
    this.db[dbname]._pubport=this.pubport;
    
    this.current=dbname; 
    if (this.session) this.session.current=this.current; 
    handles[options.path]=this;
    // synchronous mode = off! -> lazy disk sync.
    this.log((exists?'Opened':'Created')+' data base <'+dbname+'> ('+options.path+')'+(options.memory?' in memory':''));
    this.log('Set synchronous mode to '+(options.synchronous||0));
    return true;
  } catch (e) {
    console.log(e.stack)
    this.log(e);
    return false;
  }
}


sqlServer.prototype.buffer2array = function (buffer,typ) {
    var dw=4,a=[];
    typ=typ||'uint32';
    if (buffer instanceof Array) return buffer;
    buffer=(buffer instanceof Uint8Array)?Buffer(buffer):buffer;
    if (typ.indexOf('64')>0) dw=8;
    else if (typ.indexOf('16')>0) dw=2;
    else if (typ.indexOf('8')>0) dw=1;
    
    for(var i=0;i<buffer.length/dw;i++) {
      switch (typ) {
        case 'uint16':  a.push(buffer.readUInt16LE(i*2)); break;
        case 'uint32':  a.push(buffer.readUInt32LE(i*4)); break;
        case 'float32': a.push(buffer.readFloat32(i*4)); break; 
        case 'float64': a.push(buffer.readFloat64(i*8)); break; 
      }
    }
    return a;
  }

// Decode and encode buffers/arrays

sqlServer.prototype.decode = function (row,what) {
  var self=this,keys = Object.keys(what);
  if (what['$']) row=row[what['$']];
  keys.forEach(function (key) {
    if (key=='$') return;
    row[key]=self.buffer2array(row[key],what[key]);
  })
  return row;
}

// Conditional exclusion of row values { $attribute:'cond' }
sqlServer.prototype.exclude = function (row,what) {
  for(var key in what) {
    with(row) {
      if (eval(what[key])) delete row[key];
    }
  }
  return row;
}
// SQL database operations
sqlServer.prototype.operation = function (op,ctx) {
  var result={},columns,cmd,self=this,rights=0xff,
      template,cmd,prep,keys;
  // Each remote endpoint must have its own current database!!!
  // Otherwise mixed mess (this.session.current)
  // console.log('sqlServer.operation',op);

  // Protected data base (server)?
  if (this.privport && !op.capability) return { error : 'EDENIED' };
  else if (this.privport) {
    if (!Capability.prv_decode(op.capability.cap_priv,this.pubport)) return { error : 'EDENIED' };
    rights=Capability.prv_rights(op.capability.cap_priv);
  }
  if (!rights) return { error : 'ENORIGHTS' };
  if (this.options.verbose) console.log('Rights='+rights);

  if (!this.current  && !this.open) return { error : 'ENOTOPEN' };
  if (op.close) {
    if (this.current=='void') return { error : 'EBADF' };  // CLOSE
    if (op.close.database && op.close.database.path) {
      if (handles[op.close.database.path]==this) {
        this.open=false;
        // TODO   
      }
    } else if (this.db[op.close]) {
      delete handles[this.db[op.close]._path]
      delete this.db[op.close];
    }
    return {};
  }
  if (op.open) {
    if (this.db[op.open]) {
      this.current=op.open;
      if (this.session) this.session.current=op.open;
      return { status : 'OK'};
    } else {
      if ((rights && Rights.CREATE)==0) return { error : 'EDENIED' };
      // try to attach existing db.sql; no path information; used common settings (otherwise a create.database op must be used)
      op.path=op.open+'.sql';
      if (this.options._path) op.path=this.options._path+'/'+op.path;
      if (!fs.existsSync(op.path)) return { error:"ENOTEXIST" };
      if (this.attach(Object.assign(this.options,{path:op.path}))) {
        this.log('DB '+op.path+' attached.');
        return { status : 'OK'};
      };
      return { error:"ENOTEXIST" };
    }
  }
  // CREATE
  if (op.create) {
    if ((rights && Rights.CREATE)==0) return { error : 'EDENIED' };
    if (op.create.table) {
      if (this.current=='void') return { error : 'EBADF' };  // CLOSE
      if (this.db[this.current].readonly) return { error : 'EBADR' };
      if (Array.isArray(op.columns))
        columns = op.columns.map(function (column) {
          if (typeof column == 'string') return column;
          else return column.join(' ');
        }).join(',');
      else
        columns = Object.keys(op.columns).map (function (column) {
          return column+' '+op.columns[column];
        }).join(',');
      cmd='CREATE TABLE "'+op.create.table+'" ('+columns+')';
      if (this.options.verbose) this.log(cmd)
    } else if (op.create.database) {
      if ((rights && Rights.DATABASE)==0) return { error : 'EDENIED' };
      if (op.create.database.path && op.create.database.url) {
        if (handles[op.create.database.path] || urls[op.create.database.url]) 
          result.error='EEXIST';
        else {
          if (/:memory:/.test(op.create.database.path)) {
            op.create.database.memory=true;
            op.create.database.path=path.basename(op.create.database.path.replace(/:memory:/,''))
          }
          // create new service
          handles[op.create.database.path]=sqlServer({
            name    : op.create.database.name,
            path    : op.create.database.path,
            url     : op.create.database.url,
            vfs     : op.create.database.vfs,
            memory  : op.create.database.memory,
            verbose : this.options.verbose,
          }).start();
          result.result = {
            db  : handles[op.create.database.path].db,
            url : op.database.url
          };
        } 
      } else if (op.create.database.path) {
        if (handles[op.create.database.path]) {
          result.error='EEXIST';
        } else {
          if (/:memory:/.test(op.create.database.path)) {
            op.create.database.memory=true;
            op.create.database.path=path.basename(op.create.database.path.replace(/:memory:/,''))
          }
          // add a new database to this service
          if (path.dirname(op.create.database.path)=='.' && !op.create.database.memory) {
            // use path from current database
            // empty coldstart with a directory provided?
            if (!this.db[this.current] && this.options._path)
              op.create.database.path=this.options._path+'/'+op.create.database.path;
            else
              op.create.database.path=path.dirname(this.db[this.current]._path)+'/'+op.create.database.path;
          }
          if (this.attach(Object.assign(this.options,{path    : op.create.database.path,
                                                      name    : op.create.database.name,
                                                      memory  : op.create.database.memory,
                                                      vfs     : op.create.database.vfs}))) {
            this.log('DB '+op.create.database.path+' attached.');
          };
          result.result = 'OK';
        }
      } else result.error = 'EINVALID';
      return result;
    }  
    try {
      this.db[this.current].exec(cmd);
      result.result = 'OK';
    } catch (e) {
      result.error = e.toString();
    }
    return result;
  }
  // DATABASES
  if (op.databases) {
    if ((rights && Rights.READ)==0) return { error : 'EDENIED' };
    if (!op.callback) result.result=[];
    Object.keys(this.db).forEach(function (dbname) {
      if (op.callback) op.callback(dbname);
      else result.result.push(dbname);  
    });
    return result;
  }
  
  // DELETE
  if (op.delete ) {
    if ((rights && Rights.DELETE)==0) return { error : 'EDENIED' };
    if (this.current=='void') return { error : 'EBADF' };  // CLOSE
    if (this.db[this.current].readonly) return { error : 'EBADR' };
    try {
      cmd='DELETE FROM "'+op.delete+'"';
      if (op.where) cmd += (' WHERE ')+op.where;
      if (op.expression) cmd += (' '+op.expression);
      this.db[this.current].exec(cmd);
      result.result = 'OK';
    } catch (e) {
      result.error = e.toString();        
    }
    return result;
  }
  
  // DROP
  if (op.drop) {
    if ((rights && Rights.DELETE)==0 || (rights && Rights.TABLE) ==0) return { error : 'EDENIED' };
    if (typeof op.drop=='string' || (typeof op.drop=='object' && op.drop.table)) {
      if (this.current=='void') return { error : 'EBADF' };  // CLOSE
      if (this.db[this.current].readonly) return { error : 'EBADR' };
      if (typeof op.drop=='object') op.drop=op.drop.table;
      cmd='DROP TABLE'+(op.forced?' IF EXISTS ':'')+' "'+op.drop+'"';
      try {
        this.db[this.current].exec(cmd);
        result.result = 'OK';
      } catch (e) {
        result.error = e.toString();
      }
    } else if (typeof op.drop=='object' && op.drop.database) {
      if (this.db[op.drop.database]) {
        console.log('TODO: drop database '+op.drop.database)
        delete this.db[op.drop.database];
        this.current='void';
        result.result = 'OK';
      } else result.error = 'ENOTOPEN'; 
    } else result.error = 'EINVALID';
    return result;
  }
  
  // INSERT
  if (op.insert) {
    if ((rights && Rights.MODIFY)==0) return { error : 'EDENIED' };
    if (this.current=='void') return { error : 'EBADF' };  // CLOSE
    if (this.db[this.current].readonly) return { error : 'EBADR' };
    try {
      if (Array.isArray(op.values) && typeof op.values[0] == 'object') {
        template  = Object.keys(op.values[0]).map(function () { return '?' }).join(',');
        keys      = Object.keys(op.values[0]).join(',');
        cmd='INSERT INTO "'+op.insert+'" VALUES ('+template+')';
        prep = this.db[this.current].prepare(cmd);
        result.result =
          op.values.map(function (values,index) {
            return prep.run(
              Object.keys(values).map(function (attr) {
                if (values[attr] != null && 
                    typeof values[attr]=='object') {
                  if (!(values[attr] instanceof Buffer) && values[attr].buffer)
                    return values[attr].buffer;
                  else
                    return values[attr];
                } else
                  return values[attr];
            }))
          });
      } else {
        if (Array.isArray(op.values)) {
          template=values.map(function () { return '?' }).join(',');
          cmd='INSERT INTO "'+op.insert+'" VALUES ('+template+')';
        } else if (typeof op.values == 'object') {
          template=Object.keys(op.values).map(function () { return '?' }).join(',');       
          keys      = Object.keys(op.values).join(',');
          cmd='INSERT INTO "'+op.insert+'" ('+keys+') VALUES ('+template+')';
        }
        if (Array.isArray(op.values))
          result.result=this.db[this.current].prepare(cmd).run(op.values);
        else if (typeof op.values == 'object') {
          result.result=this.db[this.current].prepare(cmd).run(
            Object.keys(op.values).map(function (attr) { 
              if (op.values[attr]!=null &&
                  typeof op.values[attr]=='object'){ 
                  if (!(op.values[attr] instanceof Buffer) && op.values[attr].buffer)
                    return op.values[attr].buffer
                  else
                    return op.values[attr];
              } else
                return op.values[attr] 
            }));
        }
      }
    } catch (e) {
      result.error = e.toString();
      // print(e)  
    }
    if (result.result) result.result.time=Date.now();
    return result;
  } 
  
  // SELECT
  if (op.select) {
    if ((rights && Rights.READ)==0) return { error : 'EDENIED' };
    if (this.current=='void') return { error : 'EBADF' };  // CLOSE
    var where;
    try {
      if (op.columns instanceof Array)
        cmd='SELECT '+op.columns.join(',')+' FROM "'+op.select+'"';
      else if (typeof op.columns == 'string')
        cmd='SELECT '+op.columns+' FROM "'+op.select+'"';
      else if (typeof op.count == 'string')
        cmd='SELECT COUNT('+op.count+') FROM "'+op.select+'"';
      result.result=[];
      if (op.where) {
        if (op.where.indexOf('idlist(')==0) {
          function idlist (list) { return 'id in ('+list.join(',')+')' };
          with (ctx||{}) { where=eval(op.where) }
        } else where=op.where;
        cmd += (' WHERE ')+where;
      }
      if (op.expression) {
        cmd += (' '+op.expression);
      }
      this.db[this.current].prepare(cmd).each(function (row) {
        if (op.exclude) row=self.exclude(row,op.exclude);
        if (op.decode) row=self.decode(row,op.decode);
        if (op.callback) op.callback(row);
        else if (op.count) result.result.push(typeof row=='number'?row:row['COUNT('+op.count+')']);
        else result.result.push(row);  
      });
    } catch (e) {
      result.error = e.toString();        
    }
    if (result.result && op.target && ctx) 
      ctx[op.target]=(op.index!=undefined?result.result[op.index]:result.result);
    return result;  
  }
  
  // SCHEMA
  if (op.schema) {
    if ((rights && Rights.READ)==0) return { error : 'EDENIED' };
    if (!Array.isArray(op.schema)) {
      cmd="SELECT sql FROM sqlite_master WHERE name='"+op.schema+"'";
      if (!op.callback) result.result=null;
      this.db[this.current].prepare(cmd).each(function (row) {
        if (op.callback) op.callback(row.sql);
        else result.result=row.sql;
      });
    } else {
      if (!op.callback) result.result=[];
      op.schema.forEach(function (table) {
        cmd="SELECT sql FROM sqlite_master WHERE name='"+table+"'";
        self.db[this.current].prepare(cmd).each(function (row) {
          if (op.callback) op.callback(row.sql);
          else result.result.push(row.sql);
        });
      });
    }
    return result;  
  }
  
  // TABLES
  if (op.tables) {
    if ((rights && Rights.READ)==0) return { error : 'EDENIED' };
    if (this.current=='void') return { error : 'EBADF' };  // CLOSE
    cmd="SELECT name FROM sqlite_master WHERE type='table' ORDER BY name";
    if (!op.callback) result.result=[];
    this.db[this.current].prepare(cmd).each(function (row) {
      if (op.callback) op.callback(row.name);
      else result.result.push(row.name);  
    });
    return result;
  }
  
  // UPDATE
  if (op.update) {
    if ((rights && Rights.MODIFY)==0) return { error : 'EDENIED' };
    if (this.current=='void') return { error : 'EBADF' };  // CLOSE
    if (this.db[this.current].readonly) return { error : 'EBADR' };
    try {
      if (typeof op.values == 'object') {
        template=Object.keys(op.values).map(function (key) { return key+' = ?' }).join(',');       
        cmd='UPDATE "'+op.update+'" SET '+template;
        if (op.where) cmd += (' WHERE ')+op.where;
        result.result=this.db[this.current].prepare(cmd).run(
          Object.keys(op.values).map(function (attr) { return op.values[attr] }));
      }
    } catch (e) {
      result.error = e.toString();        
    }
    if (result.result) result.result.time=Date.now();
    return result;
  }
  return { error : 'EINVALID' }
}

// Command Interpreter
sqlServer.prototype.command = function (op,ctx) {
  var self=this,result,safe=10;
  if (!ctx) ctx={};
  if (op.vars) ctx=Object.assign(ctx,op.vars);
  function boolean(cond) { with (ctx) { return eval(cond) }}
  if (op.find && op.source && op.target) {
    var found,o=ctx[op.source];
    if (Array.isArray(o)) {
      o.forEach(function (__row,index) {
        var match;
        if (found) return;
        with (ctx) { match = eval(op.find.replace(/\$/g,'__row')) };
        if (match) found=__row;
      });
      ctx[op.target]=found;
    }
    return {};
  }
  if (op.ifthen) {
    var branch=boolean(op.ifthen);
    if (branch && op.raise) throw op.raise;
    if (branch && op.make) this.do(op.make,ctx)
    else if (op.otherwise) this.do(op.otherwise,ctx);
    if (op.result) result=ctx[op.result];
    if (result==undefined && ctx.result) result=ctx.result;
    return result;
  }
  if (op.loop) {
    op=op.loop;
    if (op.vars) ctx=Object.assign(ctx,op.vars);
    if (op.init) this.do(op.init,ctx);
    if (op.make) while (safe>0 && (!op.cond || boolean(op.cond))) {
      try {
        this.do(op.make,ctx);
      } catch (e) {
        // print(e)
        if (op.error) {
          try { return this.do(op.error,ctx) }
          catch (e) { return e && e.error?e:{ error:e } };
        }
        else return { error:e }
      }
      safe--;
    }
    if (op.finalize) this.do(op.finalize,ctx);
    if (op.result) result=ctx[op.result];
    if (result==undefined && ctx.result) result=ctx.result;
    return result;
  }
  if (op.result) {
    if (typeof op.result == 'string') 
      ctx.result=ctx[op.result];
    else
      ctx.result=op.result;
    return ctx.result;
  }
  if (op.assign) {
    with (ctx) { eval(op.assign) };
    return {};
  }
  if (op.incr) {
    try { ctx[op.incr]++; } catch (e) { return { error:e }};
    return {};
  }
  if (op.decr) {
    try { ctx[op.incr]--; } catch (e) { return { error:e }};
    return {};
  }
  if (op.decode) {
    this.decode(ctx,op.decode);
  }
}

// Main RPC interpreter entry point
sqlServer.prototype.do = function (ops,ctx) {
  var self=this,result={},tid=ops.tid;
  if (ops.sessionID) this.session=this.openSession(ops.sessionID); else this.session=null;
  if (Array.isArray(ops)) {
    result = ops.map(function (op) {
      result=self.do(op,ctx);
      if (result && result.error) throw result;
      return result;
    })
    return result;
  }
  if (ops.close || ops.create || ops.drop   || ops.databases || ops.delete || ops.insert || 
      ops.open  || ops.select || ops.schema || ops.tables    || ops.update)
    return this.operation(ops,ctx);
  else 
    return this.command(ops,ctx);  
} 

sqlServer.prototype.log = function (msg) {
  print('[SQLJSON'+(this.port?' '+this.port:'')+'] '+msg); 
}

sqlServer.prototype.openSession = function (sessionID) {
  if (this.sessions[sessionID]) {
    if (this.sessions[sessionID].current) this.current=this.sessions[sessionID].current;
    this.sessions[sessionID].timestamp=Date.now();
    return this.sessions[sessionID];
  } else {
    this.sessions[sessionID]={
      current   : this.current,
      timestamp : Date.now()
    }
    return this.sessions[sessionID];
  }
}

sqlServer.prototype.start = function () {
  var self=this,bidirectional=this.options.bidirectional;
  if (this.url) {
    // Start WEB service API
    var addr = parseUrl(this.url);
    self.port=addr.port;
    switch (addr.proto) {
      case 'http':
        var server = {
          cache : {},
          log : function (msg) {
            print('[SQLJSRV '+addr.port+'] '+msg);
          },
          parseQueryString : function ( url ) {
              var queryString = url.substring( url.indexOf('?') + 1 );
              if (queryString == url) return [];
              var params = {}, queries, temp, i, l;
              // Split into key/value pairs
              queries = queryString.split("&");
              // Convert the array of strings into an object
              for ( i = 0, l = queries.length; i < l; i++ ) {
                  temp = queries[i].split('=');
                  if (temp[1]==undefined) temp[1]='true';
                  params[temp[0]] = temp[1].replace('%20',' ');
              }
              return params;
          },

          reply: function (response,body) {
            header={'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': 'true',
                    'Content-Type': 'text/plain'};

             response.writeHead(200,header);
             response.write(body);
             response.end();
          },

          service : function  () {

            var webSrv = http.createServer(function (request,response) { try {
              var body,header,sep,query,now;
              if (request.url.length) 
                query=server.parseQueryString(request.url);
              else 
                query={}
              if (self.options.verbose>1) server.log(inspect(query));
              now=time()
              switch (request.method) {
                case 'GET':
                  // Execute a previously stored SQLjson request (!bidirectional)
                  if (!query.tid) server.reply(response,JSONfn.stringify({error:'EINVALID'}));
                  else {
                    var ops = server.cache[query.tid];
                    delete server.cache[query.tid];
                    var res = self.do(ops);
                    server.reply(response,JSONfn.stringify(res));
                  }
                  break;

                case 'POST':
                  // !bidirectional: Store a SQLjson request (but do not execute it)
                  body = '';
                  request.on('data', function (chunk) {
                    body = body + chunk;
                  });
                  request.on('end', function () {
                    var ops;
                    try {
                      // print(body)
                      ops=JSONfn.parse(body)
                      ops.tid=server.tid++;
                      if (self.options.verbose>1) { server.log(inspect(ops));  };
                      if (bidirectional) {
                        var result=self.do(ops);
                        server.reply(response,JSONfn.stringify(result))                      
                      } else {
                        server.cache[ops.tid]=ops;
                        server.reply(response,JSONfn.stringify({tid:ops.tid}))
                      }
                      if (self.options.verbose>1) {  server.log(inspect(result,null,8)) };
                    } catch (err) {
                      self.log(err.toString())
                      server.reply(response,JSONfn.stringify({error:err.toString()}));
                      if (self.options.verbose>2) print(body);
                    }
                  });
                  break;
              }
              if (self.open==false) {
                server.log('Closing ..');
                request.connection.destroy()
                webSrv.close();
                delete handles[self.options.path];
                delete urls[self.options.url];
              }
             } catch (e) { server.log(e) }
            })

            webSrv.on("connection", function (socket) {
                // socket.setNoDelay(true);
            });

            webSrv.on("error", function (err) {
              server.log(err)
            });
            webSrv.on("close", function (err) {
              server.log('Closed.')
            });

            webSrv.listen(addr.port,function (err) {
              server.log('Started http://localhost:'+addr.port+(bidirectional?' (bidir mode)':''));
            });

            // GC
            setInterval(function () {
              // console.log('GC');
              var t = Date.now()-(10*60*1000); // session timeout: 10min
              for(var p in self.sessions) {
                // console.log(t,self.sessions[p])
                if (self.sessions[p] && t>self.sessions[p].timestamp) {
                  delete self.sessions[p];
                }
              }
            },60000);
            return webSrv;
          },
          tid:1,
        }
        server.service();
        break;
    }
  }
  return this;
}
if (typeof module != 'undefined') 
module.exports = {
  server : sqlServer, 
  version: version,
}
};
BundleModuleCode['jsonfn']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  OJ=exports.stringify;
  JO=exports.parse;
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));


};
BundleModuleCode['plugins/sql/sqlvfs']=function (module,exports){
/*

FS to SQL (json) table mapper
=============================

Files and directories can be accessd by SQL queries!
Just a yaml meta file is required (named meta):

YAML Configuration

Single-file multi-row table; row-indexed table
-----------------------
table : testdata01
data  : test.json
type  : json
index : $row($data)
schema : 
  id : int unique = $row($data)
  x  : int = x($row($data))
  y  : int = y($row($data))
  meta  :
    file  : text = $file
    rows  : int  = $rows($data)
    cols  : int  = $cols($data)
-----------------------

-----------------------
table : testdata01
data  : test.csv
type  : csv
header : true
index : $row($data)
schema : 
  id : int unique = $row($data)
  x  : int = 0($row($data))
  y  : int = 1($row($data))
-----------------------
-----------------------
table : testdata01
data  : test.csv
type  : csv
header : true
# filter : $column(/[yz]/)
# convert : $typedarray($row($data))
index : $row($data)
schema : 
  id : int unique = $row($data)
  _  : int = _($row($data))
-----------------------
-----------------------
# Big CSV file (11000 cols, 5000 rows)
# Columns are selected (500/11000) based on regex pattern
# Selected columns are stored in typedarray
table : stock500
data  : data/data.csv
type  : csv
index : $row($data)
filter  : $columns(/^1\./) # Select columns with name "1. ***"
convert : $typedarray($data) # Store entire table in typedarray (MatrixTA)
schema : 
  id : int unique = $row($data)  // $index($row($data))
  data : blob = $row($data)
  meta :
    columns : $header($data)
------------------------

 
Single-file multi-row table; row-indexed table
-----------------------
table : testdata02
data  : test.npy
type  : numpy
index : $row($data)  // $dim[0]($data)
schema : 
  id : int unique = $index($row($data))   // TODO $index
  data : blob = array($row($data))
  meta  :
    file  : text = $file
    dataspace : text = json($dataspace($data))
    datatype  : text = $datatype($data)
    rows  : int  = $rows($data) // $dims[0]($data)
    cols  : int  = $cols($data) // $dims[1]($data)
    _type : text = json
-----------------------

Mult-file table;  file-index table
-----------------------
table : testdata03
data  : data/file([0-9]+).png # tif
type  : png # tiff
index : $1($file)
schema :
  id   : int unique = $1($file)
  rows : int = $rows($data)
  cols : int = $cols($data)
  data : blob = array($data)
  meta : 
    datatype  : text = "uint8"
    dataspace : array = [ $rows($data), $cols($data) ]
    file      : text = $file 
-----------------------

Mult-file table; file-index table
-----------------------
table : tomoIIWT2020
data  : data/glare([0-9]+).tif
meta  : data/glare([0-9]+).yaml
type  : tiff 
convert : 'GRAY8',
filter : $mean(10,10)  // down-sampleing of data 1:10 in each dimension
index : $1($file)
schema :
  id   : int unique = $1($file)
  rows : int = $rows($data)
  cols : int = $cols($data)
  data : blob = typedarray($data)
  meta : 
    datatype  : text = "uint8"
    dataspace : array = $dataspace($data)
    file      : text = $file 
    info      : text = $meta
-----------------------


SQLDS compatibility
===================

  type DataSetTable = Column {
     id         : integer primary key,
     type       : integer,  --  0:group, 1:direct data, 2:indirect, referenced indexed DataTable
     name       : varchar(),
     time       : integer,
     meta       : varchar(), -- YAML/JSON
     data       : blob|integer|varchar() -- DataTable name or serialized data
   }
   type DataTable = Columns {
     index      : integer primary key,
     type       : integer,  --  1:direct data, 2: indirect data, referenced indexed DataTable
     meta       : varchar(), -- optional, YAML/JSON, for chunks ?
     data       : blob,  
   }
   type meta = JSON {
     datatype   : string,
     dataspace  : [],
     index ?    : number,   // type==2
     meta : *,
   }

DS Multi-file mode, multi-file file-indexed tables
---------------------------------
table : testdata05-data
data  : "data/test([0-9]+).tiff"
type  : tiff
convert : GRAY8
index : $1($data)
schema : 
  index : int unique = $row   // $index($row)
  type : int = 1
  data : blob = $typedarray($data)
  meta  :
    file  : text = $file
    dataspace : array = $dataspace($data)
    datatype  : text = 'Uint8'
    rows  : int  = $rows($data) # $dims[0]($data)
    cols  : int  = $cols($data) # $dims[1]($data)
    _type : text = json
# Dataset API wrapper table
table2 : testdata05
schema2 : 
  id : int unique
  type : int
  name : text
  time : int 
  meta :
    datatype  : text = 'Uint8'
    dataspace : array = $dataspace($data*)
    index : int = 1
    meta  : text = "mydata"
    _type : text = json
  data : text
rows2 :
  - 0,2,"data05",0,*,"testdata05-data"
-----------------------


DS Multi-file mode, single-file row-indexed table; parent is file-indexed
-----------------------
table : testdata06-data$1
data  : "data/test([0-9]+).tiff"
type  : tiff
convert : GRAY8
index : $row($data)
loop  : $1($data)
schema : 
  index : int unique = $row  // $index($row)
  type : int = 1
  data : blob = $typedarray($row($data))
  meta  :
    file  : text = $file
    dataspace : array = $dataspace($row($data))
    datatype  : text = 'Uint8'
    rows  : int  = $rows($data) # $dims[0]($data)
    cols  : int  = $cols($data) # $dims[1]($data)
    _type : text = json
# Dataset API wrapper table
table2 : testdata06
schema2 : 
  id : int unique
  type : int
  name : text
  time : int 
  meta :
    datatype  : text = 'Uint8'
    dataspace : array = $dataspace($data)
    index : int = 1
    meta  : text = "mydata"
    _type : text = json
  data : text
rows2 : 
  loop : $row,2,"data06-$1",0,*,"testdata06-data$1"
------------------------


# Multi CSV tables generated by data file list, parent is CSV row-indexed
table : fssl-data-$1
data  : data/fssl_(.+).csv
type  : csv
header : true
# Table row index defined by CSV rows
index : $index($row($data)) // TODO $index
# Looping table constructor by pattern $1 in data file name
loop  : $1($data)
schema : 
  id : int unique = $index($row($data)) // TODO
  _  : int = _($row($data)) # expands to all header keys


-----------------------

*/
_=null

var version = "1.3.2"

var parser = Require('plugins/sql/sqlite-parser');
var fs     = require('fs');
var path   = require('path');
var yaml   = Require('plugins/sql/yaml');
var inspect  = require('util').inspect;
var numpy   = Require('plugins/numpy/numpy');
var image   = {
  png   : Require('plugins/image/UPNG'),
  tiff  : Require('plugins/image/UTIF')
};
var cache   = Require('cache');
//var papa    = Require('papaparse5');

Require('plugins/math/math');
function identity (x) { return x }

function Database(path,options) {
  var self=this;
  options=options||{};
  this.verbose=options.verbose||0;
  print('[SQLVFS] database root: '+path);
  function isFile (path) {
    return fs.existsSync(path) && fs.statSync(path).isFile()
  }
  function isDir (path) {
    return fs.existsSync(path) && fs.statSync(path).isDirectory()
  }
  this.root=path;
  // 1. Scan tables in database root directory
  //    Can contain nested directories!
  this.rootDirs = fs.readdirSync(this.root).map(function (dir) {
    // 1.b Check for meta file in this directory 
    if (isFile(self.root+'/'+dir+'/meta')) 
      return [dir]; // only one table served
    else if(isDir(self.root+'/'+dir)) {
      // multiple tables, secondary level
      var subdirs = fs.readdirSync(self.root+'/'+dir);
      return subdirs.map(function (dir2) { return dir+'/'+dir2 })
                    .filter(function (dir) {
                      return isDir(dir) && isFile(dir+'/meta')
                    }); // must be all directories!!!!
    }
  }).filter(identity).reduce(function (a,b) { return a.concat(b) })
  // console.log(this.rootDirs)
  var expanded = [];
  var secondary = [];
  this.rootTables = this.rootDirs.map(function (dir) {
    try {
      var text = fs.readFileSync(self.root+'/'+dir+'/meta','utf8');
      var meta = self.parseMeta(text);
      meta.dir = dir;
      if (meta.table2) {
        // secondary tables
        var second = {
          reference : meta,
          table : meta.table2,
          schema : meta.schema2,
          rows : meta.rows2,
          data : meta.data,
          dir : dir,
        }
        secondary.push(second);
        delete meta.table2;
        delete meta.schema2;
        delete meta.rows2;
      }
      if (meta.loop) {
        // table replicator loop
        if (meta.loop=='$1($data)') {
          var _meta=Object.assign({},meta);
          _meta.index=meta.loop;
          var index = self.createIndex({meta:_meta})
          print('[SQLVFS] '+dir+': found '+index.length+' entries');
          index.forEach(function (file) {
            var _meta=Object.assign({},meta);
            _meta.data=file;
            var replace = file.match(RegExp(meta.data))[1];
            _meta.table=meta.table.replace(/\$1/g,replace);
            expanded.push(_meta);
          });
        }
        return null;
      }
      return meta;
    } catch (e) { print('[SQLVFS]: opening of '+dir+' failed: '+e) };
  }).filter(identity);
  
  // 2. Create table handlers
  this.handleHash={};
  this.rootHandles = this.rootTables.map(function (meta) {
    var handle=self.compileMeta(meta);
    if (self.verbose) print(meta);
    self.handleHash[meta.table]=handle;
    return handle;
  });

  this.expanded = expanded.forEach(function (meta) {
    var handle=self.compileMeta(meta);
    if (self.verbose) print(meta);
    self.handleHash[meta.table]=handle;
    return handle;
  });

  this.secondary = secondary.forEach(function (meta) {
    var handle=self.compileMeta(meta);
    if (self.verbose) print(meta);
    self.handleHash[meta.table]=handle;
    return handle;
  });

  // Add sqlitemaster tabel
  var sqlitemaster = {
    table   : 'sqlite_master',
    schema  : { name : {type :'text', value : 'name($row($data))'} ,
                sql  : {type :'text', value : ''},
                type : {type :'text', value : ''} }
  }
  var handle = {
      cache : this.rootTables.concat(expanded).concat(secondary).map(function (meta) {
        return { name : meta.table, sql:self.schemaSQL(meta), type : 'table' }
      }),
      indexTable : this.rootTables.concat(expanded).concat(secondary).map(function (meta,index) {
        return index;
      }),
      getRow : function (i) {
        return handle.cache[i];
      },
      mapRow : function (i,keys) {
        var row = handle.getRow(i);
        if (!row) return;
        keys = keys || Object.keys(sqlitemaster.schema);
        // print(row,keys)
        return self.map2sql(handle,i,row,keys);
      },
      meta : sqlitemaster,
      rows : this.rootTables.concat(expanded).concat(secondary).map(function (meta,index) {
        return index;
      }),
  };
  this.rootTables.push(sqlitemaster);
  this.rootHandles.push(handle);
  this.handleHash['sqlite_master']=handle;
  this.log('Schemas:');
  print(this.rootTables.concat(expanded).concat(secondary).map(function (meta) { 
    return '  '+meta.table+' {'+self.schemaSQL(meta)+'}' 
  }).join('\n'));
  this.log('Tables:');
  print(this.rootTables.concat(expanded).concat(secondary).map(function (meta) { 
    return '  '+meta.table+(meta.type?'('+meta.type+')':'') 
  }).join('\n'));
  // this.test();
  // this.test2();
  this.readonly=true;
}

Database.prototype.columns = function (handle,row) {
  var meta=handle.meta;
  switch (meta.index) {
    case '$row($data)':
    case '$dim[0]($data)':
      switch (handle.meta.type) {
        case 'json': 
          if (!handle.cache.get(row)) handle.getRow(row);
          if (!handle.cache.get(row)) return;
          return Object.keys(handle.cache.get(row)).length;
        case 'csv': 
          if (meta.header) return meta.header.length;
          if (!handle.cache.get(row)) handle.getRow(row);
          if (!handle.cache.get(row)) return;
          return handle.cache.get(row).length;
        case 'numpy':
        case 'tiff':
          return handle.data.columns;
      }
      break;
    case '$1($data)':
      if (handle.cache.get(row)) return handle.cache.get(row).columns;
      break;
  }
}

/* Compile meta data and create a table IO handle
   type handle = {
     meta : meta,
     getRow : function (index) -> data {}
     insertRow : function (index,schema {})
     mapRow : function (index) -> schema []
     readRow : function (index) -> data {}
     setRow : function (index,data {})
     updateRow : function (index,schema [])
     writeRow : function (index,data {})
  }
*/

Database.prototype.compileMeta = function (meta) {
  var self=this,
      handle={meta:meta,cache:!meta.rows? 
        cache({   // dynamic table with external data
          limit   : (meta.cache && Number(meta.cache))||100,
          volume  : 64E6,
          maxTTL  : 120000,
          buckets : 4,
        }):[] // aux. static table
      };
  if (!meta.rows) this.log('Created cache ['+((meta.cache && Number(meta.cache))||100)+']');
print(meta)
  if (meta.index) {
    if (meta.index=='$row($data)') {
      ////////////////////////////////////////////
      // 1. Single file mode: Monolithic source //
      ////////////////////////////////////////////
      
      switch (meta.type) {
        case 'json':
        case 'csv':
          if (meta.type && meta.separator) switch (meta.separator) {
            case 'comma': meta.separator=','; break;
            case 'space': meta.separator=' '; break;
            case 'tab':   meta.separator='\t'; break;
          }
          // Get the raw data
          handle.getRow=function (i) {
            if (handle.data && i<handle.data.length) {
              // data was already read and compiled
              return handle.data[i];
            } else if (handle.cache && handle.cache.get(i)) {
              return handle.cache.get(i);
            } else {
              // read file row
              handle.readRow(i);
              return handle.cache.get(i);
            }
          };
          // Map data row to schema (main entry function) with type conversion
          // Optional keys argument sets schema key sub-set
          handle.mapRow=function (i,keys) {
            var row = handle.getRow(i);
            if (!row) return;
            keys = keys || Object.keys(meta.schema);
            return self.map2sql(handle,i,row,keys);
          };

          // Read the raw data from file
          handle.readRow = function (i) {
            if (!handle.fd) handle.fd=self.open(handle,meta.data, 'r');
            if (!handle.fd) throw self.error;
            switch (meta.type) {
              case 'json':
                // assumption: {} []
                if (handle.indexTable) {
                  handle.cache.set(i, 
                    self.parseJSON(self.read(handle,handle.indexTable[i][0],handle.indexTable[i][1]))
                  );
                }
              case 'csv':
                if (handle.indexTable) {
                  if (meta.convert == '$typedarray($row($data))') {
                    // Store row in a compact typedarray (only numbers)
                    var result=self.parseCSV(self.read(handle,handle.indexTable[i][0],handle.indexTable[i][1]),meta.separator);
                    // column filter : $columns => store only selected columns
                    if (!meta.selected) 
                      result=new Float64Array(result.map(Number));
                    else {
                      result=new Float64Array(meta.selected.map(function (i) { return Number(result[i]) }));
                    }
                    // console.log(meta.selected,result)
                    handle.cache.set(i,result);
                  } else
                    handle.cache.set(i, 
                      self.parseCSV(self.read(handle,handle.indexTable[i][0],handle.indexTable[i][1]),meta.separator)
                    );
                }
                break;
            }
          }
          handle.file=meta.data;
          this.log('Creating index table for '+meta.table);
          handle.indexTable=this.createIndex(handle);
          this.log('Index table created for '+meta.table);
          handle.rows=Math.sequence(0,handle.indexTable.length-1);
          // Auto schema - JSON/CSV header mapping?
          if (meta.schema['_'] && meta.header) {
            var pat2,repl2;
            if (meta.replace && meta.replace.indexOf('$column')==0) {
              // transform header names
              var exec = meta.replace.match(/\$column\(\/([^\/]+)\/,([^\)]+)\)/);
              if (exec) {
                pat2 = RegExp(exec[1]); repl2=exec[2].replace(/'/g,'').replace(/"/g,'');
              }
            }
            // expand schema with all header names
            if (!meta.filter || meta.filter.indexOf('$column')==-1) {
              var entry = meta.schema['_'];
              delete meta.schema['_'];
              meta.header.forEach(function (name,index) {
                if (pat2) name=name.replace(pat2,repl2);
                name=name.toLowerCase();
                meta.schema[name]={type:entry.type,value:entry.value.replace(/_/,meta.type=='json'?name:index)}
              });
            } else if (meta.filter.indexOf('$column')==0) {
              var pat = meta.filter.match(/\$column\(\/([^\/]+)\/\)/);
              if (pat) pat=RegExp(pat[1]);
              var entry = meta.schema['_'];
              delete meta.schema['_'];
              meta.selected=[];
              var _index=0;
              meta.header.forEach(function (name,index) {
                if (pat.test(name)) {
                  if (pat2) name=name.replace(pat2,repl2);
                  name=name.toLowerCase();
                  meta.schema[name]={
                    type:entry.type,
                    value:entry.value.replace(/_/,meta.type=='json'?name:(meta.convert=='$typedarray($row($data))'?_index:index))
                  }
                  meta.selected.push(meta.type=='json'?name:index);
                  _index++;
                }
              });
              // console.log(meta)
            }
          } else if (meta.replace && meta.replace.indexOf('$column')==0) {
              // transform header
              var pat,repl,exec = meta.replace.match(/\$column\(\/([^\/]+)\/,([^\)]+)\)/);
              if (exec) {
                pat = RegExp(exec[1]); repl=exec[2].replace(/'/g,'').replace(/"/g,'');
                meta.header=meta.header.map(function (name) {
                  return name.replace(pat,repl);
                });
              }
              meta.header=meta.header.map(function (name) { return name.toLowerCase() });
          }
          break;
          
          
        case 'numpy':
          // Get the raw data
          handle.getRow=function (i) {
            i=Number(i);
            if (!handle.data)
              // read file row
              handle.readRow(i);
            if (handle.data && i<handle.data.rows) {
              return handle.data.getRow(i,true,true);
            }
          }
          // Map data row to schema (main entry function) with type conversion
          // Optional keys argument sets schema key sub-set
          handle.mapRow=function (i,keys) {
            i=Number(i);
            var row = handle.getRow(i);
            if (!row) return;
            keys = keys || Object.keys(meta.schema);
            return self.map2sql(handle,i,row,keys);
          };
          // Read the raw data from file; the entire numpy data must be read
          handle.readRow = function (i) {
            i=Number(i);
            if (!handle.data) handle.data=self.open(handle,meta.data, 'r');
            if (!handle.data) throw self.error;
            handle.rows=Math.sequence(0,handle.data.rows-1);
          }
          break;
          
         case 'tiff':
          // Get the raw data
          handle.getRow=function (i) {
            i=Number(i);
            if (!handle.data)
              // read file row
              handle.readRow(i);
            if (handle.data && i<handle.data.rows) {
              return handle.data.getRow(i,true,true);
            }
          }
          // Map data row to schema (main entry function) with type conversion
          // Optional keys argument sets schema key sub-set
          handle.mapRow=function (i,keys) {
            i=Number(i);
            var row = handle.getRow(i);
            if (!row) return;
            keys = keys || Object.keys(meta.schema);
            return self.map2sql(handle,i,row,keys);
          };
          // Read the raw data from file; the entire numpy data must be read
          handle.readRow = function (i) {
            i=Number(i);
            if (!handle.data) handle.data=self.open(handle,meta.data, 'r');
            if (!handle.data) throw self.error;
            handle.rows=Math.sequence(0,handle.data.rows-1);
          }
          break;
     }
    } else if (meta.index=='$1($data)') {
      ///////////////////////////////
      // 2. Multi file/source mode //
      ///////////////////////////////
      
      switch (meta.type) {
        case 'numpy':
          handle.files=handle.indexTable=this.createIndex(handle);
          // Get the raw data (all data of file at once)
          handle.getRow=function (i) {
            i=Number(i);
            if (!handle.cache.get(i))
              // read file row
              handle.readRow(i);
            if (handle.cache.get(i)) {
              return handle.cache.get(i);
            }
          }
          // Map data row to schema (main entry function) with type conversion
          // Optional keys argument sets schema key sub-set
          handle.mapRow=function (i,keys) {
            i=Number(i);
            var row = handle.getRow(i);
            if (!row) return;
            keys = keys || Object.keys(meta.schema);
            return self.map2sql(handle,i,row,keys);
          };
          // Read the raw data from file; the entire numpy data must be read
          handle.readRow = function (i) {
            i=Number(i);
            if (!handle.cache.get(i)) handle.cache.set(i,self.open(handle,handle.indexTable[i], 'r'));
            if (!handle.cache.get(i)) throw self.error;
          }
          handle.rows=Math.sequence(0,handle.files.length-1);
          break;

        case 'tiff':
          handle.files=handle.indexTable=this.createIndex(handle);
          // Get the raw data (all data of file at once)
          handle.getRow=function (i) {
            i=Number(i);
            if (!handle.cache.get(i))
              // read file row
              handle.readRow(i);
            if (handle.cache.get(i)) {
              return handle.cache.get(i);
            }
          }
          // Map data row to schema (main entry function) with type conversion
          // Optional keys argument sets schema key sub-set
          handle.mapRow=function (i,keys) {
            i=Number(i);
            var row = handle.getRow(i);
            if (!row) return;
            keys = keys || Object.keys(meta.schema);
            return self.map2sql(handle,i,row,keys);
          };
          // Read the raw data from file; the entire numpy data must be read
          handle.readRow = function (i) {
            i=Number(i);
            if (!handle.cache.get(i)) handle.cache.set(i,self.open(handle,handle.indexTable[i], 'r'));
            if (!handle.cache.get(i)) throw self.error;
          }
          handle.rows=Math.sequence(0,handle.files.length-1);
          break;
      }
    }
  }
  if (meta.filter) {
    // console.log(meta.filter)
    var tokens = meta.filter.trim().match(/([\$a-zA-Z0-9]+)\(([^\)]+)\)/);
    if (tokens) {
      meta.filter={
        algorithm:tokens[1],
        arguments:tokens[2].split(',').map(Number)
      }
    }
  }
  if (meta.reference) {
    //////////////////////////
    // 3. Static table      //
    //////////////////////////
    // simple static table with content provided in meta file, typically wrapper around dynamic data tables

    handle.getRow=function (i) {
      i=Number(i);
      return handle.cache[i];
    }
    handle.mapRow=function (i,keys) {
      i=Number(i);
      var row = handle.getRow(i);
      if (!row) return;
      keys = keys || Object.keys(meta.schema);
      return self.map2sql(handle,i,row,keys);
    };
    if (meta.rows.loop) {
      // loop constructor
      if (meta.reference.loop=='$1($data)') {
        // TODO
        meta.index='$1($data)';
        var first,index = this.createIndex(handle);
        meta.rows = index.map(function (file,index)  {
          var replace = file.match(RegExp(meta.data))[1];
          if (!first) first=meta.reference.table.replace(/\$1/g,replace)
          return meta.rows.loop.map(function (col) {
            if (col=='*') {
              // TODO
            }
            return col.replace(/\$1/g,replace)
                      .replace(/\$row/,index); 
          });
        });
        // replace reference table pattern with the first matching data table
        meta.reference.table=first;
      }
    }
    handle.rows=Math.sequence(0,meta.rows.length-1);
    handle.cache = meta.rows.map(function (row) {
      // map array to record via schema
      var o={};
      Object.keys(meta.schema).map(function (key,index) {
        o[key]=row[index];
      });
      return o;
    });
    handle.reference=this.handleHash[meta.reference.table];
  }
  return handle;
}

// Create a row index of a table file
Database.prototype.createIndex = function (handle) {
  var meta=handle.meta,index = [],dir,pattern;
  if (meta.index=='$row($data)') {
    // single file
    switch (meta.type) {
      case 'json':
        if (!handle.fd) handle.fd=this.open(handle,meta.data, 'r');
        if (!handle.fd) throw this.error;
        // find [ >{ >}, >{ >} ]
        var b = Buffer(512), offset=0, n=1, brak=0, start, end, quotes1=false, quotes2=false;
        while (n) {
          var chunk;
          n=fs.readSync(handle.fd,b,0,512, offset);
          if (n<512) chunk=b.slice(0,n).toString();
          else chunk=b.toString();
          for(var i=0;i<chunk.length;i++) switch (chunk[i]) {
            case '"': if (!quotes2) quotes1=!quotes1; break;
            case "'": if (!quotes1) quotes2=!quotes2; break;
            case '{': if (quotes1 || quotes2) continue; if (brak==0) { start=offset+i; } brak++; break
            case '}': if (quotes1 || quotes2) continue; 
              if (brak==1) { end=offset+i; index.push([start,end]); if ((index.length % 500)==0) this.log(index.length); } brak--; break
          }
          offset += chunk.length;
        }
        break;
      case 'csv':
        if (!handle.fd) handle.fd=this.open(handle,meta.data, 'r');
        if (!handle.fd) throw this.error;
        // find \n
        var first=Buffer(512000),b = Buffer(512), offset=0, n=1, start=0;
        while (n) {
          var chunk;
          n=fs.readSync(handle.fd,b,0,512, offset);
          if (n<512) chunk=b.slice(0,n); //.toString();
          else chunk=b; // .toString();
          for(var i=0;i<chunk.length;i++) switch (chunk[i]) {
            case 0x0d: 
            case 0x0a:
              if ((offset+i) == start) { start++; continue; } // 0D 0A or vice versa pair 
              end=offset+i-1; 
              index.push([start,end]);
              if ((index.length % 500)==0) this.log(index.length);
              start=offset+i+1;  
              // if (chunk[i+1]=='0x0d' || chunk[i+1]=='0x0a') { i++; start++; }
              break;
            default:
              if (index.length==0) first[offset+i] = chunk[i]; break;
          }
          offset += chunk.length;
        }
        // no EOL at end of file?
        if (start < offset+i) {
          index.push([start,offset+i]); 
        }
        // Is first line the column header?
        if (meta.header) {
          var header = index.shift();
          meta.header = this.parseCSV(first.slice(0,header[1]+1).toString(),meta.separator);
          this.log('Found header: '+meta.header.length+' columns, found '+index.length+' rows.');
        }
        break;
      case 'numpy':
        // no indexd table; direct access of rows via MatrixTA.getRow()
        break;
    }
  } else if (meta.index=='$1($data)') {
    // multi files
    switch (meta.type) {
      case 'numpy':
      case 'tiff':
      case 'csv':
      case 'json':
      default:
        // index == filename
        var subdir = path.dirname(meta.data);
        dir = this.root+'/'+handle.meta.dir+'/'+subdir;
        pattern=RegExp(path.basename(meta.data));
        try { 
          var entries = fs.readdirSync(dir);
          entries.forEach(function (file) {
            if (pattern.test(file)) index.push((subdir?subdir+'/':'')+file);
          });
        } catch (e) { this.log(e); this.error=e }
        break;
    }  
  }
//print(index)
//print(meta)
  return index;
}

Database.prototype.dataspace = function (handle,index,withFiles) {
  var _handle = handle;
  if (handle.reference) { handle=handle.reference; index=0; handle.getRow(0); };
  var meta = handle.meta,ds=[];
  switch (meta.index) {
    case '$row($data)':
    case '$dim[0]($data)':
      switch (meta.type) {
        case 'json':
        case 'csv':   
          if (meta.index=='$row($data)')
            ds=[this.rows(handle),this.columns(handle,0)]; 
          else ds=[]; // TODO:
          break;
        case 'numpy': 
        case 'tiff': 
          if (meta.index=='$row($data)')
            ds=handle.data.dataspace;
          else ds=[]; // TODO:
          break;
      }
      break;
    case '$1($data)':
      switch (meta.type) {
        case 'numpy': 
        case 'tiff': 
        // needs index
        if (handle.cache.get(index)) ds=handle.cache.get(index).dataspace;
        else ds=[];
        break;
      }
      break;
  }
  if (withFiles) {
    // multi-file tables
    if (_handle.reference && _handle.reference.meta.index=='$1($data)')
      ds=[handle.rows.length].concat(ds);   // multi-file file-indexed table
    else  
      ds=[_handle.rows.length].concat(ds);  // single-file row-indexed table; parent is file-index
  }
  return ds;
}

Database.prototype.datatype = function (handle,index) {
  if (handle.reference) handle=handle.reference;
  var meta = handle.meta;
  switch (meta.index) {
    case '$row($data)':
    case '$dim[0]($data)':
      switch (meta.type) {
        case 'json':
        case 'csv':   
          return '*';
        case 'numpy': 
        case 'tiff': 
          if (meta.index=='$row($data)')
            return handle.data.datatype;
          else return '*'; // TODO:
      }
      break;
    case '$1($data)':
      switch (meta.type) {
        case 'numpy': 
        case 'tiff': 
        // need index
        if (handle.cache.get(index)) return handle.cache.get(index).datatype;
      }
      break;
  }      
}

Database.prototype.handle = function (table) {
  return this.handleHash[table];
}

Database.prototype.log = function (msg) {
  print('[SQLVFS] '+msg);
}

// Map one raw data row on schema elements,i.e., 
// format a SQL value according to supported SQL data formats
// Returns element array! Row is eitehr a record, an array, or binary data!
Database.prototype.map2sql = function (handle,index,row,keys) {
  var self=this,
      key2,
      meta=handle.meta;
// print(inspect(meta,null,8),keys)
// print(row)
  keys = keys || Object.keys(meta.schema);
  function isInt (t)        { return t.startsWith('int') };
  function isReal (t)       { return t.startsWith('real') };
  function isString (t)     { 
    return t.startsWith('text') || t.startsWith('char') ||
           t.startsWith('varchar')
  }
  function isArray (t)      { return t.startsWith('array') };
  function isBlob (t)       { return t.startsWith('blob') };
  function isObject(t)      { return t.startsWith('obj') };
  function isIntVal (v)     { return typeof v == 'number' }
  function isRealVal (v)    { return typeof v == 'number' }
  function isStringVal (v)  { return typeof v == 'string' }
  function isObjectVal (v)  { return typeof v == 'object' }
  
  function columnIndex(name) {
    if (!isNaN(Number(name))) return Number(name);
    if (meta.type=='csv') return meta.header.indexOf(name);
    else return name;
  }
  
  function mapValue(row,value,typ) {
    // print(row.value,typ)
    switch (value) {
      case '$file':         return handle.files?handle.files[index]:handle.file;
      case '$row($data)':   return isInt(typ)?Number(index):String(index);  // row index (of data); only backward comp.
      case '$index($row($data))':   return isInt(typ)?Number(index):String(index);  // row index (of data)
      case '$row':          return isInt(typ)?Number(index):String(index);  // row index (of file)
      case '$array($row($data))':   
        switch (meta.type) {
          case 'json':
          case 'csv':
            if (isString(typ)) {
              return JSON.stringify(row)
            }
          case 'numpy':
            if (isString(typ)) {
              // convert typedarray to array to text
              return JSON.stringify(row.toArray())
            }
        } 
        return;
      case '$object($row($data))':   
        switch (meta.type) {
          case 'json':
          case 'csv':
            if (isBlob(typ)) {
              return Buffer(JSON.stringify(row));              
            }
            if (isString(typ)) {
              return JSON.stringify(row);
            }
            return ;
        } 
        return;
      case '$typedarray($row($data))':   
        switch (meta.type) {
          case 'numpy':
          case 'tiff':
            if (isBlob(typ)) {
              // convert typedarray to blob
              return Buffer(row.data.buffer);
            }
            if (isString(typ)) {
              // convert typedarray to blob
              return row.data.toString();
            }
        } 
        return;
      case '$typedarray($data)':   
        if (meta.index=='$1($data)') switch (meta.type) {
          case 'numpy':
          case 'tiff':
            if (isBlob(typ)) {
              // convert typedarray to blob
              return Buffer(row.data.buffer);
            }
            if (isString(typ)) {
              // convert typedarray to blob
              return row.data.toString();
            }
        } 
        return;
      case '$dataspace($data)':   
        return isArray(typ)?self.dataspace(handle,index):
                            String(self.dataspace(handle,index));
      case '$dataspace($data*)': 
        return isArray(typ)?self.dataspace(handle,index,true):
                            String(self.dataspace(handle,index,true));
      case '$datatype($data)':    return String(self.datatype(handle,index));
      case '$rows($data)':        return isInt(typ)?self.rows(handle,index):String(self.rows(handle,index));
      case '$cols($data)':        return isInt(typ)?self.columns(handle,index):String(self.columns(handle,index));
      default:
        if (/[a-zA-Z0-9_ ]+\(\$row\(\$data\)\)/.test(value)) {
          // key mapping
          key2=value.replace(/\(\$row\(\$data\)\)/,'');
          //print(row,value,key2)
          if (isInt(typ) || isReal(typ)) return Number(row[columnIndex(key2)]);
          if (isString(typ)) {
            if (!isObjectVal(row[key2])) return String(row[columnIndex(key2)]);
            else {
              return this.stringify(row[columnIndex(key2)]);
            }
          }
        }
        switch (typ) {
          case 'text': /* constant text? */ return value.replace(/'/g,'').replace(/"/g,'');
          case 'int':
          case 'int unique':
          case 'real':
            /* constant number */
            return Number(value);
        }
    }
  }
  function mapRowElement(row,key,schema) {
    // value: schema target value
    var typ = meta.schema[key].type||'text',
        value = meta.schema[key].value;
    // print(row,key,value)
    if (!value && row[key] != undefined) value = row[key];
    if (isStringVal(value)) return mapValue(row,value,typ); else {
      // something like meta data
      var obj={}
      Object.keys(value).map(function (key2) {
        obj[key2]=mapValue(row,value[key2].value,value[key2].type);
      });
      return self.stringify(obj);
    }
    return null;
  }
  return keys.map(function (key) { return mapRowElement(row,key,meta.schema) });
}

Database.prototype.open = function (handle,file,mode) {
  var meta=handle.meta,data,out,filepath = this.root+'/'+handle.meta.dir+'/'+file;
  handle.file=file;
  switch (handle.meta.type) {
    case 'json':
    case 'csv':
      try {
        return fs.openSync(filepath,mode);
      } catch (e) { this.error=e; }
      return;
    case 'numpy':
      out=numpy.read(filepath,'MatrixTA');
      break;
    case 'tiff':
      data = fs.readFileSync(filepath); 
      var ifd = image.tiff.decode(data);
      image.tiff.decodeImage(data,ifd[0]);
      switch (meta.convert) {
        case 'GRAY8':
          data=image.tiff.toGRAY8(ifd[0]);
          out=Math.MatrixTA({
            dataspace:[ifd[0].width,ifd[0].height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:21
          });
          break;
        case 'RGB8':
        default:
          data=image.tiff.toRGB8(ifd[0]);
          out=Math.MatrixTA({
            dataspace:[ifd[0].width,ifd[0].height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:321
          });
      }
      break;
  }
  if (out && meta.filter && meta.filter.arguments) {
    out=out.convert(meta.filter.arguments[0],meta.filter.arguments[1],meta.filter.algorithm)
  }
  return out;
}

Database.prototype.parseCSV = function (text,separator) {
  var o;
  function unwrap(s) {
    return s.replace(/"/g,'')
  }
  try {
    o=text.split(separator||',').map(unwrap);
  } catch (e) { };
  return o;
}

Database.prototype.parseMeta = function (text) {
  var meta = yaml.eval(text);

  function expand (node) {
    if (typeof node == 'object') {
      Object.keys(node).forEach(function (key) {
        if (typeof node[key] == 'object') {
          // meta entry in meta
          if (node!=meta) {
            node[key]={
              type:'text',
              value : expand(node[key])
            }
            if (node[key].value._type) {
              node[key].type=node[key].value._type.type;
              node[key].format=node[key].value._type.value;
              delete node[key].value._type;
            }
          } else return expand(node[key])
        } else if (typeof node[key] == 'string') {
          var tokens = node[key].split('=');
          if (tokens.length==2) node[key]={
            type  : tokens[0].trim().toLowerCase(),
            value : tokens[0].trim().toLowerCase()=='text'?tokens[1].trim():tokens[1].trim().toLowerCase()
          }; else if (node!=meta && typeof node[key]=='string') {
             var list =  node[key].split(','); // static rows list???
             if (list.length>1) node[key]=list;
             else node[key]={type:node[key]};
          }
        } else if (typeof node[key] == 'boolean') {
          
        }
      });
    }
    return node;
  }
  expand(meta);
  return meta;  
}

Database.prototype.parseJSON = function (text) {
  var o;
  try {
    eval('o='+text);
  } catch (e) { };
  return o;
}

Database.prototype.prepare = function (cmd) {
  return this.compileQuery(cmd);
}

Database.prototype.pragma = function (cmd) {
 
}

Database.prototype.read = function (handle,offset,end) {
  switch (handle.meta.type) {
    case 'json':
    case 'csv':
      try {
        var result = fs.readSync(handle.fd,end-offset+1,offset);
        return result[0];
      } catch (e) { this.error = e; }
  }
}

Database.prototype.rows = function (handle,index) {
  var meta=handle.meta;
  switch (meta.index) {
    case '$row($data)':
    case '$dim[0]($data)':
      switch (meta.type) {
        case 'json':
        case 'csv':
          if (handle.indexTable) return handle.indexTable.length;
          else if (handle.data) return handle.data.rows;
          break;
        case 'numpy':
        case 'tiff':
          if (handle.data) return handle.data.rows;
          break;
      }
      break;
    case '$1($data)':
    case '$2($data)':
      switch (meta.type) {
        case 'json':
        case 'csv':
          break;
        case 'numpy':
        case 'tiff':
          // index?
          if (index!=undefined && handle.cache.get(index)) return  handle.cache.get(index).rows;
          else return handle.indexTable.length;
          break;
      }
      break;
  }
}

Database.prototype.run = function (cmd) {
  var handler = {};
}

Database.prototype.stringify = function (obj,format) {
  format=format||'json';
  switch (format) {
    case 'json':  return JSON.stringify(obj);
    case 'csv':   return obj.join(',');
    case 'yaml':  return yaml.stringify(obj);
  }
}

// Compile an SQL query and return a handler
Database.prototype.compileQuery = function (query) {
  var ast     = parser(query).statement[0],
      table   = ast.from && ast.from.name,
      handle  = this.handle(table),
      keys    = handle?Object.keys(handle.meta.schema):null,
      handler = {};
  if (this.verbose) print(query);
  if (!handle) return this.log('Table '+table+' not found!');
  // compare row columns with values 
  function equal(col,val) { 
    return col==val || col=='"'+val+'"'
  }
// print(handle)    
  // filter rows
  function filter(attr,val) {
    // TODO; have to read all rows!?
    // console.log(attr,val)
    if (handle.meta.table=='sqlite_master') {
      if (attr == 'type' && val=='table') 
        return handle.indexTable;
      if (attr == 'name') {
        for(var i in handle.rows) {
          var row = handle.getRow(handle.rows[i]);
          if (row && equal(row[attr],val)) return [handle.rows[i]];
        }      
      }
    }
    if (handle.meta.table=='sqlite_master' && attr == 'type' && val=='table') 
      return handle.indexTable; // sqlite_master???
    if (handle.reference) {
      // static wrapper table;
      // search all rows 
      for(var i in handle.rows) {
        var row = handle.getRow(handle.rows[i]);
        if (row && equal(row[attr],val)) return [handle.rows[i]];
      }
    }
  }
  var primaryKey='id';    // TODO
  
  function identifier(expr) {
    if (expr.type=='identifier') return expr.name;
  }
  
  // where expr evaluator (selecting rows)
  function expr(node) {
    switch (node.type) {
      case 'expression':
        switch (node.operation) {
          case '=':
            var id=expr(node.left);
            if (id=='row' || id==primaryKey) return [Number(expr(node.right))-1];
            if (handle.meta.schema[id]) {
              // unique==indexing key?
              if (handle.meta.schema[id].type.indexOf('unique')!=-1 ||
                  handle.meta.schema[id].value=='$row($data)') {
                return [expr(node.right)];
              } else {
                return filter(id,expr(node.right)); // TODO
              }
            } 
            break;
          case '<':
          case '>':
          case '<=':
          case '>=':
            // TODO
            var id=expr(node.left);
            if (id=='row' || id==primaryKey) {
              var limit=Number(expr(node.right));
              switch (node.operation) {
                case '<': return handle.rows.filter(function (i) { return i < limit });
                case '>': return handle.rows.filter(function (i) { return i > limit });
                case '<=': return handle.rows.filter(function (i) { return i <= limit });
                case '>=': return handle.rows.filter(function (i) { return i >= limit });
              }
            }
            break;
        }
        break;
      case 'identifier':
        return node.name
        break;
      case 'literal':
        return node.value
        break;
    }
  }
  if (ast.type=='statement') {
    // print('statement',ast.variant)
    // print(inspect(ast,null,16));
    switch (ast.variant) {
      case 'select':
// console.log(ast.result);
        if (ast.result && ast.result[0].type=='identifier') {
          handler={
            each : function (callback) {
              var cols = keys,
                  rows = handle.rows; // All rows
              if (ast.result) {
                if (ast.result[0].variant != 'star') {
                  // columns selection
                  cols = ast.result.map(function (col) {
                    return col.name;
                  });
                }
              }
              if (ast.where) {
                rows=expr(ast.where[0]);
              }
  //print('select -> rows',rows,cols);
              if (rows) rows.forEach(function (index) {
                var row = handle.mapRow(index,cols);
                var obj = {};
                cols.forEach(function (col,index) { obj[col]= row[index] });
  //print(row) 
                callback(obj);   
              });
            }
          }
        } else if (ast.result && ast.result[0].type=='function' && identifier(ast.result[0].name)=='count') {
          handler={
            each : function (callback) {
              var count=0,
                  rows = handle.rows; // All rows;
              if (ast.where) {
                rows=expr(ast.where[0]);
              }
              if (rows) count=rows.length;
              callback(count);
            }
          }
        }
        break;
    }
  }
  return handler;
}

// Create a SQL schema table signature
Database.prototype.schemaSQL = function (meta) {
  var schema=[];
  for(var key in meta.schema) {
    schema.push(key+' '+meta.schema[key].type)
  }
  return '('+schema.join(',')+')';
}

Database.prototype.test = function () {
  var handle = this.rootHandles[0];
  print(handle.getRow(1))
  print(handle.mapRow(1))
  print(inspect(parser('select * from mytable;').statement[0],null,10))
  print(inspect(parser('select * from mytable where id=2;').statement[0],null,10))
  this.compileQuery('select * from testdata01 where id=2;').each(print);
  this.compileQuery('select id,meta from testdata02 where id=2;').each(print);
  this.compileQuery('select * from testdata02 where id=2;').each(print);
  this.compileQuery('select * from testdata03 where id=1;').each(print);
}
Database.prototype.test2 = function () {
  this.compileQuery('select * from testdata05 where id=0;').each(print);
}
module.exports = Database;

};
BundleModuleCode['plugins/sql/sqlite-parser']=function (module,exports){
/*!
 * sqlite-parser - v1.0.1
 * @copyright 2015-2017 Code School (http://codeschool.com)
 * @author Nick Wronski <nick@javascript.com>
 * https://github.com/codeschool/sqlite-parser
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sqliteParser = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./streaming":[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var SqliteParserTransform=exports.SqliteParserTransform=function SqliteParserTransform(options){_classCallCheck(this,SqliteParserTransform);throw new Error('SqliteParserTransform is not available in this environment');};var SingleNodeTransform=exports.SingleNodeTransform=function SingleNodeTransform(options){_classCallCheck(this,SingleNodeTransform);throw new Error('SingleNodeTransform is not available in this environment');};

},{}],1:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.default=sqliteParser;var _parser=require('./parser');var _tracer=require('./tracer');var _streaming=require('./streaming');function sqliteParser(source,options,callback){var t=(0,_tracer.Tracer)();if(arguments.length===2){if(typeof options==='function'){callback=options;options={};}}var isAsync=typeof callback==='function';var opts={'tracer':t,'startRule':'start'};if(options&&options.streaming){opts['startRule']='start_streaming';}if(isAsync){setTimeout(function(){var result=void 0,err=void 0;try{result=(0,_parser.parse)(source,opts);}catch(e){err=e instanceof _parser.SyntaxError?t.smartError(e):e;}callback(err,result);},0);}else{try{return(0,_parser.parse)(source,opts);}catch(e){throw e instanceof _parser.SyntaxError?t.smartError(e):e;}}};sqliteParser['createParser']=function(){return new _streaming.SqliteParserTransform();};sqliteParser['createStitcher']=function(){return new _streaming.SingleNodeTransform();};sqliteParser['NAME']='sqlite-parser';sqliteParser['VERSION']='1.0.1';module.exports=exports['default'];

},{"./parser":2,"./streaming":"./streaming","./tracer":3}],2:[function(require,module,exports){
"use strict";var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};function peg$subclass(child,parent){function ctor(){this.constructor=child;}ctor.prototype=parent.prototype;child.prototype=new ctor();}function peg$SyntaxError(message,expected,found,location){this.message=message;this.expected=expected;this.found=found;this.location=location;this.name="SyntaxError";if(typeof Error.captureStackTrace==="function"){Error.captureStackTrace(this,peg$SyntaxError);}}peg$subclass(peg$SyntaxError,Error);peg$SyntaxError.buildMessage=function(expected,found){var DESCRIBE_EXPECTATION_FNS={literal:function literal(expectation){return"\""+literalEscape(expectation.text)+"\"";},"class":function _class(expectation){var escapedParts=expectation.parts.map(function(part){return Array.isArray(part)?classEscape(part[0])+"-"+classEscape(part[1]):classEscape(part);});return"["+(expectation.inverted?"^":"")+escapedParts+"]";},any:function any(expectation){return"any character";},end:function end(expectation){return"end of input";},other:function other(expectation){return expectation.description;}};function hex(ch){return ch.charCodeAt(0).toString(16).toUpperCase();}function literalEscape(s){return s.replace(/\\/g,"\\\\").replace(/"/g,"\\\"").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(ch){return"\\x0"+hex(ch);}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(ch){return"\\x"+hex(ch);});}function classEscape(s){return s.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(ch){return"\\x0"+hex(ch);}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(ch){return"\\x"+hex(ch);});}function describeExpectation(expectation){return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);}function describeExpected(expected){var descriptions=expected.map(describeExpectation);var i,j;descriptions.sort();if(descriptions.length>0){for(i=1,j=1;i<descriptions.length;i++){if(descriptions[i-1]!==descriptions[i]){descriptions[j]=descriptions[i];j++;}}descriptions.length=j;}switch(descriptions.length){case 1:return descriptions[0];case 2:return descriptions[0]+" or "+descriptions[1];default:return descriptions.slice(0,-1).join(", ")+", or "+descriptions[descriptions.length-1];}}function describeFound(found){return found?"\""+literalEscape(found)+"\"":"end of input";}return"Expected "+describeExpected(expected)+" but "+describeFound(found)+" found.";};function peg$DefaultTracer(){this.indentLevel=0;}peg$DefaultTracer.prototype.trace=function(event){var that=this;function log(event){function repeat(string,n){var result="",i;for(i=0;i<n;i++){result+=string;}return result;}function pad(string,length){return string+repeat(" ",length-string.length);}if((typeof console==="undefined"?"undefined":_typeof(console))==="object"){console.log(event.location.start.line+":"+event.location.start.column+"-"+event.location.end.line+":"+event.location.end.column+" "+pad(event.type,10)+" "+repeat("  ",that.indentLevel)+event.rule);}}switch(event.type){case"rule.enter":log(event);this.indentLevel++;break;case"rule.match":this.indentLevel--;log(event);break;case"rule.fail":this.indentLevel--;log(event);break;default:throw new Error("Invalid event type: "+event.type+".");}};function peg$parse(input,options){options=options!==undefined?options:{};var peg$FAILED={};var peg$startRuleIndices={start:0,start_streaming:1};var peg$startRuleIndex=0;var peg$consts=[function(s){return s;},function(f,b){return{'type':'statement','variant':'list','statement':flattenAll([f,b])};},function(s){return s;},peg$otherExpectation("Type Definition"),function(t,a){return Object.assign(t,a);},function(n){return{'type':'datatype','variant':n[0],'affinity':n[1]};},peg$otherExpectation("Custom Datatype Name"),function(t,r){var variant=foldStringKey([t,r]);var affinity='numeric';if(/int/i.test(variant)){affinity='integer';}else if(/char|clob|text/i.test(variant)){affinity='text';}else if(/blob/i.test(variant)){affinity='blob';}else if(/real|floa|doub/i.test(variant)){affinity='real';}return{'type':'datatype','variant':variant,'affinity':affinity};},/^[\t ]/,peg$classExpectation(["\t"," "],false,false),function(w){return w;},peg$otherExpectation("Type Definition Arguments"),function(a1,a2){return{'args':{'type':'expression','variant':'list','expression':flattenAll([a1,a2])}};},function(n){return n;},peg$otherExpectation("Null Literal"),function(n){return{'type':'literal','variant':'null','value':keyNode(n)};},peg$otherExpectation("Date Literal"),function(d){return{'type':'literal','variant':'date','value':keyNode(d)};},peg$otherExpectation("String Literal"),function(n,s){return{'type':'literal','variant':'text','value':s};},peg$otherExpectation("Single-quoted String Literal"),function(s){return unescape(s,"'");},"''",peg$literalExpectation("''",false),/^[^']/,peg$classExpectation(["'"],true,false),peg$otherExpectation("Blob Literal"),/^[x]/i,peg$classExpectation(["x"],false,true),function(b){return{'type':'literal','variant':'blob','value':b};},function(n){return{'type':'literal','variant':'text','value':n};},peg$otherExpectation("Number Sign"),function(s,n){if(isOkay(s)){n['value']=foldStringWord([s,n['value']]);}return n;},function(d,e){return{'type':'literal','variant':'decimal','value':foldStringWord([d,e])};},peg$otherExpectation("Decimal Literal"),function(f,b){return foldStringWord([f,b]);},function(t,d){return foldStringWord([t,d]);},peg$otherExpectation("Decimal Literal Exponent"),"e",peg$literalExpectation("E",true),/^[+\-]/,peg$classExpectation(["+","-"],false,false),function(e,s,d){return foldStringWord([e,s,d]);},peg$otherExpectation("Hexidecimal Literal"),"0x",peg$literalExpectation("0x",true),function(f,b){return{'type':'literal','variant':'hexidecimal','value':foldStringWord([f,b])};},/^[0-9a-f]/i,peg$classExpectation([["0","9"],["a","f"]],false,true),/^[0-9]/,peg$classExpectation([["0","9"]],false,false),peg$otherExpectation("Bind Parameter"),function(b){return Object.assign({'type':'variable'},b);},peg$otherExpectation("Numbered Bind Parameter"),function(q,id){return{'format':'numbered','name':foldStringWord([q,id])};},/^[1-9]/,peg$classExpectation([["1","9"]],false,false),function(f,r){return foldStringWord([f,r]);},peg$otherExpectation("Named Bind Parameter"),/^[:@]/,peg$classExpectation([":","@"],false,false),function(s,name){return{'format':'named','name':foldStringWord([s,name])};},peg$otherExpectation("TCL Bind Parameter"),"$",peg$literalExpectation("$",false),":",peg$literalExpectation(":",false),function(d,name,s){return Object.assign({'format':'tcl','name':foldStringWord([d,name])},s);},function(sfx){return{'suffix':sfx};},peg$otherExpectation("EXISTS Expression"),function(n,e){if(isOkay(n)){return{'type':'expression','format':'unary','variant':'exists','expression':e,'operator':keyNode(n)};}return e;},peg$otherExpectation("EXISTS Keyword"),function(n,x){return foldStringKey([n,x]);},peg$otherExpectation("RAISE Expression"),function(s,a){return Object.assign({'type':'expression','format':'unary','variant':keyNode(s),'expression':a},a);},peg$otherExpectation("RAISE Expression Arguments"),function(a){return Object.assign({'type':'error'},a);},peg$otherExpectation("IGNORE Keyword"),function(f){return{'action':keyNode(f)};},function(f,m){return{'action':keyNode(f),'message':m};},function(n){return n;},function(e,c){return Object.assign(c,{'expression':e});},function(op,e){return{'type':'expression','format':'unary','variant':'operation','expression':e,'operator':keyNode(op)};},peg$otherExpectation("COLLATE Expression"),function(c){return Object.assign({'type':'expression','format':'unary','variant':'operation','operator':'collate'},c);},function(f,rest){return composeBinary(f,rest);},function(i){return[null,i,null,{'type':'literal','variant':'null','value':'null'}];},"not ",peg$literalExpectation("NOT ",true),"null",peg$literalExpectation("NULL",true),function(){return'not';},function(){return'is';},peg$otherExpectation("CAST Expression"),function(s,e,a){return{'type':'expression','format':'unary','variant':keyNode(s),'expression':e,'as':a};},peg$otherExpectation("Type Alias"),function(d){return d;},peg$otherExpectation("CASE Expression"),function(t,e,w,s){return Object.assign({'type':'expression','variant':keyNode(t),'expression':flattenAll([w,s])},e);},function(e){return{'discriminant':e};},peg$otherExpectation("WHEN Clause"),function(s,w,t){return{'type':'condition','variant':keyNode(s),'condition':w,'consequent':t};},peg$otherExpectation("ELSE Clause"),function(s,e){return{'type':'condition','variant':keyNode(s),'consequent':e};},function(v,p){return Object.assign(p,{'left':v});},peg$otherExpectation("Comparison Expression"),function(n,m,e,x){return Object.assign({'type':'expression','format':'binary','variant':'operation','operation':foldStringKey([n,m]),'right':e},x);},peg$otherExpectation("ESCAPE Expression"),function(s,e){return{'escape':e};},peg$otherExpectation("BETWEEN Expression"),function(n,b,tail){return{'type':'expression','format':'binary','variant':'operation','operation':foldStringKey([n,b]),'right':tail};},function(f,rest){return composeBinary(f,[rest]);},function(n){return keyNode(n);},peg$otherExpectation("IN Expression"),function(n,i,e){return{'type':'expression','format':'binary','variant':'operation','operation':foldStringKey([n,i]),'right':e};},function(e){return e;},peg$otherExpectation("Expression List"),function(l){return{'type':'expression','variant':'list','expression':isOkay(l)?l:[]};},function(f,rest){return flattenAll([f,rest]);},peg$otherExpectation("Function Call"),function(n,a){return Object.assign({'type':'function','name':n},a);},peg$otherExpectation("Function Call Arguments"),function(s){return{'args':{'type':'identifier','variant':'star','name':s}};},function(d,e){return!isOkay(d)||e['expression'].length>0;},function(d,e){return{'args':Object.assign(e,d)};},function(s){return{'filter':keyNode(s)};},peg$otherExpectation("Error Message"),function(m){return m;},peg$otherExpectation("Statement"),function(m,s){return Object.assign(s,m);},peg$otherExpectation("QUERY PLAN"),function(e,q){return{'explain':isOkay(e)};},peg$otherExpectation("QUERY PLAN Keyword"),function(q,p){return foldStringKey([q,p]);},peg$otherExpectation("END Transaction Statement"),function(s,t){return{'type':'statement','variant':'transaction','action':'commit'};},peg$otherExpectation("BEGIN Transaction Statement"),function(s,m,t,n){return Object.assign({'type':'statement','variant':'transaction','action':'begin'},m,n);},function(t){return t;},function(m){return{'defer':keyNode(m)};},peg$otherExpectation("ROLLBACK Statement"),function(s,n){return Object.assign({'type':'statement','variant':'transaction','action':'rollback'},n);},peg$otherExpectation("TO Clause"),function(n){return{'savepoint':n};},function(s){return keyNode(s);},peg$otherExpectation("SAVEPOINT Statement"),function(s,n){return{'type':'statement','variant':s,'target':n};},peg$otherExpectation("RELEASE Statement"),function(s,a,n){return{'type':'statement','variant':keyNode(s),'target':n};},peg$otherExpectation("ALTER TABLE Statement"),function(s,n,e){return Object.assign({'type':'statement','variant':keyNode(s),'target':n},e);},peg$otherExpectation("ALTER TABLE Keyword"),function(a,t){return foldStringKey([a,t]);},peg$otherExpectation("RENAME TO Keyword"),function(s,n){return{'action':keyNode(s),'name':n};},peg$otherExpectation("ADD COLUMN Keyword"),function(s,d){return{'action':keyNode(s),'definition':d};},function(w,s){return Object.assign(s,w);},peg$otherExpectation("WITH Clause"),function(s,v,t){var recursive={'variant':isOkay(v)?'recursive':'common'};if(isArrayOkay(t)){t=t.map(function(elem){return Object.assign(elem,recursive);});}return{'with':t};},function(f,r){return flattenAll([f,r]);},peg$otherExpectation("Common Table Expression"),function(t,s){return Object.assign({'type':'expression','format':'table','variant':'common','target':t},s);},function(s){return{'expression':s};},function(w,s){return Object.assign(s,w);},peg$otherExpectation("ATTACH Statement"),function(a,b,e,n){return{'type':'statement','variant':keyNode(a),'target':n,'attach':e};},peg$otherExpectation("DETACH Statement"),function(d,b,n){return{'type':'statement','variant':keyNode(d),'target':n};},peg$otherExpectation("VACUUM Statement"),function(v,t){return Object.assign({'type':'statement','variant':'vacuum'},t);},function(t){return{'target':t};},peg$otherExpectation("ANALYZE Statement"),function(s,a){return Object.assign({'type':'statement','variant':keyNode(s)},a);},function(n){return{'target':n['name']};},peg$otherExpectation("REINDEX Statement"),function(a){return{'target':a['name']};},peg$otherExpectation("PRAGMA Statement"),function(s,n,v){return{'type':'statement','variant':keyNode(s),'target':n,'args':{'type':'expression','variant':'list','expression':v}};},function(v){return v;},function(v){return /^(yes|no|on|off|false|true|0|1)$/i.test(v);},function(v){return{'type':'literal','variant':'boolean','normalized':/^(yes|on|true|1)$/i.test(v)?'1':'0','value':v};},function(n){return keyNode(n);},function(n){return{'type':'identifier','variant':'name','name':n};},peg$otherExpectation("SELECT Statement"),function(s,o,l){return Object.assign(s,o,l);},peg$otherExpectation("ORDER BY Clause"),function(d){return{'order':d['result']};},peg$otherExpectation("LIMIT Clause"),function(s,e,d){return{'limit':Object.assign({'type':'expression','variant':'limit','start':e},d)};},peg$otherExpectation("OFFSET Clause"),function(o,e){return{'offset':e};},function(s,u){if(isArrayOkay(u)){return{'type':'statement','variant':'compound','statement':s,'compound':u};}else{return s;}},peg$otherExpectation("Union Operation"),function(c,s){return{'type':'compound','variant':c,'statement':s};},function(s,f,w,g){return Object.assign({'type':'statement','variant':'select'},s,f,w,g);},peg$otherExpectation("SELECT Results Clause"),function(d,t){return Object.assign({'result':t},d);},peg$otherExpectation("SELECT Results Modifier"),function(s){return{'distinct':true};},function(s){return{};},peg$otherExpectation("FROM Clause"),function(f,s){return{'from':s};},peg$otherExpectation("WHERE Clause"),function(f,e){return{'where':makeArray(e)};},peg$otherExpectation("GROUP BY Clause"),function(f,e,h){return Object.assign({'group':e},h);},peg$otherExpectation("HAVING Clause"),function(f,e){return{'having':e};},function(q,s){return{'type':'identifier','variant':'star','name':foldStringWord([q,s])};},function(n,s){return foldStringWord([n,s]);},function(e,a){return Object.assign(e,a);},function(f,t){if(isArrayOkay(t)){return{'type':'map','variant':'join','source':f,'map':t};}return f;},function(cl,c){return Object.assign(cl,c);},peg$otherExpectation("CROSS JOIN Operation"),function(n){return{'type':'join','variant':'cross join','source':n};},peg$otherExpectation("JOIN Operation"),function(o,n){return{'type':'join','variant':keyNode(o),'source':n};},function(n,l,a){return Object.assign({'type':'function','variant':'table','name':n,'args':l},a);},peg$otherExpectation("Qualified Table"),function(d,i){return Object.assign(d,i);},peg$otherExpectation("Qualified Table Identifier"),function(n,a){return Object.assign(n,a);},peg$otherExpectation("Qualfied Table Index"),function(s,n){return{'index':n};},function(n,i){return{'index':foldStringKey([n,i])};},peg$otherExpectation("SELECT Source"),function(l,a){return Object.assign(l,a);},peg$otherExpectation("Subquery"),function(s,a){return Object.assign(s,a);},peg$otherExpectation("Alias"),function(a,n){return{'alias':n};},peg$otherExpectation("JOIN Operator"),function(n,t,j){return foldStringKey([n,t,j]);},function(t,o){return foldStringKey([t,o]);},function(t){return keyNode(t);},peg$otherExpectation("JOIN Constraint"),function(c){return{'constraint':Object.assign({'type':'constraint','variant':'join'},c)};},peg$otherExpectation("Join ON Clause"),function(s,e){return{'format':keyNode(s),'on':e};},peg$otherExpectation("Join USING Clause"),function(s,e){return{'format':keyNode(s),'using':e};},peg$otherExpectation("VALUES Clause"),function(s,l){return{'type':'statement','variant':'select','result':l};},function(f,b){return{'result':flattenAll([f,b])};},function(i){return i;},peg$otherExpectation("Ordering Expression"),function(e,d){if(isOkay(d)){return Object.assign({'type':'expression','variant':'order','expression':e},d);}return e;},peg$otherExpectation("Star"),peg$otherExpectation("Fallback Type"),peg$otherExpectation("INSERT Statement"),function(k,t){return Object.assign({'type':'statement','variant':'insert'},k,t);},peg$otherExpectation("INSERT Keyword"),function(a,m){return Object.assign({'action':keyNode(a)},m);},peg$otherExpectation("REPLACE Keyword"),function(a){return{'action':keyNode(a)};},peg$otherExpectation("INSERT OR Modifier"),function(s,m){return{'or':keyNode(m)};},function(i,r){return Object.assign({'into':i},r);},peg$otherExpectation("INTO Clause"),function(s,t){return t;},peg$otherExpectation("INTO Keyword"),function(r){return{'result':r};},peg$otherExpectation("Column List"),function(f,b){return{'columns':flattenAll([f,b])};},function(c){return c;},peg$otherExpectation("Column Name"),function(n){return{'type':'identifier','variant':'column','name':n};},function(s,r){return r;},peg$otherExpectation("VALUES Keyword"),function(f,b){return flattenAll([f,b]);},peg$otherExpectation("Wrapped Expression List"),function(e){return e;},peg$otherExpectation("DEFAULT VALUES Clause"),function(d,v){return{'type':'values','variant':'default'};},peg$otherExpectation("Compound Operator"),peg$otherExpectation("UNION Operator"),function(s,a){return foldStringKey([s,a]);},function(a){return a;},peg$otherExpectation("UPDATE Statement"),function(s,f,t,u,w,o,l){return Object.assign({'type':'statement','variant':s,'into':t},f,u,w,o,l);},peg$otherExpectation("UPDATE Keyword"),peg$otherExpectation("UPDATE OR Modifier"),function(t){return{'or':keyNode(t)};},peg$otherExpectation("SET Clause"),function(c){return{'set':c};},peg$otherExpectation("Column Assignment"),function(f,e){return{'type':'assignment','target':f,'value':e};},peg$otherExpectation("DELETE Statement"),function(s,t,w,o,l){return Object.assign({'type':'statement','variant':s,'from':t},w,o,l);},peg$otherExpectation("DELETE Keyword"),peg$otherExpectation("CREATE Statement"),peg$otherExpectation("CREATE TABLE Statement"),function(s,ne,id,r){return Object.assign({'type':'statement','name':id},s,r,ne);},function(s,tmp,t){return Object.assign({'variant':s,'format':keyNode(t)},tmp);},function(t){return{'temporary':isOkay(t)};},peg$otherExpectation("IF NOT EXISTS Modifier"),function(i,n,e){return{'condition':makeArray({'type':'condition','variant':keyNode(i),'condition':{'type':'expression','variant':keyNode(e),'operator':foldStringKey([n,e])}})};},peg$otherExpectation("Table Definition"),function(s,t,r){return Object.assign({'definition':flattenAll([s,t])},r);},function(r,w){return{'optimization':[{'type':'optimization','value':foldStringKey([r,w])}]};},function(f){return f;},peg$otherExpectation("Column Definition"),function(n,t,c){return Object.assign({'type':'definition','variant':'column','name':n,'definition':isOkay(c)?c:[]},t);},peg$otherExpectation("Column Datatype"),function(t){return{'datatype':t};},peg$otherExpectation("Column Constraint"),function(n,c,ln){return Object.assign(c,n);},function(cl){return cl[cl.length-1];},peg$otherExpectation("CONSTRAINT Name"),function(n){return{'name':n};},peg$otherExpectation("FOREIGN KEY Column Constraint"),function(f){return Object.assign({'variant':'foreign key'},f);},peg$otherExpectation("PRIMARY KEY Column Constraint"),function(p,d,c,a){return Object.assign(p,c,d,a);},peg$otherExpectation("PRIMARY KEY Keyword"),function(s,k){return{'type':'constraint','variant':foldStringKey([s,k])};},peg$otherExpectation("AUTOINCREMENT Keyword"),function(a){return{'autoIncrement':true};},function(s,c){return Object.assign({'type':'constraint','variant':s},c);},peg$otherExpectation("UNIQUE Column Constraint"),peg$otherExpectation("NULL Column Constraint"),function(n,l){return foldStringKey([n,l]);},peg$otherExpectation("CHECK Column Constraint"),peg$otherExpectation("DEFAULT Column Constraint"),function(s,v){return{'type':'constraint','variant':keyNode(s),'value':v};},peg$otherExpectation("COLLATE Column Constraint"),function(c){return{'type':'constraint','variant':'collate','collate':c};},peg$otherExpectation("Table Constraint"),function(n,c,nl){return Object.assign({'type':'definition','variant':'constraint'},c,n);},peg$otherExpectation("CHECK Table Constraint"),function(c){return{'definition':makeArray(c)};},peg$otherExpectation("PRIMARY KEY Table Constraint"),function(k,c,t){return{'definition':makeArray(Object.assign(k,t,c[1])),'columns':c[0]};},function(s){return{'type':'constraint','variant':keyNode(s)};},function(p,k){return foldStringKey([p,k]);},peg$otherExpectation("UNIQUE Keyword"),function(u){return keyNode(u);},function(f,b){return[f].concat(b);},function(c){return c.map(function(_ref){var _ref2=_slicedToArray(_ref,1);var res=_ref2[0];return res;});},function(c){var auto=c.find(function(_ref3){var _ref4=_slicedToArray(_ref3,2);var res=_ref4[0];var a=_ref4[1];return isOkay(a);});return[c.map(function(_ref5){var _ref6=_slicedToArray(_ref5,2);var res=_ref6[0];var a=_ref6[1];return res;}),auto?auto[1]:null];},peg$otherExpectation("Indexed Column"),function(e,d,a){var res=e;if(isOkay(d)){res=Object.assign({'type':'expression','variant':'order','expression':e},d);}return[res,a];},peg$otherExpectation("Collation"),function(c){return{'collate':makeArray(c)};},peg$otherExpectation("Column Direction"),function(t){return{'direction':keyNode(t)};},function(s,t){return{'conflict':keyNode(t)};},peg$otherExpectation("ON CONFLICT Keyword"),function(o,c){return foldStringKey([o,c]);},function(k,c){return{'type':'constraint','variant':keyNode(k),'expression':c};},peg$otherExpectation("FOREIGN KEY Table Constraint"),function(k,l,c){return Object.assign({'definition':makeArray(Object.assign(k,c))},l);},peg$otherExpectation("FOREIGN KEY Keyword"),function(f,k){return{'type':'constraint','variant':foldStringKey([f,k])};},function(r,a,d){return Object.assign({'type':'constraint'},r,a,d);},peg$otherExpectation("REFERENCES Clause"),function(s,t){return{'references':t};},function(f,b){return{'action':flattenAll([f,b])};},peg$otherExpectation("FOREIGN KEY Action Clause"),function(m,a,n){return{'type':'action','variant':keyNode(m),'action':keyNode(n)};},peg$otherExpectation("FOREIGN KEY Action"),function(s,v){return foldStringKey([s,v]);},function(c){return keyNode(c);},function(n,a){return foldStringKey([n,a]);},function(m,n){return{'type':'action','variant':keyNode(m),'action':n};},peg$otherExpectation("DEFERRABLE Clause"),function(n,d,i){return{'defer':foldStringKey([n,d,i])};},function(i,d){return foldStringKey([i,d]);},function(s){return{'definition':makeArray(s)};},peg$otherExpectation("CREATE INDEX Statement"),function(s,ne,n,o,w){return Object.assign({'type':'statement','target':n,'on':o},s,ne,w);},function(s,u,i){return Object.assign({'variant':keyNode(s),'format':keyNode(i)},u);},function(u){return{'unique':true};},peg$otherExpectation("ON Clause"),function(o,t,c){return{'type':'identifier','variant':'expression','format':'table','name':t['name'],'columns':c};},peg$otherExpectation("CREATE TRIGGER Statement"),function(s,ne,n,cd,o,me,wh,a){return Object.assign({'type':'statement','target':n,'on':o,'event':cd,'by':isOkay(me)?me:'row','action':makeArray(a)},s,ne,wh);},function(s,tmp,t){return Object.assign({'variant':keyNode(s),'format':keyNode(t)},tmp);},peg$otherExpectation("Conditional Clause"),function(m,d){return Object.assign({'type':'event'},m,d);},function(m){return{'occurs':keyNode(m)};},function(i,o){return foldStringKey([i,o]);},peg$otherExpectation("Conditional Action"),function(o){return{'event':keyNode(o)};},function(s,f){return{'event':keyNode(s),'of':f};},function(s,c){return c;},"statement",peg$literalExpectation("STATEMENT",true),function(f,e,r){return keyNode(r);},function(w,e){return{'when':e};},peg$otherExpectation("Actions Clause"),function(s,a,e){return a;},function(l){return l;},peg$otherExpectation("CREATE VIEW Statement"),function(s,ne,n,r){return Object.assign({'type':'statement','target':n,'result':r},s,ne);},function(n,a){return Object.assign({'type':'identifier','variant':'expression','format':'view','name':n['name'],'columns':[]},a);},function(s,tmp,v){return Object.assign({'variant':keyNode(s),'format':keyNode(v)},tmp);},peg$otherExpectation("CREATE VIRTUAL TABLE Statement"),function(s,ne,n,m){return Object.assign({'type':'statement','target':n,'result':m},s,ne);},function(s,v,t){return{'variant':keyNode(s),'format':keyNode(v)};},function(m,a){return Object.assign({'type':'module','variant':'virtual','name':m},a);},peg$otherExpectation("Module Arguments"),function(l){return{'args':{'type':'expression','variant':'list','expression':isOkay(l)?l:[]}};},function(f,b){return flattenAll([f,b]).filter(function(arg){return isOkay(arg);});},function(a){return a;},peg$otherExpectation("DROP Statement"),function(s,q){return Object.assign({'type':'statement','target':Object.assign(q,{'variant':s['format']})},s);},peg$otherExpectation("DROP Keyword"),function(s,t,i){return Object.assign({'variant':keyNode(s),'format':t,'condition':[]},i);},peg$otherExpectation("DROP Type"),peg$otherExpectation("IF EXISTS Keyword"),function(i,e){return{'condition':[{'type':'condition','variant':keyNode(i),'condition':{'type':'expression','variant':keyNode(e),'operator':keyNode(e)}}]};},peg$otherExpectation("Or"),peg$otherExpectation("Add"),peg$otherExpectation("Subtract"),peg$otherExpectation("Multiply"),peg$otherExpectation("Divide"),peg$otherExpectation("Modulo"),peg$otherExpectation("Shift Left"),peg$otherExpectation("Shift Right"),peg$otherExpectation("Logical AND"),peg$otherExpectation("Logical OR"),peg$otherExpectation("Less Than"),peg$otherExpectation("Greater Than"),peg$otherExpectation("Less Than Or Equal"),peg$otherExpectation("Greater Than Or Equal"),peg$otherExpectation("Equal"),peg$otherExpectation("Not Equal"),peg$otherExpectation("IS"),function(i,n){return foldStringKey([i,n]);},peg$otherExpectation("Identifier"),peg$otherExpectation("Database Identifier"),function(n){return{'type':'identifier','variant':'database','name':n};},peg$otherExpectation("Function Identifier"),function(d,n){return{'type':'identifier','variant':'function','name':foldStringWord([d,n])};},peg$otherExpectation("Table Identifier"),function(d,n){return{'type':'identifier','variant':'table','name':foldStringWord([d,n])};},function(n,d){return foldStringWord([n,d]);},peg$otherExpectation("Column Identifier"),function(q,n){return{'type':'identifier','variant':'column','name':foldStringWord([q,n])};},function(){return'';},function(d,t){return foldStringWord([d,t]);},peg$otherExpectation("Collation Identifier"),function(n){return{'type':'identifier','variant':'collation','name':n};},peg$otherExpectation("Savepoint Identifier"),function(n){return{'type':'identifier','variant':'savepoint','name':n};},peg$otherExpectation("Index Identifier"),function(d,n){return{'type':'identifier','variant':'index','name':foldStringWord([d,n])};},peg$otherExpectation("Trigger Identifier"),function(d,n){return{'type':'identifier','variant':'trigger','name':foldStringWord([d,n])};},peg$otherExpectation("View Identifier"),function(d,n){return{'type':'identifier','variant':'view','name':foldStringWord([d,n])};},peg$otherExpectation("Pragma Identifier"),function(d,n){return{'type':'identifier','variant':'pragma','name':foldStringWord([d,n])};},peg$otherExpectation("CTE Identifier"),function(d){return d;},function(n,a){return Object.assign({'type':'identifier','variant':'expression','format':'table','name':n['name'],'columns':[]},a);},peg$otherExpectation("Table Constraint Identifier"),function(n){return{'type':'identifier','variant':'constraint','format':'table','name':n};},peg$otherExpectation("Column Constraint Identifier"),function(n){return{'type':'identifier','variant':'constraint','format':'column','name':n};},peg$otherExpectation("Datatype Name"),function(t){return[t,'text'];},function(t){return[t,'real'];},function(t){return[t,'numeric'];},function(t){return[t,'integer'];},function(t){return[t,'none'];},peg$otherExpectation("TEXT Datatype Name"),"n",peg$literalExpectation("N",true),"var",peg$literalExpectation("VAR",true),"char",peg$literalExpectation("CHAR",true),"tiny",peg$literalExpectation("TINY",true),"medium",peg$literalExpectation("MEDIUM",true),"long",peg$literalExpectation("LONG",true),"text",peg$literalExpectation("TEXT",true),"clob",peg$literalExpectation("CLOB",true),peg$otherExpectation("REAL Datatype Name"),"float",peg$literalExpectation("FLOAT",true),"real",peg$literalExpectation("REAL",true),peg$otherExpectation("DOUBLE Datatype Name"),"double",peg$literalExpectation("DOUBLE",true),"precision",peg$literalExpectation("PRECISION",true),function(d,p){return foldStringWord([d,p]);},peg$otherExpectation("NUMERIC Datatype Name"),"numeric",peg$literalExpectation("NUMERIC",true),"decimal",peg$literalExpectation("DECIMAL",true),"boolean",peg$literalExpectation("BOOLEAN",true),"date",peg$literalExpectation("DATE",true),"time",peg$literalExpectation("TIME",true),"stamp",peg$literalExpectation("STAMP",true),"string",peg$literalExpectation("STRING",true),peg$otherExpectation("INTEGER Datatype Name"),"int",peg$literalExpectation("INT",true),"2",peg$literalExpectation("2",false),"4",peg$literalExpectation("4",false),"8",peg$literalExpectation("8",false),"eger",peg$literalExpectation("EGER",true),"big",peg$literalExpectation("BIG",true),"small",peg$literalExpectation("SMALL",true),"floating",peg$literalExpectation("FLOATING",true),"point",peg$literalExpectation("POINT",true),function(f,p){return foldStringWord([f,p]);},peg$otherExpectation("BLOB Datatype Name"),"blob",peg$literalExpectation("BLOB",true),/^[a-z0-9$_]/i,peg$classExpectation([["a","z"],["0","9"],"$","_"],false,true),"\\u",peg$literalExpectation("\\u",false),/^[a-f0-9]/i,peg$classExpectation([["a","f"],["0","9"]],false,true),function(u,s){return foldStringWord([u,s]).toLowerCase();},function(n){return keyNode(n);},peg$anyExpectation(),function(n){return textNode(n);},/^[ \t]/,peg$classExpectation([" ","\t"],false,false),"\"",peg$literalExpectation("\"",false),"\"\"",peg$literalExpectation("\"\"",false),/^[^"]/,peg$classExpectation(["\""],true,false),function(n){return unescape(n,'"');},"'",peg$literalExpectation("'",false),function(n){return unescape(n,"'");},"`",peg$literalExpectation("`",false),"``",peg$literalExpectation("``",false),/^[^`]/,peg$classExpectation(["`"],true,false),function(n){return unescape(n,'`');},peg$otherExpectation("Open Bracket"),"[",peg$literalExpectation("[",false),peg$otherExpectation("Close Bracket"),"]",peg$literalExpectation("]",false),peg$otherExpectation("Open Parenthesis"),"(",peg$literalExpectation("(",false),peg$otherExpectation("Close Parenthesis"),")",peg$literalExpectation(")",false),peg$otherExpectation("Comma"),",",peg$literalExpectation(",",false),peg$otherExpectation("Period"),".",peg$literalExpectation(".",false),peg$otherExpectation("Asterisk"),"*",peg$literalExpectation("*",false),peg$otherExpectation("Question Mark"),"?",peg$literalExpectation("?",false),peg$otherExpectation("Single Quote"),peg$otherExpectation("Double Quote"),peg$otherExpectation("Backtick"),peg$otherExpectation("Tilde"),"~",peg$literalExpectation("~",false),peg$otherExpectation("Plus"),"+",peg$literalExpectation("+",false),peg$otherExpectation("Minus"),"-",peg$literalExpectation("-",false),"=",peg$literalExpectation("=",false),peg$otherExpectation("Ampersand"),"&",peg$literalExpectation("&",false),peg$otherExpectation("Pipe"),"|",peg$literalExpectation("|",false),"%",peg$literalExpectation("%",false),"<",peg$literalExpectation("<",false),">",peg$literalExpectation(">",false),peg$otherExpectation("Exclamation"),"!",peg$literalExpectation("!",false),peg$otherExpectation("Semicolon"),";",peg$literalExpectation(";",false),peg$otherExpectation("Colon"),peg$otherExpectation("Forward Slash"),"/",peg$literalExpectation("/",false),peg$otherExpectation("Backslash"),"\\",peg$literalExpectation("\\",false),"abort",peg$literalExpectation("ABORT",true),"action",peg$literalExpectation("ACTION",true),"add",peg$literalExpectation("ADD",true),"after",peg$literalExpectation("AFTER",true),"all",peg$literalExpectation("ALL",true),"alter",peg$literalExpectation("ALTER",true),"analyze",peg$literalExpectation("ANALYZE",true),"and",peg$literalExpectation("AND",true),"as",peg$literalExpectation("AS",true),"asc",peg$literalExpectation("ASC",true),"attach",peg$literalExpectation("ATTACH",true),"autoincrement",peg$literalExpectation("AUTOINCREMENT",true),"before",peg$literalExpectation("BEFORE",true),"begin",peg$literalExpectation("BEGIN",true),"between",peg$literalExpectation("BETWEEN",true),"by",peg$literalExpectation("BY",true),"cascade",peg$literalExpectation("CASCADE",true),"case",peg$literalExpectation("CASE",true),"cast",peg$literalExpectation("CAST",true),"check",peg$literalExpectation("CHECK",true),"collate",peg$literalExpectation("COLLATE",true),"column",peg$literalExpectation("COLUMN",true),"commit",peg$literalExpectation("COMMIT",true),"conflict",peg$literalExpectation("CONFLICT",true),"constraint",peg$literalExpectation("CONSTRAINT",true),"create",peg$literalExpectation("CREATE",true),"cross",peg$literalExpectation("CROSS",true),"current_date",peg$literalExpectation("CURRENT_DATE",true),"current_time",peg$literalExpectation("CURRENT_TIME",true),"current_timestamp",peg$literalExpectation("CURRENT_TIMESTAMP",true),"database",peg$literalExpectation("DATABASE",true),"default",peg$literalExpectation("DEFAULT",true),"deferrable",peg$literalExpectation("DEFERRABLE",true),"deferred",peg$literalExpectation("DEFERRED",true),"delete",peg$literalExpectation("DELETE",true),"desc",peg$literalExpectation("DESC",true),"detach",peg$literalExpectation("DETACH",true),"distinct",peg$literalExpectation("DISTINCT",true),"drop",peg$literalExpectation("DROP",true),"each",peg$literalExpectation("EACH",true),"else",peg$literalExpectation("ELSE",true),"end",peg$literalExpectation("END",true),"escape",peg$literalExpectation("ESCAPE",true),"except",peg$literalExpectation("EXCEPT",true),"exclusive",peg$literalExpectation("EXCLUSIVE",true),"exists",peg$literalExpectation("EXISTS",true),"explain",peg$literalExpectation("EXPLAIN",true),"fail",peg$literalExpectation("FAIL",true),"for",peg$literalExpectation("FOR",true),"foreign",peg$literalExpectation("FOREIGN",true),"from",peg$literalExpectation("FROM",true),"full",peg$literalExpectation("FULL",true),"glob",peg$literalExpectation("GLOB",true),"group",peg$literalExpectation("GROUP",true),"having",peg$literalExpectation("HAVING",true),"if",peg$literalExpectation("IF",true),"ignore",peg$literalExpectation("IGNORE",true),"immediate",peg$literalExpectation("IMMEDIATE",true),"in",peg$literalExpectation("IN",true),"index",peg$literalExpectation("INDEX",true),"indexed",peg$literalExpectation("INDEXED",true),"initially",peg$literalExpectation("INITIALLY",true),"inner",peg$literalExpectation("INNER",true),"insert",peg$literalExpectation("INSERT",true),"instead",peg$literalExpectation("INSTEAD",true),"intersect",peg$literalExpectation("INTERSECT",true),"into",peg$literalExpectation("INTO",true),"is",peg$literalExpectation("IS",true),"isnull",peg$literalExpectation("ISNULL",true),"join",peg$literalExpectation("JOIN",true),"key",peg$literalExpectation("KEY",true),"left",peg$literalExpectation("LEFT",true),"like",peg$literalExpectation("LIKE",true),"limit",peg$literalExpectation("LIMIT",true),"match",peg$literalExpectation("MATCH",true),"natural",peg$literalExpectation("NATURAL",true),"no",peg$literalExpectation("NO",true),"not",peg$literalExpectation("NOT",true),"notnull",peg$literalExpectation("NOTNULL",true),"of",peg$literalExpectation("OF",true),"offset",peg$literalExpectation("OFFSET",true),"on",peg$literalExpectation("ON",true),"or",peg$literalExpectation("OR",true),"order",peg$literalExpectation("ORDER",true),"outer",peg$literalExpectation("OUTER",true),"plan",peg$literalExpectation("PLAN",true),"pragma",peg$literalExpectation("PRAGMA",true),"primary",peg$literalExpectation("PRIMARY",true),"query",peg$literalExpectation("QUERY",true),"raise",peg$literalExpectation("RAISE",true),"recursive",peg$literalExpectation("RECURSIVE",true),"references",peg$literalExpectation("REFERENCES",true),"regexp",peg$literalExpectation("REGEXP",true),"reindex",peg$literalExpectation("REINDEX",true),"release",peg$literalExpectation("RELEASE",true),"rename",peg$literalExpectation("RENAME",true),"replace",peg$literalExpectation("REPLACE",true),"restrict",peg$literalExpectation("RESTRICT",true),"right",peg$literalExpectation("RIGHT",true),"rollback",peg$literalExpectation("ROLLBACK",true),"row",peg$literalExpectation("ROW",true),"rowid",peg$literalExpectation("ROWID",true),"savepoint",peg$literalExpectation("SAVEPOINT",true),"select",peg$literalExpectation("SELECT",true),"set",peg$literalExpectation("SET",true),"table",peg$literalExpectation("TABLE",true),"temp",peg$literalExpectation("TEMP",true),"temporary",peg$literalExpectation("TEMPORARY",true),"then",peg$literalExpectation("THEN",true),"to",peg$literalExpectation("TO",true),"transaction",peg$literalExpectation("TRANSACTION",true),"trigger",peg$literalExpectation("TRIGGER",true),"union",peg$literalExpectation("UNION",true),"unique",peg$literalExpectation("UNIQUE",true),"update",peg$literalExpectation("UPDATE",true),"using",peg$literalExpectation("USING",true),"vacuum",peg$literalExpectation("VACUUM",true),"values",peg$literalExpectation("VALUES",true),"view",peg$literalExpectation("VIEW",true),"virtual",peg$literalExpectation("VIRTUAL",true),"when",peg$literalExpectation("WHEN",true),"where",peg$literalExpectation("WHERE",true),"with",peg$literalExpectation("WITH",true),"without",peg$literalExpectation("WITHOUT",true),function(r){return keyNode(r);},function(){return null;},peg$otherExpectation("Line Comment"),"--",peg$literalExpectation("--",false),/^[\n\v\f\r]/,peg$classExpectation(["\n","\v","\f","\r"],false,false),peg$otherExpectation("Block Comment"),"/*",peg$literalExpectation("/*",false),"*/",peg$literalExpectation("*/",false),/^[\n\v\f\r\t ]/,peg$classExpectation(["\n","\v","\f","\r","\t"," "],false,false),peg$otherExpectation("Whitespace"),"__TODO__",peg$literalExpectation("__TODO__",false)];var peg$bytecode=[peg$decode("%;\u023F/H#;#/?$;\".\" &\"/1$;#/($8$: $!!)($'#(#'#(\"'#&'#"),peg$decode("%;\u023F/C#;#/:$;x/1$;#/($8$: $!!)($'#(#'#(\"'#&'#"),peg$decode("%;x/B#;\u023F/9$$;%0#*;%&/)$8#:!#\"\" )(#'#(\"'#&'#"),peg$decode("$;\u01B30#*;\u01B3&"),peg$decode("$;\u01B3/&#0#*;\u01B3&&&#"),peg$decode("%;$/:#;x/1$;\u023F/($8#:\"#!!)(#'#(\"'#&'#"),peg$decode("<%;'.# &;(/@#;\u023F/7$;*.\" &\"/)$8#:$#\"\" )(#'#(\"'#&'#=.\" 7#"),peg$decode("%;\u018B/' 8!:%!! )"),peg$decode("<%;\u0195/9#$;)0#*;)&/)$8\":'\"\"! )(\"'#&'#=.\" 7&"),peg$decode("%4(\"\"5!7)/1#;\u0197/($8\":*\"! )(\"'#&'#"),peg$decode("<%;\u01A0/R#;5/I$;\u023F/@$;+.\" &\"/2$;\u01A1/)$8%:,%\"#!)(%'#($'#(#'#(\"'#&'#=.\" 7+"),peg$decode("%;\u01A2/C#;\u023F/:$;5/1$;\u023F/($8$:-$!!)($'#(#'#(\"'#&'#"),peg$decode(";5.; &;6.5 &;2./ &;-.) &;..# &;/"),peg$decode("<%;\u0206/1#;\u023F/($8\":/\"!!)(\"'#&'#=.\" 7."),peg$decode("<%;\u01D2.) &;\u01D4.# &;\u01D3/1#;\u023F/($8\":1\"!!)(\"'#&'#=.\" 70"),peg$decode("<%;4.\" &\"/2#;0/)$8\":3\"\"! )(\"'#&'#=.\" 72"),peg$decode("<%;\u01A6/A#$;10#*;1&/1$;\u01A6/($8#:5#!!)(#'#(\"'#&'#=.\" 74"),peg$decode("26\"\"6677.) &48\"\"5!79"),peg$decode("<%4;\"\"5!7</1#;0/($8\":=\"! )(\"'#&'#=.\" 7:"),peg$decode("%;\u0197.# &;\u019B/' 8!:>!! )"),peg$decode("<%;\u01AA.# &;\u01AB/' 8!:\"!! )=.\" 7?"),peg$decode("%;4.\" &\"/2#;6/)$8\":@\"\"! )(\"'#&'#"),peg$decode(";<.# &;7"),peg$decode("%;8/7#;;.\" &\"/)$8\":A\"\"! )(\"'#&'#"),peg$decode("<;9.# &;:=.\" 7B"),peg$decode("%$;>/&#0#*;>&&&#/7#;:.\" &\"/)$8\":C\"\"! )(\"'#&'#"),peg$decode("%;\u01A3/9#$;>0#*;>&/)$8\":D\"\"! )(\"'#&'#"),peg$decode("<%3F\"\"5!7G/T#4H\"\"5!7I.\" &\"/@$$;>/&#0#*;>&&&#/*$8#:J##\"! )(#'#(\"'#&'#=.\" 7E"),peg$decode("<%3L\"\"5\"7M/?#$;=/&#0#*;=&&&#/)$8\":N\"\"! )(\"'#&'#=.\" 7K"),peg$decode("4O\"\"5!7P"),peg$decode("4Q\"\"5!7R"),peg$decode("<%;@.) &;B.# &;C/' 8!:T!! )=.\" 7S"),peg$decode("<%;\u01A5/@#;A.\" &\"/2$;\u023F/)$8#:V#\"\"!)(#'#(\"'#&'#=.\" 7U"),peg$decode("%4W\"\"5!7X/9#$;>0#*;>&/)$8\":Y\"\"! )(\"'#&'#"),peg$decode("<%4[\"\"5!7\\/H#$;\u0193/&#0#*;\u0193&&&#/2$;\u023F/)$8#:]#\"\"!)(#'#(\"'#&'#=.\" 7Z"),peg$decode("<%2_\"\"6_7`/o#$;\u0193.) &2a\"\"6a7b/2#0/*;\u0193.) &2a\"\"6a7b&&&#/A$;\u023F/8$;D.\" &\"/*$8$:c$##\" )($'#(#'#(\"'#&'#=.\" 7^"),peg$decode("%;\u019B/1#;\u023F/($8\":d\"!!)(\"'#&'#"),peg$decode("<%;F.\" &\"/;#;\u023F/2$;\x94/)$8#:f#\"\" )(#'#(\"'#&'#=.\" 7e"),peg$decode("<%;k.\" &\"/;#;\u01E4/2$;\u023F/)$8#:h#\"\"!)(#'#(\"'#&'#=.\" 7g"),peg$decode("<%;\u0211/_#;\u023F/V$;\u01A0/M$;\u023F/D$;H/;$;\u023F/2$;\u01A1/)$8':j'\"&\")(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7i"),peg$decode("<%;I.# &;J/' 8!:l!! )=.\" 7k"),peg$decode("<%;\u01EF/' 8!:n!! )=.\" 7m"),peg$decode("%;\u021B.) &;\u01B7.# &;\u01E6/M#;\u023F/D$;\u01A2/;$;\u023F/2$;w/)$8%:o%\"$ )(%'#($'#(#'#(\"'#&'#"),peg$decode(";?./ &;t.) &;,.# &;\u017D"),peg$decode("%;\u01A0/L#;\u023F/C$;p/:$;\u023F/1$;\u01A1/($8%:p%!\")(%'#($'#(#'#(\"'#&'#"),peg$decode(";L.; &;E.5 &;_./ &;a.) &;G.# &;K"),peg$decode("%;M/;#;\u023F/2$;Q/)$8#:q#\"\" )(#'#(\"'#&'#.# &;M"),peg$decode("%;P/A#;\u023F/8$;N.# &;p/)$8#:r#\"\" )(#'#(\"'#&'#.# &;N"),peg$decode(";\u01A9.U &;\u01AB.O &;\u01AA.I &%%;k/8#%<;\u01E4=.##&&!&'#/#$+\")(\"'#&'#/\"!&,)"),peg$decode("<%;\u012D/' 8!:t!! )=.\" 7s"),peg$decode("%;O/\x83#$%;\u023F/>#;\u0166/5$;\u023F/,$;O/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;\u0166/5$;\u023F/,$;O/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode("%;R/\x83#$%;\u023F/>#;T/5$;\u023F/,$;R/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;T/5$;\u023F/,$;R/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode(";\u0169.) &;\u016A.# &;\u016B"),peg$decode("%;S/\x83#$%;\u023F/>#;V/5$;\u023F/,$;S/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;V/5$;\u023F/,$;S/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode(";\u0167.# &;\u0168"),peg$decode("%;U/\x83#$%;\u023F/>#;X/5$;\u023F/,$;U/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;X/5$;\u023F/,$;U/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode(";\u016C.U &;\u016D.O &;\u016E.I &%%;\u016F/8#%<;\u016F=.##&&!&'#/#$+\")(\"'#&'#/\"!&,)"),peg$decode("%;W/\x83#$%;\u023F/>#;Z/5$;\u023F/,$;W/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;Z/5$;\u023F/,$;W/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode(";\u0172.{ &;\u0173.u &%%;\u0170/8#%<;X=.##&&!&'#/#$+\")(\"'#&'#/\"!&,).I &%%;\u0171/8#%<;X=.##&&!&'#/#$+\")(\"'#&'#/\"!&,)"),peg$decode("%;Y/9#$;\\0#*;\\&/)$8\":u\"\"! )(\"'#&'#"),peg$decode("%;\u023F/1#;]/($8\":v\"! )(\"'#&'#.H &%;\u023F/>#;^/5$;\u023F/,$;Y/#$+$)($'#(#'#(\"'#&'#"),peg$decode("%3w\"\"5$7x/?#;\u023F/6$3y\"\"5$7z/'$8#:{# )(#'#(\"'#&'#.? &%;\u01FB/& 8!:|! ).. &%;\u0205/& 8!:{! )"),peg$decode(";\u0177./ &;\u0175.) &;\u0176.# &;\u0174"),peg$decode("<%;\u01C9/i#;\u023F/`$;\u01A0/W$;p/N$;\u023F/E$;`/<$;\u023F/3$;\u01A1/*$8(:~(#'$\")(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7}"),peg$decode("<%;\u01BF/:#;\u023F/1$;&/($8#:\x80#! )(#'#(\"'#&'#=.\" 7\x7F"),peg$decode("<%;\u01C8/\x93#;\u023F/\x8A$;b.\" &\"/|$;\u023F/s$$;c/&#0#*;c&&&#/]$;\u023F/T$;d.\" &\"/F$;\u023F/=$;\u01E0/4$;\u023F/+$8*:\x82*$)'%#)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x81"),peg$decode("%%<;\u0230=.##&&!&'#/1#;p/($8\":\x83\"! )(\"'#&'#"),peg$decode("<%;\u0230/i#;\u023F/`$;p/W$;\u023F/N$;\u0224/E$;\u023F/<$;p/3$;\u023F/*$8(:\x85(#'%!)(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x84"),peg$decode("<%;\u01DF/D#;\u023F/;$;p/2$;\u023F/)$8$:\x87$\"#!)($'#(#'#(\"'#&'#=.\" 7\x86"),peg$decode("%;[/;#;\u023F/2$;f/)$8#:\x88#\"\" )(#'#(\"'#&'#.# &;["),peg$decode(";l.) &;i.# &;g"),peg$decode("<%;k.\" &\"/o#;\u01FF./ &;\u01EB.) &;\u0214.# &;\u0201/T$;\u023F/K$;p/B$;\u023F/9$;h.\" &\"/+$8&:\x8A&$%$\" )(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x89"),peg$decode("<%;\u01E1/D#;\u023F/;$;p/2$;\u023F/)$8$:\x8C$\"#!)($'#(#'#(\"'#&'#=.\" 7\x8B"),peg$decode("<%;k.\" &\"/E#;\u01C5/<$;\u023F/3$;j/*$8$:\x8E$##\" )($'#(#'#(\"'#&'#=.\" 7\x8D"),peg$decode("%;e/W#%;\u023F/>#;\u01BE/5$;\u023F/,$;e/#$+$)($'#(#'#(\"'#&'#/)$8\":\x8F\"\"! )(\"'#&'#"),peg$decode("%;\u0204/1#;\u023F/($8\":\x90\"!!)(\"'#&'#"),peg$decode("<%;k.\" &\"/E#;\u01F1/<$;\u023F/3$;m/*$8$:\x92$##\" )($'#(#'#(\"'#&'#=.\" 7\x91"),peg$decode(";n.# &;\u017B"),peg$decode("%;\u01A0/I#;\x95.# &;q/:$;\u023F/1$;\u01A1/($8$:\x93$!\")($'#(#'#(\"'#&'#"),peg$decode("%;e/\x83#$%;\u023F/>#;\u01BE/5$;\u023F/,$;e/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;\u01BE/5$;\u023F/,$;e/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode("%;o/\x83#$%;\u023F/>#;\u020A/5$;\u023F/,$;o/#$+$)($'#(#'#(\"'#&'#0H*%;\u023F/>#;\u020A/5$;\u023F/,$;o/#$+$)($'#(#'#(\"'#&'#&/)$8\":u\"\"! )(\"'#&'#"),peg$decode("<%;r.\" &\"/1#;\u023F/($8\":\x95\"!!)(\"'#&'#=.\" 7\x94"),peg$decode("%;p/B#;\u023F/9$$;s0#*;s&/)$8#:\x96#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01A2/:#;p/1$;\u023F/($8#:\x93#!!)(#'#(\"'#&'#"),peg$decode("<%;\u017A/[#;\u023F/R$;\u01A0/I$;u.\" &\"/;$;\u023F/2$;\u01A1/)$8&:\x98&\"%\")(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x97"),peg$decode("<%;\xDB/' 8!:\x9A!! ).V &%;v.\" &\"/G#;q/>$9:\x9B \"! -\"\"&!&#/)$8#:\x9C#\"\"!)(#'#(\"'#&'#=.\" 7\x99"),peg$decode("%;\u01DC.# &;\u01BB/1#;\u023F/($8\":\x9D\"!!)(\"'#&'#"),peg$decode("<%;//' 8!:\x9F!! )=.\" 7\x9E"),peg$decode("<%;y.\" &\"/;#;{/2$;\u023F/)$8#:\xA1#\"\"!)(#'#(\"'#&'#=.\" 7\xA0"),peg$decode("<%;\u01E5/@#;\u023F/7$;z.\" &\"/)$8#:\xA3#\"\" )(#'#(\"'#&'#=.\" 7\xA2"),peg$decode("<%;\u0210/D#;\u023F/;$;\u020D/2$;\u023F/)$8$:\xA5$\"#!)($'#(#'#(\"'#&'#=.\" 7\xA4"),peg$decode(";\x8C.S &;\xFB.M &;\u0162.G &;}.A &;|.; &;\x86.5 &;\x80./ &;\x84.) &;\x85.# &;\x96"),peg$decode("<%;\u01CD.# &;\u01E0/@#;\u023F/7$;~.\" &\"/)$8#:\xA7#\"\" )(#'#(\"'#&'#=.\" 7\xA6"),peg$decode("<%;\u01C4/^#;\u023F/U$;\x7F.\" &\"/G$;~.\" &\"/9$;\x82.\" &\"/+$8%:\xA9%$$\"! )(%'#($'#(#'#(\"'#&'#=.\" 7\xA8"),peg$decode("%;\u0226/1#;\u023F/($8\":\xAA\"!!)(\"'#&'#"),peg$decode("%;\u01D8.) &;\u01F0.# &;\u01E3/1#;\u023F/($8\":\xAB\"!!)(\"'#&'#"),peg$decode("<%;\u021B/N#;\u023F/E$;~.\" &\"/7$;\x81.\" &\"/)$8$:\xAD$\"# )($'#(#'#(\"'#&'#=.\" 7\xAC"),peg$decode("<%%;\u0225/,#;\u023F/#$+\")(\"'#&'#.\" &\"/?#;\x83.\" &\"/1$;\x82/($8#:p#! )(#'#(\"'#&'#=.\" 7\xAE"),peg$decode("%;\u0182/1#;\u023F/($8\":\xAF\"!!)(\"'#&'#"),peg$decode("%;\u021E/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#"),peg$decode("<%;\x83/2#;\x82/)$8\":\xB2\"\"! )(\"'#&'#=.\" 7\xB1"),peg$decode("<%;\u0216/J#;\u023F/A$;\x83.\" &\"/3$;\x82/*$8$:\xB4$##! )($'#(#'#(\"'#&'#=.\" 7\xB3"),peg$decode("<%;\x87/N#;\u017B/E$;\u023F/<$;\x88/3$;\u023F/*$8%:\xB6%#$#!)(%'#($'#(#'#(\"'#&'#=.\" 7\xB5"),peg$decode("<%;\u01BC/D#;\u023F/;$;\u0221/2$;\u023F/)$8$:\xB8$\"#!)($'#(#'#(\"'#&'#=.\" 7\xB7"),peg$decode(";\x89.# &;\x8A"),peg$decode("<%;\u0217/M#;\u023F/D$;\u0225/;$;\u023F/2$;\u017B/)$8%:\xBA%\"$ )(%'#($'#(#'#(\"'#&'#=.\" 7\xB9"),peg$decode("<%;\u01B9/I#;\u023F/@$;\x8B.\" &\"/2$;\u010C/)$8$:\xBC$\"# )($'#(#'#(\"'#&'#=.\" 7\xBB"),peg$decode("%;\u01CC/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#"),peg$decode("%;\x8D/2#;\xA7/)$8\":\xBD\"\"! )(\"'#&'#"),peg$decode("<%;\x8E.\" &\"/1#;\u023F/($8\":*\"!!)(\"'#&'#=.\" 7\xBE"),peg$decode("%;\u0232/J#;\u023F/A$;\x8F.\" &\"/3$;\x90/*$8$:\xBF$##! )($'#(#'#(\"'#&'#"),peg$decode("%;\u0212/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#"),peg$decode("%;\x92/B#;\u023F/9$$;\x910#*;\x91&/)$8#:\xC0#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01A2/:#;\x92/1$;\u023F/($8#:\x93#!!)(#'#(\"'#&'#"),peg$decode("<%;\u0187/2#;\x93/)$8\":\xC2\"\"! )(\"'#&'#=.\" 7\xC1"),peg$decode("%;\u01BF/:#;\u023F/1$;\x94/($8#:\xC3#! )(#'#(\"'#&'#"),peg$decode("%;\u01A0/C#;\x95/:$;\u023F/1$;\u01A1/($8$: $!\")($'#(#'#(\"'#&'#"),peg$decode("%;\x8D/2#;\xA8/)$8\":\xC4\"\"! )(\"'#&'#"),peg$decode(";\x97.; &;\x99.5 &;\x9A./ &;\x9C.) &;\x9E.# &;\xA0"),peg$decode("<%;\u01C1/\x8B#;\u023F/\x82$%;\u01D5/,#;\u023F/#$+\")(\"'#&'#.\" &\"/a$;p/X$;\u023F/O$;\u01BF/F$;\u023F/=$;\x98/4$;\u023F/+$8):\xC6)$(&%!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\xC5"),peg$decode(";\u0179.) &;-.# &;?"),peg$decode("<%;\u01DB/f#;\u023F/]$%;\u01D5/,#;\u023F/#$+\")(\"'#&'#.\" &\"/<$;\x98/3$;\u023F/*$8%:\xC8%#$\"!)(%'#($'#(#'#(\"'#&'#=.\" 7\xC7"),peg$decode("<%;\u022C/@#;\u023F/7$;\x9B.\" &\"/)$8#:\xCA#\"\" )(#'#(\"'#&'#=.\" 7\xC9"),peg$decode("%;\u0179/1#;\u023F/($8\":\xCB\"!!)(\"'#&'#"),peg$decode("<%;\u01BD/@#;\u023F/7$;\x9D.\" &\"/)$8#:\xCD#\"\" )(#'#(\"'#&'#=.\" 7\xCC"),peg$decode("%;\u017B.) &;\u0183.# &;\u0179/1#;\u023F/($8\":\xCE\"!!)(\"'#&'#"),peg$decode("<%;\u0215/I#;\u023F/@$;\x9F.\" &\"/2$;\u023F/)$8$:\xCD$\"#!)($'#(#'#(\"'#&'#=.\" 7\xCF"),peg$decode("%;\u017B.) &;\u0183.# &;\u0181/1#;\u023F/($8\":\xD0\"!!)(\"'#&'#"),peg$decode("<%;\u020E/S#;\u023F/J$;\u0186/A$;\u023F/8$;\xA1.\" &\"/*$8%:\xD2%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\xD1"),peg$decode("%;\u01A0/C#;\xA2/:$;\u023F/1$;\u01A1/($8$:\xD3$!\")($'#(#'#(\"'#&'#.D &%;\u01AC/:#;\xA2/1$;\u023F/($8#:\xD3#!!)(#'#(\"'#&'#"),peg$decode(";\xA4.) &;\xA3.# &;\xA6"),peg$decode(";5.) &;/.# &;3"),peg$decode("%;\xA5/<#9:\xD4 ! -\"\"&!&#/($8\":\xD5\"!!)(\"'#&'#"),peg$decode("%$;\u0193/&#0#*;\u0193&&&#/' 8!:\xD6!! )"),peg$decode("%;\xA5/' 8!:\xD7!! )"),peg$decode(";\xA8./ &;\xDD.) &;\xF2.# &;\xF9"),peg$decode("<%;\xAE/X#;\u023F/O$;\xA9.\" &\"/A$;\u023F/8$;\xAA.\" &\"/*$8%:\xD9%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\xD8"),peg$decode("<%;\u020B/L#;\u023F/C$;\u01C6/:$;\u023F/1$;\xD8/($8%:\xDB%! )(%'#($'#(#'#(\"'#&'#=.\" 7\xDA"),peg$decode("<%;\u0200/S#;\u023F/J$;p/A$;\u023F/8$;\xAB.\" &\"/*$8%:\xDD%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\xDC"),peg$decode("<%;\xAC/2#;p/)$8\":\xDF\"\"! )(\"'#&'#=.\" 7\xDE"),peg$decode(";\xAD.# &;\u01A2"),peg$decode("%;\u0208/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#"),peg$decode("%;\xB0/B#;\u023F/9$$;\xAF0#*;\xAF&/)$8#:\xE0#\"\" )(#'#(\"'#&'#"),peg$decode("<%;\xEF/D#;\u023F/;$;\xB0/2$;\u023F/)$8$:\xE2$\"#!)($'#(#'#(\"'#&'#=.\" 7\xE1"),peg$decode(";\xB1.# &;\xD7"),peg$decode("%;\xB2/U#;\xB8.\" &\"/G$;\xB9.\" &\"/9$;\xBA.\" &\"/+$8$:\xE3$$#\"! )($'#(#'#(\"'#&'#"),peg$decode("<%;\u021F/R#;\u023F/I$;\xB3.\" &\"/;$;\u023F/2$;\xB6/)$8%:\xE5%\"\" )(%'#($'#(#'#(\"'#&'#=.\" 7\xE4"),peg$decode("<;\xB4.# &;\xB5=.\" 7\xE6"),peg$decode("%;\u01DC/1#;\u023F/($8\":\xE7\"!!)(\"'#&'#"),peg$decode("%;\u01BB/1#;\u023F/($8\":\xE8\"!!)(\"'#&'#"),peg$decode("%;\xBC/B#;\u023F/9$$;\xB70#*;\xB7&/)$8#:\xC0#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01A2/:#;\xBC/1$;\u023F/($8#:-#!!)(#'#(\"'#&'#"),peg$decode("<%;\u01E9/D#;\u023F/;$;\xC0/2$;\u023F/)$8$:\xEA$\"#!)($'#(#'#(\"'#&'#=.\" 7\xE9"),peg$decode("<%;\u0231/D#;\u023F/;$;p/2$;\u023F/)$8$:\xEC$\"#!)($'#(#'#(\"'#&'#=.\" 7\xEB"),peg$decode("<%;\u01EC/e#;\u023F/\\$;\u01C6/S$;\u023F/J$;q/A$;\u023F/8$;\xBB.\" &\"/*$8':\xEE'#&\" )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\xED"),peg$decode("<%;\u01ED/D#;\u023F/;$;p/2$;\u023F/)$8$:\xF0$\"#!)($'#(#'#(\"'#&'#=.\" 7\xEF"),peg$decode(";\xBD.# &;\xBF"),peg$decode("%;\xBE.\" &\"/2#;\xDB/)$8\":\xF1\"\"! )(\"'#&'#"),peg$decode("%;\u0195/2#;\u01A3/)$8\":\xF2\"\"! )(\"'#&'#"),peg$decode("%;p/@#;\u023F/7$;\xCD.\" &\"/)$8#:\xF3#\"\" )(#'#(\"'#&'#"),peg$decode("%;\xC4/B#;\u023F/9$$;\xC10#*;\xC1&/)$8#:\xF4#\"\" )(#'#(\"'#&'#"),peg$decode("%;\xC2.# &;\xC3/7#;\xD4.\" &\"/)$8\":\xF5\"\"! )(\"'#&'#"),peg$decode("<%;\u01A2/:#;\xC4/1$;\u023F/($8#:\xF7#!!)(#'#(\"'#&'#=.\" 7\xF6"),peg$decode("<%;\xCE/D#;\u023F/;$;\xC4/2$;\u023F/)$8$:\xF9$\"#!)($'#(#'#(\"'#&'#=.\" 7\xF8"),peg$decode(";\xCB.5 &;?./ &;\xC5.) &;\xC6.# &;\xCC"),peg$decode("%;\u017A/S#;\u023F/J$;\xED/A$;\u023F/8$;\xCD.\" &\"/*$8%:\xFA%#$\" )(%'#($'#(#'#(\"'#&'#"),peg$decode("<%;\xC7/@#;\u023F/7$;\xC8.\" &\"/)$8#:\xFC#\"\" )(#'#(\"'#&'#=.\" 7\xFB"),peg$decode("<%;\u017B/@#;\u023F/7$;\xCD.\" &\"/)$8#:\xFE#\"\" )(#'#(\"'#&'#=.\" 7\xFD"),peg$decode("<;\xC9.# &;\xCA=.\" 7\xFF"),peg$decode("%;\u01F3/V#;\u023F/M$;\u01C6/D$;\u023F/;$;\u0183/2$;\u023F/)$8&:\u0100&\"%!)(&'#(%'#($'#(#'#(\"'#&'#"),peg$decode("%;k/;#;\u01F3/2$;\u023F/)$8#:\u0101#\"\"!)(#'#(\"'#&'#"),peg$decode("<%;\u01A0/R#;\xC0/I$;\u023F/@$;\u01A1/7$;\xCD.\" &\"/)$8%:\u0103%\"# )(%'#($'#(#'#(\"'#&'#=.\" 7\u0102"),peg$decode("<%;\x94/7#;\xCD.\" &\"/)$8\":\u0105\"\"! )(\"'#&'#=.\" 7\u0104"),peg$decode("<%%;\u01BF/Q#%%<;\u0193.# &;\u0236=.##&&!&'#/,#;\u023F/#$+\")(\"'#&'#/#$+\")(\"'#&'#.\" &\"/;#;\u0195/2$;\u023F/)$8#:\u0107#\"\"!)(#'#(\"'#&'#=.\" 7\u0106"),peg$decode("<%;\xCF.\" &\"/J#;\u023F/A$;\xD0.\" &\"/3$;\u01FC/*$8$:\u0109$##! )($'#(#'#(\"'#&'#=.\" 7\u0108"),peg$decode("%;\u0202/1#;\u023F/($8\":\x90\"!!)(\"'#&'#"),peg$decode(";\xD1.# &;\xD3"),peg$decode("%;\u01FE.) &;\u021A.# &;\u01EA/@#;\u023F/7$;\xD2.\" &\"/)$8#:\u010A#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u020C/1#;\u023F/($8\":\u010B\"!!)(\"'#&'#"),peg$decode("%;\u01F5.# &;\u01D1/1#;\u023F/($8\":\u010B\"!!)(\"'#&'#"),peg$decode("<%;\xD5.# &;\xD6/1#;\u023F/($8\":\u010D\"!!)(\"'#&'#=.\" 7\u010C"),peg$decode("<%;\u0209/;#;\u023F/2$;p/)$8#:\u010F#\"\" )(#'#(\"'#&'#=.\" 7\u010E"),peg$decode("<%;\u022B/;#;\u023F/2$;\xE6/)$8#:\u0111#\"\" )(#'#(\"'#&'#=.\" 7\u0110"),peg$decode("<%;\u022D/;#;\u023F/2$;\xEB/)$8#:\u0113#\"\" )(#'#(\"'#&'#=.\" 7\u0112"),peg$decode("%;\xDA/B#;\u023F/9$$;\xD90#*;\xD9&/)$8#:\u0114#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01A2/:#;\xDA/1$;\u023F/($8#:\u0115#!!)(#'#(\"'#&'#"),peg$decode("<%;p/@#;\u023F/7$;\u012F.\" &\"/)$8#:\u0117#\"\" )(#'#(\"'#&'#=.\" 7\u0116"),peg$decode("<;\u01A4=.\" 7\u0118"),peg$decode("<;\u0218.5 &;\u021B./ &;\u01B7.) &;\u01E6.# &;\u01EF=.\" 7\u0119"),peg$decode("<%;\xDE/;#;\u023F/2$;\xE2/)$8#:\u011B#\"\" )(#'#(\"'#&'#=.\" 7\u011A"),peg$decode(";\xDF.# &;\xE0"),peg$decode("<%;\u01F6/@#;\u023F/7$;\xE1.\" &\"/)$8#:\u011D#\"\" )(#'#(\"'#&'#=.\" 7\u011C"),peg$decode("<%;\u0218/1#;\u023F/($8\":\u011F\"!!)(\"'#&'#=.\" 7\u011E"),peg$decode("<%;\u020A/;#;\u023F/2$;\xDC/)$8#:\u0121#\"\" )(#'#(\"'#&'#=.\" 7\u0120"),peg$decode("%;\xE3/2#;\xE5/)$8\":\u0122\"\"! )(\"'#&'#"),peg$decode("<%;\xE4/2#;\u0187/)$8\":\u0124\"\"! )(\"'#&'#=.\" 7\u0123"),peg$decode("<%;\u01F9/,#;\u023F/#$+\")(\"'#&'#=.\" 7\u0125"),peg$decode("<%;\xE9.) &;\x95.# &;\xEE/1#;\u023F/($8\":\u0126\"!!)(\"'#&'#=.\" 7\u0112"),peg$decode("<%;\u01A0/T#;\xE8/K$;\u023F/B$$;\xE70#*;\xE7&/2$;\u01A1/)$8%:\u0128%\"#!)(%'#($'#(#'#(\"'#&'#=.\" 7\u0127"),peg$decode("%;\u01A2/:#;\xE8/1$;\u023F/($8#:\u0129#!!)(#'#(\"'#&'#"),peg$decode("<%;\u0178/' 8!:\u012B!! )=.\" 7\u012A"),peg$decode("<%;\xEA/2#;\xEB/)$8\":\u012C\"\"! )(\"'#&'#=.\" 7\u0112"),peg$decode("<%;\u022D/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#=.\" 7\u012D"),peg$decode("%;\xED/B#;\u023F/9$$;\xEC0#*;\xEC&/)$8#:\u012E#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01A2/:#;\xED/1$;\u023F/($8#:\x93#!!)(#'#(\"'#&'#"),peg$decode("<%;\u01A0/C#;q/:$;\u023F/1$;\u01A1/($8$:\u0130$!\")($'#(#'#(\"'#&'#=.\" 7\u012F"),peg$decode("<%;\u01D6/;#;\u023F/2$;\u022D/)$8#:\u0132#\"\" )(#'#(\"'#&'#=.\" 7\u0131"),peg$decode("<%;\xF0.) &;\u01F8.# &;\u01E2/' 8!:\xB0!! )=.\" 7\u0133"),peg$decode("<%;\u0228/@#;\u023F/7$;\xF1.\" &\"/)$8#:\u0135#\"\" )(#'#(\"'#&'#=.\" 7\u0134"),peg$decode("%;\u01BB/1#;\u023F/($8\":\u0136\"!!)(\"'#&'#"),peg$decode("<%;\xF3/\x8A#;\xF4.\" &\"/|$;\xC6/s$;\u023F/j$;\xF5/a$;\xB9.\" &\"/S$;\xA9.\" &\"/E$;\u023F/<$;\xAA.\" &\"/.$8):\u0138)'('&$#\" )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0137"),peg$decode("<%;\u022A/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#=.\" 7\u0139"),peg$decode("<%;\u020A/C#;\u023F/:$;\xDC/1$;\u023F/($8$:\u013B$!!)($'#(#'#(\"'#&'#=.\" 7\u013A"),peg$decode("<%;\u0220/C#;\u023F/:$;\xF6/1$;\u023F/($8$:\u013D$!!)($'#(#'#(\"'#&'#=.\" 7\u013C"),peg$decode("%;\xF8/9#$;\xF70#*;\xF7&/)$8\":\u012E\"\"! )(\"'#&'#"),peg$decode("%;\u023F/:#;\u01A2/1$;\xF8/($8#:\u0129#! )(#'#(\"'#&'#"),peg$decode("<%;\u017D/M#;\u023F/D$;\u01AC/;$;p/2$;\u023F/)$8%:\u013F%\"$!)(%'#($'#(#'#(\"'#&'#=.\" 7\u013E"),peg$decode("<%;\xFA/h#;\xC6/_$;\u023F/V$;\xB9.\" &\"/H$;\xA9.\" &\"/:$;\xAA.\" &\"/,$8&:\u0141&%%$\"! )(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0140"),peg$decode("<%;\u01D9/C#;\u023F/:$;\u01E9/1$;\u023F/($8$:\xB0$!#)($'#(#'#(\"'#&'#=.\" 7\u0142"),peg$decode("<;\xFD.5 &;\xFE./ &;\xFF.) &;\u0100.# &;\u0101=.\" 7\u0143"),peg$decode("%;\u01D0/1#;\u023F/($8\":\xB0\"!!)(\"'#&'#"),peg$decode("%%<%;\xFC/>#;\u01F2./ &;\u0227.) &;\u022E.# &;\u022F/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0102/($8\":\u0129\"! )(\"'#&'#"),peg$decode("%%<%;\xFC/>#;\u0221./ &;\u0227.) &;\u022E.# &;\u022F/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0143/($8\":\u0129\"! )(\"'#&'#"),peg$decode("%%<%;\xFC/>#;\u0221./ &;\u01F2.) &;\u022E.# &;\u022F/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0147/($8\":\u0129\"! )(\"'#&'#"),peg$decode("%%<%;\xFC/>#;\u0221./ &;\u01F2.) &;\u0227.# &;\u022F/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0156/($8\":\u0129\"! )(\"'#&'#"),peg$decode("%%<%;\xFC/>#;\u0221./ &;\u01F2.) &;\u0227.# &;\u022E/#$+\")(\"'#&'#=.##&&!&'#/1#;\u015A/($8\":\u0129\"! )(\"'#&'#"),peg$decode("<%;\u0103/T#;\u0105.\" &\"/F$;\u017B/=$;\u023F/4$;\u0106/+$8%:\u0145%$$#\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u0144"),peg$decode("%;\xFC/J#;\u0104.\" &\"/<$;\u0221/3$;\u023F/*$8$:\u0146$##\"!)($'#(#'#(\"'#&'#"),peg$decode("%;\u0223.# &;\u0222/1#;\u023F/($8\":\u0147\"!!)(\"'#&'#"),peg$decode("<%;\u01EE/N#;\u023F/E$;k/<$;\u01E4/3$;\u023F/*$8%:\u0149%#$\"!)(%'#($'#(#'#(\"'#&'#=.\" 7\u0148"),peg$decode(";\u0107.# &;\u0142"),peg$decode("<%;\u01A0/Z#;\u0109/Q$$;\u010B0#*;\u010B&/A$;\u01A1/8$;\u0108.\" &\"/*$8%:\u014B%##\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u014A"),peg$decode("%;\u0233/D#;\u023F/;$;\u021D/2$;\u023F/)$8$:\u014C$\"#!)($'#(#'#(\"'#&'#"),peg$decode("%;\u010C/B#;\u023F/9$$;\u010A0#*;\u010A&/)$8#:\u012E#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01A2/:#;\u010C/1$;\u023F/($8#:\xAA#!!)(#'#(\"'#&'#"),peg$decode("%;\u01A2.\" &\"/1#;\u0120/($8\":\u014D\"! )(\"'#&'#"),peg$decode("<%;\u010D/O#;\u023F/F$;\u010E.\" &\"/8$;\u010F.\" &\"/*$8$:\u014F$##! )($'#(#'#(\"'#&'#=.\" 7\u014E"),peg$decode("%;\u0195/=#%<;\u023F=/##&'!&&#/($8\":p\"!!)(\"'#&'#.\\ &%%<;\u010E.) &;\u0111.# &;\u0120=.##&&!&'#/:#;\u023F/1$;\u0198/($8#:p#! )(#'#(\"'#&'#"),peg$decode("<%;&/1#;\u023F/($8\":\u0151\"!!)(\"'#&'#=.\" 7\u0150"),peg$decode("%;\u0111/B#$;\u01100#*;\u0110&/2$;\u023F/)$8#:\u012E#\"\"!)(#'#(\"'#&'#"),peg$decode("%;\u023F/1#;\u0111/($8\":\u0129\"! )(\"'#&'#"),peg$decode("<%;\u0112.\" &\"/A#;\u0114/8$;\u0112.\" &\"/*$8#:\u0153##\"! )(#'#(\"'#&'#=.\" 7\u0152"),peg$decode("%$;\u0113/&#0#*;\u0113&&&#/' 8!:\u0154!! )"),peg$decode("<%;\u01CF/C#;\u023F/:$;\u0195/1$;\u023F/($8$:\u0156$!!)($'#(#'#(\"'#&'#=.\" 7\u0155"),peg$decode(";\u0116.; &;\u0119.5 &;\u011C./ &;\u011D.) &;\u011F.# &;\u0115"),peg$decode("<%;\u0135/' 8!:\u0158!! )=.\" 7\u0157"),peg$decode("<%;\u0117/U#;\u012F.\" &\"/G$;\u0130.\" &\"/9$;\u0118.\" &\"/+$8$:\u015A$$#\"! )($'#(#'#(\"'#&'#=.\" 7\u0159"),peg$decode("<%;\u020F.# &;\u020E/D#;\u023F/;$;\u01FD/2$;\u023F/)$8$:\u015C$\"#!)($'#(#'#(\"'#&'#=.\" 7\u015B"),peg$decode("<%;\u01C2/1#;\u023F/($8\":\u015E\"!!)(\"'#&'#=.\" 7\u015D"),peg$decode("%;\u011A/@#;\u0130.\" &\"/2$;\u023F/)$8#:\u015F#\"\"!)(#'#(\"'#&'#"),peg$decode("<%;\u011B.# &;\u0229/1#;\u023F/($8\":\u010B\"!!)(\"'#&'#=.\" 7\u0160"),peg$decode("<%;k.\" &\"/2#;\u0206/)$8\":\u0162\"\"! )(\"'#&'#=.\" 7\u0161"),peg$decode("<;\u0132=.\" 7\u0163"),peg$decode("<%;\u01D6/D#;\u023F/;$;\u011E/2$;\u023F/)$8$:\u0165$\"#!)($'#(#'#(\"'#&'#=.\" 7\u0164"),peg$decode(";L./ &;5.) &;,.# &;3"),peg$decode("<%;\u012D/' 8!:\u0167!! )=.\" 7\u0166"),peg$decode("<%;\u0112.\" &\"/J#;\u0121/A$;\u023F/8$;\u0112.\" &\"/*$8$:\u0169$##\" )($'#(#'#(\"'#&'#=.\" 7\u0168"),peg$decode(";\u0133.) &;\u0123.# &;\u0122"),peg$decode("<%;\u0132/' 8!:\u016B!! )=.\" 7\u016A"),peg$decode("<%;\u0124/J#;\u023F/A$;\u0129/8$;\u0130.\" &\"/*$8$:\u016D$##! )($'#(#'#(\"'#&'#=.\" 7\u016C"),peg$decode("%;\u0125.# &;\u0126/1#;\u023F/($8\":\u016E\"!!)(\"'#&'#"),peg$decode("<%;\u020F/;#;\u023F/2$;\u01FD/)$8#:\u016F#\"\" )(#'#(\"'#&'#=.\" 7\u015B"),peg$decode("<%;\u0229/' 8!:\u0171!! )=.\" 7\u0170"),peg$decode("%;\u01A0/T#;\u012B/K$;\u023F/B$$;\u012A0#*;\u012A&/2$;\u01A1/)$8%:\u0172%\"#!)(%'#($'#(#'#(\"'#&'#"),peg$decode("%;\u0127/' 8!:\u0173!! )"),peg$decode("%;\u0127/' 8!:\u0174!! )"),peg$decode("%;\u01A2/:#;\u012B/1$;\u023F/($8#:\u0129#!!)(#'#(\"'#&'#"),peg$decode("<%;\u012C/O#;\u023F/F$;\u012F.\" &\"/8$;\u0118.\" &\"/*$8$:\u0176$##! )($'#(#'#(\"'#&'#=.\" 7\u0175"),peg$decode("%;\xE8/\\#%<%;\u023F/8#;\u01B3.) &;\u01A1.# &;\u012F/#$+\")(\"'#&'#=/##&'!&&#/($8\":p\"!!)(\"'#&'#.# &;p"),peg$decode("<%$;\u012E/&#0#*;\u012E&&&#/' 8!:\u0178!! )=.\" 7\u0177"),peg$decode("%;\u01CB/C#;\u023F/:$;\u0181/1$;\u023F/($8$:p$!!)($'#(#'#(\"'#&'#"),peg$decode("<%;\u01C0.# &;\u01DA/1#;\u023F/($8\":\u017A\"!!)(\"'#&'#=.\" 7\u0179"),peg$decode("%;\u0131/;#;\xDC/2$;\u023F/)$8#:\u017B#\"\"!)(#'#(\"'#&'#"),peg$decode("<%;\u0209/D#;\u023F/;$;\u01CE/2$;\u023F/)$8$:\u017D$\"#!)($'#(#'#(\"'#&'#=.\" 7\u017C"),peg$decode("%;\u01CA/;#;\u023F/2$;L/)$8#:\u017E#\"\" )(#'#(\"'#&'#"),peg$decode("<%;\u0134/E#;\xE6/<$;\u0135/3$;\u023F/*$8$:\u0180$##\"!)($'#(#'#(\"'#&'#=.\" 7\u017F"),peg$decode("<%;\u01E8/D#;\u023F/;$;\u01FD/2$;\u023F/)$8$:\u0182$\"#!)($'#(#'#(\"'#&'#=.\" 7\u0181"),peg$decode("%;\u0136/F#;\u0137.\" &\"/8$;\u0140.\" &\"/*$8#:\u0183##\"! )(#'#(\"'#&'#"),peg$decode("<%;\u0213/D#;\u023F/;$;\u0187/2$;\u023F/)$8$:\u0185$\"#!)($'#(#'#(\"'#&'#=.\" 7\u0184"),peg$decode("%;\u0139/B#;\u023F/9$$;\u01380#*;\u0138&/)$8#:\u0186#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u0139/1#;\u023F/($8\":\u0136\"!!)(\"'#&'#"),peg$decode("<;\u013A.# &;\u013F=.\" 7\u0187"),peg$decode("%;\u0209/T#;\u023F/K$;\u01D9.# &;\u022A/<$;\u023F/3$;\u013B/*$8%:\u0188%#$\" )(%'#($'#(#'#(\"'#&'#"),peg$decode("<;\u013C.) &;\u013D.# &;\u013E=.\" 7\u0189"),peg$decode("%;\u0220/J#;\u023F/A$;\u0206.# &;\u01D6/2$;\u023F/)$8$:\u018A$\"#!)($'#(#'#(\"'#&'#"),peg$decode("%;\u01C7.# &;\u0219/1#;\u023F/($8\":\u018B\"!!)(\"'#&'#"),peg$decode("%;\u0203/D#;\u023F/;$;\u01B8/2$;\u023F/)$8$:\u018C$\"#!)($'#(#'#(\"'#&'#"),peg$decode("%;\u0201/D#;\u023F/;$;\u0195/2$;\u023F/)$8$:\u018D$\"#!)($'#(#'#(\"'#&'#"),peg$decode("<%;k.\" &\"/J#;\u01D7/A$;\u023F/8$;\u0141.\" &\"/*$8$:\u018F$##\" )($'#(#'#(\"'#&'#=.\" 7\u018E"),peg$decode("%;\u01F4/J#;\u023F/A$;\u01D8.# &;\u01F0/2$;\u023F/)$8$:\u0190$\"#!)($'#(#'#(\"'#&'#"),peg$decode("%;\u0159/' 8!:\u0191!! )"),peg$decode("<%;\u0144/c#;\u0105.\" &\"/U$;\u0183/L$;\u023F/C$;\u0146/:$;\xB9.\" &\"/,$8&:\u0193&%%$#! )(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0192"),peg$decode("%;\xFC/J#;\u0145.\" &\"/<$;\u01F2/3$;\u023F/*$8$:\u0194$##\"!)($'#(#'#(\"'#&'#"),peg$decode("%;\u0229/1#;\u023F/($8\":\u0195\"!!)(\"'#&'#"),peg$decode("<%;\u0209/N#;\u023F/E$;\u017B/<$;\u023F/3$;\u0128/*$8%:\u0197%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u0196"),peg$decode("<%;\u0148/\xA6#;\u0105.\" &\"/\x98$;\u0184.\" &\"/\x8A$;\u023F/\x81$;\u0149/x$;\u0209/o$;\u023F/f$;\u017B/]$;\u023F/T$;\u0151.\" &\"/F$;\u0152.\" &\"/8$;\u0153//$8,:\u0199,(+*)'$\"! )(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0198"),peg$decode("%;\xFC/J#;\u0104.\" &\"/<$;\u0227/3$;\u023F/*$8$:\u019A$##\"!)($'#(#'#(\"'#&'#"),peg$decode("<%;\u014A.\" &\"/2#;\u014C/)$8\":\u019C\"\"! )(\"'#&'#=.\" 7\u019B"),peg$decode("%;\u01C3.) &;\u01BA.# &;\u014B/1#;\u023F/($8\":\u019D\"!!)(\"'#&'#"),peg$decode("%;\u01F7/;#;\u023F/2$;\u0207/)$8#:\u019E#\"\" )(#'#(\"'#&'#"),peg$decode("<;\u014D.# &;\u014E=.\" 7\u019F"),peg$decode("%;\u01D9.# &;\u01F6/1#;\u023F/($8\":\u01A0\"!!)(\"'#&'#"),peg$decode("%;\u022A/@#;\u023F/7$;\u014F.\" &\"/)$8#:\u01A1#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u0207/;#;\u023F/2$;\u0150/)$8#:\u01A2#\"\" )(#'#(\"'#&'#"),peg$decode("%;\xE8/B#;\u023F/9$$;\xE70#*;\xE7&/)$8#:\u012E#\"\" )(#'#(\"'#&'#"),peg$decode("%;\u01E7/c#;\u023F/Z$;\u01DE/Q$;\u023F/H$;\u021C.) &3\u01A3\"\"5)7\u01A4/3$;\u023F/*$8&:\u01A5&#%#!)(&'#(%'#($'#(#'#(\"'#&'#"),peg$decode("<%;\u0230/D#;\u023F/;$;p/2$;\u023F/)$8$:\u01A6$\"#!)($'#(#'#(\"'#&'#=.\" 7\x84"),peg$decode("<%;\u01C4/W#;\u023F/N$;\u0154/E$;\u023F/<$;\u01E0/3$;\u023F/*$8&:\u01A8&#%#!)(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01A7"),peg$decode("%$;\u0155/&#0#*;\u0155&&&#/' 8!:\u01A9!! )"),peg$decode("%;\x8C/:#;\u023F/1$;$/($8#:\"#!\")(#'#(\"'#&'#"),peg$decode("<%;\u0158/T#;\u0105.\" &\"/F$;\u0157/=$;\u023F/4$;\u0159/+$8%:\u01AB%$$#\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u01AA"),peg$decode("%;\u0185/;#;\u023F/2$;\xE6/)$8#:\u01AC#\"\" )(#'#(\"'#&'#.# &;\u0185"),peg$decode("%;\xFC/J#;\u0104.\" &\"/<$;\u022E/3$;\u023F/*$8$:\u01AD$##\"!)($'#(#'#(\"'#&'#"),peg$decode("%;\u01BF/D#;\u023F/;$;\xA8/2$;\u023F/)$8$:\u012C$\"#!)($'#(#'#(\"'#&'#"),peg$decode("<%;\u015B/f#;\u0105.\" &\"/X$;\u017B/O$;\u023F/F$;\u022B/=$;\u023F/4$;\u015C/+$8':\u01AF'$&%$ )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01AE"),peg$decode("%;\xFC/N#;\u022F/E$;\u023F/<$;\u0221/3$;\u023F/*$8%:\u01B0%#$#!)(%'#($'#(#'#(\"'#&'#"),peg$decode("%;\u0197/@#;\u023F/7$;\u015D.\" &\"/)$8#:\u01B1#\"\" )(#'#(\"'#&'#"),peg$decode("<%;\u01A0/Z#;\u023F/Q$;\u015E.\" &\"/C$;\u023F/:$;\u01A1/1$;\u023F/($8&:\u01B3&!#)(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01B2"),peg$decode("%;\u0160/9#$;\u015F0#*;\u015F&/)$8\":\u01B4\"\"! )(\"'#&'#"),peg$decode("%;\u023F/H#;\u01A2/?$;\u023F/6$;\u0160.\" &\"/($8$:\u01B5$! )($'#(#'#(\"'#&'#"),peg$decode("%%<%;\u0195/;#;\u023F/2$;&.# &;\u0111/#$+#)(#'#(\"'#&'#=.##&&!&'#/:#;p/1$;\u023F/($8#:\u0130#!!)(#'#(\"'#&'#.x &%;\u0161/n#%%<;\u0193=.##&&!&'#/,#;\u023F/#$+\")(\"'#&'#/F$;\u010E.\" &\"/8$;\u010F.\" &\"/*$8$:\u014F$##! )($'#(#'#(\"'#&'#"),peg$decode(";\u0195.# &;\u0198"),peg$decode("<%;\u0163/;#;\u017B/2$;\u023F/)$8#:\u01B7#\"\"!)(#'#(\"'#&'#=.\" 7\u01B6"),peg$decode("<%;\u01DD/J#;\u023F/A$;\u0164/8$;\u0165.\" &\"/*$8$:\u01B9$##! )($'#(#'#(\"'#&'#=.\" 7\u01B8"),peg$decode("<%;\u0221./ &;\u01F2.) &;\u0227.# &;\u022E/1#;\u023F/($8\":\u010B\"!!)(\"'#&'#=.\" 7\u01BA"),peg$decode("<%;\u01EE/D#;\u023F/;$;\u01E4/2$;\u023F/)$8$:\u01BC$\"#!)($'#(#'#(\"'#&'#=.\" 7\u01BB"),peg$decode("<%;\u01AE/,#;\u01AE/#$+\")(\"'#&'#=.\" 7\u01BD"),peg$decode("<;\u01AA=.\" 7\u01BE"),peg$decode("<;\u01AB=.\" 7\u01BF"),peg$decode("<;\u01A4=.\" 7\u01C0"),peg$decode("<;\u01B5=.\" 7\u01C1"),peg$decode("<;\u01AF=.\" 7\u01C2"),peg$decode("<%;\u01B0/,#;\u01B0/#$+\")(\"'#&'#=.\" 7\u01C3"),peg$decode("<%;\u01B1/,#;\u01B1/#$+\")(\"'#&'#=.\" 7\u01C4"),peg$decode("<;\u01AD=.\" 7\u01C5"),peg$decode("<;\u01AE=.\" 7\u01C6"),peg$decode("<;\u01B0=.\" 7\u01C7"),peg$decode("<;\u01B1=.\" 7\u01C8"),peg$decode("<%;\u01B0/,#;\u01AC/#$+\")(\"'#&'#=.\" 7\u01C9"),peg$decode("<%;\u01B1/,#;\u01AC/#$+\")(\"'#&'#=.\" 7\u01CA"),peg$decode("<%;\u01AC/1#;\u01AC.\" &\"/#$+\")(\"'#&'#=.\" 7\u01CB"),peg$decode("<%;\u01B2/,#;\u01AC/#$+\")(\"'#&'#=.\" 7\u01CC"),peg$decode("<%;\u01B0/,#;\u01B1/#$+\")(\"'#&'#=.\" 7\u01CC"),peg$decode("<%;\u01FA/@#;\u023F/7$;k.\" &\"/)$8#:\u01CE#\"\" )(#'#(\"'#&'#=.\" 7\u01CD"),peg$decode("<;\u0195.# &;\u0198=.\" 7\u01CF"),peg$decode("<%;\u0178/' 8!:\u01D1!! )=.\" 7\u01D0"),peg$decode("<%;\u017C.\" &\"/2#;\u0178/)$8\":\u01D3\"\"! )(\"'#&'#=.\" 7\u01D2"),peg$decode("<%;\u017C.\" &\"/2#;\u0178/)$8\":\u01D5\"\"! )(\"'#&'#=.\" 7\u01D4"),peg$decode("%;\u0178/2#;\u01A3/)$8\":\u01D6\"\"! )(\"'#&'#"),peg$decode("<%;\u017F.) &;\u0180.# &;\u017E/2#;\u0178/)$8\":\u01D8\"\"! )(\"'#&'#=.\" 7\u01D7"),peg$decode("%;\u023F/& 8!:\u01D9! )"),peg$decode("%;\u017C/2#;\u0180/)$8\":\u01DA\"\"! )(\"'#&'#"),peg$decode("%;\u0178/2#;\u01A3/)$8\":D\"\"! )(\"'#&'#"),peg$decode("<%;\u0178/' 8!:\u01DC!! )=.\" 7\u01DB"),peg$decode("<%;\u0178/' 8!:\u01DE!! )=.\" 7\u01DD"),peg$decode("<%;\u017C.\" &\"/2#;\u0178/)$8\":\u01E0\"\"! )(\"'#&'#=.\" 7\u01DF"),peg$decode("<%;\u017C.\" &\"/2#;\u0178/)$8\":\u01E2\"\"! )(\"'#&'#=.\" 7\u01E1"),peg$decode("<%;\u017C.\" &\"/2#;\u0178/)$8\":\u01E4\"\"! )(\"'#&'#=.\" 7\u01E3"),peg$decode("<%;\u017C.\" &\"/2#;\u0178/)$8\":\u01E6\"\"! )(\"'#&'#=.\" 7\u01E5"),peg$decode("<%;\u0188.# &;\u017B/1#;\u023F/($8\":\u01E8\"!!)(\"'#&'#=.\" 7\u01E7"),peg$decode("%;\u017B/;#;\u023F/2$;\xE6/)$8#:\u01E9#\"\" )(#'#(\"'#&'#"),peg$decode("<%;\u0178/' 8!:\u01EB!! )=.\" 7\u01EA"),peg$decode("<%;\u0178/' 8!:\u01ED!! )=.\" 7\u01EC"),peg$decode("<%;\u018C/=#%<;\u0193=.##&&!&'#/($8\":\u01EF\"!!)(\"'#&'#.\xC5 &%;\u018D/=#%<;\u0193=.##&&!&'#/($8\":\u01F0\"!!)(\"'#&'#.\x9B &%;\u018F/=#%<;\u0193=.##&&!&'#/($8\":\u01F1\"!!)(\"'#&'#.q &%;\u0190/=#%<;\u0193=.##&&!&'#/($8\":\u01F2\"!!)(\"'#&'#.G &%;\u0192/=#%<;\u0193=.##&&!&'#/($8\":\u01F3\"!!)(\"'#&'#=.\" 7\u01EE"),peg$decode("<%%3\u01F5\"\"5!7\u01F6.\" &\"/F#3\u01F7\"\"5#7\u01F8.\" &\"/2$3\u01F9\"\"5$7\u01FA/#$+#)(#'#(\"'#&'#.k &%3\u01FB\"\"5$7\u01FC.5 &3\u01FD\"\"5&7\u01FE.) &3\u01FF\"\"5$7\u0200.\" &\"/2#3\u0201\"\"5$7\u0202/#$+\")(\"'#&'#.) &3\u0203\"\"5$7\u0204/' 8!:\u010B!! )=.\" 7\u01F4"),peg$decode("<%;\u018E.5 &3\u0206\"\"5%7\u0207.) &3\u0208\"\"5$7\u0209/' 8!:\u010B!! )=.\" 7\u0205"),peg$decode("<%3\u020B\"\"5&7\u020C/i#%$4(\"\"5!7)/,#0)*4(\"\"5!7)&&&#/2#3\u020D\"\"5)7\u020E/#$+\")(\"'#&'#.\" &\"/)$8\":\u020F\"\"! )(\"'#&'#=.\" 7\u020A"),peg$decode("<%3\u0211\"\"5'7\u0212.\x95 &3\u0213\"\"5'7\u0214.\x89 &3\u0215\"\"5'7\u0216.} &%3\u0217\"\"5$7\u0218/7#3\u0219\"\"5$7\u021A.\" &\"/#$+\")(\"'#&'#.S &%3\u0219\"\"5$7\u021A/7#3\u021B\"\"5%7\u021C.\" &\"/#$+\")(\"'#&'#.) &3\u021D\"\"5&7\u021E/' 8!:\u010B!! )=.\" 7\u0210"),peg$decode("<%%3\u0220\"\"5#7\u0221/V#2\u0222\"\"6\u02227\u0223.A &2\u0224\"\"6\u02247\u0225.5 &2\u0226\"\"6\u02267\u0227.) &3\u0228\"\"5$7\u0229/#$+\")(\"'#&'#.q &%3\u022A\"\"5#7\u022B.A &3\u01FD\"\"5&7\u01FE.5 &3\u022C\"\"5%7\u022D.) &3\u01FB\"\"5$7\u01FC.\" &\"/2#3\u0220\"\"5#7\u0221/#$+\")(\"'#&'#.# &;\u0191/' 8!:\u010B!! )=.\" 7\u021F"),peg$decode("%3\u022E\"\"5(7\u022F/d#%$4(\"\"5!7)/,#0)*4(\"\"5!7)&&&#/2#3\u0230\"\"5%7\u0231/#$+\")(\"'#&'#/)$8\":\u0232\"\"! )(\"'#&'#"),peg$decode("<%3\u0234\"\"5$7\u0235/' 8!:\u010B!! )=.\" 7\u0233"),peg$decode("4\u0236\"\"5!7\u0237"),peg$decode("%2\u0238\"\"6\u02387\u0239/K#$4\u023A\"\"5!7\u023B/,#0)*4\u023A\"\"5!7\u023B&&&#/)$8\":\u023C\"\"! )(\"'#&'#"),peg$decode(";\u0196.# &;\u0197"),peg$decode(";\u0199./ &;\u019D.) &;\u019B.# &;\u019C"),peg$decode("%%<;\u0234.# &;>=.##&&!&'#/J#$;\u0194.# &;\u0193/,#0)*;\u0194.# &;\u0193&&&#/($8\":\xD6\"! )(\"'#&'#"),peg$decode("%%<;\u0236.# &;>=.##&&!&'#/J#$;\u0194.# &;\u0193/,#0)*;\u0194.# &;\u0193&&&#/($8\":\u023D\"! )(\"'#&'#"),peg$decode("%;\u019E/\x99#;\u023F/\x90$%$%%<;\u019A=.##&&!&'#/1#1\"\"5!7\u023E/#$+\")(\"'#&'#0G*%%<;\u019A=.##&&!&'#/1#1\"\"5!7\u023E/#$+\")(\"'#&'#&/\"!&,)/1$;\u019A/($8$:\u023F$!!)($'#(#'#(\"'#&'#"),peg$decode("%$4\u0240\"\"5!7\u02410)*4\u0240\"\"5!7\u0241&/5#;\u019F/,$;\u023F/#$+#)(#'#(\"'#&'#"),peg$decode("%2\u0242\"\"6\u02427\u0243/k#$2\u0244\"\"6\u02447\u0245.) &4\u0246\"\"5!7\u024705*2\u0244\"\"6\u02447\u0245.) &4\u0246\"\"5!7\u0247&/7$2\u0242\"\"6\u02427\u0243/($8#:\u0248#!!)(#'#(\"'#&'#"),peg$decode("%2\u0249\"\"6\u02497\u024A/k#$26\"\"6677.) &48\"\"5!7905*26\"\"6677.) &48\"\"5!79&/7$2\u0249\"\"6\u02497\u024A/($8#:\u024B#!!)(#'#(\"'#&'#"),peg$decode("%2\u024C\"\"6\u024C7\u024D/k#$2\u024E\"\"6\u024E7\u024F.) &4\u0250\"\"5!7\u025105*2\u024E\"\"6\u024E7\u024F.) &4\u0250\"\"5!7\u0251&/7$2\u024C\"\"6\u024C7\u024D/($8#:\u0252#!!)(#'#(\"'#&'#"),peg$decode("<%2\u0254\"\"6\u02547\u0255/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0253"),peg$decode("<%2\u0257\"\"6\u02577\u0258/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0256"),peg$decode("<%2\u025A\"\"6\u025A7\u025B/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0259"),peg$decode("<%2\u025D\"\"6\u025D7\u025E/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u025C"),peg$decode("<%2\u0260\"\"6\u02607\u0261/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u025F"),peg$decode("<%2\u0263\"\"6\u02637\u0264/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0262"),peg$decode("<%2\u0266\"\"6\u02667\u0267/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0265"),peg$decode("<%2\u0269\"\"6\u02697\u026A/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0268"),peg$decode("<%2\u0249\"\"6\u02497\u024A/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u026B"),peg$decode("<%2\u0242\"\"6\u02427\u0243/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u026C"),peg$decode("<%2\u024C\"\"6\u024C7\u024D/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u026D"),peg$decode("<%2\u026F\"\"6\u026F7\u0270/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u026E"),peg$decode("<%2\u0272\"\"6\u02727\u0273/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0271"),peg$decode("<%2\u0275\"\"6\u02757\u0276/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0274"),peg$decode("<%2\u0277\"\"6\u02777\u0278/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u01CB"),peg$decode("<%2\u027A\"\"6\u027A7\u027B/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0279"),peg$decode("<%2\u027D\"\"6\u027D7\u027E/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u027C"),peg$decode("<%2\u027F\"\"6\u027F7\u0280/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u01C2"),peg$decode("<%2\u0281\"\"6\u02817\u0282/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u01C7"),peg$decode("<%2\u0283\"\"6\u02837\u0284/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u01C8"),peg$decode("<%2\u0286\"\"6\u02867\u0287/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0285"),peg$decode("<%2\u0289\"\"6\u02897\u028A/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u0288"),peg$decode("<%2a\"\"6a7b/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u028B"),peg$decode("<%2\u028D\"\"6\u028D7\u028E/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u028C"),peg$decode("<%2\u0290\"\"6\u02907\u0291/1#;\u023F/($8\":\"\"!!)(\"'#&'#=.\" 7\u028F"),peg$decode("%3\u0292\"\"5%7\u0293/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0294\"\"5&7\u0295/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0296\"\"5#7\u0297/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0298\"\"5%7\u0299/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u029A\"\"5#7\u029B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u029C\"\"5%7\u029D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u029E\"\"5'7\u029F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02A0\"\"5#7\u02A1/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02A2\"\"5\"7\u02A3/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02A4\"\"5#7\u02A5/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02A6\"\"5&7\u02A7/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02A8\"\"5-7\u02A9/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02AA\"\"5&7\u02AB/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02AC\"\"5%7\u02AD/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02AE\"\"5'7\u02AF/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02B0\"\"5\"7\u02B1/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02B2\"\"5'7\u02B3/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02B4\"\"5$7\u02B5/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02B6\"\"5$7\u02B7/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02B8\"\"5%7\u02B9/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02BA\"\"5'7\u02BB/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02BC\"\"5&7\u02BD/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02BE\"\"5&7\u02BF/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02C0\"\"5(7\u02C1/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02C2\"\"5*7\u02C3/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02C4\"\"5&7\u02C5/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02C6\"\"5%7\u02C7/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02C8\"\"5,7\u02C9/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02CA\"\"5,7\u02CB/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02CC\"\"517\u02CD/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02CE\"\"5(7\u02CF/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02D0\"\"5'7\u02D1/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02D2\"\"5*7\u02D3/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02D4\"\"5(7\u02D5/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02D6\"\"5&7\u02D7/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02D8\"\"5$7\u02D9/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02DA\"\"5&7\u02DB/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02DC\"\"5(7\u02DD/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02DE\"\"5$7\u02DF/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02E0\"\"5$7\u02E1/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02E2\"\"5$7\u02E3/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02E4\"\"5#7\u02E5/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02E6\"\"5&7\u02E7/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02E8\"\"5&7\u02E9/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02EA\"\"5)7\u02EB/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02EC\"\"5&7\u02ED/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02EE\"\"5'7\u02EF/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02F0\"\"5$7\u02F1/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02F2\"\"5#7\u02F3/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02F4\"\"5'7\u02F5/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02F6\"\"5$7\u02F7/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02F8\"\"5$7\u02F9/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02FA\"\"5$7\u02FB/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02FC\"\"5%7\u02FD/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u02FE\"\"5&7\u02FF/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0300\"\"5\"7\u0301/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0302\"\"5&7\u0303/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0304\"\"5)7\u0305/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0306\"\"5\"7\u0307/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0308\"\"5%7\u0309/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u030A\"\"5'7\u030B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u030C\"\"5)7\u030D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u030E\"\"5%7\u030F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0310\"\"5&7\u0311/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0312\"\"5'7\u0313/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0314\"\"5)7\u0315/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0316\"\"5$7\u0317/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0318\"\"5\"7\u0319/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u031A\"\"5&7\u031B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u031C\"\"5$7\u031D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u031E\"\"5#7\u031F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0320\"\"5$7\u0321/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0322\"\"5$7\u0323/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0324\"\"5%7\u0325/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0326\"\"5%7\u0327/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0328\"\"5'7\u0329/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u032A\"\"5\"7\u032B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u032C\"\"5#7\u032D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u032E\"\"5'7\u032F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3y\"\"5$7z/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0330\"\"5\"7\u0331/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0332\"\"5&7\u0333/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0334\"\"5\"7\u0335/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0336\"\"5\"7\u0337/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0338\"\"5%7\u0339/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u033A\"\"5%7\u033B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u033C\"\"5$7\u033D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u033E\"\"5&7\u033F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0340\"\"5'7\u0341/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0342\"\"5%7\u0343/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0344\"\"5%7\u0345/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0346\"\"5)7\u0347/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0348\"\"5*7\u0349/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u034A\"\"5&7\u034B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u034C\"\"5'7\u034D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u034E\"\"5'7\u034F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0350\"\"5&7\u0351/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0352\"\"5'7\u0353/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0354\"\"5(7\u0355/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0356\"\"5%7\u0357/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0358\"\"5(7\u0359/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u035A\"\"5#7\u035B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u035C\"\"5%7\u035D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u035E\"\"5)7\u035F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0360\"\"5&7\u0361/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0362\"\"5#7\u0363/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0364\"\"5%7\u0365/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0366\"\"5$7\u0367/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0368\"\"5)7\u0369/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u036A\"\"5$7\u036B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u036C\"\"5\"7\u036D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u036E\"\"5+7\u036F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0370\"\"5'7\u0371/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0372\"\"5%7\u0373/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0374\"\"5&7\u0375/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0376\"\"5&7\u0377/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0378\"\"5%7\u0379/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u037A\"\"5&7\u037B/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u037C\"\"5&7\u037D/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u037E\"\"5$7\u037F/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0380\"\"5'7\u0381/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0382\"\"5$7\u0383/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0384\"\"5%7\u0385/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0386\"\"5$7\u0387/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%3\u0388\"\"5'7\u0389/8#%<;\u0193=.##&&!&'#/#$+\")(\"'#&'#"),peg$decode("%;\u0235/' 8!:\u038A!! )"),peg$decode(";\u01B7.\u02F9 &;\u01B8.\u02F3 &;\u01B9.\u02ED &;\u01BA.\u02E7 &;\u01BB.\u02E1 &;\u01BC.\u02DB &;\u01BD.\u02D5 &;\u01BE.\u02CF &;\u01BF.\u02C9 &;\u01C0.\u02C3 &;\u01C1.\u02BD &;\u01C2.\u02B7 &;\u01C3.\u02B1 &;\u01C4.\u02AB &;\u01C5.\u02A5 &;\u01C6.\u029F &;\u01C7.\u0299 &;\u01C8.\u0293 &;\u01C9.\u028D &;\u01CA.\u0287 &;\u01CB.\u0281 &;\u01CC.\u027B &;\u01CD.\u0275 &;\u01CE.\u026F &;\u01CF.\u0269 &;\u01D0.\u0263 &;\u01D1.\u025D &;\u01D2.\u0257 &;\u01D3.\u0251 &;\u01D4.\u024B &;\u01D5.\u0245 &;\u01D6.\u023F &;\u01D7.\u0239 &;\u01D8.\u0233 &;\u01D9.\u022D &;\u01DA.\u0227 &;\u01DB.\u0221 &;\u01DC.\u021B &;\u01DD.\u0215 &;\u01DE.\u020F &;\u01DF.\u0209 &;\u01E0.\u0203 &;\u01E1.\u01FD &;\u01E2.\u01F7 &;\u01E3.\u01F1 &;\u01E4.\u01EB &;\u01E5.\u01E5 &;\u01E6.\u01DF &;\u01E7.\u01D9 &;\u01E8.\u01D3 &;\u01E9.\u01CD &;\u01EA.\u01C7 &;\u01EB.\u01C1 &;\u01EC.\u01BB &;\u01ED.\u01B5 &;\u01EE.\u01AF &;\u01EF.\u01A9 &;\u01F0.\u01A3 &;\u01F1.\u019D &;\u01F2.\u0197 &;\u01F3.\u0191 &;\u01F4.\u018B &;\u01F5.\u0185 &;\u01F6.\u017F &;\u01F7.\u0179 &;\u01F8.\u0173 &;\u01F9.\u016D &;\u01FA.\u0167 &;\u01FB.\u0161 &;\u01FC.\u015B &;\u01FD.\u0155 &;\u01FE.\u014F &;\u01FF.\u0149 &;\u0200.\u0143 &;\u0201.\u013D &;\u0202.\u0137 &;\u0203.\u0131 &;\u0204.\u012B &;\u0205.\u0125 &;\u0206.\u011F &;\u0207.\u0119 &;\u0208.\u0113 &;\u0209.\u010D &;\u020A.\u0107 &;\u020B.\u0101 &;\u020C.\xFB &;\u020D.\xF5 &;\u020E.\xEF &;\u020F.\xE9 &;\u0210.\xE3 &;\u0211.\xDD &;\u0212.\xD7 &;\u0213.\xD1 &;\u0214.\xCB &;\u0215.\xC5 &;\u0216.\xBF &;\u0217.\xB9 &;\u0218.\xB3 &;\u0219.\xAD &;\u021A.\xA7 &;\u021B.\xA1 &;\u021C.\x9B &;\u021E.\x95 &;\u021F.\x8F &;\u0220.\x89 &;\u0221.\x83 &;\u0223.} &;\u0224.w &;\u0225.q &;\u0226.k &;\u0227.e &;\u0228._ &;\u0229.Y &;\u022A.S &;\u022B.M &;\u022C.G &;\u022D.A &;\u022E.; &;\u022F.5 &;\u0230./ &;\u0231.) &;\u0232.# &;\u0233"),peg$decode(";\u01B9.\u0167 &;\u01BB.\u0161 &;\u01BC.\u015B &;\u01BE.\u0155 &;\u01BF.\u014F &;\u01C2.\u0149 &;\u01C5.\u0143 &;\u01C8.\u013D &;\u01CA.\u0137 &;\u01CB.\u0131 &;\u01CD.\u012B &;\u01CF.\u0125 &;\u01D0.\u011F &;\u01D6.\u0119 &;\u01D7.\u0113 &;\u01D9.\u010D &;\u01DC.\u0107 &;\u01DD.\u0101 &;\u01DF.\xFB &;\u01E1.\xF5 &;\u01E2.\xEF &;\u01E4.\xE9 &;\u01E8.\xE3 &;\u01E9.\xDD &;\u01EC.\xD7 &;\u01ED.\xD1 &;\u01F1.\xCB &;\u01F2.\xC5 &;\u01F6.\xBF &;\u01F8.\xB9 &;\u01F9.\xB3 &;\u01FA.\xAD &;\u01FB.\xA7 &;\u01FC.\xA1 &;\u0200.\x9B &;\u0204.\x95 &;\u0205.\x8F &;\u0206.\x89 &;\u0209.\x83 &;\u020A.} &;\u020B.w &;\u020F.q &;\u0213.k &;\u021F.e &;\u0220._ &;\u0221.Y &;\u0224.S &;\u0225.M &;\u0226.G &;\u0228.A &;\u0229.; &;\u022A.5 &;\u022B./ &;\u022D.) &;\u0230.# &;\u0231"),peg$decode(";\u0238.. &%;\u0239/& 8!:\u038B! )"),peg$decode("<%2\u038D\"\"6\u038D7\u038E/\x87#$%%<4\u038F\"\"5!7\u0390=.##&&!&'#/1#1\"\"5!7\u023E/#$+\")(\"'#&'#0M*%%<4\u038F\"\"5!7\u0390=.##&&!&'#/1#1\"\"5!7\u023E/#$+\")(\"'#&'#&/#$+\")(\"'#&'#=.\" 7\u038C"),peg$decode("<%;\u023A/5#;\u023E/,$;\u023B/#$+#)(#'#(\"'#&'#=.\" 7\u0391"),peg$decode("2\u0392\"\"6\u03927\u0393"),peg$decode("2\u0394\"\"6\u03947\u0395"),peg$decode("$%%<;\u023B.# &;\u023A=.##&&!&'#/1#1\"\"5!7\u023E/#$+\")(\"'#&'#/P#0M*%%<;\u023B.# &;\u023A=.##&&!&'#/1#1\"\"5!7\u023E/#$+\")(\"'#&'#&&&#"),peg$decode(";\u023C.# &;\u0239"),peg$decode("%;\u023D/K#$4\u0396\"\"5!7\u0397.# &;\u023D0/*4\u0396\"\"5!7\u0397.# &;\u023D&/#$+\")(\"'#&'#"),peg$decode("<%$4\u0396\"\"5!7\u0397.# &;\u02370/*4\u0396\"\"5!7\u0397.# &;\u0237&/' 8!:-!! )=.\" 7\u0398"),peg$decode("2\u0399\"\"6\u03997\u039A")];var peg$currPos=0;var peg$savedPos=0;var peg$posDetailsCache=[{line:1,column:1}];var peg$maxFailPos=0;var peg$maxFailExpected=[];var peg$silentFails=0;var peg$resultsCache={};var peg$ruleNames=["start","start_streaming","stmt_list","semi_optional","semi_required","stmt_list_tail","type_definition","type_definition_types","datatype_custom","datatype_word_tail","type_definition_args","definition_args_loop","literal_value","literal_null","literal_date","literal_string","literal_string_single","literal_string_schar","literal_blob","literal_text","number_sign","literal_number_signed","literal_number","literal_number_decimal","number_decimal_node","number_decimal_full","number_decimal_fraction","number_decimal_exponent","literal_number_hex","number_hex","number_digit","bind_parameter","bind_parameter_numbered","bind_number_id","bind_parameter_named","bind_parameter_tcl","tcl_suffix","expression_exists","expression_exists_ne","expression_raise","expression_raise_args","raise_args_ignore","raise_args_message","expression_root","expression_wrapped","expression_recur","expression_unary_collate","expression_unary","expression_unary_op","expression_collate","expression_concat","expression_multiply","expression_multiply_op","expression_add","expression_add_op","expression_shift","expression_shift_op","expression_compare","expression_compare_op","expression_equiv","expression_equiv_tails","expression_equiv_null_op","expression_equiv_op","expression_cast","type_alias","expression_case","case_expression","expression_case_when","expression_case_else","expression_postfix","expression_postfix_tail","expression_like","expression_escape","expression_between","expression_between_tail","expression_is_not","expression_in","expression_in_target","expression_list_or_select","expression_and","expression","expression_list","expression_list_loop","expression_list_rest","function_call","function_call_args","args_list_distinct","error_message","stmt","stmt_modifier","modifier_query","stmt_nodes","stmt_commit","stmt_begin","commit_transaction","stmt_begin_modifier","stmt_rollback","rollback_savepoint","savepoint_name","savepoint_alt","stmt_savepoint","stmt_release","stmt_alter","alter_start","alter_action","alter_action_rename","alter_action_add","action_add_modifier","stmt_crud","stmt_core_with","clause_with","clause_with_recursive","clause_with_tables","clause_with_loop","expression_cte","select_alias","select_wrapped","stmt_select_full","stmt_sqlite","stmt_attach","attach_arg","stmt_detach","stmt_vacuum","vacuum_target","stmt_analyze","analyze_arg","stmt_reindex","reindex_arg","stmt_pragma","pragma_expression","pragma_value","pragma_value_literal","pragma_value_bool","pragma_bool_id","pragma_value_name","stmt_crud_types","stmt_select","stmt_core_order","stmt_core_limit","stmt_core_limit_offset","limit_offset_variant","limit_offset_variant_name","select_loop","select_loop_union","select_parts","select_parts_core","select_core_select","select_modifier","select_modifier_distinct","select_modifier_all","select_target","select_target_loop","select_core_from","stmt_core_where","select_core_group","select_core_having","select_node","select_node_star","select_node_star_qualified","select_node_aliased","select_source","source_loop_tail","select_cross_clause","select_join_clause","table_or_sub","table_or_sub_func","table_qualified","table_qualified_id","table_or_sub_index_node","index_node_indexed","index_node_none","table_or_sub_sub","table_or_sub_select","alias","join_operator","join_operator_natural","join_operator_types","operator_types_hand","types_hand_outer","operator_types_misc","join_condition","join_condition_on","join_condition_using","select_parts_values","stmt_core_order_list","stmt_core_order_list_loop","stmt_core_order_list_item","select_star","stmt_fallback_types","stmt_insert","insert_keyword","insert_keyword_ins","insert_keyword_repl","insert_keyword_mod","insert_target","insert_into","insert_into_start","insert_results","loop_columns","loop_column_tail","loop_name","insert_value","insert_value_start","insert_values_list","insert_values_loop","expression_list_wrapped","insert_default","operator_compound","compound_union","compound_union_all","stmt_update","update_start","update_fallback","update_set","update_columns","update_columns_tail","update_column","stmt_delete","delete_start","stmt_create","create_start","create_table_only","create_index_only","create_trigger_only","create_view_only","create_virtual_only","create_table","create_table_start","create_core_tmp","create_core_ine","create_table_source","table_source_def","source_def_rowid","source_def_loop","source_def_tail","source_tbl_loop","source_def_column","source_def_name","column_type","column_constraints","column_constraint_tail","column_constraint","constraint_name","constraint_name_loop","column_constraint_types","column_constraint_foreign","column_constraint_primary","col_primary_start","col_primary_auto","column_constraint_null","constraint_null_types","constraint_null_value","column_constraint_check","column_constraint_default","column_default_values","column_constraint_collate","table_constraint","table_constraint_types","table_constraint_check","table_constraint_primary","primary_start","primary_start_normal","primary_start_unique","primary_columns","primary_columns_index","primary_columns_table","primary_column_tail","primary_column","primary_column_types","column_collate","column_collate_loop","primary_column_dir","primary_conflict","primary_conflict_start","constraint_check","table_constraint_foreign","foreign_start","foreign_clause","foreign_references","foreign_actions","foreign_actions_tail","foreign_action","foreign_action_on","action_on_action","on_action_set","on_action_cascade","on_action_none","foreign_action_match","foreign_deferrable","deferrable_initially","table_source_select","create_index","create_index_start","index_unique","index_on","create_trigger","create_trigger_start","trigger_conditions","trigger_apply_mods","trigger_apply_instead","trigger_do","trigger_do_on","trigger_do_update","do_update_of","do_update_columns","trigger_foreach","trigger_when","trigger_action","action_loop","action_loop_stmt","create_view","id_view_expression","create_view_start","create_as_select","create_virtual","create_virtual_start","virtual_module","virtual_args","virtual_args_loop","virtual_args_tail","virtual_arg_types","virtual_column_name","stmt_drop","drop_start","drop_types","drop_ie","binary_concat","binary_plus","binary_minus","binary_multiply","binary_divide","binary_mod","binary_left","binary_right","binary_and","binary_or","binary_lt","binary_gt","binary_lte","binary_gte","binary_equal","binary_notequal_a","binary_notequal_b","binary_lang_isnt","id_name","id_database","id_function","id_table","id_table_qualified","id_column","column_unqualified","column_qualifiers","id_column_qualified","id_collation","id_savepoint","id_index","id_trigger","id_view","id_pragma","id_cte","id_table_expression","id_constraint_table","id_constraint_column","datatype_types","datatype_text","datatype_real","datatype_real_double","datatype_numeric","datatype_integer","datatype_integer_fp","datatype_none","name_char","unicode_char","name","name_quoted","name_unquoted","name_reserved","name_bracketed","bracket_terminator","name_dblquoted","name_sglquoted","name_backticked","sym_bopen","sym_bclose","sym_popen","sym_pclose","sym_comma","sym_dot","sym_star","sym_quest","sym_sglquote","sym_dblquote","sym_backtick","sym_tilde","sym_plus","sym_minus","sym_equal","sym_amp","sym_pipe","sym_mod","sym_lt","sym_gt","sym_excl","sym_semi","sym_colon","sym_fslash","sym_bslash","ABORT","ACTION","ADD","AFTER","ALL","ALTER","ANALYZE","AND","AS","ASC","ATTACH","AUTOINCREMENT","BEFORE","BEGIN","BETWEEN","BY","CASCADE","CASE","CAST","CHECK","COLLATE","COLUMN","COMMIT","CONFLICT","CONSTRAINT","CREATE","CROSS","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","DATABASE","DEFAULT","DEFERRABLE","DEFERRED","DELETE","DESC","DETACH","DISTINCT","DROP","EACH","ELSE","END","ESCAPE","EXCEPT","EXCLUSIVE","EXISTS","EXPLAIN","FAIL","FOR","FOREIGN","FROM","FULL","GLOB","GROUP","HAVING","IF","IGNORE","IMMEDIATE","IN","INDEX","INDEXED","INITIALLY","INNER","INSERT","INSTEAD","INTERSECT","INTO","IS","ISNULL","JOIN","KEY","LEFT","LIKE","LIMIT","MATCH","NATURAL","NO","NOT","NOTNULL","NULL","OF","OFFSET","ON","OR","ORDER","OUTER","PLAN","PRAGMA","PRIMARY","QUERY","RAISE","RECURSIVE","REFERENCES","REGEXP","REINDEX","RELEASE","RENAME","REPLACE","RESTRICT","RIGHT","ROLLBACK","ROW","ROWID","SAVEPOINT","SELECT","SET","TABLE","TEMP","TEMPORARY","THEN","TO","TRANSACTION","TRIGGER","UNION","UNIQUE","UPDATE","USING","VACUUM","VALUES","VIEW","VIRTUAL","WHEN","WHERE","WITH","WITHOUT","reserved_words","reserved_word_list","reserved_critical_list","comment","comment_line","comment_block","comment_block_start","comment_block_end","comment_block_body","block_body_nodes","comment_block_feed","o","_TODO_"];var peg$descNames=[null,null,null,null,null,null,"Type Definition",null,"Custom Datatype Name",null,"Type Definition Arguments",null,null,"Null Literal","Date Literal","String Literal","Single-quoted String Literal",null,"Blob Literal",null,"Number Sign",null,null,null,"Decimal Literal",null,null,"Decimal Literal Exponent","Hexidecimal Literal",null,null,"Bind Parameter","Numbered Bind Parameter",null,"Named Bind Parameter","TCL Bind Parameter",null,"EXISTS Expression","EXISTS Keyword","RAISE Expression","RAISE Expression Arguments","IGNORE Keyword",null,null,null,null,null,null,null,"COLLATE Expression",null,null,null,null,null,null,null,null,null,null,null,null,null,"CAST Expression","Type Alias","CASE Expression",null,"WHEN Clause","ELSE Clause",null,null,"Comparison Expression","ESCAPE Expression","BETWEEN Expression",null,null,"IN Expression",null,null,null,null,"Expression List",null,null,"Function Call","Function Call Arguments",null,"Error Message","Statement","QUERY PLAN","QUERY PLAN Keyword",null,"END Transaction Statement","BEGIN Transaction Statement",null,null,"ROLLBACK Statement","TO Clause",null,null,"SAVEPOINT Statement","RELEASE Statement","ALTER TABLE Statement","ALTER TABLE Keyword",null,"RENAME TO Keyword","ADD COLUMN Keyword",null,null,"WITH Clause",null,null,null,null,"Common Table Expression",null,null,null,null,"ATTACH Statement",null,"DETACH Statement","VACUUM Statement",null,"ANALYZE Statement",null,"REINDEX Statement",null,"PRAGMA Statement",null,null,null,null,null,null,null,"SELECT Statement","ORDER BY Clause","LIMIT Clause","OFFSET Clause",null,null,null,"Union Operation",null,null,"SELECT Results Clause","SELECT Results Modifier",null,null,null,null,"FROM Clause","WHERE Clause","GROUP BY Clause","HAVING Clause",null,null,null,null,null,null,"CROSS JOIN Operation","JOIN Operation",null,null,"Qualified Table","Qualified Table Identifier","Qualfied Table Index",null,null,"SELECT Source","Subquery","Alias","JOIN Operator",null,null,null,null,null,"JOIN Constraint","Join ON Clause","Join USING Clause","VALUES Clause",null,null,"Ordering Expression","Star","Fallback Type","INSERT Statement",null,"INSERT Keyword","REPLACE Keyword","INSERT OR Modifier",null,"INTO Clause","INTO Keyword","VALUES Clause","Column List",null,"Column Name","VALUES Clause","VALUES Keyword",null,null,"Wrapped Expression List","DEFAULT VALUES Clause","Compound Operator","UNION Operator",null,"UPDATE Statement","UPDATE Keyword","UPDATE OR Modifier","SET Clause",null,null,"Column Assignment","DELETE Statement","DELETE Keyword","CREATE Statement",null,null,null,null,null,null,"CREATE TABLE Statement",null,null,"IF NOT EXISTS Modifier",null,"Table Definition",null,null,null,null,"Column Definition",null,"Column Datatype",null,null,"Column Constraint",null,"CONSTRAINT Name",null,"FOREIGN KEY Column Constraint","PRIMARY KEY Column Constraint","PRIMARY KEY Keyword","AUTOINCREMENT Keyword",null,"UNIQUE Column Constraint","NULL Column Constraint","CHECK Column Constraint","DEFAULT Column Constraint",null,"COLLATE Column Constraint","Table Constraint",null,"CHECK Table Constraint","PRIMARY KEY Table Constraint",null,"PRIMARY KEY Keyword","UNIQUE Keyword",null,null,null,null,"Indexed Column",null,"Collation",null,"Column Direction",null,"ON CONFLICT Keyword",null,"FOREIGN KEY Table Constraint","FOREIGN KEY Keyword",null,"REFERENCES Clause",null,null,"FOREIGN KEY Action Clause",null,"FOREIGN KEY Action",null,null,null,null,"DEFERRABLE Clause",null,null,"CREATE INDEX Statement",null,null,"ON Clause","CREATE TRIGGER Statement",null,"Conditional Clause",null,null,"Conditional Action",null,null,null,null,null,"WHEN Clause","Actions Clause",null,null,"CREATE VIEW Statement",null,null,null,"CREATE VIRTUAL TABLE Statement",null,null,"Module Arguments",null,null,null,null,"DROP Statement","DROP Keyword","DROP Type","IF EXISTS Keyword","Or","Add","Subtract","Multiply","Divide","Modulo","Shift Left","Shift Right","Logical AND","Logical OR","Less Than","Greater Than","Less Than Or Equal","Greater Than Or Equal","Equal","Not Equal","Not Equal","IS","Identifier","Database Identifier","Function Identifier","Table Identifier",null,"Column Identifier",null,null,null,"Collation Identifier","Savepoint Identifier","Index Identifier","Trigger Identifier","View Identifier","Pragma Identifier","CTE Identifier",null,"Table Constraint Identifier","Column Constraint Identifier","Datatype Name","TEXT Datatype Name","REAL Datatype Name","DOUBLE Datatype Name","NUMERIC Datatype Name","INTEGER Datatype Name",null,"BLOB Datatype Name",null,null,null,null,null,null,null,null,null,null,null,"Open Bracket","Close Bracket","Open Parenthesis","Close Parenthesis","Comma","Period","Asterisk","Question Mark","Single Quote","Double Quote","Backtick","Tilde","Plus","Minus","Equal","Ampersand","Pipe","Modulo","Less Than","Greater Than","Exclamation","Semicolon","Colon","Forward Slash","Backslash",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"Line Comment","Block Comment",null,null,null,null,null,"Whitespace",null];var peg$tracer="tracer"in options?options.tracer:new peg$DefaultTracer();var peg$result;if("startRule"in options){if(!(options.startRule in peg$startRuleIndices)){throw new Error("Can't start parsing from rule \""+options.startRule+"\".");}peg$startRuleIndex=peg$startRuleIndices[options.startRule];}function text(){return input.substring(peg$savedPos,peg$currPos);}function location(){return peg$computeLocation(peg$savedPos,peg$currPos);}function expected(description,location){location=location!==undefined?location:peg$computeLocation(peg$savedPos,peg$currPos);throw peg$buildStructuredError([peg$otherExpectation(description)],input.substring(peg$savedPos,peg$currPos),location);}function error(message,location){location=location!==undefined?location:peg$computeLocation(peg$savedPos,peg$currPos);throw peg$buildSimpleError(message,location);}function peg$literalExpectation(text,ignoreCase){return{type:"literal",text:text,ignoreCase:ignoreCase};}function peg$classExpectation(parts,inverted,ignoreCase){return{type:"class",parts:parts,inverted:inverted,ignoreCase:ignoreCase};}function peg$anyExpectation(){return{type:"any"};}function peg$endExpectation(){return{type:"end"};}function peg$otherExpectation(description){return{type:"other",description:description};}function peg$computePosDetails(pos){var details=peg$posDetailsCache[pos];var p;if(details){return details;}else{p=pos-1;while(!peg$posDetailsCache[p]){p--;}details=peg$posDetailsCache[p];details={line:details.line,column:details.column};while(p<pos){if(input.charCodeAt(p)===10){details.line++;details.column=1;}else{details.column++;}p++;}peg$posDetailsCache[pos]=details;return details;}}function peg$computeLocation(startPos,endPos){var startPosDetails=peg$computePosDetails(startPos);var endPosDetails=peg$computePosDetails(endPos);return{start:{offset:startPos,line:startPosDetails.line,column:startPosDetails.column},end:{offset:endPos,line:endPosDetails.line,column:endPosDetails.column}};}function peg$fail(expected){if(peg$currPos<peg$maxFailPos){return;}if(peg$currPos>peg$maxFailPos){peg$maxFailPos=peg$currPos;peg$maxFailExpected=[];}peg$maxFailExpected.push(expected);}function peg$buildSimpleError(message,location){return new peg$SyntaxError(message,null,null,location);}function peg$buildStructuredError(expected,found,location){return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected,found),expected,found,location);}function peg$decode(s){return s.split("").map(function(ch){return ch.charCodeAt(0)-32;});}function peg$parseRule(index){var bc=peg$bytecode[index];var ip=0;var ips=[];var end=bc.length;var ends=[];var stack=[];var startPos=peg$currPos;var params;peg$tracer.trace({type:"rule.enter",rule:peg$ruleNames[index],description:peg$descNames[index],location:peg$computeLocation(startPos,startPos)});var key=peg$currPos*545+index;var cached=peg$resultsCache[key];if(cached){peg$currPos=cached.nextPos;if(cached.result!==peg$FAILED){peg$tracer.trace({type:"rule.match",rule:peg$ruleNames[index],description:peg$descNames[index],result:cached.result,location:peg$computeLocation(startPos,peg$currPos)});}else{peg$tracer.trace({type:"rule.fail",rule:peg$ruleNames[index],description:peg$descNames[index],location:peg$computeLocation(startPos,startPos)});}return cached.result;}while(true){while(ip<end){switch(bc[ip]){case 0:stack.push(peg$consts[bc[ip+1]]);ip+=2;break;case 1:stack.push(undefined);ip++;break;case 2:stack.push(null);ip++;break;case 3:stack.push(peg$FAILED);ip++;break;case 4:stack.push([]);ip++;break;case 5:stack.push(peg$currPos);ip++;break;case 6:stack.pop();ip++;break;case 7:peg$currPos=stack.pop();ip++;break;case 8:stack.length-=bc[ip+1];ip+=2;break;case 9:stack.splice(-2,1);ip++;break;case 10:stack[stack.length-2].push(stack.pop());ip++;break;case 11:stack.push(stack.splice(stack.length-bc[ip+1],bc[ip+1]));ip+=2;break;case 12:stack.push(input.substring(stack.pop(),peg$currPos));ip++;break;case 13:ends.push(end);ips.push(ip+3+bc[ip+1]+bc[ip+2]);if(stack[stack.length-1]){end=ip+3+bc[ip+1];ip+=3;}else{end=ip+3+bc[ip+1]+bc[ip+2];ip+=3+bc[ip+1];}break;case 14:ends.push(end);ips.push(ip+3+bc[ip+1]+bc[ip+2]);if(stack[stack.length-1]===peg$FAILED){end=ip+3+bc[ip+1];ip+=3;}else{end=ip+3+bc[ip+1]+bc[ip+2];ip+=3+bc[ip+1];}break;case 15:ends.push(end);ips.push(ip+3+bc[ip+1]+bc[ip+2]);if(stack[stack.length-1]!==peg$FAILED){end=ip+3+bc[ip+1];ip+=3;}else{end=ip+3+bc[ip+1]+bc[ip+2];ip+=3+bc[ip+1];}break;case 16:if(stack[stack.length-1]!==peg$FAILED){ends.push(end);ips.push(ip);end=ip+2+bc[ip+1];ip+=2;}else{ip+=2+bc[ip+1];}break;case 17:ends.push(end);ips.push(ip+3+bc[ip+1]+bc[ip+2]);if(input.length>peg$currPos){end=ip+3+bc[ip+1];ip+=3;}else{end=ip+3+bc[ip+1]+bc[ip+2];ip+=3+bc[ip+1];}break;case 18:ends.push(end);ips.push(ip+4+bc[ip+2]+bc[ip+3]);if(input.substr(peg$currPos,peg$consts[bc[ip+1]].length)===peg$consts[bc[ip+1]]){end=ip+4+bc[ip+2];ip+=4;}else{end=ip+4+bc[ip+2]+bc[ip+3];ip+=4+bc[ip+2];}break;case 19:ends.push(end);ips.push(ip+4+bc[ip+2]+bc[ip+3]);if(input.substr(peg$currPos,peg$consts[bc[ip+1]].length).toLowerCase()===peg$consts[bc[ip+1]]){end=ip+4+bc[ip+2];ip+=4;}else{end=ip+4+bc[ip+2]+bc[ip+3];ip+=4+bc[ip+2];}break;case 20:ends.push(end);ips.push(ip+4+bc[ip+2]+bc[ip+3]);if(peg$consts[bc[ip+1]].test(input.charAt(peg$currPos))){end=ip+4+bc[ip+2];ip+=4;}else{end=ip+4+bc[ip+2]+bc[ip+3];ip+=4+bc[ip+2];}break;case 21:stack.push(input.substr(peg$currPos,bc[ip+1]));peg$currPos+=bc[ip+1];ip+=2;break;case 22:stack.push(peg$consts[bc[ip+1]]);peg$currPos+=peg$consts[bc[ip+1]].length;ip+=2;break;case 23:stack.push(peg$FAILED);if(peg$silentFails===0){peg$fail(peg$consts[bc[ip+1]]);}ip+=2;break;case 24:peg$savedPos=stack[stack.length-1-bc[ip+1]];ip+=2;break;case 25:peg$savedPos=peg$currPos;ip++;break;case 26:params=bc.slice(ip+4,ip+4+bc[ip+3]).map(function(p){return stack[stack.length-1-p];});stack.splice(stack.length-bc[ip+2],bc[ip+2],peg$consts[bc[ip+1]].apply(null,params));ip+=4+bc[ip+3];break;case 27:stack.push(peg$parseRule(bc[ip+1]));ip+=2;break;case 28:peg$silentFails++;ip++;break;case 29:peg$silentFails--;ip++;break;default:throw new Error("Invalid opcode: "+bc[ip]+".");}}if(ends.length>0){end=ends.pop();ip=ips.pop();}else{break;}}peg$resultsCache[key]={nextPos:peg$currPos,result:stack[0]};if(stack[0]!==peg$FAILED){peg$tracer.trace({type:"rule.match",rule:peg$ruleNames[index],description:peg$descNames[index],result:stack[0],location:peg$computeLocation(startPos,peg$currPos)});}else{peg$tracer.trace({type:"rule.fail",rule:peg$ruleNames[index],description:peg$descNames[index],location:peg$computeLocation(startPos,startPos)});}return stack[0];}function makeArray(arr){if(!isOkay(arr)){return[];}return!Array.isArray(arr)?[arr]:arr;}function isOkay(obj){return obj!=null;}function foldString(parts){var glue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:' ';var folded=parts.filter(function(part){return isOkay(part);}).reduce(function(prev,cur){return""+prev+nodeToString(cur)+glue;},'');return folded.trim();}function foldStringWord(parts){return foldString(parts,'');}function foldStringKey(parts){return foldString(parts).toLowerCase();}function flattenAll(arr){return arr.filter(function(part){return isOkay(part);}).reduce(function(prev,cur){return prev.concat(cur);},[]);}function unescape(str){var quoteChar=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'\'';var re=new RegExp(quoteChar+"{2}",'g');return nodeToString(str).replace(re,quoteChar);}function nodeToString(){var node=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];return makeArray(node).join('');}function textNode(node){return nodeToString(node).trim();}function keyNode(node){return textNode(node).toLowerCase();}function isArrayOkay(arr){return Array.isArray(arr)&&arr.length>0&&isOkay(arr[0]);}function composeBinary(first,rest){return rest.reduce(function(left,_ref7){var _ref8=_slicedToArray(_ref7,4);var x=_ref8[0];var operation=_ref8[1];var y=_ref8[2];var right=_ref8[3];return{'type':'expression','format':'binary','variant':'operation','operation':keyNode(operation),'left':left,'right':right};},first);}peg$result=peg$parseRule(peg$startRuleIndex);if(peg$result!==peg$FAILED&&peg$currPos===input.length){return peg$result;}else{if(peg$result!==peg$FAILED&&peg$currPos<input.length){peg$fail(peg$endExpectation());}throw peg$buildStructuredError(peg$maxFailExpected,peg$maxFailPos<input.length?input.charAt(peg$maxFailPos):null,peg$maxFailPos<input.length?peg$computeLocation(peg$maxFailPos,peg$maxFailPos+1):peg$computeLocation(peg$maxFailPos,peg$maxFailPos));}}module.exports={SyntaxError:peg$SyntaxError,DefaultTracer:peg$DefaultTracer,parse:peg$parse};

},{}],3:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});function findLastIndex(arr,func){for(var i=arr.length-1;i>=0;i-=1){if(func(arr[i])){return i;}}return-1;}function takeWhile(arr,func){var len=arr.length;var i=0;for(;i<len;i+=1){if(!func(arr[i])){return arr.slice(0,i);}}return arr;}var Tracer=exports.Tracer=function(){function Tracer(){if(!(this instanceof Tracer)){return new Tracer();}this.events=[];this.indentation=0;this.whitespaceRule=/(^whitespace)|(char$)|(^[oe]$)|(^sym\_)/i;this.statementRule=/Statement$/i;this.firstNodeRule=/(Statement|Clause)$/i;};Tracer.prototype.trace=function trace(event){var that=this,lastIndex,lastWsIndex;event.indentation=this.indentation;switch(event.type){case'rule.enter':this.events.push(event);this.indentation+=1;break;case'rule.match':this.indentation-=1;break;case'rule.fail':lastIndex=findLastIndex(this.events,function(_ref){var rule=_ref.rule;return rule===event.rule;});lastWsIndex=findLastIndex(this.events,function(e){return!that.whitespaceRule.test(e.rule);});if(that.whitespaceRule.test(event.rule)||lastIndex===lastWsIndex){this.events.splice(lastIndex,1);}this.indentation-=1;break;}};Tracer.prototype.smartError=function smartError(err){var that=this,message,location,chain,chainDetail,firstNode,bestNode={indentation:-1},deep=false,stmts=0,namedEvents=this.events.filter(function(e){return e.description!=null&&!that.whitespaceRule.test(e.rule);}).reverse();chain=takeWhile(namedEvents,function(elem){if(/^(sym\_semi)$/i.test(elem.rule)){stmts+=1;}if(stmts>1){return false;}if(!deep){if(elem.indentation>bestNode.indentation){bestNode=elem;}else{deep=true;}}else if(/^(stmt)$/i.test(elem.rule)){deep=true;return true;}return true;});if(chain.length){location=bestNode.location;firstNode=chain.find(function(elem){return that.firstNodeRule.test(elem.description)&&elem.description!==bestNode.description&&elem.indentation!==bestNode.indentation;});if(firstNode!=null){if(this.statementRule.test(bestNode.description)&&this.statementRule.test(firstNode.description)){chainDetail=firstNode.description;}else{chainDetail=bestNode.description+' ('+firstNode.description+')';}}else{chainDetail=bestNode.description;}message='Syntax error found near '+chainDetail;Object.assign(err,{'message':message,'location':location});}return err;};return Tracer;}();

},{}]},{},[1])(1)
});
};
BundleModuleCode['plugins/sql/yaml']=function (module,exports){
/*
YAML parser (and simple printer) for Javascript
Author: Diogo Costa

This program is released under the MIT License as follows:

Copyright (c) 2011 Diogo Costa (costa.h4evr@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

/**
 * @name YAML
 * @namespace
*/

var YAML = 
(function() {
    function isDate(value) {
        var dateFormat1 = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/,
            dateFormat2 = /^([0-9]{2,4})-([0-1][0-9])-([0-3][0-9])(?:( [0-2][0-9]):([0-5][0-9]):([0-5][0-9]))?$/,
            dateFormat3 = /[A-Z][a-z]+[ ][A-Z][a-z]+[ ][0-9]+[ ][0-9]+[ ]\d+:\d+:\d+[ ]/;
        return dateFormat1.test(value) || 
               dateFormat2.test(value) ||
               dateFormat3.test(value);
    }
    var errors = [],
        reference_blocks = [],
        processing_time = 0,
        regex =
        {
            "regLevel" : new RegExp("^([\\s\\-]+)"),
            "invalidLine" : new RegExp("^\\-\\-\\-|^\\.\\.\\.|^\\s*#.*|^\\s*$"),
            "dashesString" : new RegExp("^\\s*\\\"([^\\\"]*)\\\"\\s*$"),
            "quotesString" : new RegExp("^\\s*\\\'([^\\\']*)\\\'\\s*$"),
            "float" : new RegExp("^[+-]?[0-9]+\\.[0-9]+(e[+-]?[0-9]+(\\.[0-9]+)?)?$"),
            "integer" : new RegExp("^[+-]?[0-9]+$"),
            // @blab+: prevent array matching within text            
            "array" : new RegExp("^\\[\\s*(.*)\\s*\\]"),
            "map" : new RegExp("\\{\\s*(.*)\\s*\\}"),
            "key_value" : new RegExp("([a-z0-9_-][ a-z0-9_-]*):( .+)", "i"),
            "single_key_value" : new RegExp("^([a-z0-9_-][ a-z0-9_-]*):( .+?)$", "i"),
            // @balb+: prevent key matching in quoted strings in list items: ^[^\"a-z0-9_-]*
            "key" : new RegExp("^[^\"a-z0-9_-]*([a-z0-9_-][ a-z0-9_-]+):( .+)?", "i"),
            "item" : new RegExp("^-\\s+"),
            "trim" : new RegExp("^\\s+|\\s+$"),
            "comment" : new RegExp("([^\\\'\\\"#]+([\\\'\\\"][^\\\'\\\"]*[\\\'\\\"])*)*(#.*)?")
        };
 
     /**
      * @class A block of lines of a given level.
      * @param {int} lvl The block's level.
      * @private
      */
    function Block(lvl) {
        return {
            /* The block's parent */
            parent: null,
            /* Number of children */
            length: 0,
            /* Block's level */
            level: lvl,
            /* Lines of code to process */
            lines: [],
            /* Blocks with greater level */
            children : [],
            /* Add a block to the children collection */
            addChild : function(obj) {
                this.children.push(obj);
                obj.parent = this;
                ++this.length;
            }
        };
    }

    // function to create an XMLHttpClient in a cross-browser manner
    function createXMLHTTPRequest() {
        var xmlhttp;
        
        try {
            // Mozilla / Safari / IE7
            xmlhttp = new XMLHttpRequest();
        } catch (e) {
            // IE
            var XMLHTTP_IDS = new Array('MSXML2.XMLHTTP.5.0',
            'MSXML2.XMLHTTP.4.0',
            'MSXML2.XMLHTTP.3.0',
            'MSXML2.XMLHTTP',
            'Microsoft.XMLHTTP' );
            var success = false;
            for (var i=0;i < XMLHTTP_IDS.length && !success; i++) {
                try {
                xmlhttp = new ActiveXObject(XMLHTTP_IDS[i]);
                success = true;
                } catch (e) {}
            }
            if (!success) {
                throw new Error('Unable to create XMLHttpRequest.');
            }
        }
        
        return xmlhttp;
    }

    function fromURL(src, ondone) {
        var client = createXMLHTTPRequest();
        client.onreadystatechange = function() {
            if (this.readyState == 4 || this.status == 200) {
                var txt = this.responseText;
                ondone(YAML.eval(txt));
            }
        };
        client.open('GET', src);
        client.send();
    }

    function parser(str) {
        var regLevel = regex["regLevel"];
        var invalidLine = regex["invalidLine"];
        var lines = str.split("\n");
        var m;
        var level = 0, curLevel = 0;
        
        var blocks = [];
        
        var result = new Block(-1);
        var currentBlock = new Block(0);
        result.addChild(currentBlock);
        var levels = [];
        var line = "";
        
        blocks.push(currentBlock);
        levels.push(level);
        
        for(var i = 0, len = lines.length; i < len; ++i) {
            line = lines[i];
           
            if(line.match(invalidLine)) {
                continue;
            }
        
            if(m = regLevel.exec(line)) {
                level = m[1].length;
            } else
                level = 0;
            
            if(level > curLevel) {
                var oldBlock = currentBlock;
                currentBlock = new Block(level);
                oldBlock.addChild(currentBlock);
                blocks.push(currentBlock);
                levels.push(level);
            } else if(level < curLevel) {                
                var added = false;

                var k = levels.length - 1;
                for(; k >= 0; --k) {
                    if(levels[k] == level) {
                        currentBlock = new Block(level);
                        blocks.push(currentBlock);
                        levels.push(level);
                        if(blocks[k].parent!= null)
                            blocks[k].parent.addChild(currentBlock);
                        added = true;
                        break;
                    }
                }
                
                if(!added) {
                    errors.push("Error: Invalid indentation at line " + i + ": " + line);
                    return;
                }
            }
            
            currentBlock.lines.push(line.replace(regex["trim"], ""));
            curLevel = level;
        }
        
        return result;
    }
    
    function processValue(val) {
        val = val.replace(regex["trim"], "");
        var m = null;

        if(val == 'true') {
            return true;
        } else if(val == 'false') {
            return false;
        } else if(val == '.NaN') {
            return Number.NaN;
        } else if(val == 'null') {
            return null;
        } else if(val == '.inf') {
            return Number.POSITIVE_INFINITY;
        } else if(val == '-.inf') {
            return Number.NEGATIVE_INFINITY;
        } else if(m = val.match(regex["dashesString"])) {
            return m[1];
        } else if(m = val.match(regex["quotesString"])) {
            return m[1];
        } else if(m = val.match(regex["float"])) {
            return parseFloat(m[0]);
        } else if(m = val.match(regex["integer"])) {
            return parseInt(m[0]);
        } else if( isDate(val) ) {
            return new Date(m);
        } else if(m = val.match(regex["single_key_value"])) {
            var res = {};
            res[m[1]] = processValue(m[2]);
            return res;
        } else if(m = val.match(regex["array"])){
            var count = 0, c = ' ';
            var res = [];
            var content = "";
            var str = false;
            for(var j = 0, lenJ = m[1].length; j < lenJ; ++j) {
                c = m[1][j];
                if(c == '\'' || c == '"') {
                    if(str === false) {
                        str = c;
                        content += c;
                        continue;
                    } else if((c == '\'' && str == '\'') || (c == '"' && str == '"')) {
                        str = false;
                        content += c;
                        continue;
                    }
                } else if(str === false && (c == '[' || c == '{')) {
                    ++count;
                } else if(str === false && (c == ']' || c == '}')) {
                    --count;
                } else if(str === false && count == 0 && c == ',') {
                    res.push(processValue(content));
                    content = "";
                    continue;
                }
                
                content += c;
            }
            
            if(content.length > 0)
                res.push(processValue(content));
            return res;
        } else if(m = val.match(regex["map"])){
            var count = 0, c = ' ';
            var res = [];
            var content = "";
            var str = false;
            for(var j = 0, lenJ = m[1].length; j < lenJ; ++j) {
                c = m[1][j];
                if(c == '\'' || c == '"') {
                    if(str === false) {
                        str = c;
                        content += c;
                        continue;
                    } else if((c == '\'' && str == '\'') || (c == '"' && str == '"')) {
                        str = false;
                        content += c;
                        continue;
                    }
                } else if(str === false && (c == '[' || c == '{')) {
                    ++count;
                } else if(str === false && (c == ']' || c == '}')) {
                    --count;
                } else if(str === false && count == 0 && c == ',') {
                    res.push(content);
                    content = "";
                    continue;
                }
                
                content += c;
            }
            
            if(content.length > 0)
                res.push(content);
                
            var newRes = {};
            for(var j = 0, lenJ = res.length; j < lenJ; ++j) {
                if(m = res[j].match(regex["key_value"])) {
                    newRes[m[1]] = processValue(m[2]);
                }
            }
            
            return newRes;
        } else 
            return val;
    }
    
    function processFoldedBlock(block) {
        var lines = block.lines;
        var children = block.children;
        var str = lines.join(" ");
        var chunks = [str];
        for(var i = 0, len = children.length; i < len; ++i) {
            chunks.push(processFoldedBlock(children[i]));
        }
        return chunks.join("\n");
    }
    
    function processLiteralBlock(block) {
        var lines = block.lines;
        var children = block.children;
        var str = lines.join("\n");
        for(var i = 0, len = children.length; i < len; ++i) {
            str += processLiteralBlock(children[i]);
        }
        return str;
    }
    
    function processBlock(blocks) {
        var m = null;
        var res = {};
        var lines = null;
        var children = null;
        var currentObj = null;
        
        var level = -1;
        
        var processedBlocks = [];
        
        var isMap = true;
        
        for(var j = 0, lenJ = blocks.length; j < lenJ; ++j) {
            
            if(level != -1 && level != blocks[j].level)
                continue;
        
            processedBlocks.push(j);
        
            level = blocks[j].level;
            lines = blocks[j].lines;
            children = blocks[j].children;
            currentObj = null;
        
            for(var i = 0, len = lines.length; i < len; ++i) {
                var line = lines[i];

                if(m = line.match(regex["key"])) {
                    var key = m[1].trim();

                    if(key[0] == '-') {
                        key = key.replace(regex["item"], "");
                        if (isMap) { 
                            isMap = false;
                            if (typeof(res.length) === "undefined") {
                                res = [];
                            } 
                        }
                        if(currentObj != null) res.push(currentObj);
                        currentObj = {};
                        isMap = true;
                    }
                    
                    if(typeof m[2] != "undefined") {
                        var value = m[2].replace(regex["trim"], "");
                        if(value[0] == '&') {
                            var nb = processBlock(children);
                            if(currentObj != null) currentObj[key] = nb;
                            else res[key] = nb;
                            reference_blocks[value.substr(1)] = nb;
                        } else if(value[0] == '|') {
                            if(currentObj != null) currentObj[key] = processLiteralBlock(children.shift());
                            else res[key] = processLiteralBlock(children.shift());
                        } else if(value[0] == '*') {
                            var v = value.substr(1);
                            var no = {};
                            
                            if(typeof reference_blocks[v] == "undefined") {
                                errors.push("Reference '" + v + "' not found!");
                            } else {
                                for(var k in reference_blocks[v]) {
                                    no[k] = reference_blocks[v][k];
                                }
                                
                                if(currentObj != null) currentObj[key] = no;
                                else res[key] = no;
                            }
                        } else if(value[0] == '>') {
                            if(currentObj != null) currentObj[key] = processFoldedBlock(children.shift());
                            else res[key] = processFoldedBlock(children.shift());
                        } else {
                            if(currentObj != null) currentObj[key] = processValue(value);
                            else res[key] = processValue(value);
                        }
                    } else {
                        if(currentObj != null) currentObj[key] = processBlock(children);
                        else res[key] = processBlock(children);                        
                    }
                } else if(line.match(/^-\s*$/)) {
                    if (isMap) { 
                        isMap = false;
                        if (typeof(res.length) === "undefined") {
                            res = [];
                        } 
                    }
                    if(currentObj != null) res.push(currentObj);
                    currentObj = {};
                    isMap = true;
                    continue;
                } else if(m = line.match(/^-\s*(.*)/)) {
                    if(currentObj != null) 
                        currentObj.push(processValue(m[1]));
                    else {
                        if (isMap) { 
                            isMap = false;
                            if (typeof(res.length) === "undefined") {
                                res = [];
                            } 
                        }
                        res.push(processValue(m[1]));
                    }
                    continue;
                }
            }
            
            if(currentObj != null) {
                if (isMap) { 
                    isMap = false;
                    if (typeof(res.length) === "undefined") {
                        res = [];
                    } 
                }
                res.push(currentObj);
            }
        }
        
        for(var j = processedBlocks.length - 1; j >= 0; --j) {
            blocks.splice.call(blocks, processedBlocks[j], 1);
        }

        return res;
    }
        
    function semanticAnalysis(blocks) {
        var res = processBlock(blocks.children);
        return res;
    }
    
    function preProcess(src) {
        var m;
        var lines = src.split("\n");
        
        var r = regex["comment"];
        
        for(var i in lines) {
            if(m = lines[i].match(r)) {
/*                var cmt = "";
                if(typeof m[3] != "undefined")
                    lines[i] = m[1];
                else if(typeof m[3] != "undefined")
                    lines[i] = m[3]; 
                else
                    lines[i] = "";
                    */
                if(typeof m[3] !== "undefined") {
                    lines[i] = m[0].substr(0, m[0].length - m[3].length);
                }
            }
        }
        
        return lines.join("\n");
    }
    
    function eval(str) {
        errors = [];
        reference_blocks = [];
        processing_time = (new Date()).getTime();
        var pre = preProcess(str)
        var doc = parser(pre);
        var res = semanticAnalysis(doc);
        processing_time = (new Date()).getTime() - processing_time;
        
        return res;
    }
     
    function stringify (obj) {
      var indent=0;
      // TODO
      return '';
    }   
    return {        
        /**
         * Load and parse a YAML file from a URL.
         * @param {String} src URL from where to load the YAML file
         * @param {Function} ondone Function that will be called when the file is parsed. The result is passed as an argument.
         * @function
         */
        fromURL : fromURL,
        
        /**
         * Parse a YAML file from a string.
         * @param {String} str String with the YAML file contents.
         * @function
         */
        eval : eval,
        
        /**
         * Get errors found when parsing the last file.
         * @function
         * @returns Errors found when parsing the last file.
         */
        getErrors : function() { return errors; },
        
        /**
         * Get the time it took to parse the last file.
         * @function
         * @returns Time in milliseconds.
         */
        getProcessingTime : function() { return processing_time; },
        
        stringify : stringify
    }
})();
if (typeof module == 'object') module.exports=YAML;
};
BundleModuleCode['plugins/numpy/numpy']=function (module,exports){
/* NUMPY Binary File Reader and Writer

Format Specification: Version 1.0

The first 6 bytes are a magic string: exactly \u201cx93NUMPY\u201d.

The next 1 byte is an unsigned byte: the major version number of the file format, e.g. x01.

The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. x00. Note: the version of the file format is not tied to the version of the numpy package.

The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.

The next HEADER_LEN bytes form the header data describing the array\u2019s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (\u2018n\u2019) and padded with spaces (\u2018x20\u2019) to make the total length of the magic string + 4 + HEADER_LEN be evenly divisible by 16 for alignment purposes.

The dictionary contains three keys:

    \u201cdescr\u201d : dtype.descr
        An object that can be passed as an argument to the numpy.dtype() constructor to create the array\u2019s dtype.
    \u201cfortran_order\u201d : bool
        Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous arrays are a common form of non-C-contiguity, we allow them to be written directly to disk for efficiency.
    \u201cshape\u201d : tuple of int
        The shape of the array.

For repeatability and readability, this dictionary is formatted using pprint.pformat() so the keys are in alphabetic order.

Following the header comes the array data. If the dtype contains Python objects (i.e. dtype.hasobject is True), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on fortran_order) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that shape=() means there is 1 element) by dtype.itemsize.

*/

var fs = require('fs');

// read numpy array from file
function read(path,to) {
  var buf = fs.readFileSync(path),data;
  var array = {
    magic : buf.toString('utf8',0,6),
    major : buf.readUInt8(6),
    minor : buf.readUInt8(7),
    headerLength : buf.readInt16LE(8),
  }
  var desc = buf.toString('utf8',10,10+array.headerLength);
  desc=desc.replace(/'shape'[ ]*:/,'shape:Tuple');
  with({
    False:false,
    Tuple:function () {
      return Array.from(arguments)
    }}) { eval('array.dict = '+desc) };
  array.dataspace=array.dict.shape;
  switch (array.dict.descr) {
    case '|u1':
      array.datatype='Uint8';
      data=buf.slice(10+array.headerLength);
      array.data=new Uint8Array(new Uint8Array(data).buffer);
      break;
    case '<u2':
      array.datatype='Uint16';
      data=buf.slice(10+array.headerLength);
      array.data=new Uint16Array(new Uint8Array(data).buffer);
      break;
   case '<u4':
      array.datatype='Uint32';
      data=buf.slice(10+array.headerLength);
      array.data=new Uint32Array(new Uint8Array(data).buffer);
      break;
    case '<i1':
      array.datatype='Int8';
      data=buf.slice(10+array.headerLength);
      array.data=new Int8Array(new Uint8Array(data).buffer);
      break;
    case '<i2':
      array.datatype='Int16';
      data=buf.slice(10+array.headerLength);
      array.data=new Int16Array(new Uint8Array(data).buffer);
      break;
   case '<i4':
      array.datatype='Int32';
      data=buf.slice(10+array.headerLength);
      array.data=new Int32Array(new Uint8Array(data).buffer);
      break;
   case '<f4':
      array.datatype='Float32';
      data=buf.slice(10+array.headerLength);
      array.data=new Float32Array(new Uint8Array(data).buffer);
      break;
   case '<f8':
      array.datatype='Float64';
      data=buf.slice(10+array.headerLength);
      array.data=new Float64Array(new Uint8Array(data).buffer);
      break;
   default:
      throw ("numpy.read: unsupported data type "+array.dict.descr);
  }
  switch (to) {
    case 'MatrixTA':
    default:
      if (Math.MatrixTA)
        return Math.MatrixTA({data:array.data,dataspace:array.dataspace,datatype:array.datatype});
      else
        return array;
      break;
      
  }
  return array;
}

// write numpy array to file 
// typeof @options = { datatype?:string }

function write(path,data,options) {
  options=options||{};
  function info (data,levels) {
    var buf,dataspace,datatype,header;
    dataspace=[];
    if (data.levels || levels) dataspace.push(data.levels||levels);
    if (data.rows!=1) dataspace.push(data.rows);
    dataspace.push(data.columns);
    datatype=data.dtn;
    header = {
      magic : String.fromCharCode(0x93)+'NUMPY',
      major : 1,
      minor : 0,
      dict : {
        fortran_order: 'False',
        shape : '('+dataspace.join(',')+')',
      }
    }
    switch (datatype) {
        case 'Int8Array': header.dict.descr='<i1'; break;
        case 'Int16Array': header.dict.descr='<i2'; break;
        case 'Int32Array': header.dict.descr='<i4'; break;
        case 'Uint8Array': header.dict.descr='|u1'; break;
        case 'Uint16Array': header.dict.descr='<u2'; break;
        case 'Uint32Array': header.dict.descr='<u4'; break;
        case 'Float32Array': header.dict.descr='<f4'; break;
        case 'Float64Array': header.dict.descr='<f8'; break;
    }
    var s="{'descr': '"+header.dict.descr+"', "+
          "'fortran_order': "+header.dict.fortran_order+", "+
          "'shape': "+header.dict.shape+", }";
    header.string=s;
    header.headerLength=s.length;
    return header 
  }
  
  if (Utils.isArray(data) && Math.MatrixTA && Math.MatrixTA.isMatrix(data[0])) {
    // Array of Typedarrays (MatrixTA)
    var buf;
    var header=info(data[0],data.length);
    buf=Buffer(10+header.headerLength+data[0].data.byteLength*data.length);
    buf.write(header.magic,0,'ascii');
    buf.writeUInt8(header.major,6);
    buf.writeUInt8(header.minor,7);
    buf.writeInt16LE(header.headerLength,8);
    buf.write(header.string,10,'ascii');
    var off=10+header.headerLength;
    data.forEach(function (mat,index) {
      Buffer(mat.data.buffer).copy(buf,off);
      off += mat.data.byteLength;
    });
    return fs.writeFileSync(path,buf);    
  } else if (Math.MatrixTA && Math.MatrixTA.isMatrix(data)) {
    // Typed arrays
    var buf;
    var header=info(data);
    buf=Buffer(10+header.headerLength+data.data.byteLength);
    buf.write(header.magic,0,'ascii');
    buf.writeUInt8(header.major,6);
    buf.writeUInt8(header.minor,7);
    buf.writeInt16LE(header.headerLength,8);
    buf.write(header.string,10,'ascii');
    Buffer(data.data.buffer).copy(buf,10+header.headerLength);
    return fs.writeFileSync(path,buf);
  } else if ((Math.MatrixTA && Math.Matrix && Math.Matrix.isMatrix(data)) ||
             (Math.MatrixTA && Utils.isArrayArray(data))) {
    // Generic arrays; must be converted on-the-fly to packed typed arrays
    var buf,byteLength;
    var datatype=options.datatype||'Float64';
    var _data = Math.MatrixTA(Utils.isArrayArray(data)?data:data.data,{datatype:datatype});
    var header=info(_data);
    buf=Buffer(10+header.headerLength+_data.data.byteLength);
    buf.write(header.magic,0,'ascii');
    buf.writeUInt8(header.major,6);
    buf.writeUInt8(header.minor,7);
    buf.writeInt16LE(header.headerLength,8);
    buf.write(header.string,10,'ascii');
    Buffer(_data.data.buffer).copy(buf,10+header.headerLength);
    return fs.writeFileSync(path,buf);
  } else throw "numpy.write: unspported data format";
}

module.exports = {
  read:read,
  write:write,
  version : '1.1.2'
}
};
BundleModuleCode['plugins/image/UPNG']=function (module,exports){

var UPNG = {};
// https://github.com/photopea/UPNG.js
var pako = Require("plugins/image/pako");
	
// TODO: toRGB8, toGRAY8
	
// @blab+ returns Uint8Array (.buffer returns ArrayBuffer)
UPNG.toRGBA8 = function(out)
{
	var w = out.width, h = out.height;
	if(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out)/*.buffer*/];
	
	var frms = [];
	if(out.frames[0].data==null) out.frames[0].data = out.data;
	
	var len = w*h*4, img = new Uint8Array(len), empty = new Uint8Array(len), prev=new Uint8Array(len);
	for(var i=0; i<out.frames.length; i++)
	{
		var frm = out.frames[i];
		var fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
		var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);
		
		if(i!=0) for(var j=0; j<len; j++) prev[j]=img[j];
		
		if     (frm.blend==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
		else if(frm.blend==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
		
		frms.push(img.buffer.slice(0));
		
		if     (frm.dispose==0) {}
		else if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
		else if(frm.dispose==2) for(var j=0; j<len; j++) img[j]=prev[j];
	}
	return frms;
}
UPNG.toRGBA8.decodeImage = function(data, w, h, out)
{
	var area = w*h, bpp = UPNG.decode._getBPP(out);
	var bpl = Math.ceil(w*bpp/8);	// bytes per line

	var bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);
	var ctype = out.ctype, depth = out.depth;
	var rs = UPNG._bin.readUshort;
	
	//console.log(ctype, depth);
	var time = Date.now();

	if     (ctype==6) { // RGB + alpha
		var qarea = area<<2;
		if(depth== 8) for(var i=0; i<qarea;i+=4) {  bf[i] = data[i];  bf[i+1] = data[i+1];  bf[i+2] = data[i+2];  bf[i+3] = data[i+3]; }
		if(depth==16) for(var i=0; i<qarea;i++ ) {  bf[i] = data[i<<1];  }
	}
	else if(ctype==2) {	// RGB
		var ts=out.tabs["tRNS"];
		if(ts==null) {
			if(depth== 8) for(var i=0; i<area; i++) {  var ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];  }
			if(depth==16) for(var i=0; i<area; i++) {  var ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];  }
		}
		else {  var tr=ts[0], tg=ts[1], tb=ts[2];
			if(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];
				if(data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }
			if(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];
				if(rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }
		}
	}
	else if(ctype==3) {	// palette
		var p=out.tabs["PLTE"], ap=out.tabs["tRNS"], tl=ap?ap.length:0;
		//console.log(p, ap);
		if(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;
			for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
		}
		if(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;
			for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
		}
		if(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;
			for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
		}
		if(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
	}
	else if(ctype==4) {	// gray + alpha
		if(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }
		if(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }
	}
	else if(ctype==0) {	// gray
		var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
		for(var y=0; y<h; y++) {
			var off = y*bpl, to = y*w;
			if     (depth== 1) for(var x=0; x<w; x++) {  var gr=255*((data[off+(x>>>3)]>>>(7 -((x&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
			else if(depth== 2) for(var x=0; x<w; x++) {  var gr= 85*((data[off+(x>>>2)]>>>(6 -((x&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
			else if(depth== 4) for(var x=0; x<w; x++) {  var gr= 17*((data[off+(x>>>1)]>>>(4 -((x&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
			else if(depth== 8) for(var x=0; x<w; x++) {  var gr=data[off+     x], al=(gr                 ==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
			else if(depth==16) for(var x=0; x<w; x++) {  var gr=data[off+(x<<1)], al=(rs(data,off+(x<<i))==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
		}
	}
	//console.log(Date.now()-time);
	return bf;
}



UPNG.decode = function(buff)
{
	var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
	var out = {tabs:{}, frames:[]};
	var dd = new Uint8Array(data.length), doff = 0;	 // put all IDAT data into it
	var fd, foff = 0;	// frames
	
	var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
	for(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw "The input is not a PNG file!";

	while(offset<data.length)
	{
		var len  = bin.readUint(data, offset);  offset += 4;
		var type = bin.readASCII(data, offset, 4);  offset += 4;
		//console.log(type,len);
		
		if     (type=="IHDR")  {  UPNG.decode._IHDR(data, offset, out);  }
		else if(type=="CgBI")  {  out.tabs[type] = data.slice(offset,offset+4);  }
		else if(type=="IDAT") {
			for(var i=0; i<len; i++) dd[doff+i] = data[offset+i];
			doff += len;
		}
		else if(type=="acTL")  {
			out.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };
			fd = new Uint8Array(data.length);
		}
		else if(type=="fcTL")  {
			if(foff!=0) {  var fr = out.frames[out.frames.length-1];
				fr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;
			}
			var rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};
			var del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);
			var frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};
			//console.log(frm);
			out.frames.push(frm);
		}
		else if(type=="fdAT") {
			for(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];
			foff += len-4;
		}
		else if(type=="pHYs") {
			out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];
		}
		else if(type=="cHRM") {
			out.tabs[type] = [];
			for(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));
		}
		else if(type=="tEXt" || type=="zTXt") {
			if(out.tabs[type]==null) out.tabs[type] = {};
			var nz = bin.nextZero(data, offset);
			var keyw = bin.readASCII(data, offset, nz-offset);
			var text, tl=offset+len-nz-1;
			if(type=="tEXt") text = bin.readASCII(data, nz+1, tl);
			else {
				var bfr = UPNG.decode._inflate(data.slice(nz+2,nz+2+tl));
				text = bin.readUTF8(bfr,0,bfr.length);
			}
			out.tabs[type][keyw] = text;
		}
		else if(type=="iTXt") {
			if(out.tabs[type]==null) out.tabs[type] = {};
			var nz = 0, off = offset;
			nz = bin.nextZero(data, off);
			var keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;
			var cflag = data[off], cmeth = data[off+1];  off+=2;
			nz = bin.nextZero(data, off);
			var ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;
			nz = bin.nextZero(data, off);
			var tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;
			var text, tl=len-(off-offset);
			if(cflag==0) text  = bin.readUTF8(data, off, tl);
			else {
				var bfr = UPNG.decode._inflate(data.slice(off,off+tl));
				text = bin.readUTF8(bfr,0,bfr.length);
			}
			out.tabs[type][keyw] = text;
		}
		else if(type=="PLTE") {
			out.tabs[type] = bin.readBytes(data, offset, len);
		}
		else if(type=="hIST") {
			var pl = out.tabs["PLTE"].length/3;
			out.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));
		}
		else if(type=="tRNS") {
			if     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);
			else if(out.ctype==0) out.tabs[type] = rUs(data, offset);
			else if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];
			//else console.log("tRNS for unsupported color type",out.ctype, len);
		}
		else if(type=="gAMA") out.tabs[type] = bin.readUint(data, offset)/100000;
		else if(type=="sRGB") out.tabs[type] = data[offset];
		else if(type=="bKGD")
		{
			if     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];
			else if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];
			else if(out.ctype==3) out.tabs[type] = data[offset];
		}
		else if(type=="IEND") {
			break;
		}
		//else {  log("unknown chunk type", type, len);  }
		offset += len;
		var crc = bin.readUint(data, offset);  offset += 4;
	}
	if(foff!=0) {  var fr = out.frames[out.frames.length-1];
		fr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;
	}	
	out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
	
	delete out.compress;  delete out.interlace;  delete out.filter;
	return out;
}

UPNG.decode._decompress = function(out, dd, w, h) {
	var time = Date.now();
	var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), buff = new Uint8Array((bpl+1+out.interlace)*h);
	if(out.tabs["CgBI"]) dd = UPNG.inflateRaw(dd,buff);
	else                 dd = UPNG.decode._inflate(dd,buff);
	//console.log(dd.length, buff.length);
	//console.log(Date.now()-time);

	var time=Date.now();
	if     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);
	else if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);
	//console.log(Date.now()-time);
	return dd;
}

UPNG.decode._inflate = function(data, buff) {  var out=UPNG["inflateRaw"](new Uint8Array(data.buffer, 2,data.length-6),buff);  return out;  }
UPNG.inflateRaw=function(){var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;
if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;
if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);
var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;
w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;
h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;
c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;
d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);
I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;
if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);
d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};
H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};
H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;
if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);
n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;
while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};
H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;
var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];
b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);
while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;
n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};
H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};
H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};
H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;
return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();
(function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;
V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;
N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];
N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);
H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);
n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()


UPNG.decode._readInterlace = function(data, out)
{
	var w = out.width, h = out.height;
	var bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);
	var img = new Uint8Array( h * bpl );
	var di = 0;

	var starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];
	var starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];
	var row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];
	var col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];

	var pass=0;
	while(pass<7)
	{
		var ri = row_increment[pass], ci = col_increment[pass];
		var sw = 0, sh = 0;
		var cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }
		var cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }
		var bpll = Math.ceil(sw*bpp/8);
		UPNG.decode._filterZero(data, out, di, sw, sh);

		var y=0, row = starting_row[pass];
		while(row<h)
		{
			var col = starting_col[pass];
			var cdi = (di+y*bpll)<<3;

			while(col<w)
			{
				if(bpp==1) {
					var val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;
					img[row*bpl + (col>>3)] |= (val << (7-((col&7)<<0)));
				}
				if(bpp==2) {
					var val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;
					img[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));
				}
				if(bpp==4) {
					var val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;
					img[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));
				}
				if(bpp>=8) {
					var ii = row*bpl+col*cbpp;
					for(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];
				}
				cdi+=bpp;  col+=ci;
			}
			y++;  row += ri;
		}
		if(sw*sh!=0) di += sh * (1 + bpll);
		pass = pass + 1;
	}
	return img;
}

UPNG.decode._getBPP = function(out) {
	var noc = [1,null,3,1,2,null,4][out.ctype];
	return noc * out.depth;
}

UPNG.decode._filterZero = function(data, out, off, w, h)
{
	var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;
	bpp = Math.ceil(bpp/8);
	
	var i=0, di=1, type=data[off], x=0;
	
	if(type>1) data[off]=[0,0,1][type-2];  
	if(type==3) for(x=bpp; x<bpl; x++) data[x+1] = (data[x+1] + (data[x+1-bpp]>>>1) )&255;

	for(var y=0; y<h; y++)  {
		i = off+y*bpl; di = i+y+1;
		type = data[di-1]; x=0;

		if     (type==0)   for(; x<bpl; x++) data[i+x] = data[di+x];
		else if(type==1) { for(; x<bpp; x++) data[i+x] = data[di+x];
						   for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp]);  }
		else if(type==2) { for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl]);  }
		else if(type==3) { for(; x<bpp; x++) data[i+x] = (data[di+x] + ( data[i+x-bpl]>>>1));
			               for(; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>>1) );  }
		else             { for(; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0));
						   for(; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) );  }
	}
	return data;
}

UPNG.decode._paeth = function(a,b,c)
{
	var p = a+b-c, pa = (p-a), pb = (p-b), pc = (p-c);
	if (pa*pa <= pb*pb && pa*pa <= pc*pc)  return a;
	else if (pb*pb <= pc*pc)  return b;
	return c;
}

UPNG.decode._IHDR = function(data, offset, out)
{
	var bin = UPNG._bin;
	out.width  = bin.readUint(data, offset);  offset += 4;
	out.height = bin.readUint(data, offset);  offset += 4;
	out.depth     = data[offset];  offset++;
	out.ctype     = data[offset];  offset++;
	out.compress  = data[offset];  offset++;
	out.filter    = data[offset];  offset++;
	out.interlace = data[offset];  offset++;
}

UPNG._bin = {
	nextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },
	readUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },
	writeUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },
	readUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },
	writeUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },
	readASCII  : function(buff,p,l){  var s = "";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },
	writeASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },
	readBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },
	pad : function(n) { return n.length < 2 ? "0" + n : n; },
	readUTF8 : function(buff, p, l) {
		var s = "", ns;
		for(var i=0; i<l; i++) s += "%" + UPNG._bin.pad(buff[p+i].toString(16));
		try {  ns = decodeURIComponent(s); }
		catch(e) {  return UPNG._bin.readASCII(buff, p, l);  }
		return  ns;
	}
}
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)
{
	var w = Math.min(sw,tw), h = Math.min(sh,th);
	var si=0, ti=0;
	for(var y=0; y<h; y++)
		for(var x=0; x<w; x++)
		{
			if(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }
			else                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }
			
			if     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }
			else if(mode==1) {
				var fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa; 
				var ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba; 
				
				var ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);
				tb[ti+3] = 255*oa;  
				tb[ti+0] = (fr+br*ifa)*ioa;  
				tb[ti+1] = (fg+bg*ifa)*ioa;   
				tb[ti+2] = (fb+bb*ifa)*ioa;  
			}
			else if(mode==2){	// copy only differences, otherwise zero
				var fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; 
				var ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; 
				if(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }
				else {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }
			}
			else if(mode==3){	// check if can be blended
				var fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; 
				var ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; 
				if(fa==ba && fr==br && fg==bg && fb==bb) continue;
				//if(fa!=255 && ba!=0) return false;
				if(fa<220 && ba>20) return false;
			}
		}
	return true;
}




UPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte)
{
	if(ps==null) ps=0;
	if(forbidPlte==null) forbidPlte = false;

	var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);
	UPNG.encode.compressPNG(nimg, -1);
	
	return UPNG.encode._main(nimg, w, h, dels, tabs);
}

UPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {
	var nimg = {  ctype: 0 + (cc==1 ? 0 : 2) + (ac==0 ? 0 : 4),      depth: depth,  frames: []  };
	
	var time = Date.now();
	var bipp = (cc+ac)*depth, bipl = bipp * w;
	for(var i=0; i<bufs.length; i++)
		nimg.frames.push({  rect:{x:0,y:0,width:w,height:h},  img:new Uint8Array(bufs[i]), blend:0, dispose:1, bpp:Math.ceil(bipp/8), bpl:Math.ceil(bipl/8)  });
	
	UPNG.encode.compressPNG(nimg, 0, true);
	
	var out = UPNG.encode._main(nimg, w, h, dels, tabs);
	return out;
}

UPNG.encode._main = function(nimg, w, h, dels, tabs) {
	if(tabs==null) tabs={};
	var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;
	var offset = 8, anim = nimg.frames.length>1, pltAlpha = false;
	
	var leng = 8 + (16+5+4) /*+ (9+4)*/ + (anim ? 20 : 0);
	if(tabs["sRGB"]!=null) leng += 8+1+4;
	if(tabs["pHYs"]!=null) leng += 8+9+4;
	if(nimg.ctype==3) {
		var dl = nimg.plte.length;
		for(var i=0; i<dl; i++) if((nimg.plte[i]>>>24)!=255) pltAlpha = true;
		leng += (8 + dl*3 + 4) + (pltAlpha ? (8 + dl*1 + 4) : 0);
	}
	for(var j=0; j<nimg.frames.length; j++)
	{
		var fr = nimg.frames[j];
		if(anim) leng += 38;
		leng += fr.cimg.length + 12;
		if(j!=0) leng+=4;
	}
	leng += 12; 
	
	var data = new Uint8Array(leng);
	var wr=[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
	for(var i=0; i<8; i++) data[i]=wr[i];
	
	wUi(data,offset, 13);     offset+=4;
	wAs(data,offset,"IHDR");  offset+=4;
	wUi(data,offset,w);  offset+=4;
	wUi(data,offset,h);  offset+=4;
	data[offset] = nimg.depth;  offset++;  // depth
	data[offset] = nimg.ctype;  offset++;  // ctype
	data[offset] = 0;  offset++;  // compress
	data[offset] = 0;  offset++;  // filter
	data[offset] = 0;  offset++;  // interlace
	wUi(data,offset,crc(data,offset-17,17));  offset+=4; // crc

	// 13 bytes to say, that it is sRGB
	if(tabs["sRGB"]!=null) {
		wUi(data,offset, 1);      offset+=4;
		wAs(data,offset,"sRGB");  offset+=4;
		data[offset] = tabs["sRGB"];  offset++;
		wUi(data,offset,crc(data,offset-5,5));  offset+=4; // crc
	}
	if(tabs["pHYs"]!=null) {
		wUi(data,offset, 9);      offset+=4;
		wAs(data,offset,"pHYs");  offset+=4;
		wUi(data,offset, tabs["pHYs"][0]);      offset+=4;
		wUi(data,offset, tabs["pHYs"][1]);      offset+=4;
		data[offset]=tabs["pHYs"][2];			offset++;
		wUi(data,offset,crc(data,offset-13,13));  offset+=4; // crc
	}

	if(anim) {
		wUi(data,offset, 8);      offset+=4;
		wAs(data,offset,"acTL");  offset+=4;
		wUi(data,offset, nimg.frames.length);     offset+=4;
		wUi(data,offset, tabs["loop"]!=null?tabs["loop"]:0);      offset+=4;
		wUi(data,offset,crc(data,offset-12,12));  offset+=4; // crc
	}

	if(nimg.ctype==3) {
		var dl = nimg.plte.length;
		wUi(data,offset, dl*3);  offset+=4;
		wAs(data,offset,"PLTE");  offset+=4;
		for(var i=0; i<dl; i++){
			var ti=i*3, c=nimg.plte[i], r=(c)&255, g=(c>>>8)&255, b=(c>>>16)&255;
			data[offset+ti+0]=r;  data[offset+ti+1]=g;  data[offset+ti+2]=b;
		}
		offset+=dl*3;
		wUi(data,offset,crc(data,offset-dl*3-4,dl*3+4));  offset+=4; // crc

		if(pltAlpha) {
			wUi(data,offset, dl);  offset+=4;
			wAs(data,offset,"tRNS");  offset+=4;
			for(var i=0; i<dl; i++)  data[offset+i]=(nimg.plte[i]>>>24)&255;
			offset+=dl;
			wUi(data,offset,crc(data,offset-dl-4,dl+4));  offset+=4; // crc
		}
	}
	
	var fi = 0;
	for(var j=0; j<nimg.frames.length; j++)
	{
		var fr = nimg.frames[j];
		if(anim) {
			wUi(data, offset, 26);     offset+=4;
			wAs(data, offset,"fcTL");  offset+=4;
			wUi(data, offset, fi++);   offset+=4;
			wUi(data, offset, fr.rect.width );   offset+=4;
			wUi(data, offset, fr.rect.height);   offset+=4;
			wUi(data, offset, fr.rect.x);   offset+=4;
			wUi(data, offset, fr.rect.y);   offset+=4;
			wUs(data, offset, dels[j]);   offset+=2;
			wUs(data, offset,  1000);   offset+=2;
			data[offset] = fr.dispose;  offset++;	// dispose
			data[offset] = fr.blend  ;  offset++;	// blend
			wUi(data,offset,crc(data,offset-30,30));  offset+=4; // crc
		}
				
		var imgd = fr.cimg, dl = imgd.length;
		wUi(data,offset, dl+(j==0?0:4));     offset+=4;
		var ioff = offset;
		wAs(data,offset,(j==0)?"IDAT":"fdAT");  offset+=4;
		if(j!=0) {  wUi(data, offset, fi++);  offset+=4;  }
		data.set(imgd,offset);
		offset += dl;
		wUi(data,offset,crc(data,ioff,offset-ioff));  offset+=4; // crc
	}

	wUi(data,offset, 0);     offset+=4;
	wAs(data,offset,"IEND");  offset+=4;
	wUi(data,offset,crc(data,offset-4,4));  offset+=4; // crc

	return data.buffer;
}

UPNG.encode.compressPNG = function(out, filter, levelZero) {
	for(var i=0; i<out.frames.length; i++) {
		var frm = out.frames[i], nw=frm.rect.width, nh=frm.rect.height;
		var fdata = new Uint8Array(nh*frm.bpl+nh);
		frm.cimg = UPNG.encode._filterZero(frm.img,nh,frm.bpp,frm.bpl,fdata, filter, levelZero);
	}
}



UPNG.encode.compress = function(bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte
{
	//var time = Date.now();
	var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];
	
	var ctype = 6, depth = 8, alphaAnd=255
	
	for(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame
		var img = new Uint8Array(bufs[j]), ilen = img.length;
		for(var i=0; i<ilen; i+=4) alphaAnd &= img[i+3];
	}
	var gotAlpha = (alphaAnd!=255);
	
	//console.log("alpha check", Date.now()-time);  time = Date.now();
	
	//var brute = gotAlpha && forGIF;		// brute : frames can only be copied, not "blended"
	var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);
	//console.log("framize", Date.now()-time);  time = Date.now();
	
	var cmap={}, plte=[], inds=[]; 
	
	if(ps!=0) {
		var nbufs = [];  for(var i=0; i<frms.length; i++) nbufs.push(frms[i].img.buffer);
		
		var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);  console.log(qres);
		var cof = 0, bb = new Uint8Array(qres.abuf);
		for(var i=0; i<frms.length; i++) {  var ti=frms[i].img, bln=ti.length;  inds.push(new Uint8Array(qres.inds.buffer, cof>>2, bln>>2));
			for(var j=0; j<bln; j+=4) {  ti[j]=bb[cof+j];  ti[j+1]=bb[cof+j+1];  ti[j+2]=bb[cof+j+2];  ti[j+3]=bb[cof+j+3];  }    cof+=bln;  }
		
		for(var i=0; i<qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);
		//console.log("quantize", Date.now()-time);  time = Date.now();
	}
	else {
		// what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used
		for(var j=0; j<frms.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame
			var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw=frm.rect.width, ilen = img32.length;
			var ind = new Uint8Array(ilen);  inds.push(ind);
			for(var i=0; i<ilen; i++) {
				var c = img32[i];
				if     (i!=0 && c==img32[i- 1]) ind[i]=ind[i-1];
				else if(i>nw && c==img32[i-nw]) ind[i]=ind[i-nw];
				else {
					var cmc = cmap[c];
					if(cmc==null) {  cmap[c]=cmc=plte.length;  plte.push(c);  if(plte.length>=300) break;  }
					ind[i]=cmc;
				}
			}
		}
		//console.log("make palette", Date.now()-time);  time = Date.now();
	}
	
	var cc=plte.length; //console.log("colors:",cc);
	if(cc<=256 && forbidPlte==false) {
		if(cc<= 2) depth=1;  else if(cc<= 4) depth=2;  else if(cc<=16) depth=4;  else depth=8;
		depth =  Math.max(depth, minBits);
	}
	
	for(var j=0; j<frms.length; j++)
	{
		var frm = frms[j], nx=frm.rect.x, ny=frm.rect.y, nw=frm.rect.width, nh=frm.rect.height;
		var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);
		var bpl = 4*nw, bpp=4;
		if(cc<=256 && forbidPlte==false) {
			bpl = Math.ceil(depth*nw/8);
			var nimg = new Uint8Array(bpl*nh);
			var inj = inds[j];
			for(var y=0; y<nh; y++) {  var i=y*bpl, ii=y*nw;
				if     (depth==8) for(var x=0; x<nw; x++) nimg[i+(x)   ]   =  (inj[ii+x]             );
				else if(depth==4) for(var x=0; x<nw; x++) nimg[i+(x>>1)]  |=  (inj[ii+x]<<(4-(x&1)*4));
				else if(depth==2) for(var x=0; x<nw; x++) nimg[i+(x>>2)]  |=  (inj[ii+x]<<(6-(x&3)*2));
				else if(depth==1) for(var x=0; x<nw; x++) nimg[i+(x>>3)]  |=  (inj[ii+x]<<(7-(x&7)*1));
			}
			cimg=nimg;  ctype=3;  bpp=1;
		}
		else if(gotAlpha==false && frms.length==1) {	// some next "reduced" frames may contain alpha for blending
			var nimg = new Uint8Array(nw*nh*3), area=nw*nh;
			for(var i=0; i<area; i++) { var ti=i*3, qi=i*4;  nimg[ti]=cimg[qi];  nimg[ti+1]=cimg[qi+1];  nimg[ti+2]=cimg[qi+2];  }
			cimg=nimg;  ctype=2;  bpp=3;  bpl=3*nw;
		}
		frm.img=cimg;  frm.bpl=bpl;  frm.bpp=bpp;
	}
	//console.log("colors => palette indices", Date.now()-time);  time = Date.now();
	
	return {ctype:ctype, depth:depth, plte:plte, frames:frms  };
}
UPNG.encode.framize = function(bufs,w,h,alwaysBlend,evenCrd,forbidPrev) {
	/*  DISPOSE
	    - 0 : no change
		- 1 : clear to transparent
		- 2 : retstore to content before rendering (previous frame disposed)
		BLEND
		- 0 : replace
		- 1 : blend
	*/
	var frms = [];
	for(var j=0; j<bufs.length; j++) {
		var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);
		var nimg;
		
		var nx=0, ny=0, nw=w, nh=h, blend=alwaysBlend?1:0;
		if(j!=0) {
			var tlim = (forbidPrev || alwaysBlend || j==1 || frms[j-2].dispose!=0)?1:2, tstp = 0, tarea = 1e9;
			for(var it=0; it<tlim; it++)
			{
				var pimg = new Uint8Array(bufs[j-1-it]), p32 = new Uint32Array(bufs[j-1-it]);
				var mix=w,miy=h,max=-1,may=-1;
				for(var y=0; y<h; y++) for(var x=0; x<w; x++) {
					var i = y*w+x;
					if(cimg32[i]!=p32[i]) {
						if(x<mix) mix=x;  if(x>max) max=x;
						if(y<miy) miy=y;  if(y>may) may=y;
					}
				}
				if(max==-1) mix=miy=max=may=0;
				if(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }
				var sarea = (max-mix+1)*(may-miy+1);
				if(sarea<tarea) {
					tarea = sarea;  tstp = it;
					nx = mix; ny = miy; nw = max-mix+1; nh = may-miy+1;
				}
			}
			
			// alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.
			var pimg = new Uint8Array(bufs[j-1-tstp]);
			if(tstp==1) frms[j-1].dispose = 2;
			
			nimg = new Uint8Array(nw*nh*4);
			UPNG._copyTile(pimg,w,h, nimg,nw,nh, -nx,-ny, 0);
			
			blend =  UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 3) ? 1 : 0;
			if(blend==1) UPNG.encode._prepareDiff(cimg,w,h,nimg,{x:nx,y:ny,width:nw,height:nh});
			else         UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 0);
			//UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);
		}
		else nimg = cimg.slice(0);	// img may be rewritten further ... don't rewrite input
		
		frms.push({rect:{x:nx,y:ny,width:nw,height:nh}, img:nimg, blend:blend, dispose:0});
	}
	
	
	if(alwaysBlend) for(var j=0; j<frms.length; j++) {
		var frm = frms[j];  if(frm.blend==1) continue;
		var r0 = frm.rect, r1 = frms[j-1].rect
		var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);
		var maX = Math.max(r0.x+r0.width, r1.x+r1.width), maY = Math.max(r0.y+r0.height, r1.y+r1.height);
		var r = {x:miX, y:miY, width:maX-miX, height:maY-miY};
		
		frms[j-1].dispose = 1;
		if(j-1!=0) 
		UPNG.encode._updateFrame(bufs, w,h,frms, j-1,r, evenCrd);
		UPNG.encode._updateFrame(bufs, w,h,frms, j  ,r, evenCrd);
	}
	var area = 0;
	if(bufs.length!=1) for(var i=0; i<frms.length; i++) {
		var frm = frms[i];
		area += frm.rect.width*frm.rect.height;
		//if(i==0 || frm.blend!=1) continue;
		//var ob = new Uint8Array(
		//console.log(frm.blend, frm.dispose, frm.rect);
	}
	//if(area!=0) console.log(area);
	return frms;
}
UPNG.encode._updateFrame = function(bufs, w,h, frms, i, r, evenCrd) {
	var U8 = Uint8Array, U32 = Uint32Array;
	var pimg = new U8(bufs[i-1]), pimg32 = new U32(bufs[i-1]), nimg = i+1<bufs.length ? new U8(bufs[i+1]):null;
	var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);
	
	var mix=w,miy=h,max=-1,may=-1;
	for(var y=0; y<r.height; y++) for(var x=0; x<r.width; x++) {
		var cx = r.x+x, cy = r.y+y;
		var j = cy*w+cx, cc = cimg32[j];
		// no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.
		if(cc==0 || (frms[i-1].dispose==0 && pimg32[j]==cc && (nimg==null || nimg[j*4+3]!=0))/**/) {}
		else {
			if(cx<mix) mix=cx;  if(cx>max) max=cx;
			if(cy<miy) miy=cy;  if(cy>may) may=cy;
		}
	}
	if(max==-1) mix=miy=max=may=0;
	if(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }
	r = {x:mix, y:miy, width:max-mix+1, height:may-miy+1};
	
	var fr = frms[i];  fr.rect = r;  fr.blend = 1;  fr.img = new Uint8Array(r.width*r.height*4);
	if(frms[i-1].dispose==0) {
		UPNG._copyTile(pimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);
		UPNG.encode._prepareDiff(cimg,w,h,fr.img,r);
		//UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);
	}
	else
		UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);
}
UPNG.encode._prepareDiff = function(cimg, w,h, nimg, rec) {
	UPNG._copyTile(cimg,w,h, nimg,rec.width,rec.height, -rec.x,-rec.y, 2);
	/*
	var n32 = new Uint32Array(nimg.buffer);
	var og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);
	UPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);
	for(var i=4; i<nimg.length; i+=4) {
		if(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {
			n32[i>>>2]=o32[i>>>2];
			//var j = i, c=p32[(i>>>2)-1];
			//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }
		}
	}
	for(var i=nimg.length-8; i>0; i-=4) {
		if(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {
			n32[i>>>2]=o32[i>>>2];
			//var j = i, c=p32[(i>>>2)-1];
			//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }
		}
	}*/
}

UPNG.encode._filterZero = function(img,h,bpp,bpl,data, filter, levelZero)
{
	var fls = [], ftry=[0,1,2,3,4];
	if     (filter!=-1)             ftry=[filter];
	else if(h*bpl>500000 || bpp==1) ftry=[0];
	var opts;  if(levelZero) opts={level:0};
	
	
	var CMPR = (data.length>10e6 && UZIP!=null) ? UZIP : pako;
	
	var time = Date.now();
	for(var i=0; i<ftry.length; i++) {
		for(var y=0; y<h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);
		//var nimg = new Uint8Array(data.length);
		//var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));
		//var dfl = pako["deflate"](data), dl=dfl.length-4;
		//var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);
		//console.log(crc, UZIP.adler(data,2,data.length-6));
		fls.push(CMPR["deflate"](data,opts));
	}
	
	var ti, tsize=1e9;
	for(var i=0; i<fls.length; i++) if(fls[i].length<tsize) {  ti=i;  tsize=fls[i].length;  }
	return fls[ti];
}
UPNG.encode._filterLine = function(data, img, y, bpl, bpp, type)
{
	var i = y*bpl, di = i+y, paeth = UPNG.decode._paeth
	data[di]=type;  di++;

	if(type==0) {
		if(bpl<500) for(var x=0; x<bpl; x++) data[di+x] = img[i+x];
		else data.set(new Uint8Array(img.buffer,i,bpl),di);
	}
	else if(type==1) {
		for(var x=  0; x<bpp; x++) data[di+x] =  img[i+x];
		for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]-img[i+x-bpp]+256)&255;
	}
	else if(y==0) {
		for(var x=  0; x<bpp; x++) data[di+x] = img[i+x];

		if(type==2) for(var x=bpp; x<bpl; x++) data[di+x] = img[i+x];
		if(type==3) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - (img[i+x-bpp]>>1) +256)&255;
		if(type==4) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - paeth(img[i+x-bpp], 0, 0) +256)&255;
	}
	else {
		if(type==2) { for(var x=  0; x<bpl; x++) data[di+x] = (img[i+x]+256 - img[i+x-bpl])&255;  }
		if(type==3) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - (img[i+x-bpl]>>1))&255;
					  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - ((img[i+x-bpl]+img[i+x-bpp])>>1))&255;  }
		if(type==4) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - paeth(0, img[i+x-bpl], 0))&255;
					  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - paeth(img[i+x-bpp], img[i+x-bpl], img[i+x-bpp-bpl]))&255;  }
	}
}

UPNG.crc = {
	table : ( function() {
	   var tab = new Uint32Array(256);
	   for (var n=0; n<256; n++) {
			var c = n;
			for (var k=0; k<8; k++) {
				if (c & 1)  c = 0xedb88320 ^ (c >>> 1);
				else        c = c >>> 1;
			}
			tab[n] = c;  }
		return tab;  })(),
	update : function(c, buf, off, len) {
		for (var i=0; i<len; i++)  c = UPNG.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);
		return c;
	},
	crc : function(b,o,l)  {  return UPNG.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }
}


UPNG.quantize = function(abuf, ps)
{	
	var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);
	
	var KD = UPNG.quantize.getKDtree(nimg, ps);
	var root = KD[0], leafs = KD[1];
	
	var planeDst = UPNG.quantize.planeDst;
	var sb = oimg, tb = nimg32, len=sb.length;
		
	var inds = new Uint8Array(oimg.length>>2), nd;
	if(oimg.length<20e6)  // precise, but slow :(
		for(var i=0; i<len; i+=4) {
			var r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);
			
			nd = UPNG.quantize.getNearest(root, r, g, b, a);
			inds[i>>2] = nd.ind;  tb[i>>2] = nd.est.rgba;
		}
	else 
		for(var i=0; i<len; i+=4) {
			var r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);
			
			nd = root;  while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;
			inds[i>>2] = nd.ind;  tb[i>>2] = nd.est.rgba;
		}
	return {  abuf:nimg.buffer, inds:inds, plte:leafs  };
}

UPNG.quantize.getKDtree = function(nimg, ps, err) {
	if(err==null) err = 0.0001;
	var nimg32 = new Uint32Array(nimg.buffer);
	
	var root = {i0:0, i1:nimg.length, bst:null, est:null, tdst:0, left:null, right:null };  // basic statistic, extra statistic
	root.bst = UPNG.quantize.stats(  nimg,root.i0, root.i1  );  root.est = UPNG.quantize.estats( root.bst );
	var leafs = [root];
	
	while(leafs.length<ps)
	{
		var maxL = 0, mi=0;
		for(var i=0; i<leafs.length; i++) if(leafs[i].est.L > maxL) {  maxL=leafs[i].est.L;  mi=i;  }
		if(maxL<err) break;
		var node = leafs[mi];
		
		var s0 = UPNG.quantize.splitPixels(nimg,nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
		var s0wrong = (node.i0>=s0 || node.i1<=s0);
		//console.log(maxL, leafs.length, mi);
		if(s0wrong) {  node.est.L=0;  continue;  }
		
		
		var ln = {i0:node.i0, i1:s0, bst:null, est:null, tdst:0, left:null, right:null };  ln.bst = UPNG.quantize.stats( nimg, ln.i0, ln.i1 );  
		ln.est = UPNG.quantize.estats( ln.bst );
		var rn = {i0:s0, i1:node.i1, bst:null, est:null, tdst:0, left:null, right:null };  rn.bst = {R:[], m:[], N:node.bst.N-ln.bst.N};
		for(var i=0; i<16; i++) rn.bst.R[i] = node.bst.R[i]-ln.bst.R[i];
		for(var i=0; i< 4; i++) rn.bst.m[i] = node.bst.m[i]-ln.bst.m[i];
		rn.est = UPNG.quantize.estats( rn.bst );
		
		node.left = ln;  node.right = rn;
		leafs[mi]=ln;  leafs.push(rn);
	}
	leafs.sort(function(a,b) {  return b.bst.N-a.bst.N;  });
	for(var i=0; i<leafs.length; i++) leafs[i].ind=i;
	return [root, leafs];
}

UPNG.quantize.getNearest = function(nd, r,g,b,a)
{
	if(nd.left==null) {  nd.tdst = UPNG.quantize.dist(nd.est.q,r,g,b,a);  return nd;  }
	var planeDst = UPNG.quantize.planeDst(nd.est,r,g,b,a);
	
	var node0 = nd.left, node1 = nd.right;
	if(planeDst>0) {  node0=nd.right;  node1=nd.left;  }
	
	var ln = UPNG.quantize.getNearest(node0, r,g,b,a);
	if(ln.tdst<=planeDst*planeDst) return ln;
	var rn = UPNG.quantize.getNearest(node1, r,g,b,a);
	return rn.tdst<ln.tdst ? rn : ln;
}
UPNG.quantize.planeDst = function(est, r,g,b,a) {  var e = est.e;  return e[0]*r + e[1]*g + e[2]*b + e[3]*a - est.eMq;  }
UPNG.quantize.dist     = function(q,   r,g,b,a) {  var d0=r-q[0], d1=g-q[1], d2=b-q[2], d3=a-q[3];  return d0*d0+d1*d1+d2*d2+d3*d3;  }

UPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq)
{
	var vecDot = UPNG.quantize.vecDot;
	i1-=4;
	var shfs = 0;
	while(i0<i1)
	{
		while(vecDot(nimg, i0, e)<=eMq) i0+=4;
		while(vecDot(nimg, i1, e)> eMq) i1-=4;
		if(i0>=i1) break;
		
		var t = nimg32[i0>>2];  nimg32[i0>>2] = nimg32[i1>>2];  nimg32[i1>>2]=t;
		
		i0+=4;  i1-=4;
	}
	while(vecDot(nimg, i0, e)>eMq) i0-=4;
	return i0+4;
}
UPNG.quantize.vecDot = function(nimg, i, e)
{
	return nimg[i]*e[0] + nimg[i+1]*e[1] + nimg[i+2]*e[2] + nimg[i+3]*e[3];
}
UPNG.quantize.stats = function(nimg, i0, i1){
	var R = [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];
	var m = [0,0,0,0];
	var N = (i1-i0)>>2;
	for(var i=i0; i<i1; i+=4)
	{
		var r = nimg[i]*(1/255), g = nimg[i+1]*(1/255), b = nimg[i+2]*(1/255), a = nimg[i+3]*(1/255);
		//var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];
		m[0]+=r;  m[1]+=g;  m[2]+=b;  m[3]+=a;
		
		R[ 0] += r*r;  R[ 1] += r*g;  R[ 2] += r*b;  R[ 3] += r*a;  
		               R[ 5] += g*g;  R[ 6] += g*b;  R[ 7] += g*a; 
		                              R[10] += b*b;  R[11] += b*a;  
		                                             R[15] += a*a;  
	}
	R[4]=R[1];  R[8]=R[2];  R[9]=R[6];  R[12]=R[3];  R[13]=R[7];  R[14]=R[11];
	
	return {R:R, m:m, N:N};
}
UPNG.quantize.estats = function(stats){
	var R = stats.R, m = stats.m, N = stats.N;
	
	// when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)
	var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = (N==0 ? 0 : 1/N);
	var Rj = [
		R[ 0] - m0*m0*iN,  R[ 1] - m0*m1*iN,  R[ 2] - m0*m2*iN,  R[ 3] - m0*m3*iN,  
		R[ 4] - m1*m0*iN,  R[ 5] - m1*m1*iN,  R[ 6] - m1*m2*iN,  R[ 7] - m1*m3*iN,
		R[ 8] - m2*m0*iN,  R[ 9] - m2*m1*iN,  R[10] - m2*m2*iN,  R[11] - m2*m3*iN,  
		R[12] - m3*m0*iN,  R[13] - m3*m1*iN,  R[14] - m3*m2*iN,  R[15] - m3*m3*iN 
	];
	
	var A = Rj, M = UPNG.M4;
	var b = [Math.random(),Math.random(),Math.random(),Math.random()], mi = 0, tmi = 0;
	
	if(N!=0)
	for(var i=0; i<16; i++) {
		b = M.multVec(A, b);  tmi = Math.sqrt(M.dot(b,b));  b = M.sml(1/tmi,  b);
		if(i!=0 && Math.abs(tmi-mi)<1e-9) break;  mi = tmi;
	}	
	//b = [0,0,1,0];  mi=N;
	var q = [m0*iN, m1*iN, m2*iN, m3*iN];
	var eMq255 = M.dot(M.sml(255,q),b);
	
	return {  Cov:Rj, q:q, e:b, L:mi,  eMq255:eMq255, eMq : M.dot(b,q),
				rgba: (((Math.round(255*q[3])<<24) | (Math.round(255*q[2])<<16) |  (Math.round(255*q[1])<<8) | (Math.round(255*q[0])<<0))>>>0)  };
}
UPNG.M4 = {
	multVec : function(m,v) {
			return [
				m[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3],
				m[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3],
				m[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3],
				m[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3]
			];
	},
	dot : function(x,y) {  return  x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];  },
	sml : function(a,y) {  return [a*y[0],a*y[1],a*y[2],a*y[3]];  }
}

UPNG.encode.concatRGBA = function(bufs) {
	var tlen = 0;
	for(var i=0; i<bufs.length; i++) tlen += bufs[i].byteLength;
	var nimg = new Uint8Array(tlen), noff=0;
	for(var i=0; i<bufs.length; i++) {
		var img = new Uint8Array(bufs[i]), il = img.length;
		for(var j=0; j<il; j+=4) {  
			var r=img[j], g=img[j+1], b=img[j+2], a = img[j+3];
			if(a==0) r=g=b=0;
			nimg[noff+j]=r;  nimg[noff+j+1]=g;  nimg[noff+j+2]=b;  nimg[noff+j+3]=a;  }
		noff += il;
	}
	return nimg.buffer;
}

if (typeof module != 'undefined') module.exports = UPNG;
};
BundleModuleCode['plugins/image/pako']=function (module,exports){

/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));
}(this, (function (exports) { 'use strict';

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  /* eslint-disable space-unary-ops */

  /* Public constants ==========================================================*/

  /* ===========================================================================*/
  //const Z_FILTERED          = 1;
  //const Z_HUFFMAN_ONLY      = 2;
  //const Z_RLE               = 3;

  var Z_FIXED = 4; //const Z_DEFAULT_STRATEGY  = 0;

  /* Possible values of the data_type field (though see inflate()) */

  var Z_BINARY = 0;
  var Z_TEXT = 1; //const Z_ASCII             = 1; // = Z_TEXT

  var Z_UNKNOWN = 2;
  /*============================================================================*/

  function zero(buf) {
    var len = buf.length;

    while (--len >= 0) {
      buf[len] = 0;
    }
  } // From zutil.h


  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  /* The three kinds of block type */

  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  /* The minimum and maximum match lengths */
  // From deflate.h

  /* ===========================================================================
   * Internal compression state.
   */

  var LENGTH_CODES = 29;
  /* number of length codes, not counting the special END_BLOCK code */

  var LITERALS = 256;
  /* number of literal bytes 0..255 */

  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  /* number of Literal or Length codes, including the END_BLOCK code */

  var D_CODES = 30;
  /* number of distance codes */

  var BL_CODES = 19;
  /* number of codes used to transfer the bit lengths */

  var HEAP_SIZE = 2 * L_CODES + 1;
  /* maximum heap size */

  var MAX_BITS = 15;
  /* All codes must not exceed MAX_BITS bits */

  var Buf_size = 16;
  /* size of bit buffer in bi_buf */

  /* ===========================================================================
   * Constants
   */

  var MAX_BL_BITS = 7;
  /* Bit length codes must not exceed MAX_BL_BITS bits */

  var END_BLOCK = 256;
  /* end of block literal code */

  var REP_3_6 = 16;
  /* repeat previous bit length 3-6 times (2 bits of repeat count) */

  var REPZ_3_10 = 17;
  /* repeat a zero length 3-10 times  (3 bits of repeat count) */

  var REPZ_11_138 = 18;
  /* repeat a zero length 11-138 times  (7 bits of repeat count) */

  /* eslint-disable comma-spacing,array-bracket-spacing */

  var extra_lbits =
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
  var extra_dbits =
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
  var extra_blbits =
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
  var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  /* eslint-enable comma-spacing,array-bracket-spacing */

  /* The lengths of the bit length codes are sent in order of decreasing
   * probability, to avoid transmitting the lengths for unused bit length codes.
   */

  /* ===========================================================================
   * Local data. These are initialized only once.
   */
  // We pre-fill arrays with 0 to avoid uninitialized gaps

  var DIST_CODE_LEN = 512;
  /* see definition of array dist_code below */
  // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  /* The static literal tree. Since the bit lengths are imposed, there is no
   * need for the L_CODES extra codes used during heap construction. However
   * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
   * below).
   */

  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  /* The static distance tree. (Actually a trivial tree since all codes use
   * 5 bits.)
   */

  var _dist_code = new Array(DIST_CODE_LEN);

  zero(_dist_code);
  /* Distance codes. The first 256 values correspond to the distances
   * 3 .. 258, the last 256 values correspond to the top 8 bits of
   * the 15 bit distances.
   */

  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

  zero(_length_code);
  /* length code for each normalized match length (0 == MIN_MATCH) */

  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  /* First normalized length for each code (0 = MIN_MATCH) */

  var base_dist = new Array(D_CODES);
  zero(base_dist);
  /* First normalized distance for each code (0 = distance of 1) */

  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    /* static tree or NULL */

    this.extra_bits = extra_bits;
    /* extra bits for each code or NULL */

    this.extra_base = extra_base;
    /* base index for extra_bits */

    this.elems = elems;
    /* max number of elements in the tree */

    this.max_length = max_length;
    /* max bit length for the codes */
    // show if `static_tree` has data or dummy - needed for monomorphic objects

    this.has_stree = static_tree && static_tree.length;
  }

  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;

  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    /* the dynamic tree */

    this.max_code = 0;
    /* largest code with non zero frequency */

    this.stat_desc = stat_desc;
    /* the corresponding static tree */
  }

  var d_code = function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };
  /* ===========================================================================
   * Output a short LSB first on the stream.
   * IN assertion: there is enough room in pendingBuf.
   */


  var put_short = function put_short(s, w) {
    //    put_byte(s, (uch)((w) & 0xff));
    //    put_byte(s, (uch)((ush)(w) >> 8));
    s.pending_buf[s.pending++] = w & 0xff;
    s.pending_buf[s.pending++] = w >>> 8 & 0xff;
  };
  /* ===========================================================================
   * Send a value on a given number of bits.
   * IN assertion: length <= 16 and value fits in length bits.
   */


  var send_bits = function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 0xffff;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 0xffff;
      s.bi_valid += length;
    }
  };

  var send_code = function send_code(s, c, tree) {
    send_bits(s, tree[c * 2]
    /*.Code*/
    , tree[c * 2 + 1]
    /*.Len*/
    );
  };
  /* ===========================================================================
   * Reverse the first len bits of a code, using straightforward code (a faster
   * method would use a table)
   * IN assertion: 1 <= len <= 15
   */


  var bi_reverse = function bi_reverse(code, len) {
    var res = 0;

    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);

    return res >>> 1;
  };
  /* ===========================================================================
   * Flush the bit buffer, keeping at most 7 bits in it.
   */


  var bi_flush = function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 0xff;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };
  /* ===========================================================================
   * Compute the optimal bit lengths for a tree and update the total bit length
   * for the current block.
   * IN assertion: the fields freq and dad are set, heap[heap_max] and
   *    above are the tree nodes sorted by increasing frequency.
   * OUT assertions: the field len is set to the optimal bit length, the
   *     array bl_count contains the frequencies for each bit length.
   *     The length opt_len is updated; static_len is also updated if stree is
   *     not null.
   */


  var gen_bitlen = function gen_bitlen(s, desc) //    deflate_state *s;
  //    tree_desc *desc;    /* the tree descriptor */
  {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    /* heap index */

    var n, m;
    /* iterate over the tree elements */

    var bits;
    /* bit length */

    var xbits;
    /* extra bits */

    var f;
    /* frequency */

    var overflow = 0;
    /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */


    tree[s.heap[s.heap_max] * 2 + 1]
    /*.Len*/
    = 0;
    /* root of the heap */

    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1]
      /*.Dad*/
      * 2 + 1]
      /*.Len*/
      + 1;

      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }

      tree[n * 2 + 1]
      /*.Len*/
      = bits;
      /* We overwrite tree[n].Dad which is no longer needed */

      if (n > max_code) {
        continue;
      }
      /* not a leaf node */


      s.bl_count[bits]++;
      xbits = 0;

      if (n >= base) {
        xbits = extra[n - base];
      }

      f = tree[n * 2]
      /*.Freq*/
      ;
      s.opt_len += f * (bits + xbits);

      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1]
        /*.Len*/
        + xbits);
      }
    }

    if (overflow === 0) {
      return;
    } // Trace((stderr,"\nbit length overflow\n"));

    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */


    do {
      bits = max_length - 1;

      while (s.bl_count[bits] === 0) {
        bits--;
      }

      s.bl_count[bits]--;
      /* move one leaf down the tree */

      s.bl_count[bits + 1] += 2;
      /* move one overflow item as its brother */

      s.bl_count[max_length]--;
      /* The brother of the overflow item also moves one step up,
       * but this does not affect bl_count[max_length]
       */

      overflow -= 2;
    } while (overflow > 0);
    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */


    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];

      while (n !== 0) {
        m = s.heap[--h];

        if (m > max_code) {
          continue;
        }

        if (tree[m * 2 + 1]
        /*.Len*/
        !== bits) {
          // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
          s.opt_len += (bits - tree[m * 2 + 1]
          /*.Len*/
          ) * tree[m * 2]
          /*.Freq*/
          ;
          tree[m * 2 + 1]
          /*.Len*/
          = bits;
        }

        n--;
      }
    }
  };
  /* ===========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */


  var gen_codes = function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
  //    int max_code;              /* largest code with non zero frequency */
  //    ushf *bl_count;            /* number of codes at each bit length */
  {
    var next_code = new Array(MAX_BITS + 1);
    /* next code value for each bit length */

    var code = 0;
    /* running code value */

    var bits;
    /* bit index */

    var n;
    /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */

    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
    //        "inconsistent bit counts");
    //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1]
      /*.Len*/
      ;

      if (len === 0) {
        continue;
      }
      /* Now reverse the bits */


      tree[n * 2]
      /*.Code*/
      = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
      //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
  };
  /* ===========================================================================
   * Initialize the various 'constant' tables.
   */


  var tr_static_init = function tr_static_init() {
    var n;
    /* iterates over tree elements */

    var bits;
    /* bit counter */

    var length;
    /* length value */

    var code;
    /* code value */

    var dist;
    /* distance index */

    var bl_count = new Array(MAX_BITS + 1);
    /* number of codes at each bit length for an optimal tree */
    // do check in _tr_init()
    //if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */

    /*#ifdef NO_INIT_GLOBAL_POINTERS
      static_l_desc.static_tree = static_ltree;
      static_l_desc.extra_bits = extra_lbits;
      static_d_desc.static_tree = static_dtree;
      static_d_desc.extra_bits = extra_dbits;
      static_bl_desc.extra_bits = extra_blbits;
    #endif*/

    /* Initialize the mapping length (0..255) -> length code (0..28) */

    length = 0;

    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;

      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    } //Assert (length == 256, "tr_static_init: length != 256");

    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */


    _length_code[length - 1] = code;
    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

    dist = 0;

    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;

      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    } //Assert (dist == 256, "tr_static_init: dist != 256");


    dist >>= 7;
    /* from now on, all distances are divided by 128 */

    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;

      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */


    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }

    n = 0;

    while (n <= 143) {
      static_ltree[n * 2 + 1]
      /*.Len*/
      = 8;
      n++;
      bl_count[8]++;
    }

    while (n <= 255) {
      static_ltree[n * 2 + 1]
      /*.Len*/
      = 9;
      n++;
      bl_count[9]++;
    }

    while (n <= 279) {
      static_ltree[n * 2 + 1]
      /*.Len*/
      = 7;
      n++;
      bl_count[7]++;
    }

    while (n <= 287) {
      static_ltree[n * 2 + 1]
      /*.Len*/
      = 8;
      n++;
      bl_count[8]++;
    }
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */


    gen_codes(static_ltree, L_CODES + 1, bl_count);
    /* The static distance tree is trivial: */

    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1]
      /*.Len*/
      = 5;
      static_dtree[n * 2]
      /*.Code*/
      = bi_reverse(n, 5);
    } // Now data ready and we can init static trees


    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
  };
  /* ===========================================================================
   * Initialize a new block.
   */


  var init_block = function init_block(s) {
    var n;
    /* iterates over tree elements */

    /* Initialize the trees. */

    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2]
      /*.Freq*/
      = 0;
    }

    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2]
      /*.Freq*/
      = 0;
    }

    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2]
      /*.Freq*/
      = 0;
    }

    s.dyn_ltree[END_BLOCK * 2]
    /*.Freq*/
    = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  };
  /* ===========================================================================
   * Flush the bit buffer and align the output on a byte boundary
   */


  var bi_windup = function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      //put_byte(s, (Byte)s->bi_buf);
      s.pending_buf[s.pending++] = s.bi_buf;
    }

    s.bi_buf = 0;
    s.bi_valid = 0;
  };
  /* ===========================================================================
   * Copy a stored block, storing first the length and its
   * one's complement if requested.
   */


  var copy_block = function copy_block(s, buf, len, header) //DeflateState *s;
  //charf    *buf;    /* the input data */
  //unsigned len;     /* its length */
  //int      header;  /* true if block header must be written */
  {
    bi_windup(s);
    /* align on byte boundary */

    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    } //  while (len--) {
    //    put_byte(s, *buf++);
    //  }


    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  };
  /* ===========================================================================
   * Compares to subtrees, using the tree depth as tie breaker when
   * the subtrees have equal frequency. This minimizes the worst case length.
   */


  var smaller = function smaller(tree, n, m, depth) {
    var _n2 = n * 2;

    var _m2 = m * 2;

    return tree[_n2]
    /*.Freq*/
    < tree[_m2]
    /*.Freq*/
    || tree[_n2]
    /*.Freq*/
    === tree[_m2]
    /*.Freq*/
    && depth[n] <= depth[m];
  };
  /* ===========================================================================
   * Restore the heap property by moving down the tree starting at node k,
   * exchanging a node with the smallest of its two sons if necessary, stopping
   * when the heap property is re-established (each father smaller than its
   * two sons).
   */


  var pqdownheap = function pqdownheap(s, tree, k) //    deflate_state *s;
  //    ct_data *tree;  /* the tree to restore */
  //    int k;               /* node to move down */
  {
    var v = s.heap[k];
    var j = k << 1;
    /* left son of k */

    while (j <= s.heap_len) {
      /* Set j to the smallest of the two sons: */
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      /* Exit if v is smaller than both sons */


      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      /* Exchange v with the smallest son */


      s.heap[k] = s.heap[j];
      k = j;
      /* And continue down the tree, setting j to the left son of k */

      j <<= 1;
    }

    s.heap[k] = v;
  }; // inlined manually
  // const SMALLEST = 1;

  /* ===========================================================================
   * Send the block data compressed using the given Huffman trees
   */


  var compress_block = function compress_block(s, ltree, dtree) //    deflate_state *s;
  //    const ct_data *ltree; /* literal tree */
  //    const ct_data *dtree; /* distance tree */
  {
    var dist;
    /* distance of matched string */

    var lc;
    /* match length or unmatched char (if dist == 0) */

    var lx = 0;
    /* running index in l_buf */

    var code;
    /* the code to send */

    var extra;
    /* number of extra bits to send */

    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;

        if (dist === 0) {
          send_code(s, lc, ltree);
          /* send a literal byte */
          //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
          /* Here, lc is the match length - MIN_MATCH */
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          /* send the length code */

          extra = extra_lbits[code];

          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
            /* send the extra length bits */
          }

          dist--;
          /* dist is now the match distance - 1 */

          code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

          send_code(s, code, dtree);
          /* send the distance code */

          extra = extra_dbits[code];

          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
            /* send the extra distance bits */
          }
        }
        /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
        //       "pendingBuf overflow");

      } while (lx < s.last_lit);
    }

    send_code(s, END_BLOCK, ltree);
  };
  /* ===========================================================================
   * Construct one Huffman tree and assigns the code bit strings and lengths.
   * Update the total bit length for the current block.
   * IN assertion: the field freq is set for all tree elements.
   * OUT assertions: the fields len and code are set to the optimal bit length
   *     and corresponding code. The length opt_len is updated; static_len is
   *     also updated if stree is not null. The field max_code is set.
   */


  var build_tree = function build_tree(s, desc) //    deflate_state *s;
  //    tree_desc *desc; /* the tree descriptor */
  {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    /* iterate over heap elements */

    var max_code = -1;
    /* largest code with non zero frequency */

    var node;
    /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */

    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
      if (tree[n * 2]
      /*.Freq*/
      !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1]
        /*.Len*/
        = 0;
      }
    }
    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */


    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2]
      /*.Freq*/
      = 1;
      s.depth[node] = 0;
      s.opt_len--;

      if (has_stree) {
        s.static_len -= stree[node * 2 + 1]
        /*.Len*/
        ;
      }
      /* node is 0 or 1 so it does not have extra bits */

    }

    desc.max_code = max_code;
    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */

    for (n = s.heap_len >> 1
    /*int /2*/
    ; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */


    node = elems;
    /* next internal node of the tree */

    do {
      //pqremove(s, tree, n);  /* n = node of least frequency */

      /*** pqremove ***/
      n = s.heap[1
      /*SMALLEST*/
      ];
      s.heap[1
      /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1
      /*SMALLEST*/
      );
      /***/

      m = s.heap[1
      /*SMALLEST*/
      ];
      /* m = node of next least frequency */

      s.heap[--s.heap_max] = n;
      /* keep the nodes sorted by frequency */

      s.heap[--s.heap_max] = m;
      /* Create a new node father of n and m */

      tree[node * 2]
      /*.Freq*/
      = tree[n * 2]
      /*.Freq*/
      + tree[m * 2]
      /*.Freq*/
      ;
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1]
      /*.Dad*/
      = tree[m * 2 + 1]
      /*.Dad*/
      = node;
      /* and insert the new node in the heap */

      s.heap[1
      /*SMALLEST*/
      ] = node++;
      pqdownheap(s, tree, 1
      /*SMALLEST*/
      );
    } while (s.heap_len >= 2);

    s.heap[--s.heap_max] = s.heap[1
    /*SMALLEST*/
    ];
    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */

    gen_bitlen(s, desc);
    /* The field len is now set, we can generate the bit codes */

    gen_codes(tree, max_code, s.bl_count);
  };
  /* ===========================================================================
   * Scan a literal or distance tree to determine the frequencies of the codes
   * in the bit length tree.
   */


  var scan_tree = function scan_tree(s, tree, max_code) //    deflate_state *s;
  //    ct_data *tree;   /* the tree to be scanned */
  //    int max_code;    /* and its largest code of non zero frequency */
  {
    var n;
    /* iterates over all tree elements */

    var prevlen = -1;
    /* last emitted length */

    var curlen;
    /* length of current code */

    var nextlen = tree[0 * 2 + 1]
    /*.Len*/
    ;
    /* length of next code */

    var count = 0;
    /* repeat count of the current code */

    var max_count = 7;
    /* max repeat count */

    var min_count = 4;
    /* min repeat count */

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }

    tree[(max_code + 1) * 2 + 1]
    /*.Len*/
    = 0xffff;
    /* guard */

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1]
      /*.Len*/
      ;

      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2]
        /*.Freq*/
        += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2] /*.Freq*/++;
        }

        s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
      } else {
        s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
      }

      count = 0;
      prevlen = curlen;

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  /* ===========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */


  var send_tree = function send_tree(s, tree, max_code) //    deflate_state *s;
  //    ct_data *tree; /* the tree to be scanned */
  //    int max_code;       /* and its largest code of non zero frequency */
  {
    var n;
    /* iterates over all tree elements */

    var prevlen = -1;
    /* last emitted length */

    var curlen;
    /* length of current code */

    var nextlen = tree[0 * 2 + 1]
    /*.Len*/
    ;
    /* length of next code */

    var count = 0;
    /* repeat count of the current code */

    var max_count = 7;
    /* max repeat count */

    var min_count = 4;
    /* min repeat count */

    /* tree[max_code+1].Len = -1; */

    /* guard already set */

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1]
      /*.Len*/
      ;

      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        } //Assert(count >= 3 && count <= 6, " 3_6?");


        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }

      count = 0;
      prevlen = curlen;

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  /* ===========================================================================
   * Construct the Huffman tree for the bit lengths and return the index in
   * bl_order of the last bit length code to send.
   */


  var build_bl_tree = function build_bl_tree(s) {
    var max_blindex;
    /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */

    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    /* Build the bit length tree: */

    build_tree(s, s.bl_desc);
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */

    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
      /*.Len*/
      !== 0) {
        break;
      }
    }
    /* Update opt_len to include the bit length tree and counts */


    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
    //        s->opt_len, s->static_len));

    return max_blindex;
  };
  /* ===========================================================================
   * Send the header for a block using dynamic Huffman trees: the counts, the
   * lengths of the bit length codes, the literal tree and the distance tree.
   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
   */


  var send_all_trees = function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
  {
    var rank;
    /* index in bl_order */
    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
    //        "too many codes");
    //Tracev((stderr, "\nbl counts: "));

    send_bits(s, lcodes - 257, 5);
    /* not +255 as stated in appnote.txt */

    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    /* not -3 as stated in appnote.txt */

    for (rank = 0; rank < blcodes; rank++) {
      //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
      /*.Len*/
      , 3);
    } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


    send_tree(s, s.dyn_ltree, lcodes - 1);
    /* literal tree */
    //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, s.dyn_dtree, dcodes - 1);
    /* distance tree */
    //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
  };
  /* ===========================================================================
   * Check if the data type is TEXT or BINARY, using the following algorithm:
   * - TEXT if the two conditions below are satisfied:
   *    a) There are no non-portable control characters belonging to the
   *       "black list" (0..6, 14..25, 28..31).
   *    b) There is at least one printable character belonging to the
   *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
   * - BINARY otherwise.
   * - The following partially-portable control characters form a
   *   "gray list" that is ignored in this detection algorithm:
   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
   * IN assertion: the fields Freq of dyn_ltree are set.
   */


  var detect_data_type = function detect_data_type(s) {
    /* black_mask is the bit mask of black-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
    var black_mask = 0xf3ffc07f;
    var n;
    /* Check for non-textual ("black-listed") bytes. */

    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2]
      /*.Freq*/
      !== 0) {
        return Z_BINARY;
      }
    }
    /* Check for textual ("white-listed") bytes. */


    if (s.dyn_ltree[9 * 2]
    /*.Freq*/
    !== 0 || s.dyn_ltree[10 * 2]
    /*.Freq*/
    !== 0 || s.dyn_ltree[13 * 2]
    /*.Freq*/
    !== 0) {
      return Z_TEXT;
    }

    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2]
      /*.Freq*/
      !== 0) {
        return Z_TEXT;
      }
    }
    /* There are no "black-listed" or "white-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */


    return Z_BINARY;
  };

  var static_init_done = false;
  /* ===========================================================================
   * Initialize the tree data structures for a new zlib stream.
   */

  var _tr_init = function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }

    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    /* Initialize the first block of the first file: */

    init_block(s);
  };
  /* ===========================================================================
   * Send a stored block
   */


  var _tr_stored_block = function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
  //charf *buf;       /* input block */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */
  {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    /* send block type */

    copy_block(s, buf, stored_len, true);
    /* with header */
  };
  /* ===========================================================================
   * Send one empty static block to give enough lookahead for inflate.
   * This takes 10 bits, of which 7 may remain in the bit buffer.
   */


  var _tr_align = function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };
  /* ===========================================================================
   * Determine the best encoding for the current block: dynamic trees, static
   * trees or store, and output the encoded block to the zip file.
   */


  var _tr_flush_block = function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
  //charf *buf;       /* input block, or NULL if too old */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */
  {
    var opt_lenb, static_lenb;
    /* opt_len and static_len in bytes */

    var max_blindex = 0;
    /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */

    if (s.level > 0) {
      /* Check if the file is binary or text */
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      /* Construct the literal and distance trees */


      build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
      //        s->static_len));

      build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
      //        s->static_len));

      /* At this point, opt_len and static_len are the total bit lengths of
       * the compressed block data, excluding the tree representations.
       */

      /* Build the bit length tree for the above two trees, and get the index
       * in bl_order of the last bit length code to send.
       */

      max_blindex = build_bl_tree(s);
      /* Determine the best encoding. Compute the block lengths in bytes. */

      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
      //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
      //        s->last_lit));

      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      // Assert(buf != (char*)0, "lost buf");
      opt_lenb = static_lenb = stored_len + 5;
      /* force a stored block */
    }

    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      /* 4: two words for the lengths */

      /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
       * Otherwise we can't have processed more than WSIZE input bytes since
       * the last block flush, because compression would have been
       * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
       * transform a block into a stored block.
       */
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */


    init_block(s);

    if (last) {
      bi_windup(s);
    } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
    //       s->compressed_len-7*last));

  };
  /* ===========================================================================
   * Save the match info and tally the frequency counts. Return true if
   * the current block must be flushed.
   */


  var _tr_tally = function _tr_tally(s, dist, lc) //    deflate_state *s;
  //    unsigned dist;  /* distance of matched string */
  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
  {
    //let out_length, in_length, dcode;
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
    s.last_lit++;

    if (dist === 0) {
      /* lc is the unmatched char */
      s.dyn_ltree[lc * 2] /*.Freq*/++;
    } else {
      s.matches++;
      /* Here, lc is the match length - MIN_MATCH */

      dist--;
      /* dist = match distance - 1 */
      //Assert((ush)dist < (ush)MAX_DIST(s) &&
      //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
      //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
      s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
    } // (!) This block is disabled in zlib defaults,
    // don't enable it for binary compatibility
    //#ifdef TRUNCATE_BLOCK
    //  /* Try to guess if it is profitable to stop the current block here */
    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
    //    /* Compute an upper bound for the compressed length */
    //    out_length = s.last_lit*8;
    //    in_length = s.strstart - s.block_start;
    //
    //    for (dcode = 0; dcode < D_CODES; dcode++) {
    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
    //    }
    //    out_length >>>= 3;
    //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
    //    //       s->last_lit, in_length, out_length,
    //    //       100L - out_length*100L/in_length));
    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
    //      return true;
    //    }
    //  }
    //#endif


    return s.last_lit === s.lit_bufsize - 1;
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
  };

  var _tr_init_1 = _tr_init;
  var _tr_stored_block_1 = _tr_stored_block;
  var _tr_flush_block_1 = _tr_flush_block;
  var _tr_tally_1 = _tr_tally;
  var _tr_align_1 = _tr_align;
  var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
  };

  // It isn't worth it to make additional optimizations as in original.
  // Small size is preferable.
  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var adler32 = function adler32(adler, buf, len, pos) {
    var s1 = adler & 0xffff | 0,
        s2 = adler >>> 16 & 0xffff | 0,
        n = 0;

    while (len !== 0) {
      // Set limit ~ twice less than 5552, to keep
      // s2 in 31-bits, because we force signed ints.
      // in other case %= will fail.
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return s1 | s2 << 16 | 0;
  };

  var adler32_1 = adler32;

  // So write code to minimize size - no pregenerated tables
  // and array tools dependencies.
  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.
  // Use ordinary array, since untyped makes no boost here

  var makeTable = function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
      c = n;

      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
      }

      table[n] = c;
    }

    return table;
  }; // Create table on load. Just 255 signed longs. Not a problem.


  var crcTable = new Uint32Array(makeTable());

  var crc32 = function crc32(crc, buf, len, pos) {
    var t = crcTable;
    var end = pos + len;
    crc ^= -1;

    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
  };

  var crc32_1 = crc32;

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var messages = {
    2: 'need dictionary',

    /* Z_NEED_DICT       2  */
    1: 'stream end',

    /* Z_STREAM_END      1  */
    0: '',

    /* Z_OK              0  */
    '-1': 'file error',

    /* Z_ERRNO         (-1) */
    '-2': 'stream error',

    /* Z_STREAM_ERROR  (-2) */
    '-3': 'data error',

    /* Z_DATA_ERROR    (-3) */
    '-4': 'insufficient memory',

    /* Z_MEM_ERROR     (-4) */
    '-5': 'buffer error',

    /* Z_BUF_ERROR     (-5) */
    '-6': 'incompatible version'
    /* Z_VERSION_ERROR (-6) */

  };

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,

    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,

    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,

    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,

    /* The deflate compression method */
    Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

  };

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.


  var _tr_init$1 = trees._tr_init,
      _tr_stored_block$1 = trees._tr_stored_block,
      _tr_flush_block$1 = trees._tr_flush_block,
      _tr_tally$1 = trees._tr_tally,
      _tr_align$1 = trees._tr_align;
  /* Public constants ==========================================================*/

  /* ===========================================================================*/

  var Z_NO_FLUSH = constants.Z_NO_FLUSH,
      Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH = constants.Z_FULL_FLUSH,
      Z_FINISH = constants.Z_FINISH,
      Z_BLOCK = constants.Z_BLOCK,
      Z_OK = constants.Z_OK,
      Z_STREAM_END = constants.Z_STREAM_END,
      Z_STREAM_ERROR = constants.Z_STREAM_ERROR,
      Z_DATA_ERROR = constants.Z_DATA_ERROR,
      Z_BUF_ERROR = constants.Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION,
      Z_FILTERED = constants.Z_FILTERED,
      Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY,
      Z_RLE = constants.Z_RLE,
      Z_FIXED$1 = constants.Z_FIXED,
      Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY,
      Z_UNKNOWN$1 = constants.Z_UNKNOWN,
      Z_DEFLATED = constants.Z_DEFLATED;
  /*============================================================================*/

  var MAX_MEM_LEVEL = 9;
  /* Maximum value for memLevel in deflateInit2 */

  var MAX_WBITS = 15;
  /* 32K LZ77 window */

  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES$1 = 29;
  /* number of length codes, not counting the special END_BLOCK code */

  var LITERALS$1 = 256;
  /* number of literal bytes 0..255 */

  var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
  /* number of Literal or Length codes, including the END_BLOCK code */

  var D_CODES$1 = 30;
  /* number of distance codes */

  var BL_CODES$1 = 19;
  /* number of codes used to transfer the bit lengths */

  var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
  /* maximum heap size */

  var MAX_BITS$1 = 15;
  /* All codes must not exceed MAX_BITS bits */

  var MIN_MATCH$1 = 3;
  var MAX_MATCH$1 = 258;
  var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
  var PRESET_DICT = 0x20;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  /* block not completed, need more input or more output */

  var BS_BLOCK_DONE = 2;
  /* block flush performed */

  var BS_FINISH_STARTED = 3;
  /* finish started, need only more output at next deflate */

  var BS_FINISH_DONE = 4;
  /* finish done, accept no more input or output */

  var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

  var err = function err(strm, errorCode) {
    strm.msg = messages[errorCode];
    return errorCode;
  };

  var rank = function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  };

  var zero$1 = function zero(buf) {
    var len = buf.length;

    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  /* eslint-disable new-cap */


  var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135
  // But breaks binary compatibility
  //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;


  var HASH = HASH_ZLIB;
  /* =========================================================================
   * Flush as much pending output as possible. All deflate() output goes
   * through this function so some applications may wish to modify it
   * to avoid allocating a large strm->output buffer and copying into it.
   * (See also read_buf()).
   */

  var flush_pending = function flush_pending(strm) {
    var s = strm.state; //_tr_flush_bits(s);

    var len = s.pending;

    if (len > strm.avail_out) {
      len = strm.avail_out;
    }

    if (len === 0) {
      return;
    }

    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;

    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };

  var flush_block_only = function flush_block_only(s, last) {
    _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

    s.block_start = s.strstart;
    flush_pending(s.strm);
  };

  var put_byte = function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  };
  /* =========================================================================
   * Put a short in the pending buffer. The 16-bit value is put in MSB order.
   * IN assertion: the stream state is correct and there is enough room in
   * pending_buf.
   */


  var putShortMSB = function putShortMSB(s, b) {
    //  put_byte(s, (Byte)(b >> 8));
    //  put_byte(s, (Byte)(b & 0xff));
    s.pending_buf[s.pending++] = b >>> 8 & 0xff;
    s.pending_buf[s.pending++] = b & 0xff;
  };
  /* ===========================================================================
   * Read a new buffer from the current input stream, update the adler32
   * and total number of bytes read.  All deflate() input goes through
   * this function so some applications may wish to modify it to avoid
   * allocating a large strm->input buffer and copying from it.
   * (See also flush_pending()).
   */


  var read_buf = function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;

    if (len > size) {
      len = size;
    }

    if (len === 0) {
      return 0;
    }

    strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);

    if (strm.state.wrap === 1) {
      strm.adler = adler32_1(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32_1(strm.adler, buf, len, start);
    }

    strm.next_in += len;
    strm.total_in += len;
    return len;
  };
  /* ===========================================================================
   * Set match_start to the longest match starting at the given string and
   * return its length. Matches shorter or equal to prev_length are discarded,
   * in which case the result is equal to prev_length and match_start is
   * garbage.
   * IN assertions: cur_match is the head of the hash chain for the current
   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
   * OUT assertion: the match length is not greater than s->lookahead.
   */


  var longest_match = function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    /* max hash chain length */

    var scan = s.strstart;
    /* current string */

    var match;
    /* matched string */

    var len;
    /* length of current match */

    var best_len = s.prev_length;
    /* best match length so far */

    var nice_match = s.nice_match;
    /* stop if match long enough */

    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
    /*NIL*/
    ;
    var _win = s.window; // shortcut

    var wmask = s.w_mask;
    var prev = s.prev;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */

    var strend = s.strstart + MAX_MATCH$1;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */

    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */


    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


    do {
      // Assert(cur_match < s->strstart, "no future");
      match = cur_match;
      /* Skip to next match if the match length cannot increase
       * or if the match length is less than 2.  Note that the checks below
       * for insufficient lookahead only occur occasionally for performance
       * reasons.  Therefore uninitialized memory will be accessed, and
       * conditional jumps will be made that depend on those values.
       * However the length of the match is limited to the lookahead, so
       * the output of deflate is not affected by the uninitialized values.
       */

      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      /* The check at best_len-1 can be removed because it will be made
       * again later. (This heuristic is not always a win.)
       * It is not necessary to compare scan[2] and match[2] since they
       * are always equal when the other bytes match, given that
       * the hash keys are equal and that HASH_BITS >= 8.
       */


      scan += 2;
      match++; // Assert(*scan == *match, "match[2]?");

      /* We check for insufficient lookahead only every 8th comparison;
       * the 256th check will be made at strstart+258.
       */

      do {
        /*jshint noempty:false*/
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


      len = MAX_MATCH$1 - (strend - scan);
      scan = strend - MAX_MATCH$1;

      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;

        if (len >= nice_match) {
          break;
        }

        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

    if (best_len <= s.lookahead) {
      return best_len;
    }

    return s.lookahead;
  };
  /* ===========================================================================
   * Fill the window when the lookahead becomes insufficient.
   * Updates strstart and lookahead.
   *
   * IN assertion: lookahead < MIN_LOOKAHEAD
   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
   *    At least one byte has been read, or avail_in == 0; reads are
   *    performed for at least two bytes (required for the zip translate_eol
   *    option -- not supported here).
   */


  var fill_window = function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

    do {
      more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

      /* Deal with !@#$% 64K limit: */
      //if (sizeof(int) <= 2) {
      //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
      //        more = wsize;
      //
      //  } else if (more == (unsigned)(-1)) {
      //        /* Very unlikely, but possible on 16 bit machine if
      //         * strstart == 0 && lookahead == 1 (input done a byte at time)
      //         */
      //        more--;
      //    }
      //}

      /* If the window is almost full and there is insufficient lookahead,
       * move the upper half to the lower one to make room in the upper half.
       */

      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        /* we now have strstart >= MAX_DIST */

        s.block_start -= _w_size;
        /* Slide the hash table (could be avoided with 32 bit values
         at the expense of memory usage). We slide even when level == 0
         to keep the hash table consistent if we switch back to level > 0
         later. (Using level 0 permanently is not an optimal usage of
         zlib, so we don't care about this pathological case.)
         */

        n = s.hash_size;
        p = n;

        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);

        n = _w_size;
        p = n;

        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
          /* If n is not on any hash chain, prev[n] is garbage but
           * its value will never be used.
           */
        } while (--n);

        more += _w_size;
      }

      if (s.strm.avail_in === 0) {
        break;
      }
      /* If there was no sliding:
       *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
       *    more == window_size - lookahead - strstart
       * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
       * => more >= window_size - 2*WSIZE + 2
       * In the BIG_MEM or MMAP case (not yet supported),
       *   window_size == input_size + MIN_LOOKAHEAD  &&
       *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
       * Otherwise, window_size == 2*WSIZE so more >= 2.
       * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
       */
      //Assert(more >= 2, "more < 2");


      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      /* Initialize the hash value now that we have some input: */

      if (s.lookahead + s.insert >= MIN_MATCH$1) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); //#if MIN_MATCH != 3
        //        Call update_hash() MIN_MATCH-3 more times
        //#endif

        while (s.insert) {
          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;

          if (s.lookahead + s.insert < MIN_MATCH$1) {
            break;
          }
        }
      }
      /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
       * but this is not important since only literal bytes will be emitted.
       */

    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
    //  if (s.high_water < s.window_size) {
    //    const curr = s.strstart + s.lookahead;
    //    let init = 0;
    //
    //    if (s.high_water < curr) {
    //      /* Previous high water mark below current data -- zero WIN_INIT
    //       * bytes or up to end of window, whichever is less.
    //       */
    //      init = s.window_size - curr;
    //      if (init > WIN_INIT)
    //        init = WIN_INIT;
    //      zmemzero(s->window + curr, (unsigned)init);
    //      s->high_water = curr + init;
    //    }
    //    else if (s->high_water < (ulg)curr + WIN_INIT) {
    //      /* High water mark at or above current data, but below current data
    //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
    //       * to end of window, whichever is less.
    //       */
    //      init = (ulg)curr + WIN_INIT - s->high_water;
    //      if (init > s->window_size - s->high_water)
    //        init = s->window_size - s->high_water;
    //      zmemzero(s->window + s->high_water, (unsigned)init);
    //      s->high_water += init;
    //    }
    //  }
    //
    //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
    //    "not enough room for search");

  };
  /* ===========================================================================
   * Copy without compression as much as possible from the input stream, return
   * the current block state.
   * This function does not insert new strings in the dictionary since
   * uncompressible data is probably not useful. This function is used
   * only for the level=0 compression option.
   * NOTE: this function should be optimized to avoid extra copying from
   * window to pending_buf.
   */


  var deflate_stored = function deflate_stored(s, flush) {
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    var max_block_size = 0xffff;

    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    /* Copy as much as possible from input to output: */


    for (;;) {
      /* Fill the window as much as possible: */
      if (s.lookahead <= 1) {
        //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
        //  s->block_start >= (long)s->w_size, "slide too late");
        //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
        //        s.block_start >= s.w_size)) {
        //        throw  new Error("slide too late");
        //      }
        fill_window(s);

        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
        /* flush the current block */

      } //Assert(s->block_start >= 0L, "block gone");
      //    if (s.block_start < 0) throw new Error("block gone");


      s.strstart += s.lookahead;
      s.lookahead = 0;
      /* Emit a stored block if pending_buf will be full: */

      var max_start = s.block_start + max_block_size;

      if (s.strstart === 0 || s.strstart >= max_start) {
        /* strstart == 0 is possible when wraparound on 16-bit machine */
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        /*** FLUSH_BLOCK(s, 0); ***/

        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
      /* Flush if we may have to slide, otherwise block_start may become
       * negative and the data will be gone:
       */


      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    }

    s.insert = 0;

    if (flush === Z_FINISH) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/


      return BS_FINISH_DONE;
    }

    if (s.strstart > s.block_start) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }

    return BS_NEED_MORE;
  };
  /* ===========================================================================
   * Compress as much as possible from the input stream, return the current
   * block state.
   * This function does not perform lazy evaluation of matches and inserts
   * new strings in the dictionary only for unmatched strings or for short
   * matches. It is used only for the fast compression options.
   */


  var deflate_fast = function deflate_fast(s, flush) {
    var hash_head;
    /* head of the hash chain */

    var bflush;
    /* set if current block must be flushed */

    for (;;) {
      /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the next match, plus MIN_MATCH bytes to insert the
       * string following the next match.
       */
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);

        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
          /* flush the current block */
        }
      }
      /* Insert the string window[strstart .. strstart+2] in the
       * dictionary, and set hash_head to the head of the hash chain:
       */


      hash_head = 0
      /*NIL*/
      ;

      if (s.lookahead >= MIN_MATCH$1) {
        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
        /***/
      }
      /* Find the longest match, discarding those <= prev_length.
       * At this point we have always match_length < MIN_MATCH
       */


      if (hash_head !== 0
      /*NIL*/
      && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */
      }

      if (s.match_length >= MIN_MATCH$1) {
        // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

        /*** _tr_tally_dist(s, s.strstart - s.match_start,
                       s.match_length - MIN_MATCH, bflush); ***/
        bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);
        s.lookahead -= s.match_length;
        /* Insert new strings in the hash table only if the match length
         * is not too large. This saves time but degrades compression.
         */

        if (s.match_length <= s.max_lazy_match
        /*max_insert_length*/
        && s.lookahead >= MIN_MATCH$1) {
          s.match_length--;
          /* string at strstart already in table */

          do {
            s.strstart++;
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/

            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/

            /* strstart never exceeds WSIZE-MAX_MATCH, so there are
             * always MIN_MATCH bytes ahead.
             */
          } while (--s.match_length !== 0);

          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); //#if MIN_MATCH != 3
          //                Call UPDATE_HASH() MIN_MATCH-3 more times
          //#endif

          /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
           * matter since it will be recomputed at next deflate call.
           */
        }
      } else {
        /* No match, output a literal byte */
        //Tracevv((stderr,"%c", s.window[s.strstart]));

        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
        bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    }

    s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;

    if (flush === Z_FINISH) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/


      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }

    return BS_BLOCK_DONE;
  };
  /* ===========================================================================
   * Same as above, but achieves better compression. We use a lazy
   * evaluation for matches: a match is finally adopted only if there is
   * no better match at the next window position.
   */


  var deflate_slow = function deflate_slow(s, flush) {
    var hash_head;
    /* head of hash chain */

    var bflush;
    /* set if current block must be flushed */

    var max_insert;
    /* Process the input block. */

    for (;;) {
      /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the next match, plus MIN_MATCH bytes to insert the
       * string following the next match.
       */
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);

        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
        /* flush the current block */

      }
      /* Insert the string window[strstart .. strstart+2] in the
       * dictionary, and set hash_head to the head of the hash chain:
       */


      hash_head = 0
      /*NIL*/
      ;

      if (s.lookahead >= MIN_MATCH$1) {
        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
        /***/
      }
      /* Find the longest match, discarding those <= prev_length.
       */


      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH$1 - 1;

      if (hash_head !== 0
      /*NIL*/
      && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
      /*MAX_DIST(s)*/
      ) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */

          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096
          /*TOO_FAR*/
          )) {
            /* If prev_match is also MIN_MATCH, match_start is garbage
             * but we will ignore the current match anyway.
             */
            s.match_length = MIN_MATCH$1 - 1;
          }
        }
      /* If there was a match at the previous step and the current
       * match is not better, output the previous match:
       */


      if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
        /* Do not insert strings in hash table beyond this. */
        //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

        /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                       s.prev_length - MIN_MATCH, bflush);***/

        bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
        /* Insert in hash table all strings up to the end of the match.
         * strstart-1 and strstart are already inserted. If there is not
         * enough lookahead, the last two strings are not inserted in
         * the hash table.
         */

        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;

        do {
          if (++s.strstart <= max_insert) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
          }
        } while (--s.prev_length !== 0);

        s.match_available = 0;
        s.match_length = MIN_MATCH$1 - 1;
        s.strstart++;

        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/

        }
      } else if (s.match_available) {
        /* If there was no match at the previous position, output a
         * single literal. If there was a match but the current match
         * is longer, truncate the previous match to a single literal.
         */
        //Tracevv((stderr,"%c", s->window[s->strstart-1]));

        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);

        if (bflush) {
          /*** FLUSH_BLOCK_ONLY(s, 0) ***/
          flush_block_only(s, false);
          /***/
        }

        s.strstart++;
        s.lookahead--;

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        /* There is no previous match to compare with, wait for
         * the next step to decide.
         */
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    } //Assert (flush != Z_NO_FLUSH, "no flush?");


    if (s.match_available) {
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }

    s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;

    if (flush === Z_FINISH) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/


      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }

    return BS_BLOCK_DONE;
  };
  /* ===========================================================================
   * For Z_RLE, simply look for runs of bytes, generate matches only of distance
   * one.  Do not maintain a hash table.  (It will be regenerated if this run of
   * deflate switches away from Z_RLE.)
   */


  var deflate_rle = function deflate_rle(s, flush) {
    var bflush;
    /* set if current block must be flushed */

    var prev;
    /* byte at distance one to match */

    var scan, strend;
    /* scan goes up to strend for length of run */

    var _win = s.window;

    for (;;) {
      /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the longest run, plus one for the unrolled loop.
       */
      if (s.lookahead <= MAX_MATCH$1) {
        fill_window(s);

        if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
        /* flush the current block */

      }
      /* See how many times the previous byte repeats */


      s.match_length = 0;

      if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];

        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH$1;

          do {
            /*jshint noempty:false*/
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

          s.match_length = MAX_MATCH$1 - (strend - scan);

          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

      }
      /* Emit match if have run of MIN_MATCH or longer, else emit literal */


      if (s.match_length >= MIN_MATCH$1) {
        //check_match(s, s.strstart, s.strstart - 1, s.match_length);

        /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
        bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        /* No match, output a literal byte */
        //Tracevv((stderr,"%c", s->window[s->strstart]));

        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
        bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    }

    s.insert = 0;

    if (flush === Z_FINISH) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/


      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }

    return BS_BLOCK_DONE;
  };
  /* ===========================================================================
   * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
   * (It will be regenerated if this run of deflate switches away from Huffman.)
   */


  var deflate_huff = function deflate_huff(s, flush) {
    var bflush;
    /* set if current block must be flushed */

    for (;;) {
      /* Make sure that we have a literal to write. */
      if (s.lookahead === 0) {
        fill_window(s);

        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }

          break;
          /* flush the current block */
        }
      }
      /* Output a literal byte */


      s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    }

    s.insert = 0;

    if (flush === Z_FINISH) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/


      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }

    return BS_BLOCK_DONE;
  };
  /* Values for max_lazy_match, good_match and max_chain_length, depending on
   * the desired pack level (0..9). The values given below have been tuned to
   * exclude worst case performance for pathological files. Better values may be
   * found for specific files.
   */


  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }

  var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
  ];
  /* ===========================================================================
   * Initialize the "longest match" routines for a new zlib stream
   */

  var lm_init = function lm_init(s) {
    s.window_size = 2 * s.w_size;
    /*** CLEAR_HASH(s); ***/

    zero$1(s.head); // Fill with NIL (= 0);

    /* Set the default configuration parameters:
     */

    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH$1 - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };

  function DeflateState() {
    this.strm = null;
    /* pointer back to this zlib stream */

    this.status = 0;
    /* as the name implies */

    this.pending_buf = null;
    /* output still pending */

    this.pending_buf_size = 0;
    /* size of pending_buf */

    this.pending_out = 0;
    /* next pending byte to output to the stream */

    this.pending = 0;
    /* nb of bytes in the pending buffer */

    this.wrap = 0;
    /* bit 0 true for zlib, bit 1 true for gzip */

    this.gzhead = null;
    /* gzip header information to write */

    this.gzindex = 0;
    /* where in extra, name, or comment */

    this.method = Z_DEFLATED;
    /* can only be DEFLATED */

    this.last_flush = -1;
    /* value of flush param for previous deflate call */

    this.w_size = 0;
    /* LZ77 window size (32K by default) */

    this.w_bits = 0;
    /* log2(w_size)  (8..16) */

    this.w_mask = 0;
    /* w_size - 1 */

    this.window = null;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size.
     */

    this.window_size = 0;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    this.prev = null;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    this.head = null;
    /* Heads of the hash chains or NIL. */

    this.ins_h = 0;
    /* hash index of string to be inserted */

    this.hash_size = 0;
    /* number of elements in hash table */

    this.hash_bits = 0;
    /* log2(hash_size) */

    this.hash_mask = 0;
    /* hash_size-1 */

    this.hash_shift = 0;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    this.block_start = 0;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    this.match_length = 0;
    /* length of best match */

    this.prev_match = 0;
    /* previous match */

    this.match_available = 0;
    /* set if previous match exists */

    this.strstart = 0;
    /* start of string to insert */

    this.match_start = 0;
    /* start of matching string */

    this.lookahead = 0;
    /* number of valid bytes ahead in window */

    this.prev_length = 0;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    this.max_chain_length = 0;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    this.max_lazy_match = 0;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
    // That's alias to max_lazy_match, don't use directly
    //this.max_insert_length = 0;

    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    this.level = 0;
    /* compression level (1..9) */

    this.strategy = 0;
    /* favor or force Huffman coding*/

    this.good_match = 0;
    /* Use a faster search when the previous match is longer than this */

    this.nice_match = 0;
    /* Stop searching when current match exceeds this */

    /* used by trees.c: */

    /* Didn't use ct_data typedef below to suppress compiler warning */
    // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
    // Use flat array of DOUBLE size, with interleaved fata,
    // because JS does not support effective

    this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);
    zero$1(this.dyn_ltree);
    zero$1(this.dyn_dtree);
    zero$1(this.bl_tree);
    this.l_desc = null;
    /* desc. for literal tree */

    this.d_desc = null;
    /* desc. for distance tree */

    this.bl_desc = null;
    /* desc. for bit length tree */
    //ush bl_count[MAX_BITS+1];

    this.bl_count = new Uint16Array(MAX_BITS$1 + 1);
    /* number of codes at each bit length for an optimal tree */
    //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

    this.heap = new Uint16Array(2 * L_CODES$1 + 1);
    /* heap used to build the Huffman trees */

    zero$1(this.heap);
    this.heap_len = 0;
    /* number of elements in the heap */

    this.heap_max = 0;
    /* element of largest frequency */

    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    this.depth = new Uint16Array(2 * L_CODES$1 + 1); //uch depth[2*L_CODES+1];

    zero$1(this.depth);
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    this.l_buf = 0;
    /* buffer index for literals or lengths */

    this.lit_bufsize = 0;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    this.last_lit = 0;
    /* running index in l_buf */

    this.d_buf = 0;
    /* Buffer index for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    this.opt_len = 0;
    /* bit length of current block with optimal trees */

    this.static_len = 0;
    /* bit length of current block with static trees */

    this.matches = 0;
    /* number of string matches in current block */

    this.insert = 0;
    /* bytes at end of window left to insert */

    this.bi_buf = 0;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */

    this.bi_valid = 0;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */
    // Used for window memory init. We safely ignore it for JS. That makes
    // sense only for pointers and memory check tools.
    //this.high_water = 0;

    /* High water mark offset in window for initialized bytes -- bytes above
     * this are set to zero in order to avoid memory check warnings when
     * longest match routines access bytes past the input.  This is then
     * updated to the new high water mark.
     */
  }

  var deflateResetKeep = function deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }

    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN$1;
    var s = strm.state;
    s.pending = 0;
    s.pending_out = 0;

    if (s.wrap < 0) {
      s.wrap = -s.wrap;
      /* was made negative by deflate(..., Z_FINISH); */
    }

    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
    : 1; // adler32(0, Z_NULL, 0)

    s.last_flush = Z_NO_FLUSH;

    _tr_init$1(s);

    return Z_OK;
  };

  var deflateReset = function deflateReset(strm) {
    var ret = deflateResetKeep(strm);

    if (ret === Z_OK) {
      lm_init(strm.state);
    }

    return ret;
  };

  var deflateSetHeader = function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }

    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }

    strm.state.gzhead = head;
    return Z_OK;
  };

  var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      // === Z_NULL
      return Z_STREAM_ERROR;
    }

    var wrap = 1;

    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }

    if (windowBits < 0) {
      /* suppress zlib wrapper */
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      /* write gzip wrapper instead */

      windowBits -= 16;
    }

    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {
      return err(strm, Z_STREAM_ERROR);
    }

    if (windowBits === 8) {
      windowBits = 9;
    }
    /* until 256-byte window bug fixed */


    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.
    //s.high_water = 0;  /* nothing written to s->window yet */

    s.lit_bufsize = 1 << memLevel + 6;
    /* 16K elements by default */

    s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    //s->pending_buf = (uchf *) overlay;

    s.pending_buf = new Uint8Array(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

    s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  };

  var deflateInit = function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  };

  var deflate = function deflate(strm, flush) {
    var beg, val; // for gzip header write only

    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }

    var s = strm.state;

    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }

    s.strm = strm;
    /* just in case */

    var old_flush = s.last_flush;
    s.last_flush = flush;
    /* Write the header */

    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        // GZIP header
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);

        if (!s.gzhead) {
          // s->gzhead == Z_NULL
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 0xff);
          put_byte(s, s.gzhead.time >> 8 & 0xff);
          put_byte(s, s.gzhead.time >> 16 & 0xff);
          put_byte(s, s.gzhead.time >> 24 & 0xff);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 0xff);

          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 0xff);
            put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
          }

          if (s.gzhead.hcrc) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
          }

          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else // DEFLATE header
        {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;

          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }

          header |= level_flags << 6;

          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }

          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          /* Save the adler32 of the preset dictionary: */

          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }

          strm.adler = 1; // adler32(0L, Z_NULL, 0);
        }
    } //#ifdef GZIP


    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra
      /* != Z_NULL*/
      ) {
          beg = s.pending;
          /* start of bytes to update crc */

          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }

              flush_pending(strm);
              beg = s.pending;

              if (s.pending === s.pending_buf_size) {
                break;
              }
            }

            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }

          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
        s.status = NAME_STATE;
      }
    }

    if (s.status === NAME_STATE) {
      if (s.gzhead.name
      /* != Z_NULL*/
      ) {
          beg = s.pending;
          /* start of bytes to update crc */
          //int val;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }

              flush_pending(strm);
              beg = s.pending;

              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            } // JS specific: little magic to add zero terminator to end of string


            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }

            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }

          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
        s.status = COMMENT_STATE;
      }
    }

    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment
      /* != Z_NULL*/
      ) {
          beg = s.pending;
          /* start of bytes to update crc */
          //int val;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }

              flush_pending(strm);
              beg = s.pending;

              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            } // JS specific: little magic to add zero terminator to end of string


            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }

            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }

          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
        s.status = HCRC_STATE;
      }
    }

    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }

        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 0xff);
          put_byte(s, strm.adler >> 8 & 0xff);
          strm.adler = 0; //crc32(0L, Z_NULL, 0);

          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    } //#endif

    /* Flush as much pending output as possible */


    if (s.pending !== 0) {
      flush_pending(strm);

      if (strm.avail_out === 0) {
        /* Since avail_out is 0, deflate will be called again with
         * more output space, but possibly with both pending and
         * avail_in equal to zero. There won't be anything to do,
         * but this is not an error situation so make sure we
         * return OK instead of BUF_ERROR at next call of deflate:
         */
        s.last_flush = -1;
        return Z_OK;
      }
      /* Make sure there is something to do and avoid duplicate consecutive
       * flushes. For repeated and useless calls with Z_FINISH, we keep
       * returning Z_STREAM_END instead of Z_BUF_ERROR.
       */

    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    /* User must not provide more input after the first FINISH: */


    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    /* Start a new block or continue the current one.
     */


    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }

      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          /* avoid BUF_ERROR next call, see above */
        }

        return Z_OK;
        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
         * of deflate should use the same flush parameter to make sure
         * that the flush is complete. So we don't have to output an
         * empty block here, this will be done at next call. This also
         * ensures that for a very small output buffer, we emit at most
         * one empty block.
         */
      }

      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          _tr_align$1(s);
        } else if (flush !== Z_BLOCK) {
          /* FULL_FLUSH or SYNC_FLUSH */
          _tr_stored_block$1(s, 0, 0, false);
          /* For a full flush, this empty block will be recognized
           * as a special marker by inflate_sync().
           */


          if (flush === Z_FULL_FLUSH) {
            /*** CLEAR_HASH(s); ***/

            /* forget history */
            zero$1(s.head); // Fill with NIL (= 0);

            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }

        flush_pending(strm);

        if (strm.avail_out === 0) {
          s.last_flush = -1;
          /* avoid BUF_ERROR at next call, see above */

          return Z_OK;
        }
      }
    } //Assert(strm->avail_out > 0, "bug2");
    //if (strm.avail_out <= 0) { throw new Error("bug2");}


    if (flush !== Z_FINISH) {
      return Z_OK;
    }

    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    /* Write the trailer */


    if (s.wrap === 2) {
      put_byte(s, strm.adler & 0xff);
      put_byte(s, strm.adler >> 8 & 0xff);
      put_byte(s, strm.adler >> 16 & 0xff);
      put_byte(s, strm.adler >> 24 & 0xff);
      put_byte(s, strm.total_in & 0xff);
      put_byte(s, strm.total_in >> 8 & 0xff);
      put_byte(s, strm.total_in >> 16 & 0xff);
      put_byte(s, strm.total_in >> 24 & 0xff);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }

    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */

    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    /* write the trailer only once! */


    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  };

  var deflateEnd = function deflateEnd(strm) {
    if (!strm
    /*== Z_NULL*/
    || !strm.state
    /*== Z_NULL*/
    ) {
        return Z_STREAM_ERROR;
      }

    var status = strm.state.status;

    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }

    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  };
  /* =========================================================================
   * Initializes the compression dictionary from the given byte
   * sequence without producing any compressed output.
   */


  var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;

    if (!strm
    /*== Z_NULL*/
    || !strm.state
    /*== Z_NULL*/
    ) {
        return Z_STREAM_ERROR;
      }

    var s = strm.state;
    var wrap = s.wrap;

    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    /* when using zlib wrappers, compute Adler-32 for provided dictionary */


    if (wrap === 1) {
      /* adler32(strm->adler, dictionary, dictLength); */
      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }

    s.wrap = 0;
    /* avoid computing Adler-32 in read_buf */

    /* if dictionary would fill window, just replace the history */

    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        /* already empty otherwise */

        /*** CLEAR_HASH(s); ***/
        zero$1(s.head); // Fill with NIL (= 0);

        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      /* use the tail */
      // dictionary = dictionary.slice(dictLength - s.w_size);


      var tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    /* insert dictionary into window and hash */


    var avail = strm.avail_in;
    var next = strm.next_in;
    var input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);

    while (s.lookahead >= MIN_MATCH$1) {
      var str = s.strstart;
      var n = s.lookahead - (MIN_MATCH$1 - 1);

      do {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);

      s.strstart = str;
      s.lookahead = MIN_MATCH$1 - 1;
      fill_window(s);
    }

    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH$1 - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  };

  var deflateInit_1 = deflateInit;
  var deflateInit2_1 = deflateInit2;
  var deflateReset_1 = deflateReset;
  var deflateResetKeep_1 = deflateResetKeep;
  var deflateSetHeader_1 = deflateSetHeader;
  var deflate_2 = deflate;
  var deflateEnd_1 = deflateEnd;
  var deflateSetDictionary_1 = deflateSetDictionary;
  var deflateInfo = 'pako deflate (from Nodeca project)';
  /* Not implemented
  module.exports.deflateBound = deflateBound;
  module.exports.deflateCopy = deflateCopy;
  module.exports.deflateParams = deflateParams;
  module.exports.deflatePending = deflatePending;
  module.exports.deflatePrime = deflatePrime;
  module.exports.deflateTune = deflateTune;
  */

  var deflate_1 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo: deflateInfo
  };

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var _has = function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  var assign = function assign(obj
  /*from1, from2, from3, ...*/
  ) {
    var sources = Array.prototype.slice.call(arguments, 1);

    while (sources.length) {
      var source = sources.shift();

      if (!source) {
        continue;
      }

      if (_typeof(source) !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  }; // Join array of chunks to single array.


  var flattenChunks = function flattenChunks(chunks) {
    // calculate data length
    var len = 0;

    for (var i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    var result = new Uint8Array(len);

    for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {
      var chunk = chunks[_i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  };

  var common = {
    assign: assign,
    flattenChunks: flattenChunks
  };

  // String encode/decode helpers
  //
  // - apply(Array) can fail on Android 2.2
  // - apply(Uint8Array) can fail on iOS 5.1 Safari
  //

  var STR_APPLY_UIA_OK = true;

  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  } // Table with utf8 lengths (calculated by first byte of sequence)
  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
  // because max possible codepoint is 0x10ffff


  var _utf8len = new Uint8Array(256);

  for (var q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }

  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
  // convert string to array (typed, when possible)

  var string2buf = function string2buf(str) {
    var buf,
        c,
        c2,
        m_pos,
        i,
        str_len = str.length,
        buf_len = 0; // count binary size

    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);

      if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);

        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }

      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    } // allocate buffer


    buf = new Uint8Array(buf_len); // convert

    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);

      if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);

        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }

      if (c < 0x80) {
        /* one byte */
        buf[i++] = c;
      } else if (c < 0x800) {
        /* two bytes */
        buf[i++] = 0xC0 | c >>> 6;
        buf[i++] = 0x80 | c & 0x3f;
      } else if (c < 0x10000) {
        /* three bytes */
        buf[i++] = 0xE0 | c >>> 12;
        buf[i++] = 0x80 | c >>> 6 & 0x3f;
        buf[i++] = 0x80 | c & 0x3f;
      } else {
        /* four bytes */
        buf[i++] = 0xf0 | c >>> 18;
        buf[i++] = 0x80 | c >>> 12 & 0x3f;
        buf[i++] = 0x80 | c >>> 6 & 0x3f;
        buf[i++] = 0x80 | c & 0x3f;
      }
    }

    return buf;
  }; // Helper


  var buf2binstring = function buf2binstring(buf, len) {
    // On Chrome, the arguments in a function call that are allowed is `65534`.
    // If the length of the buffer is smaller than that, we can use this optimization,
    // otherwise we will take a slower path.
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }

    var result = '';

    for (var i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }

    return result;
  }; // convert array to string


  var buf2string = function buf2string(buf, max) {
    var i, out;
    var len = max || buf.length; // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.

    var utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
      var c = buf[i++]; // quick process ascii

      if (c < 0x80) {
        utf16buf[out++] = c;
        continue;
      }

      var c_len = _utf8len[c]; // skip 5 & 6 byte codes

      if (c_len > 4) {
        utf16buf[out++] = 0xfffd;
        i += c_len - 1;
        continue;
      } // apply mask on first byte


      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 0x3f;
        c_len--;
      } // terminated by end of string?


      if (c_len > 1) {
        utf16buf[out++] = 0xfffd;
        continue;
      }

      if (c < 0x10000) {
        utf16buf[out++] = c;
      } else {
        c -= 0x10000;
        utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
        utf16buf[out++] = 0xdc00 | c & 0x3ff;
      }
    }

    return buf2binstring(utf16buf, out);
  }; // Calculate max possible position in utf8 buffer,
  // that will not break sequence. If that's not possible
  // - (very small limits) return max size as is.
  //
  // buf[] - utf8 bytes array
  // max   - length limit (mandatory);


  var utf8border = function utf8border(buf, max) {
    max = max || buf.length;

    if (max > buf.length) {
      max = buf.length;
    } // go back from last position, until start of sequence found


    var pos = max - 1;

    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
      pos--;
    } // Very small and broken sequence,
    // return max, because we should return something anyway.


    if (pos < 0) {
      return max;
    } // If we came to start of buffer - that means buffer is too small,
    // return max too.


    if (pos === 0) {
      return max;
    }

    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };

  var strings = {
    string2buf: string2buf,
    buf2string: buf2string,
    utf8border: utf8border
  };

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function ZStream() {
    /* next input byte */
    this.input = null; // JS specific, because we have no pointers

    this.next_in = 0;
    /* number of bytes available at input */

    this.avail_in = 0;
    /* total number of input bytes read so far */

    this.total_in = 0;
    /* next output byte should be put there */

    this.output = null; // JS specific, because we have no pointers

    this.next_out = 0;
    /* remaining free space at output */

    this.avail_out = 0;
    /* total number of bytes output so far */

    this.total_out = 0;
    /* last error message, NULL if no error */

    this.msg = ''
    /*Z_NULL*/
    ;
    /* not visible by applications */

    this.state = null;
    /* best guess about the data type: binary or text */

    this.data_type = 2
    /*Z_UNKNOWN*/
    ;
    /* adler32 value of the uncompressed data */

    this.adler = 0;
  }

  var zstream = ZStream;

  var toString = Object.prototype.toString;
  /* Public constants ==========================================================*/

  /* ===========================================================================*/

  var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH,
      Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH,
      Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH,
      Z_FINISH$1 = constants.Z_FINISH,
      Z_OK$1 = constants.Z_OK,
      Z_STREAM_END$1 = constants.Z_STREAM_END,
      Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY,
      Z_DEFLATED$1 = constants.Z_DEFLATED;
  /* ===========================================================================*/

  /**
   * class Deflate
   *
   * Generic JS-style wrapper for zlib calls. If you don't need
   * streaming behaviour - use more simple functions: [[deflate]],
   * [[deflateRaw]] and [[gzip]].
   **/

  /* internal
   * Deflate.chunks -> Array
   *
   * Chunks of output data, if [[Deflate#onData]] not overridden.
   **/

  /**
   * Deflate.result -> Uint8Array
   *
   * Compressed result, generated by default [[Deflate#onData]]
   * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
   * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
   **/

  /**
   * Deflate.err -> Number
   *
   * Error code after deflate finished. 0 (Z_OK) on success.
   * You will not need it in real life, because deflate errors
   * are possible only on wrong options or bad `onData` / `onEnd`
   * custom handlers.
   **/

  /**
   * Deflate.msg -> String
   *
   * Error message, if [[Deflate.err]] != 0
   **/

  /**
   * new Deflate(options)
   * - options (Object): zlib deflate options.
   *
   * Creates new deflator instance with specified params. Throws exception
   * on bad params. Supported options:
   *
   * - `level`
   * - `windowBits`
   * - `memLevel`
   * - `strategy`
   * - `dictionary`
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Additional options, for internal needs:
   *
   * - `chunkSize` - size of generated data chunks (16K by default)
   * - `raw` (Boolean) - do raw deflate
   * - `gzip` (Boolean) - create gzip wrapper
   * - `header` (Object) - custom header for gzip
   *   - `text` (Boolean) - true if compressed data believed to be text
   *   - `time` (Number) - modification time, unix timestamp
   *   - `os` (Number) - operation system code
   *   - `extra` (Array) - array of bytes with extra data (max 65536)
   *   - `name` (String) - file name (binary string)
   *   - `comment` (String) - comment (binary string)
   *   - `hcrc` (Boolean) - true if header crc should be added
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
   *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
   *
   * const deflate = new pako.Deflate({ level: 3});
   *
   * deflate.push(chunk1, false);
   * deflate.push(chunk2, true);  // true -> last chunk
   *
   * if (deflate.err) { throw new Error(deflate.err); }
   *
   * console.log(deflate.result);
   * ```
   **/

  function Deflate(options) {
    this.options = common.assign({
      level: Z_DEFAULT_COMPRESSION$1,
      method: Z_DEFLATED$1,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY$1
    }, options || {});
    var opt = this.options;

    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }

    this.err = 0; // error code, if happens (0 = Z_OK)

    this.msg = ''; // error message

    this.ended = false; // used to avoid multiple onEnd() calls

    this.chunks = []; // chunks of compressed data

    this.strm = new zstream();
    this.strm.avail_out = 0;
    var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }

    if (opt.header) {
      deflate_1.deflateSetHeader(this.strm, opt.header);
    }

    if (opt.dictionary) {
      var dict; // Convert data if needed

      if (typeof opt.dictionary === 'string') {
        // If we need to compress text, change encoding to utf8.
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }

      status = deflate_1.deflateSetDictionary(this.strm, dict);

      if (status !== Z_OK$1) {
        throw new Error(messages[status]);
      }

      this._dict_set = true;
    }
  }
  /**
   * Deflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
   *   converted to utf8 byte sequence.
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
   *
   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
   * new compressed chunks. Returns `true` on success. The last data block must
   * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
   * buffers and call [[Deflate#onEnd]].
   *
   * On fail call [[Deflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/


  Deflate.prototype.push = function (data, flush_mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;

    var status, _flush_mode;

    if (this.ended) {
      return false;
    }

    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;else _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1; // Convert data if needed

    if (typeof data === 'string') {
      // If we need to compress text, change encoding to utf8.
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    for (;;) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      } // Make sure avail_out > 6 to avoid repeating markers


      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }

      status = deflate_1.deflate(strm, _flush_mode); // Ended => flush and finish

      if (status === Z_STREAM_END$1) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }

        status = deflate_1.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK$1;
      } // Flush if out buffer full


      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      } // Flush if requested and has data


      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }

      if (strm.avail_in === 0) break;
    }

    return true;
  };
  /**
   * Deflate#onData(chunk) -> Void
   * - chunk (Uint8Array): output data.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/


  Deflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };
  /**
   * Deflate#onEnd(status) -> Void
   * - status (Number): deflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called once after you tell deflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/


  Deflate.prototype.onEnd = function (status) {
    // On success - join
    if (status === Z_OK$1) {
      this.result = common.flattenChunks(this.chunks);
    }

    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  /**
   * deflate(data[, options]) -> Uint8Array
   * - data (Uint8Array|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * Compress `data` with deflate algorithm and `options`.
   *
   * Supported options are:
   *
   * - level
   * - windowBits
   * - memLevel
   * - strategy
   * - dictionary
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
   *
   * console.log(pako.deflate(data));
   * ```
   **/


  function deflate$1(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true); // That will never happens, if you don't cheat with options :)

    if (deflator.err) {
      throw deflator.msg || messages[deflator.err];
    }

    return deflator.result;
  }
  /**
   * deflateRaw(data[, options]) -> Uint8Array
   * - data (Uint8Array|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * The same as [[deflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/


  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
  }
  /**
   * gzip(data[, options]) -> Uint8Array
   * - data (Uint8Array|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * The same as [[deflate]], but create gzip wrapper instead of
   * deflate one.
   **/


  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
  }

  var Deflate_1 = Deflate;
  var deflate_2$1 = deflate$1;
  var deflateRaw_1 = deflateRaw;
  var gzip_1 = gzip;
  var constants$1 = constants;
  var deflate_1$1 = {
    Deflate: Deflate_1,
    deflate: deflate_2$1,
    deflateRaw: deflateRaw_1,
    gzip: gzip_1,
    constants: constants$1
  };

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.
  // See state defs from inflate.js

  var BAD = 30;
  /* got a data error -- remain here until reset */

  var TYPE = 12;
  /* i: waiting for type bits, including last-flag bit */

  /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.

     Entry assumptions:

          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8

     On return, state.mode is one of:

          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data

     Notes:

      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.

      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */

  var inffast = function inflate_fast(strm, start) {
    var _in;
    /* local strm.input */


    var last;
    /* have enough input while in < last */

    var _out;
    /* local strm.output */


    var beg;
    /* inflate()'s initial strm.output */

    var end;
    /* while out < end, enough space available */
    //#ifdef INFLATE_STRICT

    var dmax;
    /* maximum distance from zlib header */
    //#endif

    var wsize;
    /* window size or zero if not using window */

    var whave;
    /* valid bytes in the window */

    var wnext;
    /* window write index */
    // Use `s_window` instead `window`, avoid conflict with instrumentation tools

    var s_window;
    /* allocated sliding window, if wsize != 0 */

    var hold;
    /* local strm.hold */

    var bits;
    /* local strm.bits */

    var lcode;
    /* local strm.lencode */

    var dcode;
    /* local strm.distcode */

    var lmask;
    /* mask for first level of length codes */

    var dmask;
    /* mask for first level of distance codes */

    var here;
    /* retrieved table entry */

    var op;
    /* code bits, operation, extra bits, or */

    /*  window position, window bytes to copy */

    var len;
    /* match length, unused bytes */

    var dist;
    /* match distance */

    var from;
    /* where to copy match from */

    var from_source;
    var input, output; // JS specific, because we have no pointers

    /* copy state to local variables */

    var state = strm.state; //here = state.here;

    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

    dmax = state.dmax; //#endif

    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen: for (;;) {
        // Goto emulation
        op = here >>> 24
        /*here.bits*/
        ;
        hold >>>= op;
        bits -= op;
        op = here >>> 16 & 0xff
        /*here.op*/
        ;

        if (op === 0) {
          /* literal */
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          output[_out++] = here & 0xffff
          /*here.val*/
          ;
        } else if (op & 16) {
          /* length base */
          len = here & 0xffff
          /*here.val*/
          ;
          op &= 15;
          /* number of extra bits */

          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }

            len += hold & (1 << op) - 1;
            hold >>>= op;
            bits -= op;
          } //Tracevv((stderr, "inflate:         length %u\n", len));


          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }

          here = dcode[hold & dmask];

          dodist: for (;;) {
            // goto emulation
            op = here >>> 24
            /*here.bits*/
            ;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff
            /*here.op*/
            ;

            if (op & 16) {
              /* distance base */
              dist = here & 0xffff
              /*here.val*/
              ;
              op &= 15;
              /* number of extra bits */

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;

                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }

              dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              } //#endif


              hold >>>= op;
              bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

              op = _out - beg;
              /* max distance in output */

              if (dist > op) {
                /* see if copy from window */
                op = dist - op;
                /* distance back in window */

                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  } // (!) This block is disabled in zlib defaults,
                  // don't enable it for binary compatibility
                  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                  //                if (len <= op - whave) {
                  //                  do {
                  //                    output[_out++] = 0;
                  //                  } while (--len);
                  //                  continue top;
                  //                }
                  //                len -= op - whave;
                  //                do {
                  //                  output[_out++] = 0;
                  //                } while (--op > whave);
                  //                if (op === 0) {
                  //                  from = _out - dist;
                  //                  do {
                  //                    output[_out++] = output[from++];
                  //                  } while (--len);
                  //                  continue top;
                  //                }
                  //#endif

                }

                from = 0; // window index

                from_source = s_window;

                if (wnext === 0) {
                  /* very common case */
                  from += wsize - op;

                  if (op < len) {
                    /* some from window */
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                } else if (wnext < op) {
                  /* wrap around window */
                  from += wsize + wnext - op;
                  op -= wnext;

                  if (op < len) {
                    /* some from end of window */
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = 0;

                    if (wnext < len) {
                      /* some from start of window */
                      op = wnext;
                      len -= op;

                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);

                      from = _out - dist;
                      /* rest from output */

                      from_source = output;
                    }
                  }
                } else {
                  /* contiguous in window */
                  from += wnext - op;

                  if (op < len) {
                    /* some from window */
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                }

                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }

                if (len) {
                  output[_out++] = from_source[from++];

                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;
                /* copy direct from output */

                do {
                  /* minimum length is three */
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);

                if (len) {
                  output[_out++] = output[from++];

                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              /* 2nd level distance code */
              here = dcode[(here & 0xffff) + (
              /*here.val*/
              hold & (1 << op) - 1)];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        } else if ((op & 64) === 0) {
          /* 2nd level length code */
          here = lcode[(here & 0xffff) + (
          /*here.val*/
          hold & (1 << op) - 1)];
          continue dolen;
        } else if (op & 32) {
          /* end-of-block */
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }

        break; // need to emulate goto via "continue"
      }
    } while (_in < last && _out < end);
    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    /* update state and return */

    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592; //const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
  var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
  var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
  var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);

  var inflate_table = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits; //here = opts.here; /* table entry for duplication */

    var len = 0;
    /* a code's length in bits */

    var sym = 0;
    /* index of code symbols */

    var min = 0,
        max = 0;
    /* minimum and maximum code lengths */

    var root = 0;
    /* number of index bits for root table */

    var curr = 0;
    /* number of index bits for current table */

    var drop = 0;
    /* code bits to drop for sub-table */

    var left = 0;
    /* number of prefix codes available */

    var used = 0;
    /* code entries in table used */

    var huff = 0;
    /* Huffman code */

    var incr;
    /* for incrementing code, index */

    var fill;
    /* index for replicating entries */

    var low;
    /* low bits for current root entry */

    var mask;
    /* mask for low root bits */

    var next;
    /* next available space in table */

    var base = null;
    /* base value table to use */

    var base_index = 0; //  let shoextra;    /* extra bits table to use */

    var end;
    /* use base and extra for symbol > end */

    var count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

    var offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    /*
     Process a set of code lengths to create a canonical Huffman code.  The
     code lengths are lens[0..codes-1].  Each length corresponds to the
     symbols 0..codes-1.  The Huffman code is generated by first sorting the
     symbols by length from short to long, and retaining the symbol order
     for codes with equal lengths.  Then the code starts with all zero bits
     for the first code of the shortest length, and the codes are integer
     increments for the same length, and zeros are appended as the length
     increases.  For the deflate format, these bits are stored backwards
     from their more natural integer increment ordering, and so when the
     decoding tables are built in the large loop below, the integer codes
     are incremented backwards.
      This routine assumes, but does not check, that all of the entries in
     lens[] are in the range 0..MAXBITS.  The caller must assure this.
     1..MAXBITS is interpreted as that code length.  zero means that that
     symbol does not occur in this code.
      The codes are sorted by computing a count of codes for each length,
     creating from that a table of starting indices for each length in the
     sorted table, and then entering the symbols in order in the sorted
     table.  The sorted table is work[], with that space being provided by
     the caller.
      The length counts are used for other purposes as well, i.e. finding
     the minimum and maximum length codes, determining if there are any
     codes at all, checking for a valid set of lengths, and looking ahead
     at length counts to determine sub-table sizes when building the
     decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }

    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    /* bound code lengths, force root to be within code lengths */


    root = bits;

    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }

    if (root > max) {
      root = max;
    }

    if (max === 0) {
      /* no symbols to code at all */
      //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
      //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
      //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
      //table.bits[opts.table_index] = 1;
      //table.val[opts.table_index++] = 0;

      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
      /* no symbols, but wait for decoding to report error */
    }

    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }

    if (root < min) {
      root = min;
    }
    /* check for an over-subscribed or incomplete set of lengths */


    left = 1;

    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];

      if (left < 0) {
        return -1;
      }
      /* over-subscribed */

    }

    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
      /* incomplete set */
    }
    /* generate offsets into symbol table for each length for sorting */


    offs[1] = 0;

    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    /* sort symbols by length, by symbol order within each length */


    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    /*
     Create and fill in decoding tables.  In this loop, the table being
     filled is at next and has curr index bits.  The code being used is huff
     with length len.  That code is converted to an index by dropping drop
     bits off of the bottom.  For codes where len is less than drop + curr,
     those top drop + curr - len bits are incremented through all values to
     fill the table with replicated entries.
      root is the number of index bits for the root table.  When len exceeds
     root, sub-tables are created pointed to by the root entry with an index
     of the low root bits of huff.  This is saved in low to check for when a
     new sub-table should be started.  drop is zero when the root table is
     being filled, and drop is root when sub-tables are being filled.
      When a new sub-table is needed, it is necessary to look ahead in the
     code lengths to determine what size sub-table is needed.  The length
     counts are used for this, and so count[] is decremented as codes are
     entered in the tables.
      used keeps track of how many table entries have been allocated from the
     provided *table space.  It is checked for LENS and DIST tables against
     the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
     the initial root table size constants.  See the comments in inftrees.h
     for more information.
      sym increments through all symbols, and the loop terminates when
     all codes of length max, i.e. all codes, have been processed.  This
     routine permits incomplete codes, so another loop after this one fills
     in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    // poor man optimization - use if-else instead of switch,
    // to avoid deopts in old v8


    if (type === CODES) {
      base = extra = work;
      /* dummy value--not used */

      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      /* DISTS */
      base = dbase;
      extra = dext;
      end = -1;
    }
    /* initialize opts for loop */


    huff = 0;
    /* starting code */

    sym = 0;
    /* starting code symbol */

    len = min;
    /* starting code length */

    next = table_index;
    /* current table to fill in */

    curr = root;
    /* current table index bits */

    drop = 0;
    /* current bits to drop from code for index */

    low = -1;
    /* trigger new sub-table when len > root */

    used = 1 << root;
    /* use root table entries */

    mask = used - 1;
    /* mask for comparing low */

    /* check available table space */

    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    /* process all codes and make table entries */


    for (;;) {
      /* create table entry */
      here_bits = len - drop;

      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        /* end of block */

        here_val = 0;
      }
      /* replicate for those indices with low len bits equal to huff */


      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      /* save offset to next table */

      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      /* backwards increment the len-bit code huff */


      incr = 1 << len - 1;

      while (huff & incr) {
        incr >>= 1;
      }

      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      /* go to next symbol, update count, len */


      sym++;

      if (--count[len] === 0) {
        if (len === max) {
          break;
        }

        len = lens[lens_index + work[sym]];
      }
      /* create new sub-table if needed */


      if (len > root && (huff & mask) !== low) {
        /* if first time, transition to sub-tables */
        if (drop === 0) {
          drop = root;
        }
        /* increment past last table */


        next += min;
        /* here min is 1 << curr */

        /* determine length of next table */

        curr = len - drop;
        left = 1 << curr;

        while (curr + drop < max) {
          left -= count[curr + drop];

          if (left <= 0) {
            break;
          }

          curr++;
          left <<= 1;
        }
        /* check for enough space */


        used += 1 << curr;

        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        /* point entry in root table to sub-table */


        low = huff & mask;
        /*table.op[low] = curr;
        table.bits[low] = root;
        table.val[low] = next - opts.table_index;*/

        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    /* fill in remaining table entry if code is incomplete (guaranteed to have
     at most one remaining entry, since if the code is incomplete, the
     maximum code length that was allowed to get this far is one bit) */


    if (huff !== 0) {
      //table.op[next + huff] = 64;            /* invalid code marker */
      //table.bits[next + huff] = len - drop;
      //table.val[next + huff] = 0;
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    /* set return parameters */
    //opts.table_index += used;


    opts.bits = root;
    return 0;
  };

  var inftrees = inflate_table;

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.


  var CODES$1 = 0;
  var LENS$1 = 1;
  var DISTS$1 = 2;
  /* Public constants ==========================================================*/

  /* ===========================================================================*/

  var Z_FINISH$2 = constants.Z_FINISH,
      Z_BLOCK$1 = constants.Z_BLOCK,
      Z_TREES = constants.Z_TREES,
      Z_OK$2 = constants.Z_OK,
      Z_STREAM_END$2 = constants.Z_STREAM_END,
      Z_NEED_DICT = constants.Z_NEED_DICT,
      Z_STREAM_ERROR$1 = constants.Z_STREAM_ERROR,
      Z_DATA_ERROR$1 = constants.Z_DATA_ERROR,
      Z_MEM_ERROR = constants.Z_MEM_ERROR,
      Z_BUF_ERROR$1 = constants.Z_BUF_ERROR,
      Z_DEFLATED$2 = constants.Z_DEFLATED;
  /* STATES ====================================================================*/

  /* ===========================================================================*/

  var HEAD = 1;
  /* i: waiting for magic header */

  var FLAGS = 2;
  /* i: waiting for method and flags (gzip) */

  var TIME = 3;
  /* i: waiting for modification time (gzip) */

  var OS = 4;
  /* i: waiting for extra flags and operating system (gzip) */

  var EXLEN = 5;
  /* i: waiting for extra length (gzip) */

  var EXTRA = 6;
  /* i: waiting for extra bytes (gzip) */

  var NAME = 7;
  /* i: waiting for end of file name (gzip) */

  var COMMENT = 8;
  /* i: waiting for end of comment (gzip) */

  var HCRC = 9;
  /* i: waiting for header crc (gzip) */

  var DICTID = 10;
  /* i: waiting for dictionary check value */

  var DICT = 11;
  /* waiting for inflateSetDictionary() call */

  var TYPE$1 = 12;
  /* i: waiting for type bits, including last-flag bit */

  var TYPEDO = 13;
  /* i: same, but skip check to exit inflate on new block */

  var STORED = 14;
  /* i: waiting for stored size (length and complement) */

  var COPY_ = 15;
  /* i/o: same as COPY below, but only first time in */

  var COPY = 16;
  /* i/o: waiting for input or output to copy stored block */

  var TABLE = 17;
  /* i: waiting for dynamic block table lengths */

  var LENLENS = 18;
  /* i: waiting for code length code lengths */

  var CODELENS = 19;
  /* i: waiting for length/lit and distance code lengths */

  var LEN_ = 20;
  /* i: same as LEN below, but only first time in */

  var LEN = 21;
  /* i: waiting for length/lit/eob code */

  var LENEXT = 22;
  /* i: waiting for length extra bits */

  var DIST = 23;
  /* i: waiting for distance code */

  var DISTEXT = 24;
  /* i: waiting for distance extra bits */

  var MATCH = 25;
  /* o: waiting for output space to copy string */

  var LIT = 26;
  /* o: waiting for output space to write literal */

  var CHECK = 27;
  /* i: waiting for 32-bit check value */

  var LENGTH = 28;
  /* i: waiting for 32-bit length (gzip) */

  var DONE = 29;
  /* finished check, done -- remain here until reset */

  var BAD$1 = 30;
  /* got a data error -- remain here until reset */

  var MEM = 31;
  /* got an inflate() memory error -- remain here until reset */

  var SYNC = 32;
  /* looking for synchronization bytes to restart inflate() */

  /* ===========================================================================*/

  var ENOUGH_LENS$1 = 852;
  var ENOUGH_DISTS$1 = 592; //const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

  var MAX_WBITS$1 = 15;
  /* 32K LZ77 window */

  var DEF_WBITS = MAX_WBITS$1;

  var zswap32 = function zswap32(q) {
    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
  };

  function InflateState() {
    this.mode = 0;
    /* current inflate mode */

    this.last = false;
    /* true if processing last block */

    this.wrap = 0;
    /* bit 0 true for zlib, bit 1 true for gzip */

    this.havedict = false;
    /* true if dictionary provided */

    this.flags = 0;
    /* gzip header method and flags (0 if zlib) */

    this.dmax = 0;
    /* zlib header max distance (INFLATE_STRICT) */

    this.check = 0;
    /* protected copy of check value */

    this.total = 0;
    /* protected copy of output count */
    // TODO: may be {}

    this.head = null;
    /* where to save gzip header information */

    /* sliding window */

    this.wbits = 0;
    /* log base 2 of requested window size */

    this.wsize = 0;
    /* window size or zero if not using window */

    this.whave = 0;
    /* valid bytes in the window */

    this.wnext = 0;
    /* window write index */

    this.window = null;
    /* allocated sliding window, if needed */

    /* bit accumulator */

    this.hold = 0;
    /* input bit accumulator */

    this.bits = 0;
    /* number of bits in "in" */

    /* for string and stored block copying */

    this.length = 0;
    /* literal or length of data to copy */

    this.offset = 0;
    /* distance back to copy string from */

    /* for table and code decoding */

    this.extra = 0;
    /* extra bits needed */

    /* fixed and dynamic code tables */

    this.lencode = null;
    /* starting table for length/literal codes */

    this.distcode = null;
    /* starting table for distance codes */

    this.lenbits = 0;
    /* index bits for lencode */

    this.distbits = 0;
    /* index bits for distcode */

    /* dynamic table building */

    this.ncode = 0;
    /* number of code length code lengths */

    this.nlen = 0;
    /* number of length code lengths */

    this.ndist = 0;
    /* number of distance code lengths */

    this.have = 0;
    /* number of code lengths in lens[] */

    this.next = null;
    /* next available space in codes[] */

    this.lens = new Uint16Array(320);
    /* temporary storage for code lengths */

    this.work = new Uint16Array(288);
    /* work area for code table building */

    /*
     because we don't have pointers in js, we use lencode and distcode directly
     as buffers so we don't need codes
    */
    //this.codes = new Int32Array(ENOUGH);       /* space for code tables */

    this.lendyn = null;
    /* dynamic table for length/literal codes (JS specific) */

    this.distdyn = null;
    /* dynamic table for distance codes (JS specific) */

    this.sane = 0;
    /* if false, allow invalid distance too far */

    this.back = 0;
    /* bits back of last unprocessed length/lit */

    this.was = 0;
    /* initial length of match */
  }

  var inflateResetKeep = function inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR$1;
    }

    var state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = '';
    /*Z_NULL*/

    if (state.wrap) {
      /* to support ill-conceived Java test suite */
      strm.adler = state.wrap & 1;
    }

    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null
    /*Z_NULL*/
    ;
    state.hold = 0;
    state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$1);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$1);
    state.sane = 1;
    state.back = -1; //Tracev((stderr, "inflate: reset\n"));

    return Z_OK$2;
  };

  var inflateReset = function inflateReset(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR$1;
    }

    var state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };

  var inflateReset2 = function inflateReset2(strm, windowBits) {
    var wrap;
    /* get the state */

    if (!strm || !strm.state) {
      return Z_STREAM_ERROR$1;
    }

    var state = strm.state;
    /* extract wrap request from windowBits parameter */

    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;

      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    /* set number of window bits, free window if different */


    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }

    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    /* update state and reset the rest of it */


    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };

  var inflateInit2 = function inflateInit2(strm, windowBits) {
    if (!strm) {
      return Z_STREAM_ERROR$1;
    } //strm.msg = Z_NULL;                 /* in case we return an error */


    var state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
    //Tracev((stderr, "inflate: allocated\n"));

    strm.state = state;
    state.window = null
    /*Z_NULL*/
    ;
    var ret = inflateReset2(strm, windowBits);

    if (ret !== Z_OK$2) {
      strm.state = null
      /*Z_NULL*/
      ;
    }

    return ret;
  };

  var inflateInit = function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  };
  /*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
   */


  var virgin = true;
  var lenfix, distfix; // We have no pointers in JS, so keep tables separate

  var fixedtables = function fixedtables(state) {
    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);
      /* literal/length table */

      var sym = 0;

      while (sym < 144) {
        state.lens[sym++] = 8;
      }

      while (sym < 256) {
        state.lens[sym++] = 9;
      }

      while (sym < 280) {
        state.lens[sym++] = 7;
      }

      while (sym < 288) {
        state.lens[sym++] = 8;
      }

      inftrees(LENS$1, state.lens, 0, 288, lenfix, 0, state.work, {
        bits: 9
      });
      /* distance table */

      sym = 0;

      while (sym < 32) {
        state.lens[sym++] = 5;
      }

      inftrees(DISTS$1, state.lens, 0, 32, distfix, 0, state.work, {
        bits: 5
      });
      /* do this just once */

      virgin = false;
    }

    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  /*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
   */


  var updatewindow = function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    /* if it hasn't been done already, allocate space for the window */

    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    /* copy state->wsize or less output bytes into the circular window */


    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;

      if (dist > copy) {
        dist = copy;
      } //zmemcpy(state->window + state->wnext, end - copy, dist);


      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;

      if (copy) {
        //zmemcpy(state->window, end - copy, copy);
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;

        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }

        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }

    return 0;
  };

  var inflate = function inflate(strm, flush) {
    var state;
    var input, output; // input/output buffers

    var next;
    /* next input INDEX */

    var put;
    /* next output INDEX */

    var have, left;
    /* available input and output */

    var hold;
    /* bit buffer */

    var bits;
    /* bits in bit buffer */

    var _in, _out;
    /* save starting available input and output */


    var copy;
    /* number of stored or match bytes to copy */

    var from;
    /* where to copy match bytes from */

    var from_source;
    var here = 0;
    /* current decoding table entry */

    var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
    //let last;                   /* parent table entry */

    var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

    var len;
    /* length to copy for repeats, bits to drop */

    var ret;
    /* return code */

    var hbuf = new Uint8Array(4);
    /* buffer for gzip header crc calculation */

    var opts;
    var n; // temporary variable for NEED_BITS

    var order =
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR$1;
    }

    state = strm.state;

    if (state.mode === TYPE$1) {
      state.mode = TYPEDO;
    }
    /* skip check */
    //--- LOAD() ---


    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits; //---

    _in = have;
    _out = left;
    ret = Z_OK$2;

    inf_leave: // goto emulation
    for (;;) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          } //=== NEEDBITS(16);


          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (state.wrap & 2 && hold === 0x8b1f) {
            /* gzip header */
            state.check = 0
            /*crc32(0L, Z_NULL, 0)*/
            ; //=== CRC2(state.check, hold);

            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0); //===//
            //=== INITBITS();

            hold = 0;
            bits = 0; //===//

            state.mode = FLAGS;
            break;
          }

          state.flags = 0;
          /* expect zlib header */

          if (state.head) {
            state.head.done = false;
          }

          if (!(state.wrap & 1) ||
          /* check if zlib header allowed */
          (((hold & 0xff) <<
          /*BITS(8)*/
          8) + (hold >> 8)) % 31) {
            strm.msg = 'incorrect header check';
            state.mode = BAD$1;
            break;
          }

          if ((hold & 0x0f) !==
          /*BITS(4)*/
          Z_DEFLATED$2) {
            strm.msg = 'unknown compression method';
            state.mode = BAD$1;
            break;
          } //--- DROPBITS(4) ---//


          hold >>>= 4;
          bits -= 4; //---//

          len = (hold & 0x0f) +
          /*BITS(4)*/
          8;

          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = 'invalid window size';
            state.mode = BAD$1;
            break;
          } // !!! pako patch. Force use `options.windowBits` if passed.
          // Required to always use max window size by default.


          state.dmax = 1 << state.wbits; //state.dmax = 1 << len;
          //Tracev((stderr, "inflate:   zlib header ok\n"));

          strm.adler = state.check = 1
          /*adler32(0L, Z_NULL, 0)*/
          ;
          state.mode = hold & 0x200 ? DICTID : TYPE$1; //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          break;

        case FLAGS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.flags = hold;

          if ((state.flags & 0xff) !== Z_DEFLATED$2) {
            strm.msg = 'unknown compression method';
            state.mode = BAD$1;
            break;
          }

          if (state.flags & 0xe000) {
            strm.msg = 'unknown header flags set';
            state.mode = BAD$1;
            break;
          }

          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//

          state.mode = TIME;

        /* falls through */

        case TIME:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (state.head) {
            state.head.time = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC4(state.check, hold)
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            hbuf[2] = hold >>> 16 & 0xff;
            hbuf[3] = hold >>> 24 & 0xff;
            state.check = crc32_1(state.check, hbuf, 4, 0); //===
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//

          state.mode = OS;

        /* falls through */

        case OS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (state.head) {
            state.head.xflags = hold & 0xff;
            state.head.os = hold >> 8;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//

          state.mode = EXLEN;

        /* falls through */

        case EXLEN:
          if (state.flags & 0x0400) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            } //===//


            state.length = hold;

            if (state.head) {
              state.head.extra_len = hold;
            }

            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0); //===//
            } //=== INITBITS();


            hold = 0;
            bits = 0; //===//
          } else if (state.head) {
            state.head.extra = null
            /*Z_NULL*/
            ;
          }

          state.mode = EXTRA;

        /* falls through */

        case EXTRA:
          if (state.flags & 0x0400) {
            copy = state.length;

            if (copy > have) {
              copy = have;
            }

            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;

                if (!state.head.extra) {
                  // Use untyped array for more convenient processing later
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }

                state.head.extra.set(input.subarray(next, // extra field is limited to 65536 bytes
                // - no need for additional size check
                next + copy),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len); //zmemcpy(state.head.extra + len, next,
                //        len + copy > state.head.extra_max ?
                //        state.head.extra_max - len : copy);
              }

              if (state.flags & 0x0200) {
                state.check = crc32_1(state.check, input, copy, next);
              }

              have -= copy;
              next += copy;
              state.length -= copy;
            }

            if (state.length) {
              break inf_leave;
            }
          }

          state.length = 0;
          state.mode = NAME;

        /* falls through */

        case NAME:
          if (state.flags & 0x0800) {
            if (have === 0) {
              break inf_leave;
            }

            copy = 0;

            do {
              // TODO: 2 or 1 bytes?
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */

              if (state.head && len && state.length < 65536
              /*state.head.name_max*/
              ) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;

            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }

          state.length = 0;
          state.mode = COMMENT;

        /* falls through */

        case COMMENT:
          if (state.flags & 0x1000) {
            if (have === 0) {
              break inf_leave;
            }

            copy = 0;

            do {
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */

              if (state.head && len && state.length < 65536
              /*state.head.comm_max*/
              ) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;

            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }

          state.mode = HCRC;

        /* falls through */

        case HCRC:
          if (state.flags & 0x0200) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            } //===//


            if (hold !== (state.check & 0xffff)) {
              strm.msg = 'header crc mismatch';
              state.mode = BAD$1;
              break;
            } //=== INITBITS();


            hold = 0;
            bits = 0; //===//
          }

          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }

          strm.adler = state.check = 0;
          state.mode = TYPE$1;
          break;

        case DICTID:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          strm.adler = state.check = zswap32(hold); //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = DICT;

        /* falls through */

        case DICT:
          if (state.havedict === 0) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits; //---

            return Z_NEED_DICT;
          }

          strm.adler = state.check = 1
          /*adler32(0L, Z_NULL, 0)*/
          ;
          state.mode = TYPE$1;

        /* falls through */

        case TYPE$1:
          if (flush === Z_BLOCK$1 || flush === Z_TREES) {
            break inf_leave;
          }

        /* falls through */

        case TYPEDO:
          if (state.last) {
            //--- BYTEBITS() ---//
            hold >>>= bits & 7;
            bits -= bits & 7; //---//

            state.mode = CHECK;
            break;
          } //=== NEEDBITS(3); */


          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.last = hold & 0x01
          /*BITS(1)*/
          ; //--- DROPBITS(1) ---//

          hold >>>= 1;
          bits -= 1; //---//

          switch (hold & 0x03) {
            /*BITS(2)*/
            case 0:
              /* stored block */
              //Tracev((stderr, "inflate:     stored block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = STORED;
              break;

            case 1:
              /* fixed block */
              fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
              //        state.last ? " (last)" : ""));

              state.mode = LEN_;
              /* decode codes */

              if (flush === Z_TREES) {
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2; //---//

                break inf_leave;
              }

              break;

            case 2:
              /* dynamic block */
              //Tracev((stderr, "inflate:     dynamic codes block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = TABLE;
              break;

            case 3:
              strm.msg = 'invalid block type';
              state.mode = BAD$1;
          } //--- DROPBITS(2) ---//


          hold >>>= 2;
          bits -= 2; //---//

          break;

        case STORED:
          //--- BYTEBITS() ---// /* go to byte boundary */
          hold >>>= bits & 7;
          bits -= bits & 7; //---//
          //=== NEEDBITS(32); */

          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
            strm.msg = 'invalid stored block lengths';
            state.mode = BAD$1;
            break;
          }

          state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
          //        state.length));
          //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = COPY_;

          if (flush === Z_TREES) {
            break inf_leave;
          }

        /* falls through */

        case COPY_:
          state.mode = COPY;

        /* falls through */

        case COPY:
          copy = state.length;

          if (copy) {
            if (copy > have) {
              copy = have;
            }

            if (copy > left) {
              copy = left;
            }

            if (copy === 0) {
              break inf_leave;
            } //--- zmemcpy(put, next, copy); ---


            output.set(input.subarray(next, next + copy), put); //---//

            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          } //Tracev((stderr, "inflate:       stored end\n"));


          state.mode = TYPE$1;
          break;

        case TABLE:
          //=== NEEDBITS(14); */
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.nlen = (hold & 0x1f) +
          /*BITS(5)*/
          257; //--- DROPBITS(5) ---//

          hold >>>= 5;
          bits -= 5; //---//

          state.ndist = (hold & 0x1f) +
          /*BITS(5)*/
          1; //--- DROPBITS(5) ---//

          hold >>>= 5;
          bits -= 5; //---//

          state.ncode = (hold & 0x0f) +
          /*BITS(4)*/
          4; //--- DROPBITS(4) ---//

          hold >>>= 4;
          bits -= 4; //---//
          //#ifndef PKZIP_BUG_WORKAROUND

          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = 'too many length or distance symbols';
            state.mode = BAD$1;
            break;
          } //#endif
          //Tracev((stderr, "inflate:       table sizes ok\n"));


          state.have = 0;
          state.mode = LENLENS;

        /* falls through */

        case LENLENS:
          while (state.have < state.ncode) {
            //=== NEEDBITS(3);
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            } //===//


            state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
            //--- DROPBITS(3) ---//

            hold >>>= 3;
            bits -= 3; //---//
          }

          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          } // We have separate tables & no pointers. 2 commented lines below not needed.
          //state.next = state.codes;
          //state.lencode = state.next;
          // Switch to use dynamic table


          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = {
            bits: state.lenbits
          };
          ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid code lengths set';
            state.mode = BAD$1;
            break;
          } //Tracev((stderr, "inflate:       code lengths ok\n"));


          state.have = 0;
          state.mode = CODELENS;

        /* falls through */

        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;;) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              /*BITS(state.lenbits)*/

              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;

              if (here_bits <= bits) {
                break;
              } //--- PULLBYTE() ---//


              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8; //---//
            }

            if (here_val < 16) {
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits; //---//

              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                //=== NEEDBITS(here.bits + 2);
                n = here_bits + 2;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//
                //--- DROPBITS(here.bits) ---//


                hold >>>= here_bits;
                bits -= here_bits; //---//

                if (state.have === 0) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD$1;
                  break;
                }

                len = state.lens[state.have - 1];
                copy = 3 + (hold & 0x03); //BITS(2);
                //--- DROPBITS(2) ---//

                hold >>>= 2;
                bits -= 2; //---//
              } else if (here_val === 17) {
                //=== NEEDBITS(here.bits + 3);
                n = here_bits + 3;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//
                //--- DROPBITS(here.bits) ---//


                hold >>>= here_bits;
                bits -= here_bits; //---//

                len = 0;
                copy = 3 + (hold & 0x07); //BITS(3);
                //--- DROPBITS(3) ---//

                hold >>>= 3;
                bits -= 3; //---//
              } else {
                //=== NEEDBITS(here.bits + 7);
                n = here_bits + 7;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//
                //--- DROPBITS(here.bits) ---//


                hold >>>= here_bits;
                bits -= here_bits; //---//

                len = 0;
                copy = 11 + (hold & 0x7f); //BITS(7);
                //--- DROPBITS(7) ---//

                hold >>>= 7;
                bits -= 7; //---//
              }

              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD$1;
                break;
              }

              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          /* handle error breaks in while */


          if (state.mode === BAD$1) {
            break;
          }
          /* check for end-of-block code (better have one) */


          if (state.lens[256] === 0) {
            strm.msg = 'invalid code -- missing end-of-block';
            state.mode = BAD$1;
            break;
          }
          /* build code tables -- note: do not change the lenbits or distbits
             values here (9 and 6) without reading the comments in inftrees.h
             concerning the ENOUGH constants, which depend on those values */


          state.lenbits = 9;
          opts = {
            bits: state.lenbits
          };
          ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;

          state.lenbits = opts.bits; // state.lencode = state.next;

          if (ret) {
            strm.msg = 'invalid literal/lengths set';
            state.mode = BAD$1;
            break;
          }

          state.distbits = 6; //state.distcode.copy(state.codes);
          // Switch to use dynamic table

          state.distcode = state.distdyn;
          opts = {
            bits: state.distbits
          };
          ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;

          state.distbits = opts.bits; // state.distcode = state.next;

          if (ret) {
            strm.msg = 'invalid distances set';
            state.mode = BAD$1;
            break;
          } //Tracev((stderr, 'inflate:       codes ok\n'));


          state.mode = LEN_;

          if (flush === Z_TREES) {
            break inf_leave;
          }

        /* falls through */

        case LEN_:
          state.mode = LEN;

        /* falls through */

        case LEN:
          if (have >= 6 && left >= 258) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits; //---

            inffast(strm, _out); //--- LOAD() ---

            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits; //---

            if (state.mode === TYPE$1) {
              state.back = -1;
            }

            break;
          }

          state.back = 0;

          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_op && (here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;

            for (;;) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
              /*BITS(last.bits + last.op)*/
              last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;

              if (last_bits + here_bits <= bits) {
                break;
              } //--- PULLBYTE() ---//


              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8; //---//
            } //--- DROPBITS(last.bits) ---//


            hold >>>= last_bits;
            bits -= last_bits; //---//

            state.back += last_bits;
          } //--- DROPBITS(here.bits) ---//


          hold >>>= here_bits;
          bits -= here_bits; //---//

          state.back += here_bits;
          state.length = here_val;

          if (here_op === 0) {
            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'\n" :
            //        "inflate:         literal 0x%02x\n", here.val));
            state.mode = LIT;
            break;
          }

          if (here_op & 32) {
            //Tracevv((stderr, "inflate:         end of block\n"));
            state.back = -1;
            state.mode = TYPE$1;
            break;
          }

          if (here_op & 64) {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD$1;
            break;
          }

          state.extra = here_op & 15;
          state.mode = LENEXT;

        /* falls through */

        case LENEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;

            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            } //===//


            state.length += hold & (1 << state.extra) - 1
            /*BITS(state.extra)*/
            ; //--- DROPBITS(state.extra) ---//

            hold >>>= state.extra;
            bits -= state.extra; //---//

            state.back += state.extra;
          } //Tracevv((stderr, "inflate:         length %u\n", state.length));


          state.was = state.length;
          state.mode = DIST;

        /* falls through */

        case DIST:
          for (;;) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            /*BITS(state.distbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if ((here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;

            for (;;) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
              /*BITS(last.bits + last.op)*/
              last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;

              if (last_bits + here_bits <= bits) {
                break;
              } //--- PULLBYTE() ---//


              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8; //---//
            } //--- DROPBITS(last.bits) ---//


            hold >>>= last_bits;
            bits -= last_bits; //---//

            state.back += last_bits;
          } //--- DROPBITS(here.bits) ---//


          hold >>>= here_bits;
          bits -= here_bits; //---//

          state.back += here_bits;

          if (here_op & 64) {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break;
          }

          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;

        /* falls through */

        case DISTEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;

            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            } //===//


            state.offset += hold & (1 << state.extra) - 1
            /*BITS(state.extra)*/
            ; //--- DROPBITS(state.extra) ---//

            hold >>>= state.extra;
            bits -= state.extra; //---//

            state.back += state.extra;
          } //#ifdef INFLATE_STRICT


          if (state.offset > state.dmax) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD$1;
            break;
          } //#endif
          //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


          state.mode = MATCH;

        /* falls through */

        case MATCH:
          if (left === 0) {
            break inf_leave;
          }

          copy = _out - left;

          if (state.offset > copy) {
            /* copy from window */
            copy = state.offset - copy;

            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD$1;
                break;
              } // (!) This block is disabled in zlib defaults,
              // don't enable it for binary compatibility
              //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
              //          Trace((stderr, "inflate.c too far\n"));
              //          copy -= state.whave;
              //          if (copy > state.length) { copy = state.length; }
              //          if (copy > left) { copy = left; }
              //          left -= copy;
              //          state.length -= copy;
              //          do {
              //            output[put++] = 0;
              //          } while (--copy);
              //          if (state.length === 0) { state.mode = LEN; }
              //          break;
              //#endif

            }

            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }

            if (copy > state.length) {
              copy = state.length;
            }

            from_source = state.window;
          } else {
            /* copy from output */
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }

          if (copy > left) {
            copy = left;
          }

          left -= copy;
          state.length -= copy;

          do {
            output[put++] = from_source[from++];
          } while (--copy);

          if (state.length === 0) {
            state.mode = LEN;
          }

          break;

        case LIT:
          if (left === 0) {
            break inf_leave;
          }

          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;

        case CHECK:
          if (state.wrap) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }

              have--; // Use '|' instead of '+' to make sure that result is signed

              hold |= input[next++] << bits;
              bits += 8;
            } //===//


            _out -= left;
            strm.total_out += _out;
            state.total += _out;

            if (_out) {
              strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }

            _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = 'incorrect data check';
              state.mode = BAD$1;
              break;
            } //=== INITBITS();


            hold = 0;
            bits = 0; //===//
            //Tracev((stderr, "inflate:   check matches trailer\n"));
          }

          state.mode = LENGTH;

        /* falls through */

        case LENGTH:
          if (state.wrap && state.flags) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            } //===//


            if (hold !== (state.total & 0xffffffff)) {
              strm.msg = 'incorrect length check';
              state.mode = BAD$1;
              break;
            } //=== INITBITS();


            hold = 0;
            bits = 0; //===//
            //Tracev((stderr, "inflate:   length matches trailer\n"));
          }

          state.mode = DONE;

        /* falls through */

        case DONE:
          ret = Z_STREAM_END$2;
          break inf_leave;

        case BAD$1:
          ret = Z_DATA_ERROR$1;
          break inf_leave;

        case MEM:
          return Z_MEM_ERROR;

        case SYNC:
        /* falls through */

        default:
          return Z_STREAM_ERROR$1;
      }
    } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
    //--- RESTORE() ---


    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits; //---

    if (state.wsize || _out !== strm.avail_out && state.mode < BAD$1 && (state.mode < CHECK || flush !== Z_FINISH$2)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }

    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;

    if (state.wrap && _out) {
      strm.adler = state.check =
      /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
    }

    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$1 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

    if ((_in === 0 && _out === 0 || flush === Z_FINISH$2) && ret === Z_OK$2) {
      ret = Z_BUF_ERROR$1;
    }

    return ret;
  };

  var inflateEnd = function inflateEnd(strm) {
    if (!strm || !strm.state
    /*|| strm->zfree == (free_func)0*/
    ) {
        return Z_STREAM_ERROR$1;
      }

    var state = strm.state;

    if (state.window) {
      state.window = null;
    }

    strm.state = null;
    return Z_OK$2;
  };

  var inflateGetHeader = function inflateGetHeader(strm, head) {
    /* check state */
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR$1;
    }

    var state = strm.state;

    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR$1;
    }
    /* save header structure */


    state.head = head;
    head.done = false;
    return Z_OK$2;
  };

  var inflateSetDictionary = function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    /* check state */

    if (!strm
    /* == Z_NULL */
    || !strm.state
    /* == Z_NULL */
    ) {
        return Z_STREAM_ERROR$1;
      }

    state = strm.state;

    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }
    /* check for correct dictionary identifier */


    if (state.mode === DICT) {
      dictid = 1;
      /* adler32(0, null, 0)*/

      /* dictid = adler32(dictid, dictionary, dictLength); */

      dictid = adler32_1(dictid, dictionary, dictLength, 0);

      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    /* copy dictionary to window using updatewindow(), which will amend the
     existing dictionary if appropriate */


    ret = updatewindow(strm, dictionary, dictLength, dictLength);

    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }

    state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

    return Z_OK$2;
  };

  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2 = inflate;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = 'pako inflate (from Nodeca project)';
  /* Not implemented
  module.exports.inflateCopy = inflateCopy;
  module.exports.inflateGetDictionary = inflateGetDictionary;
  module.exports.inflateMark = inflateMark;
  module.exports.inflatePrime = inflatePrime;
  module.exports.inflateSync = inflateSync;
  module.exports.inflateSyncPoint = inflateSyncPoint;
  module.exports.inflateUndermine = inflateUndermine;
  */

  var inflate_1 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo: inflateInfo
  };

  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function GZheader() {
    /* true if compressed data believed to be text */
    this.text = 0;
    /* modification time */

    this.time = 0;
    /* extra flags (not used when writing a gzip file) */

    this.xflags = 0;
    /* operating system */

    this.os = 0;
    /* pointer to extra field or Z_NULL if none */

    this.extra = null;
    /* extra field length (valid if extra != Z_NULL) */

    this.extra_len = 0; // Actually, we don't need it in JS,
    // but leave for few code modifications
    //
    // Setup limits is not necessary because in js we should not preallocate memory
    // for inflate use constant limit in 65536 bytes
    //

    /* space at extra (only when reading header) */
    // this.extra_max  = 0;

    /* pointer to zero-terminated file name or Z_NULL */

    this.name = '';
    /* space at name (only when reading header) */
    // this.name_max   = 0;

    /* pointer to zero-terminated comment or Z_NULL */

    this.comment = '';
    /* space at comment (only when reading header) */
    // this.comm_max   = 0;

    /* true if there was or will be a header crc */

    this.hcrc = 0;
    /* true when done reading gzip header (not used when writing a gzip file) */

    this.done = false;
  }

  var gzheader = GZheader;

  var toString$1 = Object.prototype.toString;
  /* Public constants ==========================================================*/

  /* ===========================================================================*/

  var Z_NO_FLUSH$2 = constants.Z_NO_FLUSH,
      Z_FINISH$3 = constants.Z_FINISH,
      Z_OK$3 = constants.Z_OK,
      Z_STREAM_END$3 = constants.Z_STREAM_END,
      Z_NEED_DICT$1 = constants.Z_NEED_DICT,
      Z_STREAM_ERROR$2 = constants.Z_STREAM_ERROR,
      Z_DATA_ERROR$2 = constants.Z_DATA_ERROR,
      Z_MEM_ERROR$1 = constants.Z_MEM_ERROR;
  /* ===========================================================================*/

  /**
   * class Inflate
   *
   * Generic JS-style wrapper for zlib calls. If you don't need
   * streaming behaviour - use more simple functions: [[inflate]]
   * and [[inflateRaw]].
   **/

  /* internal
   * inflate.chunks -> Array
   *
   * Chunks of output data, if [[Inflate#onData]] not overridden.
   **/

  /**
   * Inflate.result -> Uint8Array|String
   *
   * Uncompressed result, generated by default [[Inflate#onData]]
   * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
   * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
   **/

  /**
   * Inflate.err -> Number
   *
   * Error code after inflate finished. 0 (Z_OK) on success.
   * Should be checked if broken data possible.
   **/

  /**
   * Inflate.msg -> String
   *
   * Error message, if [[Inflate.err]] != 0
   **/

  /**
   * new Inflate(options)
   * - options (Object): zlib inflate options.
   *
   * Creates new inflator instance with specified params. Throws exception
   * on bad params. Supported options:
   *
   * - `windowBits`
   * - `dictionary`
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Additional options, for internal needs:
   *
   * - `chunkSize` - size of generated data chunks (16K by default)
   * - `raw` (Boolean) - do raw inflate
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   * By default, when no options set, autodetect deflate/gzip data format via
   * wrapper header.
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
   * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
   *
   * const inflate = new pako.Inflate({ level: 3});
   *
   * inflate.push(chunk1, false);
   * inflate.push(chunk2, true);  // true -> last chunk
   *
   * if (inflate.err) { throw new Error(inflate.err); }
   *
   * console.log(inflate.result);
   * ```
   **/

  function Inflate(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ''
    }, options || {});
    var opt = this.options; // Force window size for `raw` data, if not set directly,
    // because we have no header for autodetect.

    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;

      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    } // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate


    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    } // Gzip header has no info about windows size, we can do autodetect only
    // for deflate. So, if window size not set, force it to max when gzip possible


    if (opt.windowBits > 15 && opt.windowBits < 48) {
      // bit 3 (16) -> gzipped data
      // bit 4 (32) -> autodetect gzip/deflate
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }

    this.err = 0; // error code, if happens (0 = Z_OK)

    this.msg = ''; // error message

    this.ended = false; // used to avoid multiple onEnd() calls

    this.chunks = []; // chunks of compressed data

    this.strm = new zstream();
    this.strm.avail_out = 0;
    var status = inflate_1.inflateInit2(this.strm, opt.windowBits);

    if (status !== Z_OK$3) {
      throw new Error(messages[status]);
    }

    this.header = new gzheader();
    inflate_1.inflateGetHeader(this.strm, this.header); // Setup dictionary

    if (opt.dictionary) {
      // Convert data if needed
      if (typeof opt.dictionary === 'string') {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }

      if (opt.raw) {
        //In raw mode we need to set the dictionary early
        status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);

        if (status !== Z_OK$3) {
          throw new Error(messages[status]);
        }
      }
    }
  }
  /**
   * Inflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer): input data
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
   *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
   *   `true` means Z_FINISH.
   *
   * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
   * new output chunks. Returns `true` on success. If end of stream detected,
   * [[Inflate#onEnd]] will be called.
   *
   * `flush_mode` is not needed for normal operation, because end of stream
   * detected automatically. You may try to use it for advanced things, but
   * this functionality was not tested.
   *
   * On fail call [[Inflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/


  Inflate.prototype.push = function (data, flush_mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;

    var status, _flush_mode, last_avail_out;

    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;else _flush_mode = flush_mode === true ? Z_FINISH$3 : Z_NO_FLUSH$2; // Convert data if needed

    if (toString$1.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    for (;;) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      status = inflate_1.inflate(strm, _flush_mode);

      if (status === Z_NEED_DICT$1 && dictionary) {
        status = inflate_1.inflateSetDictionary(strm, dictionary);

        if (status === Z_OK$3) {
          status = inflate_1.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR$2) {
          // Replace code with more verbose
          status = Z_NEED_DICT$1;
        }
      } // Skip snyc markers if more data follows and not raw mode


      while (strm.avail_in > 0 && status === Z_STREAM_END$3 && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        inflate_1.inflateReset(strm);
        status = inflate_1.inflate(strm, _flush_mode);
      }

      switch (status) {
        case Z_STREAM_ERROR$2:
        case Z_DATA_ERROR$2:
        case Z_NEED_DICT$1:
        case Z_MEM_ERROR$1:
          this.onEnd(status);
          this.ended = true;
          return false;
      } // Remember real `avail_out` value, because we may patch out buffer content
      // to align utf8 strings boundaries.


      last_avail_out = strm.avail_out;

      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END$3) {
          if (this.options.to === 'string') {
            var next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            var tail = strm.next_out - next_out_utf8;
            var utf8str = strings.buf2string(strm.output, next_out_utf8); // move tail & realign counters

            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      } // Must repeat iteration if out buffer is full


      if (status === Z_OK$3 && last_avail_out === 0) continue; // Finalize if end of stream reached.

      if (status === Z_STREAM_END$3) {
        status = inflate_1.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }

      if (strm.avail_in === 0) break;
    }

    return true;
  };
  /**
   * Inflate#onData(chunk) -> Void
   * - chunk (Uint8Array|String): output data. When string output requested,
   *   each chunk will be string.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/


  Inflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };
  /**
   * Inflate#onEnd(status) -> Void
   * - status (Number): inflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called either after you tell inflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/


  Inflate.prototype.onEnd = function (status) {
    // On success - join
    if (status === Z_OK$3) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }

    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  /**
   * inflate(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Decompress `data` with inflate/ungzip and `options`. Autodetect
   * format via wrapper header by default. That's why we don't provide
   * separate `ungzip` method.
   *
   * Supported options are:
   *
   * - windowBits
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako');
   * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
   * let output;
   *
   * try {
   *   output = pako.inflate(input);
   * } catch (err)
   *   console.log(err);
   * }
   * ```
   **/


  function inflate$1(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input); // That will never happens, if you don't cheat with options :)

    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
  }
  /**
   * inflateRaw(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * The same as [[inflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/


  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
  }
  /**
   * ungzip(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Just shortcut to [[inflate]], because it autodetects format
   * by header.content. Done for convenience.
   **/


  var Inflate_1 = Inflate;
  var inflate_2$1 = inflate$1;
  var inflateRaw_1 = inflateRaw;
  var ungzip = inflate$1;
  var constants$2 = constants;
  var inflate_1$1 = {
    Inflate: Inflate_1,
    inflate: inflate_2$1,
    inflateRaw: inflateRaw_1,
    ungzip: ungzip,
    constants: constants$2
  };

  var Deflate$1 = deflate_1$1.Deflate,
      deflate$2 = deflate_1$1.deflate,
      deflateRaw$1 = deflate_1$1.deflateRaw,
      gzip$1 = deflate_1$1.gzip;
  var Inflate$1 = inflate_1$1.Inflate,
      inflate$2 = inflate_1$1.inflate,
      inflateRaw$1 = inflate_1$1.inflateRaw,
      ungzip$1 = inflate_1$1.ungzip;
  var Deflate_1$1 = Deflate$1;
  var deflate_1$2 = deflate$2;
  var deflateRaw_1$1 = deflateRaw$1;
  var gzip_1$1 = gzip$1;
  var Inflate_1$1 = Inflate$1;
  var inflate_1$2 = inflate$2;
  var inflateRaw_1$1 = inflateRaw$1;
  var ungzip_1 = ungzip$1;
  var constants_1 = constants;
  var pako = {
    Deflate: Deflate_1$1,
    deflate: deflate_1$2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    Inflate: Inflate_1$1,
    inflate: inflate_1$2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip_1,
    constants: constants_1
  };

  exports.Deflate = Deflate_1$1;
  exports.Inflate = Inflate_1$1;
  exports.constants = constants_1;
  exports.default = pako;
  exports.deflate = deflate_1$2;
  exports.deflateRaw = deflateRaw_1$1;
  exports.gzip = gzip_1$1;
  exports.inflate = inflate_1$2;
  exports.inflateRaw = inflateRaw_1$1;
  exports.ungzip = ungzip_1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
};
BundleModuleCode['plugins/image/UTIF']=function (module,exports){




;(function(){
var UTIF = {};

// Make available for import by `require()`
if (typeof module == "object") {module.exports = UTIF;}
else {self.UTIF = UTIF;}

var pako = (typeof require === "function") ? Require("plugins/image/pako") : self.pako;

function log() { if (typeof process=="undefined" || process.env.NODE_ENV=="development") console.log.apply(console, arguments);  }

(function(UTIF, pako){
	
// Following lines add a JPEG decoder  to UTIF.JpegDecoder
(function(){"use strict";var W=function a1(){function W(p){this.message="JPEG error: "+p}W.prototype=new Error;W.prototype.name="JpegError";W.constructor=W;return W}(),ak=function ag(){var p=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),t=4017,ac=799,ah=3406,ao=2276,ar=1567,ai=3784,s=5793,ad=2896;function ak(Q){if(Q==null)Q={};if(Q.w==null)Q.w=-1;this.V=Q.n;this.N=Q.w}function a5(Q,h){var f=0,G=[],n,E,a=16,F;while(a>0&&!Q[a-1]){a--}G.push({children:[],index:0});var C=G[0];for(n=0;n<a;n++)
{for(E=0;E<Q[n];E++){C=G.pop();C.children[C.index]=h[f];while(C.index>0){C=G.pop()}C.index++;G.push(C);while(G.length<=n){G.push(F={children:[],index:0});C.children[C.index]=F.children;C=F}f++}if(n+1<a){G.push(F={children:[],index:0});C.children[C.index]=F.children;C=F}}return G[0].children}function a2(Q,h,f){return 64*((Q.P+1)*h+f)}function a7(Q,h,f,G,n,E,a,C,F,d){if(d==null)d=!1;var T=f.m,U=f.Z,z=h,J=0,V=0,r=0,D=0,a8,q=0,X,O,_,N,e,K,x=0,k,g,R,c;function Y(){if(V>0){V--;return J>>V&1}J=Q[h++];if(J===255){var I=Q[h++];if(I){if(I===220&&d){h+=2;var l=Z(Q,h);h+=2;if(l>0&&l!==f.s){throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data",l)}}else if(I===217){if(d){var M=q*8;
if(M>0&&M<f.s/10){throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, "+"possibly caused by incorrect `scanLines` parameter",M)}}throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data")}throw new W("unexpected marker")}}V=7;return J>>>7}function u(I){var l=I;while(!0){l=l[Y()];switch(typeof l){case"number":return l;case"object":continue}throw new W("invalid huffman sequence")}}function m(I){var e=0;while(I>0){e=e<<1|Y();I--}return e}function j(I){if(I===1){return Y()===1?1:-1}var e=m(I);if(e>=1<<I-1){return e}return e+(-1<<I)+1}function v(X,I){var l=u(X.J),M=l===0?0:j(l),N=1;
X.D[I]=X.Q+=M;while(N<64){var S=u(X.i),i=S&15,A=S>>4;if(i===0){if(A<15){break}N+=16;continue}N+=A;var o=p[N];X.D[I+o]=j(i);N++}}function $(X,I){var l=u(X.J),M=l===0?0:j(l)<<F;X.D[I]=X.Q+=M}function b(X,I){X.D[I]|=Y()<<F}function P(X,I){if(r>0){r--;return}var N=E,l=a;while(N<=l){var M=u(X.i),S=M&15,i=M>>4;if(S===0){if(i<15){r=m(i)+(1<<i)-1;break}N+=16;continue}N+=i;var A=p[N];X.D[I+A]=j(S)*(1<<F);N++}}function a4(X,I){var N=E,l=a,M=0,S,i;while(N<=l){var A=I+p[N],o=X.D[A]<0?-1:1;switch(D){case 0:i=u(X.i);S=i&15;M=i>>4;if(S===0){if(M<15){r=m(M)+(1<<M);D=4}else{M=16;D=1}}else{if(S!==1){throw new W("invalid ACn encoding")}a8=j(S);D=M?2:3}continue;case 1:case 2:if(X.D[A]){X.D[A]+=o*(Y()<<F)}else{M--;if(M===0){D=D===2?3:0}}break;case 3:if(X.D[A]){X.D[A]+=o*(Y()<<F)}else{X.D[A]=a8<<F;
D=0}break;case 4:if(X.D[A]){X.D[A]+=o*(Y()<<F)}break}N++}if(D===4){r--;if(r===0){D=0}}}function H(X,I,x,l,M){var S=x/T|0,i=x%T;q=S*X.A+l;var A=i*X.h+M,o=a2(X,q,A);I(X,o)}function w(X,I,x){q=x/X.P|0;var l=x%X.P,M=a2(X,q,l);I(X,M)}var y=G.length;if(U){if(E===0){K=C===0?$:b}else{K=C===0?P:a4}}else{K=v}if(y===1){g=G[0].P*G[0].c}else{g=T*f.R}while(x<=g){var L=n?Math.min(g-x,n):g;if(L>0){for(O=0;O<y;O++){G[O].Q=0}r=0;if(y===1){X=G[0];for(e=0;e<L;e++){w(X,K,x);x++}}else{for(e=0;e<L;
e++){for(O=0;O<y;O++){X=G[O];R=X.h;c=X.A;for(_=0;_<c;_++){for(N=0;N<R;N++){H(X,K,x,_,N)}}}x++}}}V=0;k=an(Q,h);if(!k){break}if(k.u){var a6=L>0?"unexpected":"excessive";h=k.offset}if(k.M>=65488&&k.M<=65495){h+=2}else{break}}return h-z}function al(Q,h,f){var G=Q.$,n=Q.D,E,a,C,F,d,T,U,z,J,V,Y,u,m,j,v,$,b;if(!G){throw new W("missing required Quantization Table.")}for(var r=0;r<64;r+=8){J=n[h+r];V=n[h+r+1];Y=n[h+r+2];u=n[h+r+3];m=n[h+r+4];j=n[h+r+5];v=n[h+r+6];$=n[h+r+7];J*=G[r];if((V|Y|u|m|j|v|$)===0){b=s*J+512>>10;f[r]=b;f[r+1]=b;f[r+2]=b;f[r+3]=b;f[r+4]=b;f[r+5]=b;f[r+6]=b;f[r+7]=b;continue}V*=G[r+1];Y*=G[r+2];u*=G[r+3];m*=G[r+4];j*=G[r+5];v*=G[r+6];$*=G[r+7];E=s*J+128>>8;a=s*m+128>>8;C=Y;F=v;d=ad*(V-$)+128>>8;z=ad*(V+$)+128>>8;
T=u<<4;U=j<<4;E=E+a+1>>1;a=E-a;b=C*ai+F*ar+128>>8;C=C*ar-F*ai+128>>8;F=b;d=d+U+1>>1;U=d-U;z=z+T+1>>1;T=z-T;E=E+F+1>>1;F=E-F;a=a+C+1>>1;C=a-C;b=d*ao+z*ah+2048>>12;d=d*ah-z*ao+2048>>12;z=b;b=T*ac+U*t+2048>>12;T=T*t-U*ac+2048>>12;U=b;f[r]=E+z;f[r+7]=E-z;f[r+1]=a+U;f[r+6]=a-U;f[r+2]=C+T;f[r+5]=C-T;f[r+3]=F+d;f[r+4]=F-d}for(var P=0;P<8;++P){J=f[P];V=f[P+8];Y=f[P+16];u=f[P+24];m=f[P+32];j=f[P+40];v=f[P+48];$=f[P+56];if((V|Y|u|m|j|v|$)===0){b=s*J+8192>>14;if(b<-2040){b=0}else if(b>=2024){b=255}else{b=b+2056>>4}n[h+P]=b;n[h+P+8]=b;n[h+P+16]=b;n[h+P+24]=b;n[h+P+32]=b;n[h+P+40]=b;n[h+P+48]=b;n[h+P+56]=b;continue}E=s*J+2048>>12;a=s*m+2048>>12;C=Y;F=v;d=ad*(V-$)+2048>>12;z=ad*(V+$)+2048>>12;T=u;U=j;E=(E+a+1>>1)+4112;a=E-a;b=C*ai+F*ar+2048>>12;C=C*ar-F*ai+2048>>12;F=b;d=d+U+1>>1;U=d-U;z=z+T+1>>1;T=z-T;E=E+F+1>>1;F=E-F;a=a+C+1>>1;C=a-C;b=d*ao+z*ah+2048>>12;d=d*ah-z*ao+2048>>12;z=b;
b=T*ac+U*t+2048>>12;T=T*t-U*ac+2048>>12;U=b;J=E+z;$=E-z;V=a+U;v=a-U;Y=C+T;j=C-T;u=F+d;m=F-d;if(J<16){J=0}else if(J>=4080){J=255}else{J>>=4}if(V<16){V=0}else if(V>=4080){V=255}else{V>>=4}if(Y<16){Y=0}else if(Y>=4080){Y=255}else{Y>>=4}if(u<16){u=0}else if(u>=4080){u=255}else{u>>=4}if(m<16){m=0}else if(m>=4080){m=255}else{m>>=4}if(j<16){j=0}else if(j>=4080){j=255}else{j>>=4}if(v<16){v=0}else if(v>=4080){v=255}else{v>>=4}if($<16){$=0}else if($>=4080){$=255}else{$>>=4}n[h+P]=J;
n[h+P+8]=V;n[h+P+16]=Y;n[h+P+24]=u;n[h+P+32]=m;n[h+P+40]=j;n[h+P+48]=v;n[h+P+56]=$}}function a0(Q,h){var f=h.P,G=h.c,n=new Int16Array(64);for(var E=0;E<G;E++){for(var a=0;a<f;a++){var C=a2(h,E,a);al(h,C,n)}}return h.D}function an(Q,h,f){if(f==null)f=h;var G=Q.length-1,n=f<h?f:h;if(h>=G){return null}var E=Z(Q,h);if(E>=65472&&E<=65534){return{u:null,M:E,offset:h}}var a=Z(Q,n);while(!(a>=65472&&a<=65534)){if(++n>=G){return null}a=Z(Q,n)}return{u:E.toString(16),M:a,offset:n}}ak.prototype={parse(Q,h){if(h==null)h={};
var f=h.F,E=0,a=null,C=null,F,d,T=0;function G(){var o=Z(Q,E);E+=2;var B=E+o-2,V=an(Q,B,E);if(V&&V.u){B=V.offset}var ab=Q.subarray(E,B);E+=ab.length;return ab}function n(F){var o=Math.ceil(F.o/8/F.X),B=Math.ceil(F.s/8/F.B);for(var Y=0;Y<F.W.length;Y++){R=F.W[Y];var ab=Math.ceil(Math.ceil(F.o/8)*R.h/F.X),af=Math.ceil(Math.ceil(F.s/8)*R.A/F.B),ap=o*R.h,aq=B*R.A,ae=64*aq*(ap+1);R.D=new Int16Array(ae);R.P=ab;R.c=af}F.m=o;F.R=B}var U=[],z=[],J=[],V=Z(Q,E);E+=2;if(V!==65496){throw new W("SOI not found")}V=Z(Q,E);
E+=2;markerLoop:while(V!==65497){var Y,u,m;switch(V){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var j=G();if(V===65504){if(j[0]===74&&j[1]===70&&j[2]===73&&j[3]===70&&j[4]===0){a={version:{d:j[5],T:j[6]},K:j[7],j:j[8]<<8|j[9],H:j[10]<<8|j[11],S:j[12],I:j[13],C:j.subarray(14,14+3*j[12]*j[13])}}}if(V===65518){if(j[0]===65&&j[1]===100&&j[2]===111&&j[3]===98&&j[4]===101){C={version:j[5]<<8|j[6],k:j[7]<<8|j[8],q:j[9]<<8|j[10],a:j[11]}}}break;
case 65499:var v=Z(Q,E),b;E+=2;var $=v+E-2;while(E<$){var r=Q[E++],P=new Uint16Array(64);if(r>>4===0){for(u=0;u<64;u++){b=p[u];P[b]=Q[E++]}}else if(r>>4===1){for(u=0;u<64;u++){b=p[u];P[b]=Z(Q,E);E+=2}}else{throw new W("DQT - invalid table spec")}U[r&15]=P}break;case 65472:case 65473:case 65474:if(F){throw new W("Only single frame JPEGs supported")}E+=2;F={};F.G=V===65473;F.Z=V===65474;F.precision=Q[E++];var D=Z(Q,E),a4,q=0,H=0;E+=2;F.s=f||D;F.o=Z(Q,E);E+=2;F.W=[];F._={};var a8=Q[E++];for(Y=0;Y<a8;Y++){a4=Q[E];var w=Q[E+1]>>4,y=Q[E+1]&15;if(q<w){q=w}if(H<y){H=y}var X=Q[E+2];m=F.W.push({h:w,A:y,L:X,$:null});F._[a4]=m-1;E+=3}F.X=q;F.B=H;n(F);break;case 65476:var O=Z(Q,E);E+=2;
for(Y=2;Y<O;){var _=Q[E++],N=new Uint8Array(16),e=0;for(u=0;u<16;u++,E++){e+=N[u]=Q[E]}var K=new Uint8Array(e);for(u=0;u<e;u++,E++){K[u]=Q[E]}Y+=17+e;(_>>4===0?J:z)[_&15]=a5(N,K)}break;case 65501:E+=2;d=Z(Q,E);E+=2;break;case 65498:var x=++T===1&&!f,R;E+=2;var k=Q[E++],g=[];for(Y=0;Y<k;Y++){var c=Q[E++],L=F._[c];R=F.W[L];R.index=c;var a6=Q[E++];R.J=J[a6>>4];R.i=z[a6&15];g.push(R)}var I=Q[E++],l=Q[E++],M=Q[E++];try{var S=a7(Q,E,F,g,d,I,l,M>>4,M&15,x);E+=S}catch(ex){if(ex instanceof DNLMarkerError){return this.parse(Q,{F:ex.s})}else if(ex instanceof EOIMarkerError){break markerLoop}throw ex}break;case 65500:E+=4;break;case 65535:if(Q[E]!==255){E--}break;default:var i=an(Q,E-2,E-3);if(i&&i.u){E=i.offset;break}if(E>=Q.length-1){break markerLoop}throw new W("JpegImage.parse - unknown marker: "+V.toString(16))}V=Z(Q,E);E+=2}this.width=F.o;this.height=F.s;this.g=a;this.b=C;this.W=[];for(Y=0;Y<F.W.length;Y++){R=F.W[Y];
var A=U[R.L];if(A){R.$=A}this.W.push({index:R.index,e:a0(F,R),l:R.h/F.X,t:R.A/F.B,P:R.P,c:R.c})}this.p=this.W.length;return undefined},Y(Q,h,f){if(f==null)f=!1;var G=this.width/Q,n=this.height/h,E,a,C,F,d,T,U,z,J,V,Y=0,u,m=this.W.length,j=Q*h*m,v=new Uint8ClampedArray(j),$=new Uint32Array(Q),b=4294967288,r;for(U=0;U<m;U++){E=this.W[U];a=E.l*G;C=E.t*n;Y=U;u=E.e;F=E.P+1<<3;if(a!==r){for(d=0;d<Q;d++){z=0|d*a;$[d]=(z&b)<<3|z&7}r=a}for(T=0;T<h;T++){z=0|T*C;V=F*(z&b)|(z&7)<<3;for(d=0;d<Q;d++){v[Y]=u[V+$[d]];Y+=m}}}var P=this.V;if(!f&&m===4&&!P){P=new Int32Array([-256,255,-256,255,-256,255,-256,255])}if(P){for(U=0;U<j;){for(z=0,J=0;z<m;z++,U++,J+=2){v[U]=(v[U]*P[J]>>8)+P[J+1]}}}return v},get f(){if(this.b){return!!this.b.a}if(this.p===3){if(this.N===0){return!1}else if(this.W[0].index===82&&this.W[1].index===71&&this.W[2].index===66){return!1}return!0}if(this.N===1){return!0}return!1},z:function aj(Q){var h,f,G;
for(var n=0,E=Q.length;n<E;n+=3){h=Q[n];f=Q[n+1];G=Q[n+2];Q[n]=h-179.456+1.402*G;Q[n+1]=h+135.459-.344*f-.714*G;Q[n+2]=h-226.816+1.772*f}return Q},O:function aa(Q){var h,f,G,n,E=0;for(var a=0,C=Q.length;a<C;a+=4){h=Q[a];f=Q[a+1];G=Q[a+2];n=Q[a+3];Q[E++]=-122.67195406894+f*(-660635669420364e-19*f+.000437130475926232*G-54080610064599e-18*h+.00048449797120281*n-.154362151871126)+G*(-.000957964378445773*G+.000817076911346625*h-.00477271405408747*n+1.53380253221734)+h*(.000961250184130688*h-.00266257332283933*n+.48357088451265)+n*(-.000336197177618394*n+.484791561490776);
Q[E++]=107.268039397724+f*(219927104525741e-19*f-.000640992018297945*G+.000659397001245577*h+.000426105652938837*n-.176491792462875)+G*(-.000778269941513683*G+.00130872261408275*h+.000770482631801132*n-.151051492775562)+h*(.00126935368114843*h-.00265090189010898*n+.25802910206845)+n*(-.000318913117588328*n-.213742400323665);Q[E++]=-20.810012546947+f*(-.000570115196973677*f-263409051004589e-19*G+.0020741088115012*h-.00288260236853442*n+.814272968359295)+G*(-153496057440975e-19*G-.000132689043961446*h+.000560833691242812*n-.195152027534049)+h*(.00174418132927582*h-.00255243321439347*n+.116935020465145)+n*(-.000343531996510555*n+.24165260232407)}return Q.subarray(0,E)},r:function a3(Q){var h,f,G;
for(var n=0,E=Q.length;n<E;n+=4){h=Q[n];f=Q[n+1];G=Q[n+2];Q[n]=434.456-h-1.402*G;Q[n+1]=119.541-h+.344*f+.714*G;Q[n+2]=481.816-h-1.772*f}return Q},U:function as(Q){var h,f,G,n,E=0;for(var a=0,C=Q.length;a<C;a+=4){h=Q[a];f=Q[a+1];G=Q[a+2];n=Q[a+3];Q[E++]=255+h*(-6747147073602441e-20*h+.0008379262121013727*f+.0002894718188643294*G+.003264231057537806*n-1.1185611867203937)+f*(26374107616089404e-21*f-8626949158638572e-20*G-.0002748769067499491*n-.02155688794978967)+G*(-3878099212869363e-20*G-.0003267808279485286*n+.0686742238595345)-n*(.0003361971776183937*n+.7430659151342254);
Q[E++]=255+h*(.00013596372813588848*h+.000924537132573585*f+.00010567359618683593*G+.0004791864687436512*n-.3109689587515875)+f*(-.00023545346108370344*f+.0002702845253534714*G+.0020200308977307156*n-.7488052167015494)+G*(6834815998235662e-20*G+.00015168452363460973*n-.09751927774728933)-n*(.0003189131175883281*n+.7364883807733168);Q[E++]=255+h*(13598650411385308e-21*h+.00012423956175490851*f+.0004751985097583589*G-36729317476630424e-22*n-.05562186980264034)+f*(.00016141380598724676*f+.0009692239130725186*G+.0007782692450036253*n-.44015232367526463)+G*(5.068882914068769e-7*G+.0017778369011375071*n-.7591454649749609)-n*(.0003435319965105553*n+.7063770186160144)}return Q.subarray(0,E)},getData:function(Q){var h=Q.width,f=Q.height,G=Q.forceRGB,n=Q.isSourcePDF;
if(this.p>4){throw new W("Unsupported color mode")}var E=this.Y(h,f,n);if(this.p===1&&G){var a=E.length,C=new Uint8ClampedArray(a*3),F=0;for(var d=0;d<a;d++){var T=E[d];C[F++]=T;C[F++]=T;C[F++]=T}return C}else if(this.p===3&&this.f){return this.z(E)}else if(this.p===4){if(this.f){if(G){return this.O(E)}return this.r(E)}else if(G){return this.U(E)}}return E}};return ak}();function a9(p,t){return p[t]<<24>>24}function Z(p,t){return p[t]<<8|p[t+1]}function am(p,t){return(p[t]<<24|p[t+1]<<16|p[t+2]<<8|p[t+3])>>>0}UTIF.JpegDecoder=ak}());

//UTIF.JpegDecoder = PDFJS.JpegImage;


UTIF.encodeImage = function(rgba, w, h, metadata)
{
	var idf = { "t256":[w], "t257":[h], "t258":[8,8,8,8], "t259":[1], "t262":[2], "t273":[1000], // strips offset
				"t277":[4], "t278":[h], /* rows per strip */          "t279":[w*h*4], // strip byte counts
				"t282":[[72,1]], "t283":[[72,1]], "t284":[1], "t286":[[0,1]], "t287":[[0,1]], "t296":[1], "t305": ["Photopea (UTIF.js)"], "t338":[1]
		};
	if (metadata) for (var i in metadata) idf[i] = metadata[i];
	
	var prfx = new Uint8Array(UTIF.encode([idf]));
	var img = new Uint8Array(rgba);
	var data = new Uint8Array(1000+w*h*4);
	for(var i=0; i<prfx.length; i++) data[i] = prfx[i];
	for(var i=0; i<img .length; i++) data[1000+i] = img[i];
	return data.buffer;
}

UTIF.encode = function(ifds)
{
	var LE = false;
	var data = new Uint8Array(20000), offset = 4, bin = LE ? UTIF._binLE : UTIF._binBE;
	data[0]=data[1]=LE?73:77;  bin.writeUshort(data,2,42);

	var ifdo = 8;
	bin.writeUint(data, offset, ifdo);  offset+=4;
	for(var i=0; i<ifds.length; i++)
	{
		var noffs = UTIF._writeIFD(bin, UTIF._types.basic, data, ifdo, ifds[i]);
		ifdo = noffs[1];
		if(i<ifds.length-1) {
			if((ifdo&3)!=0) ifdo+=(4-(ifdo&3));  // make each IFD start at multiple of 4
			bin.writeUint(data, noffs[0], ifdo);
		}
	}
	return data.slice(0, ifdo).buffer;
}

UTIF.decode = function(buff, prm)
{
	if(prm==null) prm = {parseMN:true, debug:false};  // read MakerNote, debug
	var data = new Uint8Array(buff), offset = 0;

	var id = UTIF._binBE.readASCII(data, offset, 2);  offset+=2;
	var bin = id=="II" ? UTIF._binLE : UTIF._binBE;
	var num = bin.readUshort(data, offset);  offset+=2;

	var ifdo = bin.readUint(data, offset);  offset+=4;
	var ifds = [];
	while(true) {
		var cnt = bin.readUshort(data,ifdo), typ = bin.readUshort(data,ifdo+4);  if(cnt!=0) if(typ<1 || 13<typ) {  log("error in TIFF");  break  };
		UTIF._readIFD(bin, data, ifdo, ifds, 0, prm);
		
		ifdo = bin.readUint(data, ifdo+2+cnt*12);
		if(ifdo==0) break;
	}
	return ifds;
}

UTIF.decodeImage = function(buff, img, ifds)
{
	if(img.data) return;
	var data = new Uint8Array(buff);
	var id = UTIF._binBE.readASCII(data, 0, 2);

	if(img["t256"]==null) return;	// No width => probably not an image
	img.isLE = id=="II";
	img.width  = img["t256"][0];  //delete img["t256"];
	img.height = img["t257"][0];  //delete img["t257"];

	var cmpr   = img["t259"] ? img["t259"][0] : 1;  //delete img["t259"];
	var fo = img["t266"] ? img["t266"][0] : 1;  //delete img["t266"];
	if(img["t284"] && img["t284"][0]==2) log("PlanarConfiguration 2 should not be used!");

	var bipp;  // bits per pixel
	if(img["t258"]) bipp = Math.min(32,img["t258"][0])*img["t258"].length;
	else            bipp = (img["t277"]?img["t277"][0]:1);  
	// Some .NEF files have t258==14, even though they use 16 bits per pixel
	if(cmpr==1 && img["t279"]!=null && img["t278"] && img["t262"][0]==32803)  {
		bipp = Math.round((img["t279"][0]*8)/(img.width*img["t278"][0]));
	}
	var bipl = Math.ceil(img.width*bipp/8)*8;
	var soff = img["t273"];  if(soff==null) soff = img["t324"];
	var bcnt = img["t279"];  if(cmpr==1 && soff.length==1) bcnt = [img.height*(bipl>>>3)];  if(bcnt==null) bcnt = img["t325"];
	//bcnt[0] = Math.min(bcnt[0], data.length);  // Hasselblad, "RAW_HASSELBLAD_H3D39II.3FR"
	var bytes = new Uint8Array(img.height*(bipl>>>3)), bilen = 0;

	if(img["t322"]!=null) // tiled
	{
		var tw = img["t322"][0], th = img["t323"][0];
		var tx = Math.floor((img.width  + tw - 1) / tw);
		var ty = Math.floor((img.height + th - 1) / th);
		var tbuff = new Uint8Array(Math.ceil(tw*th*bipp/8)|0);
		for(var y=0; y<ty; y++)
			for(var x=0; x<tx; x++)
			{
				var i = y*tx+x;  for(var j=0; j<tbuff.length; j++) tbuff[j]=0;
				UTIF.decode._decompress(img,ifds, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo);
				// Might be required for 7 too. Need to check
				if (cmpr==6) bytes = tbuff;
				else UTIF._copyTile(tbuff, Math.ceil(tw*bipp/8)|0, th, bytes, Math.ceil(img.width*bipp/8)|0, img.height, Math.ceil(x*tw*bipp/8)|0, y*th);
			}
		bilen = bytes.length*8;
	}
	else	// stripped
	{
		var rps = img["t278"] ? img["t278"][0] : img.height;   rps = Math.min(rps, img.height);
		for(var i=0; i<soff.length; i++)
		{
			UTIF.decode._decompress(img,ifds, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen/8)|0, fo);
			bilen += bipl * rps;
		}
		bilen = Math.min(bilen, bytes.length*8);
	}
	img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen/8)|0);
}

UTIF.decode._decompress = function(img,ifds, data, off, len, cmpr, tgt, toff, fo)  // fill order
{
	//console.log("compression", cmpr);
	//var time = Date.now();
	if(false) {}
	else if(cmpr==1/* || (len==tgt.length && cmpr!=32767)*/) for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
	else if(cmpr==3) UTIF.decode._decodeG3 (data, off, len, tgt, toff, img.width, fo, img["t292"]?((img["t292"][0]&1)==1):false);
	else if(cmpr==4) UTIF.decode._decodeG4 (data, off, len, tgt, toff, img.width, fo);
	else if(cmpr==5) UTIF.decode._decodeLZW(data, off, len, tgt, toff,8);
	else if(cmpr==6) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
	else if(cmpr==7 || cmpr==34892) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
	else if(cmpr==8 || cmpr==32946) {  var src = new Uint8Array(data.buffer,off,len);  var bin = pako["inflate"](src);  for(var i=0; i<bin.length; i++) tgt[toff+i]=bin[i];  }
	else if(cmpr==9) UTIF.decode._decodeVC5(data,off,len,tgt,toff);
	else if(cmpr==32767) UTIF.decode._decodeARW(img, data, off, len, tgt, toff);
	else if(cmpr==32773) UTIF.decode._decodePackBits(data, off, len, tgt, toff);
	else if(cmpr==32809) UTIF.decode._decodeThunder (data, off, len, tgt, toff);
	else if(cmpr==34713) //for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
		UTIF.decode._decodeNikon   (img,ifds, data, off, len, tgt, toff);
	else log("Unknown compression", cmpr);
	
	//console.log(Date.now()-time);
	
	var bps = (img["t258"]?Math.min(32,img["t258"][0]):1);
	var noc = (img["t277"]?img["t277"][0]:1), bpp=(bps*noc)>>>3, h = (img["t278"] ? img["t278"][0] : img.height), bpl = Math.ceil(bps*noc*img.width/8);
	
	// convert to Little Endian  /*
	if(bps==16 && !img.isLE && img["t33422"]==null)  // not DNG
		for(var y=0; y<h; y++) {
			//console.log("fixing endianity");
			var roff = toff+y*bpl;
			for(var x=1; x<bpl; x+=2) {  var t=tgt[roff+x];  tgt[roff+x]=tgt[roff+x-1];  tgt[roff+x-1]=t;  }
		}  //*/

	if(img["t317"] && img["t317"][0]==2)
	{
		for(var y=0; y<h; y++)
		{
			var ntoff = toff+y*bpl;
			if(bps==16) for(var j=bpp; j<bpl; j+=2) {
				var nv = ((tgt[ntoff+j+1]<<8)|tgt[ntoff+j])  +  ((tgt[ntoff+j-bpp+1]<<8)|tgt[ntoff+j-bpp]);
				tgt[ntoff+j] = nv&255;  tgt[ntoff+j+1] = (nv>>>8)&255;  
			}
			else if(noc==3) for(var j=  3; j<bpl; j+=3)
			{
				tgt[ntoff+j  ] = (tgt[ntoff+j  ] + tgt[ntoff+j-3])&255;
				tgt[ntoff+j+1] = (tgt[ntoff+j+1] + tgt[ntoff+j-2])&255;
				tgt[ntoff+j+2] = (tgt[ntoff+j+2] + tgt[ntoff+j-1])&255;
			}
			else for(var j=bpp; j<bpl; j++) tgt[ntoff+j] = (tgt[ntoff+j] + tgt[ntoff+j-bpp])&255;
		}
	}
}

UTIF.decode._decodeVC5 = UTIF.decode._decodeVC5=function(){var e=[1,0,1,0,2,2,1,1,3,7,1,2,5,25,1,3,6,48,1,4,6,54,1,5,7,111,1,8,7,99,1,6,7,105,12,0,7,107,1,7,8,209,20,0,8,212,1,9,8,220,1,10,9,393,1,11,9,394,32,0,9,416,1,12,9,427,1,13,10,887,1,18,10,784,1,14,10,790,1,15,10,835,60,0,10,852,1,16,10,885,1,17,11,1571,1,19,11,1668,1,20,11,1669,100,0,11,1707,1,21,11,1772,1,22,12,3547,1,29,12,3164,1,24,12,3166,1,25,12,3140,1,23,12,3413,1,26,12,3537,1,27,12,3539,1,28,13,7093,1,35,13,6283,1,30,13,6331,1,31,13,6335,180,0,13,6824,1,32,13,7072,1,33,13,7077,320,0,13,7076,1,34,14,12565,1,36,14,12661,1,37,14,12669,1,38,14,13651,1,39,14,14184,1,40,15,28295,1,46,15,28371,1,47,15,25320,1,42,15,25336,1,43,15,25128,1,41,15,27300,1,44,15,28293,1,45,16,50259,1,48,16,50643,1,49,16,50675,1,50,16,56740,1,53,16,56584,1,51,16,56588,1,52,17,113483,1,61,17,113482,1,60,17,101285,1,55,17,101349,1,56,17,109205,1,57,17,109207,1,58,17,100516,1,54,17,113171,1,59,18,202568,1,62,18,202696,1,63,18,218408,1,64,18,218412,1,65,18,226340,1,66,18,226356,1,67,18,226358,1,68,19,402068,1,69,19,405138,1,70,19,405394,1,71,19,436818,1,72,19,436826,1,73,19,452714,1,75,19,452718,1,76,19,452682,1,74,20,804138,1,77,20,810279,1,78,20,810790,1,79,20,873638,1,80,20,873654,1,81,20,905366,1,82,20,905430,1,83,20,905438,1,84,21,1608278,1,85,21,1620557,1,86,21,1621582,1,87,21,1621583,1,88,21,1747310,1,89,21,1810734,1,90,21,1810735,1,91,21,1810863,1,92,21,1810879,1,93,22,3621725,1,99,22,3621757,1,100,22,3241112,1,94,22,3494556,1,95,22,3494557,1,96,22,3494622,1,97,22,3494623,1,98,23,6482227,1,102,23,6433117,1,101,23,6989117,1,103,23,6989119,1,105,23,6989118,1,104,23,7243449,1,106,23,7243512,1,107,24,13978233,1,111,24,12964453,1,109,24,12866232,1,108,24,14486897,1,113,24,13978232,1,110,24,14486896,1,112,24,14487026,1,114,24,14487027,1,115,25,25732598,1,225,25,25732597,1,189,25,25732596,1,188,25,25732595,1,203,25,25732594,1,202,25,25732593,1,197,25,25732592,1,207,25,25732591,1,169,25,25732590,1,223,25,25732589,1,159,25,25732522,1,235,25,25732579,1,152,25,25732575,1,192,25,25732489,1,179,25,25732573,1,201,25,25732472,1,172,25,25732576,1,149,25,25732488,1,178,25,25732566,1,120,25,25732571,1,219,25,25732577,1,150,25,25732487,1,127,25,25732506,1,211,25,25732548,1,125,25,25732588,1,158,25,25732486,1,247,25,25732467,1,238,25,25732508,1,163,25,25732552,1,228,25,25732603,1,183,25,25732513,1,217,25,25732587,1,168,25,25732520,1,122,25,25732484,1,128,25,25732562,1,249,25,25732505,1,187,25,25732504,1,186,25,25732483,1,136,25,25928905,1,181,25,25732560,1,255,25,25732500,1,230,25,25732482,1,135,25,25732555,1,233,25,25732568,1,222,25,25732583,1,145,25,25732481,1,134,25,25732586,1,167,25,25732521,1,248,25,25732518,1,209,25,25732480,1,243,25,25732512,1,216,25,25732509,1,164,25,25732547,1,140,25,25732479,1,157,25,25732544,1,239,25,25732574,1,191,25,25732564,1,251,25,25732478,1,156,25,25732546,1,139,25,25732498,1,242,25,25732557,1,133,25,25732477,1,162,25,25732515,1,213,25,25732584,1,165,25,25732514,1,212,25,25732476,1,227,25,25732494,1,198,25,25732531,1,236,25,25732530,1,234,25,25732529,1,117,25,25732528,1,215,25,25732527,1,124,25,25732526,1,123,25,25732525,1,254,25,25732524,1,253,25,25732523,1,148,25,25732570,1,218,25,25732580,1,146,25,25732581,1,147,25,25732569,1,224,25,25732533,1,143,25,25732540,1,184,25,25732541,1,185,25,25732585,1,166,25,25732556,1,132,25,25732485,1,129,25,25732563,1,250,25,25732578,1,151,25,25732501,1,119,25,25732502,1,193,25,25732536,1,176,25,25732496,1,245,25,25732553,1,229,25,25732516,1,206,25,25732582,1,144,25,25732517,1,208,25,25732558,1,137,25,25732543,1,241,25,25732466,1,237,25,25732507,1,190,25,25732542,1,240,25,25732551,1,131,25,25732554,1,232,25,25732565,1,252,25,25732475,1,171,25,25732493,1,205,25,25732492,1,204,25,25732491,1,118,25,25732490,1,214,25,25928904,1,180,25,25732549,1,126,25,25732602,1,182,25,25732539,1,175,25,25732545,1,141,25,25732559,1,138,25,25732537,1,177,25,25732534,1,153,25,25732503,1,194,25,25732606,1,160,25,25732567,1,121,25,25732538,1,174,25,25732497,1,246,25,25732550,1,130,25,25732572,1,200,25,25732474,1,170,25,25732511,1,221,25,25732601,1,196,25,25732532,1,142,25,25732519,1,210,25,25732495,1,199,25,25732605,1,155,25,25732535,1,154,25,25732499,1,244,25,25732510,1,220,25,25732600,1,195,25,25732607,1,161,25,25732604,1,231,25,25732473,1,173,25,25732599,1,226,26,51465122,1,116,26,51465123,0,1],x,u,H,d=[3,3,3,3,2,2,2,1,1,1],a=24576,a7=16384,K=8192,ai=a7|K;
function A(B){var P=B[1],D=B[0][P>>>3]>>>7-(P&7)&1;B[1]++;return D}function aj(B,P){if(x==null){x={};
for(var D=0;D<e.length;D+=4)x[e[D+1]]=e.slice(D,D+4)}var U=A(B),X=x[U];while(X==null){U=U<<1|A(B);X=x[U]}var y=X[3];
if(y!=0)y=A(B)==0?y:-y;P[0]=X[2];P[1]=y}function Q(B,P){for(var D=0;D<P;D++){if((B&1)==1)B++;B=B>>>1}return B}function c(B,P){return B>>P}function N(B,P,D,U,X,y){P[D]=c(c(11*B[X]-4*B[X+y]+B[X+y+y]+4,3)+B[U],1);
P[D+y]=c(c(5*B[X]+4*B[X+y]-B[X+y+y]+4,3)-B[U],1)}function g(B,P,D,U,X,y){var n=B[X-y]-B[X+y],S=B[X],O=B[U];
P[D]=c(c(n+4,3)+S+O,1);P[D+y]=c(c(-n+4,3)+S-O,1)}function L(B,P,D,U,X,y){P[D]=c(c(5*B[X]+4*B[X-y]-B[X-y-y]+4,3)+B[U],1);
P[D+y]=c(c(11*B[X]-4*B[X-y]+B[X-y-y]+4,3)-B[U],1)}function t(B){B=B<0?0:B>4095?4095:B;B=H[B]>>>2;return B}function ab(B,P,D,U,X){U=new Uint16Array(U.buffer);
var y=Date.now(),n=UTIF._binBE,S=P+D,O,q,i,M,m,aA,T,a8,a0,am,au,a3,aw,ao,v,ax,p,k;P+=4;while(P<S){var W=n.readShort(B,P),E=n.readUshort(B,P+2);
P+=4;if(W==12)O=E;else if(W==20)q=E;else if(W==21)i=E;else if(W==48)M=E;else if(W==53)m=E;else if(W==35)aA=E;
else if(W==62)T=E;else if(W==101)a8=E;else if(W==109)a0=E;else if(W==84)am=E;else if(W==106)au=E;else if(W==107)a3=E;
else if(W==108)aw=E;else if(W==102)ao=E;else if(W==104)v=E;else if(W==105)ax=E;else{var C=W<0?-W:W,F=C&65280,o=0;
if(C&ai){if(C&K){o=E&65535;o+=(C&255)<<16}else{o=E&65535}}if((C&a)==a){if(p==null){p=[];for(var f=0;
f<4;f++)p[f]=new Int16Array((q>>>1)*(i>>>1));k=new Int16Array((q>>>1)*(i>>>1));u=new Int16Array(1024);
for(var f=0;f<1024;f++){var aF=f-512,j=Math.abs(aF),O=Math.floor(768*j*j*j/(255*255*255))+j;u[f]=Math.sign(aF)*O}H=new Uint16Array(4096);
var al=(1<<16)-1;for(var f=0;f<4096;f++){var ad=f,az=al*(Math.pow(113,ad/4095)-1)/112;H[f]=Math.min(az,al)}}var Z=p[T],V=Q(q,1+d[M]),z=Q(i,1+d[M]);
if(M==0){for(var b=0;b<z;b++)for(var G=0;G<V;G++){var w=P+(b*V+G)*2;Z[b*(q>>>1)+G]=B[w]<<8|B[w+1]}}else{var aC=[B,P*8],aq=[],a5=0,ae=V*z,I=[0,0],s=0,E=0;
while(a5<ae){aj(aC,I);s=I[0];E=I[1];while(s>0){aq[a5++]=E;s--}}var $=(M-1)%3,aE=$!=1?V:0,as=$!=0?z:0;
for(var b=0;b<z;b++){var ay=(b+as)*(q>>>1)+aE,aa=b*V;for(var G=0;G<V;G++)Z[ay+G]=u[aq[aa+G]+512]*m}if($==2){var v=q>>>1,an=V*2,at=z*2;
for(var b=0;b<z;b++){for(var G=0;G<an;G++){var f=b*2*v+G,_=b*v+G,l=z*v+_;if(b==0)N(Z,k,f,l,_,v);else if(b==z-1)L(Z,k,f,l,_,v);
else g(Z,k,f,l,_,v)}}var h=Z;Z=k;k=h;for(var b=0;b<at;b++){for(var G=0;G<V;G++){var f=b*v+2*G,_=b*v+G,l=V+_;
if(G==0)N(Z,k,f,l,_,1);else if(G==V-1)L(Z,k,f,l,_,1);else g(Z,k,f,l,_,1)}}var h=Z;Z=k;k=h;var a6=[],aD=2-~~((M-1)/3);
for(var r=0;r<3;r++)a6[r]=a0>>14-r*2&3;var af=a6[aD];if(af!=0)for(var b=0;b<at;b++)for(var G=0;G<an;
G++){var f=b*v+G;Z[f]=Z[f]<<af}}}if(M==9&&T==3){var a2=p[0],ar=p[1],ah=p[2],a1=p[3];for(var b=0;b<i;
b+=2)for(var G=0;G<q;G+=2){var J=b*q+G,w=(b>>>1)*(q>>>1)+(G>>>1),R=a2[w],ak=ar[w]-2048,aB=ah[w]-2048,av=a1[w]-2048,a4=(ak<<1)+R,a9=(aB<<1)+R,ap=R+av,ag=R-av;
U[J]=t(a4);U[J+1]=t(ap);U[J+q]=t(ag);U[J+q+1]=t(a9)}}P+=o*4}else if(C==16388){P+=o*4}else if(F==8192||F==8448||F==9216){}else throw C.toString(16)}}console.log(Date.now()-y)}return ab}()

UTIF.decode._ljpeg_diff = function(data, prm, huff) {
	var getbithuff   = UTIF.decode._getbithuff;
	var len, diff;
	len  = getbithuff(data, prm, huff[0], huff);
	diff = getbithuff(data, prm, len, 0);
	if ((diff & (1 << (len-1))) == 0)  diff -= (1 << len) - 1;
	return diff;
}
UTIF.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
	var raw_width = img["t256"][0], height=img["t257"][0], tiff_bps=img["t258"][0];
	var bin=(img.isLE ? UTIF._binLE : UTIF._binBE);
	//console.log(raw_width, height, tiff_bps, raw_width*height, src_length);
	var arw2 = (raw_width*height == src_length) || (raw_width*height*1.5 == src_length);
	//arw2 = true;
	//console.log("ARW2: ", arw2, raw_width*height, src_length, tgt.length);
	if(!arw2) {  //"sony_arw_load_raw"; // not arw2
		height+=8;
		var prm = [off,0,0,0];
		var huff = new Uint16Array(32770);
		var tab = [ 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,
			0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 ];
		var i, c, n, col, row, sum=0;
		var ljpeg_diff = UTIF.decode._ljpeg_diff;

		huff[0] = 15;
		for (n=i=0; i < 18; i++) {
			var lim = 32768 >>> (tab[i] >>> 8);
			for(var c=0; c<lim; c++) huff[++n] = tab[i];
		}
		for (col = raw_width; col--; )
			for (row=0; row < height+1; row+=2) {
				if (row == height) row = 1;
				sum += ljpeg_diff(inp, prm, huff);
				if (row < height) {
					var clr =  (sum)&4095;
					UTIF.decode._putsF(tgt, (row*raw_width+col)*tiff_bps, clr<<(16-tiff_bps));
				}
			}
		return;
	}
	if(raw_width*height*1.5==src_length) {
		//console.log("weird compression");
		for(var i=0; i<src_length; i+=3) {  var b0=inp[off+i+0], b1=inp[off+i+1], b2=inp[off+i+2];  
			tgt[toff+i]=(b1<<4)|(b0>>>4);  tgt[toff+i+1]=(b0<<4)|(b2>>>4);  tgt[toff+i+2]=(b2<<4)|(b1>>>4);  }
		return;
	}
	
	var pix = new Uint16Array(16);
	var row, col, val, max, min, imax, imin, sh, bit, i,    dp;
	
	var data = new Uint8Array(raw_width+1);
	for (row=0; row < height; row++) {
		//fread (data, 1, raw_width, ifp);
		for(var j=0; j<raw_width; j++) data[j]=inp[off++];
		for (dp=0, col=0; col < raw_width-30; dp+=16) {
			max  = 0x7ff & (val = bin.readUint(data,dp));
			min  = 0x7ff & (val >>> 11);
			imax = 0x0f & (val >>> 22);
			imin = 0x0f & (val >>> 26);
			for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);
			for (bit=30, i=0; i < 16; i++)
				if      (i == imax) pix[i] = max;
				else if (i == imin) pix[i] = min;
				else {
					pix[i] = ((bin.readUshort(data, dp+(bit >> 3)) >>> (bit & 7) & 0x7f) << sh) + min;
					if (pix[i] > 0x7ff) pix[i] = 0x7ff;
					bit += 7;
				}
			for (i=0; i < 16; i++, col+=2) {
				//RAW(row,col) = curve[pix[i] << 1] >> 2;
				var clr =  pix[i]<<1;   //clr = 0xffff;
				UTIF.decode._putsF(tgt, (row*raw_width+col)*tiff_bps, clr<<(16-tiff_bps));
			}
			col -= col & 1 ? 1:31;
		}
	}
}

UTIF.decode._decodeNikon = function(img,imgs, data, off, src_length, tgt, toff)
{
	var nikon_tree = [
    [ 0, 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy */
      5,4,3,6,2,7,1,0,8,9,11,10,12 ],
    [ 0, 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy after split */
      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 ],
    [ 0, 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */
      5,4,6,3,7,2,8,1,9,0,10,11,12 ],
    [ 0, 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	/* 14-bit lossy */
      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 ],
    [ 0, 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	/* 14-bit lossy after split */
      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 ],
    [ 0, 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	/* 14-bit lossless */
      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 ] ];
	  
	var raw_width = img["t256"][0], height=img["t257"][0], tiff_bps=img["t258"][0];
	
	var tree = 0, split = 0;
	var make_decoder = UTIF.decode._make_decoder;
	var getbithuff   = UTIF.decode._getbithuff;
	
	var mn = imgs[0].exifIFD.makerNote, md = mn["t150"]?mn["t150"]:mn["t140"], mdo=0;  //console.log(mn,md);
	//console.log(md[0].toString(16), md[1].toString(16), tiff_bps);
	var ver0 = md[mdo++], ver1 = md[mdo++];
	if (ver0 == 0x49 || ver1 == 0x58)  mdo+=2110;
	if (ver0 == 0x46) tree = 2;
	if (tiff_bps == 14) tree += 3;
	
	var vpred = [[0,0],[0,0]], bin=(img.isLE ? UTIF._binLE : UTIF._binBE);
	for(var i=0; i<2; i++) for(var j=0; j<2; j++) {  vpred[i][j] = bin.readShort(md,mdo);  mdo+=2;   }  // not sure here ... [i][j] or [j][i]
	//console.log(vpred);
	
	
	var max = 1 << tiff_bps & 0x7fff, step=0;
	var csize = bin.readShort(md,mdo);  mdo+=2;
	if (csize > 1) step = Math.floor(max / (csize-1));
	if (ver0 == 0x44 && ver1 == 0x20 && step > 0)  split = bin.readShort(md,562);
	
	
	var i;
	var row, col;
	var len, shl, diff;
	var min_v = 0;
	var hpred = [0,0];
	var huff = make_decoder(nikon_tree[tree]);
	
	//var g_input_offset=0, bitbuf=0, vbits=0, reset=0;
	var prm = [off,0,0,0];
	//console.log(split);  split = 170;
	
	for (min_v=row=0; row < height; row++) {
		if (split && row == split) {
			//free (huff);
			huff = make_decoder (nikon_tree[tree+1]);
			//max_v += (min_v = 16) << 1;
		}
		for (col=0; col < raw_width; col++) {
			i = getbithuff(data,prm,huff[0],huff);
			len = i  & 15;
			shl = i >>> 4;
			diff = (((getbithuff(data,prm,len-shl,0) << 1) + 1) << shl) >>> 1;
			if ((diff & (1 << (len-1))) == 0)
				diff -= (1 << len) - (shl==0?1:0);
			if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
			else         hpred[col & 1] += diff;
			
			var clr = Math.min(Math.max(hpred[col & 1],0),(1<<tiff_bps)-1);
			var bti = (row*raw_width+col)*tiff_bps;  
			UTIF.decode._putsF(tgt, bti, clr<<(16-tiff_bps));
		}
	}
}
// put 16 bits
UTIF.decode._putsF= function(dt, pos, val) {  val = val<<(8-(pos&7));  var o=(pos>>>3);  dt[o]|=val>>>16;  dt[o+1]|=val>>>8;  dt[o+2]|=val;  }


UTIF.decode._getbithuff = function(data,prm,nbits, huff) {
	var zero_after_ff = 0;
	var get_byte = UTIF.decode._get_byte;
	var c;
  
	var off=prm[0], bitbuf=prm[1], vbits=prm[2], reset=prm[3];

	//if (nbits > 25) return 0;
	//if (nbits <  0) return bitbuf = vbits = reset = 0;
	if (nbits == 0 || vbits < 0) return 0; 
	while (!reset && vbits < nbits && (c = data[off++]) != -1 &&
		!(reset = zero_after_ff && c == 0xff && data[off++])) {
		//console.log("byte read into c");
		bitbuf = (bitbuf << 8) + c;
		vbits += 8;
	} 
	c = (bitbuf << (32-vbits)) >>> (32-nbits);
	if (huff) {
		vbits -= huff[c+1] >>> 8;  //console.log(c, huff[c]>>8);
		c =  huff[c+1]&255;
	} else
		vbits -= nbits;
	if (vbits < 0) throw "e";
  
	prm[0]=off;  prm[1]=bitbuf;  prm[2]=vbits;  prm[3]=reset;
  
	return c;
}

UTIF.decode._make_decoder = function(source) {
	var max, len, h, i, j;
	var huff = [];

	for (max=16; max!=0 && !source[max]; max--);
	var si=17;
	
	huff[0] = max;
	for (h=len=1; len <= max; len++)
		for (i=0; i < source[len]; i++, ++si)
			for (j=0; j < 1 << (max-len); j++)
				if (h <= 1 << max)
					huff[h++] = (len << 8) | source[si];
	return huff;
}

UTIF.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff)
{
	len = Math.min(len, data.length-off);
	var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
	
	if (tables) {
		var SOI = 216, EOI = 217, boff = 0;
		for (var i=0; i<(tlen-1); i++)
		{
			// Skip EOI marker from JPEGTables
			if (tables[i]==255 && tables[i+1]==EOI) break;
			buff[boff++] = tables[i];
		}

		// Skip SOI marker from data
		var byte1 = data[off], byte2 = data[off + 1];
		if (byte1!=255 || byte2!=SOI)
		{
			buff[boff++] = byte1;
			buff[boff++] = byte2;
		}
		for (var i=2; i<len; i++) buff[boff++] = data[off+i];
	}
	else for (var i=0; i<len; i++) buff[i] = data[off+i];

	if(img["t262"][0]==32803 || (img["t259"][0]==7 && img["t262"][0]==34892)) // lossless JPEG (used in DNG files)
	{
		var bps = img["t258"][0];//, dcdr = new LosslessJpegDecoder();
		//var time = Date.now();
		var out = UTIF.LosslessJpegDecode(buff), olen=out.length;  //console.log(olen);
		//var out = ULLJPG(buff), olen=out.length;  //console.log(olen);
		//console.log(Date.now()-time);
		
		if(false) {}
		else if(bps==16) {
			if(img.isLE) for(var i=0; i<olen; i++ ) {  tgt[toff+(i<<1)] = (out[i]&255);  tgt[toff+(i<<1)+1] = (out[i]>>>8);  }
			else         for(var i=0; i<olen; i++ ) {  tgt[toff+(i<<1)] = (out[i]>>>8);  tgt[toff+(i<<1)+1] = (out[i]&255);  }
		}
		else if(bps==14 || bps==12) {  // 4 * 14 == 56 == 7 * 8
			var rst = 16-bps;
			for(var i=0; i<olen; i++) UTIF.decode._putsF(tgt, i*bps, out[i]<<rst);
		}
		else if(bps==8) {
			for(var i=0; i<olen; i++) tgt[toff+i]=out[i];
		}
		else throw new Error("unsupported bit depth "+bps);
	}
	else
	{
		var parser = new UTIF.JpegDecoder();  parser.parse(buff);
		var decoded = parser.getData({"width":parser.width,"height":parser.height,"forceRGB":true,"isSourcePDF":false});
		for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];
	}

	// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
	// RGB format, so updating the tag value
	if(img["t262"][0] == 6)  img["t262"][0] = 2;
}

UTIF.decode._decodeOldJPEGInit = function(img, data, off, len)
{
	var SOI = 216, EOI = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS = 218;
	var joff = 0, soff = 0, tables, sosMarker, isTiled = false, i, j, k;
	var jpgIchgFmt    = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
	var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
	var soffTag       = img["t324"] || img["t273"] || jpgIchgFmt;
	var ycbcrss       = img["t530"], ssx = 0, ssy = 0;
	var spp           = img["t277"]?img["t277"][0]:1;
	var jpgresint     = img["t515"];

	if(soffTag)
	{
		soff = soffTag[0];
		isTiled = (soffTag.length > 1);
	}

	if(!isTiled)
	{
		if(data[off]==255 && data[off+1]==SOI) return { jpegOffset: off };
		if(jpgIchgFmt!=null)
		{
			if(data[off+jifoff]==255 && data[off+jifoff+1]==SOI) joff = off+jifoff;
			else log("JPEGInterchangeFormat does not point to SOI");

			if(jpgIchgFmtLen==null) log("JPEGInterchangeFormatLength field is missing");
			else if(jifoff >= soff || (jifoff+jiflen) <= soff) log("JPEGInterchangeFormatLength field value is invalid");

			if(joff != null) return { jpegOffset: joff };
		}
	}

	if(ycbcrss!=null) {  ssx = ycbcrss[0];  ssy = ycbcrss[1];  }

	if(jpgIchgFmt!=null)
		if(jpgIchgFmtLen!=null)
			if(jiflen >= 2 && (jifoff+jiflen) <= soff)
			{
				if(data[off+jifoff+jiflen-2]==255 && data[off+jifoff+jiflen-1]==SOI) tables = new Uint8Array(jiflen-2);
				else tables = new Uint8Array(jiflen);

				for(i=0; i<tables.length; i++) tables[i] = data[off+jifoff+i];
				log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
			}
			else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");

	if(tables == null)
	{
		var ooff = 0, out = [];
		out[ooff++] = 255; out[ooff++] = SOI;

		var qtables = img["t519"];
		if(qtables==null) throw new Error("JPEGQTables tag is missing");
		for(i=0; i<qtables.length; i++)
		{
			out[ooff++] = 255; out[ooff++] = DQT; out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
			for(j=0; j<64; j++) out[ooff++] = data[off+qtables[i]+j];
		}

		for(k=0; k<2; k++)
		{
			var htables = img[(k == 0) ? "t520" : "t521"];
			if(htables==null) throw new Error(((k == 0) ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
			for(i=0; i<htables.length; i++)
			{
				out[ooff++] = 255; out[ooff++] = DHT;
				//out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
				var nc = 19;
				for(j=0; j<16; j++) nc += data[off+htables[i]+j];

				out[ooff++] = (nc >>> 8); out[ooff++] = nc & 255;
				out[ooff++] = (i | (k << 4));
				for(j=0; j<16; j++) out[ooff++] = data[off+htables[i]+j];
				for(j=0; j<nc; j++) out[ooff++] = data[off+htables[i]+16+j];
			}
		}

		out[ooff++] = 255; out[ooff++] = SOF0;
		out[ooff++] = 0;  out[ooff++] = 8 + 3*spp;  out[ooff++] = 8;
		out[ooff++] = (img.height >>> 8) & 255;  out[ooff++] = img.height & 255;
		out[ooff++] = (img.width  >>> 8) & 255;  out[ooff++] = img.width  & 255;
		out[ooff++] = spp;
		if(spp==1) {  out[ooff++] = 1;  out[ooff++] = 17;  out[ooff++] = 0;  }
		else for(i=0; i<3; i++)
		{
			out[ooff++] = i + 1;
			out[ooff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
			out[ooff++] = i;
		}

		if(jpgresint!=null && jpgresint[0]!=0)
		{
			out[ooff++] = 255;  out[ooff++] = DRI;  out[ooff++] = 0;  out[ooff++] = 4;
			out[ooff++] = (jpgresint[0] >>> 8) & 255;
			out[ooff++] = jpgresint[0] & 255;
		}

		tables = new Uint8Array(out);
	}

	var sofpos = -1;
	i = 0;
	while(i < (tables.length - 1)) {
		if(tables[i]==255 && tables[i+1]==SOF0) {  sofpos = i; break;  }
		i++;
	}

	if(sofpos == -1)
	{
		var tmptab = new Uint8Array(tables.length + 10 + 3*spp);
		tmptab.set(tables);
		var tmpoff = tables.length;
		sofpos = tables.length;
		tables = tmptab;

		tables[tmpoff++] = 255; tables[tmpoff++] = SOF0;
		tables[tmpoff++] = 0;  tables[tmpoff++] = 8 + 3*spp;  tables[tmpoff++] = 8;
		tables[tmpoff++] = (img.height >>> 8) & 255;  tables[tmpoff++] = img.height & 255;
		tables[tmpoff++] = (img.width  >>> 8) & 255;  tables[tmpoff++] = img.width  & 255;
		tables[tmpoff++] = spp;
		if(spp==1) {  tables[tmpoff++] = 1;  tables[tmpoff++] = 17;  tables[tmpoff++] = 0;  }
		else for(i=0; i<3; i++)
		{
			tables[tmpoff++] = i + 1;
			tables[tmpoff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
			tables[tmpoff++] = i;
		}
	}

	if(data[soff]==255 && data[soff+1]==SOS)
	{
		var soslen = (data[soff+2]<<8) | data[soff+3];
		sosMarker = new Uint8Array(soslen+2);
		sosMarker[0] = data[soff];  sosMarker[1] = data[soff+1]; sosMarker[2] = data[soff+2];  sosMarker[3] = data[soff+3];
		for(i=0; i<(soslen-2); i++) sosMarker[i+4] = data[soff+i+4];
	}
	else
	{
		sosMarker = new Uint8Array(2 + 6 + 2*spp);
		var sosoff = 0;
		sosMarker[sosoff++] = 255;  sosMarker[sosoff++] = SOS;
		sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 6 + 2*spp;  sosMarker[sosoff++] = spp;
		if(spp==1) {  sosMarker[sosoff++] = 1;  sosMarker[sosoff++] = 0;  }
		else for(i=0; i<3; i++)
		{
			sosMarker[sosoff++] = i+1;  sosMarker[sosoff++] = (i << 4) | i;
		}
		sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 63;  sosMarker[sosoff++] = 0;
	}

	return { jpegOffset: off, tables: tables, sosMarker: sosMarker, sofPosition: sofpos };
}

UTIF.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff)
{
	var i, dlen, tlen, buff, buffoff;
	var jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);

	if(jpegData.jpegOffset!=null)
	{
		dlen = off+len-jpegData.jpegOffset;
		buff = new Uint8Array(dlen);
		for(i=0; i<dlen; i++) buff[i] = data[jpegData.jpegOffset+i];
	}
	else
	{
		tlen = jpegData.tables.length;
		buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
		buff.set(jpegData.tables);
		buffoff = tlen;

		buff[jpegData.sofPosition+5] = (img.height >>> 8) & 255;  buff[jpegData.sofPosition+6] = img.height & 255;
		buff[jpegData.sofPosition+7] = (img.width  >>> 8) & 255;  buff[jpegData.sofPosition+8] = img.width  & 255;

		if(data[off]!=255 || data[off+1]!=SOS)
		{
			buff.set(jpegData.sosMarker, buffoff);
			buffoff += sosMarker.length;
		}
		for(i=0; i<len; i++) buff[buffoff++] = data[off+i];
		buff[buffoff++] = 255;  buff[buffoff++] = EOI;
	}

	var parser = new UTIF.JpegDecoder();  parser.parse(buff);
	var decoded = parser.getData({"width":parser.width,"height":parser.height,"forceRGB":true,"isSourcePDF":false});
	for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];

	// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
	// RGB format, so updating the tag value
	if(img["t262"] && img["t262"][0] == 6)  img["t262"][0] = 2;
}

UTIF.decode._decodePackBits = function(data, off, len, tgt, toff)
{
	var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off+len;
	while(off<lim)
	{
		var n = sa[off];  off++;
		if(n>=0  && n<128)    for(var i=0; i< n+1; i++) {  ta[toff]=sa[off];  toff++;  off++;   }
		if(n>=-127 && n<0) {  for(var i=0; i<-n+1; i++) {  ta[toff]=sa[off];  toff++;           }  off++;  }
	}
}

UTIF.decode._decodeThunder = function(data, off, len, tgt, toff)
{
	var d2 = [ 0, 1, 0, -1 ],  d3 = [ 0, 1, 2, 3, 0, -3, -2, -1 ];
	var lim = off+len, qoff = toff*2, px = 0;
	while(off<lim)
	{
		var b = data[off], msk = (b>>>6), n = (b&63);  off++;
		if(msk==3) { px=(n&15);  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
		if(msk==0) for(var i=0; i<n; i++) {  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
		if(msk==2) for(var i=0; i<2; i++) {  var d=(n>>>(3*(1-i)))&7;  if(d!=4) { px+=d3[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
		if(msk==1) for(var i=0; i<3; i++) {  var d=(n>>>(2*(2-i)))&3;  if(d!=2) { px+=d2[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
	}
}

UTIF.decode._dmap = { "1":0,"011":1,"000011":2,"0000011":3, "010":-1,"000010":-2,"0000010":-3  };
UTIF.decode._lens = ( function()
{
	var addKeys = function(lens, arr, i0, inc) {  for(var i=0; i<arr.length; i++) lens[arr[i]] = i0 + i*inc;  }

	var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101," // 15
	+ "101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010," // 31
	+ "00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010," // 47
	+ "00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";

	var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000," // 15
	+ "0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001," // 31
	+ "000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111," // 47
	+ "000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";

	var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,"
	+ "011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";

	var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,"
	+ "0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,"
	+ "0000001011011,0000001100100,0000001100101";

	var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";

	termW = termW.split(",");  termB = termB.split(",");  makeW = makeW.split(",");  makeB = makeB.split(",");  makeA = makeA.split(",");

	var lensW = {}, lensB = {};
	addKeys(lensW, termW, 0, 1);  addKeys(lensW, makeW, 64,64);  addKeys(lensW, makeA, 1792,64);
	addKeys(lensB, termB, 0, 1);  addKeys(lensB, makeB, 64,64);  addKeys(lensB, makeA, 1792,64);
	return [lensW, lensB];
} )();

UTIF.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo)
{
	var U = UTIF.decode, boff=off<<3, len=0, wrd="";	// previous starts with 1
	var line=[], pline=[];  for(var i=0; i<w; i++) pline.push(0);  pline=U._makeDiff(pline);
	var a0=0, a1=0, a2=0, b1=0, b2=0, clr=0;
	var y=0, mode="", toRead=0;
	var bipl = Math.ceil(w/8)*8;

	while((boff>>>3)<off+slen)
	{
		b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
		var bit =0;
		if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
		if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
		boff++;  wrd+=bit;
		if(mode=="H")
		{
			if(U._lens[clr][wrd]!=null)
			{
				var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
				if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
			}
		}
		else
		{
			if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
			if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
			if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
		}
		if(line.length==w && mode=="")
		{
			U._writeBits(line, tgt, toff*8+y*bipl);
			clr=0;  y++;  a0=0;
			pline=U._makeDiff(line);  line=[];
		}
		//if(wrd.length>150) {  log(wrd);  break;  throw "e";  }
	}
}

UTIF.decode._findDiff = function(line, x, clr) {  for(var i=0; i<line.length; i+=2) if(line[i]>=x && line[i+1]==clr)  return line[i];  }

UTIF.decode._makeDiff = function(line)
{
	var out = [];  if(line[0]==1) out.push(0,1);
	for(var i=1; i<line.length; i++) if(line[i-1]!=line[i]) out.push(i, line[i]);
	out.push(line.length,0,line.length,1);  return out;
}

UTIF.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo, twoDim)
{
	var U = UTIF.decode, boff=off<<3, len=0, wrd="";
	var line=[], pline=[];  for(var i=0; i<w; i++) line.push(0);
	var a0=0, a1=0, a2=0, b1=0, b2=0, clr=0;
	var y=-1, mode="", toRead=0, is1D=true;
	var bipl = Math.ceil(w/8)*8;
	while((boff>>>3)<off+slen)
	{
		b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
		var bit =0;
		if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
		if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
		boff++;  wrd+=bit;

		if(is1D)
		{
			if(U._lens[clr][wrd]!=null)
			{
				var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
				if(dl<64) {  U._addNtimes(line,len,clr);  clr=1-clr;  len=0;  }
			}
		}
		else
		{
			if(mode=="H")
			{
				if(U._lens[clr][wrd]!=null)
				{
					var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
					if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
				}
			}
			else
			{
				if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
				if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
				if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
			}
		}
		if(wrd.endsWith("000000000001")) // needed for some files
		{
			if(y>=0) U._writeBits(line, tgt, toff*8+y*bipl);
			if(twoDim) {
				if(fo==1) is1D = ((data[boff>>>3]>>>(7-(boff&7)))&1)==1;
				if(fo==2) is1D = ((data[boff>>>3]>>>(  (boff&7)))&1)==1;
				boff++;
			}
			//log("EOL",y, "next 1D:", is1D);
			wrd="";  clr=0;  y++;  a0=0;
			pline=U._makeDiff(line);  line=[];
		}
	}
	if(line.length==w) U._writeBits(line, tgt, toff*8+y*bipl);
}

UTIF.decode._addNtimes = function(arr, n, val) {  for(var i=0; i<n; i++) arr.push(val);  }

UTIF.decode._writeBits = function(bits, tgt, boff)
{
	for(var i=0; i<bits.length; i++) tgt[(boff+i)>>>3] |= (bits[i]<<(7-((boff+i)&7)));
}

UTIF.decode._decodeLZW=UTIF.decode._decodeLZW=function(){var e,U,Z,u,K=0,V=0,g=0,N=0,O=function(){var S=e>>>3,A=U[S]<<16|U[S+1]<<8|U[S+2],j=A>>>24-(e&7)-V&(1<<V)-1;
e+=V;return j},h=new Uint32Array(4096*4),w=0,m=function(S){if(S==w)return;w=S;g=1<<S;N=g+1;for(var A=0;
A<N+1;A++){h[4*A]=h[4*A+3]=A;h[4*A+1]=65535;h[4*A+2]=1}},i=function(S){V=S+1;K=N+1},D=function(S){var A=S<<2,j=h[A+2],a=u+j-1;
while(A!=65535){Z[a--]=h[A];A=h[A+1]}u+=j},L=function(S,A){var j=K<<2,a=S<<2;h[j]=h[(A<<2)+3];h[j+1]=a;
h[j+2]=h[a+2]+1;h[j+3]=h[a+3];K++;if(K+1==1<<V&&V!=12)V++},T=function(S,A,j,a,n,q){e=A<<3;U=S;Z=a;u=n;
var B=A+j<<3,_=0,t=0;m(q);i(q);while(e<B&&(_=O())!=N){if(_==g){i(q);_=O();if(_==N)break;D(_)}else{if(_<K){D(_);
L(t,_)}else{L(t,t);D(K-1)}}t=_}return u};return T}();

UTIF.tags = {};
//UTIF.ttypes = {  256:3,257:3,258:3,   259:3, 262:3,  273:4,  274:3, 277:3,278:4,279:4, 282:5, 283:5, 284:3, 286:5,287:5, 296:3, 305:2, 306:2, 338:3, 513:4, 514:4, 34665:4  };
// start at tag 250
UTIF._types = function() {
	var main = new Array(250);  main.fill(0);
	main = main.concat([0,0,0,0,4,3,3,3,3,3,0,0,3,0,0,0,3,0,0,2,2,2,2,4,3,0,0,3,4,4,3,3,5,5,3,2,5,5,0,0,0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,2,2,3,5,5,3,0,3,3,4,4,4,3,4,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
	var rest = {33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7};
	return {
		basic: {
			main: main,
			rest: rest
		},
		gps: {
			main: [1,2,5,2,5,1,5,5,0,9],
			rest: {18:2,29:2}
		}
	}
}();

UTIF._readIFD = function(bin, data, offset, ifds, depth, prm)
{
	var cnt = bin.readUshort(data, offset);  offset+=2;
	var ifd = {};

	if(prm.debug) log("   ".repeat(depth),ifds.length-1,">>>----------------");
	for(var i=0; i<cnt; i++)
	{
		var tag  = bin.readUshort(data, offset);    offset+=2;
		var type = bin.readUshort(data, offset);    offset+=2;
		var num  = bin.readUint  (data, offset);    offset+=4;
		var voff = bin.readUint  (data, offset);    offset+=4;
		
		var arr = [];
		//ifd["t"+tag+"-"+UTIF.tags[tag]] = arr;
		if(type== 1 || type==7) {  arr = new Uint8Array(data.buffer, (num<5 ? offset-4 : voff), num);  }
		if(type== 2) {  var o0 = (num<5 ? offset-4 : voff), c=data[o0], len=Math.max(0, Math.min(num-1,data.length-o0));
						if(c<128 || len==0) arr.push( bin.readASCII(data, o0, len) );
						else      arr = new Uint8Array(data.buffer, o0, len);  }
		if(type== 3) {  for(var j=0; j<num; j++) arr.push(bin.readUshort(data, (num<3 ? offset-4 : voff)+2*j));  }
		if(type== 4 
		|| type==13) {  for(var j=0; j<num; j++) arr.push(bin.readUint  (data, (num<2 ? offset-4 : voff)+4*j));  }
		if(type== 5 || type==10) {  
			var ri = type==5 ? bin.readUint : bin.readInt;
			for(var j=0; j<num; j++) arr.push([ri(data, voff+j*8), ri(data,voff+j*8+4)]);  }
		if(type== 8) {  for(var j=0; j<num; j++) arr.push(bin.readShort (data, (num<3 ? offset-4 : voff)+2*j));  }
		if(type== 9) {  for(var j=0; j<num; j++) arr.push(bin.readInt   (data, (num<2 ? offset-4 : voff)+4*j));  }
		if(type==11) {  for(var j=0; j<num; j++) arr.push(bin.readFloat (data, voff+j*4));  }
		if(type==12) {  for(var j=0; j<num; j++) arr.push(bin.readDouble(data, voff+j*8));  }
		
		if(num!=0 && arr.length==0) {  log(tag, "unknown TIFF tag type: ", type, "num:",num);  if(i==0)return;  continue;  }
		if(prm.debug) log("   ".repeat(depth), tag, type, UTIF.tags[tag], arr);
		
		ifd["t"+tag] = arr;
		
		if(tag==330 && ifd["t272"] && ifd["t272"][0]=="DSLR-A100") {  } 
		else if(tag==330 || tag==34665 || tag==34853 || (tag==50740 && bin.readUshort(data,bin.readUint(arr,0))<300  ) ||tag==61440) {
			var oarr = tag==50740 ? [bin.readUint(arr,0)] : arr;
			var subfd = [];
			for(var j=0; j<oarr.length; j++) UTIF._readIFD(bin, data, oarr[j], subfd, depth+1, prm);
			if(tag==  330) ifd.subIFD = subfd;
			if(tag==34665) ifd.exifIFD = subfd[0];
			if(tag==34853) ifd.gpsiIFD = subfd[0];  //console.log("gps", subfd[0]);  }
			if(tag==50740) ifd.dngPrvt = subfd[0];
			if(tag==61440) ifd.fujiIFD = subfd[0];
		}
		if(tag==37500 && prm.parseMN) {
			var mn = arr;
			//console.log(bin.readASCII(mn,0,mn.length), mn);
			if(bin.readASCII(mn,0,5)=="Nikon")  ifd.makerNote = UTIF["decode"](mn.slice(10).buffer)[0];
			else if(bin.readUshort(data,voff)<300 && bin.readUshort(data,voff+4)<=12){
				var subsub=[];  UTIF._readIFD(bin, data, voff, subsub, depth+1, prm);
				ifd.makerNote = subsub[0];
			}
		}
	}
	ifds.push(ifd);
	if(prm.debug) log("   ".repeat(depth),"<<<---------------");
	return offset;
}

UTIF._writeIFD = function(bin, types, data, offset, ifd)
{
	var keys = Object.keys(ifd), knum=keys.length;  if(ifd["exifIFD"]) knum--;  if(ifd["gpsiIFD"]) knum--;
	bin.writeUshort(data, offset, knum);  offset+=2;

	var eoff = offset + knum*12 + 4;

	for(var ki=0; ki<keys.length; ki++)
	{
		var key = keys[ki];  if(key=="t34665" || key=="t34853") continue;  
		if(key=="exifIFD") key="t34665";  if(key=="gpsiIFD") key="t34853";
		var tag = parseInt(key.slice(1)), type = types.main[tag];  if(type==null) type=types.rest[tag];		
		if(type==null || type==0) throw new Error("unknown type of tag: "+tag);
		//console.log(offset+":", tag, type, eoff);
		var val = ifd[key];  
		if(tag==34665) {
			var outp = UTIF._writeIFD(bin, types, data, eoff, ifd["exifIFD"]);
			val = [eoff];  eoff = outp[1];
		}
		if(tag==34853) {
			var outp = UTIF._writeIFD(bin, UTIF._types.gps, data, eoff, ifd["gpsiIFD"]);
			val = [eoff];  eoff = outp[1];
		}
		if(type==2) val=val[0]+"\u0000";  var num = val.length;
		bin.writeUshort(data, offset, tag );  offset+=2;
		bin.writeUshort(data, offset, type);  offset+=2;
		bin.writeUint  (data, offset, num );  offset+=4;

		var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;  //if(dlen<1) throw "e";
		var toff = offset;
		if(dlen>4) {  bin.writeUint(data, offset, eoff);  toff=eoff;  }

		if     (type== 1 || type==7) {  for(var i=0; i<num; i++) data[toff+i] = val[i];  }
		else if(type== 2) {  bin.writeASCII(data, toff, val);   }
		else if(type== 3) {  for(var i=0; i<num; i++) bin.writeUshort(data, toff+2*i, val[i]);    }
		else if(type== 4) {  for(var i=0; i<num; i++) bin.writeUint  (data, toff+4*i, val[i]);    }
		else if(type== 5 || type==10) {  
			var wr = type==5?bin.writeUint:bin.writeInt;
			for(var i=0; i<num; i++) {  
			var v=val[i],nu=v[0],de=v[1];  if(nu==null) throw "e";  wr(data, toff+8*i, nu);  wr(data, toff+8*i+4, de);  }   }
		else if(type== 9) {  for(var i=0; i<num; i++) bin.writeInt   (data, toff+4*i, val[i]);    }
		else if(type==12) {  for(var i=0; i<num; i++) bin.writeDouble(data, toff+8*i, val[i]);    }
		else throw type;

		if(dlen>4) {  dlen += (dlen&1);  eoff += dlen;  }
		offset += 4;
	}
	return [offset, eoff];
}

UTIF.toRGBA8 = function(out, scl)
{
	var w = out.width, h = out.height, area = w*h, qarea = area*4, data = out.data;
	var img = new Uint8Array(area*4);
	//console.log(out);
	// 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK
	var intp = (out["t262"] ? out["t262"][0]: 2), bps = (out["t258"]?Math.min(32,out["t258"][0]):1);
	if(out["t262"]==null && bps==1) intp=0;
	//log("interpretation: ", intp, "bps", bps, out);
	if(false) {}
	else if(intp==0)
	{
		var bpl = Math.ceil(bps*w/8);
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))& 1;  img[qi]=img[qi+1]=img[qi+2]=( 1-px)*255;  img[qi+3]=255;    }
			if(bps== 4) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>1)])>>(4-4*(i&1)))&15;  img[qi]=img[qi+1]=img[qi+2]=(15-px)* 17;  img[qi+3]=255;    }
			if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i];  img[qi]=img[qi+1]=img[qi+2]=255-px;  img[qi+3]=255;    }
		}
	}
	else if(intp==1)
	{
		var smpls = out["t258"]?out["t258"].length : 1;
		var bpl = Math.ceil(smpls*bps*w/8);
		if(scl==null) scl=1/256;
		
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))&1;   img[qi]=img[qi+1]=img[qi+2]=(px)*255;  img[qi+3]=255;    }
			if(bps== 2) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>2)])>>(6-2*(i&3)))&3;   img[qi]=img[qi+1]=img[qi+2]=(px)* 85;  img[qi+3]=255;    }
			if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i*smpls];  img[qi]=img[qi+1]=img[qi+2]=    px;  img[qi+3]=255;    }
			if(bps==16) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=off+(2*i), px=(data[o+1]<<8)|data[o];  img[qi]=img[qi+1]=img[qi+2]= Math.min(255,~~(px*scl));  img[qi+3]=255;    } // ladoga.tif
		}
	}
	else if(intp==2)
	{
		var smpls = out["t258"]?out["t258"].length : 3;
		
		if(bps== 8) 
		{
			if(smpls==4) for(var i=0; i<qarea; i++) img[i] = data[i];
			if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  img[qi+3]=255;    }
		}
		else{  // 3x 16-bit channel
			if(smpls==4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*8+1;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=data[ti+6];    }
			if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6+1;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=255;           }
		}
	}
	else if(intp==3)
	{
		var map = out["t320"];
		var smpls = out["t258"]?out["t258"].length : 1;
		var bpl = Math.ceil(smpls*bps*w/8);
		var cn = 1<<bps;
		
		for(var y=0; y<h; y++) 
			for(var x=0; x<w; x++) {  
				var i = y*w+x;
				var qi=i<<2, mi=0;
				var dof = y*bpl;
				if(false) {}
				else if(bps==1) mi=(data[dof+(x>>>3)]>>>(7-(x&7)))&1;
				else if(bps==4) mi=(data[dof+(x>>>1)]>>>(4-4*(x&1)))&15;
				else if(bps==8) mi= data[dof+x*smpls]; 
				else throw bps;
				img[qi]=(map[mi]>>8);  img[qi+1]=(map[cn+mi]>>8);  img[qi+2]=(map[cn+cn+mi]>>8);  img[qi+3]=255;   
			}
	}
	else if(intp==5) 
	{
		var smpls = out["t258"]?out["t258"].length : 4;
		var gotAlpha = smpls>4 ? 1 : 0;
		for(var i=0; i<area; i++) {
			var qi=i<<2, si=i*smpls;  var C=255-data[si], M=255-data[si+1], Y=255-data[si+2], K=(255-data[si+3])*(1/255);
			img[qi]=~~(C*K+0.5);  img[qi+1]=~~(M*K+0.5);  img[qi+2]=~~(Y*K+0.5);  img[qi+3]=255*(1-gotAlpha)+data[si+4]*gotAlpha;
		}
	}
	else if(intp==6 && out["t278"]) {  // only for DSC_1538.TIF
		var rps = out["t278"][0];
		for(var y=0; y<h; y+=rps) {
			var i=(y*w), len = rps*w;
			
			for(var j=0; j<len; j++) {
				var qi = 4*(i+j), si = 3*i+4*(j>>>1);
				var Y = data[si+(j&1)], Cb=data[si+2]-128, Cr=data[si+3]-128;
				
				var r = Y + ( (Cr >> 2) + (Cr >> 3) + (Cr >> 5) ) ;
				var g = Y - ( (Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ( (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5)) ;
				var b = Y + ( Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6)) ;
				
				img[qi  ]=Math.max(0,Math.min(255,r));
				img[qi+1]=Math.max(0,Math.min(255,g));
				img[qi+2]=Math.max(0,Math.min(255,b));
				img[qi+3]=255;
			}
		}
	}
	else log("Unknown Photometric interpretation: "+intp);
	return img;
}

function RGBAtoRGB(r, g, b, a, r2,g2,b2){
  a=a/255;
  var r3 = Math.round(((1 - a) * r2) + (a * r))
  var g3 = Math.round(((1 - a) * g2) + (a * g))
  var b3 = Math.round(((1 - a) * b2) + (a * b))
  return {r:r3,g:g3,b:b3}
} 
function RGB2GRAY(rgb){
  return Math.round((rgb.r+rgb.g+rgb.b)/3);
}

// w/o alpha channel
UTIF.toRGB8 = function(out, scl)
{
    ////////////////////
    // Requires RGBAtoRGB!
    ////////////////////
	var w = out.width, h = out.height, area = w*h, qarea = area*4, data = out.data;
	var img = new Uint8Array(area*3);
	//console.log(out);
	// 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK
	var intp = (out["t262"] ? out["t262"][0]: 2), bps = (out["t258"]?Math.min(32,out["t258"][0]):1);
	if(out["t262"]==null && bps==1) intp=0;
	//log("interpretation: ", intp, "bps", bps, out);
	if(false) {}
	else if(intp==0)
	{
		var bpl = Math.ceil(bps*w/8);
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, px=((data[off+(i>>3)])>>(7-  (i&7)))& 1; 
              img[qi]=img[qi+1]=img[qi+2]=( 1-px)*255;  
              // img[qi+3]=255;    
            }
			if(bps== 4) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, px=((data[off+(i>>1)])>>(4-4*(i&1)))&15;  
              img[qi]=img[qi+1]=img[qi+2]=(15-px)* 17;  
              // img[qi+3]=255;    
            }
			if(bps== 8) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, px=data[off+i];  
              img[qi]=img[qi+1]=img[qi+2]=255-px;  
              // img[qi+3]=255;    
            }
		}
	}
	else if(intp==1)
	{
		var smpls = out["t258"]?out["t258"].length : 1;
		var bpl = Math.ceil(smpls*bps*w/8);
		if(scl==null) scl=1/256;
		
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, px=((data[off+(i>>3)])>>(7-  (i&7)))&1;   
              img[qi]=img[qi+1]=img[qi+2]=(px)*255;  
              // img[qi+3]=255;    
            }
			if(bps== 2) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, px=((data[off+(i>>2)])>>(6-2*(i&3)))&3;   
              img[qi]=img[qi+1]=img[qi+2]=(px)* 85;  
              // img[qi+3]=255;    
            }
			if(bps== 8) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, px=data[off+i*smpls];  
              img[qi]=img[qi+1]=img[qi+2]=    px;  
              // img[qi+3]=255;    
            }
			if(bps==16) for(var i=0; i<w; i++) {  
              var qi=(io+i)*3, o=off+(2*i), px=(data[o+1]<<8)|data[o];  
              img[qi]=img[qi+1]=img[qi+2]= Math.min(255,~~(px*scl));  
              // img[qi+3]=255;    
            } // ladoga.tif
		}
	}
	else if(intp==2)
	{
		var smpls = out["t258"]?out["t258"].length : 3;
		
		if(bps== 8) 
		{
            var qi=0;
			if(smpls==4) for(var i=0; i<qarea; i++) {
              // 4/3 down sampling
              if ((i % 4)==0) {
                var r=data[i],g=data[i+1],b=data[i+2],a=data[i+3],rgb=RGBAtoRGB(r,g,b,a,255,255,255);
                img[qi] = rgb.r; img[qi+1] = rgb.g; img[qi+2] = rgb.b; 
                qi += 3;
              }
              
            }
			if(smpls==3) for(var i=0; i<area; i++) {  
              var qi=i*3, ti=i*3;  
              img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  
              // img[qi+3]=255;    
            }
		}
		else{  // 3x 16-bit channel
			if(smpls==4) for(var i=0; i<area; i++) {  
              var qi=i*3, ti=i*8+1; 
              var rgb=RGBAtoRGB(data[ti],data[ti+2],data[ti+4],data[ti+3],255,255,255);
              img[qi]=rgb.r;  img[qi+1]=rgb.g;  img[qi+2]=rgb.b;  
              // img[qi+3]=data[ti+6];    
            }
			if(smpls==3) for(var i=0; i<area; i++) {  
              var qi=i*3, ti=i*6+1;  
              img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  
              // img[qi+3]=255;           
            }
		}
	}
	else if(intp==3)
	{
		var map = out["t320"];
		var smpls = out["t258"]?out["t258"].length : 1;
		var bpl = Math.ceil(smpls*bps*w/8);
		var cn = 1<<bps;
		
		for(var y=0; y<h; y++) 
			for(var x=0; x<w; x++) {  
				var i = y*w+x;
				var qi=i*3, mi=0;
				var dof = y*bpl;
				if(false) {}
				else if(bps==1) mi=(data[dof+(x>>>3)]>>>(7-(x&7)))&1;
				else if(bps==4) mi=(data[dof+(x>>>1)]>>>(4-4*(x&1)))&15;
				else if(bps==8) mi= data[dof+x*smpls]; 
				else throw bps;
				img[qi]=(map[mi]>>8);  img[qi+1]=(map[cn+mi]>>8);  img[qi+2]=(map[cn+cn+mi]>>8);  
                // img[qi+3]=255;   
			}
	}
	else if(intp==5) 
	{
		var smpls = out["t258"]?out["t258"].length : 4;
		var gotAlpha = smpls>4 ? 1 : 0;
		for(var i=0; i<area; i++) {
			var qi=i*3, si=i*smpls;  var C=255-data[si], M=255-data[si+1], Y=255-data[si+2], K=(255-data[si+3])*(1/255);
            var rgb=RGBAtoRGB(~~(C*K+0.5),~~(M*K+0.5),~~(Y*K+0.5),255*(1-gotAlpha)+data[si+4]*gotAlpha,255,255,255);
            img[qi] = rgb.r; img[qi+1] = rgb.g; img[qi+2] = rgb.b;             
			// img[qi]=~~(C*K+0.5);  img[qi+1]=~~(M*K+0.5);  img[qi+2]=~~(Y*K+0.5);  
            // img[qi+3]=255*(1-gotAlpha)+data[si+4]*gotAlpha;
		}
	}
	else if(intp==6 && out["t278"]) {  // only for DSC_1538.TIF
		var rps = out["t278"][0];
		for(var y=0; y<h; y+=rps) {
			var i=(y*w), len = rps*w;
			
			for(var j=0; j<len; j++) {
				var qi = 3*(i+j), si = 3*i+4*(j>>>1);
				var Y = data[si+(j&1)], Cb=data[si+2]-128, Cr=data[si+3]-128;
				
				var r = Y + ( (Cr >> 2) + (Cr >> 3) + (Cr >> 5) ) ;
				var g = Y - ( (Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ( (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5)) ;
				var b = Y + ( Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6)) ;
				
				img[qi  ]=Math.max(0,Math.min(255,r));
				img[qi+1]=Math.max(0,Math.min(255,g));
				img[qi+2]=Math.max(0,Math.min(255,b));
				// img[qi+3]=255;
			}
		}
	}
	else log("Unknown Photometric interpretation: "+intp);
	return img;
}

// Returns gray-level transformed image
UTIF.toGRAY8 = function(out, scl)
{
    ////////////////////
    // Requires RGBAtoRGB!
    ////////////////////
	var w = out.width, h = out.height, area = w*h, qarea = area*4, data = out.data;
	var img = new Uint8Array(area);
	//console.log(out);
	// 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK
	var intp = (out["t262"] ? out["t262"][0]: 2), bps = (out["t258"]?Math.min(32,out["t258"][0]):1);
	if(out["t262"]==null && bps==1) intp=0;
	//log("interpretation: ", intp, "bps", bps, out);
	if(false) {}
	else if(intp==0)
	{
		var bpl = Math.ceil(bps*w/8);
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  
              var qi=(io+i), px=((data[off+(i>>3)])>>(7-  (i&7)))& 1; 
              img[qi]=( 1-px)*255;  
            }
			if(bps== 4) for(var i=0; i<w; i++) {  
              var qi=(io+i), px=((data[off+(i>>1)])>>(4-4*(i&1)))&15;  
              img[qi]=(15-px)* 17;  
            }
			if(bps== 8) for(var i=0; i<w; i++) {  
              var qi=(io+i), px=data[off+i];  
              img[qi]=255-px;  
            }
		}
	}
	else if(intp==1)
	{
		var smpls = out["t258"]?out["t258"].length : 1;
		var bpl = Math.ceil(smpls*bps*w/8);
		if(scl==null) scl=1/256;
		
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  
              var qi=(io+i), px=((data[off+(i>>3)])>>(7-  (i&7)))&1;   
              img[qi]=(px)*255;  
            }
			if(bps== 2) for(var i=0; i<w; i++) {  
              var qi=(io+i), px=((data[off+(i>>2)])>>(6-2*(i&3)))&3;   
              img[qi]=(px)* 85;  
            }
			if(bps== 8) for(var i=0; i<w; i++) {  
              var qi=(io+i), px=data[off+i*smpls];  
              img[qi]=px;  
            }
			if(bps==16) for(var i=0; i<w; i++) {  
              var qi=(io+i), o=off+(2*i), px=(data[o+1]<<8)|data[o];  
              img[qi]=Math.min(255,~~(px*scl));  
            } // ladoga.tif
		}
	}
	else if(intp==2)
	{
		var smpls = out["t258"]?out["t258"].length : 3;
		
		if(bps== 8) 
		{
            var qi=0;
			if(smpls==4) for(var i=0; i<qarea; i++) {
              // 4/3 down sampling
              if ((i % 4)==0) {
                var r=data[i],g=data[i+1],b=data[i+2],a=data[i+3],rgb=RGBAtoRGB(r,g,b,a,255,255,255);
                img[qi] = RGB2GRAY(rgb); 
                qi += 1;
              }
              
            }
			if(smpls==3) for(var i=0; i<area; i++) {  
              var qi=i, ti=i*3;  
              img[qi]=RGB2GRAY({r:data[ti],g:data[ti+1],b:data[ti+2]});  
            }
		}
		else{  // 3x 16-bit channel
			if(smpls==4) for(var i=0; i<area; i++) {  
              var qi=i, ti=i*8+1; 
              var rgb=RGBAtoRGB(data[ti],data[ti+2],data[ti+4],data[ti+3],255,255,255);
              img[qi]=RGB2GRAY(rgb);  
            }
			if(smpls==3) for(var i=0; i<area; i++) {  
              var qi=i, ti=i*6+1;  
              img[qi]=RGB2GRAY({r:data[ti],g:data[ti+2],b:data[ti+4]});  
            }
		}
	}
	else if(intp==3)
	{
		var map = out["t320"];
		var smpls = out["t258"]?out["t258"].length : 1;
		var bpl = Math.ceil(smpls*bps*w/8);
		var cn = 1<<bps;
		
		for(var y=0; y<h; y++) 
			for(var x=0; x<w; x++) {  
				var i = y*w+x;
				var qi=i, mi=0;
				var dof = y*bpl;
				if(false) {}
				else if(bps==1) mi=(data[dof+(x>>>3)]>>>(7-(x&7)))&1;
				else if(bps==4) mi=(data[dof+(x>>>1)]>>>(4-4*(x&1)))&15;
				else if(bps==8) mi= data[dof+x*smpls]; 
				else throw bps;
				img[qi]=RGB2GRAY({r:(map[mi]>>8),g:(map[cn+mi]>>8),b:(map[cn+cn+mi]>>8)});  
			}
	}
	else if(intp==5) 
	{
		var smpls = out["t258"]?out["t258"].length : 4;
		var gotAlpha = smpls>4 ? 1 : 0;
		for(var i=0; i<area; i++) {
			var qi=i, si=i*smpls;  var C=255-data[si], M=255-data[si+1], Y=255-data[si+2], K=(255-data[si+3])*(1/255);
            var rgb=RGBAtoRGB(~~(C*K+0.5),~~(M*K+0.5),~~(Y*K+0.5),255*(1-gotAlpha)+data[si+4]*gotAlpha,255,255,255);
            img[qi] = RGB2GRAY(rgb);             
			// img[qi]=~~(C*K+0.5);  img[qi+1]=~~(M*K+0.5);  img[qi+2]=~~(Y*K+0.5);  
            // img[qi+3]=255*(1-gotAlpha)+data[si+4]*gotAlpha;
		}
	}
	else if(intp==6 && out["t278"]) {  // only for DSC_1538.TIF
		var rps = out["t278"][0];
		for(var y=0; y<h; y+=rps) {
			var i=(y*w), len = rps*w;
			
			for(var j=0; j<len; j++) {
				var qi = (i+j), si = 3*i+4*(j>>>1);
				var Y = data[si+(j&1)], Cb=data[si+2]-128, Cr=data[si+3]-128;
				
				var r = Y + ( (Cr >> 2) + (Cr >> 3) + (Cr >> 5) ) ;
				var g = Y - ( (Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ( (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5)) ;
				var b = Y + ( Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6)) ;
				
				img[qi  ]=RGB2GRAY({
                  r:Math.max(0,Math.min(255,r)),
				  g:Math.max(0,Math.min(255,g)),
				  b:Math.max(0,Math.min(255,b))
                });
				// img[qi+3]=255;
			}
		}
	}
	else log("Unknown Photometric interpretation: "+intp);
	return img;
}

UTIF.replaceIMG = function(imgs)
{
	if(imgs==null) imgs = document.getElementsByTagName("img");
	var sufs = ["tif","tiff","dng","cr2","nef"]
	for (var i=0; i<imgs.length; i++)
	{
		var img=imgs[i], src=img.getAttribute("src");  if(src==null) continue;
		var suff=src.split(".").pop().toLowerCase();
		if(sufs.indexOf(suff)==-1) continue;
		var xhr = new XMLHttpRequest();  UTIF._xhrs.push(xhr);  UTIF._imgs.push(img);
		xhr.open("GET", src);  xhr.responseType = "arraybuffer";
		xhr.onload = UTIF._imgLoaded;   xhr.send();
	}
}

UTIF._xhrs = [];  UTIF._imgs = [];
UTIF._imgLoaded = function(e)
{
	var buff = e.target.response;
	var ifds = UTIF.decode(buff);  //console.log(ifds);
	var vsns = ifds, ma=0, page=vsns[0];  if(ifds[0].subIFD) vsns = vsns.concat(ifds[0].subIFD);
	for(var i=0; i<vsns.length; i++) {
		var img = vsns[i];
		if(img["t258"]==null || img["t258"].length<3) continue;
		var ar = img["t256"]*img["t257"];
		if(ar>ma) {  ma=ar;  page=img;  }
	}
	UTIF.decodeImage(buff, page, ifds);
	var rgba = UTIF.toRGBA8(page), w=page.width, h=page.height;
	var ind = UTIF._xhrs.indexOf(e.target), img = UTIF._imgs[ind];
	UTIF._xhrs.splice(ind,1);  UTIF._imgs.splice(ind,1);
	var cnv = document.createElement("canvas");  cnv.width=w;  cnv.height=h;
	var ctx = cnv.getContext("2d");
	var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer),w,h);
	/*imgd = ctx.createImageData(w,h);
	for(var i=0; i<rgba.length; i++) imgd.data[i]=rgba[i];   */    
	ctx.putImageData(imgd,0,0);
	img.setAttribute("src",cnv.toDataURL());
}


UTIF._binBE =
{
	nextZero   : function(data, o) {  while(data[o]!=0) o++;  return o;  },
	readUshort : function(buff, p) {  return (buff[p]<< 8) |  buff[p+1];  },
	readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+1];  a[1]=buff[p+0];                                    return UTIF._binBE. i16[0];  },
	readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE. i32[0];  },
	readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE.ui32[0];  },
	readASCII  : function(buff, p, l) {  var s = "";   for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);   return s; },
	readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+3-i];  return UTIF._binBE.fl32[0];  },
	readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+7-i];  return UTIF._binBE.fl64[0];  },

	writeUshort: function(buff, p, n) {  buff[p] = (n>> 8)&255;  buff[p+1] =  n&255;  },
	writeInt   : function(buff, p, n) {  var a=UTIF._binBE.ui8;  UTIF._binBE.i32[0]=n;  buff[p+3]=a[0];  buff[p+2]=a[1];  buff[p+1]=a[2];  buff[p+0]=a[3];  },
	writeUint  : function(buff, p, n) {  buff[p] = (n>>24)&255;  buff[p+1] = (n>>16)&255;  buff[p+2] = (n>>8)&255;  buff[p+3] = (n>>0)&255;  },
	writeASCII : function(buff, p, s) {  for(var i = 0; i < s.length; i++)  buff[p+i] = s.charCodeAt(i);  },
	writeDouble: function(buff, p, n)
	{
		UTIF._binBE.fl64[0] = n;
		for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];
	}
}
UTIF._binBE.ui8  = new Uint8Array  (8);
UTIF._binBE.i16  = new Int16Array  (UTIF._binBE.ui8.buffer);
UTIF._binBE.i32  = new Int32Array  (UTIF._binBE.ui8.buffer);
UTIF._binBE.ui32 = new Uint32Array (UTIF._binBE.ui8.buffer);
UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer);
UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer);

UTIF._binLE =
{
	nextZero   : UTIF._binBE.nextZero,
	readUshort : function(buff, p) {  return (buff[p+1]<< 8) |  buff[p];  },
	readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];                                    return UTIF._binBE. i16[0];  },
	readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE. i32[0];  },
	readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE.ui32[0];  },
	readASCII  : UTIF._binBE.readASCII,
	readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl32[0];  },
	readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl64[0];  },
	
	writeUshort: function(buff, p, n) {  buff[p] = (n)&255;  buff[p+1] =  (n>>8)&255;  },
	writeInt   : function(buff, p, n) {  var a=UTIF._binBE.ui8;  UTIF._binBE.i32[0]=n;  buff[p+0]=a[0];  buff[p+1]=a[1];  buff[p+2]=a[2];  buff[p+3]=a[3];  },
	writeUint  : function(buff, p, n) {  buff[p] = (n>>>0)&255;  buff[p+1] = (n>>>8)&255;  buff[p+2] = (n>>>16)&255;  buff[p+3] = (n>>>24)&255;  },
	writeASCII : UTIF._binBE.writeASCII
}
UTIF._copyTile = function(tb, tw, th, b, w, h, xoff, yoff)
{
	//log("copyTile", tw, th,  w, h, xoff, yoff);
	var xlim = Math.min(tw, w-xoff);
	var ylim = Math.min(th, h-yoff);
	for(var y=0; y<ylim; y++)
	{
		var tof = (yoff+y)*w+xoff;
		var sof = y*tw;
		for(var x=0; x<xlim; x++) b[tof+x] = tb[sof+x];
	}
}

UTIF.LosslessJpegDecode = function(){var I,C,o,m,a,z,E,A,u,v;function i(){return I[C++]}function q(){return I[C++]<<8|I[C++]}function s(){var w=i(),r=[0,0,0,255],p=[],D=8;
for(var k=0;k<16;k++)p[k]=i();for(var k=0;k<16;k++){for(var B=0;B<p[k];B++){var G=t(r,0,k+1,1);r[G+3]=i()}}var j=new Uint8Array(1<<D);
u[w]=[new Uint8Array(r),j];for(var k=0;k<1<<D;k++){var g=D,n=k,F=0,x=0;while(r[F+3]==255&&g!=0){x=n>>--g&1;
F=r[F+x]}j[k]=F}}function t(w,r,p,k){if(w[r+3]!=255)return 0;if(p==0)return r;for(var B=0;B<2;B++){if(w[r+B]==0){w[r+B]=w.length;
w.push(0,0,k,255)}var G=t(w,w[r+B],p-1,k+1);if(G!=0)return G}return 0}function H(w){var r=w.a,p=w.d;
while(r<25&&w.c<w.e){var k=w.data[w.c++];if(!w.b)w.c+=k+1>>>8;p=p<<8|k;r+=8}w.a=r;w.d=p}function b(w,r){if(r.a<w)H(r);
return r.d>>(r.a-=w)&65535>>16-w}function c(w,r){var p=w[0],k=0,B=255,G=0;if(r.a<16)H(r);var D=r.d>>r.a-8&255;
k=w[1][D];B=p[k+3];r.a-=p[k+2];while(B==255){G=r.d>>--r.a&1;k=p[k+G];B=p[k+3]}return B}function d(w,r){if(w<32768>>16-r)w+=-(1<<r)+1;
return w}function h(w,r){var p=c(w,r);if(p==0)return 0;var k=b(p,r);return d(k,p)}function f(w,r,p){var k=z,B=m,G=E,D=v;
for(var j=0;j<k;j++){w[j]=h(D[j],p)+(1<<o-1)}for(var g=k;g<r;g+=k){for(var j=0;j<k;j++)w[g+j]=h(D[j],p)+w[g+j-k]}var n=r;
for(var F=1;F<B;F++){for(var j=0;j<k;j++){w[n+j]=h(D[j],p)+w[n+j-r]}for(var g=k;g<r;g+=k){for(var j=0;
j<k;j++){var x=n+g+j,y=w[x-k];if(G==1){}else if(G==6)y=w[x-r]+(y-w[x-k-r]>>>1);else if(G==7)y=y+w[x-r]>>>1;
else throw G;w[x]=y+h(D[j],p)}}n+=r}}function J(w,r){var p=b(w,r);return w==16?-32768:d(p,w)}function e(w,r,p){var k=I.length-C;
for(var B=0;B<k;B+=4){var G=I[C+B];I[C+B]=I[C+B+3];I[C+B+3]=G;var G=I[C+B+1];I[C+B+1]=I[C+B+2];I[C+B+2]=G}var D=v[0];
for(var j=0;j<m;j++){var g=32768,n=32768;for(var F=0;F<r;F+=2){var x=c(D,p),y=c(D,p);if(x!=0)g+=J(x,p);
if(y!=0)n+=J(y,p);w[j*r+F]=g&65535;w[j*r+F+1]=n&65535}}}function l(w){I=w;C=0;u=[],v=[];if(q()!=65496)throw"e";
while(!0){var r=q();if(r==65535){C--;continue}var p=q();if(r==65475){o=i();m=q();a=q();z=i();A=[];for(var k=0;
k<z;k++){var B=i(),G=i();if(G!=17)throw"e";var D=i();if(D!=0)throw"e";A[B]=k}}else if(r==65476){var j=C+p-2;
while(C<j)s()}else if(r==65498){C++;for(var k=0;k<z;k++){var g=i();v[A[g]]=u[i()>>>4]}E=i();C+=2;break}else{C+=p-2}}var n=o>8?Uint16Array:Uint8Array,F=a*z,x=new n(m*F),y={a:0,d:0,b:E==8,c:C,data:I,e:I.length};
if(y.b)e(x,F,y);else f(x,F,y);return x}return l}()




})(UTIF, pako);
})();
};
BundleModuleCode['cache']=function (module,exports){
// https://github.com/naugtur/safe-memory-cache
// Universal size- and volume constrained cache module
/*
typeof @options = {
  limit   : 40,
  volume  : 1E5,
  maxTTL  : 60000,
  buckets : 4,
  cleanupListener : function (dropped) {
    print(Array.from( dropped.keys() ))
  },
*/
function createMem(number, limit, volume) {
    var mem = Object.create(bucketsProto)
    mem.N = number
    mem.max = limit
    mem.maxVolume = volume
    mem.clear()
    return mem
}

function sizeOf(o) {
  if (typeof o == 'string') return 8;
  if (o instanceof Array) return 8;
  if (o instanceof Uint8Array) return 1;
  if (o instanceof Uint16Array) return 2;
  if (o instanceof Uint32Array) return 4;
  if (o instanceof Int8Array) return 1;
  if (o instanceof Int16Array) return 2;
  if (o instanceof Int32Array) return 4;
  if (o instanceof Float32Array) return 4;
  if (o instanceof Float64Array) return 8;
}

var bucketsProto = {
    clear: function clear() {
        this.size = 0;
        this.volume = 0;  // TODO: volumen / bucket
        this.buckets = [];
        for (var i = 0; i < this.N; i++) {
            this.spawnBucket()
        }
    },
    spawnBucket: function spawnBucket() {
        this.buckets.unshift(new Map())
    },
    rotateBuckets: function rotateBuckets() {
        var dropped = this.buckets.pop()
        this.spawnBucket()
        this.size = 0;
        this.volume = 0;
        if (this.rotationHook) {
            this.rotationHook(dropped)
        }
    },
    set: function set(key, value) {
        if (!(this.buckets[0].has(key))) {
            this.size++;
            if (value.length) this.volume += (value.length*8);
            else if (value.data && value.data.length) {
              this.volume += (value.data.length*4) // TODO
            }
            if ((this.max && this.size >= Math.ceil(this.max / this.buckets.length)) ||
                (this.maxVolume && this.volume >= Math.ceil(this.maxVolume / this.buckets.length))) {
                this.rotateBuckets()
            }
        }
        this.buckets[0].set(key, value)
        return value
    },
    get: function get(key) {
        for (var i = 0; i < this.buckets.length; i++) {
            if (this.buckets[i].has(key)) {
                //todo: this should be configurable
                if (i) {
                    //put a reference in the newest bucket
                    return this.set(key, this.buckets[i].get(key))
                }
                return this.buckets[i].get(key)
            }
        }
    }
}



module.exports = 
    function safeMemoryCache(opts) {
        opts=opts||{};
        var buckets = ~~(opts.buckets) || 4;
        var mem = createMem(buckets, opts.limit || 100, opts.volume|| 1E6)
        mem.rotationHook = opts.cleanupListener || null

        if (opts.maxTTL) {
            var intervalHandle = setInterval(mem.rotateBuckets.bind(mem), ~~(opts.maxTTL / buckets))
        }

        return {
            set: mem.set.bind(mem),
            get: mem.get.bind(mem),
            clear: mem.clear.bind(mem),
            destroy: function () {
                clearInterval(intervalHandle)
            },
            _get_buckets: function () {
                return mem.buckets
            },
            _rotate_buckets: function () {
                return mem.rotateBuckets()
            }
        }

    }

};
BundleModuleCode['plugins/math/math']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.48.1X
 **
 **    $INFO:
 **
 **  Extended math Library
 **
 **    $ENDOFINFO
 */

if (typeof Utils == 'undefined') Require('plugins/com/utils')
var MatrixTA = Require('plugins/math/matrixTA')
  MatrixTA.EVD = Require('plugins/math/matrixTA-EVD');
  MatrixTA.SVD = Require('plugins/math/matrixTA-SVD');
  
var VectorTA = Require('plugins/math/vectorTA')
var Matrix  = Require('plugins/math/matrix')
var Vector  = Require('plugins/math/vector')
var Line    = Require('plugins/math/line')
var Plane   = Require('plugins/math/plane')
var Stats   = Require('plugins/math/stats')
var DWT     = Require('plugins/math/dwt5')
var Numeric = Require('plugins/math/numeric')
var Regression  = Require('plugins/math/regression')
var Polyfit     = Require('plugins/math/polyfit')
var Smoothers   = Require('plugins/math/smoothers')
var LinLogReg   = Require('plugins/ml/reg')
var Bin   = Require('plugins/math/data-bin')
Require('plugins/math/matja')
var Points = Require('plugins/math/points');
var Vol    = Require('plugins/math/vol');

var MAN  = FileEmbedded('plugins/math/help.md','utf8');
Math.help = function (topic) {
  // TODO
  return MAN
}

// Generic array vector & matrix modules
Math.Line     = Line;
Math.Matrix   = Matrix;
Math.Plane    = Plane;
Math.Vector   = Vector;
Math.DWT      = DWT;
Math.numeric  = Numeric;
Math.regression = {
  polyfit : Polyfit,
  linlog  : LinLogReg,
  regression : Regression,
  smoothers : Smoothers,
};
Math.statistics = Stats;

// Typedarray vector & matrix modules
Math.MatrixTA = MatrixTA;
Math.VectorTA = VectorTA;
Math.Vol3      = Vol.Vol3;

var FFT     = Require('plugins/math/fft')
Math.FFT    = FFT;
var CONV    = Require('plugins/math/conv')
Math.Convolution = CONV;

Math.points = Points;

Math.version  = '1.49.1X'

var none = null;

// Dynamic array method extensions (more extension in MatrixTA!)
Object.addProperty(Array,'abs', function () {
  return this.map(Math.abs)
})
Object.addProperty(Array,'add', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b+v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b+v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]+v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]+v })});
  }
})
Object.addProperty(Array,'append', function (a) {
  for(var i=0;i<a.length;i++) this.push(a[i]);
  return this
})

Object.addProperty(Array,'contains', function (elements,test,single) {
  if (Utils.isArray(elements) && !single)  {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (this[i]==elements[j]) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        for(var j=0;j<elements.length;j++) if (test(this[i],elements[j])) return true;  
      } 
  
  } else {
    if (!test) 
      for(var i=0;i<this.length;i++) {
        if (this[i]==elements) return true;  
      } 
    else 
      for(var i=0;i<this.length;i++) {
        if (test(this[i],elements)) return true;  
      } 
  }
  return false;
})
Object.addProperty(Array,'div', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v/b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v/b[j][i] })});
  }
})
Object.addProperty(Array,'extend', function (array) {
  for(var i=0;i<array.length;i++) this.push(array[i]);
  return this;
})
if (!Array.prototype.flat) {
  Object.addProperty(Array,'flat', function flat () {
    var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

    return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
      if (Array.isArray(cur)) {
        acc.push.apply(acc, flat.call(cur, depth - 1));
      } else {
        acc.push(cur);
      }
      return acc;
    }, []) : Array.prototype.slice.call(this);
  })
}

Object.addProperty(Array,'head', function (num) {
  return this.slice(0,num||1);
})

Object.addProperty(Array,'index', function (offset) {
  offset=offset||0;
  return this.map(function (v,i) { return i+offset });
})

Object.addProperty(Array,'mul', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b*v });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b*v })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return b[i]*v });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return b[j][i]*v })});
  }
})

if (!Array.prototype.includes) {
  Object.addProperty(Array,'includes', function (r,e) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var t = Object(this),
            n = t.length >>> 0;
        if (0 === n) return !1;
        var i, o, a = 0 | e,
            u = Math.max(0 <= a ? a : n - Math.abs(a), 0);
        for (; u < n;) {
            if ((i = t[u]) === (o = r) || "number" == typeof i && "number" == typeof o && isNaN(i) && isNaN(o)) return !0;
            u++
        }
        return !1
    });
};
Object.addProperty(Array,'intersect', function (second) {
  var result=[];
  for(var i=0;i<this.length;i++) {
    for(var j=0;j<second.length;j++)
      if (Math.equal(this[i],second[j])) result.push(this[i]);
  }
  return result;
})

Object.addProperty(Array,'loop', function (callback,tmo) {
  var self=this;
  Code.later(tmo||1,function (id,index) {
    callback(self[index],index);
    return index<(self.length-1);
  })
})

Object.addProperty(Array,'match', function (test) {
  if (test.length != this.length) return false;
  for(var i=0;i<this.length;i++) if (this[i]!=test[i]) return false;
  return true;
})

Object.addProperty(Array,'pad', function (size,v,left) {
  v=v||0;
  if (size<this.length) return this.slice();
  var ext = Array.init(size-this.length,v);
  if (!left) return this.concat(ext);
  else return ext.concat(this);
})

Object.addProperty(Array,'sample', function (frag,filter) {
  var m = Math.floor(this.length/frag),
      i,
      fn,
      s=0,
      res=[];
  filter=filter||'mean';
  switch (filter) {
    case 'mean':
      fn=function (a,b,i) {
        if (i!=frag-1) return a+b;
        else return (a+b)/frag;
      };
      break;
    case 'peak':
      fn=function (a,b,i) {
        return a>b?a:b;
      };
      break;
  }
  for(i=0;i<m;i++) {
    s=this.slice(i*frag,i*frag+frag).reduce(fn);
    res.push(s);
  }
  return res;
})
Object.addProperty(Array,'search', function (test) {
  for(var i=0;i<this.length;i++) if (test(this[i])) return this[i];
  return
})

// Shuffle array randomly (uniform distribution)
// if weak is set true then the original
// element position acts like a magnet, i.e.,
// elements are stay mostly in their array original region
// (localized non-uniform distribution)
Object.addProperty(Array,'shuffle', function (weak) {
  if (weak) return this.slice().sort(function () { return Math.random()-0.5 });
  var array=this;
  for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;  
});

Object.addProperty(Array,'split', function (frag) {
  var rows = this.length/frag,
      cols = frag,
      j,
      mat=[];
  for(j=0;j<rows;j++) {
    mat.push(this.slice(j*cols,j*cols+cols));
  }
  return mat;
})
Object.addProperty(Array,'subtract', function (b) {
  if (typeof b == 'number') {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b });  
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b })});
  } else {
    if (!Utils.isArray(this[0]))
      return this.map(function (v,i) { return v-b[i] });
    else
      return this.map(function (row,j) { return row.map(function (v,i) { return v-b[j][i] })});
  }
})
Object.addProperty(Array,'tail', function (num) {
  return this.slice(this.length-(num||1));
})
Object.addProperty(Array,'toObject', function (keys) {
  var o={};
  for(var i=0;i<this.length;i++) {
    var key = keys?keys[i]||String(i):String(i);
    o[key]=this[i];
  }
  return o;
})
Object.addProperty(Array,'transpose', function () {
  var rows = this.length, i, cols = this[0].length, j;
  var elements = [], i = cols;
  while (i--) { j = rows;
    elements[i] = [];
    while (j--) {
      elements[i][j] = this[j][i];
    }
  }
  return elements;
})
if (!Array.prototype.unflat) {
  Object.addProperty(Array,'unflat', function unflat (n) {
      // suppports only 1d->2d transformation
      var rows = [];
      for(var i=0;i<=(this.length-n);i+=n) rows.push(this.slice(i,i+n));
      return rows;
  })
}
Object.addProperty(Array,'without', function (without) {
  if (Utils.isArray(without)) {
    return this.filter(function (el) {
      var found=false;
      for(var i=0;i<without.length;i++) 
        found = found  | Math.equal(el,without[i])
      return !found; 
    });
  } else return this.filter(function (el) { return !Math.equal(el,without) });
})

// Static array method extensions

// Simple array array matrix
Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
Array.matrix3d =  function (n,m,k,init) {
    var x,y,z,mat;
    mat=new Array(n);
    for(x=0;x<n;x++) {
      mat[x]=new Array(m);
      for(y=0;y<m;y++) {
        mat[x][y]=new Array(k);
        if (init!=undefined) {
          if (typeof init == 'function')
            for(var z=0;z<k;z++) mat[x][y][z]=init(x,y,z);
          else
            for(var z=0;z<k;z++) mat[x][y][z]=init; 
        }  
      }
    }
    return mat;
  };
Array.random = function (n,a,b) {
  var res=[];
  a=a||0;
  b=b||1;
  for(var i=0;i<n;i++) res.push(Math.random()*(b-a)+a);
  return res;
}

Array.sequence = function (a,b,step,func) {
  var res=[], preci=1;
  step=step||1;
  if (step < 1) {
    preci = Math.ceil(Math.log10(1/step))
    for(var i=a;i<=b;i += step) res.push(func?func(i):Math.precision(i,preci));
  } else for(var i=a;i<=b;i += step) res.push(func?func(i):i);
  return res;
}

// Transpose matrix (array of arrays) by swapping rows and columns
Array.transpose = function (matrix) {
  var t=[];
  for (var i=0;i<matrix[0].length;i++) {
    var row=[];
    for(var j=0;j<matrix.length;j++) {
      row.push(matrix[j][i]);
    }
    t.push(row);
  }
  return t;
}  
// Simple array vectorA
Array.vector = function (cols,init) {
  if (init==undefined) init=0;
  if (typeof init != 'function') return Array(cols).fill(init);
  var row=[];
  for(var j=0;j<cols;j++) row.push(init(j));
  return row;
};
Array.init=Array.vector;

// Dynamic Object method extensions

Object.addProperty(Object,'toArray', function () {
  var self=this;
  return Object.keys(this).map(function (key) {
    return self[key]
  })
})


// Angle of line (p1,p2)  or delty vector
// +---------X
// |    270
// | 180 *  0
// |    90 
// Y
Math.angle = function (p1,p2) {
  var pd=[],i=0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') {
        if (i==0) dx=(p1[p]-p2[p]);
        else if (i==1) dy=(p1[p]-p2[p]);
        i++;
      }
  } else { 
    for(var p in p1) {
        if (i==0) dx=p1[p];
        else if (i==1) dy=p1[p];
        i++;    
    }
  }
  var theta = Math.atan2(dy, dx); // range (-PI, PI]
  theta *= 180 / Math.PI;
  if (theta < 0) theta = 360 + theta; // range [0, 360)
  return theta;
}
// Element-wise mean average computation
Math.average = function () {
  var ret=0,count=0;
  for (var i in arguments) {
    if (typeof arguments[i]=='number') ret+=arguments[i];
    else if (Utils.isObject(arguments[i])) {
      if (!ret) ret={}
      for(var j in arguments[i]) {
        if (!ret[j]) ret[j]=0;
        ret[j] += arguments[i][j];
      }
    } else if (Utils.isArray(arguments[i])) {
      if (!ret) ret=[];
      for(var j in arguments[i]) {
        if (!ret[j]) ret[j]=0;
        ret[j] += arguments[i][j];
      }    
    }
    count++;
  }
  if (typeof ret=='number') ret /= count;
  else {
    for(var i in ret) ret[i] /= count;
  }
  return ret;
}

Math.bin = Bin;

// mass of center of (optionally weighted) points
// typeof @pts = {x:numebr,y:number,weight?:number } | number [x,y] []
Math.center = function (pts) {
  var n,center,weight,totalmass=0,totalx=0,totaly=0;
  for (var i in pts)
  {
    n=pts[i]; if (n.length==2) n={x:n[0],y:n[1]};
    weight=(n.weight==undefined?1:n.weight);
    totalmass += weight;
    totalx += (n.x*weight);
    totaly += (n.y*weight);
  }
  center = {x:totalx/totalmass,y:totaly/totalmass}
  return center;
}

// Coding and Decoding

// Multi-level: Math.code(['A','B','C'],{A:1,B:2,C:4}) -> 7
// One-hot:     Math.code('A',['A','B','C']) -> [1,0,0]
Math.code = function (list,codes) {
  var y=0;
  if (typeof list == 'string' && Utils.isArray(codes)) {
    // One-hot
    var width = codes.length,
        index = codes.indexOf(list);
    y=[];
    for(var i=0;i<width;i++) y.push(i==index?1:0);
    return y;
  }
  // Multi-level
  if (!Utils.isArray(list)) list=[list];
  for(var i=0;i<list.length;i++) {
    if (list[i]!=undefined) y += (codes[list[i]]); 
  }
  return y; 
}
Math.code.onehot = function (classes,symbol,low,high) {
  if (low==undefined) low=0;
  if (high==undefined) high=1;
  return classes.map(function (c) { return symbol==c?high:low })
}
Math.code.interval = function (values,min,max,step,prefix,relative) {
  function code(x) {
    if (x<min) return (prefix?prefix:'')+'-';
    if (x > max) return (prefix?prefix:'')+'+';
    var xn = (x-min)/(max-min),
        sn = (step)/(max-min)
    return (prefix?prefix:0)+(relative?Math.floor(xn/sn):(min+Math.floor(xn/sn)*step))
  }
  if (Utils.isArray(values)) return values.map(code);
  else return code(values);
}
Math.contains = function (a,element) {
  if (Utils.isArray(a)) {
    return a.contains(element,Math.equal,true);
  } else if (Uitls.isObject(a)) {
    
  } else if (typeof a == 'string') {
    return a.indexOf(String(element))!=-1
  } 
}
// Returns dataspace and datatype of numerical objects
Math.dataspace = function (o) {
  if (Utils.isArrayArrayArray(o)) return [o.length,o[0].length,o[0][0].length];
  else if (Utils.isArrayArray(o)) return [o.length,o[0].length];
  else if (Utils.isArray(o))  return [o.length].concat(Math.dataspace(o[0]));
  else if (Math.Matrix.isMatrix(o)) return [o.rows,o.columns];
  else if (Math.MatrixTA.isMatrix(o)) return [o.rows,o.columns];
  else if (Utils.isBuffer(o)) return [o.length];
  return [];
}
Math.datatype = function (o,sig) {
  if (Utils.isArrayArray(o)) return Math.datatype(o[0][0],sig)+(sig?' [][]':'');
  else if (Utils.isArray(o))  return Math.datatype(o[0],sig)+(sig?' []':'');
  else if (Math.Matrix.isMatrix(o)) return Math.datatype(o.data[0][0],sig)+(sig?' Matrix':'');
  else if (Math.MatrixTA.isMatrix(o)) return o.datatype+(sig?' MatrixTA':'');
  else if (Utils.isBuffer(o)) return 'Buffer';
  else if (typeof o == 'object') return '{'+Object.keys(o).map(function (key) {
    return key+':'+Math.datatype(o[key],sig)
  }).join(',')+'}';
  return typeof o;
}

// Multi-level: Math.decode(7,{A:1,B:2,C:4}) -> ['A','B','C']
// One-hot:     Math.decode([1,0,0],['A','B','C'])
Math.decode = function (value, codes,mutual) {
  var list=[],y=value;
  if (Utils.isArray(value) && Utils.isArray(codes)) {
    // One-hot
    return codes[value.indexOf(value.max())]
  }
  // Multi-level
  if (mutual == undefined) {
    var sum=0;
    Object.keys(codes).forEach(function (code,index) {
      if (codes[code] & sum) mutual=true;
      if (codes[code]==0) mutual=true;
      sum += codes[code];
    })
  }
  Object.keys(codes).forEach(function (code) {
    if (mutual || y<0 || codes[code]<0) {
      if (y==codes[code]) list.push(code) 
    } 
    else 
    if ((y & codes[code]) ||
        y==codes[code]) list.push(code);
  })
  return list; 
}

// API changed! h/points swapped!
Math.derivative = function (data,order,h,points) {
  // https://math.stackexchange.com/questions/302160/correct-way-to-calculate-numeric-derivative-in-discrete-time
  var result;
  data=data.data||data; // comp. with Matrix
  order=order||1;
  points=points||2;
  h=h||1;
  if (Utils.isArray(data)||Utils.isTypedArray(data)) {
    result=[];
    switch (order) {
      case 1:
        switch (points) {
          case 1:
            for(var i=0; i<(data.length-1); i++) {
              result.push((data[i+1]-data[i])/h);
            }
            break;
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-data[i-1])/(2*h));
            }
            break;
          case 3:
            for(var i=2; i<(data.length-3); i++) {
              result.push((data[i-2]-8*data[i-1]+8*data[i+1]-data[i+2])/(12*h));
            }
            break;
        }
        break;
       case 2:
        switch (points) {
          case 2:
            for(var i=1; i<(data.length-2); i++) {
              result.push((data[i+1]-2*data[i]+data[i-1])/(h*h));
            }
            break;
        }
        break;
    }
  }
  return result;
} 
Math.delta = function (p1,p2) {
  var pd=p1.length?[]:{};
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') pd[p]=p1[p]-p2[p];
  } 
  return pd;
}
Math.distance = function (p1,p2,one) {
  var y=one?1:0;
  if (p2) {
    for(var p in p1) 
      if (typeof p1[p] == 'number' && 
          typeof p2[p] == 'number') y+=Math.pow(p1[p]-p2[p],2);
  } else {
    for(var p in p1) 
      if (typeof p1[p] == 'number') y+=Math.pow(p1[p],2);
  }
  return Math.sqrt(y)-(one?1:0) 
}
Math.deviation = function (values) {
  // d3.deviation comp. via variance (n-1)
  var v = Math.variance(values);
  return v ? Math.sqrt(v) : v;
}
// For sorting; sort down
Math.down = function (a,b) {
  return a>b?-1:1
}
Math.equal = function (a,b) {
    var i;
    if (Utils.isNumber(a) && Utils.isNumber(b)) return a==b;
    else if (Utils.isArray(a) && Utils.isArray(b)) {
      if (a.length!=b.length) return false;
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isObject(a) && Utils.isObject(b)) {
      for (i in a) {
        if (!Math.equal(a[i],b[i])) return false;
      }
      return true;     
    }
    else if (Utils.isString(a) && Utils.isString(b))
      return (a.length==b.length && a==b)
    return false;
  }
Math.frac = function (x,frac) {
  if (frac<=1) {
    frac=(1/frac)|0;
    return Math.round(x*frac)/frac;
  } else {
    return Math.floor(x-(x%frac));
  }
}
Math.id = function (x) { return x }
Math.int = function (x) { return x|0 }
Math.decr = function (x) { return x-1 }
Math.incr = function (x) { return x+1 }

Math.isFloat = function (x) {
  function isFloat32Array(x) {
    if (typeof x[0] == 'object') return isFloat32Array(x[0]);
    if (typeof x.data == 'object') return isFloat32Array(x.data);
    return (x instanceof Array) ||
           (x instanceof Float32Array) ||
           (x instanceof Float64Array)
  }
  return typeof x == 'number'?true:
          (typeof x == 'object'?isFloat32Array(x):false)
}
Math.isNumber = function (x) {
  return !isNaN(Number(x)) 
}

// Hilbert transform using FFT (input data length must be a power of 2!) 
// Returns real, imaginary, and magnitude (norm) vectors (same length as input)
Math.hilbert = function hilbert(inp) {
  var N=inp.length,
      N2=N/2,
      fft = Math.FFT.FFT(N);
  var re1 = inp.slice();
  var im1 = Array.vector(N);
  fft.fft1d(re1,im1)
  var re2=re1.slice();
  var im2=im1.slice();
  for(var i=1;i<N2;i++) { re2[i]*=2; im2[i]*=2; }
  for(var i=N2+1;i<N;i++) { re2[i]=0; im2[i]=0; }  
  fft.ifft1d(re2,im2);
  return {re:re2, im:im2, mag:re2.map(function (r,i) {
      return Math.sqrt(r*r+im2[i]*im2[i]);
    })
  }
}

// Find and return nearest point in a point series {x=index in points,y=best value}
Math.nearest = function (points,valu,epsilon,test) {
  var best;
  if (!test) {
    for(var i in points) {
      if (epsilon==undefined) { // find any nearest value
        if (best==undefined ||
            Math.abs(points[i]-valu)<Math.abs(points[best]-valu))
          best=i;
      } else {
        if ((best!=undefined && Math.abs(points[i]-valu)<Math.abs(points[best]-valu))||
            (Math.abs(points[i]-valu) <= epsilon)) best=i;
      }
    }
  }
  if (best!=undefined) return {x:best,y:points[best]}
}

Math.precision = function (number, precision) {
  if (precision==undefined) {
    precision=number;
    return function (number) { return Math.precision(number,precision) }
  }
  var factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
}
// generate gaussian noise (Standard Normal variate using Box-Muller transform)
// https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
Math.random.gaussian = function (min,max,skew) {
    min=min||0;
    max=max||1;
    skew=skew||1;
    var u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    var num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );

    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) num = Math.random.gaussian(min, max, skew); // resample between 0 and 1 if out of range
    num = Math.pow(num, skew); // Skew
    num *= max - min; // Stretch to fill range
    num += min; // offset to min
    return num;
}
// uniform distribution
Math.random.int = function (n,b) {
  return b==undefined?(Math.random()*n)|0:((Math.random()*(b-n))+n)|0
}
Math.random.int8 = function () {
  return 128-((Math.random()*256)|0)
}
Math.random.uint8 = function () {
  return (Math.random()*256)|0
}
Math.random.int16 = function () {
  var R=65536;
  return (R/2)-((Math.random()*R)|0)
}
Math.random.uint16 = function () {
  var R=65536;
  return (Math.random()*R)|0
}
Math.random.int32 = function () {
  var R=65536*65536;
  return (R/2)-Math.floor(((Math.random()*R)))
}
Math.random.uint32 = function () {
  var R=65536*65536;
  return Math.floor((Math.random()*R))
}
Math.random.range = function(min,max) {
  return min+Math.random()*(max-min)
}
Math.random.interval = function(min,max) {
  return Math.round(min+Math.random()*(max-min))
}
Math.random.noise = function(val,eps,relative) {
  return relative?val+Math.random.gaussian(-Math.abs(val*eps),Math.abs(val*eps)):val+Math.random.gaussian(-eps,eps);
}
Math.random.frac = function (a,b,frac) {
    var r,n,p,i,keys,k;
    if (Utils.isArray(a)) {
      n = a.length;
      if (n>0)
        return a[Math.random.int(n)];  
      else
        return none;
    } else if (Utils.isObject(a)) {
      keys=Object.keys(a);
      n = keys.length;
      if (n>0)
        return a[keys[Math.random.int(n)]];  
      else
        return none;
    } else if (b==undefined) {b=a;a=0}; 
    if (!frac ||frac==1)
      return Math.random.interval(a,b);
    else {
      r=Math.random.range(a,b);
      return ((r/frac)|0)*frac;
    }
}

// Random selection (one or multiple samples from collection / array / object)
Math.random.select = function (o,samples) {
  var r,n,p,i,keys,k;
  if (samples) {
    var A=[],index;
    var data = Utils.isArray(o)?o:Utils.isObject(o)?Object.keys(o):[];
    function shuffle(array) {
      var m = array.length, t, i;
      // While there remain elements to shuffle
      while (m) {
        // Pick a remaining element
        i = Math.floor(Math.random() * m--);
        // And swap it with the current element.
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }
      return array;
    }
    index=Array(data.length).fill().map(function (x,i) { return i });
    index=shuffle(index);
    for(var i=0;i<samples;i++) {
      A.push(data[index[i]]);
    }
    if (Utils.isArray(o)) return A;
    else if (Utils.isObject(o)) {
      return A.map(function (key) { o[key] });
    }
  }
  if (Utils.isArray(o)) {
    n = o.length;
    if (n>0)
      return o[Math.random.int(n)];  
    else
      return none;
  } else if (Utils.isObject(o)) {
    keys=Object.keys(o);
    n = keys.length;
    if (n>0)
      return o[keys[Math.random.int(n)]];  
    else
      return none;
  }
}

Math.pulse = function (length,off,on,pulses) {
  var v = Array.init(length,off);
  if (!Utils.isMatrix(pulses)) pulses=[pulses];
  pulses.forEach(function (pulse) {
    if (Utils.isArray(pulse) && pulse.length==2) 
      for(var i=pulse[0];i<=pulse[1];i++) v[i]=on;
  });
  return v;
}

// Reshape an array or a matrix
Math.reshape = function (array, rows, cols ) {
  var dims = cols!=undefined?[rows,cols]:[rows];
  function _reshape (array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array
    var tmpArray2
    // for each dimensions starting by the last one and ignoring the first one
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex]
      tmpArray2 = []

      // aggregate the elements of the current tmpArray in elements of the requested size
      var length = tmpArray.length / size
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size))
      }
      // set it as the new tmpArray for the next loop turn or for return
      tmpArray = tmpArray2
    }

    return tmpArray
  }
  function _flatten (array) {
    var flat = []

    array.forEach(function callback (value) {
      if (Array.isArray(value)) {
        value.forEach(callback) // traverse through sub-arrays recursively
      } else {
        flat.push(value)
      }
    })
    return flat
  }
  return _reshape(_flatten(array),dims)
  
}

Math.scale = function (vrow,scala) {
  if (!scala) return vrow;
  if (typeof vrow == 'number') {
    if (typeof scala.k == 'number')
      return scala.shift+(vrow-scala.off)*scala.k
    else if (scala.length)
      return scala[0].shift+(vrow-scala[0].off)*scala[0].k;
    else
      return scala.shift+(vrow-scala.off[0])*scala.k[0];
  }
  if (typeof scala.k == 'number')
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off)*scala.k })
  else if (scala.length)
    return vrow.map(function (col,i) { 
      return scala[i].shift+(col-scala[i].off)*scala[i].k })
  else
    return vrow.map(function (col,i) { 
      return scala.shift+(col-scala.off[i])*scala.k[i] })
}

// Compute scaling descriptor for a given data set -> [0,1]
// Target output range of scaled data: [shift+0,shift+1] with shift=shift||0;
Math.scale0 = function (data,lower,upper) {
  var min=data.min(),
      max=data.max();
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  return {
    k:(upper-lower)/(max-min),
    off:min,
    shift:lower,
    min:min,
    max:max
  }
}
Math.scale1 = function (min,max,lower,upper) {
  if (lower==undefined) lower=0;
  if (upper==undefined) upper=1;
  return {
    k:(upper-lower)/(max-min),
    off:min,
    shift:lower,
    min:min,
    max:max
  }
}

// Select column(s) from array rows (array array matrix)
// Start column ia a, end column is b (column range)
Math.select = function (data,a,b){
  if (b==undefined) {
    return data.map(function(object) { 
      return object[a]
    })
  }else {
    return data.map(function(object) {
      return object.slice(a,b+1)
    })
  }
}

// Returns a number sequence set
Math.sequence = Array.sequence;

// Math core extensions
Math.signal = {
  chirp : function (N,period,offset,width) {
    var limiter=Math.gaussian(Math.sequence(1,N),offset,width),
        wave = Math.sequence(0,N-1,1,function (i) { return Math.sin(i/period*2*Math.PI) }).mul(limiter);
    return wave;
  },
  energy: function (data) {
    if (Utils.isArray(data)) {
      var s=0;
      data.forEach(function (v) {
        s+= Math.pow(v,2);
      });
      return s/data.length;
    }
  },
  filter : {
    boxcar : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||3;
      switch (points) {
        case 3:
          for(var i=1;i<array.length-1;i++) result.push(
            (array[i-1]+array[i]+array[i+1])/3
          );
          return result;
          break;
      }
    },
    // 0 > k > 1 !!!
    lowpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.z == undefined) state.z=0;
      t=(1-k)*x+state.z*k;
      y=t;
      state.z=t;
      return y;
    },
    // 0 > k > 1 !!!!
    highpass : function (x,k,state) {
      var y,t;
      // typeof @state = { z:number }
      if (state.y == undefined) state.y=0;
      if (state.x == undefined) state.x=0;
      // t=(1-k)*x+state.z*(-k);
      t=k*(state.y+x-state.x);
      y=t;
      state.y=t;
      state.x=x;
      return y;    
    },
    // Function constructors
    lowPass : function (k,state) {
      state=state||{}
      return function (x) { return Math.signal.filter.lowpass(x,k,state) }
    },
    highPass : function (k,state) {
      state=state||{}
      return function (x) { return Math.signal.filter.highpass(x,k,state) }
    },
    triangular : function (array,points) {
      // https://terpconnect.umd.edu/~toh/spectrum/Smoothing.html
      var result=[];
      points=points||5;
      switch (points) {
        case 5:
          for(var i=2;i<array.length-2;i++) result.push(
            (array[i-2]+2*array[i-1]+3*array[i]+2*array[i+1]+array[i+2])/9
          );
          return result;
          break;
      }
    },
    
  },
  meanAbsoluteDeviation: function(data) {
    var mean = Math.signal.mean(data);
       return Math.signal.mean(data.map(function(num) {
         return Math.abs(num - mean);
       }));
  },
  mean:function (data) { return data.mean() },
  peak: function (data) {
    if (Utils.isArray(data)) {
      return Math.max(Math.abs(data.max()),Math.abs(data.min()));
    }  
  },
  rms: function (data) {
    return Math.sqrt(data.map(Math.sq).sum()/data.length)
  },
  sample : function (data,frag,filter) {
    return data.sample(frag,filter)
  },
  standardDeviation: function(data) {
    return Math.sqrt(Math.signal.variance(data));
  },
  variance: function (data) {
    if (Utils.isArray(data)) {
      return data.variance()
    }
  },
}

Math.sq = function (x) { return x*x }

Math.sum = function (a,b) {
  return a+b
}
// Return unique identifier name [a-zA-Z0-9]
Math.unique = function (length) {
  return Math.random().toString(36).substr(2, 2+length);
}
// For sorting; sort up
Math.up = function (a,b) {
  return a<b?-1:1
}

Math.variance = function (values) {
  var count = 0;
  var delta;
  var mean = 0;
  var sum = 0;
  for (var value of values) {
    if (value != null && (value = +value) >= value) {
      delta = value - mean;
      mean += delta / ++count;
      sum += delta * (value - mean);
    }
  }
  if (count > 1) return sum / (count - 1);
}

Math.window = {
  // window functions returning mask array of width w
  // https://github.com/scijs/window-function
  
  //////////////// WINDOWS ////////////////
  gaussian : function (w,sigma) {
    var res=[];
    sigma=sigma||0.4;
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i-nm12)/sigma/nm12,
          h=Math.exp(-0.5*f*f);
      res.push(h)
    }
    return res;
  },
  
  hamming : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 0.54 - 0.46 * Math.cos(Math.PI*2*i/(w-1));
      res.push(h)
    }
    return res;
  },
  
  hann: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      var t = -0.9999999+2*(i/(w+1));
      var h = Math.sqrt(2)/2 * (1+Math.cos(t*Math.PI)) / 
              Math.sqrt(1+Math.pow(Math.cos(t*Math.PI),2) ) * (
              Math.abs(t)<1?1:0);
      res.push(h)
    }
    return res;
  },
  
  rect: function (w) {
    var res=[];
    for(var i=1;i<=w;i++) {
      res.push(1)
    }
    return res;
  },
  
  triangular : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var h = 1 - Math.abs( 2 * (i - 0.5*(w-1)) / w );
      res.push(h)
    }
    return res;
  },
  
  welch : function (w) {
    var res=[];
    for(var i=0;i<w;i++) {
      var nm12 = 0.5*(w-1),
          f = (i - nm12)/nm12,
          h = 1 - f*f  ;
      res.push(h)
    }
    return res;
  },
  
  /////////////////////// MASKING /////////////////////  
  mask: function (data,off,width,win,arg) {
    var mask = (win||Math.window.hann)(width,arg);
    var res=[];
    for(var i=0;i<width;i++) res.push(data[off+i]*mask[i]);
    return res;
  },
  

}
Math.zip = function (v1,v2) {
  if (typeof v1[0]=='number' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return [row,v2[index]]
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return row.concat(v2[index])
    })
  if (typeof v1[0]=='object' && typeof v2[0]=='number')
    return v1.map(function (row,index) {
      return row.concat([v2[index]])
    })
  if (typeof v1[0]=='number' && typeof v2[0]=='object')
    return v1.map(function (row,index) {
      return [row].concat(v2[index])
    })
  
} 
if (typeof module != 'undefined') module.exports=Math
if (typeof window != 'undefined') console.log('Math '+Math.version+' loaded.');
};
BundleModuleCode['plugins/com/utils']=function (module,exports){
var fs      = require('fs');
var http    = require('http');
var deasync = require('deasync');
var util    = require('util');
try { var crypto = require("crypto") } catch (e) { }
var https;
try { https=require('https') } catch (e) {};

JSONfn = Require('plugins/com/jsonfn');

if (typeof print == 'undefined') print=console.log;

function POST(url, data, cb) {
  var params,headers;
  if (data && data.params && data.data != undefined) {
    params=data.params;
    headers=data.headers;
    data=data.data;
  }
  var ishttps= url.match(/https:/);
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  var post_data = typeof data == 'string'?data:JSONfn.stringify(data);
  var post_options = {
      host: host,
      port: port,
      path: '/'+path+params,
      method: 'POST',
      keepAlive: true,
      headers: headers || {
          'Content-Type': 'application/json', // ?? 'application/x-www-form-urlencoded',
          // 'Content-Length': Buffer.byteLength(post_data)
          'Content-Length': post_data.length,
      }
  };
  // console.log('POST', post_options,post_data)
  var post_req = (ishttps?https:http).request(post_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('POST: ',result);
        } catch (e) { print(data); result=e; }
        if (cb) cb(result);
      });
  });
  post_req.on('error',function (err) {
    if (cb) cb(err); else console.log(url,err)
  });
  post_req.setNoDelay();
  // console.log('POST: ',post_data);
  // post the data
  post_req.write(post_data);
  post_req.end();
}
var POSTsync = deasync(function(url,data,cb) {
  POST(url,data,function (result) {
    cb(null,result);
  })
})

function GET(url,params, cb) {
  var ishttps= url.match(/https:/)!=null;
  url=url.replace(/http[s]?:\/\//,'');
  var parts = url.split(':'),
      path  = parts[0].split('/').slice(1).join('/'),
      host  = parts[0].split('/')[0],
      port  = parts[1]||(ishttps?'443':'80');
  if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
  } else params='';
  path += params; 
  // print(host,path,port,ishttps)
  var get_options = {
      host: host,
      port: port,
      path: path,
      method: 'GET',
      keepAlive: true,
      headers: {
          // 'Content-Type': 'application/x-www-form-urlencoded',
      }
  };
  // console.log('GET', post_options,post_data)
  var get_req = (ishttps?https:http).request(get_options, function(res) {
      res.setEncoding('utf8');
      
      var data='';
      res.on('data', function (chunk) {
        data += chunk;
        // console.log('Response: ' + chunk);
      });
      res.on('end', function () {
        try {
          var result=JSONfn.parse(data);
          // console.log('GET: ',result);
        } catch (e) { result=e; }
        if (cb) cb(result);
      });
  });
  get_req.on('error',function (err) {
    // console.log(err)
    if (cb) cb(err); else console.log(url,err);
  });
  get_req.setNoDelay();
  // get_req.write();
  get_req.end();
}
var GETsync = deasync(function(url,params,cb) {
  GET(url,params,function (result) {
    cb(null,result)
  })
})

Common = {
  existFile: function (file) {
    try {
      var stat=fs.statSync(file);
      return stat?true:false;
    } catch (e) {
      return false;
    }
  },
  loadFile: function (file,callback) {
    try {
      var text = fs.readFileSync(file,'utf8');
      // var data = JSONfn.parse(text);
      if (callback) return callback(text);
      else return text;
    } catch (e) {
      if (callback) return callback(data);
      else return e
    }
  },
  saveFile: function (data,file,mimetype) {
    try {
      var data = typeof data=='string'?data:JSONfn.stringify(data);
      return fs.writeFileSync(file,data,'utf8');
    } catch (e) {
      return e
    }
  }
}

Utils = {

  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  deserialize : function (data) {
    return JSONfn.deserialize(data)
  },

  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  format : function (args) {
    // format array of arguments like console.log
    var s='',sep='';
    for(var i in args) {
      switch (typeof args[i]) {
        case 'number':
        case 'string':
        case 'boolean':
          s += (sep+args[i]);
          break;
        case'function':
          s += (sep+'[Function]');
          break;
        case'object':
          s += (sep+util.inspect(args[i]));
          break;
      }
      sep = ' ';
    }
    return s;
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*\([^\)]+\))/)[1];
    }
  },

  inspect : Require('util').inspect,

  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isArrayArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]) &&
                Utils.isArray(o[0][0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isBufferArray : function (o) {
    return (typeof ArrayBuffer != 'undefined' && o instanceof ArrayBuffer) ||
           (typeof SharedArrayBuffer != 'undefined' && o instanceof SharedArrayBuffer) ||
           (typeof Buffer != 'undefined' && o instanceof Buffer)
  },
  isMatrix: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return (Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isMatrixTA: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return Math.MatrixTA && Math.MatrixTA.isMatrix(o)
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isNumber(o) {
      return typeof o == "boolean"
  },
  isString: function isNumber(o) {
      return typeof o == "string"
  },
  isTypedArray: function isTypedArray(o) {
      return Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },
  isVectorTA: function isMatrix(o) {
    if (o==_ || o ==null) return false;
    else return Math.VectorTA && Math.VectorTA.isVector(o)
  },
  isVol3: function isVol3(o) {
    if (o==_ || o ==null) return false;
    else return Math.Vol3 && Math.Vol3.isVol(o)
  },

  network : function () {
    const results = Object.create(null); // Or just '{}', an empty object
    Object.defineProperty(results, 'first', {
      value: function () {
        var keys = Object.keys(this); 
        return keys.length? this[keys[0]][0]:null
      },
      writable: false,
      enumerable : false,
    });
    try { 
      const networkInterfaces  = require('os').networkInterfaces;
      const nets = networkInterfaces();
      for (const name of Object.keys(nets)) {
          for (const net of nets[name]) {
              // Skip over non-IPv4 and internal (i.e. 127.0.0.1) addresses
              if (net.family === 'IPv4' && !net.internal) {
                  if (!results[name]) {
                      results[name] = [];
                  }
                  results[name].push(net.address);
              }
          }
      }
    } catch (e) {};
    
    return results
  },

  /** Convert agent text sources to agent code in JSOB format
   *
   */
  ofString : function (source) {
    var code;
    try {
      // execute script in private context
      eval('code = '+source);
    } catch (e) { console.log(e,source); };
    return code; 
  },

  protect : function (func,arguments,verbose) {
    try {
      return func.apply(this,arguments||[]);
    } catch (e) {
      if (verbose) console.log(e.stack || e.toString());
      return e;
    }
  },
  
  serialize : function (data) {
    return JSONfn.serialize(data)
  },

  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },

  /** Convert any object to text source in JSOB format
  *
  */
  toString : function (o) {
    var usebuffer=false;
    var p,i,keys,s='',sep,tokens;
    if (o===null) return 'null';
    else if (Utils.isArray(o)) {
      s='[';sep='';
      for(p in o) {
        s=s+sep+Utils.toString(o[p]);
        sep=',';
      }
      s+=']';
    } else if (o instanceof Buffer) {    
      s='Buffer([';sep='';
      for(i=0;i<o.length;i++) {
        s=s+sep+Utils.toString(o[i]);
        sep=',';
      }
      s+='])';  
    } else if (o instanceof Error) {    
      s='(new Error("'+o.toString()+'"))';
    } else if (Utils.isTypedArray(o)) {    
      s='(new '+Utils.TypedArrayToName(o)+'([';sep='';
      var b=Array.prototype.slice.call(o);
      for(i=0;i<b.length;i++) {
        s=s+sep+String(b[i]);
        sep=',';
      }
      s+=']))';  
    } else if (typeof o == 'object') {
      s='{';sep='';
      keys=Object.keys(o);
      for(i in keys) {
        p=keys[i];
        if (o[p]==undefined) continue;
        s=s+sep+"'"+p+"'"+':'+Utils.toString(o[p]);
        sep=',';
      }
      s+='}';
      if (o.__constructor__) s = '(function () { var o='+s+'; o.__proto__='+o.__constructor__+'.prototype; return o})()';
    } else if (typeof o == 'string')
      s="'"+
            o.toString().replace(/'/g,'\\\'')
                        .replace(/\n/g,'\\n')+
        "'"; 
    else if (typeof o == 'function') {
      s=o.toString(true);   // try minification (true) if supported by platform
      if (tokens=s.match(/function[ ]+([a-zA-Z0-9]+)[ ]*\(\)[ ]*{[^\[]*\[native code\][^}]*}/)) {
        return tokens[1];
      } else return s;
    } else if (o != undefined)
      s=o.toString();
    else s='undefined';
    return s;
  },

  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
    if (ftyp==Int8Array   || ftyp instanceof Int8Array) return 'Int8Array';
    if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return 'Uint8Array';
    if (ftyp==Int16Array  || ftyp instanceof Int16Array) return 'Int16Array';
    if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return 'Uint16Array';
    if (ftyp==Int32Array  || ftyp instanceof Int32Array) return 'Int32Array';
    if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return 'Uint32Array';
    if (ftyp==Float32Array || ftyp instanceof Float32Array) return 'Float32Array';
    if (ftyp==Float64Array || ftyp instanceof Float64Array) return 'Float64Array';
  },
  DataSize : {
    Int8:1,
    Uint8:1,
    Int16:2,
    Uint16:2,
    Int32:4,
    Uint32:4,
    Float32:4,
    Float64:4,
    Boolean:1,
    Number:8,  
  },

  uniqueID : function (length) {
    var s='',
        keys=['a','b','c','d','e','f','g','h','i','j','k','l','m','n',
              'o','p','q','r','s','t','u','v','w','x','y','z'];
    keys=keys.concat(keys,keys.map(function (k) { return k.toUpperCase() }));
    keys=keys.concat(['0','1','2','3','4','5','6','7','8','9']);
    if (typeof crypto == 'undefined') {
      for(var i=0;i<length;i++) {
        var b = (Math.random()*255)|0;
        s+= (keys[b%keys.length]);
      }
    } else {
      if (crypto.getRandomValues) { 
        var rav = new Uint8Array(length);
        crypto.getRandomValues(rav);
      }
      if (crypto.randomBytes) {
        var rav = crypto.randomBytes(length);
      } 
      for(var i=0;i<length;i++) {
        s+= (keys[rav[i]%keys.length]);
      };
    }
    return s;
  },
 
  UUIDv4 : function uuidv4() {
    if (typeof crypto != "undefined" && crypto.getRandomValues) { 
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    if (typeof crypto != "undefined" && crypto.randomBytes) { 
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.randomBytes(1)[0] & 15 >> c / 4).toString(16)
      );
    }
  },

  GET: function (url,params,cb) {
    if (!cb) return GETsync(url,params);
    else return GET(url,params,cb);
  },
  
  POST: function (url,data,cb,sync){
    if (!cb) return POSTsync(url,data);
    else return POST(url,data,cb);
  },

  version: '1.3.1'
}


Object.addProperty = function (obj,name,fun) {
  if (obj.prototype[name]) return;
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

Object.updateProperty = function (obj,name,fun) {
  obj.prototype[name]=fun;
  Object.defineProperty(obj.prototype, name, {enumerable: false});
};

// Array static methods extensions
if (!Array.create) Array.create = function(length,init) {
      var arr = [], i = length;
      while (i--) {
        arr[i] = init;
      }
      return arr;
  }

if (!Array.matrix) Array.matrix = function (rows,cols,init) {
  if (init==undefined) init=0;
  var mat=[];
  for(var i=0;i<rows;i++) {
    var row=[];
    for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
    mat.push(row);
  }
  return mat;
};

// Array prototype extensions
Object.addProperty(Array,'last',function () { return this[this.length-1] });

// String static methods extensions
if (!String.create) String.create = function(size,init) {
      var i, s='';
      init=init||' ';
      for(i=0;i<size;i++) s=s+init;
      return s;
};
if (!String.copy) String.copy = function(src) {
      var i,dst='';
      for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
      return dst;
}; 
if (!String.get) String.get = function (str,index) {
      return str.charAt(index);
}
if (!String.hex) String.hex = function (n,len) {
      // format a hexadecimal number with 'len' figures.
      switch (len) {
          case 2: return (((n>>4) & 0xf).toString(16))+
                          ((n&0xf).toString(16));
          case 4: return (((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 6: return (((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          case 8: return (((n>>28) & 0xf).toString(16)+
                          ((n>>24) & 0xf).toString(16)+
                          ((n>>20) & 0xf).toString(16)+
                          ((n>>16) & 0xf).toString(16)+
                          ((n>>12) & 0xf).toString(16)+
                          ((n>>8) & 0xf).toString(16)+
                          ((n>>4) & 0xf).toString(16)+
                          (n&0xf).toString(16));
          default: return 'format_hex??';
      }
}; 
if (!String.set) String.set = function (str,index,char) {
  return str.substr(0, index) + char + str.substr(index+1)
}
// String prototype extensions
Object.addProperty(String,'contains', function (el) {
  return this.includes(el)
})
Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
});


};
BundleModuleCode['plugins/com/jsonfn']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  OJ=exports.stringify;
  JO=exports.parse;
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));


};
BundleModuleCode['plugins/math/matrixTA']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2022 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.14.1X
 **
 **    $INFO:
 **
 **  Numerical Matrix Module associated with typed arrays, but with generic array compatibility. 
 **  A matrix provides a wrapper and multi-dimensional array view for one-dimensional byte arrays (typed arrays using buffers).
 **
 **  Examples:
 **
 ** // From shared array buffer:
 ** Math.MatrixTA({data:function (size) { return new SharedArrayBuffer(size) } OR data:SharedArrayBuffer(size),
 ** rows:10,columns:10,datatype:'Float32'})
 **
 ** // From shared memory segment
 ** var sm = BufferSegment(...);
 ** Math.MatrixTA({
 **  data : sm,
 **  rows:10,columns:10,datatype:'Float32'
 ** });
 **
 **
 **    $ENDOFINFO
 */

var version = "1.14.1X"

var utils  =  Require('plugins/math/matrixTA-utils');
var Vector =  Require('plugins/math/vectorTA');

var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

integer = function (v)  { return Math.floor(v) }
divide = function (a,b) { return Math.floor(a/b) }


var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString,
    DataSize = Utils.DataSize,
    TypedArrayOfName = Utils.TypedArrayOfName;


function todo (what) { throw ("Not implemented: Matrix."+what) }
function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(name+'must be a number');
  }
}
function transpose (layout) {
  switch (layout) {
    case 12: return 21;
    case 21: return 12;
  }
}
/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

// Most generic versions - always overwrite (polyfill/vector definitions)
Object.updateProperty(Array,'get', function (i,j,k) {
  if (k!=undefined)
   return this[i][j][k];
  else if (j!=undefined)
   return this[i][j];
  else
   return this[i];
})
Object.updateProperty(Array,'getRow', function (i) {
 return this[i];
})

Object.updateProperty(Array,'info', function () {
  var rows,columns,levels;
  if (isArrayArrayArray(this)) levels=this.length,rows=this[0].length,columns=this[0][0].length;
  else if (isArrayArray(this)) rows=this.length,columns=this[0].length;
  else columns=this.length;
  if (levels) return {
    dtn:'Array',
    size:levels*rows*columns,
    levels:levels,
    rows:rows,
    columns:columns,
    dims:3,
    offset:0,
  }; else if (rows) return {
    dtn:'Array',
    size:rows*columns,
    rows:rows,
    columns:columns,
    dims:2,
    offset:0,
  }; else return {
    dtn:'Array',
    size:columns,
    columns:columns,
    dims:1,
    offset:0,
  }
})


Object.updateProperty(Array,'mapRow', function (i,f) {
 return this[i].map(f);
})

Object.updateProperty(Array,'max', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] > m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] > m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.max.apply(null, this) // vector
  else   // matrix
    return Math.max.apply(null,this.map(function (row) { return Math.max.apply(null, row) }))
})


Object.updateProperty(Array,'mean', function () {
  if (typeof this[0] == 'number')
    return this.sum()/this.length // vector
  else   // matrix
    return this.sum()/(this.length*this[0].length)
})

// this and b can be vectors or matrix objects
// returns always a matrix
Object.updateProperty(Array,'merge', function (b,align) {
  var a=this;
  if (!b || a.length!=b.length) throw "array.merge: length mismatch";
  if (align && align.indexOf('c')==0) {
    // columns alignment ab
    if (Utils.isArray(a[0]))
      return a.map(function (row,index) {
        return Utils.isArray(row)?row.concat(b[index]):[row,b[index]];
      });
    else // a is vector
      return a.map(function (row,index) {
        return Utils.isArray(row)?[row].concat(b[index]):[row,b[index]];
      })
  } else if (!align || align.indexOf('r')==0) {
    // row alignment a
    //               b
    if (!Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b).map(function (row) { return [row] });
    else if (Utils.isArray(a[0]) && !Utils.isArray(b[0])) return a.concat(b.map(function (row) { return [row] }));
    else if (!Utils.isArray(a[0]) && Utils.isArray(b[0])) return a.map(function (row) { return [row] }).concat(b);
    else return a.concat(b);
  }
})

Object.updateProperty(Array,'min', function (position) {
  if (position) {
    var mi;
    if (typeof this[0] == 'number') { // vector
      var m = this[0], i = this.length;
      while (i--) {
        if (this[i] < m) { mi=i; m = this[i]; }
      }
    } else {   // matrix
      var m = this[0][0], i = this.length, nj = this[0].length, j;
      while (i--) { j = nj;
        while (j--) {
          if (this[i][j] < m) { mi=[i,j]; m = this[i][j]; }
        }
      }
    }
    return mi;
  }
  if (typeof this[0] == 'number')
    return Math.min.apply(null, this) // vector
  else    // matrix
    return Math.min.apply(null,this.map(function (row) { return Math.min.apply(null, row) }))
})


Object.updateProperty(Array,'pluck', function (key) {
  var collection=this;
  return collection.map(function(object) {
    return object == null ? undefined : object[key];
  });
})

Object.updateProperty(Array,'print', function (format) {
  var i,j,k,s='',sep='', info=this.info();
  if (!format) format = '%4.2f';
  switch (info.dims) {
    case 1:
      for(j=0;j<info.columns;j++) {
        if (j!=0) s = s + '\n';
        s = s + sprintf(format,this[j]) ;
      }
      break;
    case 2:
      for(j=0;j<info.rows;j++) {
        sep = '';
        if (j!=0) s = s + '\n';
        for (i=0;i<info.columns;i++) {
          s = s + sep + sprintf(format,this[j][i]) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<info.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(j=0;j<info.rows;j++) {
          sep = '';
          if (j!=0) s = s + '\n';
          for (i=0;i<info.columns;i++) {
            s = s + sep + sprintf(format,this[k][j][i]) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
})

Object.updateProperty(Array,'prod', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a*b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a*b })
    }).reduce(function (a,b) { return a*b })
})

// sub(row number|[row0,row1]|[[rowa,rowb,rowc,..]],col number|[col0,col1]|[[cola,colb,colc,..]])
Object.updateProperty(Array,'sub', function (i /*row/col*/,j /*col?*/) {
  var res;
  if (typeof i == 'number') res = this[i];
  else if (isArrayArray(i)) {
    res=[]
    for(var k in i[0]) {
      res.push(this[i[0][k]])
    }
  } else if (isArray(i) && i.length==2) res = this.slice(i[0],i[1]+1);
  else res=this;
  if (!isArrayArray(res)) {
    if (typeof j == 'number') res = res[j];
    else if (isArrayArray(j)) {
      res=res.filter(function (col,coli) {
        return j[0].indexOf(coli)!=-1
      })
    } else if (isArray(j) && j.length==2) res = res(j[0],j[1]+1);
  } else if (isArray(res)) {
    if (typeof j == 'number') 
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a[j]]:a).concat([b[j]]) });
    else if (isArrayArray(j)) {
      res=res.map(function (row) {
        return row.filter(function (col,coli) {
          return j[0].indexOf(coli)!=-1
        })
      })
    } else if (isArray(j) && j.length==2)
      res=res.reduce(function (a,b,pos) { 
        return (pos==1?[a.slice(j[0],j[1]+1)]:a)
                .concat([b.slice(j[0],j[1]+1)]) });
  }
  return res;
})

Object.updateProperty(Array,'set', function (a,b,c,d) {
  if (d!=undefined)
   return this[a][b][c]=d;
  else if (c!=undefined)
   return this[a][b]=c;
  else
   return this[a]=b;
})

Object.updateProperty(Array,'setRow', function (i,row) {
 return this[i]=row;
})

Object.updateProperty(Array,'sum', function () {
  if (typeof this[0] == 'number')
    return this.reduce(function (a,b) { return a+b }) // vector
  else   // matrix
    return this.map(function (row) {
      return row.reduce(function (a,b) { return a+b })
    }).reduce(function (a,b) { return a+b })
})

// [][] -> [] == flat
Object.updateProperty(Array,'unwrap', function () {
  return this.flat();
})

Object.updateProperty(Array,'variance', function () {
  // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
  var sigma1=0,sigma2=0,n=0;
  if (typeof this[0] == 'number') {
    for(var i=0;i<this.length;i++) {
      sigma1 += (this[i]*this[i]);
      sigma2 += this[i];
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/this.length)/this.length);
  } else {  // matrix
    for(var i=0;i<this.length;i++) {
      for(var j=0;j<this[i].length;j++) {
        sigma1 += (this[i][j]*this[i][j]);
        sigma2 += this[i][j];
        n++;
      }
    }
    return Math.sqrt((sigma1-Math.pow(sigma2,2)/n)/n);
  }
})

// [] -> [][]
Object.updateProperty(Array,'wrap', function () {
  return this.map(function (row) { return [row] });
})



/****************** MATRIX ***************************/
// Matrix object based on typed arrays!
// Supports mixed mode typed arrays and generic arrays!
// {type:function,dtn:string} specifies data type
//
// dataspace : [levels,rows,columns]
// Usage:
// Matrix(columns:number)
// Matrix(rows:number,columns:number)
// Matrix(rows:number,columns:number,levels:number)
// Matrix(rows:number,columns:number,options:{dtn:string})
// Matrix([])
// Matrix([][])
// Matrix([][][])
// Matrix({data:buffer|typedarray|SharedArrayBuffer,rows:numner,columns:number,dtn:..})
//
// typeof return = Matrix

function Matrix (a,b,c,d) {
  var self = this;
  var rows,columns,levels,dims=2,dtn,dt=Matrix.options.dt,data,
      layout=12,size,transpose,offset=0;
  var options = isObject(d)?d:(isObject(c)?c:(isObject(b)?b:{}));
  this.tag='MatrixTA';
  if (!(this instanceof Matrix)) return new Matrix(a,b,c,d);
  if (isNumber(a) && isNumber(b)) {
    // Create new empty matrix (2/3 dims)
    rows=a;
    columns=b;
    if (isNumber(c)) levels=c;
    dims=levels?3:2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    size=rows*columns;
    if (levels) size *= levels;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.data)
      data=new dt(options.data);
    else if (dt.name=='Array')
      data=new Array(rows).fill(null).map(function (row) { return new Array(columns).fill(0) });
    else
      data=new dt(size);
  } 
  else if (isNumber(a)) {
    // Create a new empty matrix vector (rows=1)
    rows=1;
    columns=a;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    size=columns;
    if (options.data)
      data=new dt(options.data);
    else
      data=new dt(size);
  } 
  else if (isArrayArray(a)) {
    if (options.datatype) options.dtn=options.datatype+'Array';
    rows=a.length;
    columns=a[0].length;
    if (isArrayArrayArray(a)) levels=rows,rows=a[0].length,columns=a[0][0].length;
    size=rows*columns;
    if (levels) size *= levels;
    dims=levels?3:2;
    if (options.type) dt=options.type;
    if (options.dtn)  {
      dt=TypedArrayOfName[options.dtn];
    }
    if (options.layout) layout=options.layout;
    else layout=dims==2?12:123;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(size);
      switch (layout) {
        case 12:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[coli+rowi*columns]=col;
            })
          });
          break;
        case 21:
          a.forEach(function (row,rowi) {
            row.forEach(function (col,coli) {
              data[rowi+coli*rows]=col;   // TBCHECK!
            })
          });
          break;
      }
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isArray(a)) {
    // Vector 
    rows=1;
    columns=a.length;
    size=columns;
    dims=2;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=TypedArrayOfName[options.dtn];
    if (options.layout) layout=options.layout;
    else layout=12;
    if (options.dtn && !dt) throw ("Matrix: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=[a];
    }
  } else if (a instanceof Matrix) {
    if (options.transpose) {
      // transposeView !
      rows=a.columns;
      columns=a.rows;
      levels=a.levels;
      size=a.size;
      dims=a.dims;
      transpose=true;
      data=a.data;
      dtn=a.dtn;
      switch (a.layout) {
        case 12: layout=21; break;
        case 21: layout=12; break;
        case 123: layout=321; break;
        case 321: layout=123; break;
      }
    } else {
      // Copy (and convert?)
      if (options.datatype) options.dtn=options.datatype+'Array';
      rows=options.rows||a.rows;
      columns=options.columns||a.columns;
      levels=options.levels||a.levels;
      dims=a.dims;
      size=rows*columns;
      if(levels) size*=levels;
      transpose=false;
      scale=options.scale;
      if ((options.dtn && options.dtn != a.dtn) || size != a.size) {
        // convert or resize dtn
        dtn = options.dtn;
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      } else {
        dtn=a.dtn;
        if (dtn != 'Array')
          data=a.data.slice();
        else {
          // TODO dims=3
          data=a.data.map(function (row) { return row.slice() });
        }
      }
      if (a.scale) this.scale=a.scale;
      if (a.complex) this.complex=a.complex;
      layout=a.layout;
    }
  } else if (isObject(a)) {
      // Partial matrix object
      if (a.dataspace) {
        if (a.dataspace.length==1)
          a.rows=1,a.columns=a.dataspace[0];
        else if (a.dataspace.length==2) 
          a.rows=a.dataspace[0],
          a.columns=a.dataspace[1];
        else if (a.dataspace.length==3) 
          a.levels=a.dataspace[0],
          a.rows=a.dataspace[1],
          a.columns=a.dataspace[2];
      }
      if (a.datatype) a.dtn=a.datatype+'Array';
      rows=a.rows||(a.y && a.x);
      columns=a.columns||a.y||a.x;
      levels=a.levels||a.z;
      size=a.size||((rows?rows:1)*(columns?columns:1)*(levels?levels:1));
      dims=a.dims||(levels?3:(rows?2:1));
      layout=a.layout||(levels?123:(rows?12:1));
      dtn=a.dtn||'Float32Array';
      dt=TypedArrayOfName[a.dtn];
      if (!a.data) a.data=new dt(size);
      if (typeof BufferSegment != 'undefined' && a.data instanceof BufferSegment) {
        // Buffer segment allocated data
        this.block = a.data.object(a.dtn,size);
        a.data = this.block.data;
        delete this.block.data;
      } else if (typeof a.data == 'function') {
        // allocation function for a buffer returning array buffer or segment block with sliced buffer ..
        var block=a.data(size*DataSize[dtn.replace(/Array/,'')]);
        if (Utils.isBufferArray(block)) a.data=block; 
        else {
          this.block={addr:block.addr,size:block.size,segment:block.segment};
          a.data=block.data;
        }
      } else if (a.block) {
        // Buffer sgement allocated data, too
        this.block=a.block;
        var sm = BufferSegments[a.block.segment];
        if (sm) {
          var block = sm.object(dtn,size,this.block.addr);
          a.data=block.data;
        }
      } 
      
      if (Utils.isBuffer(a.data)) data=new dt(a.data.buffer,a.offset);
      else if (Utils.isBufferArray(a.data)) data=new dt(a.data,a.offset);
      else
        data=a.data;
  }
  if (levels) this.levels=levels;   // z
  this.rows     = rows;                   // x
  this.columns  = columns;             // x/y
  this.size     = size;              // number of elements
  this.layout   = layout;
  this.data     = data;
  this.dims     = dims;
  this.dataspace  = levels?[levels,rows,columns]:[rows,columns];
  this.length   = levels?levels:(rows?rows:columns);
  
  this.dtn=dtn||dt.name;
  this.datatype=this.dtn.replace(/Array/,'');
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  // get/set index order: 
  // 1. column(x)
  // 2. row(x),column(y)
  // 3. row(x),column(y),level(z)
  

  if (Matrix.options.compatLayout) {
    // Old WRONG layouts; but needed for backward compatibility! Enabled with Matrx.options.compatLayout=true;
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (column,row)   { return this.data[row][column] };
          this.set=function (column,row,v) { this.data[row][column]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[row][column][level] };
          this.set=function (row,column,level,v) { this.data[row][column][level]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 12:
        // x=row,y=column
        this.index = function (x,y)   { return x*this.columns+y}
        this.get = function (x,y)     { return this.data[x*this.columns+y] }
        this.set = function (x,y,v)   { return this.data[x*this.columns+y]=v }
        break;
      case 21:
        // x=row,y=column      
        this.index = function (x,y)   { return y*this.rows+x }
        this.get = function (x,y)     { return this.data[y*this.rows+x] }
        this.set = function (x,y,v)   { return this.data[y*this.rows+x]=v }
        break;
      case 123:
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+y*this.columns+x*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[z+y*this.levels*this.rows+x*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+y*this.levels*this.rows+x*this.levels]=v }
        break;
      case 321:
        // x=row,y=column,z=level
        // TBC
        this.index = function (x,y,z) { return x+y*this.rows+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[x+y*this.rows+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[x+y*this.rows+z*this.columns*this.rows]=v }
        break;
    }

  } else {
    // New correct layouts!
    if (this.dtn=='Array') {
      switch (this.layout) {
        case 12:
          this.get=function (row,column)   { return this.data[row][column] };
          this.set=function (row,column,v) { this.data[row][column]=v };
          break;
        case 21:
          // transposed view
          this.get=function (row,column)   { return this.data[column][row] };
          this.set=function (row,column,v) { this.data[column][row]=v };
          break;
        case 123:
          this.get=function (row,column,level)   { return this.data[level][row][column] };
          this.set=function (row,column,level,v) { this.data[level][row][column]=v };
          break;
       }
    } else switch (this.layout) {
      case 1:
        // C0,C1,..
        // x=column
        this.index = function (x)     { return x }
        this.get = function (x)       { return this.data[x] }
        this.set = function (x,v)     { return this.data[x]=v }
        break;
      case 21:
        // C0:R0R1..RM,C1:R0R1..RM,..
        // x=row,y=column
        this.index = function (x,y)   { return x+y*this.rows}
        this.get = function (x,y)     { return this.data[x+y*this.rows] }
        this.set = function (x,y,v)   { return this.data[x+y*this.rows]=v }
        break;
      case 12:
        // R0:C0C1..CN,R1:C0C1..CN,..
        // x=row,y=column      
        this.index = function (x,y)   { return y+x*this.columns }
        this.get = function (x,y)     { return this.data[y+this.columns*x] }
        this.set = function (x,y,v)   { return this.data[y+this.columns*x]=v }
        break;
      case 321:
        // C0: R0:L0L1..LO,R1:L0L1..LO,..
        // C1: ..
        // x=row,y=column,z=level
        // TBC??
        this.index = function (x,y,z) { return z+x*this.levels+y*this.levels*this.rows }
        this.get = function (x,y,z)   { return this.data[z+x*this.levels+y*this.levels*this.rows] }
        this.set = function (x,y,z,v) { return this.data[z+x*this.levels+y*this.levels*this.rows]=v }
        break;
      case 312:
        // RGB format!!!!!
        // R0: C0:L0L1..LO,C1:L0L1..LO,..
        // R1: ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return z+x*this.levels*this.columns+y*this.levels }
        this.get = function (x,y,z)   { return this.data[z+x*this.levels*this.columns+y*this.levels] }
        this.set = function (x,y,z,v) { return this.data[z+x*this.levels*this.columns+y*this.levels]=v }
        break;
      case 123:
        // Z0: R0:C0C1..CN,R1:C0C1..CN,.. 
        // Z1; ..
        // x=row,y=column,z=level
        this.index = function (x,y,z) { return y+x*this.columns+z*this.columns*this.rows }
        this.get = function (x,y,z)   { return this.data[y+x*this.columns+z*this.columns*this.rows] }
        this.set = function (x,y,z,v) { return this.data[y+x*this.columns+z*this.columns*this.rows]=v }
        break;
    }
  }
  this.__constructor__='Math.MatrixTA';
}



Matrix.options = {
  // Degault TA change must be applied to dt (and dtn)!
  dt : Float32Array,
  dtn : 'Float32Array',
  compatLayout : false,   // old wrong matrix layout for backward compatibility
}


/******** STATIC MEMBERS ********/
Matrix.abs = function (m) {
  return Matrix.clone(m).abs();
}

Matrix.add = function (m,v) {
  return Matrix.clone(m).add(v);
}

Matrix.clone = function (src) {
  return Matrix(src);
}

Matrix.columnVector = function (array) {
  return Matrix(array)
}

// Return an (typed)array
Matrix.checkArray = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof _MatrixConstructor) return arrayOrMatrix.data;
  else return arrayOrMatrix;
}

// Return a Matrix
Matrix.checkMatrix = function (arrayOrMatrix) {
  if (arrayOrMatrix instanceof Matrix) return arrayOrMatrix;
  else return Matrix(arrayOrMatrix);
}

Matrix.checkMatrixSize = function (matrix1,matrix2) {
  if (matrix1.dims != matrix2.dims) return false;
  if (matrix1.rows != matrix2.rows ||
      matrix1.columns != matrix2.columns ||
      matrix1.levels != matrix2.levels ) return false;
}

Matrix.cos = function (m) {
  return Matrix.clone(m).cos();
}

Matrix.crop = function (m,bbox) {
  if (m.dims!=2) throw "Matrix.crop: matrix.dims<>2";
  if (Utils.isArray(bbox)) {
    // [x,y,w,h]
    return m.subMatrix(bbox[1],bbox[1]+bbox[3]-1,
                       bbox[0],bbox[0]+bbox[2]-1)
  } else if (Utils.isObject(bbox) && bbox.w && bbox.h) {
    // {x,y,w,h}
    return m.subMatrix(bbox.y,bbox.y+bbox.h-1,
                       bbox.x,bbox.x+bbox.w-1)  
  } else if (Utils.isObject(bbox) && bbox.width && bbox.height) {
    // {x,y,width,height}
    return m.subMatrix(bbox.y,bbox.y+bbox.height-1,
                       bbox.x,bbox.x+bbox.width-1)  
  }
}

Matrix.diag = function (array,rows,columns) {
  if (!rows) rows=array.length;
  if (!columns) columns=rows;
  if (rows!=columns) Matrix.error("Not a square matrix",'diag');
  return Matrix(rows,columns).fill(function (i,j) {
    return i==j?array[i]:0;
  })
}

Matrix.div = function (m,v) {
  return Matrix.clone(m).div(v);
}

Matrix.empty = function (rows,columns) {
  return Matrix(rows,columns);
}

Matrix.error = function (what,where,ref) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.errorRange = function (what,where,ref) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

Matrix.eye = function (rows,columns,val,options) {
  if (!val) val=1;
  if (!columns) columns=rows;
  return Matrix(rows,columns,options).fill(function (i,j) {
    return i==j?val:0;
  });
}
 
Matrix.exp = function (m) {
  return Matrix.clone(m).exp();
}

// create an Uint8 RGB Matrix from raw RGBA image data [3,rows,columns]
// supports image descriptors {width,height,depth,data}, too
Matrix.fromImage = function (widthOrImage,height,imgData) {
  var image= {};
  if (typeof widthOrImage == 'object') {
    image = widthOrImage;
  } else {
    image.width=widthOrImage;
    image.height=height;
    image.depth=4;
    image.data=imgData;
  }
  // imgData is RGBA => RGB layout 123
  var mat = Matrix({
    rows:image.height,
    columns:image.width,
    levels:3,
    layouet:123,
    datatype : 'Uint8',
  })
  var row=0,col=0;
  for(var i=0;i<image.data.length;i=i+4) {
    var r=image.data[i],
        g=image.data[i+1],
        b=image.data[i+2],
        a=image.data[i+3]/255,
        r2=255,g2=255,b2 = 255;
    var r3 = Math.round(((1 - a) * r2) + (a * r))
    var g3 = Math.round(((1 - a) * g2) + (a * g))
    var b3 = Math.round(((1 - a) * b2) + (a * b))
    mat.set(row,col,0,r3);
    mat.set(row,col,1,g3);
    mat.set(row,col,2,b3);
    col++;
    if (col==image.width) { col=0; row++ };
  }
  return mat;
}

Matrix.isMatrix = function (o) {
  return (o instanceof Matrix)
}

// Identity matrix (squared)
Matrix.I = function (n,options) { return Matrix.eye(n,n,1,options) };

Matrix.max =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','max');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
    case 3:
      break;
  }
  return result;
}

Matrix.min =  function(matrix1, matrix2) {
  var result;
  matrix1 = this.checkMatrix(matrix1);
  matrix2 = this.checkMatrix(matrix2);
  if (!this.checkMatrixSize(matrix1,matrix2)) Matrix.error('matrix1 not compatble with matrix2','min');
  var rows = matrix1.rows;
  var columns = matrix1.columns;
  var levels = matrix1.levels;
  switch (matrix1.dims) {
    case 1:
      break;
    case 2:
      result = Matrix(rows, columns, levels, {dtn:matrix1.dtn});
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
        }
      }
      break;
  }
  return result;
}


Matrix.mod = function (m,v) {
  return Matrix.clone(m).mod(v);
}

Matrix.mul = function (m,v) {
  return Matrix.clone(m).mul(v);
}

Matrix.neg = function (m) {
  return Matrix.clone(m).neg();
}

Matrix.ones = function (rows,columns) {
  return Matrix(rows,columns).fill(1);
}

Matrix.rand = function (rows, columns, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return rng();
  });
}
/* rows, [cols,] [levels] options? */
Matrix.Random = function (a,b,c,d) {
  var dataspace=[],options={};
  if (typeof c == 'number') dataspace.push(c);  
  if (typeof a == 'number') dataspace.push(a);  
  if (typeof b == 'number') dataspace.push(b);  
  if (typeof a == 'object') options=a;
  if (typeof b == 'object') options=b;
  if (typeof c == 'object') options=c;
  if (typeof d == 'object') options=d;
  if (dataspace.length) options.dataspace=dataspace;
  if (!options.datatype) options.datatype='Float32';
  var mat = Matrix(options);
  var rng=Math.random;
  if (/int8/.test(options.datatype)) rng=function() { return (Math.random()*255)|0 };
  if (/int16/.test(options.datatype)) rng=function() { return (Math.random()*(65535))|0 };
  if (/int32/.test(options.datatype)) rng=function() { return (Math.random()*(4294967295))|0 };  
  mat.fill(rng);
  return mat
}
Matrix.randInt = function (rows, columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Matrix(rows,columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}
// resize a matrix (up- and downscaling) with different algorithms
// resize supports:
// 'nn': nearest neighbor algorihm (default, up- and down.scaling)
// 'mean': mean filter kernel (down-scaling)
// 'min': minimum value slection filter kernel (down-scaling)
// 'max': maximum value selection filter kernel (down-scaling)
// 'linear: bilinear filter kernel (up-sclaing)

Matrix.resize = function (src,a,b,c,d) {
  var dataspaceSrc=src.dataspace,
      datatype=src.datatype,
      meth='nn',
      options={},
      dataspaceDst=[];
  if (typeof a == 'number') dataspaceDst.push(a);
  if (typeof b == 'number') dataspaceDst.push(b);
  if (typeof c == 'number') dataspaceDst.push(c);
  if (typeof b == 'string') meth=b;
  if (typeof c == 'string') meth=c;
  if (typeof d == 'string') meth=d;  
  var dst = Matrix({dataspace:dataspaceDst,datatype:datatype});
  if (src.dims==2) {
    var rows=dst.rows,
        cols=dst.columns,
        rowsS=src.rows,
        colsS=src.columns,
        rowSD=rowsS/rows,
        colSD=colsS/cols;
    // default nearest neighbor method
    if (meth=='nn') {
      for(var i=0;i<rows;i++)
        for(var j=0;j<cols;j++) {
          var iS=Math.floor(i*rowSD),
              jS=Math.floor(j*colSD);
          dst.set(i,j,src.get(iS,jS)); 
      }
    } else if (meth=='mean') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var sum=0,n=0;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { sum+=v;  } n++; /* padding with zeros? */
          }
          return sum/n;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='max' || meth=='peak') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var max;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { max=max==undefined?v:Math.max(v,max) } 
          }
          return max;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='min') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var min;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              if (v!=undefined)  { min=min==undefined?v:Math.min(v,min) } 
          }
          return min;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else throw "Matrix.resize: not supported resize method";    
    } else if (meth=='linear') {
      if (rowSD>1 && colSD>1) {
        // TODO WRONG, CORRECT? rowR=Math.floor(rowSD)-1, ... !!!!!!!!!
        // down-scaling; interpolation
        var rowR=Math.ceil(1/rowSD),
            colR=Math.ceil(1/colSD);

        function kernel(row,col) {
          var sum=0,n=0;
          for(var i=row-rowR;i<=row+rowR;i++)
            for(var j=col-colR;j<=col+colR;j++) {
              var v = src.get(i,j);
              var w = 1-Math.distance([i-row,j-col])/Math.distance([rowR,colR]);
              if (v!=undefined)  { sum+=(v*w); }  n++; /* padding with zeros? */
          }
          return sum/n;
        }
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            var iS=Math.floor(i*rowSD),
                jS=Math.floor(j*colSD);
            dst.set(i,j,kernel(iS,jS));
        } 
      } else if (rowSD<1 && colSD<1) {
        // see https://chao-ji.github.io/jekyll/update/2018/07/19/BilinearResize.html
        var rowR=rowsS/rows,
            colR=colsS/cols;
        function kernel(i,j) {
          var x_l = Math.floor(colR * j), y_l = Math.floor(rowR * i)
              x_h = Math.ceil(colR * j),  y_h = Math.ceil(rowR * i);
          var x_weight = (colR * j) - x_l,
              y_weight = (rowR * i) - y_l;
          var a = src.get(y_l, x_l)||0,
              b = src.get(y_l, x_h)||0,
              c = src.get(y_h, x_l)||0,
              d = src.get(y_h, x_h)||0;
          return a * (1 - x_weight) * (1 - y_weight) + 
                 b * x_weight * (1 - y_weight) + 
                 c * y_weight * (1 - x_weight) + 
                 d * x_weight * y_weight
        }
        // up-scaling; extrapolation
        for(var i=0;i<rows;i++)
          for(var j=0;j<cols;j++) {
            dst.set(i,j,kernel(i,j));
        }
      } else throw "Matrix.resize: not supported resize method";
    } else throw "Matrix.resize: not supported resize method";
  }
  return dst;
}

Matrix.sin = function (m) {
  return Matrix.clone(m).sin();
}

Matrix.sub = function (m,v) {
  return Matrix.clone(m).sub(v);
}

// Returns now image descriptor { width, height, depth=4, data:UintArray }
Matrix.toImage = function (matrix) {
  // TODO matrix.layout != 123
  switch (matrix.dims) {
    case 2:
      var data = new Uint8Array(matrix.size*4);
      matrix.forEach(function (v,row,col) {
        data[0+col*4+row*matrix.columns*4]=v;
        data[1+col*4+row*matrix.columns*4]=v;
        data[2+col*4+row*matrix.columns*4]=v;
        // set alpha to 255
        data[3+col*4+row*matrix.columns*4]=255;
      });
      break;
    case 3:
      var data = new Uint8Array(matrix.rows*matrix.columns*4);
      matrix.forEach(function (v,row,col,level) {
        data[level+col*4+row*matrix.columns*4]=v;
        // set alpha to 255
        data[3+col*4+row*matrix.columns*4]=255;
      });
      break;
  }
  return { width:matrix.columns, height:matrix.rows, depth:4, data : data };
}

Matrix.zero = function (rows,columns) {
  return Matrix(columns,rows).fill(0);
}

Matrix.version = version;

/********* INSTANCE MEMBERS *********/


Matrix.prototype.abs = function (v) {
  this.eval(Math.abs);
  return this; 
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.add = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] += v.data[i];
    return result;
  } else result.eval(function (x) {return x+v});
  return result; 
}

// Apply a function to all elements AND update the elements by the return value of f!
Matrix.prototype.apply = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        this.set(j,f.call(this,this.get(j),j))
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          this.set(i,j,f.call(this,this.get(i,j),i,j))
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            this.set(i,j,k,f.call(this,this.get(i,j,k),i,j,k))
      return this;
  }
}

// Iterate over all elements of matrix and apply function to matrix elements (w/o matrix update)
Matrix.prototype.forEach = function (f) {
  var i,j,k;
  switch (this.dims) {
    case 1:
      for(j=0; j < this.columns; j++) 
        f.call(this,this.get(j),j)
      return this;
    case 2:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          f.call(this,this.get(i,j),i,j)
      return this;
    case 3:
      for(i=0; i<this.rows;i++) 
        for(j=0; j < this.columns; j++) 
          for(k=0; k<this.levels;k++) 
            f.call(this,this.get(i,j,k),i,j,k)
      return this;
  }
}

Matrix.prototype.checkIndex = function(x,y,z) {
  switch (this.dims) {
    case 1: return x>=0&&x<this.columns;
    case 2: return y>=0&&y<this.columns&&x>=0&&x<this.rows;
    case 3: return y>=0&&y<this.columns&&x>=0&&x<this.rows&&z>=0&&z<this.levels;
  }
}

Matrix.prototype.checkMatrixDims = function(dims) {
  if (this.dims != dims) this.errorRange('Matrix has not expected dimension '+dims);
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkColumnIndex = function(index, outer) {
  var max = outer ? this.columns : this.columns - 1;
  if (index < 0 || index > max) this.errorRange('Column index out of range');
}


/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
Matrix.prototype.checkRowIndex = function(index, outer) {
  var max = outer ? this.rows : this.rows - 1;
  if (index < 0 || index > max)
    this.errorRange('Row index out of range');
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkRowVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.columns) 
    this.errorRange(
      'vector size must be the same as the number of columns'
    );
  
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
Matrix.prototype.checkColumnVector = function(vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== this.rows) 
    this.errorRange('vector size must be the same as the number of rows');
  
  return vector;
}

Matrix.prototype.checkIndices = function(rowIndices, columnIndices) {
  return {
    row: this.checkRowIndices(rowIndices),
    column: this.checkColumnIndices(columnIndices)
  };
}

Matrix.prototype.checkRowIndices = function(rowIndices) {
  var self=this;
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= self.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

Matrix.prototype.checkColumnIndices = function(columnIndices) {
  var self=this;
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= self.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

Matrix.prototype.checkRange = function(startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 4) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= this.rows ||
    endRow < 0 ||
    endRow >= this.rows ||
    startColumn < 0 ||
    startColumn >= this.columns ||
    endColumn < 0 ||
    endColumn >= this.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

Matrix.prototype.clone = function () {
  return Matrix(this);
}


// Return array or vector
Matrix.prototype.col = function (index,asVector) {
  var col=[];
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 2: col=this.data.pluck(index); break;
        case 3: throw new Error ('EINVALID');
      }
    default:
      switch (this.dims) {
        case 2: for(var i=0;i<this.rows;i++) col.push(this.get(i,index)); break;
        case 3: throw new Error ('EINVALID');
      }
  }
  return asVector?Math.VectorTA(col,{dtn:this.dtn}):col;
}

Matrix.prototype.getCol = Matrix.prototype.col;
Matrix.prototype.pluck = Matrix.prototype.col;

/** Copy (1) a sorurce array (vector) into this matrix (row/column w or w/o subrange), or (2) create a copy of this matrix (empty argument list)
 *
 * copy()
 * copy([a,b]|[],[v1,v2,...])
 * copy(number,[a,b]|[],[v1,v2,...])
 * copy([a,b]|[],number,[v1,v2,...])
 * copy(number,number,[a,b]|[],[v1,v2,...])
 * ..
 */
 
Matrix.prototype.copy = function (a,b,c,d) {
  var x,y,z,rx,ry,rz,i,j,k,src;

  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;

  if (isArray(d)) src=d;
  if (isVector(d)) src=d;
  
  if (!src && !d && (isArray(c) || isVector(c))) src=c,rz=undefined;
  if (!src && !c && (isArray(b) || isVector(b))) src=b,ry=undefined;
  if (!src && !a && (isArray(a) || isVector(a))) src=a,rx=[0,this.columns-1];  // 1-dim only
    
  if (isVector(src)) src=src.data;
  if (!src) return Matrix({
    rows:this.rows,
    columns:this.columns,
    levels:this.levels,
    dtn:this.dtn,
    layout:this.layout,
    data:this.data.slice()
  })
  
  if (!src) throw "Matrix.copy: no source array provided";
  if (rx && rx.length==0) rx=[0,this.rows-1];
  if (ry && ry.length==0) ry=[0,this.columns-1];
  if (rz && rz.length==0) rz=[0,this.levels-1];
  if (rx && (rx[1]-rx[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (ry && (ry[1]-ry[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
  if (rz && (rz[1]-rz[0]+1)!=src.length) throw "Matrix.copy: range mismatch (src)"
   
  switch (this.dims) {
    case 1:
      for(x=rx[0];x<rx[1];x++) this.data[x]=src[x-rx[0]];
      break;
    case 2:
      if (rx && j != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j)]=src[x-rx[0]];
      else if (i != undefined && ry)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y)]=src[y-ry[0]];
      else todo('copy 2'); 
      break;   
    case 3:
      if (rx && j != undefined && k != undefined)
        for(x=rx[0];x<=rx[1];x++) 
          this.data[this.index(x,j,k)]=src[x-rx[0]];
      else if (ry && i != undefined && k != undefined)
        for(y=ry[0];y<=ry[1];y++) 
          this.data[this.index(i,y,k)]=src[y-ry[0]];
      else if (rz && i != undefined && j != undefined)
        for(z=rz[0];z<=rz[1];z++) 
          this.data[this.index(i,j,z)]=src[z-rz[0]];
      else todo('copy 3');    
      break;
  }
  return this;
}

/** Convert size using a data filter.
 ** TODO: actually only down-sizing is sipported! Need up-sizing, too
 ** The target size must be provided.
 *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
 */

Matrix.prototype.convert = function (a,b,c,d) {
  var i,j,k,l,p,v,m,ni,nj,nk,filter;
  
  if (isNumber(a)) i=a;
  if (isNumber(b)) j=b;
  if (isNumber(c)) k=c;
  if (isString(b)) filter=b;
  if (isString(c)) filter=c;
  if (isString(d)) filter=d;
  if (!filter) filter='mean';

  if (!i) throw "Matrix.convert: no target size (number, first dim.)";
  if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";
    
  if (!k) k= {datatype:this.datatype,layout:this.layout}
  else l= {datatype:this.datatype,layout:this.layout}
  m = Matrix(i,j,k,l);
      
  if (typeof filter != 'function') switch (filter) {
    case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
    case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
    case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
    case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
    case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
    case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
    default:          filter = function () { return 0 }
  }
  switch (this.dims) {
    case 1:
      ni=Math.floor(this.columns/m.columns);
      if (ni>0) {
        for(i=0;i<m.columns;i++) {
          v=this.data[i*ni]; 
          for(p=1;p<ni;p++) {
            v=filter(v,this.data[i*ni+p],p,ni);
          }
          m.data[i]=v;
        }
      } else {
        // TODO up-sizing
      }
      break;
    case 2:
      // TBC
      ni=Math.floor(this.rows/m.rows);
      nj=Math.floor(this.columns/m.columns);
      if (ni>0 && nj>0) {
        for(i=0;i<m.rows;i++) {
          for(j=0;j<m.columns;j++) {
            for(p=0;p<ni;p++) {
              for(q=0;q<nj;q++) {
                if (p==0 && q==0) 
                  v=this.get(i*ni,j*nj);
                else
                  v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
              }
            }
            m.set(i,j,v);
          }
        }
      } else {
        // TODO: up-sizing
      }
      break;
  }
  return m;
}


Matrix.prototype.cos = function (v) {
  this.eval(Math.cos);
  return this; 
}

Matrix.prototype.diag = function (v) {
  if (v!=undefined) {
    // set diagonal
    if (this.rows!=this.columns) return;
    for(var i=0;i<this.rows;i++) this.set(i,i,v);
    return this;
  }
  // TODO Vector
  var a = [];
  if (this.rows!=this.columns) return;
  for(var i=0;i<this.rows;i++) a.push(this.get(i,i));
  return a; 
}

Matrix.prototype.dim = function () {
  switch (this.dims) {
    case 1: return [this.columns];
    case 2: return [this.rows,this.columns];
    case 3: return [this.rows,this.columns,this.levels];
  }
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.div = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] /= v.data[i];
    return result;
  } else result.eval(function (x) {return x/v});
  return result; 
}

Matrix.prototype.divide = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)/b);
    case 2: return this.set(a,b,this.get(a,b)/c);
    case 3: return this.set(a,b,c,this.get(a,b,c)/d);
  }
}

Matrix.prototype.error = function (what,where) {
  throw new Error((where?('Matrix.'+where+': '):'')+what);
}

Matrix.prototype.errorRange = function (what,where) {
  throw new RangeError((where?('Matrix.'+where+': '):'')+what);
}

// Evaluate all elements x of matrix by applying function f(x)
Matrix.prototype.eval = function (f) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            this.set(i,f(this.get(i)))
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              this.set(i,j,f(this.get(i,j)))
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                this.set(i,j,k,f(this.get(i,j,k)))
          break;
      }
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i]);
  }
  return this;
}

Matrix.prototype.exp = function (v) {
  this.eval(Math.exp);
  return this; 
}

Matrix.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
    switch (this.dims) {
      case 1:
        for(i=0; i < this.columns; i++) 
          this.set(i,valueOrFunction(i.j))
        return this;
      case 2:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            this.set(i,j,valueOrFunction(i,j))
        return this;
      case 3:
        for(i=0; i < this.rows;i++) 
          for(j=0; j < this.columns; j++) 
            for(k=0; k < this.levels; k++) 
              this.set(i,j,k,valueOrFunction(i,j,k))
        return this;
    }
  } else this.data.fill(valueOrFunction);
  return this;
}

// Flattens a matruix by reducing the dimension
// [level,rows,columns] -> [rows,columns]
// [rows,columns] -> [rows]
Matrix.prototype.flatten = function (flatten) {
  if (!flatten) flatten=function (vl) { return vl.reduce(function (a,b) { return a+b }) };
  switch (this.dims) {
    case 3:
      var mf = Matrix(this.rows,this.columns,{datatype:this.datatype});
      for (var row=0;row<this.rows;row++) {
        for (var col=0;col<this.columns;col++) {
          var vl=[];
          for (var z=0;z<this.levels;z++) {
            vl.push(this.get(row,col,z));
          }
          mf.set(row,col,flatten(vl)/this.levels);
        }
      }
      return mf;
      break;
  }
}
Matrix.prototype.forEach = function (f,linear) {
  var i,j,k;
  switch (this.dtn) {
    case 'Array':
      switch (this.dims) {
        case 1:
          for(i=0; i < this.columns; i++) 
            f.call(this,this.get(i),i)
          break;
        case 2:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              f.call(this,this.get(i,j),i,j)
          break
        case 3:
          for(i=0; i < this.rows;i++) 
            for(j=0; j < this.columns; j++) 
              for(k=0; k < this.levels; k++) 
                f.call(this,this.get(i,j,k),i,j,k)
          break;
      }
      break;
    default:
      if (linear) for(i=0;i<this.size;i++) {
        f.call(this,this.data[i],i);
      } else {
        switch (this.dims) {
          case 1:
            for(i=0; i < this.columns; i++) 
              f.call(this,this.get(i),i)
            break;
          case 2:
            for(i=0; i < this.rows;i++) 
              for(j=0; j < this.columns; j++) 
                f.call(this,this.get(i,j),i,j)
            break
          case 3:
            for(i=0; i < this.rows;i++) 
              for(j=0; j < this.columns; j++) 
                for(k=0; k < this.levels; k++) 
                  f.call(this,this.get(i,j,k),i,j,k)
            break;
        }      
      }
  }
  return this;
}

// x += delta
Matrix.prototype.incr = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)+b);
    case 2: return this.set(a,b,this.get(a,b)+c);
    case 3: return this.set(a,b,c,this.get(a,b,c)+d);
  }
}

Matrix.prototype.info = function () {
  var o = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    layout:this.layout,
    dims:this.dims,
    dataspace:this.dataspace,
    datatype:this.datatype,
  }
  if (this.rows) o.rows=this.rows;
  if (this.levels) o.levels=this.levels;
  if (this.scaler) o.scaler=this.scaler;
  if (this.complex) o.complex=true;
  return o;
}


Matrix.prototype.isColumnVector = function () {
   return this.columns === 1;
}

Matrix.prototype.isEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isEchelonForm = false;
        checked = true;
      }
    }
    i++;
  }
  return isEchelonForm;
}

Matrix.prototype.isReducedEchelonForm = function () {
  this.checkMatrixDims(2);
  var i = 0;
  var j = 0;
  var previousColumn = -1;
  var isReducedEchelonForm = true;
  var checked = false;
  while ((i < this.rows) && (isReducedEchelonForm)) {
    j = 0;
    checked = false;
    while ((j < this.columns) && (checked === false)) {
      if (this.get(i, j) === 0) {
        j++;
      } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
        checked = true;
        previousColumn = j;
      } else {
        isReducedEchelonForm = false;
        checked = true;
      }
    }
    for (var k = j + 1; k < this.rows; k++) {
      if (this.get(i, k) !== 0) {
        isReducedEchelonForm = false;
      }
    }
    i++;
  }
  return isReducedEchelonForm;
}
Matrix.prototype.isRowVector = function () {
   return this.rows === 1;
}

Matrix.prototype.isSquare = function () {
  return this.rows==this.columns
}

Matrix.prototype.isSymmetric = function () {
  if (this.isSquare()) {
        for (var i = 0; i < this.rows; i++) {
          for (var j = 0; j <= i; j++) {
            if (this.get(i, j) !== this.get(j, i)) {
              return false;
            }
          }
        }
        return true;
      }
  return false;
}

/** Iterate over matrix elements
 * Parameter arrays specify iteration ranges, FORALL='*' specifies a target vector range
 * iter(function (@elem,@index,@array))
 * iter(number [],function)
 * iter(number [],number [],function)
 * iter(number [],number [],number [],function)
 * Examples: 
 *  m.iter(FORALL,[],[],f)   <=> for all x-vectors with y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([], FORALL,[],f)  <=> for all y-vectors with x in [0,j-1], z in [0,k-1] do .. 
 *  m.iter([],[],[],f)       <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *  m.iter(f)                <=> for all values with x in [0,i-1], y in [0,j-1], z in [0,k-1] do .. 
 *
 *
 */
  
Matrix.prototype.iter = function (a,b,c,d) {
  var func,rx,ry,rz,x,y,z,
      self=this;
  if (isFunction(a)) func=a;
  else if (isFunction(b)) func=b;
  else if (isFunction(c)) func=c;
  else if (isFunction(d)) func=d;
  if (isArray(a)) rx=a;
  if (isArray(b)) ry=b;
  if (isArray(c)) rz=c;
  if (isString(a)) rx=a;
  if (isString(b)) ry=b;
  if (isString(c)) rz=c;
  if (!func) throw "Matrx.iter: no function supplied";
  if (!rx && !ry && !rz) // linear iteration over all elements
    return this.data.forEach(func);
  switch (this.dims) {
    case 1: break;
  // TODO
      todo('iter 1')
    case 2: break;
  // TODO
      todo('iter 2')
    case 3:
      if (isArray(rx) && rx.length==0) rx=[0,this.rows];
      if (isArray(ry) && ry.length==0) ry=[0,this.columns];
      if (isArray(rz) && rz.length==0) rz=[0,this.levels];
      if (rz == FORALL) {
        for(x=rx[0];x<rx[1];x++) {
          for(y=ry[0];y<ry[1];y++) {
            func(x,y,this.subMatrixRange(x,y,ALL))
          }
        }
      } else if (rx==FORALL) {
  // TODO
        todo('iter 3.ryx=FORALL')
      
      } else if (ry==FORALL) {
  // TODO
        todo('iter 3.ry=FORALL')
      
      } else {
        // single data cell iteration
  // TODO
        todo('iter 3')
      }
  }
  // TODO
  return this;
}

Matrix.prototype.map = function (f,asArray) {
  var res,i,j,k;
  switch (this.dims) {
    case 1:
      res = Matrix(this.columns,{dtn:asArray?'Array':this.dtn});
      for(j=0;j<this.columns;j++)
        res.set(j,f(this.get(j),j));
      break;
    case 2:
      res = Matrix(this.rows,this.columns,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          res.set(i,j,f(this.get(i,j),i,j));
      break;
    case 3:
      res = Matrix(this.rows,this.columns,this.levels,{dtn:asArray?'Array':this.dtn});
      for(i=0;i<this.rows;i++)
        for(j=0;j<this.columns;j++)
          for(k=0;k<this.levels;k++)
            res.set(i,j,k,f(this.get(i,j,k),i,j,k));
      break;
  }
  return res;
}


// Row mapping function
Matrix.prototype.mapRow = function (f) {
  var res=[];
  for(var row=0;row<this.rows;row++) {
    res.push(f(this.getRow(row),row));
  }
  return res;
}

/** Return minimum and maximum value of the matrix
 *
 */
Matrix.prototype.minmax = function () {
  var d0=Number.MAX_VALUE,d1=-Number.MAX_VALUE;
  for (i = 0;i < this.size; i++) {
    d0=Math.min(d0,this.data[i]);
    d1=Math.max(d1,this.data[i]);    
  }
  return { min:d0, max:d1 };
}
Matrix.prototype.max = function () {
  return this.minmax().max
}
Matrix.prototype.min = function () {
  return this.minmax().min
}
Matrix.prototype.mapToArray = function (f) {
  var res = new Array(this.size);
  for(var i=0;i<this.rows;i++)
    for(var j=0;j<this.columns;j++)
      res[i*this.columns+j]=f?f(this.get(i,j),i,j):this.get(i,j);
  return res;
}

Matrix.prototype.mapToArrayArray = function (f) {
  var res = new Array(this.rows);
  for(var i=0;i<this.rows;i++) {
    res[i]=new Array(this.columns);
    for(var j=0;j<this.columns;j++)
      res[i][j]=f?f(this.get(i,j),i,j):this.get(i,j);
  }
  return res;
}

Matrix.prototype.mapToArrayArrayArray = function (f) {
  var res = new Array(this.levels);
  for(var i=0;i<this.levels;i++) {
    res[i]=new Array(this.rows);
    for(var j=0;j<this.rows;j++) {
      res[i][j]=new Array(this.columns);
      for(var k=0;k<this.columns;k++) {
        res[i][j][k]=f?f(this.get(i,j,k),i,j,k):this.get(i,j,k);
      }
    }
  }
  return res;
}

// x *= k
Matrix.prototype.multiply = function (a,b,c,d) {
  switch (this.dims) {
    case 1: return this.set(a,this.get(a)*b);
    case 2: return this.set(a,b,this.get(a,b)*c);
    case 3: return this.set(a,b,c,this.get(a,b,c)*d);
  }
}

Matrix.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Matrix.prototype.mod = function (v) {
  this.eval(function (x) {return x%v});
  return this; 
}

/**
     * Returns the matrix product between this and other
     * @param {Matrix} other
     * @return {Matrix}
     */
Matrix.prototype.mmul = function (other) {
  this.checkMatrixDims(2);
  other = Matrix.checkMatrix(other);
  if (this.columns !== other.rows) {
    // eslint-disable-next-line no-console
    console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
  }

  var m = this.rows;
  var n = this.columns;
  var p = other.columns;

  var result = Matrix(m, p, {dtn:this.dtn});

  var Bcolj = new Array(n);
  for (var j = 0; j < p; j++) {
    for (var k = 0; k < n; k++) {
      Bcolj[k] = other.get(k, j);
    }
    for (var i = 0; i < m; i++) {
      var s = 0;
      for (k = 0; k < n; k++) {
        s += this.get(i, k) * Bcolj[k];
      }
      result.set(i, j, s);
    }
  }
  return result;
}

// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.mul = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] *= v.data[i];
    return result;
  } else result.eval(function (x) {return x*v});
  return result; 
}

Matrix.prototype.neg = function (v) {
  this.eval(function (x) {return -x});
  return this; 
}

Matrix.prototype.prod = function (v) {
  var i,j,k,v = 1;
  // Comp. mode
  switch (this.dtn+this.dims) {
    case 'Array1':
      for (i = 0; i < this.columns; i++) {
          v *= this.data[i];
      }
      break;
    case 'Array2':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          v *= this.data[i][j];
        }
      }
      break;
    case 'Array3':
      for (i = 0; i < this.rows; i++) {
        for (j = 0; j < this.columns; j++) {
          for (k = 0; k < this.levels; k++) {
            v *= this.data[i][j][k];
          }
        }
      }
      break;
    default:
      for (i = 0; i < this.size; i++) v *= this.data[i];
  }
  return v;
}

Matrix.prototype.print = function (format) {
  var i,j,k,s='',sep='';
  if (!format) format = '%4.2f';
  switch (this.dims) {
    case 1:
      for(i=0;i<this.columns;i++) {
        if (i!=0) s = s + '\n';
        s = s + sprintf(format,this.get(i)) ;
      }
      break;
    case 2:
      for(i=0;i<this.rows;i++) {
        sep = '';
        if (i!=0) s = s + '\n';
        for (j=0;j<this.columns;j++) {
          s = s + sep + sprintf(format,this.get(i,j)) ;
          sep = ' ';
        }
      }
      break;
    case 3:
      for(k=0;k<this.levels;k++) {
        if (k!=0) s = s + '\n\n';
        for(i=0;i<this.rows;i++) {
          sep = '';
          if (i!=0) s = s + '\n';
          for (j=0;j<this.columns;j++) {
            s = s + sep + sprintf(format,this.get(i,j,k)) ;
            sep = ' ';
          }
        }
      }
  }  
  return s;
}

/** Reduce dimension: Linear matrix data reduction applying a function (a,b) -> c to all elements.
 *  Returns a scalar value or any other object accumulated by the supplied function
 */
Matrix.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

// Return array or vector (layout=12: matrix view if !copy)
Matrix.prototype.row = function (index,asVector,copy) {
  this.checkMatrixDims(2);
  this.checkRowIndex(index);
  var row,data,i,j;
  switch (this.dtn) {
    case 'Array':
      if (this.layout==12) {
        if (!asVector)
          return this.data[index];
        else
          return Vector(this.data[index]);
      } else {
        // transposed view
        if (!asVector) {
          row = new Array(this.columns);
          if (this.rows==1) return this.data;
          for (i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
        } else {
          if (this.rows==1) return this.data;
          row= Vector(this.columns,{dtn:this.dtn});
          for (i = 0; i < this.columns; i++) {
            row.set(i, this.get(index, i));
          };
        }  
      }
      break;
    default:
      // With advanced slicing
      if (!asVector) {
        row = new Array(this.columns);
        if (this.rows==1) return this.data.toArray();
        for (i = 0; i < this.columns; i++) {
          row[i] = this.get(index, i);
        }
      } else if (this.layout == 12) {
        if (copy) {
          data = this.data.slice(index*this.columns,(index+1)*this.columns);
          row= Vector({dtn:this.dtn,data:data,columns:this.columns});
        } else {
          row= Vector({dtn:this.dtn,data:this.data,offset:index*this.columns,columns:this.columns});
        }
      } else {
        if (this.rows==1) return this.data;
        row= Vector(this.columns,{dtn:this.dtn});
        for (i = 0; i < this.columns; i++) {
          row.set(i, this.get(index, i));
        };
      }   
  }
  
  return row;
}
Matrix.prototype.getRow=Matrix.prototype.row;

/** resize matrix
** NO: (only modifying meta data - not buffer data)
** YES: interpol/extrapol
 *  TODO: offset
 */
Matrix.prototype.resize = function (options) {
  for(var p in options) {
    switch (p) {
      case 'rows':
      case 'columns':
      case 'levels':
        this[p]=options[p];
        break;
      case 'offset':
        // TODO
        break;
    }
  }
  this.size=this.columns*(this.rows?this.rows:1)*(this.levels?this.levels:1);
  this.length=this.rows?this.rows:this.columns;
  return this
}


Matrix.prototype.reverseRow = function (row) {
  var t,len=this.columns;
  for(var i=0;i<(len/2)|0;i++) {
    t=this.get(row,i);
    this.set(row,i,this.get(row,len-i-1));
    this.set(row,len-i-1,t);
  }
  return this; 
}

/** Scale (and/or adjust offset optionally of) all matrix elements -= offset *= k
 * scale(k)
 * scale(k,inplace:boolean)
 * scale(k,offset)
 * scale(k,offset,inplace:boolean)
 */
 
Matrix.prototype.scale = function (a,b,c) {
  var m,k=1,offset,inplace=false;
  if (isNumber(a)) k=a;
  if (isBoolean(b)) inplace=b;
  else if (isBoolean(c)) inplace=c;
  if (isNumber(b)) offset=b;
  else if (isNumber(c)) offset=c;
  
  m = inplace?this:this.copy();
  if (k!=1) {
    if (offset)
      for(var i=0;i<m.data.length;i++) m.data[i]=(m.data[i]-offset)*k;
    else
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]*k;
  } else if (offset) {
      for(var i=0;i<m.data.length;i++) m.data[i]=m.data[i]-offset;  
  }
  return m;
}

/*
Return a new matrix based on a selection of rows and columns
selection(rowIndices: Array<number>, columnIndices: Array<number>): Matrix
Parameters
rowIndices (Array<number>) The row indices to select. Order matters and an index can be more than once.
columnIndices (Array<number>) The column indices to select. Order matters and an index can be use more than once.
Returns 
Matrix: The new matrix 
*/
Matrix.prototype.selection = function (rowIndices,columnIndices) {
  this.checkMatrixDims(2);
  var newMatrix = Matrix(rowIndices.length,columnIndices.length,{dtn:this.dtn});
  for (var i = 0; i < rowIndices.length; i++) {
    var rowIndex = rowIndices[i];
    for (var j = 0; j < columnIndices.length; j++) {
      var columnIndex = columnIndices[j];
      newMatrix.set(i,j, this.get(rowIndex, columnIndex));
    }
  }
  return newMatrix;
}


// Set a row of the matrix
Matrix.prototype.setRow = function (row,data) {
  data=Matrix.checkArray(data);
  for(var i=0;i<this.columns;i++) {
     this.set(row,i,data[i]); 
  }
}

// Share a matrix (data must be either a sharedarraybuffer or a buffer segment object
Matrix.prototype.__share = function () {
  if (this.block) {
    // Matrix buffer is part of a Shared Memory Segment Buffer (SMS) TODO
    return {
      data : { data : [], block : this.block, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn   : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  } else if (typeof SharedArrayBuffer != 'undefined' && this.data instanceof SharedArrayBuffer) {
    // Browser/Web Worker: Shared Array Buffer
    return {
      data : { data : this.data, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn  : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  } else if (typeof SharedArrayBuffer != 'undefined' && this.data.buffer instanceof SharedArrayBuffer) {
    // Browser/Web Worker: Shared Array Buffer
    return {
      data : { data : this.data.buffer, rows:this.rows, columns:this.columns, levels:this.levels,
               dtn  : this.dtn, datatype : this.datatype },
      eval : 'function (data) { return Math.MatrixTA(data) }',
    }
  }
}
// Slice of data in major dimension
Matrix.prototype.slice = function (i,offset) {
  var rows,columns,levels;
  switch (this.dims) {
    case 1:
      return Matrix(this,{columns:i,offset:offset,slice:true});
      break;
    case 2:
    case 3:
      return Matrix(this,{rows:i,offset:offset,slice:true});
      break;
  }
}

Matrix.prototype.sin = function () {
  this.eval(Math.sin);
  return this;
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Matrix.prototype.size = function () {
  return  this.size;
}


// 1. Add constant value to all elements 2. Add two matrix element wise
Matrix.prototype.sub = function (v,copy) {
  var result=copy?Matrix.clone(this):this;
  if (Matrix.isMatrix(v)) {
    // TODO check |data|=|this|
    for (var i=0;i<result.data.length;i++) result.data[i] -= v.data[i];
    return result;
  } else result.eval(function (x) {return x-v});
  return result; 
}


/** Return a sub-matrix (2 dims only)
 *
 */
Matrix.prototype.subMatrix = function (startRow, endRow, startColumn, endColumn) {
  this.checkMatrixDims(2);
  this.checkRange(startRow, endRow, startColumn, endColumn);
  var newMatrix = Matrix(endRow - startRow + 1, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = startRow; i <= endRow; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      newMatrix.set(i - startRow,j - startColumn, this.get(i, j));
    }
  }
  return newMatrix;
}

/** Return a sub-matrix (1-3 dims)
 *
 * rx:row,ry:column,rz?:level
 */
Matrix.prototype.subMatrixRange = function (rx,ry,rz) {
  var i,j,i0,i1,x0,x1,y0,y1,z0,z1,res;
  switch (this.dims) {
    case 1:
      // simple case, return sliced array
      x0=0,x1=this.i-1;
      if (isRange(rx)) x0=rx[0],x1=rx[1];
      else throw "Matrix.subMatrixRange: no range";
      var i0=x0,i1=i0+1+x1;
      return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
    case 2:
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    case 3:
      if ((isAll(rz) || (isRange(rz))) && isNumber(rx) && isNumber(ry) && (Matrix.options.compatLayout?this.layout==123:this.layout==321)) {
        // simple case, return sliced array (1-dim matrix)
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        var i0=this.index(rx,ry,z0),i1=i0+1+z1;
        return Vector({data:this.data.slice(i0,i1),columns:i1-i0,dtn:this.dtn});
      } else if (isNumber(rz)) {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=rz;
        res = Matrix(x1-x0+1,y1-y0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            res.set(i-x0,j-y0, this.get(i,j,z0));
        return res;
      } else  {
        x0=0,x1=this.rows-1;
        if (isNumber(rx)) x0=x1=rx;
        if (isRange(rx)) x0=rx[0],x1=rx[1];
        y0=0,y1=this.columns-1;
        if (isRange(ry)) y0=ry[0],y1=ry[1];
        if (isNumber(ry)) y0=y1=ry;
        z0=0,z1=this.levels-1;
        if (isRange(rz)) z0=rz[0],z1=rz[1];
        if (isNumber(rz)) z0=z1=rz;        
        res = Matrix(x1-x0+1,y1-y0+1,z1-z0+1,{dtn:this.dtn});
        for(i=x0;i<=x1;i++)
          for(j=y0;j<=y1;j++)
            for(var k=z0;k<=z1;k++)
              res.set(i-x0,j-y0,k-z0,this.get(i,j,k));
        return res;
      }
  }
}

Matrix.prototype.subMatrixRow = function (indices, startColumn, endColumn) {
  this.checkMatrixDims(2);
  if (startColumn === undefined) startColumn = 0;
  if (endColumn === undefined) endColumn = this.columns - 1;
  if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(indices.length, endColumn - startColumn + 1, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startColumn; j <= endColumn; j++) {
      if (indices[i] < 0 || indices[i] >= this.rows) {
        throw new RangeError('Row index out of range: '+indices[i]);
      }
      newMatrix.set(i, j - startColumn, this.get(indices[i], j));
    }
  }
  return newMatrix;
}

Matrix.prototype.subMatrixColumn = function (indices, startRow, endRow) {
  this.checkMatrixDims(2);
  if (startRow === undefined) startRow = 0;
  if (endRow === undefined) endRow = this.rows - 1;
  if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
    throw new RangeError('Argument out of range');
  }

  var newMatrix = Matrix(endRow - startRow + 1, indices.length, {dtn:this.dtn});
  for (var i = 0; i < indices.length; i++) {
    for (var j = startRow; j <= endRow; j++) {
      if (indices[i] < 0 || indices[i] >= this.columns) {
        throw new RangeError('Column index out of range: '+indices[i]);
      }
      newMatrix.set(j - startRow, i, this.get(j, indices[i]));
    }
  }
  return newMatrix;
}


Matrix.prototype.subRowVector = function (vector) {
  this.checkMatrixDims(2);
  vector = this.checkRowVector(vector);
  for (var i = 0; i < this.rows; i++) {
    for (var j = 0; j < this.columns; j++) {
      this.set(i, j, this.get(i, j) - vector[j]);
    }
  }
  return this;
}

Matrix.prototype.setSubMatrix = function (matrix, startRow, startColumn) {
  matrix = this.checkMatrix(matrix);
  this.checkMatrixDims(2);
  matrix.checkMatrixDims(2);
  var endRow = startRow + matrix.rows - 1;
  var endColumn = startColumn + matrix.columns - 1;
  this.checkRange(startRow, endRow, startColumn, endColumn);
  for (var i = 0; i < matrix.rows; i++) {
    for (var j = 0; j < matrix.columns; j++) {
      this.set(startRow + i,startColumn + j) = matrix.get(i, j);
    }
  }
  return this;
}

Matrix.prototype.sum = function (by) {
  var i,j,k,v=0;
  switch (by) {
    case 'row':
      return this.sumByRow();
    case 'column':
      return this.sumByColumn();
    default:
      switch (this.dtn+this.dims) {
        case 'Array1':
          for (i = 0; i < this.columns; i++) {
              v += this.data[i];
          }
          break;
        case 'Array2':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              v += this.data[i][j];
            }
          }
          break;
        case 'Array3':
          for (i = 0; i < this.rows; i++) {
            for (j = 0; j < this.columns; j++) {
              for (k = 0; k < this.levels; k++) {
                v += this.data[i][j][k];
              }
            }
          }
          break;
        default:
          for (i = 0; i < this.size; i++) v += this.data[i];
      }
      return v;
  }
}

Matrix.prototype.sumByRow = function () {
  var sum = Matrix.zeros(this.rows, 1);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.sumByColumn = function() {
  var sum = Matrix.zeros(1, this.columns);
  for (var i = 0; i < this.rows; ++i) {
    for (var j = 0; j < this.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + this.get(i, j));
    }
  }
  return sum;
}

Matrix.prototype.toCsv = function (sep) {
  sep=sep||',';
  switch (this.dims) {
    case 1: return Array.from(this.data).join('\n');
    case 2: return this.mapToArrayArray().map(function (row) {
      return row.join(sep);
    }).join('\n');
  }
}

Matrix.prototype.toArray = function (rx,ry,rz) {
  switch (this.dims) {
    case 1: return Array.from(this.data);
    case 2: return this.mapToArrayArray();
    case 3: return this.mapToArrayArrayArray();
  }
}

Matrix.prototype.toBuffer = function () {
  return this.data.buffer;
}

Matrix.prototype.toJson = function () {
  return JSON.stringify(this.toArray());
}

Matrix.prototype.transpose = function () {
  utils.checkMatrixDims(this,2);
  if (!Matrix.native || this.rows != this.columns || this.dtn != 'Float32Array') {
    var result = Matrix(this.columns, this.rows,{datatype:this.datatype});
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          result.set(j, i, this.get(i, j));
        }
    }
    return result;
  } else if (Matrix.native) {
    /* Native BLAS support */
    var res = Matrix(this.columns,this.rows,{dtn:this.dtn});
    if (this.dtn == 'Float32Array')
      Matrix.native.blas.stran_(Buffer(this.data.buffer),
                                Buffer(res.data.buffer),
                                Matrix.native.intPtr(this.rows),
                                Matrix.native.intPtr(this.columns));
    return res;
  }
}

Matrix.prototype.transposeView = function () {
  utils.checkMatrixDims(this,2);
  var res = Matrix(this,{transpose:true});
  return res;
}

Matrix.ALL=ALL;
Matrix.FOREACH=FOREACH;
Matrix.FORALL=FORALL;
Matrix.utils = utils;

module.exports = Matrix 
};
BundleModuleCode['plugins/math/matrixTA-utils']=function (module,exports){
// Matrix Utility Functions
// TypedArray version
// Ver. 1.3.1

'use strict';

function checkMatrixDims(matrix, dims) {
  if (matrix.dims != dims) throw new Error('Matrix has not expected dimension '+dims);
}
/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  var max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  var max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns'
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices)
  };
}

function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  var rowOut = rowIndices.some((r) => {
    return r < 0 || r >= matrix.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  var columnOut = columnIndices.some((c) => {
    return c < 0 || c >= matrix.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function getRange(from, to) {
  var arr = new Array(to - from + 1);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = from + i;
  }
  return arr;
}

function sumByRow(matrix) {
  var sum = Matrix.zeros(matrix.rows, 1);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  var sum = Matrix.zeros(1, matrix.columns);
  for (var i = 0; i < matrix.rows; ++i) {
    for (var j = 0; j < matrix.columns; ++j) {
      sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
    }
  }
  return sum;
}

function sumAll(matrix) {
  var i,j,k,v = 0;
  // Comp. mode
  switch (matrix.dtn) {
    case 'Array':
      for (i = 0; i < matrix.rows; i++) {
        for (j = 0; j < matrix.columns; j++) {
          v += matrix.data[i][j];
        }
      }
      break;
    default:
      for (i = 0; i < matrix.size; i++) v += matrix.data[i];
  }
  return v;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}

function getFilled2DArray(rows,columns,init) {
  var a = Array(rows);
  for(var i = 0;i < rows; i++) {
    a[i]=Array(columns).fill(init)
  }
  return a;
}

function hypotenuse(a, b) {
  var r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}

// function squaredEuclidean(p: number[], q: number[])
function squaredEuclidean(p, q) {
  var d = 0;
  for (var i = 0; i < p.length; i++) {
    d += (p[i] - q[i]) * (p[i] - q[i]);
  }
  return d;
}

// function euclidean(p: number[], q: number[]) 
function euclidean(p, q) {
  return Math.sqrt(squaredEuclidean(p, q));
}

var defaultOptions = {
  distanceFunction: squaredEuclidean
}
// function nearestVector(listVectors: Matrix, vector: number[],  options = defaultOptions)
function nearestVector(
  listVectors,
  vector,
  options
) {
  options=checkOptions(options,{distanceFunction: squaredEuclidean});
  const distanceFunction = checkOption(
    options.distanceFunction, defaultOptions.distanceFunction);
  const similarityFunction = checkOption(
    options.similarityFunction, defaultOptions.similarityFunction);

  let vectorIndex = -1;
  if (typeof similarityFunction === 'function') {
    // maximum similarity
    let maxSim = Number.MIN_VALUE;
    for (let j = 0; j < listVectors.rows; j++) {
      const sim = similarityFunction(vector, listVectors.getRow(j));
      if (sim > maxSim) {
        maxSim = sim;
        vectorIndex = j;
      }
    }
  } else if (typeof distanceFunction === 'function') {
    // minimum distance
    let minDist = Number.MAX_VALUE;
    for (let i = 0; i < listVectors.rows; i++) {
      const dist = distanceFunction(vector, listVectors.getRow(i));
      if (dist < minDist) {
        minDist = dist;
        vectorIndex = i;
      }
    }
  } else {
    throw new Error("A similarity or distance function it's required");
  }

  return vectorIndex;
}

// function findNearestVector(  vectorList: Matrix,  vector: Vector,  options: IOptions = defaultOptions) 
function findNearestVector(
  vectorList,
  vector,
  options
) {
  const index = nearestVector(vectorList, vector, options);
  return vectorList[index];
}

module.exports = {
  checkMatrixDims:checkMatrixDims,
  checkRowIndex:checkRowIndex,
  checkRowVector:checkRowVector,
  checkColumnIndex:checkColumnIndex,
  checkColumnVector:checkColumnVector,
  checkIndices:checkIndices,
  checkRowIndices:checkRowIndices,
  checkColumnIndices:checkColumnIndices,
  checkRange:checkRange,
  euclidean:euclidean,
  findNearestVector:findNearestVector,findNearestVector,
  getFilled2DArray:getFilled2DArray,
  getRange:getRange,
  hypotenuse:hypotenuse,
  nearestVector:nearestVector,nearestVector,
  sumByRow:sumByRow,
  sumByColumn:sumByColumn,
  sumAll:sumAll,
  squaredEuclidean:squaredEuclidean,
}
};
BundleModuleCode['plugins/math/vectorTA']=function (module,exports){
/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.sblab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 bLAB
 **    $CREATED:     1-1-19 by sbosse.
 **    $VERSION:     1.6.1X
 **
 **    $INFO:
 ** 
 **   Vector module supporting typed and generic arrays.
 **   
 ** 
 **    $ENDOFINFO
 */

var isArray = Utils.isArray,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isString = Utils.isString,
    TypedArrayOfName = Utils.TypedArrayOfName;

/********** TYPEDARRY/ARRAY Extension for Matrix/Vector compatibility *************/

Object.addProperty(Array,'get', function (i) {
  return this[i];
})
Object.addProperty(Array,'set', function (a,b) {
  this[a]=b;
})

  
Object.addProperty(Array,'print', function (format) {
  var i,s='',sep='', columns=this.length,complex=isArray(this[0]);
  if (!format) format = '%4.2f';
  for(i=0;i<columns;i++) {
    if (i!=0) s = s + '\n';
    if (complex) 
      s = s + sprintf(format,this[i][0]) + ',' +
              sprintf(format,this[i][1]);
    else
      s = s + sprintf(format,this[i]) ;
  }    
  return s;
})


Object.addProperty(Array,'info', function () {
  return {
    dtn:'Array',
    size:this.length,
    columns:this.length,
    offset:0,
  }
})

Object.addProperty(Array,'unique', function () {
  var array=this;
  var length = array ? array.length : 0;
  function baseUniq(array) {
    var index = -1,
        length = array.length,
        seen,
        result = [];

    seen = result;
    outer:
    while (++index < length) {
      var value = array[index];
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === value) {
          continue outer;
        }
      }
      result.push(value);
    }
    return result;
  }
  if (!length) {
    return [];
  }
  return baseUniq(array);
})

Object.addProperty(Array,'min', function () {
  return Math.min.apply(null, this) 
})

Object.addProperty(Array,'max', function () {
  return Math.max.apply(null, this) 
})


Object.addProperty(Int16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint16Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Int32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Uint32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float32Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})
Object.addProperty(Float64Array,'fill', function (v) {
  for(var i=0;i<this.length;i++) this[i]=v; return this;
})

/********************* STRING Conversion ******************************/
function toUTF8Array(str) {
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 
                      0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            charcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)
            utf8.push(0xf0 | (charcode >>18), 
                      0x80 | ((charcode>>12) & 0x3f), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}

function fromUTF8Array(data) { // array of bytes
    var str = '', i;
    for (i = 0; i < data.length; i++) {
        var value = data[i];
        if (value < 0x80) {
            str += String.fromCharCode(value);
        } else if (value > 0xBF && value < 0xE0) {
            str += String.fromCharCode((value & 0x1F) << 6 | data[i + 1] & 0x3F);
            i += 1;
        } else if (value > 0xDF && value < 0xF0) {
            str += String.fromCharCode((value & 0x0F) << 12 | (data[i + 1] & 0x3F) << 6 | data[i + 2] & 0x3F);
            i += 2;
        } else {
            // surrogate pair
            var charCode = ((value & 0x07) << 18 | (data[i + 1] & 0x3F) << 12 | (data[i + 2] & 0x3F) << 6 | data[i + 3] & 0x3F) - 0x010000;

            str += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00); 
            i += 3;
        }
    }
    return str;
}

var complex = {
  //-------------------------------------------------
  // Add two complex numbers
  //-------------------------------------------------
  add : function (a, b)
  {
      return [a[0] + b[0], a[1] + b[1]];
  },

  //-------------------------------------------------
  // Subtract two complex numbers
  //-------------------------------------------------
  subtract : function (a, b)
  {
      return [a[0] - b[0], a[1] - b[1]];
  },

  //-------------------------------------------------
  // Multiply two complex numbers
  //
  // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
  //-------------------------------------------------
  multiply : function (a, b) 
  {
      return [(a[0] * b[0] - a[1] * b[1]), 
              (a[0] * b[1] + a[1] * b[0])];
  },

  //-------------------------------------------------
  // Calculate |a + bi|
  //
  // sqrt(a*a + b*b)
  //-------------------------------------------------
  magnitude : function (offset,c) 
  {
      return Math.sqrt(c[offset]*c[offset] + c[offset+1]*c[offset+1]); 
  },
  
  phase : function (offset,c) 
  {
      return c[offset]!=0?Math.atan(c[offset+1]/c[offset])*180/Math.PI:(c[offset+1]>0?90:-90); 
  }

}

/*********** VECTOR ************/
function Vector(a,b) {
  var self = this;
  var i,columns,size,offset=0,dim=1,dtn,dt=Vector.options.dt,data;
  
  if (!(this instanceof Vector)) return new Vector(a,b);
  var options=isObject(b)?b:{};
  this.tag='VectorTA';
  
  if (isNumber(a)) {
    // Create a new empty vector (rows=1)
    columns=a;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    size=columns;
    if (options.complex) size *=2;
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(size);
  } else if (isArray(a)) {
    size=columns=a.length;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && options.dtn != 'Array') {
      // Create typedarray from generic array
      data=new dt(a);
    } else {
      // Matrix wrapper for generic arrays and array arrays
      // modify .get .set .getRow  prototype ...
      // no _Matrix.call
      dt=Array;
      data=a;
    }
  } else if (isObject(a)) {
    // partial object
    columns=a.columns;
    size=a.size||columns;
    scale=options.scale;
    if (options.datatype) options.dtn=options.datatype+'Array';
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    if (options.dtn && a.dtn != options.dtn) {
      // convert dtn
      if (isArray(a.data) && !scale)
        data=new dt(a.data);
      else {
        data=new dt(size);
        if (scale)  for(i=0;i<size;i++) data[i]=a.data[i]/scale;
        else        for(i=0;i<size;i++) data[i]=a.data[i];
      }
      dtn=options.dtn;
    } else {
      dtn=a.dtn;
      data=a.data;
      offset=a.offset;
    }
    if (a.scale) this.scale=a.scale;
    if (a.complex) this.complex=a.complex;
  } else if (isString(a)) {
    columns=a.length;
    if (options.type) dt=options.type;
    if (options.dtn)  dt=options.dtn=='Array'?Array:TypedArrayOfName[options.dtn];
    if (options.dtn && !dt) throw ("Vector: Unknown array type dtn="+options.dtn)
    data=new dt(toUTF8Array(a));
  }
  
  this.columns=columns;
  this.size=this.length=size;
  this.layout=1;
  this.data=data;
  this.dims=dim;
  this.offset=offset;
  if (options.complex) this.complex=true;
  if (options.scale)   this.scaler=options.scale;
  
  this.dtn=dtn||dt.name;
  
  if (this.dtn=='Array') this._arrayFix();

  this.__constructor__='Math.VectorTA';
}
Vector.options = {
  dt : Float32Array,
  dtn : 'Float32Array'
}

/********* STATIC MEMBERS *********/
Vector.abs = function (m) {
  return Vector.clone(m).abs();
}

Vector.add = function (m,v) {
  return Vector.clone(m).add(v);
}

Vector.clone = function (src) {
  return Vector(src);
}

Vector.checkVector = function (o) {
  if (o instanceof Vector) return o;
  else return Vector(o);
}

Vector.cos = function (m) {
  return Vector.clone(m).cos();
}

Vector.div = function (m,v) {
  return Vector.clone(m).div(v);
}

Vector.empty = function (columns) {
  return Vector(columns);
}

Vector.exp = function (m) {
  return Vector.clone(m).exp();
}

Vector.init = function (columns,valueOrCallback) {
  return Vector(columns).fill(valueOrCallback);
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.max =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]= Math.max(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.min =  function(vector1, vector2) {
  vector1 = Vector.checkVector(vector1);
  vector2 = Vector.checkVector(vector2);
  var columns =vector1.columns;
  var result = Vector(columns,{dtn:vector1.dtn});
  for (var i = 0; i< columns; i++) {
    result.data[i]=Math.min(vector1.data[i], vector2.data[i]);
  }
  return result;
}

Vector.mod = function (m,v) {
  return Vector.clone(m).mod(v);
}

Vector.mul = function (m,v) {
  return Vector.clone(m).mul(v);
}

Vector.neg = function (m) {
  return Vector.clone(m).neg();
}

Vector.ones = function (columns) {
  return Vector(columns).fill(1);
}

Vector.rand = function (columns, rng, options) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns,options).fill(function () {
    return rng();
  });
}
Vector.Random=function (columns,options) {
  return Vector.rand(columns,options&&options.rng,options)
};
Vector.randInt = function (columns, maxValue, rng) {
  if (rng==undefined) rng=Math.random;
  return Vector(columns).fill(function () {
    return (rng()*maxValue)|0;
  });
}

Vector.sin = function (m) {
  return Vector.clone(m).sin();
}

Vector.sub = function (m,v) {
  return Vector.clone(m).sub(v);
}

Vector.zero = function (columns) {
  return Vector(columns).fill(0);
}



/********* INSTANCE MEMBERS *********/
// Fix some prototype methods for generic array data content
Vector.prototype._arrayFix = function () {
  var self=this;
  this.get=function (column)   { return self.data[self.offset+column] };
  this.set=function (column,v) { self.data[self.offset+column]=v };
}

Vector.prototype.abs = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.abs(this.data[i]);
  return this; 
}

Vector.prototype.add = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]+=v;
  return this; 
}

Vector.prototype.apply = function (f) {
  for(var i=0; i < this.columns; i++) 
    this.set(i,f.call(this,i))
  return this;
}

Vector.prototype.clone = function () {
  return Vector(this);
}

Vector.prototype.cos = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.cos(this.data[i]);
  return this; 
}

Vector.prototype.div = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]/=v;
  return this; 
}

Vector.prototype.divide = function (column,k) {
  return this.data[column] /= k;
}

// Evaluate all elements x of matrix by applying function f(x)
Vector.prototype.eval = function (f) {
  var i;
  switch (this.dtn) {
    case 'Array':
      for(i=0; i < this.columns; i++) 
        this.set(i,f(this.get(i)))
      break;
    default:
      for(i=0;i<this.size;i++) this.data[i]=f(this.data[i],i);
  }
  return this;
}

Vector.prototype.exp = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.exp(this.data[i]);
  return this; 
}

Vector.prototype.fill = function (valueOrFunction) {
  if (typeof valueOrFunction == 'function') {
      for(var i=0;i<this.columns;i++) {
        this.data[i]=valueOrFunction(i);
      } 
  } else this.data.fill(valueOrFunction);
  return this;
}

Vector.prototype.filter = function (f,asArray) {
  var i,j=0,res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(i=0;i<this.columns;i++) {
    v=f(this.data[i],i);
    if (v) res.data[j]=this.data[i],j++;
  }
  return j<this.columns?res.slice(j):res;
}

Vector.prototype.get = function (column) {
  return this.data[this.offset+column];
}

Vector.prototype.imag = function (i) {
  if (this.complex) return this.get(i*2+1);
}

Vector.prototype.incr = function (column,delta) {
  return this.data[column] += delta;
}

Vector.prototype.info = function () {
  var i = {
    dtn:this.dtn,
    size:this.size,
    columns:this.columns,
    offset:this.offset,
  }
  if (this.scaler) i.scaler=this.scaler;
  if (this.complex) i.complex=true;
  return i;
}

isVector = Vector.isVector = function (o) {
  return (o instanceof Vector)
}

Vector.prototype.magnitude = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.magnitude(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.map = function (f,asArray) {
  var res = Vector(this.columns,{dtn:asArray?'Array':this.dtn});
  for(var i=0;i<this.columns;i++)
    res.data[i]=f(this.data[i],i);
  return res;
}

Vector.prototype.multiply = function (column,k) {
  return this.data[column] *= k;
}

Vector.prototype.mean = function (v) {
  return this.sum()/this.size;
}

Vector.prototype.mod = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=this.data[i]%v;
  return this; 
}

Vector.prototype.mul = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]*=v;
  return this; 
}

Vector.prototype.neg = function (v) {
  var i,j;
  for(var i=0;i<this.size;i++) this.data[i]=-this.data[i];
  return this; 
}

Vector.prototype.pad = function (n,v,left) { 
  var ext = Vector.init(n,v); 
  if (!left) ext.data.set(this.data);
  else ext.data.set(this.data,this.length);
  return ext;
}

Vector.prototype.phase = function () {
  var res;
  if (this.complex) {
    res=Vector(this.columns,{dtn:this.dtn});
    for(var i=0; i < res.columns; i++) 
      res.data[i]=complex.phase(this.offset+i*2,this.data);
  }
  return res;
}

Vector.prototype.prod = function (v) {
  var i,j,v = 1;
  for (i = 0; i < this.size; i++) v *= this.data[i];
  return v;
}

Vector.prototype.print = function (format,transpose) {
  var j, s='';
  if (!format) format = '%4.2f';
  if (!this.complex)
    for(j=0;j<this.columns;j++) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + sprintf(format,this.data[j]) ;
    }
  else
    for(j=0;j<this.columns;j=j+2) {
      if (j!=0) s = s + (transpose?' ':'\n');
      s = s + '('+sprintf(format,this.data[j])+','+sprintf(format,this.data[j+1])+')' ;
    }
  
  return s;
}

Vector.prototype.reduce = function (f) {
  return this.data.reduce(f);
}

Vector.prototype.real = function (i) {
  if (this.complex) return this.get(i*2);
}

Vector.prototype.resize = function (options) {
  if ((options.offset && (options.columns+options.offset) > this.columns) ||
      !options.columns) throw new Error('Vecotr.resize: invalid argument(s)');
  this.columns=options.columns;
  if (options.offset) this.offset=options.offset;
  this.size=this.length=this.columns;
  if (options.slice) 
    this.data=options.offset?this.data.slice(options.offset,options.columns+offset):
                             this.data.slice(0,options.columns);
  return this;
}

Vector.prototype.set = function (column,val) {
  this.data[this.offset+column]=val;
  return this;
}

Vector.prototype.sin = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]=Math.sin(this.data[i]);
}

/*
size
Properties
size (number) : The number of elements in the matrix.
*/
Vector.prototype.size = function () {
  return  this.size;
}

/** Return new vecotr with sliced data
 *
 */
Vector.prototype.slice = function (columns,offset) {
  return Vector(this,{columns:columns,offset:offset,slice:true});
}

Vector.prototype.sub = function (v) {
  var i,j;
  for(i=0;i<this.size;i++) this.data[i]-=v;
  return this; 
}

Vector.prototype.subRange = function (columns,offset) {
  offset=checkOption(offset,0);
  var res=Vector({columns:columns,data:this.data.slice(offset,columns+offset),dtn:this.dtn});
  return res;
}

Vector.prototype.sum = function () {
  var sum=0;
  for(var i=0;i<this.size;i++) sum += this.data[i];
  return sum
}

Vector.prototype.toArray = function () {
  if (!this.complex) return Array.prototype.slice.call(this.data);
}

module.exports = Vector;
};
BundleModuleCode['plugins/math/matrixTA-EVD']=function (module,exports){
// Matrix EigenvalueDecomposition
// TypedArray version 
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function EigenvalueDecomposition(matrix, options) {
  if (!(this instanceof EigenvalueDecomposition)) return new EigenvalueDecomposition(matrix,options);
  options=checkOptions(options);
  var assumeSymmetric = checkOption(options.assumeSymmetric,false);

  matrix = Matrix.checkMatrix(matrix);
  if (!matrix.isSquare()) {
    throw new Error('EigenvalueDecomposition: Matrix is not a square matrix');
  }

  var n = matrix.columns;
  var V = Matrix(n, n);
  var d = new Array(n);
  var e = new Array(n);
  var value = matrix;
  var i, j;

  var isSymmetric = false;
  if (assumeSymmetric) {
    isSymmetric = true;
  } else {
    isSymmetric = matrix.isSymmetric();
  }

  if (isSymmetric) {
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        V.set(i,j, value.get(i, j));
      }
    }
    tred2(n, e, d, V);
    tql2(n, e, d, V);
  } else {
    var H = Matrix(n, n);
    var ort = new Array(n);
    for (j = 0; j < n; j++) {
      for (i = 0; i < n; i++) {
        H.set(i,j,  value.get(i, j));
      }
    }
    orthes(n, H, ort, V);
    hqr2(n, e, d, V, H);
  }

  this.n = n;
  this.e = e;
  this.d = d;
  this.V = V;
}

EigenvalueDecomposition.prototype = {
  /**
   *
   * @return {Array<number>}
   */
  get realEigenvalues() {
    return this.d;
  },

  /**
   *
   * @return {Array<number>}
   */
  get imaginaryEigenvalues() {
    return this.e;
  },

  /**
   *
   * @return {Matrix}
   */
  get eigenvectorMatrix() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    var n = this.n;
    var e = this.e;
    var d = this.d;
    var X = new Matrix(n, n);
    var i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i,j,0);
      }
      X.set(i,i,d[i]);
      if (e[i] > 0) {
        X.set(i,i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i,i - 1,e[i]);
      }
    }
    return X;
  },
}

function tred2(n, e, d, V) {
  var f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1,j);
        V.set(i,j, 0);
        V.set(j,i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j,i,f);
        g = e[j] + V.get(j,j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k,j) * d[k];
          e[k] += V.get(k,j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.incr(k,j, -(f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1,j);
        V.set(i,j,0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1,i, V.get(i,i));
    V.set(i,i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k,i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k,i + 1) * V.get(k,j);
        }
        for (k = 0; k <= i; k++) {
          V.incr(k,j, -(g * d[k]));
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k,i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1,j);
    V.set(n - 1,j, 0);
  }

  V.set(n - 1,n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  var f = 0;
  var tst1 = 0;
  var eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      iter = 0;
      do {
        iter = iter + 1;

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k,i + 1);
            V.set(k,i + 1, s * V.get(k,i) + c * h);
            V.set(k,i, c * V.get(k,i) - s * h);
          }
        }

        p = -s * s2 * c3 * el1 * e[l] / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j,i);
        V.set(j,i, V.get(j,k));
        V.set(j,k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  var low = 0;
  var high = n - 1;
  var f, g, h, i, j, m;
  var scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i,m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i,m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i,j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.incr(i,j, -(f * ort[i]));
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i,j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.incr(i,j, -(f * ort[j]));
        }
      }

      ort[m] = scale * ort[m];
      H.set(m,m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i,j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m,m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i,m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i,j);
        }

        g = g / ort[m] / H.get(m,m - 1);
        for (i = m; i <= high; i++) {
          V.incr(i,j, g * ort[i]);
        }
      }
    }
  }
}


function hqr2(nn, e, d, V, H) {
  var n = nn - 1;
  var low = 0;
  var high = nn - 1;
  var eps = Number.EPSILON;
  var exshift = 0;
  var norm = 0;
  var p = 0;
  var q = 0;
  var r = 0;
  var s = 0;
  var z = 0;
  var iter = 0;
  var i, j, k, l, m, t, w, x, y;
  var ra, sa, vr, vi;
  var notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i,i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i,j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1,l - 1)) + Math.abs(H.get(l,l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l,l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.incr(n,n,exshift);
      d[n] = H.get(n,n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n,n - 1) * H.get(n - 1,n);
      p = (H.get(n - 1,n - 1) - H.get(n,n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.incr(n,n,exshift);
      H.incr(n - 1,n - 1,exshift);
      x = H.get(n,n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n,n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1,j);
          H.set(n - 1,j, q * z + p * H.get(n,j));
          H.set(n,j, q * H.get(n,j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i,n - 1);
          H.set(i,n - 1, q * z + p * H.get(i,n));
          H.set(i,n, q * H.get(i,n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i,n - 1);
          V.set(i,n - 1, q * z + p * V.get(i,n));
          V.set(i,n,  q * V.get(i,n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n,n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1,n - 1);
        w = H.get(n,n - 1) * H.get(n - 1,n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.incr(i,i, -x);
        }
        s = Math.abs(H.get(n,n - 1)) + Math.abs(H.get(n - 1,n - 2));
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.incr(i,i, -s);
          }
          exshift += s;
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m,m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1,m) + H.get(m,m + 1);
        q = H.get(m + 1,m + 1) - z - r - s;
        r = H.get(m + 2,m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m,m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1,m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1,m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i,i - 2, 0);
        if (i > m + 2) {
          H.set(i,i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k,k - 1);
          q = H.get(k + 1,k - 1);
          r = notlast ? H.get(k + 2,k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k,k - 1, -s * x);
          } else if (l !== m) {
            H.set(k,k - 1, -H.get(k,k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k,j) + q * H.get(k + 1,j);
            if (notlast) {
              p = p + r * H.get(k + 2,j);
              H.incr(k + 2,j, -(p * z));
            }

            H.incr(k,j, -(p * x));
            H.incr(k + 1,j, -(p * y));
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i,k) + y * H.get(i,k + 1);
            if (notlast) {
              p = p + z * H.get(i,k + 2);
              H.incr(i,k + 2, -(p * r));
            }

            H.incr(i,k, -p);
            H.incr(i,k + 1, -(p * q));
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i,k) + y * V.get(i,k + 1);
            if (notlast) {
              p = p + z * V.get(i,k + 2);
              V.incr(i,k + 2 , -(p * r));
            }

            V.incr(i,k,-p);
            V.incr(i,k + 1,-(p * q));
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n,n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i,i, -p);
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i,j) * H.get(j,n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i,n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i,n, t);
            H.set(i + 1,n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z);
          }

          t = Math.abs(H.get(i,n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n, t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n,n - 1)) > Math.abs(H.get(n - 1,n))) {
        H.set(n - 1,n - 1, q / H.get(n,n - 1));
        H.set(n - 1,n, -(H.get(n,n) - p) / H.get(n,n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1,n), H.get(n - 1,n - 1) - p, q);
        H.set(n - 1,n - 1, cdivres[0]);
        H.set(n - 1,n,  cdivres[1]);
      }

      H.set(n,n - 1,  0);
      H.set(n,n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i,j) * H.get(j,n - 1);
          sa = sa + H.get(i,j) * H.get(j,n);
        }

        w = H.get(i,i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
          } else {
            x = H.get(i,i + 1);
            y = H.get(i + 1,i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi
            );
            H.set(i,n - 1, cdivres[0]);
            H.set(i,n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(i + 1,n - 1,(-ra - w * H.get(i,n - 1) + q * H.get(i,n)) / x);
              H.set(i + 1,n, (-sa - w * H.get(i,n) - q * H.get(i,n - 1)) / x);
            } else {
              cdivres = cdiv(-r - y * H.get(i,n - 1), -s - y * H.get(i,n), z, q);
              H.set(i + 1,n - 1, cdivres[0]);
              H.set(i + 1,n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i,n - 1)), Math.abs(H.get(i,n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.divide(j,n - 1, t);
              H.divide(j,n, t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i,j,  H.get(i,j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i,k) * H.get(k,j);
      }
      V.set(i,j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  var r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}

module.exports = EigenvalueDecomposition
};
BundleModuleCode['plugins/math/matrixTA-SVD']=function (module,exports){
// Matrix SingularValueDecomposition
// TypedArray version
// Ver. 1.2.3

"use strict";
var Io = Require('com/io');
var Matrix = Require('plugins/math/matrixTA')
var hypotenuse = Matrix.utils.hypotenuse,
    checkOption = Io.checkOption,
    checkOptions = Io.checkOptions;

function SingularValueDecomposition(matrix, options) {
  if (!(this instanceof SingularValueDecomposition)) return new SingularValueDecomposition(matrix,options);
  options=checkOptions(options);
  var value = Matrix.checkMatrix(matrix);

  var m = value.rows;
  var n = value.columns;

  var computeLeftSingularVectors = checkOption(options.computeLeftSingularVectors,true)
  var computeRightSingularVectors = checkOption(options.computeRightSingularVectors,true)
  var autoTranspose = checkOption(options.autoTranspose,false)

  var wantu = Boolean(computeLeftSingularVectors);
  var wantv = Boolean(computeRightSingularVectors);

  var swapped = false;
  var a;
  if (m < n) {
    if (!autoTranspose) {
      a = value.clone();
      // eslint-disable-next-line no-console
      console.warn(
        'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
      );
    } else {    
      a = value.transpose();
      m = a.rows;
      n = a.columns;
      swapped = true;
      var aux = wantu;
      wantu = wantv;
      wantv = aux;
    }
  } else {
    a = value.clone();
  }

  var nu = Math.min(m, n);
  var ni = Math.min(m + 1, n);
  var s = new Array(ni);
  var U = Matrix(m, nu, {dtn:value.dtn}); 
  var V = Matrix(n, n,  {dtn:value.dtn});  

  var e = new Array(n);
  var work = new Array(m);

  var si = new Array(ni);
  for (var i = 0; i < ni; i++) si[i] = i;

  var nct = Math.min(m - 1, n);
  var nrt = Math.max(0, Math.min(n - 2, m));
  var mrc = Math.max(nct, nrt);
  
  for (var k = 0; k < mrc; k++) {
    if (k < nct) {
      s[k] = 0;
      for (var i = k; i < m; i++) {
        s[k] = hypotenuse(s[k], a.get(i,k));
      }
      if (s[k] !== 0) {
        if (a.get(k,k) < 0) {
          s[k] = -s[k];
        }
        for (var i = k; i < m; i++) {
          a.divide(i,k,s[k]);
        }
        a.incr(k,k,1);
      }
      s[k] = -s[k];
    }

    for (var j = k + 1; j < n; j++) {
      if (k < nct && s[k] !== 0) {
        var t = 0;
        for (var i = k; i < m; i++) {
          t += a.get(i,k) * a.get(i,j);
        }
        t = -t / a.get(k,k);
        for (var i = k; i < m; i++) {
          a.incr(i,j, t * a.get(i,k));
        }
      }
      e[j] = a.get(k,j);
    }
    
    if (wantu && k < nct) {
      for (var i = k; i < m; i++) {
        U.set(i,k, a.get(i,k));
      }
    }
    
    if (k < nrt) {
      e[k] = 0;
      for (var i = k + 1; i < n; i++) {
        e[k] = hypotenuse(e[k], e[i]);
      }
      if (e[k] !== 0) {
        if (e[k + 1] < 0) {
          e[k] = 0 - e[k];
        }
        for (var i = k + 1; i < n; i++) {
          e[i] /= e[k];
        }
        e[k + 1] += 1;
      }
      e[k] = -e[k];
      if (k + 1 < m && e[k] !== 0) {
        for (var i = k + 1; i < m; i++) {
          work[i] = 0;
        }
        for (var i = k + 1; i < m; i++) {
          for (var j = k + 1; j < n; j++) {
            work[i] += e[j] * a.get(i,j);
          }
        }
        for (var j = k + 1; j < n; j++) {
          var t = -e[j] / e[k + 1];
          for (var i = k + 1; i < m; i++) {
            a.incr(i,j, t * work[i]);
          }
        }
      }
      if (wantv) {
        for (var i = k + 1; i < n; i++) {
          V.set(i,k, e[i]);
        }
      }
    }
  }

  var p = Math.min(n, m + 1);
  if (nct < n) {
    s[nct] = a.get(nct,nct);
  }
  if (m < p) {
    s[p - 1] = 0;
  }
  if (nrt + 1 < p) {
    e[nrt] = a.get(nrt,p - 1);
  }
  e[p - 1] = 0;

  if (wantu) {
    for (var j = nct; j < nu; j++) {
      for (var i = 0; i < m; i++) {
        U.set(i,j, 0);
      }
      U.set(j,j, 1);
    }
    for (var k = nct - 1; k >= 0; k--) {
      if (s[k] !== 0) {
        for (var j = k + 1; j < nu; j++) {
          var t = 0;
          for (var i = k; i < m; i++) {
            t += U.get(i,k) * U.get(i,j);
          }
          t = -t / U.get(k,k);
          for (var i = k; i < m; i++) {
            U.incr(i,j, t * U.get(i,k));
          }
        }
        for (var i = k; i < m; i++) {
          U.set(i,k, -U.get(i,k));
        }
        U.incr(k,k,1); // = 1 + U[k][k];
        for (var i = 0; i < k - 1; i++) {
          U.set(i,k,0);
        }
      } else {
        for (var i = 0; i < m; i++) {
          U.set(i,k,0);
        }
        U.set(k,k,1);
      }
    }
  }

  if (wantv) {
    for (var k = n - 1; k >= 0; k--) {
      if (k < nrt && e[k] !== 0) {
        for (var j = k + 1; j < n; j++) {
          var t = 0;
          for (var i = k + 1; i < n; i++) {
            t += V.get(i,k) * V.get(i,j);
          }
          t = -t / V.get(k + 1,k);
          for (var i = k + 1; i < n; i++) {
            V.incr(i,j, t * V.get(i,k));
          }
        }
      }
      for (var i = 0; i < n; i++) {
        V.set(i,k,0);
      }
      V.set(k,k, 1);
    }
  }
  
  var pp = p - 1;
  var iter = 0;
  var eps = Number.EPSILON;
  
  while (p > 0) {
    var k, kase;
    for (k = p - 2; k >= -1; k--) {
      if (k === -1) {
        break;
      }
      const alpha =
        Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
      if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
        e[k] = 0;
        break;
      }
    }
    if (k === p - 2) {
      kase = 4;
    } else {
      var ks;
      for (ks = p - 1; ks >= k; ks--) {
        if (ks === k) {
          break;
        }
        var t =
          (ks !== p ? Math.abs(e[ks]) : 0) +
          (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
        if (Math.abs(s[ks]) <= eps * t) {
          s[ks] = 0;
          break;
        }
      }
      if (ks === k) {
        kase = 3;
      } else if (ks === p - 1) {
        kase = 1;
      } else {
        kase = 2;
        k = ks;
      }
    }

    k++;

    switch (kase) {
      case 1: {
        var f = e[p - 2];
        e[p - 2] = 0;
        for (var j = p - 2; j >= k; j--) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          if (j !== k) {
            f = -sn * e[j - 1];
            e[j - 1] = cs * e[j - 1];
          }
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,p - 1);
              V,set(i,p - 1, -sn * V.get(i,j) + cs * V.get(i,p - 1));
              V.set(i,j, t);
            }
          }
        }
        break;
      }
      case 2: {
        var f = e[k - 1];
        e[k - 1] = 0;
        for (var j = k; j < p; j++) {
          var t = hypotenuse(s[j], f);
          var cs = s[j] / t;
          var sn = f / t;
          s[j] = t;
          f = -sn * e[j];
          e[j] = cs * e[j];
          if (wantu) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U[i][k - 1];
              U.set(i,k - 1, -sn * U.get(i,j) + cs * U.get(i,k - 1));
              U.set(i,j,t);
            }
          }
        }
        break;
      }
      case 3: {
        const scale = Math.max(
          Math.abs(s[p - 1]),
          Math.abs(s[p - 2]),
          Math.abs(e[p - 2]),
          Math.abs(s[k]),
          Math.abs(e[k])
        );
        const sp = s[p - 1] / scale;
        const spm1 = s[p - 2] / scale;
        const epm1 = e[p - 2] / scale;
        const sk = s[k] / scale;
        const ek = e[k] / scale;
        const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
        const c = sp * epm1 * (sp * epm1);
        var shift = 0;
        if (b !== 0 || c !== 0) {
          if (b < 0) {
            shift = 0 - Math.sqrt(b * b + c);
          } else {
            shift = Math.sqrt(b * b + c);
          }
          shift = c / (b + shift);
        }
        var f = (sk + sp) * (sk - sp) + shift;
        var g = sk * ek;
        for (var j = k; j < p - 1; j++) {
          var t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          var cs = f / t;
          var sn = g / t;
          if (j !== k) {
            e[j - 1] = t;
          }
          f = cs * s[j] + sn * e[j];
          e[j] = cs * e[j] - sn * s[j];
          g = sn * s[j + 1];
          s[j + 1] = cs * s[j + 1];
          if (wantv) {
            for (var i = 0; i < n; i++) {
              t = cs * V.get(i,j) + sn * V.get(i,j + 1);
              V.set(i,j + 1, -sn * V.get(i,j) + cs * V.get(i,j + 1));
              V.set(i,j, t);
            }
          }
          t = hypotenuse(f, g);
          if (t === 0) t = Number.MIN_VALUE;
          cs = f / t;
          sn = g / t;
          s[j] = t;
          f = cs * e[j] + sn * s[j + 1];
          s[j + 1] = -sn * e[j] + cs * s[j + 1];
          g = sn * e[j + 1];
          e[j + 1] = cs * e[j + 1];
          if (wantu && j < m - 1) {
            for (var i = 0; i < m; i++) {
              t = cs * U.get(i,j) + sn * U.get(i,j + 1);
              U.set(i,j + 1,  -sn * U.get(i,j) + cs * U.get(i,j + 1));
              U.set(i,j, t);
            }
          }
        }
        e[p - 2] = f;
        iter = iter + 1;
        break;
      }
      case 4: {
        if (s[k] <= 0) {
          s[k] = s[k] < 0 ? -s[k] : 0;
          if (wantv) {
            for (var i = 0; i <= pp; i++) {
              V.set(i,k, -V.get(i,k));
            }
          }
        }
        while (k < pp) {
          if (s[k] >= s[k + 1]) {
            break;
          }
          var t = s[k];
          s[k] = s[k + 1];
          s[k + 1] = t;
          if (wantv && k < n - 1) {
            for (var i = 0; i < n; i++) {
              t = V.get(i,k + 1);
              V.set(i,k + 1, V.get(i,k));
              V.set(i,k, t);
            }
          }
          if (wantu && k < m - 1) {
            for (var i = 0; i < m; i++) {
              t = U.get(i,k + 1);
              U.set(i,k + 1,  U.get(i,k));
              U.set(i,k, t);
            }
          }
          k++;
        }
        iter = 0;
        p--;
        break;
      }
      // no default
    }
  }

  if (swapped) {
    var tmp = V;
    V = U;
    U = tmp;
  }

  this.m = m;
  this.n = n;
  this.s = s;
  this.U = U;
  this.V = V;

    
}

SingularValueDecomposition.prototype = {
  /**
   *
   * @return {number}
   */
  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  },

  /**
   *
   * @return {number}
   */
  get norm2() {
    return this.s[0];
  },

  /**
   *
   * @return {number}
   */
  get rank() {
    var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    var r = 0;
    var s = this.s;
    for (var i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  },

  /**
   *
   * @return {Array<number>}
   */
  get diagonal() {
    return this.s;
  },

  /**
   *
   * @return {number}
   */
  get threshold() {
    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
  },

  /**
   *
   * @return {Matrix}
   */
  get leftSingularVectors() {
    if (!Matrix.isMatrix(this.U)) {
      this.U = new Matrix(this.U);
    }
    return this.U;
  },

  /**
   *
   * @return {Matrix}
   */
  get rightSingularVectors() {
    if (!Matrix.isMatrix(this.V)) {
      this.V = new Matrix(this.V);
    }
    return this.V;
  },

  /**
   *
   * @return {Matrix}
   */
  get diagonalMatrix() {
    return Matrix.diag(this.s);
  }
}
  /**
   * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
   * var svd = SingularValueDecomposition(A);
   * var x = svd.solve(b);
   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
   * @return {Matrix} - The vector x
   */
SingularValueDecomposition.prototype.solve = function(value) {
  var Y = value;
  var e = this.threshold;
  var scols = this.s.length;
  var Ls = Matrix.zeros(scols, scols);

  for (var i = 0; i < scols; i++) {
    if (Math.abs(this.s[i]) <= e) {
      Ls.set(i,i, 0);
    } else {
      Ls.set(i,i, 1 / this.s[i]);
    }
  }

  var U = this.U;
  var V = this.rightSingularVectors;

  var VL = V.mmul(Ls);
  var vrows = V.rows;
  var urows = U.length;
  var VLU = Matrix.zeros(vrows, urows);

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < scols; k++) {
        sum += VL.get(i,k) * U.get(j,k);
      }
      VLU.set(i,j, sum);
    }
  }

  return VLU.mmul(Y);
}

  /**
   *
   * @param {Array<number>} value
   * @return {Matrix}
   */
SingularValueDecomposition.prototype.solveForDiagonal = function (value) {
  return this.solve(Matrix.diag(value));
}

  /**
   * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
   * var svd = SingularValueDecomposition(A);
   * var inverseA = svd.inverse();
   * @return {Matrix} - The approximation of the inverse of the matrix
   */
SingularValueDecomposition.prototype.inverse = function () {
  var V = this.V;
  var e = this.threshold;
  var vrows = V.rows;
  var vcols = V.columns;
  var X = Matrix(vrows, this.s.length, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < vcols; j++) {
      if (Math.abs(this.s[j]) > e) {
        X.set(i,j, V.get(i,j) / this.s[j]);
      } else {
        X.set(i,j, 0);
      }
    }
  }

  var U = this.U;

  var urows = U.rows;
  var ucols = U.columns;
  var Y = Matrix(vrows, urows, {dtn:V.dtn});

  for (var i = 0; i < vrows; i++) {
    for (var j = 0; j < urows; j++) {
      var sum = 0;
      for (var k = 0; k < ucols; k++) {
        sum += X.get(i,k) * U.get(j,k);
      }
      Y.set(i,j, sum);
    }
  }

  return Y;
}

module.exports = SingularValueDecomposition;
};
BundleModuleCode['plugins/math/matrix']=function (module,exports){
/* Matrix array objects
** Version 1.3.4
*/
var version = "1.4.1"
var ALL = [], 
    FORALL = '*',
    FOREACH = 'x';
    
Utils.isRange   = function (v)  { return isArray(v) && v.length==2 }
Utils.isAll     = function (v)  { return v=='*' || (isArray(v) && v.length==0) }
Utils.isForEach = function (v)  { return v == FOREACH }
Utils.isArrayArray = function (v) { return isArray(v) && isArray(v[0]) }
Utils.isArrayArrayArray = function (v) { return isArray(v) && isArray(v[0]) && isArray(v[0][0]) }

var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;

// elements:[rows,columns,levels] (3D not supported by methods)
function Matrix(elements,options,aux) {
  if (!(this instanceof Matrix)) return new Matrix(elements,options,aux);
  options=options||{};
  this.tag='Matrix';
  var space=[];
  if (Utils.isNumber(elements)) space.push(elements);
  if (Utils.isNumber(options)) space.push(options);  
  if (Utils.isNumber(aux)) space.unshift(aux); // !!!
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.data=Array(space[0]).fill(0);
    if (space.length>1) for(var i=0;i<space[0];i++) this.data[i]=Array(space[1]).fill(0);
    if (space.length>2) for(var i=0;i<space[0];i++) 
                          for(var j=0;j<space[1];j++) this.data[i][j]=Array(space[2]).fill(0);
    this.dims=space.length;
    
  } else  
    this.setData(elements,options.reference);
  this.__constructor__='Math.Matrix';
};

Matrix.version=version;

Matrix.create = Matrix
// var $M = Matrix.create;

Matrix.isMatrix = function (o) {
  return o instanceof Matrix
}

Matrix.I = function(n) {
  var els = [], i = n, j;
  while (i--) { j = n;
    els[i] = [];
    while (j--) {
      els[i][j] = (i === j) ? 1 : 0;
    }
  }
  return Matrix.create(els);
};

Matrix.Init = function(rows,columns,callback) {
  var els = [], i = rows, j;
  while (i--) { j = columns;
    els[i] = [];
    if (typeof callback == 'function')
    while (j--) {
      els[i][j] = callback(i,j);
    }
    else
    while (j--) {
      els[i][j] = callback; // constant value
    }
  }
  return Matrix.create(els);
};

Matrix.Diagonal = function(elements) {
  var i = elements.length;
  var M = Matrix.I(i);
  while (i--) {
    M.data[i][i] = elements[i];
  }
  return M;
};

Matrix.Rotation = function(theta, a) {
  if (!a) {
    return Matrix.create([
      [Math.cos(theta),  -Math.sin(theta)],
      [Math.sin(theta),   Math.cos(theta)]
    ]);
  }
  var axis = a.dup();
  if (axis.data.length !== 3) { return null; }
  var mod = axis.modulus();
  var x = axis.data[0]/mod, y = axis.data[1]/mod, z = axis.data[2]/mod;
  var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
  // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
  // That proof rotates the co-ordinate system so theta becomes -theta and sin
  // becomes -sin here.
  return Matrix.create([
    [ t*x*x + c, t*x*y - s*z, t*x*z + s*y ],
    [ t*x*y + s*z, t*y*y + c, t*y*z - s*x ],
    [ t*x*z - s*y, t*y*z + s*x, t*z*z + c ]
  ],{reference:true});
};

Matrix.RotationX = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  1,  0,  0 ],
    [  0,  c, -s ],
    [  0,  s,  c ]
  ],{reference:true});
};
Matrix.RotationY = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c,  0,  s ],
    [  0,  1,  0 ],
    [ -s,  0,  c ]
  ],{reference:true});
};
Matrix.RotationZ = function(t) {
  var c = Math.cos(t), s = Math.sin(t);
  return Matrix.create([
    [  c, -s,  0 ],
    [  s,  c,  0 ],
    [  0,  0,  1 ]
  ],{reference:true});
};

Matrix.Random = function(n, m) {
  return Matrix.Zero(n, m).map(
    function() { return Math.random(); }
  );
};

Matrix.Zero = function(n, m) {
  var els = [], i = n, j;
  while (i--) { j = m;
    els[i] = [];
    while (j--) {
      els[i][j] = 0;
    }
  }
  return Matrix.create(els,{reference:true});
};

Matrix.prototype = {

  add: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x + M[i][j]; });
  },

  addColumn : function (index,data) {
    var T = this, cols = T.data[0].length;
    if (index==cols) {
      // simple, append on right side
      T.data.forEach(function (row,i) {
        row.push(data[i])
      })
    }
    return T;
  },
  
  apply: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        this.data[i][j]=fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  augment: function(matrix) {
    if (this.data.length === 0) { return this.dup(); }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    var T = this.dup(), cols = T.data[0].length;
    var i = T.data.length, nj = M[0].length, j;
    if (i !== M.length) { return null; }
    while (i--) { j = nj;
      while (j--) {
        T.data[i][cols + j] = M[i][j];
      }
    }
    return T;
  },

  canMultiplyFromLeft: function(matrix) {
    if (this.data.length === 0) { return false; }
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    // this.columns should equal matrix.rows
    return (this.data[0].length === M.length);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b,c,d) {
    var i,j,k,p,v,m,ni,nj,nk,filter;

    if (isNumber(a)) i=a;
    if (isNumber(b)) j=b;
    if (isNumber(c)) k=c;
    if (isString(b)) filter=b;
    if (isString(c)) filter=c;
    if (isString(d)) filter=d;
    if (!filter) filter='mean';

    if (!i) throw "Matrix.convert: no target size (number, first dim.)";
    if (this.dims>1 && !j) throw "Matrix.convert: no target size (number, second dim.)";

    m = Matrix(i,j,k);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.rows/m.rows);
    nj=Math.floor(this.columns/m.columns);
    for(i=0;i<m.rows;i++) {
      for(j=0;j<m.columns;j++) {
        for(p=0;p<ni;p++) {
          for(q=0;q<nj;q++) {
            if (p==0 && q==0) 
              v=this.get(i*ni,j*nj);
            else
              v=filter(v,this.get(i*ni+p,j*nj+q),p*nj+q,ni*nj);
          }
        }
        m.set(i,j,v);
      }
    }
    return m;
  },

  col: function(j,asVector) {
    if (this.data.length === 0) { return null; }
    if (j >= this.data[0].length) { return null; }
    var col = [], n = this.data.length;
    for (var i = 0; i < n; i++) { col.push(this.data[i][j]); }
    return asVector?Math.Vector.create(col):col;
  },

  cols: function() {
    if (this.data.length === 0) { return 0; }
    return this.data[0].length;
  },

  derivative : function (order,points,h) {
    // TODO >1dim return Matrix.create(Math.derivative(this.data,order,points,h),{reference:true});
  },
  
  determinant: function() {
    if (this.data.length === 0) { return 1; }
    if (!this.isSquare()) { return null; }
    var M = this.toRightTriangular();
    var det = M.data[0][0], n = M.data.length;
    for (var i = 1; i < n; i++) {
      det = det * M.data[i][i];
    }
    return det;
  },

  diagonal: function() {
    if (!this.isSquare) { return null; }
    var els = [], n = this.data.length;
    for (var i = 0; i < n; i++) {
      els.push(this.data[i][i]);
    }
    return Math.Vector.create(els);
  },

  dimensions: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return {rows: this.data.length, cols: cols};
  },

  dup: function() {
    return Matrix.create(this.data);
  },

  // row,col
  e: function(i,j) {
    if (i < 1 || i > this.data.length || j < 1 || j > this.data[0].length) { return null; }
    return this.data[i-1][j-1];
  },

  eql: function(matrix) {
    var M = matrix.data || matrix;
    if (!M[0] || typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0 || M.length === 0) {
      return this.data.length === M.length;
    }
    if (this.data.length !== M.length) { return false; }
    if (this.data[0].length !== M[0].length) { return false; }
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j] - M[i][j]) > Math.precision) { return false; }
      }
    }
    return true;
  },

  forEach: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  get: function (i,j) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j];    
  },

  get rows () {
    return this.data.length;
  },
  get columns () {
    return this.data[0].length;
  },

  indexOf: function(x) {
    if (this.data.length === 0) { return null; }
    var index = null, ni = this.data.length, i, nj = this.data[0].length, j;
    for (i = 0; i < ni; i++) {
      for (j = 0; j < nj; j++) {
        if (this.data[i][j] === x) { return {i: i+1, j: j+1}; }
      }
    }
    return null;
  },

  inspect: function() {
    var matrix_rows = [];
    var n = this.data.length;
    if (n === 0) return '[]';
    for (var i = 0; i < n; i++) {
      matrix_rows.push(Math.Vector.create(this.data[i]).inspect());
    }
    return matrix_rows.join('\n');
  },

  inverse: function() {
    if (this.data.length === 0) { return null; }
    if (!this.isSquare() || this.isSingular()) { return null; }
    var n = this.data.length, i= n, j;
    var M = this.augment(Matrix.I(n)).toRightTriangular();
    var np = M.data[0].length, p, els, divisor;
    var inverse_elements = [], new_element;
    // Matrix. is non-singular so there will be no zeros on the
    // diagonal. Cycle through rows from last to first.
    while (i--) {
      // First, normalise diagonal elements to 1
      els = [];
      inverse_elements[i] = [];
      divisor = M.data[i][i];
      for (p = 0; p < np; p++) {
        new_element = M.data[i][p] / divisor;
        els.push(new_element);
        // Shuffle off the current row of the right hand side into the results
        // array as it will not be modified by later runs through this loop
        if (p >= n) { inverse_elements[i].push(new_element); }
      }
      M.data[i] = els;
      // Then, subtract this row from those above it to give the identity matrix
      // on the left hand side
      j = i;
      while (j--) {
        els = [];
        for (p = 0; p < np; p++) {
          els.push(M.data[j][p] - M.data[i][p] * M.data[j][i]);
        }
        M.data[j] = els;
      }
    }
    return Matrix.create(inverse_elements);
  },

  isSameSizeAs: function(matrix) {
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (this.data.length === 0) { return M.length === 0; }
    return (this.data.length === M.length &&
        this.data[0].length === M[0].length);
  },

  isSingular: function() {
    return (this.isSquare() && this.determinant() === 0);
  },

  isSquare: function() {
    var cols = (this.data.length === 0) ? 0 : this.data[0].length;
    return (this.data.length === cols);
  },

  iter: function(fn, context) {
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      while (j<nj) {
        fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return this;
  },

  loop: function(fn, context, tmo) {
    var tmo=typeof context=='number'?context:(tmo||1);
    var i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    var timer = setInterval(tmo,function () {
      if (i<ni) { 
        if (j<nj) {
          fn.call(context, this.data[i][j], i, j);
          j++;
        } else j = 0,i++;
      } else clearInterval(timer);
    });
    return this;
  },
  
  max: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] > m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) > Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  map: function(fn, context) {
    if (this.data.length === 0) { return Matrix.create([]); }
    var els = [], i = 0, ni=this.data.length, nj = this.data[0].length, j=0;
    while (i<ni) { 
      j = 0;
      els[i] = [];
      while (j<nj) {
        els[i][j] = fn.call(context, this.data[i][j], i, j);
        j++;
      }
      i++;
    }
    return Matrix.create(els);
  },

  mapRow : function (f) {
    var res=[];
    for(var row=0;row<this.rows;row++) {
      res.push(f(this.data[row],row));
    }
    return res;
  },

  min: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (this.data[i][j] < m) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    if (this.data.length === 0) { return null; }
    var m = this.data[0][0], i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(this.data[i][j]) < Math.abs(m)) { mi=[i,j]; m = this.data[i][j]; }
      }
    }
    return position?mi:m;
  },

  minor: function(a, b, c, d) {
    if (this.data.length === 0) { return null; }
    var elements = [], ni = c, i, nj, j;
    var rows = this.data.length, cols = this.data[0].length;
    while (ni--) { i = c - ni - 1;
      elements[i] = [];
      nj = d;
      while (nj--) { j = d - nj - 1;
        elements[i][j] = this.data[(a+i-1)%rows][(b+j-1)%cols];
      }
    }
    return Matrix.create(elements);
  },

  multiply: function(matrix) {
    if (this.data.length === 0) { return null; }
    if (!matrix.data) {
      return this.map(function(x) { return x * matrix; });
    }
    var returnVector = matrix.modulus ? true : false;
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.canMultiplyFromLeft(M)) { return null; }
    var i = this.data.length, nj = M[0].length, j;
    var cols = this.data[0].length, c, elements = [], sum;
    while (i--) { j = nj;
      elements[i] = [];
      while (j--) { c = cols;
        sum = 0;
        while (c--) {
          sum += this.data[i][c] * M[c][j];
        }
        elements[i][j] = sum;
      }
    }
    var M = Matrix.create(elements);
    return returnVector ? M.col(0,true) : M;
  },

  print : function (preci) {
    return this.dims==3?this.data.map(function (m) { return m.print() }).join('\n\n'):this.data.print(preci)
  },
  
  rank: function() {
    if (this.data.length === 0) { return 0; }
    var M = this.toRightTriangular(), rank = 0;
    var i = this.data.length, nj = this.data[0].length, j;
    while (i--) { j = nj;
      while (j--) {
        if (Math.abs(M.data[i][j]) > Math.precision) { rank++; break; }
      }
    }
    return rank;
  },

  // typeof @options = { rows, columns, algorithm?:'bilinear', ..}
  resize : function (options) {
    var space=this.dataspace,
        new_space=[],
        interp = 'nearest-neighbor',  // resize with interpolation 
        offset=[];
    if (Utils.isArray(options)) { // [row0,col0,row1,col1]
      switch (options.length) {
        case 2:
          new_space=[options[1]-options[0]];
          offset=[options[0]];
          break;
        case 4:
          new_space=[options[2]-options[0], options[3]-options[1]];
          offeset=[options[0],options[1]];
          break;
      }
    } else for(var p in options) {
      switch (p) {
        case 'rows':    new_space[0]=options[p]; break;
        case 'columns': new_space[1]=options[p]; break;
        case 'levels':  new_space[2]=options[p]; break;
        case 'dataspace': new_space=dataspace; break;
        case 'algorithm': interp=options[p]; break;
        case 'offset':
          offset=options[p];
          break;
      }
    }
    if (typeof offset == 'number') offset=[offset];
    
    // from https://github.com/LinusU/resize-image-data
    function nearestNeighbor (src, dst) {
      for (var y = 0; y < dst.rows; y++) {
        for (var x = 0; x < dst.columns; x++) {
          var srcX = Math.floor(x * src.columns / dst.columns)
          var srcY = Math.floor(y * src.rows / dst.rows)
          dst.data[y][x]=src.data[srcY][srcX];
        }
      }
    }
    function bilinearInterpolation (src, dst) {
      function interpolate (k, kMin, kMax, vMin, vMax) {
        return ((k - kMin) * vMax + (kMax - k) * vMin)
      }
      function interpolateHorizontal (x, y, xMin, xMax) {
        var vMin = src.data[y][xMin]
        if (xMin === xMax) return vMin;
        var vMax = src.data[y][xMax];
        return interpolate(x, xMin, xMax, vMin, vMax)
      }
      function interpolateVertical (x, xMin, xMax, y, yMin, yMax) {
        var vMin = interpolateHorizontal(x, yMin, xMin, xMax);
        if (yMin === yMax) return vMin;
        var vMax = interpolateHorizontal(x, yMax, xMin, xMax);
        return interpolate(y, yMin, yMax, vMin, vMax)
      }
      for (var y = 0; y < dst.rows; y++) {
        for (var x = 0; x < dst.columns; x++) {
          var srcX = x * src.columns / dst.columns
          var srcY = y * src.rows / dst.rows
          var xMin = Math.floor(srcX)
          var yMin = Math.floor(srcY)
          var xMax = Math.min(Math.ceil(srcX), src.columns - 1)
          var yMax = Math.min(Math.ceil(srcY), src.rows - 1)
          dst.data[y][x] = interpolateVertical(srcX, xMin, xMax, srcY, yMin, yMax)
         }
      }
    }
    
    switch (new_space.length) {
      case 0:
        // shrink rows
        if (offset.length==1) {
          return this.slice(offset[0]);        
        }
        break;
      case 1:
        // shrink/expand rows
        if (new_space[0]<space[0]) {
          offset=offset[0]||0;
          return this.slice(offset,offset+new_space[0]);
        }
        break;
      case 2:
        switch (interp) {
          case 'biliniear-interpolation':
          case 'bilinear':
            var src = this,
                dst = Matrix(new_space[0],new_space[1]);
            bilinearInterpolation(src,dst);
            return dst;
            break;
          case 'nearest-neighbor':
          case 'nearest':
          default:
            var src = this,
                dst = Matrix(new_space[0],new_space[1]);
            nearestNeighbor(src,dst);
            return dst;
            break;
        }
     
    }
    return new Error('ENOTSUPPORTED');
  },
  
  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  row: function(i,asVector) {
    if (i >= this.data.length) { return null; }
    return asVector?Math.Vector.create(this.data[i]):this.data[i];
  },

  snapTo: function(x) {
    return this.map(function(p) {
      return (Math.abs(p - x) <= Math.precision) ? x : p;
    });
  },

  set: function (i,j,v) {
    if (i < 0 || i >= this.data.length || j < 0 || j >= this.data[0].length) { return null; }
    return this.data[i][j]=v;    
  },

  setData: function(els,ref) {
    var i, j, elements = els.data || els;
    this.datatype='number';
    this.dataspace=Math.dataspace(elements);
    if (ref) { this.data=els; return this};
    if (elements[0] && typeof(elements[0][0]) !== 'undefined') {
      i = elements.length;
      this.data = [];
      while (i--) { j = elements[i].length;
        this.data[i] = [];
        while (j--) {
          this.data[i][j] = elements[i][j];
        }
      }
      return this;
    }
    var n = elements.length;
    this.data = [];
    for (i = 0; i < n; i++) {
      this.data.push([elements[i]]);
    }
    return this;
  },
  
  // Slice of data in major dimension
  slice : function (a,b,inplace) {
    if (b==undefined) b=this.rows;
    return inplace?
            Matrix(this.data.slice(a,b))
            : Matrix(this.data.slice(a,b).map(function (row) { return row.slice() }));
  },
  
  subMatrix : function (startRow, endRow, startColumn, endColumn) {
    var data = [];
    switch (this.dataspace.length) {
      case 1:
        for(var i=startRow;i<=endRow;i++) {
          data.push(this.data[i]);
        }
        return Vector(data);
        break;
      case 2:
        for(var i=startRow;i<endRow;i++) {
          var row=[];
          for(var j=startColumn;j<=endColumn;j++) {
            row.push(this.data[i][j]);
          }
          data.push(row);
        }
        return Matrix(data);
        break;
    }
  },
  
  // rx:rows,ry:columns,rz:levels
  subMatrixRange : function (rx,ry,rz) {
    var data=[];
    function copy(x) { return x.slice() }
    if (this.dataspace.length!=2) throw "subMatrixRange: dim not supported"
    if (isNumber(rx) && isAll(ry)) {
      return Matrix([this.data[rx].slice()]);
    } else if (isRange(rx) && isAll(ry)) {
      return Matrix(this.data.slice(rx[0],rx[1]+1).map(copy)); 
    } else {
      return this.subMatrix(isAll(rx)?0:isRange(rx)?rx[0]:isNumber(rx)?rx:0,
                            isAll(rx)?this.rows-1:isRange(rx)?rx[1]:isNumber(rx)?rx:this.rows-1,
                            isAll(ry)?0:isRange(ry)?ry[0]:isNumber(ry)?ry:0,
                            isAll(ry)?this.columns-1:isRange(ry)?ry[1]:isNumber(ry)?ry:this.columns-1);
    }
  },
  
  
  subtract: function(matrix) {
    if (this.data.length === 0) return this.map(function(x) { return x });
    var M = matrix.data || matrix;
    if (typeof(M[0][0]) === 'undefined') { M = Matrix.create(M).data; }
    if (!this.isSameSizeAs(M)) { return null; }
    return this.map(function(x, i, j) { return x - M[i][j]; });
  },

  toArray : function () { return this.data },
  
  toRightTriangular: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var M = this.dup(), els;
    var n = this.data.length, i, j, np = this.data[0].length, p;
    for (i = 0; i < n; i++) {
      if (M.data[i][i] === 0) {
        for (j = i + 1; j < n; j++) {
          if (M.data[j][i] !== 0) {
            els = [];
            for (p = 0; p < np; p++) { els.push(M.data[i][p] + M.data[j][p]); }
            M.data[i] = els;
            break;
          }
        }
      }
      if (M.data[i][i] !== 0) {
        for (j = i + 1; j < n; j++) {
          var multiplier = M.data[j][i] / M.data[i][i];
          els = [];
          for (p = 0; p < np; p++) {
            // Elements with column numbers up to an including the number of the
            // row that we're subtracting can safely be set straight to zero,
            // since that's the point of this routine and it avoids having to
            // loop over and correct rounding errors later
            els.push(p <= i ? 0 : M.data[j][p] - M.data[i][p] * multiplier);
          }
          M.data[j] = els;
        }
      }
    }
    return M;
  },

  trace: function() {
    if (this.data.length === 0) { return 0; }
    if (!this.isSquare()) { return null; }
    var tr = this.data[0][0], n = this.data.length;
    for (var i = 1; i < n; i++) {
      tr += this.data[i][i];
    }
    return tr;
  },
  
  transpose: function() {
    if (this.data.length === 0) return Matrix.create([]);
    var rows = this.data.length, i, cols = this.data[0].length, j;
    var elements = [], i = cols;
    while (i--) { j = rows;
      elements[i] = [];
      while (j--) {
        elements[i][j] = this.data[j][i];
      }
    }
    return Matrix.create(elements);
  },
};

Matrix.prototype.toUpperTriangular = Matrix.prototype.toRightTriangular;
Matrix.prototype.det = Matrix.prototype.determinant;
Matrix.prototype.tr = Matrix.prototype.trace;
Matrix.prototype.rk = Matrix.prototype.rank;
Matrix.prototype.inv = Matrix.prototype.inverse;
Matrix.prototype.x = Matrix.prototype.multiply;
Matrix.prototype.pluck = Matrix.prototype.col;

module.exports = Matrix;
};
BundleModuleCode['plugins/math/vector']=function (module,exports){
/*
** Vector array objects
**
** Ver. 1.4.1
*/
var isArray = Utils.isArray,
    isArrayArray = Utils.isArrayArray,
    isArrayArrayArray = Utils.isArrayArrayArray,
    isAll = Utils.isAll,
    isBoolean = Utils.isBoolean,
    isObj = Utils.isObject,
    isForEach = Utils.isForEach,
    isObject = Utils.isObject,
    isNumber = Utils.isNumber,
    isRange = Utils.isRange,
    isString = Utils.isString;
    
var Vector = function(elements,options) {
  if (!(this instanceof Vector)) return new Vector(elements,options);
  options=options||{};
  var space=[];
  this.tag='Vector';
  if (typeof elements == 'number') space.push(elements);
  if (space.length) {
    this.datatype='number';
    this.dataspace=space;
    this.columns=space[0];
    this.data=Array(space[0]).fill(0);
  } else {
    this.columns=elements.length;
    this.setData(elements,options.reference);
  }
  this.__constructor__='Math.Vector';
};

Vector.isVector = function (o) {
  return o instanceof Vector
}

Vector.create = Vector

// var $V = Vector.create;
Vector.Init = function(n,valueOrCallback) {
  var elements = [],i=0;
  if (typeof valueOrCallback == 'function')
    while (i<n) { elements.push(valueOrCallback(i)); i++; }
  else
    while (i<n) { elements.push(valueOrCallback); i++; }
  return Vector.create(elements);
};

Vector.Random = function(n) {
  var elements = [];
  while (n--) { elements.push(Math.random()); }
  return Vector.create(elements);
};

Vector.Sequence = function(a,b,step) {
  if (!step) step=1;
  var elements = [];
  var i=a;
  while (i<b) { 
    elements.push(i);
    i += step; 
  }
  return Vector.create(elements);
};

Vector.Zero = function(n) {
  var elements = [];
  while (n--) { elements.push(0); }
  return Vector.create(elements);
};

Vector.prototype = {
  e: function(i) {
    return (i < 1 || i > this.data.length) ? null : this.data[i-1];
  },


  add: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x + V[i-1]; });
  },

  angleFrom: function(vector) {
    var V = vector.data || vector;
    var n = this.data.length, k = n, i;
    if (n !== V.length) { return null; }
    var dot = 0, mod1 = 0, mod2 = 0;
    // Work things out in parallel to save time
    this.each(function(x, i) {
      dot += x * V[i-1];
      mod1 += x * x;
      mod2 += V[i-1] * V[i-1];
    });
    mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
    if (mod1*mod2 === 0) { return null; }
    var theta = dot / (mod1*mod2);
    if (theta < -1) { theta = -1; }
    if (theta > 1) { theta = 1; }
    return Math.acos(theta);
  },

  cross: function(vector) {
    var B = vector.data || vector;
    if (this.data.length !== 3 || B.length !== 3) { return null; }
    var A = this.data;
    return Vector.create([
      (A[1] * B[2]) - (A[2] * B[1]),
      (A[2] * B[0]) - (A[0] * B[2]),
      (A[0] * B[1]) - (A[1] * B[0])
    ]);
  },

  /** Convert size using a data filter.
   ** The target size must be provided.
   *  typeof @filter = 'mean' | 'peak' | 'min' | 'max' | 'win' | 'exp' | 'exp-peak' | function (a:number,b:number,i:number) -> number 
   */

  convert : function (a,b) {
    var i,p,v,m,ni,filter;

    if (isNumber(a)) i=a;
    if (isString(b)) filter=b;
    if (!filter) filter='mean';

    if (!i) throw "Vector.convert: no target size (number, first dim.)";

    m = Vector(i);

    if (typeof filter != 'function') switch (filter) {
      case 'mean':      filter=function (a,b,i,n) { if (i==n-1) return (a+b)/n; else return a+b }; break;
      case 'exp':       filter=function (a,b,i,n) { return (a+b)/2 }; break;
      case 'exp-peak':  filter=function (a,b,i,n) { return (Math.abs(a)+Math.abs(b))/2 }; break;
      case 'peak':      filter=function (a,b,i,n) { return Math.abs(a)>Math.abs(b)? Math.abs(a):Math.abs(b); }; break;
      case 'min':       filter=function (a,b,i,n) { return a<b?a:b }; break;
      case 'max':       filter=function (a,b,i,n) { return a>b?a:b }; break;
      default:          filter = function () { return 0 }
    }
    ni=Math.floor(this.columns/m.columns);
    for(i=0;i<m.columns;i++) {
        v=this.data[i*ni]; 
        for(p=1;p<ni;p++) {
          v=filter(v,this.data[i*ni+p],p,ni);
        }
        m.data[i]=v;
    }
    return m;
  },

  derivative : function (order,points,h) {
    return Vector.create(Math.derivative(this.data,order,points,h),{reference:true});
  },

  dimensions: function() {
    return this.data.length;
  },

  distanceFrom: function(obj) {
    if (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    var V = obj.data || obj;
    if (V.length !== this.data.length) { return null; }
    var sum = 0, part;
    this.each(function(x, i) {
      part = x - V[i-1];
      sum += part * part;
    });
    return Math.sqrt(sum);
  },

  dot: function(vector) {
    var V = vector.data || vector;
    var i, product = 0, n = this.data.length;
    if (n !== V.length) { return null; }
    while (n--) { product += this.data[n] * V[n]; }
    return product;
  },

  dup: function() {
    return Vector.create(this.data);
  },

  eql: function(vector) {
    var n = this.data.length;
    var V = vector.data || vector;
    if (n !== V.length) { return false; }
    while (n--) {
      if (Math.abs(this.data[n] - V[n]) > Math.precision) { return false; }
    }
    return true;
  },

  forEach: function(fn, context) {
    var n = this.data.length;
    for (var i = 0; i < n; i++) {
      fn.call(context, this.data[i], i+1);
    }
  },
  
  get : function (i) { return this.data[i] },

  indexOf: function(x) {
    var index = null, n = this.data.length;
    for (var i = 0; i < n; i++) {
      if (index === null && this.data[i] === x) {
        index = i + 1;
      }
    }
    return index;
  },

  inspect: function() {
    return '[' + this.data.join(', ') + ']';
  },

  // resize vector to any new size with interpolation
  interpolate : function (newpoints) {
    // http://hevi.info/do-it-yourself/interpolating-and-array-to-fit-another-size/
    function linearInterpolate(before, after, atPoint) {
	    return before + (after - before) * atPoint;
    };
    function interpolateArray(data, fitCount) {
	    var newData = new Array();
	    var springFactor = new Number((data.length - 1) / (fitCount - 1));
	    newData[0] = data[0]; // for new allocation
	    for ( var i = 1; i < fitCount - 1; i++) {
		    var tmp = i * springFactor;
		    var before = new Number(Math.floor(tmp)).toFixed();
		    var after = new Number(Math.ceil(tmp)).toFixed();
		    var atPoint = tmp - before;
		    newData[i] = linearInterpolate(data[before], data[after], atPoint);
		    }
	    newData[fitCount - 1] = data[data.length - 1]; // for new allocation
	    return newData;
    };
    return Vector(interpolateArray(this.data,newpoints));
  },
  
  isParallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (angle <= Math.precision);
  },

  isAntiparallelTo: function(vector) {
    var angle = this.angleFrom(vector);
    return (angle === null) ? null : (Math.abs(angle - Math.PI) <= Math.precision);
  },

  isPerpendicularTo: function(vector) {
    var dot = this.dot(vector);
    return (dot === null) ? null : (Math.abs(dot) <= Math.precision);
  },

  liesOn: function(line) {
    return line.contains(this);
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  get length () {
    return this.data.length
  },
  
  map: function(fn, context) {
    var elements = [];
    this.each(function(x, i) {
      elements.push(fn.call(context, x, i));
    });
    return Vector.create(elements);
  },

  max: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] > m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  maxAbs: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) > Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  min: function(position) {
    var mi;
    var m = this.data[0], i = this.data.length;
    while (i--) {
      if (this.data[i] < m) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  minAbs: function(position) {
    var mi;
    var m = 0, i = this.data.length;
    while (i--) {
      if (Math.abs(this.data[i]) < Math.abs(m)) { mi=i; m = this.data[i]; }
    }
    return position?mi:m;
  },

  modulus: function() {
    return Math.sqrt(this.dot(this));
  },

  multiply: function(k) {
    return this.map(function(x) { return x*k; });
  },

  pad : function (n,v,left) {
    return Vector(this.data.pad(n,v,left));
  },

  print : function () {
    return this.data.print()
  },

  reflectionIn: function(obj) {
    if (obj.anchor) {
      // obj is a plane or line
      var P = this.data.slice();
      var C = obj.pointClosestTo(P).data;
      return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
    } else {
      // obj is a point
      var Q = obj.data || obj;
      if (this.data.length !== Q.length) { return null; }
      return this.map(function(x, i) { return Q[i-1] + (Q[i-1] - x); });
    }
  },

  rotate: function(t, obj) {
    var V, R = null, x, y, z;
    if (t.determinant) { R = t.data; }
    switch (this.data.length) {
      case 2:
        V = obj.data || obj;
        if (V.length !== 2) { return null; }
        if (!R) { R = Math.Matrix.Rotation(t).data; }
        x = this.data[0] - V[0];
        y = this.data[1] - V[1];
        return Vector.create([
          V[0] + R[0][0] * x + R[0][1] * y,
          V[1] + R[1][0] * x + R[1][1] * y
        ]);
        break;
      case 3:
        if (!obj.direction) { return null; }
        var C = obj.pointClosestTo(this).data;
        if (!R) { R = Math.Matrix.Rotation(t, obj.direction).data; }
        x = this.data[0] - C[0];
        y = this.data[1] - C[1];
        z = this.data[2] - C[2];
        return Vector.create([
          C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
          C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
          C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
        ]);
        break;
      default:
        return null;
    }
  },

  round: function() {
    return this.map(function(x) { return Math.round(x); });
  },

  set : function (i,v) { return this.data[i]=v },

  setData: function(els,ref) {
    this.datatype='number';
    this.dataspace=[els.length];
    if (ref) { this.data=(els.data || els); return this};
    this.data = (els.data || els).slice();
    return this;
  },
  
  snapTo: function(x) {
    return this.map(function(y) {
      return (Math.abs(y - x) <= Math.precision) ? x : y;
    });
  },

  subtract: function(vector) {
    var V = vector.data || vector;
    if (this.data.length !== V.length) { return null; }
    return this.map(function(x, i) { return x - V[i-1]; });
  },

  toArray : function () { return this.data },

  to3D: function() {
    var V = this.dup();
    switch (V.data.length) {
      case 3: break;
      case 2: V.data.push(0); break;
      default: return null;
    }
    return V;
  },

  toDiagonalMatrix: function() {
    return Math.Matrix.Diagonal(this.data);
  },

  toUnitVector: function() {
    var r = this.modulus();
    if (r === 0) { return this.dup(); }
    return this.map(function(x) { return x/r; });
  },


};

Vector.prototype.x = Vector.prototype.multiply;
Vector.prototype.each = Vector.prototype.forEach;
Vector.prototype.sample = function (frag,filter) { return Vector(this.data.sample(frag,filter)) };

Vector.i = Vector.create([1,0,0]);
Vector.j = Vector.create([0,1,0]);
Vector.k = Vector.create([0,0,1]);

module.exports = Vector;
};
BundleModuleCode['plugins/math/line']=function (module,exports){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 

var Line = function(anchor, direction) {
  if (!(this instanceof Line)) return new Line(anchor, direction);
  this.setVectors(anchor, direction);
};

Line.prototype = {
  eql: function(line) {
    return (this.isParallelTo(line) && this.contains(line.anchor));
  },

  dup: function() {
    return Line.create(this.anchor, this.direction);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Line.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.direction);
  },

  isParallelTo: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }
    var theta = this.direction.angleFrom(obj.direction);
    return (Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    if (obj.direction) {
      // obj is a line
      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }
      var N = this.direction.cross(obj.direction).toUnitVector().data;
      var A = this.anchor.data, B = obj.anchor.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, D = this.direction.data;
      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
      if (modPA === 0) return 0;
      // Assumes direction vector is normalized
      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
      var sin2 = 1 - cosTheta*cosTheta;
      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
    }
  },

  contains: function(obj) {
    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }
    var dist = this.distanceFrom(obj);
    return (dist !== null && dist <= Math.precision);
  },

  positionOf: function(point) {
    if (!this.contains(point)) { return null; }
    var P = point.data || point;
    var A = this.anchor.data, D = this.direction.data;
    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];
  },

  liesIn: function(plane) {
    return plane.contains(this);
  },

  intersects: function(obj) {
    if (obj.normal) { return obj.intersects(this); }
    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Math.precision);
  },

  intersectionWith: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }
    if (!this.intersects(obj)) { return null; }
    var P = this.anchor.data, X = this.direction.data,
        Q = obj.anchor.data, Y = obj.direction.data;
    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
    var XdotX = X1*X1 + X2*X2 + X3*X3;
    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
  },

  pointClosestTo: function(obj) {
    if (obj.start && obj.end) {
      // obj is a line segment
      var P = obj.pointClosestTo(this);
      return (P === null) ? null : this.pointClosestTo(P);
    } else if (obj.direction) {
      // obj is a line
      if (this.intersects(obj)) { return this.intersectionWith(obj); }
      if (this.isParallelTo(obj)) { return null; }
      var D = this.direction.data, E = obj.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
      // Create plane containing obj and the shared normal and intersect this
      // with it Thank you:
      // http://www.cgafaq.info/wiki/Line-line_distance
      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];
      var P = Math.Plane.create(obj.anchor, N);
      return P.intersectionWith(this);
    } else {
      // obj is a point
      var P = obj.data || obj;
      if (this.contains(P)) { return Vector.create(P); }
      var A = this.anchor.data, D = this.direction.data;
      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
      var k = this.distanceFrom(P) / V.modulus();
      return Vector.create([
        P[0] + V.data[0] * k,
        P[1] + V.data[1] * k,
        (P[2] || 0) + V.data[2] * k
      ]);
    }
  },

  // Returns a copy of the line rotated by t radians about the given line. Works
  // by finding the argument's closest point to this line's anchor point (call
  // this C) and rotating the anchor about C. Also rotates the line's direction
  // about the argument's. Be careful with this - the rotation axis' direction
  // affects the outcome!
  rotate: function(t, line) {
    // If we're working in 2D
    if (typeof(line.direction) === 'undefined') { line = Line.create(line.to3D(), Vector.k); }
    var R = Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, D = this.direction.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Line.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
    ]);
  },

  reverse: function() {
    return Line.create(this.anchor, this.direction.x(-1));
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, D = this.direction.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the line's direction vector to its anchor, then mirror that in the plane
      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
      var Q = obj.pointClosestTo([AD1, AD2, AD3]).data;
      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
      return Line.create(newA, newD);
    } else if (obj.direction) {
      // obj is a line - reflection obtained by rotating PI radians about obj
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point - just reflect the line's anchor in it
      var P = obj.data || obj;
      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
    }
  },

  setVectors: function(anchor, direction) {
    // Need to do this so that line's properties are not references to the
    // arguments passed in
    anchor = Vector.create(anchor);
    direction = Vector.create(direction);
    if (anchor.data.length === 2) {anchor.data.push(0); }
    if (direction.data.length === 2) { direction.data.push(0); }
    if (anchor.data.length > 3 || direction.data.length > 3) { return null; }
    var mod = direction.modulus();
    if (mod === 0) { return null; }
    this.anchor = anchor;
    this.direction = Vector.create([
      direction.data[0] / mod,
      direction.data[1] / mod,
      direction.data[2] / mod
    ]);
    return this;
  }
};

Line.create = Line;

Line.X = Line.create(Vector.Zero(3), Vector.i);
Line.Y = Line.create(Vector.Zero(3), Vector.j);
Line.Z = Line.create(Vector.Zero(3), Vector.k);


module.exports = Line;
};
BundleModuleCode['plugins/math/plane']=function (module,exports){
var Vector = Require('plugins/math/vector') 
var Matrix = Require('plugins/math/matrix') 
var Line   = Require('plugins/math/line') 

var Plane = function(anchor, v1, v2) {
  if (!(this instanceof Plane)) return  new Plane(anchor, v1, v2);
  this.setVectors(anchor, v1, v2);
};

Plane.prototype = {
  eql: function(plane) {
    return (this.contains(plane.anchor) && this.isParallelTo(plane));
  },

  dup: function() {
    return Plane.create(this.anchor, this.normal);
  },

  translate: function(vector) {
    var V = vector.data || vector;
    return Plane.create([
      this.anchor.data[0] + V[0],
      this.anchor.data[1] + V[1],
      this.anchor.data[2] + (V[2] || 0)
    ], this.normal);
  },

  isParallelTo: function(obj) {
    var theta;
    if (obj.normal) {
      // obj is a plane
      theta = this.normal.angleFrom(obj.normal);
      return (Math.abs(theta) <= Math.precision || Math.abs(Math.PI - theta) <= Math.precision);
    } else if (obj.direction) {
      // obj is a line
      return this.normal.isPerpendicularTo(obj.direction);
    }
    return null;
  },

  isPerpendicularTo: function(plane) {
    var theta = this.normal.angleFrom(plane.normal);
    return (Math.abs(Math.PI/2 - theta) <= Math.precision);
  },

  distanceFrom: function(obj) {
    if (this.intersects(obj) || this.contains(obj)) { return 0; }
    if (obj.anchor) {
      // obj is a plane or line
      var A = this.anchor.data, B = obj.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
    }
  },

  contains: function(obj) {
    if (obj.normal) { return null; }
    if (obj.direction) {
      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));
    } else {
      var P = obj.data || obj;
      var A = this.anchor.data, N = this.normal.data;
      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
      return (diff <= Math.precision);
    }
  },

  intersects: function(obj) {
    if (typeof(obj.direction) === 'undefined' && typeof(obj.normal) === 'undefined') { return null; }
    return !this.isParallelTo(obj);
  },

  intersectionWith: function(obj) {
    if (!this.intersects(obj)) { return null; }
    if (obj.direction) {
      // obj is a line
      var A = obj.anchor.data, D = obj.direction.data,
          P = this.anchor.data, N = this.normal.data;
      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);
    } else if (obj.normal) {
      // obj is a plane
      var direction = this.normal.cross(obj.normal).toUnitVector();
      // To find an anchor point, we find one co-ordinate that has a value of
      // zero somewhere on the intersection, and remember which one we picked
      var N = this.normal.data, A = this.anchor.data,
          O = obj.normal.data, B = obj.anchor.data;
      var solver = Matrix.Zero(2,2), i = 0;
      while (solver.isSingular()) {
        i++;
        solver = Matrix.create([
          [ N[i%3], N[(i+1)%3] ],
          [ O[i%3], O[(i+1)%3]  ]
        ]);
      }
      // Then we solve the simultaneous equations in the remaining dimensions
      var inverse = solver.inverse().data;
      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
      var intersection = [
        inverse[0][0] * x + inverse[0][1] * y,
        inverse[1][0] * x + inverse[1][1] * y
      ];
      var anchor = [];
      for (var j = 1; j <= 3; j++) {
        // This formula picks the right element from intersection by cycling
        // depending on which element we set to zero above
        anchor.push((i === j) ? 0 : intersection[(j + (5 - i)%3)%3]);
      }
      return Line.create(anchor, direction);
    }
  },

  pointClosestTo: function(point) {
    var P = point.data || point;
    var A = this.anchor.data, N = this.normal.data;
    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
  },

  rotate: function(t, line) {
    var R = t.determinant ? t.data : Matrix.Rotation(t, line.direction).data;
    var C = line.pointClosestTo(this.anchor).data;
    var A = this.anchor.data, N = this.normal.data;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Plane.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
    ]);
  },

  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.data, N = this.normal.data;
      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
      var newA = this.anchor.reflectionIn(obj).data;
      // Add the plane's normal to its anchor, then mirror that in the other plane
      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
      var Q = obj.pointClosestTo([AN1, AN2, AN3]).data;
      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
      return Plane.create(newA, newN);
    } else if (obj.direction) {
      // obj is a line
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point
      var P = obj.data || obj;
      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
    }
  },

  setVectors: function(anchor, v1, v2) {
    anchor = Vector.create(anchor);
    anchor = anchor.to3D(); if (anchor === null) { return null; }
    v1 = Vector.create(v1);
    v1 = v1.to3D(); if (v1 === null) { return null; }
    if (typeof(v2) === 'undefined') {
      v2 = null;
    } else {
      v2 = Vector.create(v2);
      v2 = v2.to3D(); if (v2 === null) { return null; }
    }
    var A1 = anchor.data[0], A2 = anchor.data[1], A3 = anchor.data[2];
    var v11 = v1.data[0], v12 = v1.data[1], v13 = v1.data[2];
    var normal, mod;
    if (v2 !== null) {
      var v21 = v2.data[0], v22 = v2.data[1], v23 = v2.data[2];
      normal = Vector.create([
        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
      ]);
      mod = normal.modulus();
      if (mod === 0) { return null; }
      normal = Vector.create([normal.data[0] / mod, normal.data[1] / mod, normal.data[2] / mod]);
    } else {
      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
      if (mod === 0) { return null; }
      normal = Vector.create([v1.data[0] / mod, v1.data[1] / mod, v1.data[2] / mod]);
    }
    this.anchor = anchor;
    this.normal = normal;
    return this;
  }
};

Plane.create = Plane


Plane.XY = Plane.create(Vector.Zero(3), Vector.k);
Plane.YZ = Plane.create(Vector.Zero(3), Vector.i);
Plane.ZX = Plane.create(Vector.Zero(3), Vector.j);
Plane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;

Plane.fromPoints = function(points) {
  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);
  for (i = 0; i < np; i++) {
    P = Vector.create(points[i]).to3D();
    if (P === null) { return null; }
    list.push(P);
    n = list.length;
    if (n > 2) {
      // Compute plane normal for the latest three points
      A = list[n-1].data; B = list[n-2].data; C = list[n-3].data;
      N = Vector.create([
        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
      ]).toUnitVector();
      if (n > 3) {
        // If the latest normal is not (anti)parallel to the previous one, we've
        // strayed off the plane. This might be a slightly long-winded way of
        // doing things, but we need the sum of all the normals to find which
        // way the plane normal should point so that the points form an
        // anticlockwise list.
        theta = N.angleFrom(prevN);
        if (theta !== null) {
          if (!(Math.abs(theta) <= Math.precision || Math.abs(theta - Math.PI) <= Math.precision)) { return null; }
        }
      }
      totalN = totalN.add(N);
      prevN = N;
    }
  }
  // We need to add in the normals at the start and end points, which the above
  // misses out
  A = list[1].data; B = list[0].data; C = list[n-1].data; D = list[n-2].data;
  totalN = totalN.add(Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).toUnitVector()).add(Vector.create([
    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),
    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),
    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])
  ]).toUnitVector());
  return Plane.create(list[0], totalN);
};
};
BundleModuleCode['plugins/math/stats']=function (module,exports){
// https://github.com/simple-statistics/simple-statistics
// Version 1.3.3

'use strict';

var exports = module.exports;
function log2(n) {
  return Math.log(n) / Math.log(2);
}

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0,
            sumY = 0,
            sumXX = 0,
            sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    } else if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0],
        // store the mode as we find new modes
        value = NaN,
        // store how many times we've seen the mode
        maxSeen = 0,
        // how many times the current candidate for the mode
        // has been seen
        seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(nlog(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, min is
        // undefined and is thus made the minimum element in the array
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        // On the first iteration of this loop, max is
        // undefined and is thus made the maximum element in the array
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    // The mad of nothing is null
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // chose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample.slice(), randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0,
        lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix.length - 1) {
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "geometricMean requires only positive numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.2174396181152126432e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Infinity;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    "1": {
        "0.995": 0,
        "0.99": 0,
        "0.975": 0,
        "0.95": 0,
        "0.9": 0.02,
        "0.5": 0.45,
        "0.1": 2.71,
        "0.05": 3.84,
        "0.025": 5.02,
        "0.01": 6.63,
        "0.005": 7.88
    },
    "2": {
        "0.995": 0.01,
        "0.99": 0.02,
        "0.975": 0.05,
        "0.95": 0.1,
        "0.9": 0.21,
        "0.5": 1.39,
        "0.1": 4.61,
        "0.05": 5.99,
        "0.025": 7.38,
        "0.01": 9.21,
        "0.005": 10.6
    },
    "3": {
        "0.995": 0.07,
        "0.99": 0.11,
        "0.975": 0.22,
        "0.95": 0.35,
        "0.9": 0.58,
        "0.5": 2.37,
        "0.1": 6.25,
        "0.05": 7.81,
        "0.025": 9.35,
        "0.01": 11.34,
        "0.005": 12.84
    },
    "4": {
        "0.995": 0.21,
        "0.99": 0.3,
        "0.975": 0.48,
        "0.95": 0.71,
        "0.9": 1.06,
        "0.5": 3.36,
        "0.1": 7.78,
        "0.05": 9.49,
        "0.025": 11.14,
        "0.01": 13.28,
        "0.005": 14.86
    },
    "5": {
        "0.995": 0.41,
        "0.99": 0.55,
        "0.975": 0.83,
        "0.95": 1.15,
        "0.9": 1.61,
        "0.5": 4.35,
        "0.1": 9.24,
        "0.05": 11.07,
        "0.025": 12.83,
        "0.01": 15.09,
        "0.005": 16.75
    },
    "6": {
        "0.995": 0.68,
        "0.99": 0.87,
        "0.975": 1.24,
        "0.95": 1.64,
        "0.9": 2.2,
        "0.5": 5.35,
        "0.1": 10.65,
        "0.05": 12.59,
        "0.025": 14.45,
        "0.01": 16.81,
        "0.005": 18.55
    },
    "7": {
        "0.995": 0.99,
        "0.99": 1.25,
        "0.975": 1.69,
        "0.95": 2.17,
        "0.9": 2.83,
        "0.5": 6.35,
        "0.1": 12.02,
        "0.05": 14.07,
        "0.025": 16.01,
        "0.01": 18.48,
        "0.005": 20.28
    },
    "8": {
        "0.995": 1.34,
        "0.99": 1.65,
        "0.975": 2.18,
        "0.95": 2.73,
        "0.9": 3.49,
        "0.5": 7.34,
        "0.1": 13.36,
        "0.05": 15.51,
        "0.025": 17.53,
        "0.01": 20.09,
        "0.005": 21.96
    },
    "9": {
        "0.995": 1.73,
        "0.99": 2.09,
        "0.975": 2.7,
        "0.95": 3.33,
        "0.9": 4.17,
        "0.5": 8.34,
        "0.1": 14.68,
        "0.05": 16.92,
        "0.025": 19.02,
        "0.01": 21.67,
        "0.005": 23.59
    },
    "10": {
        "0.995": 2.16,
        "0.99": 2.56,
        "0.975": 3.25,
        "0.95": 3.94,
        "0.9": 4.87,
        "0.5": 9.34,
        "0.1": 15.99,
        "0.05": 18.31,
        "0.025": 20.48,
        "0.01": 23.21,
        "0.005": 25.19
    },
    "11": {
        "0.995": 2.6,
        "0.99": 3.05,
        "0.975": 3.82,
        "0.95": 4.57,
        "0.9": 5.58,
        "0.5": 10.34,
        "0.1": 17.28,
        "0.05": 19.68,
        "0.025": 21.92,
        "0.01": 24.72,
        "0.005": 26.76
    },
    "12": {
        "0.995": 3.07,
        "0.99": 3.57,
        "0.975": 4.4,
        "0.95": 5.23,
        "0.9": 6.3,
        "0.5": 11.34,
        "0.1": 18.55,
        "0.05": 21.03,
        "0.025": 23.34,
        "0.01": 26.22,
        "0.005": 28.3
    },
    "13": {
        "0.995": 3.57,
        "0.99": 4.11,
        "0.975": 5.01,
        "0.95": 5.89,
        "0.9": 7.04,
        "0.5": 12.34,
        "0.1": 19.81,
        "0.05": 22.36,
        "0.025": 24.74,
        "0.01": 27.69,
        "0.005": 29.82
    },
    "14": {
        "0.995": 4.07,
        "0.99": 4.66,
        "0.975": 5.63,
        "0.95": 6.57,
        "0.9": 7.79,
        "0.5": 13.34,
        "0.1": 21.06,
        "0.05": 23.68,
        "0.025": 26.12,
        "0.01": 29.14,
        "0.005": 31.32
    },
    "15": {
        "0.995": 4.6,
        "0.99": 5.23,
        "0.975": 6.27,
        "0.95": 7.26,
        "0.9": 8.55,
        "0.5": 14.34,
        "0.1": 22.31,
        "0.05": 25,
        "0.025": 27.49,
        "0.01": 30.58,
        "0.005": 32.8
    },
    "16": {
        "0.995": 5.14,
        "0.99": 5.81,
        "0.975": 6.91,
        "0.95": 7.96,
        "0.9": 9.31,
        "0.5": 15.34,
        "0.1": 23.54,
        "0.05": 26.3,
        "0.025": 28.85,
        "0.01": 32,
        "0.005": 34.27
    },
    "17": {
        "0.995": 5.7,
        "0.99": 6.41,
        "0.975": 7.56,
        "0.95": 8.67,
        "0.9": 10.09,
        "0.5": 16.34,
        "0.1": 24.77,
        "0.05": 27.59,
        "0.025": 30.19,
        "0.01": 33.41,
        "0.005": 35.72
    },
    "18": {
        "0.995": 6.26,
        "0.99": 7.01,
        "0.975": 8.23,
        "0.95": 9.39,
        "0.9": 10.87,
        "0.5": 17.34,
        "0.1": 25.99,
        "0.05": 28.87,
        "0.025": 31.53,
        "0.01": 34.81,
        "0.005": 37.16
    },
    "19": {
        "0.995": 6.84,
        "0.99": 7.63,
        "0.975": 8.91,
        "0.95": 10.12,
        "0.9": 11.65,
        "0.5": 18.34,
        "0.1": 27.2,
        "0.05": 30.14,
        "0.025": 32.85,
        "0.01": 36.19,
        "0.005": 38.58
    },
    "20": {
        "0.995": 7.43,
        "0.99": 8.26,
        "0.975": 9.59,
        "0.95": 10.85,
        "0.9": 12.44,
        "0.5": 19.34,
        "0.1": 28.41,
        "0.05": 31.41,
        "0.025": 34.17,
        "0.01": 37.57,
        "0.005": 40
    },
    "21": {
        "0.995": 8.03,
        "0.99": 8.9,
        "0.975": 10.28,
        "0.95": 11.59,
        "0.9": 13.24,
        "0.5": 20.34,
        "0.1": 29.62,
        "0.05": 32.67,
        "0.025": 35.48,
        "0.01": 38.93,
        "0.005": 41.4
    },
    "22": {
        "0.995": 8.64,
        "0.99": 9.54,
        "0.975": 10.98,
        "0.95": 12.34,
        "0.9": 14.04,
        "0.5": 21.34,
        "0.1": 30.81,
        "0.05": 33.92,
        "0.025": 36.78,
        "0.01": 40.29,
        "0.005": 42.8
    },
    "23": {
        "0.995": 9.26,
        "0.99": 10.2,
        "0.975": 11.69,
        "0.95": 13.09,
        "0.9": 14.85,
        "0.5": 22.34,
        "0.1": 32.01,
        "0.05": 35.17,
        "0.025": 38.08,
        "0.01": 41.64,
        "0.005": 44.18
    },
    "24": {
        "0.995": 9.89,
        "0.99": 10.86,
        "0.975": 12.4,
        "0.95": 13.85,
        "0.9": 15.66,
        "0.5": 23.34,
        "0.1": 33.2,
        "0.05": 36.42,
        "0.025": 39.36,
        "0.01": 42.98,
        "0.005": 45.56
    },
    "25": {
        "0.995": 10.52,
        "0.99": 11.52,
        "0.975": 13.12,
        "0.95": 14.61,
        "0.9": 16.47,
        "0.5": 24.34,
        "0.1": 34.28,
        "0.05": 37.65,
        "0.025": 40.65,
        "0.01": 44.31,
        "0.005": 46.93
    },
    "26": {
        "0.995": 11.16,
        "0.99": 12.2,
        "0.975": 13.84,
        "0.95": 15.38,
        "0.9": 17.29,
        "0.5": 25.34,
        "0.1": 35.56,
        "0.05": 38.89,
        "0.025": 41.92,
        "0.01": 45.64,
        "0.005": 48.29
    },
    "27": {
        "0.995": 11.81,
        "0.99": 12.88,
        "0.975": 14.57,
        "0.95": 16.15,
        "0.9": 18.11,
        "0.5": 26.34,
        "0.1": 36.74,
        "0.05": 40.11,
        "0.025": 43.19,
        "0.01": 46.96,
        "0.005": 49.65
    },
    "28": {
        "0.995": 12.46,
        "0.99": 13.57,
        "0.975": 15.31,
        "0.95": 16.93,
        "0.9": 18.94,
        "0.5": 27.34,
        "0.1": 37.92,
        "0.05": 41.34,
        "0.025": 44.46,
        "0.01": 48.28,
        "0.005": 50.99
    },
    "29": {
        "0.995": 13.12,
        "0.99": 14.26,
        "0.975": 16.05,
        "0.95": 17.71,
        "0.9": 19.77,
        "0.5": 28.34,
        "0.1": 39.09,
        "0.05": 42.56,
        "0.025": 45.72,
        "0.01": 49.59,
        "0.005": 52.34
    },
    "30": {
        "0.995": 13.79,
        "0.99": 14.95,
        "0.975": 16.79,
        "0.95": 18.49,
        "0.9": 20.6,
        "0.5": 29.34,
        "0.1": 40.26,
        "0.05": 43.77,
        "0.025": 46.98,
        "0.01": 50.89,
        "0.005": 53.67
    },
    "40": {
        "0.995": 20.71,
        "0.99": 22.16,
        "0.975": 24.43,
        "0.95": 26.51,
        "0.9": 29.05,
        "0.5": 39.34,
        "0.1": 51.81,
        "0.05": 55.76,
        "0.025": 59.34,
        "0.01": 63.69,
        "0.005": 66.77
    },
    "50": {
        "0.995": 27.99,
        "0.99": 29.71,
        "0.975": 32.36,
        "0.95": 34.76,
        "0.9": 37.69,
        "0.5": 49.33,
        "0.1": 63.17,
        "0.05": 67.5,
        "0.025": 71.42,
        "0.01": 76.15,
        "0.005": 79.49
    },
    "60": {
        "0.995": 35.53,
        "0.99": 37.48,
        "0.975": 40.48,
        "0.95": 43.19,
        "0.9": 46.46,
        "0.5": 59.33,
        "0.1": 74.4,
        "0.05": 79.08,
        "0.025": 83.3,
        "0.01": 88.38,
        "0.005": 91.95
    },
    "70": {
        "0.995": 43.28,
        "0.99": 45.44,
        "0.975": 48.76,
        "0.95": 51.74,
        "0.9": 55.33,
        "0.5": 69.33,
        "0.1": 85.53,
        "0.05": 90.53,
        "0.025": 95.02,
        "0.01": 100.42,
        "0.005": 104.22
    },
    "80": {
        "0.995": 51.17,
        "0.99": 53.54,
        "0.975": 57.15,
        "0.95": 60.39,
        "0.9": 64.28,
        "0.5": 79.33,
        "0.1": 96.58,
        "0.05": 101.88,
        "0.025": 106.63,
        "0.01": 112.33,
        "0.005": 116.32
    },
    "90": {
        "0.995": 59.2,
        "0.99": 61.75,
        "0.975": 65.65,
        "0.95": 69.13,
        "0.9": 73.29,
        "0.5": 89.33,
        "0.1": 107.57,
        "0.05": 113.14,
        "0.025": 118.14,
        "0.01": 124.12,
        "0.005": 128.3
    },
    "100": {
        "0.995": 67.33,
        "0.99": 70.06,
        "0.975": 74.22,
        "0.95": 77.93,
        "0.9": 82.36,
        "0.5": 99.33,
        "0.1": 118.5,
        "0.05": 124.34,
        "0.025": 129.56,
        "0.01": 135.81,
        "0.005": 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z,
        tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI$1) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the cumulative distribution function of the normal distribution.
 * It is used to find the probability that a statistic is observed below,
 * above, or between values on the standard normal distribution, and by
 * extension, any normal distribution.
 *
 * The probabilities are calculated using the
 * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).
 * The table used is the cumulative, and not cumulative from 0 to mean
 * (even though the latter has 5 digits precision, instead of 4).
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return +(1 - standardNormalTable[index]).toFixed(4);
    }
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'"
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}


// More statistics: enrtopy ...

// Finds element with highest occurrence in a list
function mostCommon(list) {
  var elementFrequencyMap = {};
  var largestFrequency = -1;
  var mostCommonElement = null;
  list.forEach(function(element) {
    var elementFrequency = (elementFrequencyMap[element] || 0) + 1;
    elementFrequencyMap[element] = elementFrequency;

    if (largestFrequency < elementFrequency) {
      mostCommonElement = element;
      largestFrequency = elementFrequency;
    }
  });

  return mostCommonElement;
}
exports.mostCommon = mostCommon;

// Probe for a value
function probe(value, list) {
  var occurrences = list.filter(function(element) {
    return element === value
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probe = probe;
/**
 * Computes probability of of a given value existing in a given list
 * with additional 2*epsilon interval, only applicable to numerical values.
 */
function probeEps(value, list, eps) {
  var occurrences = list.filter(function(element) {
    return (element >= (value-eps)) && (element <= (value+eps));
  });

  var numOccurrences = occurrences.length;
  var numElements = list.length;
  return numOccurrences / numElements;
}
exports.probeEps = probeEps;


exports.unique = function (list) { return list.unique() };
function uniqueSorted (array) {
  var set = array.unique().sort(function (a,b) { return a<b?-1:1 });
  return set;
}
function uniqueEps(array,eps) {
  var result=[];
  array.forEach(function (x) {
    var found;
    if (!result.length) result.push(x);
    else {
      result.forEach(function (y) {
        if (found) return;
        found = Math.abs(x-y)<=eps;
      }); 
      if (!found) result.push(x);
    }
  });
  return result;
}
exports.uniqueEps = uniqueEps;

// Entropy of data vectors
function entropy(vals) {
  var uniqueVals = vals.unique();
  var probs = uniqueVals.map(function(x) {
    return probe(x, vals)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropy = entropy;

function entropyEps(vals,eps) {
  var uniqueVals = uniqueEps(vals,eps);
  var probs = uniqueVals.map(function(x) {
    return probeEps(x, vals, eps)
  });

  var logVals = probs.map(function(p) {
    return -p * log2(p)
  });

  return logVals.sum();
}
exports.entropyEps = entropyEps;

// Entropy of target variable partitioned feature vector
function entropyT(data,featureIndex,targetIndex,targets) {
  var en = 0;
  var col =  pluck(data,featureIndex);
  var uniqueVals = unique(col);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2==v) cn++,frac[targets.indexOf(data[row][targetIndex])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyT = entropyT;

function entropyTEps(data,feature,target,targets,eps) {
  var en = 0;
  var col =  pluck(data,feature);
  var uniqueVals = uniqueEps(col,eps);
  uniqueVals.forEach(function (v) {
    var frac = targets.map(function () { return 0 }),
        cn=0;
    col.forEach (function (v2,row) {
      if (v2>=v-eps && v2<=v+eps) cn++,frac[targets.indexOf(data[row][target])]++;
    })
    var p = cn/data.length;
    en += (p*entropyN(frac,frac.sum()))
    // print(frac,p,frac.reduce(sum))
  })
  return en;
}
exports.entropyTEps = entropyTEps;


function gainEps(data,feature,target,targets,eps) {
  var et = entropy(data.pluck(target));
  return et/entropyTEps(data,feature,target,targets,eps)
}


function maxGainEps(data,features,target,targets,eps) {
  var maxgain=max(features, function(feature,index) {
    var g = gainEps(data,feature,target,targets,selectEps(eps,index));
    return g;
  });
  return maxgain;
}

function distribution (table) {
  var d={};
  table.forEach(function (row) {
    if (Utils.isArray(row)) row.forEach(function (v) { 
      if (d[v]==undefined) d[v]=1; else d[v]++ });
    else { if (d[row]==undefined) d[row]=1; else d[row]++ };
  })
  return d;
}
function histogram (vector,delta,min,max) {
  if (vector instanceof Array) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.length;i++) {
      var chan=Math.floor((vector[i]-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h};
  }
  if (Utils.isVector(vector)) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.length;i++) {
      var chan=Math.floor((vector.get(i)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isMatrix(vector)) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.rows;i++) for(var j=0;j<vector.columns;j++) {
      var chan=Math.floor((vector.get(i,j)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isVectorTA(vector)) {
    if (min==undefined) min=vector.min();
    if (max==undefined) max=vector.max();
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var j=0;j<vector.columns;j++) {
      var chan=Math.floor((vector.get(j)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isMatrixTA(vector)) {
    var minmax = vector.minmax();
    if (min==undefined) min=minmax.min;
    if (max==undefined) max=minmax.max;
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var i=0;i<vector.rows;i++) for(var j=0;j<vector.columns;j++) {
      var chan=Math.floor((vector.get(i,j)-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
  if (Utils.isTypedArray(vector)) {
    var _min=vector[0],_max=vector[0];
    for(var i=0;i<vector.length;i++) {
      _min=Math.min(_min,vector[i]);
      _max=Math.max(_max,vector[i]);
    }
    if (min==undefined) min=_min;
    if (max==undefined) max=_max;
    var n;
    if (delta!=undefined) {
      n = Math.ceil((max-min)/delta);
    } else {
      n=100; delta=(max-min)/n;
    }
    var h = Array.init(n),x=Math.sequence(min,max,delta);
    for(var j=0;j<vector.length;j++) {
      var chan=Math.floor((vector[j]-min)/delta);
      h[chan]++;
    }
    return {x:x,y:h}; 
  }
}

function smN (vector,N) {
  var xm=vector.sum()/vector.length;
  return vector.map(function (x) { return Math.pow(x-xm,N) }).sum() 
}
function nans(vector) {
  var n=0; for(var i in vector) if (isNaN(vector[i])) n++;
  return n
}
function zeros(vector) {
  var n=0; for(var i in vector) if (vector[i]==0) n++;
  return n
}
exports.BayesianClassifier = BayesianClassifier;
exports.PerceptronModel = PerceptronModel;
exports.addToMean = addToMean;
exports.average = mean;
exports.averageSimple = meanSimple;
exports.bayesian = BayesianClassifier;
exports.bernoulliDistribution = bernoulliDistribution;
exports.binomialDistribution = binomialDistribution;
exports.bisect = bisect;
exports.chiSquaredDistributionTable = chiSquaredDistributionTable;
exports.chiSquaredGoodnessOfFit = chiSquaredGoodnessOfFit;
exports.chunk = chunk;
exports.ckmeans = ckmeans;
exports.combinations = combinations;
exports.combinationsReplacement = combinationsReplacement;
exports.combineMeans = combineMeans;
exports.combineVariances = combineVariances;
exports.cumulativeStdNormalProbability = cumulativeStdNormalProbability;
exports.distribution = distribution;
exports.epsilon = epsilon;
exports.equalIntervalBreaks = equalIntervalBreaks;
exports.erf = errorFunction;
exports.errorFunction = errorFunction;
exports.extent = extent;
exports.extentSorted = extentSorted;
exports.factorial = factorial;
exports.gamma = gamma;
exports.gammaln = gammaln;
exports.geometricMean = geometricMean;
exports.harmonicMean = harmonicMean;
exports.histogram = histogram;
exports.interquartileRange = interquartileRange;
exports.inverseErrorFunction = inverseErrorFunction;
exports.iqr = interquartileRange;
exports.kde = kernelDensityEstimation;
exports.kernelDensityEstimation = kernelDensityEstimation;
exports.linearRegression = linearRegression;
exports.linearRegressionLine = linearRegressionLine;
exports.mad = medianAbsoluteDeviation;
exports.max = max;
exports.maxSorted = maxSorted;
exports.mean = mean;
exports.meanSimple = meanSimple;
exports.median = median;
exports.medianAbsoluteDeviation = medianAbsoluteDeviation;
exports.medianSorted = medianSorted;
exports.min = min;
exports.minSorted = minSorted;
exports.mode = mode;
exports.modeFast = modeFast;
exports.modeSorted = modeSorted;
exports.nans = nans;
exports.numericSort = numericSort;
exports.perceptron = PerceptronModel;
exports.permutationTest = permutationTest;
exports.permutationsHeap = permutationsHeap;
exports.poissonDistribution = poissonDistribution;
exports.probit = probit;
exports.product = product;
exports.quantile = quantile;
exports.quantileRank = quantileRank;
exports.quantileRankSorted = quantileRankSorted;
exports.quantileSorted = quantileSorted;
exports.quickselect = quickselect;
exports.rSquared = rSquared;
exports.rms = rootMeanSquare;
exports.rootMeanSquare = rootMeanSquare;
exports.sample = sample;
exports.sampleCorrelation = sampleCorrelation;
exports.sampleCovariance = sampleCovariance;
exports.sampleKurtosis = sampleKurtosis;
exports.sampleSkewness = sampleSkewness;
exports.sampleStandardDeviation = sampleStandardDeviation;
exports.sampleVariance = sampleVariance;
exports.sampleWithReplacement = sampleWithReplacement;
exports.shuffle = shuffle;
exports.shuffleInPlace = shuffleInPlace;
exports.sign = sign;
exports.standardDeviation = standardDeviation;
exports.standardNormalTable = standardNormalTable;
exports.subtractFromMean = subtractFromMean;
exports.sm2 = function (v) { return smN(v,2) };
exports.sm3 = function (v) { return smN(v,3) };
exports.sm4 = function (v) { return smN(v,4) };
exports.sum = sum;
exports.sumNthPowerDeviations = sumNthPowerDeviations;
exports.sumSimple = sumSimple;
exports.tTest = tTest;
exports.tTestTwoSample = tTestTwoSample;
exports.uniqueCountSorted = uniqueCountSorted;
exports.uniqueSorted = uniqueSorted;
exports.variance = variance;
exports.zeros = zeros;
exports.zScore = zScore;


// Full statistical analysis of a data set
function analysis (data,options) {
  var i,numeric,column;
  options=options||{};
  function analize(column,options) {
    var numeric=options.numeric;
    if (numeric == undefined) {
        numeric = column.filter(function (row) {
        return isNaN(Number(row))
      }).length==0; 
    }
    if (numeric) {
      var sm2=smN(column,2),sm3=smN(column,3),
          sm4=smN(column,4),n = column.length;;
      return {
        covariance : sampleCovariance(column,column),
        kurtosis : n*sm4/(sm2*sm2),
        mean    : mean(column),
        median  : median(column),
        medianAbsoluteDeviation:medianAbsoluteDeviation(column),
        min     : min(column),
        max     : max(column),
        n       : n,
        nan     : nans(column),
        rootMeanSquare:rootMeanSquare(column),
        skewness : Math.sqrt(n)*sm3/(sm2*Math.sqrt(sm2)),
        sm2     : sm2,
        sm3     : sm3,
        sm4     : sm4,
        standardDeviation:standardDeviation(column),
        sum     : sum(column),
        uniqueCountSorted:uniqueCountSorted(column),
        variance:variance(column),
        zeros   : zeros(column),
      }
    } else {
      return {
        distribution:distribution(column),
        entropy:entropy(column),
        mostCommon:mostCommon(column),
        unique:uniqueSorted(column),
      }
    }
  }
  if (Utils.isMatrix(data)) {
    return data[0].map(function (x,i) {
      return analize(data.pluck(i),{
        numeric:typeof options.numeric == 'boolean'?options.numeric:
                (Utils.isArray(options.numeric)?options.numeric[i]:undefined)
      });
    })
  } else
    return analize(data,options); // todo: matrix
}
exports.analysis = analysis;

};
BundleModuleCode['plugins/math/dwt5']=function (module,exports){
/* https://github.com/Symmetronic/discrete-wavelets */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.wt = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /**
     * Antisymmetric padding.
     */
    var ANTISYMMETRIC_PADDING = 'antisymmetric';
    /**
     * Returns a single value of antisymmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function antisymmetricPadding$$1(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        var dirChanges = Math.floor(index / data.length);
        var sign = (dirChanges % 2 === 0) ? -1 : 1;
        return sign * symmetricPadding(data, index, inverse);
    }

    /**
     * Constant padding.
     */
    var CONSTANT_PADDING = 'constant';
    /**
     * Returns a single value of constant padding.
     * @param  data    Input values.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function constantPadding(data, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine constant padding for data of zero length.');
        }
        /* Determine constant padding. */
        return (!inverse)
            ? data[data.length - 1]
            : data[0];
    }

    /**
     * Periodic padding.
     */
    var PERIODIC_PADDING = 'periodic';
    /**
     * Returns a single value of periodic padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function periodicPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine periodic padding for data of zero length.');
        }
        /* Determine periodic padding. */
        return (!inverse)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Reflect padding.
     */
    var REFLECT_PADDING = 'reflect';
    /**
     * Returns a single value of reflect padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function reflectPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine reflect padding for data of zero length.');
        }
        /* Return constant value for data of length one. */
        if (data.length === 1)
            return data[0];
        /* Determine reflect padding. */
        var dirChanges = Math.floor(index / (data.length - 1));
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % (data.length - 1) + 1]
            : data[data.length - 2 - (index % (data.length - 1))];
    }

    /**
     * Smooth padding.
     */
    var SMOOTH_PADDING = 'smooth';
    /**
     * Returns a single value of smooth padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function smoothPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine smooth padding for data of zero length.');
        }
        /* Determine line equation. */
        var end = data.length - 1;
        var offset = (inverse) ? data[0] : data[end];
        var slope = (inverse)
            ? (data.length === 1) ? data[0] : data[0] - data[1]
            : (data.length === 1) ? -data[0] : data[end] - data[end - 1];
        return offset + (index + 1) * slope;
    }

    /**
     * Symmetric padding.
     */
    var SYMMETRIC_PADDING = 'symmetric';
    /**
     * Returns a single value of symmetric padding.
     * @param  data    Input values.
     * @param  index   Index of padding.
     * @param  inverse True if the direction should be inversed.
     * @return         Single padding value.
     */
    function symmetricPadding(data, index, inverse) {
        if (inverse === void 0) { inverse = false; }
        /* Check if data has length larger than zero. */
        if (data.length === 0) {
            throw new Error('Cannot determine symmetric padding for data of zero length.');
        }
        /* Determine symmetric padding. */
        var dirChanges = Math.floor(index / data.length);
        var inversions = (inverse) ? dirChanges : dirChanges + 1;
        return (inversions % 2 === 0)
            ? data[index % data.length]
            : data[data.length - 1 - (index % data.length)];
    }

    /**
     * Zero padding.
     */
    var ZERO_PADDING = 'zero';
    /**
     * Returns a single value of zero padding.
     * @return         Single padding value.
     */
    function zeroPadding() {
        return 0;
    }

    /**
     * Supported signal extension modes.
     */
    var PADDING_MODES = {
        antisymmetric: ANTISYMMETRIC_PADDING,
        constant: CONSTANT_PADDING,
        periodic: PERIODIC_PADDING,
        reflect: REFLECT_PADDING,
        smooth: SMOOTH_PADDING,
        symmetric: SYMMETRIC_PADDING,
        zero: ZERO_PADDING,
        modes: [
            ZERO_PADDING,
            CONSTANT_PADDING,
            SYMMETRIC_PADDING,
            PERIODIC_PADDING,
            SMOOTH_PADDING,
            REFLECT_PADDING,
            ANTISYMMETRIC_PADDING,
        ],
    };

    // SOURCE: https://github.com/PyWavelets/pywt/blob/master/pywt/_extensions/c/wavelets_coeffs.template.h
    /**
     * Haar wavelet scaling numbers.
     */
    var HaarWavelet = [
        1 / Math.SQRT2,
        1 / Math.SQRT2
    ];
    /**
     * Daubechies 2 scaling numbers.
     */
    var Db2Wavelet = [
        (1 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 + Math.sqrt(3)) / (4 * Math.SQRT2),
        (3 - Math.sqrt(3)) / (4 * Math.SQRT2),
        (1 - Math.sqrt(3)) / (4 * Math.SQRT2)
    ];
    /**
     * Daubechies 3 scaling numbers.
     */
    var Db3Wavelet = [
        3.326705529500826159985115891390056300129233992450683597084705e-01,
        8.068915093110925764944936040887134905192973949948236181650920e-01,
        4.598775021184915700951519421476167208081101774314923066433867e-01,
        -1.350110200102545886963899066993744805622198452237811919756862e-01,
        -8.544127388202666169281916918177331153619763898808662976351748e-02,
        3.522629188570953660274066471551002932775838791743161039893406e-02
    ];
    /**
     * Daubechies 4 scaling numbers.
     */
    var Db4Wavelet = [
        2.303778133088965008632911830440708500016152482483092977910968e-01,
        7.148465705529156470899219552739926037076084010993081758450110e-01,
        6.308807679298589078817163383006152202032229226771951174057473e-01,
        -2.798376941685985421141374718007538541198732022449175284003358e-02,
        -1.870348117190930840795706727890814195845441743745800912057770e-01,
        3.084138183556076362721936253495905017031482172003403341821219e-02,
        3.288301166688519973540751354924438866454194113754971259727278e-02,
        -1.059740178506903210488320852402722918109996490637641983484974e-02
    ];
    /**
     * Daubechies 5 scaling numbers.
     */
    var Db5Wavelet = [
        1.601023979741929144807237480204207336505441246250578327725699e-01,
        6.038292697971896705401193065250621075074221631016986987969283e-01,
        7.243085284377729277280712441022186407687562182320073725767335e-01,
        1.384281459013207315053971463390246973141057911739561022694652e-01,
        -2.422948870663820318625713794746163619914908080626185983913726e-01,
        -3.224486958463837464847975506213492831356498416379847225434268e-02,
        7.757149384004571352313048938860181980623099452012527983210146e-02,
        -6.241490212798274274190519112920192970763557165687607323417435e-03,
        -1.258075199908199946850973993177579294920459162609785020169232e-02,
        3.335725285473771277998183415817355747636524742305315099706428e-03
    ];
    /**
     * Daubechies 6 scaling numbers.
     */
    var Db6Wavelet = [
        1.115407433501094636213239172409234390425395919844216759082360e-01,
        4.946238903984530856772041768778555886377863828962743623531834e-01,
        7.511339080210953506789344984397316855802547833382612009730420e-01,
        3.152503517091976290859896548109263966495199235172945244404163e-01,
        -2.262646939654398200763145006609034656705401539728969940143487e-01,
        -1.297668675672619355622896058765854608452337492235814701599310e-01,
        9.750160558732304910234355253812534233983074749525514279893193e-02,
        2.752286553030572862554083950419321365738758783043454321494202e-02,
        -3.158203931748602956507908069984866905747953237314842337511464e-02,
        5.538422011614961392519183980465012206110262773864964295476524e-04,
        4.777257510945510639635975246820707050230501216581434297593254e-03,
        -1.077301085308479564852621609587200035235233609334419689818580e-03
    ];
    /**
     * Daubechies 7 scaling numbers.
     */
    var Db7Wavelet = [
        7.785205408500917901996352195789374837918305292795568438702937e-02,
        3.965393194819173065390003909368428563587151149333287401110499e-01,
        7.291320908462351199169430703392820517179660611901363782697715e-01,
        4.697822874051931224715911609744517386817913056787359532392529e-01,
        -1.439060039285649754050683622130460017952735705499084834401753e-01,
        -2.240361849938749826381404202332509644757830896773246552665095e-01,
        7.130921926683026475087657050112904822711327451412314659575113e-02,
        8.061260915108307191292248035938190585823820965629489058139218e-02,
        -3.802993693501441357959206160185803585446196938467869898283122e-02,
        -1.657454163066688065410767489170265479204504394820713705239272e-02,
        1.255099855609984061298988603418777957289474046048710038411818e-02,
        4.295779729213665211321291228197322228235350396942409742946366e-04,
        -1.801640704047490915268262912739550962585651469641090625323864e-03,
        3.537137999745202484462958363064254310959060059520040012524275e-04
    ];
    /**
     * Daubechies 8 scaling numbers.
     */
    var Db8Wavelet = [
        5.441584224310400995500940520299935503599554294733050397729280e-02,
        3.128715909142999706591623755057177219497319740370229185698712e-01,
        6.756307362972898068078007670471831499869115906336364227766759e-01,
        5.853546836542067127712655200450981944303266678053369055707175e-01,
        -1.582910525634930566738054787646630415774471154502826559735335e-02,
        -2.840155429615469265162031323741647324684350124871451793599204e-01,
        4.724845739132827703605900098258949861948011288770074644084096e-04,
        1.287474266204784588570292875097083843022601575556488795577000e-01,
        -1.736930100180754616961614886809598311413086529488394316977315e-02,
        -4.408825393079475150676372323896350189751839190110996472750391e-02,
        1.398102791739828164872293057263345144239559532934347169146368e-02,
        8.746094047405776716382743246475640180402147081140676742686747e-03,
        -4.870352993451574310422181557109824016634978512157003764736208e-03,
        -3.917403733769470462980803573237762675229350073890493724492694e-04,
        6.754494064505693663695475738792991218489630013558432103617077e-04,
        -1.174767841247695337306282316988909444086693950311503927620013e-04
    ];
    /**
     * Daubechies 9 scaling numbers.
     */
    var Db9Wavelet = [
        3.807794736387834658869765887955118448771714496278417476647192e-02,
        2.438346746125903537320415816492844155263611085609231361429088e-01,
        6.048231236901111119030768674342361708959562711896117565333713e-01,
        6.572880780513005380782126390451732140305858669245918854436034e-01,
        1.331973858250075761909549458997955536921780768433661136154346e-01,
        -2.932737832791749088064031952421987310438961628589906825725112e-01,
        -9.684078322297646051350813353769660224825458104599099679471267e-02,
        1.485407493381063801350727175060423024791258577280603060771649e-01,
        3.072568147933337921231740072037882714105805024670744781503060e-02,
        -6.763282906132997367564227482971901592578790871353739900748331e-02,
        2.509471148314519575871897499885543315176271993709633321834164e-04,
        2.236166212367909720537378270269095241855646688308853754721816e-02,
        -4.723204757751397277925707848242465405729514912627938018758526e-03,
        -4.281503682463429834496795002314531876481181811463288374860455e-03,
        1.847646883056226476619129491125677051121081359600318160732515e-03,
        2.303857635231959672052163928245421692940662052463711972260006e-04,
        -2.519631889427101369749886842878606607282181543478028214134265e-04,
        3.934732031627159948068988306589150707782477055517013507359938e-05
    ];
    /**
     * Daubechies 10 scaling numbers.
     */
    var Db10Wavelet = [
        2.667005790055555358661744877130858277192498290851289932779975e-02,
        1.881768000776914890208929736790939942702546758640393484348595e-01,
        5.272011889317255864817448279595081924981402680840223445318549e-01,
        6.884590394536035657418717825492358539771364042407339537279681e-01,
        2.811723436605774607487269984455892876243888859026150413831543e-01,
        -2.498464243273153794161018979207791000564669737132073715013121e-01,
        -1.959462743773770435042992543190981318766776476382778474396781e-01,
        1.273693403357932600826772332014009770786177480422245995563097e-01,
        9.305736460357235116035228983545273226942917998946925868063974e-02,
        -7.139414716639708714533609307605064767292611983702150917523756e-02,
        -2.945753682187581285828323760141839199388200516064948779769654e-02,
        3.321267405934100173976365318215912897978337413267096043323351e-02,
        3.606553566956169655423291417133403299517350518618994762730612e-03,
        -1.073317548333057504431811410651364448111548781143923213370333e-02,
        1.395351747052901165789318447957707567660542855688552426721117e-03,
        1.992405295185056117158742242640643211762555365514105280067936e-03,
        -6.858566949597116265613709819265714196625043336786920516211903e-04,
        -1.164668551292854509514809710258991891527461854347597362819235e-04,
        9.358867032006959133405013034222854399688456215297276443521873e-05,
        -1.326420289452124481243667531226683305749240960605829756400674e-05
    ];

    /**
     * Mapping of wavelet type keys to scaling numbers.
     */
    var ScalingNumbers = {
        'db1': HaarWavelet,
        'db2': Db2Wavelet,
        'db3': Db3Wavelet,
        'db4': Db4Wavelet,
        'db5': Db5Wavelet,
        'db6': Db6Wavelet,
        'db7': Db7Wavelet,
        'db8': Db8Wavelet,
        'db9': Db9Wavelet,
        'db10': Db10Wavelet,
        'D2': HaarWavelet,
        'D4': Db2Wavelet,
        'D6': Db3Wavelet,
        'D8': Db4Wavelet,
        'D10': Db5Wavelet,
        'D12': Db6Wavelet,
        'D14': Db7Wavelet,
        'D16': Db8Wavelet,
        'D18': Db9Wavelet,
        'D20': Db10Wavelet,
        'haar': HaarWavelet,
    };

    /**
     * Calculates the element-wise sum of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Element-wise sum.
     */
    function add(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate element-wise sum. */
        return a.map(function (value, index) { return value + b[index]; });
    }
    /**
     * Asserts if approximation and detail coefficients are valid or throws an
     * error if they are invalid.
     * @param  approx Approximation coefficients.
     * @param  detail Detail coefficients.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidApproxDetail(approx, detail) {
        /* Check if coefficients have equal length. */
        if (approx.length !== detail.length) {
            throw new Error('Approximation and detail coefficients must have equal length.');
        }
        /* Check for coefficients of zero length. */
        if (approx.length === 0) {
            throw new Error('Approximation and detail coefficients must not have zero length.');
        }
        return true;
    }
    /**
     * Asserts if coefficients are valid or throws an error if they are invalid.
     * @param  coeffs Coefficients to test.
     * @return        True if the coefficients are valid, otherwise throws an error.
     */
    function assertValidCoeffs(coeffs) {
        /* Check if at least an array of approximation coefficients is given. */
        if (coeffs.length < 1) {
            throw new Error('Invalid coefficients. Array length must not be zero.');
        }
        return true;
    }
    /**
     * Asserts if wavelet filters are valid or throws an error if they are invalid.
     * @param  filters Wavelet filters to test.
     * @return         True if the wavelet filters are valid, otherwise throws an error.
     */
    function assertValidFilters(filters) {
        /* Check if high-pass and low-pass filters have equal length. */
        if (filters.high.length !== filters.low.length) {
            throw new Error('High-pass and low-pass filters have to have equal length.');
        }
        /* Check if filter length is larger than or equal to two. */
        if (filters.low.length < 2) {
            throw new Error('Wavelet filter length has to be larger than or equal to two.');
        }
        return true;
    }
    /**
     * Determines a wavelet basis from a wavelet type or basis.
     * @param  wavelet Wavelet type or basis.
     * @return         Wavelet basis.
     */
    function basisFromWavelet(wavelet) {
        return (typeof wavelet !== 'string')
            ? wavelet
            : waveletFromScalingNumbers(ScalingNumbers[wavelet]);
    }
    /**
     * Creates an array and populates it.
     * @param  length   Length of the array.
     * @param  populate Function to populate the array.
     * @return          Populated array with specified length.
     */
    function createArray(length, populate) {
        if (populate === void 0) { populate = 0; }
        /* Check for non-integer length. */
        if (!Number.isInteger(length)) {
            throw new Error('Length has to be an integer.');
        }
        /* Check for length less than zero. */
        if (length < 0) {
            throw new Error('Length must not be smaller than zero.');
        }
        /* Create and populate array. */
        return Array.apply(null, Array(length)).map(function (_, index) {
            return (typeof populate === 'function')
                ? populate(index)
                : populate;
        });
    }
    /**
     * Calculates the dot product of two arrays.
     * @param  a First array.
     * @param  b Second array.
     * @return   Dot product.
     */
    function dot(a, b) {
        /* Check for same length of arrays. */
        if (a.length !== b.length) {
            throw new Error('Both arrays have to have the same length.');
        }
        /* Calculate dot product. */
        return a.reduce(function (dot, value, index) { return dot + value * b[index]; }, 0);
    }
    /**
     * Multiplies an array with a scalar value.
     * @param  scalar Scalar value.
     * @param  array  Array of numbers.
     * @return        Array multiplied with scalar value.
     */
    function mulScalar(scalar, array) {
        return array.map(function (value) { return scalar * value; });
    }
    /**
     * Returns a single padding element.
     * @param  data    Input data.
     * @param  index   Index of padding element.
     * @param  inverse True if the padding direction is inversed.
     * @param  mode    Signal extension mode.
     * @return         Single padding element.
     */
    function padElement(data, index, inverse, mode) {
        switch (mode) {
            case PADDING_MODES.antisymmetric:
                return antisymmetricPadding$$1(data, index, inverse);
            case PADDING_MODES.constant:
                return constantPadding(data, inverse);
            case PADDING_MODES.periodic:
                return periodicPadding(data, index, inverse);
            case PADDING_MODES.reflect:
                return reflectPadding(data, index, inverse);
            case PADDING_MODES.smooth:
                return smoothPadding(data, index, inverse);
            case PADDING_MODES.symmetric:
                return symmetricPadding(data, index, inverse);
            case PADDING_MODES.zero:
                return zeroPadding();
            default:
                throw new Error('Unknown signal extension mode: "' + mode + '"');
        }
    }
    /**
     * Determines the padding widths.
     * @param  dataLength   Length of signal.
     * @param  filterLength Length of filter.
     * @return              Padding widths.
     */
    function padWidths(dataLength, filterLength) {
        /* Check for valid data length. */
        if (dataLength <= 0) {
            throw new Error('Cannot determine padding widths for data of length less than or equal to zero.');
        }
        /* Check for valid filter length. */
        if (filterLength < 2) {
            throw new Error('Cannot determine padding widths for filter of length less than two.');
        }
        /* Determine padding widths. */
        return [
            filterLength - 2,
            ((dataLength + filterLength) % 2 === 0)
                ? filterLength - 2
                : filterLength - 1
        ];
    }
    /**
     * Determines a wavelet basis from scaling numbers.
     * @param  scalingNumbers Wavelet scaling numbers.
     * @return                Wavelet basis.
     */
    function waveletFromScalingNumbers(scalingNumbers) {
        /* Check if length is larger than or equal to two. */
        if (scalingNumbers.length < 2) {
            throw new Error('Scaling numbers length has to be larger than or equal to two.');
        }
        /* Determine wavelet numbers. */
        var waveletNumbers = scalingNumbers.slice() // Copy array
            .reverse()
            .map(function (value, index) { return (index % 2 === 0) ? value : -value; });
        /* Determine wavelet basis. */
        return {
            dec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers
            },
            rec: {
                low: scalingNumbers.slice(),
                high: waveletNumbers.slice()
            },
        };
    }

    /**
     * Default padding mode to use.
     */
    var DEFAULT_PADDING_MODE = PADDING_MODES.symmetric;
    /**
     * Collection of methods for Discrete Wavelet Transform (DWT).
     */
    var DiscreteWavelets = /** @class */ (function () {
        function DiscreteWavelets() {
        }
        /**
         * Single level Discrete Wavelet Transform.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @return         Approximation and detail coefficients as result of the transform.
         */
        DiscreteWavelets.dwt = function (data, wavelet, mode) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.dec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Add padding. */
            data = this.pad(data, padWidths(data.length, filterLength), mode);
            /* Initialize approximation and detail coefficients. */
            var approx = [];
            var detail = [];
            /* Calculate coefficients. */
            for (var offset = 0; offset + filterLength <= data.length; offset += 2) {
                /* Determine slice of values. */
                var values = data.slice(offset, offset + filterLength);
                /* Calculate approximation coefficients. */
                approx.push(dot(values, filters.low));
                /* Calculate detail coefficients. */
                detail.push(dot(values, filters.high));
            }
            /* Return approximation and detail coefficients. */
            return [approx, detail];
        };
        /**
         * Calculates the energy as sum of squares of an array of data or
         * coefficients.
         * @param  values Array of data or coefficients.
         * @return        Energy of values as the sum of squares.
         */
        DiscreteWavelets.energy = function (values) {
            var energy = 0;
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var value = values_1[_i];
                if (!Array.isArray(value))
                    energy += Math.pow(value, 2);
                else
                    energy += this.energy(value);
            }
            return energy;
        };
        /**
         * Single level inverse Discrete Wavelet Transform.
         * @param  approx  Approximation coefficients. If undefined, it will be set to an array of zeros with length equal to the detail coefficients.
         * @param  detail  Detail coefficients. If undefined, it will be set to an array of zeros with length equal to the approximation coefficients.
         * @param  wavelet Wavelet to use.
         * @return         Approximation coefficients of previous level of transform.
         */
        DiscreteWavelets.idwt = function (approx, detail, wavelet) {
            /* Fill empty array with zeros. */
            if (approx === undefined && detail !== undefined) {
                approx = createArray(detail.length, 0);
            }
            if (detail === undefined && approx !== undefined) {
                detail = createArray(approx.length, 0);
            }
            /* Check if some coefficients are undefined. */
            if (approx === undefined || detail === undefined) {
                throw new Error('Coefficients must not be undefined.');
            }
            assertValidApproxDetail(approx, detail);
            /* Determine wavelet basis and filters. */
            var waveletBasis = basisFromWavelet(wavelet);
            var filters = waveletBasis.rec;
            assertValidFilters(filters);
            var filterLength = filters.low.length;
            /* Initialize transform. */
            var coeffLength = approx.length;
            var pad = createArray(filterLength + (coeffLength - 1) * 2, 0);
            /* Perform inverse Discrete Wavelet Transform. */
            for (var i = 0; i < coeffLength; i++) {
                var offset = 2 * i;
                /* Calculate values. */
                var values = pad.slice(offset, offset + filterLength);
                values = add(values, mulScalar(approx[i], filters.low));
                values = add(values, mulScalar(detail[i], filters.high));
                /* Update values. */
                pad.splice.apply(pad, __spreadArrays([offset, filterLength], values));
            }
            /* Remove padding. */
            return pad.slice(filterLength - 2, pad.length - (filterLength - 2));
        };
        /**
         * Determines the maximum level of useful decomposition.
         * @param  dataLength Length of input data.
         * @param  wavelet    Wavelet to use.
         * @return            Maximum useful level of decomposition.
         */
        DiscreteWavelets.maxLevel = function (dataLength, wavelet) {
            /* Check for non-integer length. */
            if (!Number.isInteger(dataLength)) {
                throw new Error('Length of data is not an integer. This is not allowed.');
            }
            /* Check for invalid input. */
            if (dataLength < 0) {
                throw new Error('Data length cannot be less than zero.');
            }
            /* Return zero for data of zero length. */
            if (dataLength === 0)
                return 0;
            /* Determine wavelet basis. */
            var waveletBasis = basisFromWavelet(wavelet);
            /* Determine length of filter. */
            var filterLength = waveletBasis.dec.low.length;
            // SOURCE: https://pywavelets.readthedocs.io/en/latest/ref/dwt-discrete-wavelet-transform.html#maximum-decomposition-level-dwt-max-level-dwtn-max-level
            return Math.max(0, Math.floor(Math.log2(dataLength / (filterLength - 1))));
        };
        /**
         * Extends a signal with a given padding mode.
         * @param  data      Input data.
         * @param  padWidths Widths of padding at front and back.
         * @param  mode      Signal extension mode.
         * @return           Data with padding.
         */
        DiscreteWavelets.pad = function (data, padWidths$$1, mode) {
            /* Check for undefined data. */
            if (!data) {
                throw new Error('Cannot add padding to empty data.');
            }
            /* Initialize. */
            var front = padWidths$$1[0];
            var back = padWidths$$1[1];
            /* Add padding. */
            return createArray(front, function (index) {
                return padElement(data, (front - 1 - index), true, mode);
            })
                .concat(data)
                .concat(createArray(back, function (index) {
                return padElement(data, index, false, mode);
            }));
        };
        
        /**
         *  Expand each row of the data matrix (returned, e.g., by wavedec) with respect
         *  to the widest row. Mode specifies the interpolation function (default: 'step').
         */
        DiscreteWavelets.expand = function (data, mode) {
          var len=0,dataX=[];
          for(var row in data) len=Math.max(len,data[row].length); 
          switch (mode) {
            case 'step':
            default:
              // simple; extend each data point
              for(row in data) {
                if (data[row].length!=len) {
                  var frag=Math.floor(len/data[row].length);
                  dataX[row]=[];
                  for(var col=0; col < data[row].length; col++) {
                    dataX[row].push(Array.init(frag,data[row][col]));
                  }
                  dataX[row]=dataX[row].flat();
                } else dataX.push(data[row]);
              }
          }
          return dataX;
        };
        
        /**
         * 1D wavelet decomposition. Transforms data by calculating multi-level coefficients from
         * input data.
         * @param  data    Input data.
         * @param  wavelet Wavelet to use.
         * @param  mode    Signal extension mode.
         * @param  level   Decomposition level. Defaults to level calculated by maxLevel function.
         * @return         Coefficients as result of the transform.
         */
        DiscreteWavelets.wavedec = function (data, wavelet, mode, level) {
            if (mode === void 0) { mode = DEFAULT_PADDING_MODE; }
            /* Determine decomposition level. */
            if (level === undefined)
                level = this.maxLevel(data.length, wavelet);
            if (level < 0) {
                throw new Error('Decomposition level must not be less than zero');
            }
            /*  Initialize transform. */
            var coeffs = [];
            var approx = data;
            /* Transform. */
            for (var l = 1; l <= level; l++) {
                /* Perform single level transform. */
                var approxDetail = this.dwt(approx, wavelet, mode);
                approx = approxDetail[0];
                var detail = approxDetail[1];
                /* Prepend detail coefficients. */
                coeffs.unshift(detail);
            }
            /* Prepend last approximation. */
            // coeffs.unshift(approx);
            /* Return coefficients. */
            return coeffs.reverse();
        };
        /**
         * 1D wavelet reconstruction. Inverses a transform by calculating input data
         * from coefficients.
         * @param  coeffs  Coefficients as result of a transform.
         * @param  wavelet Wavelet to use.
         * @return         Input data as result of the inverse transform.
         */
        DiscreteWavelets.waverec = function (coeffs, wavelet) {
            /* Check if coefficients are valid. */
            assertValidCoeffs(coeffs);
            /* Determine wavelet. */
            wavelet = basisFromWavelet(wavelet);
            /* Initialize transform. */
            var approx = coeffs[0];
            /* Transform. */
            for (var i = 1; i < coeffs.length; i++) {
                /* Initialize detail coefficients. */
                var detail = coeffs[i];
                // TODO: Check if problem of different coefficient lengths because of padding can be solved in a more elegant way.
                if (approx.length === detail.length + 1) {
                    approx = approx.slice(0, approx.length - 1);
                }
                /* Calculate previous level of approximation. */
                approx = this.idwt(approx, detail, wavelet);
            }
            /* Return data. */
            return approx;
        };
        /**
         * Contains static information about the signal extension modes.
         */
        DiscreteWavelets.Modes = PADDING_MODES;
        return DiscreteWavelets;
    }());

    return DiscreteWavelets;

})));
//# sourceMappingURL=discrete-wavelets.umd.js.map
};
BundleModuleCode['plugins/math/numeric']=function (module,exports){
// https://github.com/sloisel/numeric

"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
};
BundleModuleCode['plugins/math/regression']=function (module,exports){
// https://github.com/Tom-Alexander/regression-js
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.regression = mod.exports;
  }
})(this, function (module) {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

  /**
  * Determine the coefficient of determination (r^2) of a fit from the observations
  * and predictions.
  *
  * @param {Array<Array<number>>} data - Pairs of observed x-y values
  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
  *
  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
  */
  function determinationCoefficient(data, results) {
    var predictions = [];
    var observations = [];

    data.forEach(function (d, i) {
      if (d[1] !== null) {
        observations.push(d);
        predictions.push(results[i]);
      }
    });

    var sum = observations.reduce(function (a, observation) {
      return a + observation[1];
    }, 0);
    var mean = sum / observations.length;

    var ssyy = observations.reduce(function (a, observation) {
      var difference = observation[1] - mean;
      return a + difference * difference;
    }, 0);

    var sse = observations.reduce(function (accum, observation, index) {
      var prediction = predictions[index];
      var residual = observation[1] - prediction[1];
      return accum + residual * residual;
    }, 0);

    return 1 - sse / ssyy;
  }

  /**
  * Determine the solution of a system of linear equations A * x = b using
  * Gaussian elimination.
  *
  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
  * @param {number} order - How many degrees to solve for
  *
  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
  */
  function gaussianElimination(input, order) {
    var matrix = input;
    var n = input.length - 1;
    var coefficients = [order];

    for (var i = 0; i < n; i++) {
      var maxrow = i;
      for (var j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (var k = i; k < n + 1; k++) {
        var tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (var _j = i + 1; _j < n; _j++) {
        for (var _k = n; _k >= i; _k--) {
          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
        }
      }
    }

    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
      var total = 0;
      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
        total += matrix[_k2][_j2] * coefficients[_k2];
      }

      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
    }

    return coefficients;
  }

  /**
  * Round a number to a precision, specificed in number of decimal places
  *
  * @param {number} number - The number to round
  * @param {number} precision - The number of decimal places to round to:
  *                             > 0 means decimals, < 0 means powers of 10
  *
  *
  * @return {numbr} - The number, rounded
  */
  function round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
  * The set of all fitting methods
  *
  * @namespace
  */
  var methods = {
    linear: function linear(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = 0;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          len++;
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      var run = len * sum[2] - sum[0] * sum[0];
      var rise = len * sum[3] - sum[0] * sum[1];
      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [gradient, intercept],
        r2: round(determinationCoefficient(data, points), options.precision),
        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
      };
    },
    exponential: function exponential(data, options) {
      var sum = [0, 0, 0, 0, 0, 0];

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
      var coeffA = round(a, options.precision);
      var coeffB = round(b, options.precision);
      var predict = function predict(x) {
        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    logarithmic: function logarithmic(data, options) {
      var sum = [0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      var coeffB = round(a, options.precision);
      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    power: function power(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
      var a = (sum[2] - b * sum[0]) / len;
      var coeffA = round(Math.exp(a), options.precision);
      var coeffB = round(b, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'x^' + coeffB,
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    polynomial: function polynomial(data, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var len = data.length;
      var k = options.order + 1;

      for (var i = 0; i < k; i++) {
        for (var l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        var c = [];
        for (var j = 0; j < k; j++) {
          for (var _l = 0; _l < len; _l++) {
            if (data[_l][1] !== null) {
              b += Math.pow(data[_l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      var coefficients = gaussianElimination(rhs, k).map(function (v) {
        return round(v, options.precision);
      });

      var predict = function predict(x) {
        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      var string = [];
      for (var _i = 0; _i <coefficients.length; _i++) {
        if (_i > 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*Math.pow(x,' + _i + '))');
        } else if (_i === 1 && coefficients[_i] !== 0) {
          string.push ('('+coefficients[_i] + '*x)');
        } else if (coefficients[_i] !== 0) {
          string.push('('+coefficients[_i]+')');
        }
      }
      string=string.join('+');

      return {
        string: string,
        points: points,
        predict: predict,
        equation: [].concat(_toConsumableArray(coefficients)),
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    }
  };

  function createWrapper() {
    var reduce = function reduce(accumulator, name) {
      return _extends({
        _round: round
      }, accumulator, _defineProperty({}, name, function (data, supplied) {
        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
      }));
    };

    return Object.keys(methods).reduce(reduce, {});
  }

  module.exports = createWrapper();
});
};
BundleModuleCode['plugins/math/polyfit']=function (module,exports){
// Requirement: https://github.com/sloisel/numeric/blob/master/src/numeric.js

var numeric = Require('plugins/math/numeric')

// Find the best-fit curve for an nth order polynomial.
function polyfit(xArray, yArray, order) {

  if (xArray.length <= order) console.warn("Warning: Polyfit may be poorly conditioned.")

  var xMatrix = []
  var yMatrix = numeric.transpose([yArray])

  for (var i = 0; i < xArray.length; i++) {

    var temp = []

    for (var j = 0; j <= order; j++) {

      temp.push(Math.pow(xArray[i], j))

    }

    xMatrix.push(temp)

  }

  var xMatrixT = numeric.transpose(xMatrix)

  var dot1 = numeric.dot(xMatrixT, xMatrix)
  var dot2 = numeric.dot(xMatrixT, yMatrix)

  var dotInv = numeric.inv(dot1)

  var coefficients = numeric.dot(dotInv, dot2)

  return coefficients.unwrap().reverse()

}

// Predict y given x.
function predict(x, coefficients) {

  var prediction = 0

  for (var i = 0; i < coefficients.length; i++) {

    prediction += coefficients[i] * Math.pow(x, i)

  }

  return prediction

}

// Evaluate model accuracy.
function rSquared(x, y, coefficients) {

  var regressionSquaredError = 0
  var totalSquaredError = 0

  var yMean = y.reduce((a, b) => a + b) / y.length

  for (var i = 0; i < x.length; i++) {

    regressionSquaredError += Math.pow(y[i] - predict(x[i], coefficients), 2)
    totalSquaredError += Math.pow(y[i] - yMean, 2)

  }

  return 1 - (regressionSquaredError / totalSquaredError)

}

module.exports = polyfit
};
BundleModuleCode['plugins/math/smoothers']=function (module,exports){
/*********************/
/* Helper Functions. */
/* http://madrury.github.io/smoothers */
/*********************/
var numeric = Require('plugins/math/numeric')

/* Compute the dot product of two vectors. */
var dot = function(v1, v2) {
    var s = 0;
    for(var i = 0; i < v1.length; i++) {
        s += v1[i] * v2[i];
    }
    return s
}

/* Construct a linear function given a slope and an intercept. */
var linear_function = function(m, b) {
    return function(x) {
        return b + m * x;
    }
}

/* Compute the weighted mean of x with weights w.  Weights may be
   un-normalized.
*/
var wmean = function(x, w) {
    var r = [];
    for(i = 0; i < x.length; i++) {
        r.push(x[i]*w[i]);
    }
    return r.sum() / w.sum();
}

/* The sum of squared errors of a data set when making a prediction equal
   to the mean.
*/
var sum_of_squared_errors = function(xs) {
    return xs.map(x => x - xs.mean()).map(x => x*x).reduce((a, b) => a + b, 0);
}

/* Fit a simple linear regression on data (ys, xs).

   This returns a linear function, i.e. the prediction function from the
   fit linear regression.
*/
var linear_regressor = function(xs, ys) {
    var xmean = xs.mean();
    var ymean = ys.mean();
    var xymean = (Math.zip(xs, ys).map(p => p[0]*p[1])).mean();
    var xsqmean = (Math.zip(xs, xs).map(p => p[0]*p[1])).mean();
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var intercept = ymean - beta * xmean;
    return linear_function(beta, intercept);
};

/* Simple linear regression with sample weights. */
var weighted_linear_regressor = function(xs, ys, ws) {
    var xmean = wmean(xs, ws);
    var ymean = wmean(ys, ws);
    var xymean = wmean(Math.zip(xs, ys).map(p => p[0]*p[1]), ws);
    var xsqmean = wmean(Math.zip(xs, xs).map(p => p[0]*p[1]), ws);
    var beta = (xymean - xmean * ymean) / (xsqmean - xmean * xmean);
    var betaz = ymean - beta * xmean;
    return linear_function(beta, betaz)
};

/* Given a function from numbers to numbers, return one that maps arrays to
   arrays through mapping.
*/
var vectorize = function(f) {
    return function(arr) {
        return arr.map(f)
    }
}

/* Undo a zip operation */
var unzip = function(ps, i) {
    return ps.map(p => p[i]);
}

/* Sort ordered pairs of x, y data by x. */
var sort_data = function(xs, ys) {
    var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
    var xsort = unzip(psort, 0);
    var ysort = unzip(psort, 1);
    return [xsort, ysort];
}


/*******************************************/
/* Ridge Regression with Basis Expansions. */
/*******************************************/

/* Fit a ridge regression to data X and response ys with regularization
   strength lambda.

   This returns an object containing the data needed to score the fitted
   regression:
   
   {
       "betas": <array of standardized parameter estiamtes>,
       "Xsd": <standardizer data for X>,
       "ysd": <standardizer data for y>
   }
*/
var fit_ridge_regression = function(X, ys, lambda) {
    /* Construct a square matrix of size n with lambdas along the main
       diagonal, and a zero in the (0, 0) position.  This type of matrix is
       useful in ridge regression.
    */
    var make_ridge_shrinkage_matrix = function(n, lambda) {
        var shrink_matrix = numeric.diag(numeric.rep([n + 1], lambda));
        /* Dont shrink the linear term in basis expansion regressions. */
        shrink_matrix[0][0] = 0;
        return shrink_matrix
    }

    /* Compute the translation and scale factors necessary to standardize the
      columns of a matrix.

      This returns an object with two attributes:

      { "mean": [<array of translation factors>],
        "sd": [<array of scale factors>] }
    */
    var compute_matrix_standardization = function(X) {
        var standardization = {"mean": [], "sd": []};
        /* It is easier to iterate over the rows of a matrix than the columns. */
        var Xt = numeric.transpose(X);
        for(var i = 0; i < Xt.length; i++) {
            var standardized_row = compute_vector_standardization(Xt[i]);
            standardization.mean.push(standardized_row.mean);
            standardization.sd.push(standardized_row.sd);
        }
        return standardization;
    }

    /* Compute the translation and scale factor necessary to standardize a
      vector.

      This returns an object with two attributes:

      {"mean": <mean of vector>, "sd": <standard deviation of vector>}
    */
    var compute_vector_standardization = function(v) {
        var mean = v.mean();
        var sd = Math.deviation(v);
        return {'mean': mean, 'sd': sd}
    }

    var X_standardization = compute_matrix_standardization(X);
    var Xsd = standardize_matrix(X, X_standardization);
    var y_standardization = compute_vector_standardization(ys);
    var ysd = standardize_vector(ys, y_standardization);
    // Compute the regression.
    var Xsdt = numeric.transpose(Xsd);
    var XtX = numeric.dot(Xsdt, Xsd);
    var Xty = numeric.dot(Xsdt, ysd);
    var shrink_matrix = make_ridge_shrinkage_matrix(X[0].length, lambda);
    var betas = numeric.solve(numeric.add(XtX, shrink_matrix), Xty);

    return {
        "betas": betas,
        "Xsd": X_standardization,
        "ysd": y_standardization
    }
}

/* Apply standardization data to a matrix.  Returns a standardized version
   of the matrix, i.e. a matrix with standardized columns.
*/
var standardize_matrix = function(X, standardization) {
    /* It is easier to iterate over the rows of a matrix than the columns. */
    var Xt = numeric.transpose(X);
    var S = []
    for(var i = 0; i < Xt.length; i++) {
        var row_standardization = {
            "mean": standardization.mean[i],
            "sd": standardization.sd[i]
        };
        var standardized_row = standardize_vector(Xt[i], row_standardization);
        S.push(standardized_row);
    }
    return numeric.transpose(S);
}

/* Apply standardization data to a vector. */
var standardize_vector = function(v, standardization) {
    return v.map(x => (x - standardization.mean) / standardization.sd)
}


/* Basies for fitting basis expansion models. 

   A basis is a linearly independent sequence of functions [f_1, f_2, ..., f_k].
   A basis expansion is a transformation of a vector v into a matrix..  The
   columns of the basis expanded matrix are created by mapping each of the
   functions in the basis expansion over the vector in turn.
*/
var basies = {

    /* Polynomial basis expansion.

         x -> [1, x, x^2, ...]
    */
    polynomial_basis: function(d) {
        var basis = [];
        function push(i) {
          basis.push(function (x) { return  Math.pow(x, i) })
        }
        for(var i = 1; i <= d; i++) {
          push(i)
        }
        return basis;
    },

    /* Piecewise linear spline basis.

       This basis depends on a sequence of knots: k_1, k_2, ...
       The basis expansion is given by the sequence of functions
       x -> max(0, x - k_i).

       Models fit using a PL basis expansion as predictors result in piecewise
       linear prediction functions.
    */
    pl_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        function push(i) {
          basis.push(function (x) { return  Math.max(x - knots[i], 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis;
    },

    /* Quadratic spline basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a quadratic spline basis expansion as predictors reult
       in a peicewise quadratic prediction function.
    */ 
    quadratic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        function push(i) {
          basis.push(function (x) { return  Math.pow(x - knots[i], 2)*((x - knots[i]) >= 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a cubic spline basis expansion as predictors reult
       in a peicewise cubic prediction function.
    */ 
    cubic_spline_basis: function(knots) {
        var basis = [];
        basis.push(x => x);
        basis.push(x => x*x);
        basis.push(x => x*x*x);
        function push(i) {
          basis.push(function (x) { return  Math.max(Math.pow(x - knots[i], 3), 0) })
        }
        for(var i = 0; i < knots.length; i++) {
          push(i)
        }
        return basis
    },

    /* Natural cubic spline (unrestricted) basis function.

       This basis depends on a sequence of knots: k_1, k_2, ...

       Models fit with a natural cubic spline basis expansion as predictors
       reult in a peicewise cubic prediction function, but with the extra
       feature that the function is linear outside of the leftmost and
       rightmost knots.
    */ 
    natural_cubic_spline_basis: function(knots) {
        n_knots = knots.length;
        var basis = [];
        basis.push(x => x);
        var ppart = (t => Math.max(t, 0))
        var cube = (t => t*t*t);
        var d = function(knot_idx) {
            return function(x) {
                return (
                    // Sure would be nice if this was scheme.
                    (cube(ppart(x - knots[knot_idx], 0)) 
                        - cube(ppart(x - knots[n_knots - 1], 0)))
                    / (knots[n_knots - 1] - knots[knot_idx]));
            };
        };
        function push(k) {
          basis.push(function (x) { return  d(k)(x) - d(n_knots - 2)(x) })
        }
        for(var k = 0; k < n_knots - 2; k++) {
          push(k)
        }
        return basis
    }
}

/* Construct a regression operator given a basis of functions, and a
   regularization strength.

   This constructs a function witht he following signature:
       (xs, ys) => (x => _)
   I.e. a function that consumes data, and returns a prediction function.
   The prediction function is constructed by fitting a ridge regression
   on the data (xs, ys) after applying the given basis expansion.
*/
var make_basis_expansion_regression = function(basis, lambda) {
    /* Map a basis expansion across a vector. The result is a vector. */
    var evaluate_basis_expansion = function(basis, xs) {
        return xs.map(x => basis.map(s => s(x)))
    }

    return function(xs, ys) {
        var X = evaluate_basis_expansion(basis, xs);
        var ridge = fit_ridge_regression(X, ys, lambda);
        var smooth_value = function(newx) {
            // There is a small hack here.  After getting the basis
            // expansion, we have a vector.  We immediately wrap this in a
            // list, creating a one row matrix.  This allows us to use
            // standardize_matrix, avoiding duplication of some logic.
            var basis_expansion = [basis.map(s => s(newx))]
            var standardized_basis_expansion = 
                standardize_matrix(basis_expansion, ridge.Xsd)[0];

            return (
                numeric.dot(ridge.betas, standardized_basis_expansion) * ridge.ysd.sd
                + ridge.ysd.mean); 
        }
        return Object.assign(vectorize(smooth_value),{parameter:ridge});
    };
}

/* Consume a basis expansion representing a spline basis, and return a function
   that consumes a object of parameters (the only parameter being the number of
   knots), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_spline_regression = function(spline_basis_function) {

    return function(parameters) {
        var n = Number(parameters["n"]);
        var knots = make_knots(n);
        var sp = spline_basis_function(knots);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(sp, lambda);
    }
}

/* Make a set of equally spaced knots in the interval [0, 1] */
var make_knots = function(n) {
    return numeric.linspace(0, 1, n + 2).slice(1, n + 1);
}

/* Consume a basis expansion representing a polynomial basis, and return a
   function that consumes a object of parameters (the only parameter being the
   degree), and returns a basis expansion regression (See definition above).

   I.e., the signature of this function is:

   basis => (parameters => ((xs, ys) => (x => _)))
*/
var make_polynomial_regression = function(polynomial_basis_function) {
    return function(parameters) {
        var d = Number(parameters["degree"]);
        var p = polynomial_basis_function(d);
        var lambda = Number(parameters["lambda"]);
        return make_basis_expansion_regression(p, lambda);
    }
}


/********************/
/* Regression Trees */
/********************/

/* Construct a function that fits regression trees of a specified depth.

   Returns a function ((xs, ys) => (x => _)) that fits a regression tree
   to the supplied xs, ys data.
*/
var make_regression_tree = function(parameters) {
    var depth = Number(parameters["depth"]);
    return function(xs, ys) {
        /* We sort the data once up front, it will stay sorted as we
           decend the tree.
        */
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var tree = fit_regression_tree(xsorted, ysorted, depth);
        var regression_tree_predict_pointwise = function(x) {
            return score_regression_tree(x, tree);
        }
        var fs = vectorize(regression_tree_predict_pointwise);
        fs.tree=tree;
        return fs;
    }
}

/* Fit a regression tree to data of a specified depth.

   Returns a simple object (informally of type tree) representing a fit
   regression tree.  A tree object has the following shape.

    {
        "is_leaf": <boolean: is this tree a lead node?>,
        "value": <float: The value to predict in this node, if a leaf>,
        "left_child_condition": <function: f(x) answers "is x in the reigon
                                 defined by the left child node>
        "left_child": <tree: A fit regression tree to those xs, ys in the left
                       child>,
        "right_child": <tree: A fit regression tree to those xs, ys in the
                        right child>,
    }

    The field "value" is only defined for leaf nodes.  The fields
    "left_child_condition", "left_child", and "right_child" are only defined if
    *not* a lead node.
*/
var fit_regression_tree = function(xs, ys, depth) {
    if(depth === 0 || ys.length <= 1) {
        /* Base case step. */
        var tree = make_tree_object();
        tree.is_leaf = true;
        tree.value = ys.mean();
        return tree;
    } else {
        /* Recursive step. */
        var split = compute_split_point(xs, ys);
        var condition = function(x) {return x <= split}
        var ps = Math.zip(xs, ys);
        var left_data = ps.filter(p => condition(p[0]));
        var right_data = ps.filter(p => !condition(p[0]));
        /* Construct and return the tree */
        var tree = make_tree_object();
        tree.left_child_condition = condition;
        tree.left_child = fit_regression_tree(
            unzip(left_data, 0), unzip(left_data, 1), depth - 1);
        tree.right_child = fit_regression_tree(
            unzip(right_data, 0), unzip(right_data, 1), depth - 1);
        return tree;
    }
}


/* Construct an empty tree object. */
var make_tree_object = function() {
    return {
        "is_leaf": false,
        "left_child_condition": null,
        "left_child": null,
        "right_child": null,
        "value": null
    }
}

/* Compute the optimal split point in data xs, ys.

   The split point is the midpoint between two data points, so that grouping
   the ys data into those left of and right of the split point produces the
   least total varaince.

   Note: This function assumes that the xs, ys data is sorted in increasing
         xs order.
*/
var compute_split_point = function(xs, ys) {
    var best_sosd = Infinity;
    var best_split = null;
    for(var i = 1; i <= ys.length - 1; i++) {
        var left_ys = ys.slice(0, i);
        var right_ys = ys.slice(i, ys.length);
        var this_sosd = sum_of_squared_errors(left_ys) + 
                        sum_of_squared_errors(right_ys);
        if(this_sosd <= best_sosd) {
            best_sosd  = this_sosd;
            best_split = (xs[i-1] + xs[i]) / 2;
        }
    }
    return best_split;
}

/* Generate a predictor from a regression tree at a point x */
var score_regression_tree = function(x, tree) {
    if(tree.is_leaf == true) {
        return tree.value;
    } else {
        if(tree.left_child_condition(x)) {
            return score_regression_tree(x, tree.left_child);
        } else {
            return score_regression_tree(x, tree.right_child);
        }
    }
}


/*********************/
/* Gradient Boosting */
/*********************/

/* Construct a function that fits a gradient boosted regression.

   Returns a function ((xs, ys) => (x => _)) that fits a gradient booster
   to the supplied xs, ys data.
*/
var make_boosted_model = function(parameters) {
    var learning_rate = Number(parameters["learning_rate"]);
    var n_trees = Number(parameters["n_trees"]);
    var tree_depth = Number(parameters["tree_depth"]);
    return function(xs, ys) {
        var xysorted = sort_data(xs, ys), xsorted = xysorted[0], ysorted = xysorted[1];
        var booster = fit_boosted_model(xs, ys, n_trees, learning_rate, tree_depth);
        var boosted_model_predict_pointwise = function(x) {
            return score_boosted_model(x, booster);
        }
        return vectorize(boosted_model_predict_pointwise);
    }
}

/* Fit a gradient boosted regression to data of a specified depth.

   Returns a simple object (informally of type booster) representing a fit
   boosted model.  A booster object has the following shape.

   {
       "intercept": <The mean of the training data, used as the 0'th
                     boosting stage>,
       "trees": [<Array of tree objects, the boosting stages>],
       "learning_rate": <The learning rate of the boosted model>
   }
*/
var fit_boosted_model = function(xs, ys, n_trees, learning_rate, tree_depth) {
    var boosted_model = new_boosted_model();
    boosted_model.learning_rate = learning_rate;
    var working_ys = ys.slice(); // Copy.
    /* Fit the first stage */
    boosted_model.intercept = ys.mean();
    working_ys = working_ys.map(y => y - boosted_model.intercept);
    /* Boost */
    for(var i = 0; i <= n_trees; i++) {
        var tree = fit_regression_tree(xs, working_ys, tree_depth);
        working_ys = 
            Math.zip(xs, working_ys)
              .map(p => p[1] - learning_rate * score_regression_tree(p[0], tree));
        boosted_model.trees.push(tree);
    }
    return boosted_model;
}

/* Construct a booster object. */
var new_boosted_model = function() {
    return {"intercept": null, "trees": [], "learning_rate": null};
}

/* Make predictions on a new datapoint from a booster object. */
var score_boosted_model = function(x, booster) {
    var y_hat = booster.intercept;
    for(var i = 0; i < booster.trees.length; i++) {
        y_hat += booster.learning_rate * score_regression_tree(x, booster.trees[i]);
    }
    return y_hat;
}

/************************/
/* Smoothing Algorithms */
/************************/

/* A namespace for scatterplot smoother objects.

  Each smoother object has three attributes:

    - label: A short description of the smoother.  Appears in a select input
      field.
    - smoother: A smoother function.  Each smoother function has the form

          parameters => ((xs, ys) => (x => _))

      where parameters is a dictionary containing the values of huperparameters
      for the smoother, and xs, ys are equal length vectors of x-coordinates
      and y-coordinates of data points to be smoothed.
    - parameters: Configuration objects for hyperparameters.  These are used
      to populate input slider elements in the user interface.
*/
var smoothers = {

    /* Trivial global mean smoother.

    Simply return the mean of the y values as the smoothed data.

    Hyperparamters: None
    */
    "smooth-type-mean": {

        "label": "Constant Mean",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var mean = ys.mean();
                return vectorize(x => mean)
            }
        },

        "parameters": []
    },

    /* Running mean smoother. 

    The smoothed value y at a given x is the mean value of the y data for
    those data with the closest k x data.

    Hyperparameters:
        k: Number of data points included in each side of the symmetric nbhd.
    */
    "smooth-type-runmean": {

        "label": "Running Mean",
    
        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var xysorted = sort_data(xs, ys), xsort = xysorted[0], ysort = xysorted[1];
                var mean_of_symm_nbrd = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length - 1, pos_in_array + k)
                    ];
                    return (ysort.slice(cutoffs[0], cutoffs[1])).mean();
                };
                return vectorize(mean_of_symm_nbrd);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 1, "max": 20, "step": 1, "default": 2}
        ]
    },

    /* Simple linear regression smoother. 
    
    Hyperparameters:
        None.
    */
    "smooth-type-linreg": {

        "label": "Linear Regression",

        "smoother": function(parameters) {
            return function(xs, ys) {
                var linreg = linear_regressor(xs, ys);
                return vectorize(linreg);
            };
        },

        "parameters": []

    },

    /* Gaussian kernel smoother.

    Hyperparmeters:
        lambda: Width of the gaussian kernel.
    */
    "smooth-type-gaussk": {

        "label": "Gaussian Kernel Smoother",

        "smoother": function(parameters) {
            var lambda = Number(parameters["lambda"]);
            return function(xs, ys) {
                var gauss_kern_smooth = function(x) {
                    var ds = xs.map(function(xi) {return x - xi;});
                    var ws = ds.map(function(di) {return Math.exp(-di*di/lambda);});
                    var normc = ws.sum(); 
                    var normws = ws.map(function(wi) {return wi / normc;});
                    return (Math.zip(normws, ys).map(function(p) {return p[0]*p[1]})).sum();
                };
                return vectorize(gauss_kern_smooth)
            };
        },

        "parameters": [
            {"label": "Width of Kernel", "name": "lambda",
             "min": .001, "max": .05, "step": .001, "default": .01}
        ]

    },

    /* Running line smoother.

       To calculate the smoothed value of y at a given x, we first take
       together the k data points closest to x.  Then fit a simple linear
       regression to these k data points.  The smoothed value of y is the value
       f(x), where f is the prediction function of this linear regression.

    Hyperparameters:
        k: The number of neighbours to consider when fitting the local linear
           regressions.
    */
    "smooth-type-runline": {

        "label": "Running Line",

        "smoother": function(parameters) {
            var k = Number(parameters["k"]);
            return function(xs, ys) {
                // Reorder xs and ys so that xs is in increasing order
                var psort = Math.zip(xs, ys).sort(function(a, b) {return a[0] - b[0]});
                var xsort = psort.map(function(p) {return p[0]});
                var ysort = psort.map(function(p) {return p[1]});
                var loc_lin_approx = function(newx) {
                    var pos_in_array = d3.bisect(xsort, newx);
                    // TODO: Check that you lined up the fenceposts.
                    var cutoffs = [
                        Math.max(0, pos_in_array - k), 
                        Math.min(xsort.length, pos_in_array + k)
                    ];
                    var locx =  xsort.slice(cutoffs[0], cutoffs[1]);
                    var locy =  ysort.slice(cutoffs[0], cutoffs[1]);
                    return linear_regressor(locx, locy)(newx);
                }
                return vectorize(loc_lin_approx);
            };
        },

        "parameters": [
            {"label": "Number of Neighbors", "name": "k",
             "min": 2, "max": 20, "step": 1, "default": 2}
        ]

    },

    /* Ridge regression with a polynomial basis expansion.

    Hyperparameters:
        degree: The maximum degree of polynomial in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-polyreg": {
    
        "label": "Polynomial Ridge Regression",

        "smoother": make_polynomial_regression(basies.polynomial_basis),

        "parameters": [
            {"label": "Polynomial Degree", "name": "degree",
             "min": 1, "max": 20, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ]

    },

    /* Ridge regression with a piecewise linear basis expansion.

    Hyperparameters:
        n: The number of knots to use in the PL basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-pl": {

        "label": "Piecewise Linear Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.pl_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .1, "step": .0001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise quadratic basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
     */
    "smooth-type-quad": {

        "label": "Quadratic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.quadratic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .01, "step": .00001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a piecewise cubic (unrestricted) basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-spline": {

        "label": "Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 2},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Ridge regression with a natural cubic spline basis expansion.

    Hyperparameters:
        n: The number of knots to use in the basis.
        lambda: The ridge regularization strength.
    */
    "smooth-type-natural-spline": {

        "label": "Natural Cubic Spline (Fixed Knots)",

        "smoother": make_spline_regression(basies.natural_cubic_spline_basis),

        "parameters": [
            {"label": "Number of Knots", "name": "n",
             "min": 2, "max": 10, "step": 1, "default": 3},
            {"label": "Ridge Shrinkage", "name": "lambda",
             "min": 0, "max": .001, "step": .000001, "default": 0}
        ],

        "knot_function": make_knots
    },

    /* Regression tree smoother.

    Hyperparameters:
        depth: The maximum depth in the fit tree.  The final tree has 2**depth
               leaf nodes.
    */
    "smooth-type-regression-tree": {
    
        "label": "Regression Tree",

        "smoother": make_regression_tree,

        "parameters": [
            {"label": "Maximum Tree Depth", "name": "depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },

    /* Gradient boosting to minimize the sum of squared errors.

    Hyperparameters:
        n_trees: The number of boosting stages.
        learning_rate: Learning rate.
        tree_depth: The maximum depth of the individual trees.
    */
    "smooth-type-boosting": {
    
        "label": "Gradient Boosting Regression",

        "smoother": make_boosted_model,

        "parameters": [
            {"label": "Number of Boosting Stages", "name": "n_trees",
             "min": 0, "max": 250, "step": 1, "default": 5},
            {"label": "Learning Rate", "name": "learning_rate",
             "min": 0, "max": 1, "step": 0.01, "default": 0.05},
            {"label": "Maximum Tree Depth", "name": "tree_depth",
             "min": 0, "max": 7, "step": 1, "default": 1}
        ]
    },
/*
    // Locally weighted linear regression smoother.
    "smooth-type-loess": function(xs, ys) {
        var k = 5
        var loess = function(x) {
            // Sort by increasing absolute distance from x.
            var psort = d3.zip(xs, ys).sort(function(a, b) {
                return Math.abs(x - a[0]) - Math.abs(x - b[0])}
            );
            var xsort = psort.map(function(p) {return p[0]}).slice(0, 7);
            var ysort = psort.map(function(p) {return p[1]}).slice(0, 7);
            var nearest_nbrs = psort.slice(0, 7);
            var ds = nearest_nbrs.map(function(p) {return Math.abs(p[0] - x)});
            var dsmax = d3.max(ds);
            var ws = ds.map(function(d) {
                return Math.pow(1 - d*d*d, 3) / (dsmax * dsmax * dsmax)
            });
            return weighted_linear_regressor(xsort, ysort, ws)(x);
        };
        return vectorize(loess)
    },
*/
};

// fourier-polynomial.js
//
// A class modeling a fourier polynomial (finite degree).

var FourierPolynomial = function(cs) {
  
  var _coefs = cs

  return {
  
    get degree() {
      return _coefs.length - 1
    },

    // The maximum possible value obtained by the polynomial
    get pmax() {
      var s, i
      s = 0
      for(i = 0; i < _coefs.length; i++) {
        s += Math.abs(_coefs[i])
      }
      return s
    },

    // Evaluate the polynomial at a number after shifting by a given 
    // phase.
    _eval: function(x, phase) {
      var acc, i
      phase = phase || 0
      acc = 0
      for(i = 0; i <= this.degree; i++) {
        acc += _coefs[i] * Math.sin(2 * i * Math.PI * (x - phase))
      }
      return acc
    },

    // Evaluate teh polynomial at an array after shifting a given 
    // pahse.
    eval: function(xs, phase) {
      that = this
      var ys = xs.map(function(x) {return that._eval(x, phase)})
      that = null // Destruct
      return ys
    },

  }
}

var _runif = function(low, high) {
    return (high - low) * Math.random() + low
}

var randomPolynomial = function(degree) {
    var coefs = []
    for(var i = 0; i <= degree; i++) {
        coefs.push(_runif(-1, 1))
    }
    //coefs = coefs.sort(function(a, b) {return b - a})
    console.log(coefs)
    return new FourierPolynomial(coefs)
}

module.exports = smoothers;

};
BundleModuleCode['plugins/ml/reg']=function (module,exports){
/* https://github.com/chen0040/js-regression */
var jsregression = jsregression || {};

(function (jsr) {
    'use strict';
	var LinearRegression = function (config) {
        config = config || {};
        
        if (!config.iterations) {
            config.iterations = 1000;
        }
        if (!config.alpha) {
            config.alpha = 0.001;
        }
        if (!config.lambda) {
            config.lambda = 0.0;
        }
        if(!config.trace) {
            config.trace = false;
        }
        
        this.iterations = config.iterations;
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.costThres = config.cost||0;
        this.errorThres = config.error||0;
        this.trace = config.trace;
        this.dynamic = config.dynamic;  // dynamic alpha rate
    };
    
    LinearRegression.prototype.fit = function (data) {
        var N = data.length, X = [], Y = [];
        this.dim = data[0].length;

    
        for (var i=0; i < N; ++i) {
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j) {
                x_i.push(row[j]);
            }
            Y.push(y_i);
            X.push(x_i);
        }
        
        this.theta = [];
        
        for (var d = 0; d < this.dim; ++d) {
            this.theta.push(0.0);
        }
        
        var cost,lastCost=0, lastVx, lastTheta, alpha=this.alpha;
        for (var k = 0; k < this.iterations; ++k) {
            var Vx = this.grad(X, Y, this.theta);
            
            for(var d = 0; d < this.dim; ++d) {
                this.theta[d] = this.theta[d] - alpha * Vx[d];
                if (isNaN(this.theta[d])) 
                 throw Error ('LinearRegression.fit: parameter overflow, probably alpha rate to high! (alpha:'+alpha+', step:'+k+')')
            }
            
            if (this.errorThres && this.error(X,Y,this.theta) < this.errorThres) break;
            if (this.costThres && this.cost(X,Y,this.theta) < this.costThres) break;
            if (this.dynamic) {
              // experimental dynamic aloha rate adaptation
              if (lastVx) {
                var gMax=0, gradVx = lastVx.map(function (vx,index) {
                  var g = Math.abs(Vx[index]/vx);
                  gMax = Math.max(gMax,g)
                  return g
                })
                // if some gradVx > XX then lower alpha
                if (gMax > 2) {
                  alpha /= 2;
                } else if (gMax < 1 && (1-gMax) < 0.01) alpha *= 2;
              }
              lastVx = Vx.slice();
              lastTheta = this.theta.slice();
              // console.log(alpha,Vx);
            }
            if(this.trace) {
                console.log('theta: ',this.theta)
                console.log('cost at iteration ' + k + ': ' + cost+' alpha:'+alpha);
            }
        }
        
        return {
            theta: this.theta,
            dim: this.dim,
            cost: this.cost(X, Y, this.theta),
            error: this.error(X, Y, this.theta),
            iterations : k,
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        };
    };
    
    LinearRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        
        var Vtheta = [];
        
        for(var d = 0; d < this.dim; ++d){
            var g = 0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var y_i = Y[i];
                
                var predicted = this.h(x_i, theta);
                
                g += (predicted - y_i) * x_i[d];  
            }
            
            g = (g + this.lambda * theta[d]) / N;
            
            Vtheta.push(g);
        }
        
        return Vtheta;
    };
    
    LinearRegression.prototype.h = function(x_i, theta) {
        var predicted = 0.0;
        for(var d = 0; d < this.dim; ++d) {
            predicted += x_i[d] * theta[d];
        }
        return predicted;
    }
    
    LinearRegression.prototype.cost = function(X, Y, theta) {
      
        var N = X.length;
        var cost = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            cost += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        for(var d = 0; d < this.dim; ++d) {
            cost += this.lambda * theta[d] * theta[d];
        }
        
        return cost / (2.0 * N);
    };

    LinearRegression.prototype.error = function(X, Y, theta) {
      
        var N = X.length;
        var err = 0;
        for(var i = 0; i < N; ++i){
            var x_i = X[i];
            var predicted = this.h(x_i, theta);
            err += (predicted - Y[i]) * (predicted - Y[i]);
        }
        
        
        return err / (N);
    };
    
    LinearRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        // x is a row vector
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    };

    LinearRegression.prototype.toFunction = function () {
      var self=this, foo;
      var fcode = 'foo=function (x) { return '
      fcode += (self.theta.map(function (p,index) {
        var xx=[]; for (var i=0;i<index;i++) xx.push('x');
        return self.theta[index]+(xx.length?'*'+xx.join('*'):'');
      }).join('+'))
      fcode += '}';
      eval(fcode);
      return foo
    }
    
    jsr.LinearRegression = LinearRegression;
    
    var LogisticRegression = function(config) {
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    }
    
    LogisticRegression.prototype.fit = function(data) {
        this.dim = data[0].length;
        var N = data.length;
        
        var X = [];
        var Y = [];
        for(var i=0; i < N; ++i){
            var row = data[i];
            var x_i = [];
            var y_i = row[row.length-1];
            x_i.push(1.0);
            for(var j=0; j < row.length-1; ++j){
                x_i.push(row[j]);
            }
            X.push(x_i);
            Y.push(y_i);
        }
        
        this.theta = [];
        for(var d = 0; d < this.dim; ++d){
            this.theta.push(0.0);
        }
        
        for(var iter = 0; iter < this.iterations; ++iter){
            var theta_delta = this.grad(X, Y, this.theta);
            for(var d = 0; d < this.dim; ++d){
                this.theta[d] = this.theta[d] - this.alpha * theta_delta[d];        
            }
        }
        
        this.threshold = this.computeThreshold(X, Y);
        
        return {
            theta: this.theta,
            threshold: this.threshold,
            cost: this.cost(X, Y, this.theta),
            config: {
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations 
            }
        }
    };
    
    LogisticRegression.prototype.computeThreshold = function(X, Y){
        var threshold=1.0, N = X.length;
        
        for (var i = 0; i < N; ++i) {
            var prob = this.transform(X[i]);
            if(Y[i] == 1 && threshold > prob){
                threshold = prob;
            }
        }
        
        return threshold;
    }
    
    LogisticRegression.prototype.grad = function(X, Y, theta) {
        var N = X.length;
        var Vx = [];
        for(var d = 0; d < this.dim; ++d) {
            var sum = 0.0;
            for(var i = 0; i < N; ++i){
                var x_i = X[i];
                var predicted = this.h(x_i, theta);
                sum += ((predicted - Y[i]) * x_i[d] + this.lambda * theta[d]) / N;
            }    
            Vx.push(sum);
        }
        
        return Vx;
        
    }
    
    LogisticRegression.prototype.h = function(x_i, theta) {
        var gx = 0.0;
        for(var d = 0; d < this.dim; ++d){
            gx += theta[d] * x_i[d];
        }
        return 1.0 / (1.0 + Math.exp(-gx));
    }
    
    LogisticRegression.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        var x_i = [];
        x_i.push(1.0);
        for(var j=0; j < x.length; ++j){
            x_i.push(x[j]);
        }
        return this.h(x_i, this.theta);
    }
    
    LogisticRegression.prototype.cost = function(X, Y, theta) {
        var N = X.length;
        var sum = 0;
        for(var i = 0; i < N; ++i){
            var y_i = Y[i];
            var x_i = X[i];
            sum += - (y_i * Math.log(this.h(x_i, theta)) + (1-y_i) * Math.log(1 - this.h(x_i, theta))) / N;
        }
        
        for(var d = 0; d < this.dim; ++d) {
            sum += (this.lambda * theta[d] * theta[d]) / (2.0 * N);
        }
        return sum;
    };
    
    jsr.LogisticRegression = LogisticRegression;
    
    var MultiClassLogistic = function(config){
        var config = config || {};
        if(!config.alpha){
            config.alpha = 0.001;
        }
        if(!config.iterations) {
            config.iterations = 100;
        }
        if(!config.lambda) {
            config.lambda = 0;
        }
        this.alpha = config.alpha;
        this.lambda = config.lambda;
        this.iterations = config.iterations;
    };
    
    MultiClassLogistic.prototype.fit = function(data, classes) {
        this.dim = data[0].length;
        var N = data.length;
        
        if(!classes){
            classes = [];
            for(var i=0; i < N; ++i){
                var found = false;
                var label = data[i][this.dim-1];
                for(var j=0; j < classes.length; ++j){
                    if(label == classes[j]){
                        found = true;
                        break;
                    }
                }
                if(!found){
                    classes.push(label);
                }
            }
        }
        
        this.classes = classes;
        
        this.logistics = {};
        var result = {};
        for(var k = 0; k < this.classes.length; ++k){
            var c = this.classes[k];
            this.logistics[c] = new jsr.LogisticRegression({
                alpha: this.alpha,
                lambda: this.lambda,
                iterations: this.iterations
            });
            var data_c = [];
            for(var i=0; i < N; ++i){
                var row = [];
                for(var j=0; j < this.dim-1; ++j){
                    row.push(data[i][j]);
                }
                row.push(data[i][this.dim-1] == c ? 1 : 0);
                data_c.push(row);
            }
            result[c] = this.logistics[c].fit(data_c);
        }
        return result;
    };
    
    MultiClassLogistic.prototype.transform = function(x) {
        if(x[0].length){ // x is a matrix            
            var predicted_array = [];
            for(var i=0; i < x.length; ++i){
                var predicted = this.transform(x[i]);
                predicted_array.push(predicted);
            }
            return predicted_array;
        }
        
        
        
        var max_prob = 0.0;
        var best_c = '';
        for(var k = 0; k < this.classes.length; ++k) {
            var c = this.classes[k];
            var prob_c = this.logistics[c].transform(x);
            if(max_prob < prob_c){
                max_prob = prob_c;
                best_c = c;
            }
        }
        
        return best_c;
    }
    
    
    
    jsr.MultiClassLogistic = MultiClassLogistic;

})(jsregression);

var module = module || {};
if(module) {
	module.exports = jsregression;
}
};
BundleModuleCode['plugins/math/data-bin']=function (module,exports){
// https://github.com/mhyfritz/bin-data

// included from https://github.com/d3/d3-array/tree/main/src
var pickRepresentatives = {
  max:function max(values, valueof) {
    var max;
    if (valueof === undefined) {
      for (const value of values) {
        if (value != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    }
    return max;
  },
  mean:function mean(values, valueof) {
    var count = 0;
    var sum = 0;
    if (valueof === undefined) {
      for (var value of values) {
        if (value != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    }
    if (count) return sum / count;
  },
  min:function min(values, valueof) {
    var min;
    if (valueof === undefined) {
      for (var value of values) {
        if (value != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    } else {
      var index = -1;
      for (var value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    }
    return min;
  }
}
function bin(data, numChunks, pickRepresentative ) {
  if (typeof pickRepresentative=='string') pickRepresentative=pickRepresentatives[pickRepresentative];
  pickRepresentative=pickRepresentative|| pickRepresentatives.max
  if (!Array.isArray(data)) {
    data = Array.from(data);
  }

  var chunks = chunk(data, numChunks);
  return chunks.map(chunk => pickRepresentative(chunk.data));
}

function chunk(data, numChunks) {
  var chunks = new Array(numChunks);
  var binSize = data.length / numChunks;

  for (var i = 0, start = 0, end = 0; i < numChunks; i += 1) {
    end = Math.round((i + 1) * binSize);
    var slice = data.slice(start, end);
    chunks[i] = {
      start,
      end: end - 1,
      data: slice
    };
    start = end;
  }

  return chunks;
}

module.exports = bin;
};
BundleModuleCode['plugins/math/matja']=function (module,exports){
// MatLab math compatibility and related extensions
Math.gaussian = function (x,pos,wid) {
  if(typeof(x)==='number' && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //numerator
    var num = Math.pow((x-pos),2)
    //Divison
    var res = num/den;
    //Exponent of total result
    var result = Math.exp(-res)
    return result;
  }
  else if(Utils.isArrayArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function (row) { return  row.map(function (element) { return  element - pos})});
    //numerator
     var num = sub.map(function (row) { return row.map(function (element) { return Math.pow(element,2) }) });
    //Division
    var res = num.map(function (row) { return row.map(function (element) { return element/den }) });
    //Exponent of result
    var result = res.map(function (row) { return row.map(function (element) { return Math.exp(-element) }) });
    return result;
  }
  else if(Utils.isArray(x)===true && typeof(pos)==='number' && typeof(wid)==='number') {
    //Denominator
    var den = Math.pow((0.6005615*wid),2)
    //Subtracting array from pos
    var sub = x.map(function(value) {
      return value - pos;
    });
    //numerator
    var num = sub.map(function (num,i) { return Math.pow(num,2) });
    ////Division
    var res = num.map(function(value) {
      return value/den;
    });
    //Exponent of result
    var result = res.map(function(value) {
      return Math.exp(-value);
    });
    return result;
  }
  else {
    throw 'EINVALID'
  } 
}


Math.sign = function (x) { return x<0?-1:x>0?1:0 }

// Sequence of numbers (discrete number ranges)
// [first:increment:second]
$S = function (first,incrementOrSecond,second) {
  if (second==undefined) return Math.sequence(first,incrementOrSecond);
  else return Math.sequence(first,second,incrementOrSecond);
}

// Right-hand side array selector
// A(first:last)
$RS = function (A,first,last) {
  if (Utils.isArray(A)) return A.slice(first,last+1)
}
// Left-hand side array selector
// A(first:last) = B
$WS = function (A,first,last,B) {
  if (Utils.isArray(A) && Utils.isArray(B)) 
    for(var i=0;i<last-first+1;i++) A[first+i]=B[i];
}

};
BundleModuleCode['plugins/math/points']=function (module,exports){
var Hull = Require('plugins/math/hull');
function toArray(points) {
  if (points[0].x != undefined) points=points.map(function (p) {
    return [p.x,p.y]
  })
  return points  
}
function toPoints(points) {
  if (typeof points[0][0] == 'number') points=points.map(function (v) {
    return {x:v[0],y:v[1]}
  })
  return points  
}
function ConvexHull (points) {
  points=toArray(points);
  return Hull(points)
}
// mass of center of point cloud
function moc (points) {
  var n = points.length, pc={x:0,y:0};
  for(var i=0;i<n;i++) {
    pc.x += points[i].x;
    pc.y += points[i].y;
  }
  pc.x/=n; pc.y/=n;
  return pc
}
// mean bounding box of point cloud
function mbb (points) {
  var n = points.length,
      pc = moc(points),
      b = { x1:pc.x, y1:pc.y, x2: pc.x, y2:pc.y },
      c = { x1:1, y1:1, x2:1, y2:1 };
  for(var i=0;i<n;i++) {
    var p = points[i];
    if (p.x>pc.x) { c.x2++; b.x2 += p.x }
    if (p.x<pc.x) { c.x1++; b.x1 += p.x }
    if (p.y>pc.y) { c.y2++; b.y2 += p.y }
    if (p.y<pc.y) { c.y1++; b.y1 += p.y }
  }
  b.x1 /= c.x1; b.x2 /= c.x2;
  b.y1 /= c.y1; b.y2 /= c.y2;
  return b
}
// Expansion of boundaries with second averaging of outside points
function mbx (points,b) {
  var n = points.length,
      b2 = { x1:b.x1, y1:b.y1, x2: b.x2, y2:b.y2 },
      c  = { x1:1, y1:1, x2:1, y2:1 };
  for(var i=0;i<n;i++) {
    var p = points[i];
    if (p.x>b.x2) { c.x2++; b2.x2 += p.x }
    if (p.x<b.x1) { c.x1++; b2.x1 += p.x }
    if (p.y>b.y2) { c.y2++; b2.y2 += p.y }
    if (p.y<b.y1) { c.y1++; b2.y1 += p.y }
  }
  b2.x1 /= c.x1; b2.x2 /= c.x2;
  b2.y1 /= c.y1; b2.y2 /= c.y2;
  return b2
}
// Minimum bounding rectangle
function findMinBoundingRect (points) {
  // https://github.com/mahetoodang/minimum-bounding-rectangle
  function multiply (a,b) {
    return Math.Matrix(a).multiply(Math.Matrix(b))
  }
  function transpose (a) {
    return Math.Matrix(a).transpose()
  }
  function matrix (a) {
    return Math.Matrix(a)
  }
  // Convex hull for the points
  points=toArray(points);
  const hullPoints = ConvexHull(points);

  const edges = [];
  for (let i=0; i < hullPoints.length-1; i++) {
    edges.push([
      hullPoints[i+1][0] - hullPoints[i][0],
      hullPoints[i+1][1] - hullPoints[i][1]
    ]);
  }

  const angles = Array.from(new Set(
    edges.map(function (edge) {
      return Math.abs(
        Math.atan2(edge[1], edge[0]) % (Math.PI / 2)
      )
    })
  ));

  const rotations = angles.map(function (angle) {
    return [
      [ Math.cos(angle), Math.cos(angle - Math.PI/2) ],
      [ Math.cos(angle + Math.PI/2), Math.cos(angle) ]
    ]
  });

  // Apply rotations to the hull
  const rotPoints = rotations.map(function (rotation) {
    return multiply(
      matrix(rotation),
      transpose(matrix(hullPoints))
    ).toArray()
  });

  const minXY = rotPoints.map(function (pMat) {
    const minValues = pMat.map(function (row) { return row.min() })// mathjs.min(pMat, 1); // TODO
    return [minValues[0], minValues[1]];
  });
  const maxXY = rotPoints.map(function (pMat) {
    const maxValues = pMat.map(function (row) { return row.max() }) // mathjs.max(pMat, 1); // TODO
    return [maxValues[0], maxValues[1]];
  });

  const minX = minXY.map(function (m) { return m[0]});
  const minY = minXY.map(function (m) { return m[1]});
  const maxX = maxXY.map(function (m) { return m[0]});
  const maxY = maxXY.map(function (m) { return m[1]});

  // Find the box with the best area
  const areas = minX.map(function (v, i) {
    return (maxX[i] - minX[i]) * (maxY[i] - minY[i])
  });
  const bestIdx = areas.reduce(function (iMax, x, i, arr) { 
    return i==1?0:(x < arr[iMax] ? i : iMax)
    // ,0 // TODO
  });

  // Return the best box
  const x1 = maxX[bestIdx];
  const x2 = minX[bestIdx];
  const y1 = maxY[bestIdx];
  const y2 = minY[bestIdx];
  const r = rotations[bestIdx];
  const minRect = [];

  minRect.push(multiply([[x1, y2]], r).toArray().unwrap());
  minRect.push(multiply([[x2, y2]], r).toArray().unwrap());
  minRect.push(multiply([[x2, y1]], r).toArray().unwrap());
  minRect.push(multiply([[x1, y1]], r).toArray().unwrap());
  minRect.push(multiply([[x1, y2]], r).toArray().unwrap());
  
  return minRect;
}
module.exports = {
  Hull : Hull,
  ConvexHull : ConvexHull,
  findMinBoundingRect : findMinBoundingRect,
  massOfCenter : moc,
  meanBoundingBox : mbb,
  meanBoundingBoxExpand : mbx,
  toArray : toArray,
  toPoints : toPoints,
}

};
BundleModuleCode['plugins/math/hull']=function (module,exports){
/**
 * Computes hull curve (of n points) of point cloud
 * https://github.com/AndriiHeonia/hull
 * var points = [ [236, 126], [234, 115], [238, 109], [247, 102], ... ];
 * hull(points, 50); // returns points of the hull (in clockwise order)
 *
*/
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.hull = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _cross(o, a, b) {
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}

function _upperTangent(pointset) {
    const lower = [];
    for (let l = 0; l < pointset.length; l++) {
        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {
            lower.pop();
        }
        lower.push(pointset[l]);
    }
    lower.pop();
    return lower;
}

function _lowerTangent(pointset) {
    const reversed = pointset.reverse(),
        upper = [];
    for (let u = 0; u < reversed.length; u++) {
        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {
            upper.pop();
        }
        upper.push(reversed[u]);
    }
    upper.pop();
    return upper;
}

// pointset has to be sorted by X
function convex(pointset) {
    const upper = _upperTangent(pointset),
          lower = _lowerTangent(pointset);
    const convex = lower.concat(upper);
    convex.push(pointset[0]);  
    return convex;  
}

module.exports = convex;

},{}],2:[function(require,module,exports){
module.exports = {

    toXy: function(pointset, format) {
        if (format === undefined) {
            return pointset.slice();
        }
        return pointset.map(function(pt) {
            /*jslint evil: true */
            const _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');
            return _getXY(pt);
        });
    },

    fromXy: function(pointset, format) {
        if (format === undefined) {
            return pointset.slice();
        }
        return pointset.map(function(pt) {
            /*jslint evil: true */
            const _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');
            return _getObj(pt);
        });
    }

}
},{}],3:[function(require,module,exports){
function Grid(points, cellSize) {
    this._cells = [];
    this._cellSize = cellSize;
    this._reverseCellSize = 1 / cellSize;

    for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const x = this.coordToCellNum(point[0]);
        const y = this.coordToCellNum(point[1]);
        if (!this._cells[x]) {
            const array = [];
            array[y] = [point];
            this._cells[x] = array;
        } else if (!this._cells[x][y]) {
            this._cells[x][y] = [point];
        } else {
            this._cells[x][y].push(point);
        }
    }
}

Grid.prototype = {
    cellPoints: function(x, y) { // (Number, Number) -> Array
        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];
    },

    rangePoints: function(bbox) { // (Array) -> Array
        const tlCellX = this.coordToCellNum(bbox[0]);
        const tlCellY = this.coordToCellNum(bbox[1]);
        const brCellX = this.coordToCellNum(bbox[2]);
        const brCellY = this.coordToCellNum(bbox[3]);
        const points = [];

        for (let x = tlCellX; x <= brCellX; x++) {
            for (let y = tlCellY; y <= brCellY; y++) {
                Array.prototype.push.apply(points, this.cellPoints(x, y));
            }
        }

        return points;
    },

    removePoint: function(point) { // (Array) -> Array
        const cellX = this.coordToCellNum(point[0]);
        const cellY = this.coordToCellNum(point[1]);
        const cell = this._cells[cellX][cellY];
        let pointIdxInCell;
        
        for (let i = 0; i < cell.length; i++) {
            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {
                pointIdxInCell = i;
                break;
            }
        }

        cell.splice(pointIdxInCell, 1);

        return cell;
    },

    trunc: Math.trunc || function(val) { // (number) -> number
        return val - val % 1;
    },

    coordToCellNum: function(x) { // (number) -> number
        return this.trunc(x * this._reverseCellSize);
    },

    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array
        return [
            bbox[0] - (scaleFactor * this._cellSize),
            bbox[1] - (scaleFactor * this._cellSize),
            bbox[2] + (scaleFactor * this._cellSize),
            bbox[3] + (scaleFactor * this._cellSize)
        ];
    }
};

function grid(points, cellSize) {
    return new Grid(points, cellSize);
}

module.exports = grid;
},{}],4:[function(require,module,exports){
/*
 (c) 2014-2019, Andrii Heonia
 Hull.js, a JavaScript library for concave hull generation by set of points.
 https://github.com/AndriiHeonia/hull
*/

'use strict';

const intersect = require('./intersect.js');
const grid = require('./grid.js');
const formatUtil = require('./format.js');
const convexHull = require('./convex.js');

function _filterDuplicates(pointset) {
    const unique = [pointset[0]];
    let lastPoint = pointset[0];
    for (let i = 1; i < pointset.length; i++) {
        const currentPoint = pointset[i];
        if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
            unique.push(currentPoint);
        }
        lastPoint = currentPoint;
    }
    return unique;
}

function _sortByX(pointset) {
    return pointset.sort(function(a, b) {
        return (a[0] - b[0]) || (a[1] - b[1]);
    });
}

function _sqLength(a, b) {
    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);
}

function _cos(o, a, b) {
    const aShifted = [a[0] - o[0], a[1] - o[1]],
        bShifted = [b[0] - o[0], b[1] - o[1]],
        sqALen = _sqLength(o, a),
        sqBLen = _sqLength(o, b),
        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];

    return dot / Math.sqrt(sqALen * sqBLen);
}

function _intersect(segment, pointset) {
    for (let i = 0; i < pointset.length - 1; i++) {
        const seg = [pointset[i], pointset[i + 1]];
        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||
            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
            continue;
        }
        if (intersect(segment, seg)) {
            return true;
        }
    }
    return false;
}

function _occupiedArea(pointset) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    for (let i = pointset.length - 1; i >= 0; i--) {
        if (pointset[i][0] < minX) {
            minX = pointset[i][0];
        }
        if (pointset[i][1] < minY) {
            minY = pointset[i][1];
        }
        if (pointset[i][0] > maxX) {
            maxX = pointset[i][0];
        }
        if (pointset[i][1] > maxY) {
            maxY = pointset[i][1];
        }
    }

    return [
        maxX - minX, // width
        maxY - minY  // height
    ];
}

function _bBoxAround(edge) {
    return [
        Math.min(edge[0][0], edge[1][0]), // left
        Math.min(edge[0][1], edge[1][1]), // top
        Math.max(edge[0][0], edge[1][0]), // right
        Math.max(edge[0][1], edge[1][1])  // bottom
    ];
}

function _midPoint(edge, innerPoints, convex) {
    let point = null,
        angle1Cos = MAX_CONCAVE_ANGLE_COS,
        angle2Cos = MAX_CONCAVE_ANGLE_COS,
        a1Cos, a2Cos;

    for (let i = 0; i < innerPoints.length; i++) {
        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);
        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);

        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&
            !_intersect([edge[0], innerPoints[i]], convex) &&
            !_intersect([edge[1], innerPoints[i]], convex)) {

            angle1Cos = a1Cos;
            angle2Cos = a2Cos;
            point = innerPoints[i];
        }
    }

    return point;
}

function _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {
    let midPointInserted = false;

    for (let i = 0; i < convex.length - 1; i++) {
        const edge = [convex[i], convex[i + 1]];
        // generate a key in the format X0,Y0,X1,Y1
        const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];

        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||
            edgeSkipList.has(keyInSkipList)) { continue; }

        let scaleFactor = 0;
        let bBoxAround = _bBoxAround(edge);
        let bBoxWidth;
        let bBoxHeight;
        let midPoint;
        do {
            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);
            bBoxWidth = bBoxAround[2] - bBoxAround[0];
            bBoxHeight = bBoxAround[3] - bBoxAround[1];

            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);
            scaleFactor++;
        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));

        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
            edgeSkipList.add(keyInSkipList);
        }

        if (midPoint !== null) {
            convex.splice(i + 1, 0, midPoint);
            grid.removePoint(midPoint);
            midPointInserted = true;
        }
    }

    if (midPointInserted) {
        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);
    }

    return convex;
}

function hull(pointset, concavity, format) {
    let maxEdgeLen = concavity || 20;

    const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));

    if (points.length < 4) {
        return points.concat([points[0]]);
    }

    const occupiedArea = _occupiedArea(points);
    const maxSearchArea = [
        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,
        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT
    ];

    const convex = convexHull(points);
    const innerPoints = points.filter(function(pt) {
        return convex.indexOf(pt) < 0;
    });

    const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));

    const concave = _concave(
        convex, Math.pow(maxEdgeLen, 2),
        maxSearchArea, grid(innerPoints, cellSize), new Set());

    if (format) {
        return formatUtil.fromXy(concave, format);
    } else {
        return concave;
    }
}

const MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg
const MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;

module.exports = hull;

},{"./convex.js":1,"./format.js":2,"./grid.js":3,"./intersect.js":5}],5:[function(require,module,exports){
function ccw(x1, y1, x2, y2, x3, y3) {           
    const cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));
    return cw > 0 ? true : cw < 0 ? false : true; // colinear
}

function intersect(seg1, seg2) {
  const x1 = seg1[0][0], y1 = seg1[0][1],
      x2 = seg1[1][0], y2 = seg1[1][1],
      x3 = seg2[0][0], y3 = seg2[0][1],
      x4 = seg2[1][0], y4 = seg2[1][1];

    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);
}

module.exports = intersect;
},{}]},{},[4])(4)
});
};
BundleModuleCode['plugins/math/vol']=function (module,exports){
/*
  3D and 4D Data Volumes with typed arrays
  Linear array layout: xyz/xyza : 312/3124 (conforming to image RGBA)
  [ r0:c0:d0, d1, d2 ..,r0:c1:d0,d1,d2,..,..,r1:c0:d0,... ]   
*/
function isArray(o) {
  return (typeof o == 'object') && (o.buffer instanceof ArrayBuffer || o instanceof Array)
}
function isTypedArray(o) {
  return o && o.buffer instanceof ArrayBuffer
}
function size(interval) {
  return interval[1]-interval[0]+1;
}
// Default Vol3D
var Vol = function(sx, sy, depth, c, datatype) {
  if (!(this instanceof Vol)) return new Vol(sx, sy, depth, c, datatype);
  // this is how you check if a variable is an array. Oh, Javascript :)
  // if(Object.prototype.toString.call(sx) === '[object Array]') {
  if (isArray(sx)) {
    // we were given a list in sx, assume 1D volume and fill it up
    this.sx = 1;
    this.sy = 1;
    this.depth = sx.length;
    for(var i=0;i<this.depth;i++) {
      this.w[i] = sx[i];
    }
  } else if (typeof sx == 'object') {
    // fromJSON
    this.fromJSON(sx);
  } else {
    // we were given dimensions of the vol
    this.sx = sx;
    this.sy = sy;
    this.depth = depth;
    var n = sx*sy*depth;
    if (isArray(c)) {
      this.w  = isTypedArray(c)?c:Vol.data.from(c,datatype);
      return;
    } else if (typeof c == 'number') {
      this.w  = Vol.data.constant(n,c,datatype);
    } else {
      this.w  = Vol.data.zeros(n,datatype);
    }
  }
}

Vol.prototype = {
  add: function(x, y, d, v) {
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] += v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] += v; 
    }
    return this;
  },
  addVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] += V.w[k]; }},
  addFromScaled: function(V, a) { for(var k=0;k<this.w.length;k++) { this.w[k] += a*V.w[k]; }},
  apply : function (v) {
    if (typeof v == 'number')  for(var k=0;k<this.w.length;k++) this.w[k]=v;
    else if (typeof v == 'function')  for(var k=0;k<this.w.length;k++) this.w[k]=v.apply(this,this.fromIndex(k));
    return this;   
  },
  checkIndex : function (x,y,z) {
    return !(x<0 || x>= this.sx) &&
           !(y<0 || y>= this.sy) &&
           !(z<0 || z>= this.depth);
  },
  cloneAndZero: function() { return new Vol(this.sx, this.sy, this.depth, 0.0)},
  clone: function(shared) {
    var V = new Vol(this.sx, this.sy, this.depth, 0.0, Utils.TypedArrayToName(this.w).replace('Array',''));
    var n = this.w.length;
    V.w=Vol.data.clone(this.w,shared)
    return V;
  },
  // kernel : [
  //  v, v, v,
  //  v, v, v,
  //  v, v, v,
  // ]
  // shape(Output)==shape(Input)
  convolution : function (kernel,z0,z1,divisor,offset) {
    // https://developpaper.com/image-processing-with-convolution-kernel-in-html5-canvas/
    let w = this.sx,
        h = this.sy,
        d = this.depth;
    divisor = divisor||1;
    offset=offset||0;
    if (z0==undefined) z0=0,z1=d-1;
    var V = Vol.create(this.sx,this.sy,this.depth,this.datatype()); 
    let iD = this.w,
        oD = V.w;
    for (let y = 1; y < h - 1; y += 1) {
      for (let x = 1; x < w - 1; x += 1) {
        for (let c = z0; c < z1; c += 1) {
          let i = (y * w + x) * d + c
          oD[i] =
            offset +
            (kernel[0] * iD[i - w * d - d] +
              kernel[1] * iD[i - w * d] +
              kernel[2] * iD[i - w * d + d] +
              kernel[3] * iD[i - d] +
              kernel[4] * iD[i] +
              kernel[5] * iD[i + d] +
              kernel[6] * iD[i + w * d - d] +
              kernel[7] * iD[i + w * d] +
              kernel[8] * iD[i + w * d + d]) /
              divisor
        }
      }
    }    
    // RGBA?
    if (z0 == 0 && z1==2 && d==4) {
      for (let y = 1; y < h - 1; y += 1) {
        for (let x = 1; x < w - 1; x += 1) {
          oD[(y * w + x) * d + 3] = 255;
        }
      }      
    }
    return V
  },
  // typeof @options = { stride, pad, dilation }, @filters = Vol [] 
  // Input:   [sx,sy,depth]
  // Output:  [sx+pad*2/stride+1,sy+pad*2/stride+1,|filters|]
  // taken from convnet.js
  convolutionN : function(filters,options) {
    options=options||{}
    if (options.pad==undefined) options.pad=0;
    if (options.stride==undefined) options.stride=1;
    if (options.dilation==undefined) options.dilation=0;
    if (options.sx==undefined) options.sx=filters[0].sx; // filter size
    if (options.sy==undefined) options.sy=filters[0].sy; // filter size
    var V=this,
        out_depth = filters.length,
        out_sx = Math.floor((this.sx + options.pad * 2 - options.sx) / options.stride + 1),
        out_sy = Math.floor((this.sy + options.pad * 2 - options.sy) / options.stride + 1);
    var A = options.output || new Vol(out_sx, out_sy, out_depth, 0.0);
    
    var V_sx = V.sx;
    var V_sy = V.sy;
    var xy_stride = options.stride;

    for(var d=0;d<out_depth;d++) {
      var f = filters[d];
      var x = -options.pad;
      var y = -options.pad;
      for(var ay=0; ay<out_sy; y+=xy_stride,ay++) {  // xy_stride
        x = -options.pad;
        for(var ax=0; ax<out_sx; x+=xy_stride,ax++) {  // xy_stride
          // convolve centered at this particular location
          var a = 0.0;
          for(var fy=0;fy<f.sy;fy++) {
            var oy = y+fy; // coordinates in the original input array coordinates
            for(var fx=0;fx<f.sx;fx++) {
              var ox = x+fx;
              if(oy>=0 && oy<V_sy && ox>=0 && ox<V_sx) {
                for(var fd=0;fd<f.depth;fd++) {
                  // avoid function call overhead (x2) for efficiency, compromise modularity :(
                  a += f.w[((f.sx * fy)+fx)*f.depth+fd] * V.w[((V_sx * oy)+ox)*V.depth+fd];
                }
              }
            }
          }
          A.set(ax, ay, d, a);
        }
      }
    }
    return A;
  },
  copy : function (src,dx,dy,dz,plane) {
    plane=plane||'xyz';
    if (typeof dx == 'number') dx=[dx,dx+src.sx-1];
    if (typeof dy == 'number') dy=[dy,dy+src.sy-1];
    if (typeof dz == 'number') dz=[dz,dz+src.depth-1];
    if (dx.length==0) dx=[0,this.sx-1];
    if (dy.length==0) dy=[0,this.sy-1];
    if (dz.length==0) dz=[0,this.depth-1];
    switch (plane) {
      case 'xyz':
        for(var i=dx[0];i<=dx[1];i++)
          for(var j=dy[0];j<=dy[1];j++) 
            for(var k=dz[0];k<=dz[1];k++) {
              var ia = ((src.sx * (j-dy[0]))+(i-dx[0]))*src.depth+(k-dz[0]),
                  ib = ((this.sx * j)+i)*this.depth+k;
              this.w[ib]=src.w[ia];
            }
        break;
      default:
        throw 'Vol3.copy: supported planes ["xyz"]';
    }
  },
  datatype : function () { return Utils.TypedArrayToName(this.w).replace('Array','') },
  diag : function (v) {
    if (v!= undefined) {
      if (this.depth==1) {
        for(var i=0;i<this.sx;i++) 
          this.set(i,i,0,v);
      }
    }
    return this;
  },
  div: function(x, y, d, v) {
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] /= v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] /= v; 
    }
    return this;
  },
  divVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] /= V.w[k]; }},
  fromIndex : function (ix) {
    // ix=((this.sx * y)+x)*this.depth+d;
    var d = ix % this.depth,
        x = Math.floor(ix/this.depth) % this.sx,
        y = ((ix-d)/this.depth-x)/this.sx;
    return [x,y,d]
  },
  fromJSON: function(json) {
    this.sx = json.sx;
    this.sy = json.sy;
    this.depth = json.depth;
    var n = this.sx*this.sy*this.depth;
    this.w = Vol.data.from(json.w,json.dt,n);
  },
  get: function(x, y, d) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    return this.w[ix];
  },
  index : function (x,y,d) {
    var ix=((this.sx * y)+x)*this.depth+d;
    return ix;
  },
  info : function () {
    return {
      sx:this.sx,
      sy:this.sy,
      depth:this.depth,
      datatype:this.datatype()
    }
  },
  max : function () {
    var v=this.w[0];
    for(var k=1;k<this.w.length;k++) { v=Math.max(v,this.w[k]) }
    return v
  },
  min : function () {
    var v=this.w[0];
    for(var k=1;k<this.w.length;k++) { v=Math.min(v,this.w[k]) }
    return v
  },
  minmax : function () {
    var min=this.w[0],max=this.w[0];
    for(var k=1;k<this.w.length;k++) { min=Math.min(min,this.w[k]);max=Math.max(max,this.w[k]); }
    return {min:min,max:max }
  },
  // Scalar multiplication
  mul: function(x, y, d, v) {
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] *= v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] *= v; 
    }
    return this;
  },
  // Element-wise volume multiplication
  mulVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] *= V.w[k]; }},
  print : function (format) {
    var s='';
    if (!format) format = '%4.2f';
    for(k=0;k<this.depth;k++) {
      if (k!=0) s = s + '\n\n';
      for(j=0;j<this.sy;j++) {
        sep = '';
        if (j!=0) s = s + '\n';
        for (i=0;i<this.sx;i++) {
          s = s + sep + sprintf(format,this.get(i,j,k)) ;
          sep = ' ';
        }
      }
    }
    return s;
  },
  random  : function(min,max,frac) { 
    if (min==undefined && max==undefined) for(var k=0;k<this.w.length;k++) { this.w[k] = Math.random() }
    else if (frac) for(var k=0;k<this.w.length;k++) { this.w[k] = Math.frac(min+Math.random()*(max-min),frac) }
    else for(var k=0;k<this.w.length;k++) { this.w[k] = min+Math.random()*(max-min) };
    return this;
  },
  // resize vol (simple pick and place algorithm)
  resize : function (sx,sy,depth,datatype,inplace) {
    var dx = this.sx/sx,
        dy = this.sy/sy,
        dz = this.depth/depth,
        V;
    if (typeof datatype == 'boolean') { inplace=datatype; datatype=null };
    if (!inplace) {
      V = Vol(sx,sy,depth,datatype||this.datatype());
      for (var i=0;i<sx;i++)
        for (var j=0;j<sy;j++) 
          for(var k=0;k<depth;k++) {
            var ia = (this.sx * Math.floor(j*dy)+Math.floor(i*dx))*this.depth+Math.floor(k*dz),
                ib = ((sx * j)+i)*depth+k;
            V.w[ib]=this.w[ia];
      }
    } else {
      // TODO
    }
    return V;
  },
  // rotate and opt. mirror a vol
  rotate : function (rot,inplace) {
    function xzy (direction,inplace) {
      if (!inplace) {
        var V = Vol(this.sx,this.depth,this.sy,this.datatype());
        for(var i=0;i<this.sx;i++)
          for(var j=0;j<this.sy;j++) {
            if (direction==1) for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+i)*this.depth+k,
                  b = ((V.sx * (V.sy-k-1))+i)*V.depth+j;
                  V.w[b]=this.w[a];
            } else for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * (this.sy-j-1))+i)*this.depth+k,
                  b = ((V.sx * k)+i)*V.depth+j;
                  V.w[b]=this.w[a];
            }
        }
        return V
      } else {
        // TODO
      }
    }
    function zyx (direction,inplace) {
      if (!inplace) {
        var V = Vol(this.depth,this.sy,this.sx,this.datatype());
        for(var i=0;i<this.sx;i++)
          for(var j=0;j<this.sy;j++) {
            if (direction==1) for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+i)*this.depth+k,
                  b = ((V.sx * j)+k)*V.depth+i;
                  V.w[b]=this.w[a];
            } else for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * (this.sy-j-1))+i)*this.depth+k,
                  b = ((V.sx * j)+k)*V.depth+i;
                  V.w[b]=this.w[a];
            }
        }
        return V
      } else {
        // TODO
      }
    }
    function yxz (direction,inplace) {
      if (!inplace) {
        var V = Vol(this.sy,this.sx,this.depth,this.datatype());
        for(var i=0;i<this.sx;i++)
          for(var j=0;j<this.sy;j++) {
            if (direction==1) for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+i)*this.depth+k,
                  b = ((V.sx * i)+(V.sx-j-1))*V.depth+k;
                  V.w[b]=this.w[a];
            } else for (var k=0;k<this.depth;k++)  {
              var a = ((this.sx * j)+(this.sx-i-1))*this.depth+k,
                  b = ((V.sx * i)+j)*V.depth+k;
                  V.w[b]=this.w[a];
            }
        }
        return V
      } else {
        // TODO
      }
    }
    var dir=1;
    if (Utils.isArray(rot)) {
      switch(rot.join(',')) {
        case '1,0,0': rot='xzy'; break;
        case '-1,0,0': rot='-xzy'; break;
        case '0,1,0': rot='zyx'; break;
        case '0,-1,0': rot='-zyx'; break;
        case '0,0,1': rot='yxz'; break;
        case '0,0,-1': rot='-yxz'; break;
      }
    }
    if (rot[0]=='-') { rot=rot.slice(1); dir=-1 }; 
    if (rot=='xzy') return xzy.call(this,dir,inplace);
    if (rot=='zyx') return zyx.call(this,dir,inplace);
    if (rot=='yxz') return yxz.call(this,dir,inplace);
    throw 'Vol3.rotate: supported rotations ["(-)xzy","(-)yxz","(-)zyx","""(-)1,0,0","0,0,(-)1"]'
  },
  // kernel-based vol resizing (down- and up-sampling with interpolation/extrapolation)
  // filters: 'nearest', 'linear', 'min', 'max', 'peak'
  sample : function (sx,sy,depth,filter,datatype) {
    var dx = this.sx/sx,
        dy = this.sy/sy,
        dz = this.depth/depth,
        src = this,
        kernel;
    var V = Vol(sx,sy,depth,datatype||this.datatype()),
        dst = V;
    // TODO: inline .get/.set
    function kernelNearest(x,y,z) { return src.get(x,y,z) };
    // Down-sampling kernels
    function kernelMin(x,y,z,xR,yR,zR) {
      var q=src.get(x,y,z);
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q=Math.min(p,q)
      }
      return q;
    }
    function kernelMax(x,y,z,xR,yR,zR) {
      var q=src.get(x,y,z);
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q=Math.max(p,q) 
      }
      return q;
    }
    function kernelMean(x,y,z,xR,yR,zR) {
      var n=0,q=0;
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q+=p; n++;
      }
      return q/n;
    }    
    function kernelPeak(x,y,z,xR,yR,zR) {
      var q=src.get(x,y,z);
      for(var j=y-yR;j<=y+yR;j++)
        for(var i=x-xR;i<=x+xR;i++) 
          for(var k=z-zR;k<=z+zR;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          q=Math.abs(p)>Math.abs(q)?p:q; 
      }
      return q;
    }
    function kernelLinearDown(x,y,z,xR,yR,zR) {
      var q=0,n=0;
      var xRn=Math.floor(xR),yRn=Math.floor(yR),zRn=Math.floor(zR);
      for(var j=y-yRn;j<=y+yRn;j++)
        for(var i=x-xRn;i<=x+xRn;i++) 
          for(var k=z-zRn;k<=z+zRn;k++) {
          if (i<0||j<0||k<0||i>=src.sx||j>=src.sy||k>=src.depth) continue;
          var p = src.get(i,j,k);
          var w = 1-Math.distance([i-x,j-y,k-z])/Math.distance([zR,yR,xR]);
          q+=(p*w); n++; /* padding with zeros? */
      }
      return q/n;
    }
    // Up-sampling
    function kernelLinearUp2D(x,y,z,xR,yR,zR) {
      var x_l = Math.floor(xR * x), y_l = Math.floor(yR * y),
          x_h = Math.ceil(xR * x),  y_h = Math.ceil(yR * y);
      var x_weight = (xR * x) - x_l,
          y_weight = (yR * y) - y_l;
      // TODO x,y,z boundary check
      // console.log(x,y,z,x_l,y_l,x_h,y_h);
      var a = src.get(x_l, y_l, z)||0,
          b = src.get(x_h, y_l, z)||0,
          c = src.get(x_l, y_h, z)||0,
          d = src.get(x_h, y_h, z)||0;
      return a * (1 - x_weight) * (1 - y_weight) + 
             b * x_weight * (1 - y_weight) + 
             c * y_weight * (1 - x_weight) + 
             d * x_weight * y_weight
    }
    function kernelLinearUp3D(x,y,z,xR,yR,zR) {
      var x_l = Math.floor(xR * x), y_l = Math.floor(yR * y), z_l = Math.floor(zR * z),
          x_h = Math.ceil(xR * x),  y_h = Math.ceil(yR * y), z_h = Math.floor(zR * z);
      var x_weight = (xR * x) - x_l,
          y_weight = (yR * y) - y_l,
          z_weight = (zR * z) - z_l;
      // TODO x,y,z boundary check
      var a = src.get(x_l, y_l, z_l)||0,
          b = src.get(x_h, y_l, z_l)||0,
          c = src.get(x_l, y_h, z_l)||0,
          d = src.get(x_h, y_h, z_l)||0,
          e = src.get(x_l, y_l, z_h)||0,
          f = src.get(x_h, y_l, z_h)||0,
          g = src.get(x_l, y_h, z_h)||0,
          h = src.get(x_h, y_h, z_h)||0;
          // TODO TBC
      return a * (1 - x_weight) * (1 - y_weight)  * (1 - z_weight)+ 
             b * x_weight * (1 - y_weight)  * (1 - z_weight)+ 
             c * y_weight * (1 - x_weight)   * (1 - z_weight)+ 
             d * x_weight * y_weight  * (1 - z_weight) +
             e * (1 - x_weight) * (1 - y_weight)  * z_weight+ 
             f * x_weight * (1 - y_weight)  * z_weight+ 
             g * y_weight * (1 - x_weight)   * z_weight+ 
             h * x_weight * y_weight  * z_weight;
             
    }
    if (dz==1 && this.depth==1) {
      // 2D Scaling
      if (dx>=1 && dy>=1) {
        // down-sampling
        switch (filter) {
          case 'nearest':
          case 'nn': kernel=kerneNearest; break;
          case 'mean': kernel=kernelMean; break;  
          case 'min': kernel=kernelMin; break;  
          case 'max': kernel=kernelMax; break;  
          case 'peak': kernel=kernelPeak; break;          
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearDown; break;          
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) {
          var ix = Math.floor(i*dx),
              iy = Math.floor(j*dy);
          V.set(i,j,0,kernel(ix,iy,0,dx,dy,1));
        }
      } else {
        // up-sampling
        switch (filter) {
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearUp2D; break;
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) {
            V.set(i,j,0,kernel(i,j,0,dx,dy,dz));
        }
      }
    } else {
      // 3D Scaling
      if (dx>=1 && dy>=1 && dz>=1) {
        switch (filter) {
          case 'nearest':
          case 'nn': kernel=kerneNearest; break;
          case 'mean': kernel=kernelMean; break;  
          case 'min': kernel=kernelMin; break;  
          case 'max': kernel=kernelMax; break;  
          case 'peak': kernel=kernelPeak; break;          
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearDown; break;          
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) 
            for (var k=0;k<V.depth;k++) {
          var ix = Math.floor(i*dx),
              iy = Math.floor(j*dy),
              iz = Math.floor(k*dz);
          V.set(i,j,k,kernel(ix,iy,iz,dx,dy,dz));
        }      
      } else {
        // up-sampling
        switch (filter) {
          case 'linear': 
          case 'bilinear': 
            kernel=kernelLinearUp3D; break;
        }
        if (!kernel) throw ("Vol.sample: unsupported kernel "+filter)
        for(var j=0;j<V.sy;j++)
          for(var i=0;i<V.sx;i++) 
            for (var k=0;k<V.depth;k++) {
            V.set(i,j,k,kernel(i,j,k,dx,dy,dz));
        }      
      }
    }
    return V
  },
  // min:number||{ k, off, shift, min, max }
  scale : function (min,max,lower,upper,clip) {
    var scala;
    if (typeof min=='object') scala=min;
    else if (min==undefined && max==undefined) {
      scala=Math.scale0(this,0,1);
    } else {
      scala=Math.scale1(min,max,lower,upper);
    }
    if (!clip) for(var k=0;k<this.w.length;k++) { this.w[k] = ((this.w[k]-scala.off)*scala.k)+scala.shift; }
    else for(var k=0;k<this.w.length;k++) { 
      var v = Math.min(Math.max(this.w[k],scala.min),scala.max);
      this.w[k] = ((v-scala.off)*scala.k)+scala.shift; 
    }
    return this;
  },
  set: function(x, y, d, v) { 
    var ix=((this.sx * y)+x)*this.depth+d;
    this.w[ix] = v; 
  },
  setConst: function(a) { for(var k=0;k<this.w.length;k++) { this.w[k] = a; }; return this},
  slice : function (dx,dy,dz,plane) {
    var V,data;
    plane=plane||'xyz'
    if (isArray(dz) && dz.length==0 && 
        isArray(dx) && dx.length==0) {
      // fast data slicing is possible
      var iy0,iy1;
      if (isArray(dy) && dy.length==0) dy=[0,this.sy-1];
      else if (typeof dy == 'number') dy=[dy,dy];
      iy0=dy[0]*this.sx*this.depth;
      iy1=(dy[1]+1)*this.sx*this.depth;
      data=this.w.slice(iy0,iy1);
      return Vol(this.sx,dy[1]-dy[0]+1,this.depth,data);
    } else {
      // data must be copied by hand
      if (isArray(dx) && dx.length==0) dx=[0,this.sx-1];
      else if (typeof dx == 'number') dx=[dx,dx];
      if (isArray(dy) && dy.length==0) dy=[0,this.sy-1];
      else if (typeof dy == 'number') dy=[dy,dy];
      if (isArray(dz) && dz.length==0) dz=[0,this.depth-1];
      else if (typeof dz == 'number') dz=[dz,dz];
      var sx = dx[1]-dx[0]+1,
          sy = dy[1]-dy[0]+1,
          sz = dz[1]-dz[0]+1;
      switch (plane) {
        case 'xyz':
          V=Vol(sx,sy,sz,this.datatype());
          data=V.w;
          for(var j=dy[0];j<=dy[1];j++)
            for(var i=dx[0];i<=dx[1];i++) 
              for(var k=dz[0];k<=dz[1];k++) {
            V.set(i-dx[0],j-dy[0],k-dz[0],this.get(i,j,k))   
          }
          return V
          break;
        case 'yzx':
          V=Vol(sy,sz,sx,this.datatype());
          data=V.w;
          for(var j=dy[0];j<=dy[1];j++)
            for(var i=dx[0];i<=dx[1];i++) 
              for(var k=dz[0];k<=dz[1];k++) {
            V.set(j-dy[0],k-dz[0],i-dx[0],this.get(i,j,k))   
          }
          return V
          break;
        default:
          throw ('Vol3.slice: supported planes ["xyz","yzx"]');
      }
    }
  },
  sub: function(x, y, d, v) { 
    if (v==undefined) {
      v=x;
      for(var k=0;k<this.w.length;k++) { this.w[k] -= v; }
    } else {
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] -= v; 
    }
    return this;
  },
  subVol: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] -= V.w[k]; }},
  sum : function (norm) {
    var v=0;
    for(var k=0;k<this.w.length;k++) v += this.w[k];
    return norm?v/this.w.lengt:v;
  },
  to : function (datatype) {
    var V = new Vol(this.sx, this.sy, this.depth, 0, datatype);
    for(var k=0;k<this.w.length;k++) V.w[k]=this.w[k];
    return V;
  },
  toArray : function (linear) {
    if (linear) {
      return this.w.toArray()
    } else if (this.sx!=1 || this.sy!=1) {
      var ma=[],ix;
      for(var j=0;j<this.sy;j++) {
        var row = [];
        for(var i=0;i<this.sx;i++) {
          if (this.depth==1) {
            ix=((this.sx * j)+i);
            row.push(this.w[ix]);
          } else {
            var slice=[];
            for(var k=0;k<this.depth;k++) {
              ix=((this.sx * j)+i)*this.depth+k;
              slice.push(this.w[ix])
            }
            row.push(slice);
          }
        }
        ma.push(row);
      }
      return ma;
    } else {
      // Vector
      return this.w.toArray()
    }
  },
  toImage : function (scala) {
    var data,depth=this.depth;
    if (depth==4) data=this.w;
    else {
      // already layout 321
      var data=Vol.data.zeros(this.sx*this.sy*4,'Uint8');
      for(var k=0;k<this.sx*this.sy;k++) {
        var i=k*depth,j=k*4;
        data[j+3]=255;
        if (scala) for(var l=0;l<3;l++) data[j+l]=((this.w[i+(l%this.depth)]-scala.off)*scala.k)+scala.shift; 
        else for(var l=0;l<3;l++) data[j+l]=this.w[i+(l%this.depth)];
      }      
    } 
    return { width: this.sx, height: this.sy, depth:4, data:data }
  },

  toJSON: function() {
    // todo: we may want to only save d most significant digits to save space
    var json = {}
    json.sx = this.sx; 
    json.sy = this.sy;
    json.depth = this.depth;
    json.w = this.w;
    json.dt = Utils.TypedArrayToName(this.w).replace('Array','');
    return json;
  },
  toVTK : function (spacing) {
    // For VTK viewer
    var V=this;
    spacing=spacing||[1,1,1];
    var lines = [
    '<VTKFile type="ImageData" version="1.0" byte_order="LittleEndian" header_type="UInt64">',
    '<ImageData WholeExtent="0 '+(V.sx-1)+' 0 '+(V.sy-1)+' 0 '+(V.depth-1)+'" Origin="0 0 0" Spacing="'+spacing.join(' ')+'">',
    '<Piece Extent="0 '+(V.sx-1)+' 0 '+(V.sy-1)+' 0 '+(V.depth-1)+'">',
    '<PointData Scalars="Scalars_">',
    // TODO: Range
    '<DataArray type="'+V.datatype()+'" Name="Scalars_" format="ascii" RangeMin="0" RangeMax="4095">',
    ];
    var line = [];
    for(var k=0;k<V.depth;k++)  {
      for(var j=0;j<V.sy;j++) {
        for(var i=0;i<V.sx;i++) { 
          line.push(V.get(i,j,k));
        }
        lines.push('  '+line.join(' '))
        line=[]
      }
    }
    if (line.length) lines.push(line.join(' '));
    lines=lines.concat([
    '</DataArray>',
    '</PointData>',
    '<CellData>',
    '</CellData>',
    '</Piece>',
    '</ImageData>',
    '</VTKFile>',
    ]);
    return lines.join('\n');  
  }
}
// Core typed array Operations
Vol.data = {
  constant : function (n,c,datatype) {
    datatype=datatype||'Float32';
    var dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!dt) return;
    var ta = new dt(n);
    for (var k=0;k<ta.length;k++) ta[k]=c;
    return ta;
  },
  clone : function (ta,shared) {
    var datatype = Utils.TypedArrayToName(ta).replace('Array',''),
        dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!shared) return new dt(ta);
    else return new dt(ta.buffer);
  },
  from : function (a,datatype,n) {
    if (!datatype) {
      if (isTypedArray(a)) datatype=Utils.TypedArrayToName(ta).replace('Array','');
      else datatype='Float32';
    }
    var dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!dt) return;
    if (typeof a == 'string') a=Buffer.from(a);
    else if (Utils.isObject(a) && !Utils.isArray(a)) {
      // copy over the elements
      if (!n) n=Object.keys(a).length();
      var dst = new dt(n);
      for(var i=0;i<n;i++) {
        dst[i] = a[i];
      }
      return dst;
    } else if (Utils.isArrayArray(a)) {
      a=a.flat();
    }
    return new dt(a);  
  },
  slice : function (ta,offset,length,shared) {
    var datatype = Utils.TypedArrayToName(ta).replace('Array',''),
        dsize = Utils.DataSize[datatype],
        dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!shared) return new dt(ta.slice(offset,offset+length));
    else return new dt(ta.buffer,offset*dsize,(offset+length)*dsize);
  },
  zeros : function (n,datatype) {
    datatype=datatype||'Float32';
    var dt = Utils.TypedArrayOfName[datatype+'Array'];
    if (!dt) return;
    var ta = new dt(n);
    return ta;
  }
}
// aliases
Vol.prototype.reshape =  Vol.prototype.resize;

Vol.from = function (o,datatype) {
  var V;
  if (Math.MatrixTA.isMatrix(o)) {
    if (o.layout==21 || o.layout==321)
      V = Vol(o.columns,o.rows,o.levels||1,o.data);
    else {
      // have to copy
      V = Vol(o.columns,o.rows,o.level||1,o.datatype);
      for(var i=0;i<V.sx;i++)
        for(var j=0;j<V.sy;j++)
          for(var k=0;k<V.depth;k++) {
        V.set(i,j,k,o.get(j,i,k));   
      }
    }
    return V
  } else if (o.width && o.height && o.data) { // Image handler
    var data,depth=o.data.length/(o.width*o.height)
    if (depth==4) data=o.data;
    else {
      data=Vol.data.zeros(o.width*o.height*4,datatype);
      for(var k=0;k<o.width*o.height;k++) {
        var i=k*depth,j=k*4;
        data[j+3]=255;
        for(var l=0;l<3;l++) data[j+l]=o.data[i+(l%depth)]; 
      }
    }
    return Vol(o.width,o.height,4,data);
  } else if (o.sx && o.sy && o.depth && o.w) {
    return Vol(o.sx,o.sy,o.depth,o.w);
  }
  if (typeof o == 'string') return Vol(1,1,o.length,Vol.data.from(o,datatype));
  if (isTypedArray(o)) return Vol(1,1,o.length,o);
  if (Utils.isArrayArray(o)) return Vol(o[0].length,o.length,1,Vol.data.from(o,datatype));
  if (isArray(o)) return Vol(1,1,o.length,Vol.data.from(o,datatype));
}
Vol.isVol = function (o) {
  return o instanceof Vol
}
Vol.version = '0.2.2';
module.exports = {
 Vol3:Vol
};

};
BundleModuleCode['plugins/math/fft']=function (module,exports){
/**
 * Fast Fourier Transform module
 * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)
 */
 
/* Version 1.3.1 */

(function() {
  var FFT= function (n,n2) { if (!(this instanceof FFT)) return new FFT(n,n2); this.init(n,n2) };           // top-level namespace
  var _root = this;  // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FFT=FFT;
  } else {
    window.FFT = FFT;
  }

  FFT.prototype = {
    init : function(n,n2) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        this._n = n;
        this._n2 = n2;
        this._initArray();
        this._makeBitReversalTable();
        this._makeCosSinTable();
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // 1D-FFT
    fft1d : function(re, im) {
      if (Utils.isArray(re))
        this.fft(re, im, 1);
      else if (Math.Vector.isVector(re)) 
        this.fft(re.data,im.data,1);
      else if (Math.VectorTA.isVector(re)) 
        this.fft(re.data,im.data,1);      
    },
    // 1D-IFFT
    ifft1d : function(re, im) {
      var k = 1/this._n;
      this.fft(re, im, -1);
      for(var i=0; i<this._n; i++) {
        re[i] *= k;
        im[i] *= k;
      }
    },
    // 2D-FFT
    fft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      if (Utils.isArray(re) && !Utils.isArrayArray(re)) {
        // x-axis
        for(var y=0; y<this._n; y++) {
          i = y*this._n;
          for(var x1=0; x1<this._n; x1++) {
            tre[x1] = re[x1 + i];
            tim[x1] = im[x1 + i];
          }
          this.fft1d(tre, tim);
          for(var x2=0; x2<this._n; x2++) {
            re[x2 + i] = tre[x2];
            im[x2 + i] = tim[x2];
          }
        }
        // y-axis
        for(var x=0; x<this._n; x++) {
          for(var y1=0; y1<this._n; y1++) {
            i = x + y1*this._n;
            tre[y1] = re[i];
            tim[y1] = im[i];
          }
          this.fft1d(tre, tim);
          for(var y2=0; y2<this._n; y2++) {
            i = x + y2*this._n;
            re[i] = tre[y2];
            im[i] = tim[y2];
          }
        }
      } else if (Utils.isArrayArray(re) || Math.Matrix.isMatrix(re)) {
        // TODO
      } else if (Math.MatrixTA.isMatrix(re)) {
        // TODO
      }
    },
    // 2D-IFFT
    ifft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<this._n; y++) {
        i = y*this._n;
        for(var x1=0; x1<this._n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        this.ifft1d(tre, tim);
        for(var x2=0; x2<this._n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<this._n; x++) {
        for(var y1=0; y1<this._n; y1++) {
          i = x + y1*this._n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        this.ifft1d(tre, tim);
        for(var y2=0; y2<this._n; y2++) {
          i = x + y2*this._n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // core operation of FFT
    fft : function(re, im, inv) {
      var d, h, ik, m, tmp, wr, wi, xr, xi,
          n4 = this._n >> 2;
      // bit reversal
      for(var l=0; l<this._n; l++) {
        m = this._bitrev[l];
        if(l < m) {
          tmp = re[l];
          re[l] = re[m];
          re[m] = tmp;
          tmp = im[l];
          im[l] = im[m];
          im[m] = tmp;
        }
      }
      // butterfly operation
      for(var k=1; k<this._n; k<<=1) {
        h = 0;
        d = this._n/(k << 1);
        for(var j=0; j<k; j++) {
          wr = this._cstb[h + n4];
          wi = inv*this._cstb[h];
          for(var i=j; i<this._n; i+=(k<<1)) {
            ik = i + k;
            xr = wr*re[ik] + wi*im[ik];
            xi = wr*im[ik] - wi*re[ik];
            re[ik] = re[i] - xr;
            re[i] += xr;
            im[ik] = im[i] - xi;
            im[i] += xi;
          }
          h += d;
        }
      }
    },
    // returns spectrum of signal array
    signalSpectrum : function (data,islog,norm,scale) {
      var re=data.slice(),
          im = data.map(function () { return 0 });
      this.fft1d(re,im);
      return this.spectrum(re,im,islog,norm,scale).slice(0,data.length/2);
    },
    // returns shifted spectrum array of signal input array
    signalSpectrumWindow : function (data,islog,norm,scale) {
      var res=[];
      for(var off=0;off<(data.length-this._n);off++) {
        var re = data.slice(off,off+this._n),
            im = re.map(function () { return 0 });
        this.fft1d(re,im);
        res.push(this.spectrum(re,im,islog,norm,scale).slice(0,this._n/2)); 
      }
      return res;
    },
    // returns amplitude spectrum array from re/im fft output
    spectrum : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
     // returns phase spectrum
    phase : function (re,im,islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          n2 = this._n*(this._n2||1),
          log = Math.log,
          atan = Math.atan;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(atan(im[i]/re[i]));
        } else {
          spectrum[i] = atan(im[i]/re[i]);
        }
      }
      return spectrum;
    },
    // returns power spectrum
    power : function (re,im,islog,norm,scale) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = this._n*(this._n2||1),
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log((re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = (re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      if (norm)
        for(var j=0; j<n2; j++) {
          spectrum[j] = spectrum[j]*imax;
        }
      else if (scale)
        for(var j=0; j<n2; j++) {
          spectrum[j] /= n2;
        }
      return spectrum;
    },
    // initialize the array (supports TypedArray)
    _initArray : function() {
      if(typeof Uint8Array !== 'undefined') {
				if(this._n<=256)
                                        this._bitrev = new Uint8Array(this._n);
				else if(this._n<=65536)
					this._bitrev = new Uint16Array(this._n);
				else
					this._bitrev = new Uint32Array(this._n);
      } else {
        this._bitrev = [];
      }
      if(typeof Float64Array !== 'undefined') {
        this._cstb = new Float64Array(this._n*1.25);
      } else {
        this._cstb = [];
      }
    },
    // zero padding
    _paddingZero : function() {
      // TODO
    },
    // makes bit reversal table
    _makeBitReversalTable : function() {
      var i = 0,
          j = 0,
          k = 0;
      this._bitrev[0] = 0;
      while(++i < this._n) {
        k = this._n >> 1;
        while(k <= j) {
          j -= k;
          k >>= 1;
        }
        j += k;
        this._bitrev[i] = j;
      }
    },
    // makes trigonometiric function table
    _makeCosSinTable : function() {
      var n2 = this._n >> 1,
          n4 = this._n >> 2,
          n8 = this._n >> 3,
          n2p4 = n2 + n4,
          t = Math.sin(Math.PI/this._n),
          dc = 2*t*t,
          ds = Math.sqrt(dc*(2 - dc)),
          c = this._cstb[n4] = 1,
          s = this._cstb[0] = 0;
      t = 2*dc;
      for(var i=1; i<n8; i++) {
        c -= dc;
        dc += t*c;
        s += ds;
        ds -= t*s;
        this._cstb[i] = s;
        this._cstb[n4 - i] = c;
      }
      if(n8 !== 0) {
        this._cstb[n8] = Math.sqrt(0.5);
      }
      for(var j=0; j<n4; j++) {
        this._cstb[n2 - j]  = this._cstb[j];
      }
      for(var k=0; k<n2p4; k++) {
        this._cstb[k + n2] = -this._cstb[k];
      }
    }
  };
}).call(this);

/**
 * Spatial Frequency Filtering
 * High-pass/Low-pass/Band-pass Filter
 * Windowing using hamming window
 */
(function() {
  var FrequencyFilter={};  // top-level namespace
  var _root = this;     // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.FrequencyFilter=FrequencyFilter;
  } else if(typeof exports !== 'undefined') {
    FrequencyFilter = exports;   // for CommonJS
  } else {
    FrequencyFilter = _root.FrequencyFilter = {};
  }

  // core operations
  var _n = 0;
  var core = {
    init : function(n) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        _n = n;
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // swaps quadrant
    swap : function(re, im) {
      var xn, yn, i, j, k, l, tmp,
          len = _n >> 1;
      for(var y=0; y<len; y++) {
        yn = y + len;
        for(var x=0; x<len; x++) {
          xn = x + len;
          i = x + y*_n;
          j = xn + yn*_n;
          k = x + yn*_n;
          l = xn + y*_n;
          tmp = re[i];
          re[i] = re[j];
          re[j] = tmp;
          tmp = re[k];
          re[k] = re[l];
          re[l] = tmp;
          tmp = im[i];
          im[i] = im[j];
          im[j] = tmp;
          tmp = im[k];
          im[k] = im[l];
          im[l] = tmp;
        }
      }
    },
    // applies High-Pass Filter
    HPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Low-Pass Filter
    LPF : function(re, im, radius) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r > radius) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // applies Band-Pass Filter
    BPF : function(re, im, radius, bandwidth) {
      var i = 0,
          p = 0,
          r = 0.0,
          n2 = _n >> 1,
          sqrt = Math.sqrt;
      for(var y=-n2; y<n2; y++) {
        i = n2 + (y + n2)*_n;
        for(var x=-n2; x<n2; x++) {
          r = sqrt(x*x + y*y);
          p = x + i;
          if(r < radius || r > (radius + bandwidth)) {
            re[p] = im[p] = 0;
          }
        }
      }
    },
    // windowing using hamming window
    windowing : function(data, inv) {
      var len = data.length,
          pi = Math.PI,
          cos = Math.cos;
      for(var i=0; i<len; i++) {
        if(inv === 1) {
          data[i] *= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        } else {
          data[i] /= 0.54 - 0.46*cos(2*pi*i/(len - 1));
        }
      }
    }
  };
  // aliases (public APIs)
  var apis = ['init', 'swap', 'HPF', 'LPF', 'BPF', 'windowing'];
  for(var i=0; i<apis.length; i++) {
    FrequencyFilter[apis[i]] = core[apis[i]];
  }
}).call(this);

/**
 * FFT Power Spectrum Viewer
 */
(function() {
  var SpectrumViewer={};  // top-level namespace
  var _root = this;    // reference to 'window' or 'global'

  if(typeof module !== 'undefined') {
    module.exports.SpectrumViewer=SpectrumViewer;
  } else if(typeof exports !== 'undefined') {
    SpectrumViewer = exports;   // for CommonJS
  } else {
    SpectrumViewer = _root.SpectrumViewer = {};
  }

  // core operations
  var _context = null,
      _n = 0,
      _img = null,
      _data = null;
  var core = {
    init : function(context) {
      _context = context;
      _n = context.canvas.width,
      _img = context.getImageData(0, 0, _n, _n);
      _data = _img.data;
    },
    // renders FFT power spectrum on the canvas
    render : function(re, im, islog) {
      var val = 0,
          i = 0,
          p = 0,
          spectrum = [],
          max = 1.0,
          imax = 0.0,
          n2 = _n*_n,
          log = Math.log,
          sqrt = Math.sqrt;
      for(var i=0; i<n2; i++) {
        if(islog){
          spectrum[i] = log(Math.sqrt(re[i]*re[i] + im[i]*im[i]));
        } else {
          spectrum[i] = sqrt(re[i]*re[i] + im[i]*im[i]);
        }
        if(spectrum[i] > max) {
          max = spectrum[i];
        }
      }
      imax = 1/max;
      for(var j=0; j<n2; j++) {
        spectrum[j] = spectrum[j]*255*imax;
      }
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x=0; x<_n; x++) {
          val = spectrum[i + x];
          p = (i << 2) + (x << 2);
          _data[p] = 0;
          _data[p + 1] = val;
          _data[p + 2] = val >> 1;
        }
      }
      _context.putImageData(_img, 0, 0);
    }
  };
  // aliases (public APIs)
  SpectrumViewer.init = core.init;
  SpectrumViewer.render = core.render;
}).call(this);
};
BundleModuleCode['plugins/math/conv']=function (module,exports){
/*
** Convolution and correlation of vectors and matrix objects
** using FFT
*/
function setup(a,b) {
  var N = a.length,
      M = Math.pow(2,Math.ceil(Math.log2(N))),
      N2  = M*2;
  var data1 = a.data?a.toArray():a,
      data2 = b.data?b.toArray():b;
  if (N!=M) {
    data1=data1.pad(M);
    data2=data2.pad(M);
  }
  var fft   = Math.FFT.FFT(N2);
  var re1   = data1.pad(N2,0);
  var im1   = Array.init(re1.length);
  fft.fft1d(re1,im1);
  var re2   = data2.pad(N2,0);
  var im2   = Array.init(re2.length);
  fft.fft1d(re2,im2);
  return {
    fft:fft,
    reA:re1,
    imA:im2,
    reB:re2,
    imB:im2
  }
}
Convolution = {
  convolute1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('convolute: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB);
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.add(im).slice(0,N),
          ca = Convolution.correlate1d(a,a), // ??
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.add(im).slice(0,N)
  },
  correlate1d : function (a,b,normalize) {
    if (a.length != b.length) throw Error('correlate: vectors of different size');
    var N = a.length;
    var op = setup(a,b);
    var re = op.reA.mul(op.reB),
        im = op.imA.mul(op.imB.mul(-1));
    op.fft.ifft1d(re,im);
    if (normalize) {
      var cab = re.sub(im).slice(0,N),
          ca = Convolution.correlate1d(a,a),
          cb = Convolution.correlate1d(b,b);
      return cab.div(Math.sqrt(ca[0])*Math.sqrt(cb[0]))
    } else return re.sub(im).slice(0,N)
  }
}

module.exports = Convolution;
};
BundleModuleCode['plugins/sql/sqlvfs2']=function (module,exports){
/*

FS to SQL (json) table mapper (KISS V2)
=============================

Files and directories can be accessd by SQL queries!
Just a functional JSONfn descriptor is required 

Either 1:1 or 1:N mapping of vDB<->vtable

NEW: Simplfified functional JSON configuration (can be provided on request)

- Single and multi-file indexing is supported

type meta = {
  table : string,
  path  : string,
  // more private attributes...
  
  cache?: number,   // row cache entries limit
  // Table initialisation:
  // create static row index table with at least rowid and file mappings
  // each prelimenary row entry can contain source data ranges (e.g., row in a table)  
  // !!! will be replaced on creation by returned rows array!
  // can contain already loaded data (e.g., monolithic csv files ...)
  // or store monolithic data in:
  // this._data=....
  // File operations, conversion, and caching via this.io
  // this._cache=this.io.cache(entries,bytes)
  // this._cache.set(key,data), this._cache.get(key)
  rows  : function () -> {rowid:number,...} [],
  // or even better a dynamic index table function -> Proxy // must support length attribute!
  rows  : function () -> (function (index:number|string) -> {rowid:number,...})
  // row schema
  schema : {
    id : 'int unique',
    datatype : 'char []=Uint8', 
    meta : 'char[]',
    meta : {} // or
    ..
  },
  // read one row (cacking is done outside)
  read   : function (rowIndex) -> row {},
  // evaluate a "where" expression, return rowIndex list
  select?    : function (expr) -> rowIndex [] 
}

this.io : io

type image = {width,height,data}

typeof io = {
  cache : function(entries,volume?), // create a cache
  convert : {
    toGRAY8 : function (image) -> image,
    toRGB   : function (image) -> image,
    ...
  },
  filter : function (list,regexp:string) -> list,
  list : function (path,kind?="dir"|"file") -> {dir?:string, file:?string, size?:number, ext?:string } []
  open : {
    csv : function (file,header?:{},separator) -> { index: [], header:[], fd:number }
  },
  parse : {
    csv : function (line,separator) -> {}
  },
  read : {
    binary : function (path:string,) -> buffer,
    text   : function (path:string,) -> string,
    yaml   : function (path:string,) -> {},
    json   : function (path:string,) -> {},
    numpy : function (path:string,) -> typedarray,
    png   : function (path:string,format?:string,matrix?:boolean) -> image,
    tiff : function (path:string,format?:string,matrix?:boolean) -> image,
  }
  transform : {
    mean : function (typedarray) -> typedarray,
    peak : ...
  }
}

*/
_=null

var version = "2.2.1"

var parser = Require('plugins/sql/sqlite-parser');
var fs     = require('fs');
var path   = require('path');
var inspect = require('util').inspect;
var numpy   = Require('plugins/numpy/numpy');
var image   = {
  png   : Require('plugins/image/UPNG'),
  tiff  : Require('plugins/image/UTIF')
};
var cache   = Require('cache');
//var papa    = Require('papaparse5');

Require('plugins/math/math');
function identity (x) { return x }

function Database(meta,options) {
  var self=this;
  if (!(this instanceof Database)) return new Database(meta,options);
  if (meta instanceof Array) {
    meta.forEach(self.checkMeta)
  } else this.checkMeta(meta);
  
  // Add sqlitemaster table
  var sqlitemaster = {
    table   : 'sqlite_master',
    schema  : { name : 'text', sql  : 'text', type : 'text' }
  }
  sqlitemaster.schema=this.compileSchema(sqlitemaster.schema);
  this.handleHash={};
  var tables = [sqlitemaster];
  if (meta instanceof Array) {
    tables=tables.concat(meta);
    meta.forEach(function (meta) {
      self.handleHash[meta.table]=self.compileMeta(meta);    
    })
  } else {
    tables.push(meta);
    this.handleHash[meta.table]=this.compileMeta(meta); 
  }
  var handle0 = {
    cache   : tables.map(function (meta) {
      return { name : meta.table, sql:self.schemaSQL(meta), type : 'table' }
    }),
    count   : function () {
      return cache.length
    },
    rows    : tables.map(function (meta,index) { return {name:meta.table,rowid:index+1} }),
    getRow  : function (rowIndex) {
      return this.cache[rowIndex-1]
    },
    mapRow : function (rowIndex,keys) {
      var row = this.getRow(rowIndex);
      if (!row) return;
      keys = keys || Object.keys(this.meta.schema);
      // print(row,keys)
      return self.map2sql(handle0,rowIndex,row,keys);
    },
    meta : sqlitemaster,
  };
  this.handleHash['sqlite_master']=handle0;
  this.log('VDB <'+options.name+'> created.');
  this.log('VDB <'+options.name+'> tables:\n     '+tables.map(function (td) { return self.tableInfo(td.table) }).join(',\n     ')+'.');
  this.readonly=true;
}


Database.prototype.checkMeta = function (meta) {
  if (!meta.table) throw("Missing meta.table");
  if (typeof meta.rows != 'function') throw("Missing meta.rows function");
  if (typeof meta.read != 'function') throw("Missing meta.read function");
  if (typeof meta.schema != 'object') throw("Missing meta.schema object");
}

Database.prototype.compileMeta = function (meta) {
  var self=this,handle={}
  // row cache
  handle.cache =  cache({   // dynamic table with external data
    limit   : (meta.cache && Number(meta.cache))||100,
    volume  : 64E6,
    maxTTL  : 120000,
    buckets : 4,
  })
  var rows = meta.rows.call(Object.assign({io:this.io},meta));
  if (typeof rows == 'function') {
    // dynamic row index table; create a proxy
    handle.rows = new Proxy([],{
      get : function (target,name) {
        if (typeof name == 'symbol') return;
        if (!isNaN(Number(name))) return rows(Number(name));
        else if (name=='length') return rows(name);
        else if (name=='filter') return function (f) {
          var result=[];
          for(var i=0;i<rows.length;i++) {
            if (f(rows[i],i)) result.push(rows[i]);
          }
          return result;
        }
        return;
      },
      set : function () {
        return;
      }
    })
  } else handle.rows=rows;
  if (!handle.rows.length) throw ("compileMeta: meta.rows returned empty array");
  if (handle.rows[0].rowid==undefined) for(var i=0;i<handle.rows.length;i++) {
    handle.rows[i].rowid=i+1;
  };
  meta.rows = handle.rows;
  meta.schema = this.compileSchema(meta.schema);
  handle.meta = meta;
  handle.getRow = function (rowIndex) {
// console.log('handle.getRow',meta.table,rowIndex)
    var data = handle.cache.get(rowIndex);
    if (!data) {
      data = meta.read.call(Object.assign({io:self.io},meta),rowIndex);
      if (data) handle.cache.set(rowIndex,data);
    }
    data.rowid=rowIndex;
    return data;
  }
  handle.mapRow = function (rowIndex,keys) {
    var row = this.getRow(rowIndex);
    if (!row) return;
    keys = keys || Object.keys(this.meta.schema);
    // print(row,keys)
    return self.map2sql(handle,rowIndex,row,keys);
  }
  return handle;
}

// Compile an SQL query and return a handler
Database.prototype.compileQuery = function (query) {
  var ast     = parser(query).statement[0],
      table   = ast.from && ast.from.name,
      handle  = this.handle(table),
      keys    = handle?Object.keys(handle.meta.schema):null,
      handler = {};
  if (this.verbose) print(query);

  if (!handle) { this.log('Table '+table+' not found!'); throw "ENOTEXIST" }
  // compare row columns with values 
  function equal(col,val) { 
    return col==val || col=='"'+val+'"'
  }
  // filter rows
  function filter(attr,val) {
    // console.log(attr,val)
    if (handle.meta.table=='sqlite_master') {
      if (attr == 'type' && val=='table') 
        return handle.rows;
      if (attr == 'name') {
        for(var i=0;i<handle.rows.length;i++) {
          var row = handle.getRow(handle.rows[i].rowid);
          if (row && equal(row[attr],val)) return [handle.rows[i]];
        }      
      }
    }
    if (handle.meta.table=='sqlite_master' && attr == 'type' && val=='table') 
        return handle.rows; // sqloite_master?
    if (handle.reference) {
      // static wrapper table;
      // search all rows 
      for(var i=0;i<handle.rows.length;i++) {
        var row = handle.getRow(handle.rows[i].rowid);
        if (row && equal(row[attr],val)) return [handle.rows[i]];
      }
    }
  }
  var primaryKey='id';    // TODO
  
  function identifier(expr) {
    if (expr.type=='identifier') return expr.name;
  }
  
  // where expr evaluator (selecting rows)
  function expr(node) {
    switch (node.type) {
      case 'expression':
        switch (node.operation) {
          case '=':
            var id=expr(node.left);
            if (id=='row' || id=='rowid' || id==primaryKey) return [handle.getRow(Number(expr(node.right)))];
            if (handle.meta.schema[id]) {
              // unique==indexing key?
              if (/unique/.test(handle.meta.schema[id].type)) {
                return [expr(node.right)];
              } else {
                return filter(id,expr(node.right)); // TODO
              }
            }
            break;
          case '<':
          case '>':
          case '<=':
          case '>=':
            // TODO: ranges: rowid >= a and rowid <= b will not be handled efficiently
            // for large index tables!
            // assumption: rowid=rows.index+1
            var id=expr(node.left);
            if (id=='row' || id=='rowid' || id==primaryKey) {
              // should return { first,last } 
              var limit=Number(expr(node.right));
              switch (node.operation) {
                case '<': return handle.rows.filter(function (row) { return row.rowid < limit });
                case '>': return handle.rows.filter(function (row) { return row.rowid > limit });
                case '<=': return handle.rows.filter(function (row) { return row.rowid <= limit });
                case '>=': return handle.rows.filter(function (row) { return row.rowid >= limit });
              }
            }
            break;
        }
        break;
      case 'identifier':
        return node.name
        break;
      case 'literal':
        return node.value
        break;
    }
  }
  if (ast.type=='statement') {
    // print('statement',ast.variant)
    // print(inspect(ast,null,16));
    switch (ast.variant) {
      case 'select':
// console.log(ast.result);
        if (ast.result && ast.result[0].type=='identifier') {
          handler={
            each : function (callback) {
              var cols = keys,
                  rows = handle.rows; // All rows
              if (ast.result) {
                if (ast.result[0].variant != 'star') {
                  // columns selection
                  cols = ast.result.map(function (col) {
                    return col.name;
                  });
                }
              }
              if (ast.where) {
                rows=expr(ast.where[0]);
              }
  //print('select -> rows',rows,cols);
              if (rows) for(var index=0;index<rows.length;index++) {
              // console.log(index,row)
                var row = rows[index];
                row     = handle.mapRow(row.rowid,cols);
                var obj = {};
                cols.forEach(function (col,index) { obj[col]= row[index] });
  //print(row) 
                callback(obj);   
              };
            }
          }
        } else if (ast.result && ast.result[0].type=='function' && identifier(ast.result[0].name)=='count') {
          handler={
            each : function (callback) {
              var count=0,
                  rows = handle.rows; // All rows;
              if (ast.where) {
                rows=expr(ast.where[0]);
              }
              if (rows) count=rows.length;
              callback(count);
            }
          }
        }
        break;
    }
  }
  return handler;
}

Database.prototype.compileSchema = function (schema) {
  var schemaSQL={};
  for(var key in schema) {
    if (typeof schema[key] == 'object')
      schemaSQL[key]={type:'char[]',value:'',struct:schema[key]};  
    else {
      var tv = schema[key].split('=');
      if (tv.length==1)
        schemaSQL[key]={type:schema[key],value:''};
      else
        schemaSQL[key]={type:tv[0],value:tv[1]};
    } 
  }
  return schemaSQL;
}

Database.prototype.handle = function (table) {
  return this.handleHash[table];
}


var io  = {
  // create a key-value cache
  cache : function (entries,volume) {
    return cache({   // dynamic table with external data
      limit   : entries||100,
      volume  : volume||64E6,
      maxTTL  : 120000,
      buckets : 4,
    })  
  },
  // data conversion
  convert : {
    // convert RGBA image data
    toRGB8 : function (image) {
      var size = image.width*image.height,
          buf8 = Buffer(size*3),
          imgData = image.data;
      for(var i=0;i<size;i++) {
        var r=imgData[i*4],
            g=imgData[i*4+1],
            b=imgData[i*4+2],
            a=imgData[i*4+3]/255,
            r2=255,g2=255,b2 = 255;
        var r3 = Math.round(((1 - a) * r2) + (a * r))
        var g3 = Math.round(((1 - a) * g2) + (a * g))
        var b3 = Math.round(((1 - a) * b2) + (a * b))
        buf8[i*3]=r3;
        buf8[i*3+1]=g3;
        buf8[i*3+2]=b3;
      }
      return {
        width:image.width,
        height:image.height,
        data:buf8,
        type:'RGB8',
      }    
    },
    toGRAY8 : function (image) {
      var size = image.width*image.height,
          buf8 = Buffer(size),
          imgData = image.data;
      for(var i=0;i<size;i++) {
        var r=imgData[i*4],
            g=imgData[i*4+1],
            b=imgData[i*4+2],
            a=imgData[i*4+3]/255,
            r2=255,g2=255,b2 = 255;
        var r3 = Math.round(((1 - a) * r2) + (a * r))
        var g3 = Math.round(((1 - a) * g2) + (a * g))
        var b3 = Math.round(((1 - a) * b2) + (a * b))
        buf8[i]=Math.round((r3+g3+b3)/3);
      }
      return {
        width:image.width,
        height:image.height,
        data:buf8,
        type:'GRAY8',
      }
    }
  },
  // list filtering
  filter : function (list,expr) {
    expr=expr.replace(/\./g,'\\.').replace(/\*/g,'.+');
    expr='^'+expr+'$';
    var re = new RegExp(expr)
    return list.filter(function (entry) {
      return re.test(entry);
    })
  },
  // list directory
  list : function (path,kind) {
    try {
      var entries = fs.readdirSync(path);
      if (entries) entries=entries.map(function (name) {
        var stat = fs.statSync(path+'/'+name),
            extension = name.match(/\.([a-zA-Z0-9]+)$/);
        if (stat.isDirectory()) return { dir:name };
        else return {
          file : name,
          size : stat.size,
          ext  : extension && extension[1]
        }
      })
      if (!kind) return entries;
      else return entries.filter(function (entry) {
        return entry[kind]!=undefined
      });
    } catch (e) { return  [] }
  },
  // Open one file for reading, extract index table (lines/rows), extract header
  open : {
    csv : function (file,header,separator) {
      var index = [],fd=fs.openSync(file,'r');
      // find \n
      var first=Buffer(512000),b = Buffer(512), offset=0, n=1, start=0;
      while (n) {
        var chunk;
        n=fs.readSync(fd,b,0,512, offset);
        if (n<512) chunk=b.slice(0,n); //.toString();
        else chunk=b; // .toString();
        for(var i=0;i<chunk.length;i++) switch (chunk[i]) {
          case 0x0d: 
          case 0x0a:
            if ((offset+i) == start) { start++; continue; } // 0D 0A or vice versa pair 
            end=offset+i-1; 
            index.push([start,end]);
            if ((index.length % 500)==0) this.log(index.length);
            start=offset+i+1;  
            // if (chunk[i+1]=='0x0d' || chunk[i+1]=='0x0a') { i++; start++; }
            break;
          default:
            if (index.length==0) first[offset+i] = chunk[i]; break;
        }
        offset += chunk.length;
      }
      // no EOL at end of file?
      if (start < offset+i) {
        index.push([start,offset+i]); 
      }
      // Is first line the column header?
      if (!header) {
        header = index.shift();
        header = io.parse.csv(first.slice(0,header[1]+1).toString(),separator);
      }
      return { index:index, header:header, fd:fd }
    }  
  },
  parse : {
    // one row!
    csv :  function (text,separator) {
      var o;
      function unwrap(s) {
        return s.replace(/"/g,'')
      }
      try {
        o=text.split(separator||',').map(unwrap);
      } catch (e) { };
      return o;
    }
  },
  // read one file
  read : {
    png : function (file,format,matrix) {
      var output,data = fs.readFileSync(file); 
      var img = image.png.decode(data);
      var rgba = image.png.toRGBA8(img)[0];
       switch (format) {
        case 'GRAY8':
          data=io.convert.toGRAY8({width:img.width,height:img.height,data:rgba}).data;
          output=matrix?Math.MatrixTA({
            dataspace:[img.width,img.height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:21
          }):data;
          break;
        case 'RGBA':
          data=rgba;
          output=matrix?Math.MatrixTA({
            dataspace:[4,img.width,img.height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:321
          }):data;
          break;        
        case 'RGB':
        case 'RGB8':
        default:
          data=io.convert.toRGB8({width:img.width,height:img.height,data:rgba}).data;
          output=matrix?Math.MatrixTA({
            dataspace:[3,img.width,img.height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:321
          }):data;
       }
       return  {
          width   : img.width,
          height  : img.height,
          data    : output,
      }
      return;
    },
    tiff : function (file,format,matrix) {
      var data,output;
      data = fs.readFileSync(file); 
      var ifd = image.tiff.decode(data);
      image.tiff.decodeImage(data,ifd[0]);
      if (!ifd[0].width || !ifd[0].height) return Error("TIFF decoding failed");
      switch (format) {
        case 'Int16':
        case 'INT16':
          data=ifd[0].data;
          output=matrix?Math.MatrixTA({
            rows:ifd[0].height, 
            columns:ifd[0].width, 
            datatype:'Int16',
            data:data,
            layout:12
          }):data;
          break;
        case 'GRAY8':
          data=image.tiff.toGRAY8(ifd[0]);
          output=matrix?Math.MatrixTA({
            dataspace:[ifd[0].width,ifd[0].height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:21
          }):data;
          break;
        case 'RGB':
        case 'RGB8':
        default:
          data=image.tiff.toRGB8(ifd[0]);
          output=Math.MatrixTA({
            dataspace:[3,ifd[0].width,ifd[0].height], // width/height order correct?
            datatype:'Uint8',
            data:data,
            layout:321
          });
      }
      return {width:ifd[0].width,height:ifd[0].height,data:output};
    }
  }
}
Database.prototype.io = io;

Database.prototype.log = function (msg) {
  print('[SQLVFS2] '+msg);
}
Database.prototype.map2sql = function (handle,index,row,keys) {
  var self=this,
      meta=handle.meta,
      schema=meta.schema;
  function mapRowElement(row,key) {
    var typ = schema[key].type;
    if (row[key]==undefined && schema[key].value!=undefined) row[key]=schema[key].value;
    if (typeof row[key] == 'number' ||
        typeof row[key] == 'string') return row[key];
    if (/char|text/.test(typ)) return JSON.stringify(row[key]);
    if (/blob/.test(typ)) {
      return row[key].data?Buffer(row[key].data.buffer):Buffer(row[key]);
    }
  }
  return keys.map(function (key) { 
    return mapRowElement(row,key,meta.schema) 
  });
}
Database.prototype.prepare = function (cmd) {
  return this.compileQuery(cmd);
}

Database.prototype.pragma = function (cmd) {
 
}

// Create a SQL schema table signature
Database.prototype.schemaSQL = function (meta) {
  var schema=[];
  for(var key in meta.schema) {
    schema.push(key+' '+meta.schema[key].type);
  }
  return '('+schema.join(',')+')';
}

Database.prototype.tableInfo = function (table) {
  var handle  = this.handle(table);
  if (!handle) return table+':ENOTEXIST';
  return table+'['+handle.rows.length+']:'+this.schemaSQL(handle.meta);
}

module.exports = Database;
};
BundleModuleCode['cap.js']=function (module,exports){
// TODO String/Array extensions from compat

Capability = {
  /**
   *
   * typeof @port_valse = number [] 
   * typeof return = string
   */
  Port : function (port_vals) {
      if (port_vals==undefined) port_vals=[0,0,0,0,0,0];
      var port='';
      for(var i = 0; i< Capability.PORT_SIZE;i++) {
          port=port+String.fromCharCode(port_vals[i]);
      }
      return port;

  },
  /**
   *
   * typeof @obj = number | undefined
   * typeof @rights = number | undefined
   * typeof @rand = port | undefined
   * typeof function = constructor
   */
  Private : function (obj,rights,rand) {
      if (obj==undefined) {
          // Create empty private field
        return {
            prv_obj : 0,
            prv_rights : 0,
            prv_rand : Capability.Port()
        }
      } else {
        return {
          prv_obj : obj,               // Integer
          prv_rights : rights,         // Integer
          prv_rand : rand              // Port=string
        }
      }
  },

  /**
   *
   * typeof @cap_port = port
   * typeof @cap_priv = privat
   * typeof function = @constructor
   */
  Capability : function(cap_port, cap_priv) {
      if (cap_port==undefined) {
          // Create empty capability
          return {
            cap_port : Capability.Port(),
            cap_priv : Capability.Private()
          }
      } else {
          return {
            cap_port : cap_port,      // Port=string
            cap_priv : cap_priv?cap_priv:Capability.Private()
          }
      }
  },
  cap_parse : function (str,offset) {
      var cap=Capability.Capability(),
          pos=0;
      if (offset!=undefined) pos=offset;
      var pp=Capability.port_parse(str,pos);
      if (pp==undefined) return undefined;
      cap.cap_port=pp.port;
      pos=pp.pos;
      pp=Capability.prv_parse(str,pos);
      if (pp==undefined) return undefined;
      cap.cap_priv=pp.priv;
      pos=pp.pos;
      return {cap:cap,pos:pos};
  },

  cap_of_string : function (str) { var pp = Capability.cap_parse(str,0); return pp?pp.cap:undefined },

  cap_to_string : function (cap) {
      var str='';
      if (cap==undefined) return 'undefined';
      if (cap.cap_port!=undefined) str='['+Capability.port_to_string(cap.cap_port)+']'; else str = '[]';
      if (cap.cap_priv!=undefined) str=str+'('+Capability.prv_to_string(cap.cap_priv)+')'; else str=str+'()';
      return str;
  },

  /*
   ** Utils to get and set single bytes of a port
   */
  get_portbyte : function (port,i) {
      return port.charCodeAt(i); // String.fromCharCode(String.get(port,i))
  },
  set_portbyte : function (port,i,byte) {
      return String.set(port, i, (String.fromCharCode(byte)));
  },

  /*
   ** Encryption function
   */
  one_way : function (port) {
      var key = Array.create(64,0);
      var block = Array.create(48,0);
      var pubport = String.create (Capability.PORT_SIZE,'\0');
      var i, j, k;

      /*
      ** We actually need 64 bit key.
      ** Throw some zeroes in at bits 6 and 7 mod 8
      ** The bits at 7 mod 8 etc are not used by the algorithm
      */
      j=0;
      for (i = 0; i< 64; i++) {
          if ((i & 7) > 5)
              key[i] = 0;
          else {
              if ((Capability.get_portbyte(port, (j >> 3)) & (1 << (j & 7))) != 0)
                  key[i] = 1;
              else
                  key[i] = 0;
              j++;
          }
      }

      Des48.des_OWsetkey(key);
      /*
      ** Now go encrypt constant 0
      */
      block=Des48.des_OWcrypt48(block);


      /*
      ** and put the bits in the destination port
      */
      var pb = 0;

      for (i = 0; i < Capability.PORT_SIZE;i++) {
          var pbyte = 0;
          for (j = 0; j < 8; j++) {
              pbyte = pbyte | (block[pb] << j);
              pb++;
          }
          pubport=Capability.set_portbyte(pubport, i, pbyte);
      }
      return pubport;
  },

  pad : function (str,size) {
      while (str.length < (size || 2)) {str = "0" + str;}
      return str;
  },

  port_cmp : function (port1,port2) {
    return port1==port2;
  },

  port_copy : function (port) {
      return String.copy(port);
  },

  // Expected format: XX:XX:XX:XX:XX
  port_of_string : function (str,compact) {
      var tokens=str.split(':'),i,port='';
      for (i=0;i<Capability.PORT_SIZE;i++) {
          var num='0x'+tokens[i];
          port=port+String.fromCharCode(parseInt(num,16));
      }
      return port;
  },

  port_of_name : function (str) {
    var portvals = [0,0,0,0,0,0];
    for (var i=0;i<str.length;i++) {
      var d = str.charCodeAt(i);
      portvals[i % Capability.PORT_SIZE] = (portvals[i % Capability.PORT_SIZE]+d) & 0xff;
    }
    var port=""
    for (i=0;i<Capability.PORT_SIZE;i++) {
      port += String.fromCharCode(portvals[i]);
    }
    return port;
  },
  
  port_parse : function (str,pos) {
      var port='';
      var len=str.length;
      if (pos==undefined) pos=0;
      if (len<(pos+17)) return undefined;
      if (str[pos]=='[') pos++;
      for(var i=0;i<6;i++) {
          var sv='0x'+str[pos]+str[pos+1];
          port=port+String.fromCharCode(parseInt(sv));
          pos=pos+2;
          if (str[pos]==':') pos++;
      }
      if (str[pos]==']') pos++;
      return {port:port,pos:pos};
  },

  port_to_string : function (port,compact) {
      var i,str='';
      if (port) {
          for (i = 0; i < Capability.PORT_SIZE; i++) {
              var num = port.charCodeAt(i); // String.fromCharCode(String.get(port, i));
              if (!compact && i > 0) str = str + ':';
              str = str + Capability.pad(num.toString(16).toUpperCase(), 2);
          }
      } else str='undefined';
      return str;
  },

  priv2pub_cache : [],
  
  prv2pub : function  (port) {
      var putport;
      if (Capability.priv2pub_cache[port] == undefined) {
          putport=Capability.one_way(port);
          Capability.priv2pub_cache[port] = putport;
      } else putport = Capability.priv2pub_cache[port];
      return putport;
  },

  prv_cmp : function (prv1,prv2) {
   return  (prv1==undefined&&prv2==undefined) ||
           (prv1.prv_obj==prv2.prv_obj &&
            prv1.prv_rights==prv2.prv_rights &&
            Capability.port_cmp(prv1.prv_rand,prv2.prv_rand))
  },

  /**
   ** Decode a private structure (check for a valid private field)
   *
   * typeof @prv =  privat
   * typeof @rand = port
   * returns boolean
   */
  prv_decode : function  (prv,rand) {
      if (prv.prv_rights == Capability.PRV_ALL_RIGHTS)
          return Capability.port_cmp(prv.prv_rand,rand);
      else {
          var tmp_port = Capability.port_copy(rand),
              pt0 = Capability.get_portbyte(tmp_port, 0),
              pr0 = prv.prv_rights;
          tmp_port = Capability.set_portbyte(tmp_port, 0, (pt0 ^ pr0));
          tmp_port = Capability.one_way(tmp_port);
          return Capability.port_cmp(prv.prv_rand, tmp_port)
      }
  },

  /*
   ** Encode a private part from the object number, the rights field
   ** and the random port.
   ** Returns the created private structure.
   */
  prv_encode : function (obj,rights,rand) {
      var tmp_port = Capability.port_copy(rand),
          r1 = rights,
          rmask = Capability.PRV_ALL_RIGHTS;

      if (rights == Capability.PRV_ALL_RIGHTS)
          return Capability.Private(obj,r1 & rmask,tmp_port);
      else {
          var pt0 = Capability.get_portbyte(tmp_port,0);
          tmp_port = Capability.set_portbyte(tmp_port,0,pt0 ^ r1);
          tmp_port = Capability.one_way(tmp_port);
          return Capability.Private(obj,r1 & rmask,tmp_port)
      }
  },

  prv_of_string : function (str) { var pp=Capability.prv_parse(str,0); return pp?pp.priv:undefined },

  /*
   ** Return the private object number form a private structure
   */
  prv_number : function (prv) {
      return prv.prv_obj;
  },

  // Expected format: obj(right)[port]
  prv_parse : function (str,offset) {
      var priv=Capability.Private();
      var sv;
      var len=str.length,pos=offset;
      if (str[pos]=='(') pos++;
      sv='';
      while(str[pos]!='(') {
          sv=sv+str[pos];
          pos++;
      }
      priv.prv_obj=parseInt(sv);
      sv='';
      if (str[pos]=='(') pos++;
      while(str[pos]!=')') {
          sv=sv+str[pos];
          pos++;
      }
      priv.prv_rights=parseInt('0x'+sv);
      if (str[pos]==')') pos++;
      var pp=Capability.port_parse(str,pos);
      if (pp==undefined) return undefined;
      priv.prv_rand=pp.port;
      pos=pp.pos;
      return {priv:priv,pos:pos};
  },


  prv_to_string : function (priv) {
      var str='';
      if (priv==undefined) return 'undefined';
      str=priv.prv_obj;
      str=str+'('+String.hex(priv.prv_rights,2).toUpperCase()+')[';
      str=str+Capability.port_to_string(priv.prv_rand)+']';
      return str;
  },

  /** Restrict a private field (rights&mask) of a capability.
   *
   * @param {privat} priv
   * @param {number} mask rights restriction mask
   * @param {port} random secret server random port
   */
  prv_restrict: function (priv,mask,random) {
      var pr = Capability.prv_encode(priv.prv_obj,
                          priv.prv_rights & mask,
                          random);
      return pr;
  },
  /*
   ** Return the private rights field.
   */
  prv_rights: function (prv) {
      return prv.prv_rights & Capability.PRV_ALL_RIGHTS;
  },
  /*
   ** Check the private rights field: 1. Validation, 2: Required rights.
   */
  prv_rights_check : function (prv,rand,required) {
    if (!Capability.prv_decode(prv,rand)) return false;
    return (prv.prv_rights & required)==required;
  },

  /*
   * Return a new random unique port.
   *
   * Warning: the quality of the random ports are strongly
   * related to JSVMs underlying random generator.
   *
   * typeof return = port
   */
  uniqport: function () {
      var port = String.create (Capability.PORT_SIZE,0);
      var i,values;

      do {
        values = Rnd.generate({number:true,length:Capability.PORT_SIZE});
        for (i = 0; i <= (Capability.PORT_SIZE - 1); i++) 
          port = String.set(port, i, (String.fromCharCode(values[i])));
        if (Capability.uniquePorts[port]) Capability.uniquePorts[port]++;
        else Capability.uniquePorts[port]=1;
      } while (Capability.uniquePorts[port]>1);
      return port;
  },

  PORT_SIZE : 6,
  PRIVSIZE : 24,
  CAP_SIZE : 16,
  PRV_ALL_RIGHTS : 0xff,

  priv2pub_cache : [],
  uniquePorts : {},

}


Capability.Port.equal = Capability.port_cmp
Capability.Port.toString = Capability.port_to_string
Capability.Port.ofString = Capability.port_of_string
Capability.Port.ofName = Capability.port_of_name
Capability.Port.prv2pub = Capability.prv2pub
Capability.Port.random = Capability.uniqport
Capability.Port.unique = Capability.uniqport
Capability.Private.decode = Capability.prv_decode
Capability.Private.encode = Capability.prv_encode
Capability.Private.equal = Capability.prv_cmp
Capability.Private.number = Capability.prv_number
Capability.Private.ofString = Capability.prv_of_string
Capability.Private.restrict = Capability.prv_restrict
Capability.Private.rights = Capability.prv_rights
Capability.Private.rights_check = Capability.prv_rights_check
Capability.Private.toString = Capability.prv_to_string
Capability.Capability.toString = Capability.cap_to_string
Capability.Capability.ofString = Capability.cap_of_string

Crypto = (function () {
  var globalScope;
  if ("undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope) globalScope=self;
  else if ("object" == typeof window) globalScope=window;
  else if ("object" == typeof global) globalScope=global;
  
  var crypto = globalScope.crypto || globalScope.msCrypto;

  if (!crypto && typeof require != 'undefined') try { crypto=globalScope.crypto=require('require') } catch (e) {};

  var twister;

  var MersenneTwister = function(seed) {
	  if (seed == undefined) {
          /**
          ** It is not sure that Math.random is seeded randomly
          ** Thus, a combination of current system time and Math.random 
          ** is used to seed and initialize this random generator
          */
		  seed = new Date().getTime();
          seed *= Math.random()*91713;
          seed |= 0;
	  }

	  /* Period parameters */
	  this.N = 624;
	  this.M = 397;
	  this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	  this.mt = new Array(this.N); /* the array for the state vector */
	  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	  if (seed.constructor == Array) {
		  this.init_by_array(seed, seed.length);
	  }
	  else {
		  this.init_seed(seed);
	  }
  }

  /* initializes mt[N] with a seed */
  /* origin name init_genrand */
  MersenneTwister.prototype.init_seed = function(s) {
	  this.mt[0] = s >>> 0;
	  for (this.mti=1; this.mti<this.N; this.mti++) {
		  var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		  this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		  + this.mti;
		  /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		  /* In the previous versions, MSBs of the seed affect   */
		  /* only MSBs of the array mt[].                        */
		  /* 2002/01/09 modified by Makoto Matsumoto             */
		  this.mt[this.mti] >>>= 0;
		  /* for >32 bit machines */
	  }
  }

  /* initialize by an array with array-length */
  /* init_key is the array for initializing keys */
  /* key_length is its length */
  /* slight change for C++, 2004/2/26 */
  MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	  var i, j, k;
	  this.init_seed(19650218);
	  i=1; j=0;
	  k = (this.N>key_length ? this.N : key_length);
	  for (; k; k--) {
		  var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
		  this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		  + init_key[j] + j; /* non linear */
		  this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		  i++; j++;
		  if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		  if (j>=key_length) j=0;
	  }
	  for (k=this.N-1; k; k--) {
		  var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		  this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		  - i; /* non linear */
		  this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		  i++;
		  if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	  }

	  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
  }

  /* generates a random number on [0,0xffffffff]-interval */
  /* origin name genrand_int32 */
  MersenneTwister.prototype.random_int = function() {
	  var y;
	  var mag01 = new Array(0x0, this.MATRIX_A);
	  /* mag01[x] = x * MATRIX_A  for x=0,1 */

	  if (this.mti >= this.N) { /* generate N words at one time */
		  var kk;

		  if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			  this.init_seed(5489);  /* a default initial seed is used */

		  for (kk=0;kk<this.N-this.M;kk++) {
			  y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			  this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		  }
		  for (;kk<this.N-1;kk++) {
			  y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			  this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		  }
		  y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		  this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		  this.mti = 0;
	  }

	  y = this.mt[this.mti++];

	  /* Tempering */
	  y ^= (y >>> 11);
	  y ^= (y << 7) & 0x9d2c5680;
	  y ^= (y << 15) & 0xefc60000;
	  y ^= (y >>> 18);

	  return y >>> 0;
  }

  /* generates a random number on [0,0x7fffffff]-interval */
  /* origin name genrand_int31 */
  MersenneTwister.prototype.random_int31 = function() {
	  return (this.random_int()>>>1);
  }

  /* generates a random number on [0,1]-real-interval */
  /* origin name genrand_real1 */
  MersenneTwister.prototype.random_incl = function() {
	  return this.random_int()*(1.0/4294967295.0);
	  /* divided by 2^32-1 */
  }

  /* generates a random number on [0,1)-real-interval */
  MersenneTwister.prototype.random = function() {
	  return this.random_int()*(1.0/4294967296.0);
	  /* divided by 2^32 */
  }

  /* generates a random number on (0,1)-real-interval */
  /* origin name genrand_real3 */
  MersenneTwister.prototype.random_excl = function() {
	  return (this.random_int() + 0.5)*(1.0/4294967296.0);
	  /* divided by 2^32 */
  }

  /* generates a random number on [0,1) with 53-bit resolution*/
  /* origin name genrand_res53 */
  MersenneTwister.prototype.random_long = function() {
	  var a=this.random_int()>>>5, b=this.random_int()>>>6;
	  return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  function polyfill () {
    twister = new MersenneTwister(); // (Math.random()*Number.MAX_SAFE_INTEGER)|0)
    if (!crypto) crypto=globalScope.crypto={};
    crypto.getRandomValues = function getRandomValues (abv) {
      var l = abv.length
      while (l--) {
        abv[l] = Math.floor(twister.random() * 256)
      }
      return abv
    }
    if (!globalScope.Uint8Array && !Uint8Array) throw new Error('crypto.rand: No Uint8Array found!');
    if (!globalScope.Uint8Array) globalScope.Uint8Array=Uint8Array;
  }


  function randomByte (min,max) {
    if (!twister) twister = new MersenneTwister();
    return Math.floor(twister.random() * (max-min))+min;
  }

  function randomBytes (size, cb) {
    // phantomjs needs to throw
    if (size > 65536) throw new Error('requested too many random bytes')
    if (!crypto || !crypto.getRandomValues) polyfill();

    // in case browserify  isn't using the Uint8Array version
    var rawBytes = new globalScope.Uint8Array(size);
    // This will not work in older browsers.
    // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
    if (size > 0) {  // getRandomValues fails on IE if size == 0
      crypto.getRandomValues(rawBytes);
    }
    // phantomjs doesn't like a buffer being passed here
    var bytes = new Buffer(rawBytes);
    if (typeof cb === 'function') {
      cb(null, bytes)
    }

    return bytes
  } 

  return {
    randomByte:randomByte,
    randomBytes:randomBytes
  }
})();

Des48 = (function () {
  
  const des_HBS = 24;
  const des_BS = des_HBS * 2;


  /*
  ** Initial permutation,
  */

  var des_IP = [
      23, 27, 34, 44, 37, 17, 12, 42,
      3, 32, 41, 29, 20,  2,  1, 10,
      0, 28, 40,  6,  7, 11, 16,  8,
      25, 30, 14, 26, 47, 38, 19, 43,
      18,  5, 35, 39, 36, 21,  4, 45,
      24, 22, 13, 33, 31,  9, 15, 46 ];

  /*
  ** Final permutation, FP = IP^(-1)
  */

  var des_FP = [
      16, 14, 13,  8, 38, 33, 19, 20,
      23, 45, 15, 21,  6, 42, 26, 46,
      22,  5, 32, 30, 12, 37, 41,  0,
      40, 24, 27,  1, 17, 11, 25, 44,
      9, 43,  2, 34, 36,  4, 29, 35,
      18, 10,  7, 31,  3, 39, 47, 28 ];

  /*
  ** Permuted-choice 1 from the key bits
  ** to yield C and D.
  ** Note that bits 8,16... are left out:
      ** They are intended for a parity check.
  */

  var des_PC1_C = [
      57,49,41,33,25,17, 9,
      1,58,50,42,34,26,18,
      10, 2,59,51,43,35,27,
      19,11, 3,60,52,44,36 ];

  var des_PC1_D = [
      63,55,47,39,31,23,15,
      7,62,54,46,38,30,22,
      14, 6,61,53,45,37,29,
      21,13, 5,28,20,12, 4 ];


  /*
  ** Sequence of shifts used for the key schedule.
  */

  var des_shifts = [
      1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 ];



  /*
  ** Permuted-choice 2, to pick out the bits from
  ** the CD array that generate the key schedule.
  */

  var des_PC2_C = [
      14,17,11,24, 1, 5,
      3,28,15, 6,21,10,
      23,19,12, 4,26, 8,
      16, 7,27,20,13, 2 ];

  var des_PC2_D = [
      41,52,31,37,47,55,
      30,40,51,45,33,48,
      44,49,39,56,34,53,
      46,42,50,36,29,32 ];

  /*
  ** The C and D arrays used to calculate the key schedule.
  */


  var des_C = Array.create(56,0);
  // des_D = des_C[28]
  var des_D_get = function (i) {return des_C[i+28]};
  var des_D_set  =  function (i,sval) { des_C[i+28] = sval };

  /*
  ** The key schedule.
  ** Generated from the key.
  */

  var des_KS= Array.matrix(16,48,0);

  var des_OWsetkey = function(key) {
      var ks = [];
      var t = 0;
      var i,j,k;
      /*
      ** First, generate C and D by permuting
      ** the key.  The low order bit of each
      ** 8-bit char is not used, so C and D are only 28
      ** bits apiece.
      */

      for(i = 0;i < 28;i++) {

          var index1 = des_PC1_C[i] - 1;
          var index2 = des_PC1_D[i] - 1;

          des_C[i] = key[index1];
          des_D_set(i,key[index2]);
      }

      /*
      ** To generate Ki, rotate C and D according
      ** to schedule and pick up a permutation
      ** using PC2.
      */


      for (i = 0 ;i< 16;i++) {

          ks = des_KS[i];

          // rotate
          for (k = 0; k < des_shifts[i]; k++) {
              t = des_C[0];

              for (j = 0; j < 27; j++) {
                  des_C[j] = -des_C[j + 1];
              }

              des_C[27] = t;
              t = des_D_get(0);

              for (j = 0; j < 27; j++) {
                  des_D_set(j, des_D_get(j + 1));
              }
              des_D_set(27, t);
          }

          /*
           ** get Ki. Note C and D are concatenated.
           */

          for (j = 0; j < 24; j++) {
              ks[j] = des_C[des_PC2_C[j] - 1];
              ks[j + 24] = des_D_get(des_PC2_D[j] - 28 - 1);
          }

      }
  };


  /*
  ** The E bit-selection table.
  */

  var des_E = [
      22, 15, 12,  3,  8,  2, 23, 16,
      14, 13,  9, 10,  0,  1, 21, 19,
      18,  6, 11,  7, 17,  4, 20,  5,
      5, 17, 11, 13, 12, 14,  8,  7,
      19, 22, 18,  9,  3,  4,  1,  6,
      16,  2, 20, 15, 10, 23,  0, 21 ];


  /*
  ** The 8 selection functions.
  ** For some reason, they give a 0-origin
  ** index, unlike everything else.
  */

  var des_S = [
      [ 14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
      0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
      4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
      15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13 ],

      [ 15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10,
      3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5,
      0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15,
      13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9 ],

      [ 10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8,
      13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1,
      13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7,
      1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12 ],

      [ 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15,
      13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9,
      10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4,
      3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14 ],

      [ 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9,
      14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6,
      4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14,
      11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3 ],

      [ 12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11,
      10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8,
      9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6,
      4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13 ],

      [ 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1,
      13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6,
      1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2,
      6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12 ],

      [ 13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7,
      1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2,
      7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8,
      2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11 ]
      ];


  /*
  ** P is a permutation on the selected combination
  ** of the current L and key.
  */

  var des_P = [
      3, 13,  9, 12,  8, 20, 21,  7,
      5, 23, 16,  1, 14, 18,  4, 15,
      22, 10,  2,  0, 11, 19, 17,  6 ];

  var des_L = Array.create(des_BS,0);
  var des_R_get = function (i) { return des_L[(i+des_HBS)]};
  var des_R_set = function (i,sval) { des_L[i+des_HBS]= sval};
  var des_tempL = Array.create(des_HBS,0);
  var des_f = Array.create (32,0);

  /*
  ** Warning!!
  **
  ** f[] used to be HBS for some years.
  ** 21/6/1990 cbo and sater discovered that inside the loop where f is computed
  ** indices are used from 0 to 31. These overlapped the preS array which is
  ** declared hereafter on all compilers upto that point, but only those
  ** values that were not used anymore. But the values of f are only used
  ** upto HBS. Makes you wonder about the one-way property.
  ** Then came ACK, and reversed the order of the arrays in the image.
  **
  ** As a short term solution f[] was increased to 32, but in the long run
  ** someone should have a good look at our "oneway" function
  */

  /*
  ** The combination of the key and the input, before selection.
  */
  var des_preS = Array.create (48,0);

  /*
  ** The payoff: encrypt a block. (Now 48 bytes, 1 bit/byte)
  */

  var des_OWcrypt48 = function(block) {
      var ks = [];
      var t1 = 0;
      var t2 = 0;
      var i, j, k;
      /*
       ** First, permute the bits in the input
       */

      for (j = 0; j <= (des_BS - 1); j++) {
          des_L[j] = block[des_IP[j]];
      }
      /*
       ** Perform an encryption operation 16 times.
       */

      for (i = 0; i <= 15; i++) {
          ks = des_KS[i];

          /*
           ** Save the R array,
           ** which will be the new L.
           */

          for (j = 0; j < (des_HBS - 1); j++) {
              des_tempL[j] = des_R_get(j);
          }
          /*
           ** Expand R to 48 bits using the E selector;
           ** exclusive-or with the current key bits.
           */

          for (j = 0; j <= 47; j++) {
              des_preS[j] = (des_R_get(des_E[j])) ^ ks[j];
          }

          /*
           ** The pre-select bits are now considered
           ** in 8 groups of 6 bits each.
           ** The 8 selection functions map these
           ** 6-bit quantities into 4-bit quantities
           ** and the results permuted
           ** to make an f(R, K).
           ** The indexing into the selection functions
           ** is peculiar; it could be simplified by
           ** rewriting the tables.
           */

          t1 = 0;
          t2 = 0;

          for (j = 0; j <= 7; j++) {
              var sind2 =
                  ((des_preS[t1 + 0] << 5) & 0xff) +
                  ((des_preS[t1 + 1] << 3) & 0xff) +
                  ((des_preS[t1 + 2] << 2) & 0xff) +
                  ((des_preS[t1 + 3] << 1) & 0xff) +
                  ((des_preS[t1 + 4] << 0) & 0xff) +
                  ((des_preS[t1 + 5] << 4) & 0xff);

              k = des_S[j][sind2];

              des_f[t2 + 0] = (k >> 3) & 0x1;
              des_f[t2 + 1] = (k >> 2) & 0x1;
              des_f[t2 + 2] = (k >> 1) & 0x1;
              des_f[t2 + 3] = (k >> 0) & 0x1;    // 3 .. 31 !!!

              t1 = t1 + 6;
              t2 = t2 + 4;
          }

          /*
           ** The new R is L ^ f(R, K).
           ** The f here has to be permuted first, though.
           */

          for (j = 0; j < des_HBS; j++) {
              des_R_set(j, (des_L[j] ^ des_f[des_P[j]]));
          }

          /*
           ** Finally, the new L (the original R)
           ** is copied back.
           */

          for (j = 0; j < des_HBS; j++) {
              des_L[j] = des_tempL[j];
          }

      }


      /*
       ** The output L and R are reversed.
       */

      for (j = 0; j < des_HBS; j++) {
          t1 = des_L[j];
          des_L[j] = des_R_get(j);
          des_R_set(j, t1);
      }

      /*
       ** The final output
       ** gets the inverse permutation of the very original.
       */

      for (j = 0; j < des_BS; j++) {
          block[j] = des_L[des_FP[j]];
      }
      return block;
  };

  return {
      des_OWsetkey:des_OWsetkey,
      des_OWcrypt48:des_OWcrypt48
  };
})();


Rnd = {
  generate : function (options) {
  
  function numgen (options) {
    // assuming byte number range 0-255
    var arr = new Uint8Array(options.length||8);
    getRandomValues(arr);
    return arr;
  }
  
  function pwgen (options) {
    var localName, consonant, letter, vowel, pattern = options.pattern,
        char = "", n, i, validChars = [], prefix=options.prefix;
    letter = /[a-zA-Z]$/;
    vowel = /[aeiouAEIOU]$/;
    consonant = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/;
    if (options.length == null) {
      options.length = 10;
    }
    if (pattern == null) {
      pattern = /\w/;
    }
    if (prefix == null) {
      prefix = '';
    }

    // Non memorable passwords will pick characters from a pre-generated
    // list of characters
    if (!options.memorable) {
      for (i = 33; 126 > i; i += 1) {
        char = String.fromCharCode(i);
        if (char.match(pattern)) {
          validChars.push(char);
        }
      }

      if (!validChars.length) {
        throw new Error("Could not find characters that match the " +
          "password pattern " + pattern + ". Patterns must match individual " +
          "characters, not the password as a whole.");
      }
    }


    while (prefix.length < options.length) {
      if (options.memorable) {
        if (prefix.match(consonant)) {
          pattern = vowel;
        } else {
          pattern = consonant;
        }
        n = Crypto.randomByte(33,126); // rand(33, 126);
        char = String.fromCharCode(n);
      } else {
        char = validChars[rand(0, validChars.length)];
      }

      if (options.lowercase) char = char.toLowerCase();
      else if (options.uppercase) char = char.toUpperCase();
      
      if (char.match(pattern)) {
        prefix = "" + prefix + char;
      }
    }
    return prefix;
  };


  function rand(min, max) {
    var key, value, arr = new Uint8Array(max);
    getRandomValues(arr);
    for (key in arr) {
      if (arr.hasOwnProperty(key)) {
        value = arr[key];
        if (value > min && value < max) {
          return value;
        }
      }
    }
    return rand(min, max);
  }


  function getRandomValues(buf) {
    var bytes = Crypto.randomBytes(buf.length);
    buf.set(bytes);
  }
  if (options.number) 
    return numgen(options)
  else
    return pwgen(options);
}};
};
FilesEmbedded['plugins/math/help.md']=function (format){return Base64.decode('JTIzJTIwTWF0aCUwQSUwQSUyMyUyMyUyMFV0aWxzJTBBJTBBTWF0aC5hdmVyYWdlJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBFbGVtZW50LXdpc2UlMjBtZWFuJTIwdmFsdWVzJTBBJTIwJTIwYXJndW1lbnRzJTIwJTNBJTIwJTI4bnVtYmVyJTdDJTdCJTdEJTdDJTVCJTVEJTI5JTIwJTVCJTVEJTBBJTIwJTIwcmV0dXJuJTIwJTIwJTIwJTIwJTNBJTIwbnVtYmVyJTdDJTdCJTdEJTdDJTVCJTVEJTBBJTBBJTIzJTIzJTIwR2VvbWV0cnklMEElMEFNYXRoLmRlbHRhJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBEZWx0YSUyMHZlY3RvciUwQSUyMCUyMHBvaW50MSUyMCUzQSUyMCU1QnglMkN5JTJDLi4lNUQlMEElMjAlMjBwb2ludDElMjAlM0ElMjAlN0J4JTJDeSUyQy4uJTdEJTBBJTIwJTIwcG9pbnQyJTIwJTNBJTIwJTVCeCUyQ3klMkMuLiU1RCUwQSUyMCUyMHBvaW50MiUyMCUzQSUyMCU3QnglMkN5JTJDLi4lN0QlMEElMjAlMjByZXR1cm4lMjAlM0ElMjAlNUIlNUQlMEElMjAlMjByZXR1cm4lMjAlM0ElMjAlN0IlN0QlMEElMEFNYXRoLmRpc3RhbmNlJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBFdWNsaWRpYW4lMjBkaXN0YW5jZSUwQSUyMCUyMHBvaW50MSUyMCUzQSUyMCU1QnglMkN5JTJDLi4lNUQlMEElMjAlMjBwb2ludDElMjAlM0ElMjAlN0J4JTJDeSUyQy4uJTdEJTBBJTIwJTIwcG9pbnQyJTNGJTIwJTNBJTIwJTVCeCUyQ3klMkMuLiU1RCUwQSUyMCUyMHBvaW50MiUzRiUyMCUzQSUyMCU3QnglMkN5JTJDLi4lN0QlMEElMjAlMjByZXR1cm4lMjAlM0ElMjBudW1iZXIlMEElMEFNYXRoLm5lYXJlc3QlMjAlM0ElMjBmdW5jdGlvbiUyMCUyMyUyMEZpbmQlMjBuZWFyZXN0JTIwcG9pbnQlMjBpbiUyMG51bWJlciUyMHNlcmllcyUwQSUyMCUyMHBvaW50cyUyMCUzQSUyMG51bWJlciUyMCU1QiU1RCUwQSUyMCUyMHZhbHUlMjAlMjAlMjAlM0ElMjBudW1iZXIlMEElMjAlMjBlcHNpbG9uJTNGJTIwJTNBJTIwbnVtYmVyJTBBJTIwJTIwcmV0dXJuJTIwJTNBJTIwJTdCJTIweCUzQWluZGV4JTIwbnVtYmVyJTJDJTIweSUzQW51bWJlciUyMCU3RCUwQSUwQSUyMyUyMyUyMFJhbmRvbSUwQSUwQU1hdGgucmFuZG9tJTIwJTNBJTIwZnVuY3Rpb24lMjAlMjMlMjBSYW5kb20lMjBudW1iZXIlMjAlNUIwJTJDMSUyOSUwQSUyMCUyMHJldHVybiUyMCUzQSUyMG51bWJlciUwQSUwQU1hdGgucmFuZG9tLnNlbGVjdCUyMCUzQSUyMGZ1bmN0aW9uJTIwJTIzJTIwUmFuZG9tJTIwc2VsZWN0aW9uJTBBJTIwJTIwY2hvaWNlcyUyMCUzQSUyMCUyN2ElMjAlNUIlNUQlMjAlMEElMjAlMjByZXR1cm4lMjAlM0ElMjAlMjdhJTBBJTBBJTIwJTIwJTBBJTIwJTIwJTBB')};

var Base64=Require('os/base64');
Require('plugins/sql/sqld.js');
