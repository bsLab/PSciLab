var CoreModule = {};
CoreModule['com/io']='com/io.browser';
CoreModule['crypto']='os/crypto';
CoreModule['util']='os/util';
CoreModule['http']='os/http.browser';
CoreModule['url']='os/url';
CoreModule['path']='os/path';
CoreModule['string_decoder']='os/string_decoder';
CoreModule['fs']='';
CoreModule['stream']='';
CoreModule['zlib']='';
CoreModule['dgram']='';
CoreModule['net']='';
CoreModule['child_process']='';
CoreModule['dns']='';
CoreModule['buffer']='os/buffer';

var BundleModuleCode=[];
var BundleObjectCode=[];
var BundleModules = [];
PATH=[".","/home/sbosse/proj/workbook/src"];
if (typeof global == "undefined")  global=(typeof window != "undefined"?window:{})
if (typeof process == "undefined") var process={browser:true};
Require=function(modupath) {
  if (CoreModule[modupath]!=undefined) modupath=CoreModule[modupath];
  if (modupath=='') return undefined;
  if (BundleModules[modupath]) return BundleModules[modupath];
  var exports={}, module={exports:exports};
  if (BundleModuleCode[modupath]) BundleModuleCode[modupath](module,exports,window,process);
  else if (BundleObjectCode[modupath]) BundleObjectCode[modupath](module,exports,window,process);
  else return undefined;
  BundleModules[modupath]=module.exports||module;
  return module.exports||module;};
var FilesEmbedded = {};
var FileEmbedd = function (path,format) {};
var FileEmbedded = function (path,format) {return FilesEmbedded[path](format);};
global.TARGET='browser';
Script=function(){};

BundleModuleCode['os/buffer']=function (module,exports,global,process){
var Ieee754 = Require('os/buffer_ieee754');

/* ------- base64-js -------- */
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}
/* ------- base64-js -------- */

var assert;

exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= {
    ok : function(cond,msg) {
      if (cond != true) {
        console.log('** Assertion failed: '+msg+' **');
        throw Error(msg);
      }
    }
  };
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new TypeError('First argument needs to be a number, ' +
                            'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          // Round-up subject[i] to a UInt8.
          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
          //                                  = 80
          this[i] = ((subject[i] % 256) + 256) % 256;
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var b = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(b)) throw new Error('Invalid hex string');
    this[offset + i] = b;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }
  // TODO
  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return Ieee754.readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  Ieee754.writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
};
BundleModuleCode['os/buffer_ieee754']=function (module,exports,global,process){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};
};
BundleModuleCode['com/io.browser']=function (module,exports,global,process){
    /*
    ************
    ** Browser
    ************
    */

    var tracing = true;
    var stderr_fun = function (str) { console.log(str); };
    var stdout_fun = function (str) { console.log(str); };
    var args=[];

    module.exports = {
        checkOptions : function(options,defaultOptions) {
          return Object.assign({}, defaultOptions||{}, options) },

        checkOption : function (option,defaultOption) { 
          return option==undefined? defaultOption:option },

        config: {
            columns:undefined,
            rows:undefined
        },
        /*
         ** FILE IO
         * TODO WebStorage
         */
        close: function (fd) {
            return;
        },
        exists: function (path) {
            return false;
        },
        open: function (path, mode) {
            var fd = Fs.openSync(path, mode);
            return fd;
        },

        read: function (fd, len, foff) {
            // TODO
        },
        read_file: function (path) {
            return '';
        },

        read_line: function (fd) {
            // TODO
        },
        /**
         *
         * @param fd
         * @param buf
         * @param boff
         * @param len
         * @param [foff]
         * @returns {*}
         */
        read_buf: function (fd, buf, boff, len, foff) {
            return -1;
        },
        sync: function (fd) {
            return;
        },
        
        /**
         *
         * @param fd
         * @param data
         * @param [foff]
         * @returns {*}
         */
        write: function (fd, data, foff) {
            return -1;
        },
        /**
         *
         * @param fd
         * @param buf
         * @param bpos
         * @param blen
         * @param [foff]
         * @returns {*}
         */
        write_buf: function (fd, buf, bpos, blen, foff) {
            return -1;
        },

        /*
         ** CONSOLE IO
         */
        debug: function (msg) {
            stderr_fun('Debug: ' + msg);
        },
        err: function (msg) {
            stderr_fun('Error: ' + msg);
            throw Error(msg);
        },
        fail: function (msg) {
            stderr_fun('Fatal Error: ' + msg);
        },
        inspect: function (obj) {
            return;
        },
        stacktrace: function () {
            var e = new Error('dummy');
            var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                .split('\n');
            stderr_fun('Stack Trace');
            stderr_fun('--------------------------------');
            for(var i in stack) {
                if (i>0) {
                    var line = stack[i];
                    if(line.indexOf('Module.',0)>=0) break;
                    stderr_fun(line);
                }
            }
            stderr_fun('--------------------------------');
        },
        time : function () {
          return Date.now()
        },
        /**
         *
         * @param e
         * @param where
         */
        printstack: function (e,where) {
            if (where==undefined) stderr_fun(e);
            else stderr_fun(where+': '+e);
        },
        /**
         *
         * @param {boolean|string} condmsg conditional message var log=X;  log((log lt. N)||(msg))
         */
        log: function (condmsg) {
            if (condmsg != true) console.warn(condmsg);
        },
        out: function (msg) {
            stdout_fun(msg)
        },
        warn: function (msg) {
            stderr_fun('Warning: ' + msg);
        },


        set_stderr: function(fun) {
            stderr_fun=fun;
        },
        set_stdout: function(fun) {
            stdout_fun=fun;
        },

        stderr: function (msg) {
            stderr_fun(msg);
        },
        stdout: function (msg) {
            stdout_fun(msg);
        },

        /** Write a message with a time stamp written to the trace file.
         *
         * @param {boolean|string} condmsg conditional message var trace=Io.tracing;  trace(trace||(msg))
         */
        trace: function (condmsg) {
            if (condmsg != true && tracefile != undefined) {
                var date = new Date();
                var time = date.getTime();
                this.log('[' + time + '] ' + condmsg + '\n');
            }
        },
        tracing: tracing,
        /**
         *
         * @param {string} path
         */
        trace_open: function (path) {
            return undefined;
        },

        exit: function (n) {
            return;
        },
        /**
         *
         * @returns {*} RSS HEAP in kBytes {data,heap}
         */
        mem: function () {
            return {data:0,heap:0};
        },

        getenv: function (name, def) {
            return def;
        },
        workdir: function () {
            return '';
        },
        /**
         *  @return {string []}
         */
        getargs: function () {
            return args;
        },
        set_args: function (argv) {
            args=argv;
        }
    };
};
BundleModuleCode['com/path']=function (module,exports,global,process){
var process = process || {};
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';
var util = Require('util');


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {
  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

  // Regex to split the tail part of the above into [*, dir, basename, ext]
  var splitTailRe =
      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

  // Function to split a filename into [root, dir, basename, ext]
  // windows version
  var splitPath = function(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  };

  var normalizeUNCRoot = function(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  };

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else if (!resolvedDevice) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive. We're sure the device is not
        // an unc path at this points, because unc paths are always absolute.
        path = process.env['=' + resolvedDevice];
        // Verify that a drive-local cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (!path || path.substr(0, 3).toLowerCase() !==
            resolvedDevice.toLowerCase() + '\\') {
          path = resolvedDevice + '\\';
        }
      }

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = exports.isAbsolute(path),
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = exports.isAbsolute(path),
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // If device is a drive letter, we'll normalize to lower case.
    if (device && device.charAt(1) === ':') {
      device = device[0].toLowerCase() + device.substr(1);
    }

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
      device = normalizeUNCRoot(device);
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.isAbsolute = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = !!device && device.charAt(1) !== ':';
    // UNC paths are always absolute
    return !!result[2] || isUnc;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      if (!util.isString(p)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }

    var paths = Array.prototype.filter.call(arguments, f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
      joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }

    return exports.normalize(joined);
  };

  // path.relative(from, to)
  // it will solve the relative path from 'from' to 'to', for instance:
  // from = 'C:\\orandea\\test\\aaa'
  // to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  // windows version
  exports.relative = function(from, to) {
    from = exports.resolve(from);
    to = exports.resolve(to);

    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var toParts = trim(to.split('\\'));

    var lowerFromParts = trim(lowerFrom.split('\\'));
    var lowerToParts = trim(lowerTo.split('\\'));

    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    if (samePartsLength == 0) {
      return to;
    }

    var outputParts = [];
    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('\\');
  };

  exports.sep = '\\';
  exports.delimiter = ';';

} else /* posix */ {

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (!util.isString(path)) {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function(path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function() {
    var path = '';
    for (var i = 0; i < arguments.length; i++) {
      var segment = arguments[i];
      if (!util.isString(segment)) {
        throw new TypeError('Arguments to path.join must be strings');
      }
      if (segment) {
        if (!path) {
          path += segment;
        } else {
          path += '/' + segment;
        }
      }
    }
    return exports.normalize(path);
  };


  // path.relative(from, to)
  // posix version
  exports.relative = function(from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';
}

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};


exports.exists = util.deprecate(function(path, callback) {
  require('fs').exists(path, callback);
}, 'path.exists is now called `fs.exists`.');


exports.existsSync = util.deprecate(function(path) {
  return require('fs').existsSync(path);
}, 'path.existsSync is now called `fs.existsSync`.');


if (isWindows) {
  exports._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path))
      return path;

    if (!path) {
      return '';
    }

    var resolvedPath = exports.resolve(path);

    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      // path is local filesystem path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      // path is network UNC path, which needs to be converted
      // to long UNC path.
      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }

    return path;
  };
} else {
  exports._makeLong = function(path) {
    return path;
  };
}
}());
};
BundleModuleCode['os/util']=function (module,exports,global,process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = function isBuffer(arg) {
  return arg && typeof arg === 'object'
             && typeof arg.copy === 'function'
             && typeof arg.fill === 'function'
             && typeof arg.readUInt8 === 'function';
};

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */

exports.inherits = Require('os/inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
};
BundleModuleCode['os/inherits']=function (module,exports,global,process){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}
};
BundleModuleCode['com/sprintf']=function (module,exports,global,process){
(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            try {_fmt = _fmt.substring(match[0].length)} catch (e) {throw new SyntaxError("[sprintf] unexpected fromat")}
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== "undefined") {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === "function" && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === "undefined" ? this : window);
};
BundleModuleCode['os/base64']=function (module,exports,global,process){
var keyStr = "ABCDEFGHIJKLMNOP" +
               "QRSTUVWXYZabcdef" +
               "ghijklmnopqrstuv" +
               "wxyz0123456789+/" +
               "=";
var Buffer=Require('buffer').Buffer;
var Base64 = {
  encode: function (input) {
     input = escape(input);
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < input.length);

     return output;
  },

  encodeBuf: function (input) {
     var output = "";
     var NaN = output.charCodeAt(2);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var len = input.length;
     do {
        chr1 = input.readUInt8(i++);
        chr2 = (i<len)?input.readUInt8(i++):NaN;
        chr3 = (i<len)?input.readUInt8(i++):NaN;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
           enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
           enc4 = 64;
        }

        output = output +
           keyStr.charAt(enc1) +
           keyStr.charAt(enc2) +
           keyStr.charAt(enc3) +
           keyStr.charAt(enc4);
        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";
     } while (i < len);

     return output;
  },

  decode: function (input) {
     var output = "";
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;

     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
           output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
           output = output + String.fromCharCode(chr3);
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return unescape(output);
  },
  decodeBuf: function (input) {
     var len = input.length;
     var buf = new Buffer(len);
     var chr1, chr2, chr3 = "";
     var enc1, enc2, enc3, enc4 = "";
     var i = 0;
     var buflen = 0;
     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
     buf.fill(0);
     do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.writeUInt8(chr1,buflen);
        buflen++;
        if (enc3 != 64) {
          buf.writeUInt8(chr2,buflen);
          buflen++;
        }
        if (enc4 != 64) {
            buf.writeUInt8(chr3,buflen);
            buflen++;
        }

        chr1 = chr2 = chr3 = "";
        enc1 = enc2 = enc3 = enc4 = "";

     } while (i < input.length);

     return buf.slice(0,buflen);
  }

};


module.exports = Base64;
};
BundleModuleCode['plugins/db/db_browser.js']=function (module,exports,global,process){
/* Standalone DB SQLjson API plugin used outside of workbook environment */
Script('aux/buffer')
Script('./inspect')
Script('plugins/com/utils_browser')
Script('./jsonfn')
Script('./db')
};
/* https://github.com/feross/buffer */
/* Buffer Polyfill for Browsers */

function BufferInit() {
! function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).buffer = t()
    }
}(function() {
    return function() {
        return function t(r, e, n) {
            function i(f, u) {
                if (!e[f]) {
                    if (!r[f]) {
                        var s = "function" == typeof require && require;
                        if (!u && s) return s(f, !0);
                        if (o) return o(f, !0);
                        var h = new Error("Cannot find module '" + f + "'");
                        throw h.code = "MODULE_NOT_FOUND", h
                    }
                    var a = e[f] = {
                        exports: {}
                    };
                    r[f][0].call(a.exports, function(t) {
                        return i(r[f][1][t] || t)
                    }, a, a.exports, t, r, e, n)
                }
                return e[f].exports
            }
            for (var o = "function" == typeof require && require, f = 0; f < n.length; f++) i(n[f]);
            return i
        }
    }()({
        1: [function(t, r, e) {
            (function(r) {
                "use strict";
                var n = t("base64-js"),
                    i = t("ieee754"),
                    o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                e.Buffer = r, e.SlowBuffer = function(t) {
                    +t != t && (t = 0);
                    return r.alloc(+t)
                }, e.INSPECT_MAX_BYTES = 50;
                var f = 2147483647;

                function u(t) {
                    if (t > f) throw new RangeError('The value "' + t + '" is invalid for option "size"');
                    var e = new Uint8Array(t);
                    return Object.setPrototypeOf(e, r.prototype), e
                }

                function r(t, r, e) {
                    if ("number" == typeof t) {
                        if ("string" == typeof r) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return a(t)
                    }
                    return s(t, r, e)
                }

                function s(t, e, n) {
                    if ("string" == typeof t) return function(t, e) {
                        "string" == typeof e && "" !== e || (e = "utf8");
                        if (!r.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
                        var n = 0 | l(t, e),
                            i = u(n),
                            o = i.write(t, e);
                        o !== n && (i = i.slice(0, o));
                        return i
                    }(t, e);
                    if (ArrayBuffer.isView(t)) return p(t);
                    if (null == t) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
                    if (z(t, ArrayBuffer) || t && z(t.buffer, ArrayBuffer)) return function(t, e, n) {
                        if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
                        if (t.byteLength < e + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        var i;
                        i = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, e) : new Uint8Array(t, e, n);
                        return Object.setPrototypeOf(i, r.prototype), i
                    }(t, e, n);
                    if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var i = t.valueOf && t.valueOf();
                    if (null != i && i !== t) return r.from(i, e, n);
                    var o = function(t) {
                        if (r.isBuffer(t)) {
                            var e = 0 | c(t.length),
                                n = u(e);
                            return 0 === n.length ? n : (t.copy(n, 0, 0, e), n)
                        }
                        if (void 0 !== t.length) return "number" != typeof t.length || D(t.length) ? u(0) : p(t);
                        if ("Buffer" === t.type && Array.isArray(t.data)) return p(t.data)
                    }(t);
                    if (o) return o;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return r.from(t[Symbol.toPrimitive]("string"), e, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
                }

                function h(t) {
                    if ("number" != typeof t) throw new TypeError('"size" argument must be of type number');
                    if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"')
                }

                function a(t) {
                    return h(t), u(t < 0 ? 0 : 0 | c(t))
                }

                function p(t) {
                    for (var r = t.length < 0 ? 0 : 0 | c(t.length), e = u(r), n = 0; n < r; n += 1) e[n] = 255 & t[n];
                    return e
                }

                function c(t) {
                    if (t >= f) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + f.toString(16) + " bytes");
                    return 0 | t
                }

                function l(t, e) {
                    if (r.isBuffer(t)) return t.length;
                    if (ArrayBuffer.isView(t) || z(t, ArrayBuffer)) return t.byteLength;
                    if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
                    var n = t.length,
                        i = arguments.length > 2 && !0 === arguments[2];
                    if (!i && 0 === n) return 0;
                    for (var o = !1;;) switch (e) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return P(t).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return j(t).length;
                        default:
                            if (o) return i ? -1 : P(t).length;
                            e = ("" + e).toLowerCase(), o = !0
                    }
                }

                function y(t, r, e) {
                    var n = t[r];
                    t[r] = t[e], t[e] = n
                }

                function g(t, e, n, i, o) {
                    if (0 === t.length) return -1;
                    if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), D(n = +n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
                        if (o) return -1;
                        n = t.length - 1
                    } else if (n < 0) {
                        if (!o) return -1;
                        n = 0
                    }
                    if ("string" == typeof e && (e = r.from(e, i)), r.isBuffer(e)) return 0 === e.length ? -1 : w(t, e, n, i, o);
                    if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : w(t, [e], n, i, o);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function w(t, r, e, n, i) {
                    var o, f = 1,
                        u = t.length,
                        s = r.length;
                    if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                        if (t.length < 2 || r.length < 2) return -1;
                        f = 2, u /= 2, s /= 2, e /= 2
                    }

                    function h(t, r) {
                        return 1 === f ? t[r] : t.readUInt16BE(r * f)
                    }
                    if (i) {
                        var a = -1;
                        for (o = e; o < u; o++)
                            if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                                if (-1 === a && (a = o), o - a + 1 === s) return a * f
                            } else -1 !== a && (o -= o - a), a = -1
                    } else
                        for (e + s > u && (e = u - s), o = e; o >= 0; o--) {
                            for (var p = !0, c = 0; c < s; c++)
                                if (h(t, o + c) !== h(r, c)) {
                                    p = !1;
                                    break
                                }
                            if (p) return o
                        }
                    return -1
                }

                function d(t, r, e, n) {
                    e = Number(e) || 0;
                    var i = t.length - e;
                    n ? (n = Number(n)) > i && (n = i) : n = i;
                    var o = r.length;
                    n > o / 2 && (n = o / 2);
                    for (var f = 0; f < n; ++f) {
                        var u = parseInt(r.substr(2 * f, 2), 16);
                        if (D(u)) return f;
                        t[e + f] = u
                    }
                    return f
                }

                function v(t, r, e, n) {
                    return N(P(r, t.length - e), t, e, n)
                }

                function b(t, r, e, n) {
                    return N(function(t) {
                        for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
                        return r
                    }(r), t, e, n)
                }

                function m(t, r, e, n) {
                    return b(t, r, e, n)
                }

                function E(t, r, e, n) {
                    return N(j(r), t, e, n)
                }

                function B(t, r, e, n) {
                    return N(function(t, r) {
                        for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f) e = t.charCodeAt(f), n = e >> 8, i = e % 256, o.push(i), o.push(n);
                        return o
                    }(r, t.length - e), t, e, n)
                }

                function A(t, r, e) {
                    return 0 === r && e === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(r, e))
                }

                function U(t, r, e) {
                    e = Math.min(t.length, e);
                    for (var n = [], i = r; i < e;) {
                        var o, f, u, s, h = t[i],
                            a = null,
                            p = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                        if (i + p <= e) switch (p) {
                            case 1:
                                h < 128 && (a = h);
                                break;
                            case 2:
                                128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                                break;
                            case 3:
                                o = t[i + 1], f = t[i + 2], 128 == (192 & o) && 128 == (192 & f) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & f) > 2047 && (s < 55296 || s > 57343) && (a = s);
                                break;
                            case 4:
                                o = t[i + 1], f = t[i + 2], u = t[i + 3], 128 == (192 & o) && 128 == (192 & f) && 128 == (192 & u) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & f) << 6 | 63 & u) > 65535 && s < 1114112 && (a = s)
                        }
                        null === a ? (a = 65533, p = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += p
                    }
                    return function(t) {
                        var r = t.length;
                        if (r <= T) return String.fromCharCode.apply(String, t);
                        var e = "",
                            n = 0;
                        for (; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += T));
                        return e
                    }(n)
                }
                e.kMaxLength = f, r.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var t = new Uint8Array(1),
                            r = {
                                foo: function() {
                                    return 42
                                }
                            };
                        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(t, r), 42 === t.foo()
                    } catch (t) {
                        return !1
                    }
                }(), r.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(r.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(r.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.byteOffset
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && r[Symbol.species] === r && Object.defineProperty(r, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), r.poolSize = 8192, r.from = function(t, r, e) {
                    return s(t, r, e)
                }, Object.setPrototypeOf(r.prototype, Uint8Array.prototype), Object.setPrototypeOf(r, Uint8Array), r.alloc = function(t, r, e) {
                    return function(t, r, e) {
                        return h(t), t <= 0 ? u(t) : void 0 !== r ? "string" == typeof e ? u(t).fill(r, e) : u(t).fill(r) : u(t)
                    }(t, r, e)
                }, r.allocUnsafe = function(t) {
                    return a(t)
                }, r.allocUnsafeSlow = function(t) {
                    return a(t)
                }, r.isBuffer = function(t) {
                    return null != t && !0 === t._isBuffer && t !== r.prototype
                }, r.compare = function(t, e) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), z(e, Uint8Array) && (e = r.from(e, e.offset, e.byteLength)), !r.isBuffer(t) || !r.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (t === e) return 0;
                    for (var n = t.length, i = e.length, o = 0, f = Math.min(n, i); o < f; ++o)
                        if (t[o] !== e[o]) {
                            n = t[o], i = e[o];
                            break
                        }
                    return n < i ? -1 : i < n ? 1 : 0
                }, r.isEncoding = function(t) {
                    switch (String(t).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, r.concat = function(t, e) {
                    if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === t.length) return r.alloc(0);
                    var n;
                    if (void 0 === e)
                        for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                    var i = r.allocUnsafe(e),
                        o = 0;
                    for (n = 0; n < t.length; ++n) {
                        var f = t[n];
                        if (z(f, Uint8Array) && (f = r.from(f)), !r.isBuffer(f)) throw new TypeError('"list" argument must be an Array of Buffers');
                        f.copy(i, o), o += f.length
                    }
                    return i
                }, r.byteLength = l, r.prototype._isBuffer = !0, r.prototype.swap16 = function() {
                    var t = this.length;
                    if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var r = 0; r < t; r += 2) y(this, r, r + 1);
                    return this
                }, r.prototype.swap32 = function() {
                    var t = this.length;
                    if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var r = 0; r < t; r += 4) y(this, r, r + 3), y(this, r + 1, r + 2);
                    return this
                }, r.prototype.swap64 = function() {
                    var t = this.length;
                    if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var r = 0; r < t; r += 8) y(this, r, r + 7), y(this, r + 1, r + 6), y(this, r + 2, r + 5), y(this, r + 3, r + 4);
                    return this
                }, r.prototype.toString = function() {
                    var t = this.length;
                    return 0 === t ? "" : 0 === arguments.length ? U(this, 0, t) : function(t, r, e) {
                        var n = !1;
                        if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
                        if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
                        if ((e >>>= 0) <= (r >>>= 0)) return "";
                        for (t || (t = "utf8");;) switch (t) {
                            case "hex":
                                return L(this, r, e);
                            case "utf8":
                            case "utf-8":
                                return U(this, r, e);
                            case "ascii":
                                return I(this, r, e);
                            case "latin1":
                            case "binary":
                                return S(this, r, e);
                            case "base64":
                                return A(this, r, e);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return R(this, r, e);
                            default:
                                if (n) throw new TypeError("Unknown encoding: " + t);
                                t = (t + "").toLowerCase(), n = !0
                        }
                    }.apply(this, arguments)
                }, r.prototype.toLocaleString = r.prototype.toString, r.prototype.equals = function(t) {
                    if (!r.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                    return this === t || 0 === r.compare(this, t)
                }, r.prototype.inspect = function() {
                    var t = "",
                        r = e.INSPECT_MAX_BYTES;
                    return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"
                }, o && (r.prototype[o] = r.prototype.inspect), r.prototype.compare = function(t, e, n, i, o) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), !r.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
                    if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), e < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError("out of range index");
                    if (i >= o && e >= n) return 0;
                    if (i >= o) return -1;
                    if (e >= n) return 1;
                    if (this === t) return 0;
                    for (var f = (o >>>= 0) - (i >>>= 0), u = (n >>>= 0) - (e >>>= 0), s = Math.min(f, u), h = this.slice(i, o), a = t.slice(e, n), p = 0; p < s; ++p)
                        if (h[p] !== a[p]) {
                            f = h[p], u = a[p];
                            break
                        }
                    return f < u ? -1 : u < f ? 1 : 0
                }, r.prototype.includes = function(t, r, e) {
                    return -1 !== this.indexOf(t, r, e)
                }, r.prototype.indexOf = function(t, r, e) {
                    return g(this, t, r, e, !0)
                }, r.prototype.lastIndexOf = function(t, r, e) {
                    return g(this, t, r, e, !1)
                }, r.prototype.write = function(t, r, e, n) {
                    if (void 0 === r) n = "utf8", e = this.length, r = 0;
                    else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
                    else {
                        if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        r >>>= 0, isFinite(e) ? (e >>>= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
                    }
                    var i = this.length - r;
                    if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    n || (n = "utf8");
                    for (var o = !1;;) switch (n) {
                        case "hex":
                            return d(this, t, r, e);
                        case "utf8":
                        case "utf-8":
                            return v(this, t, r, e);
                        case "ascii":
                            return b(this, t, r, e);
                        case "latin1":
                        case "binary":
                            return m(this, t, r, e);
                        case "base64":
                            return E(this, t, r, e);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return B(this, t, r, e);
                        default:
                            if (o) throw new TypeError("Unknown encoding: " + n);
                            n = ("" + n).toLowerCase(), o = !0
                    }
                }, r.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                var T = 4096;

                function I(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
                    return n
                }

                function S(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
                    return n
                }

                function L(t, r, e) {
                    var n = t.length;
                    (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
                    for (var i = "", o = r; o < e; ++o) i += F[t[o]];
                    return i
                }

                function R(t, r, e) {
                    for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
                    return i
                }

                function C(t, r, e) {
                    if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                    if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
                }

                function O(t, e, n, i, o, f) {
                    if (!r.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (e > o || e < f) throw new RangeError('"value" argument is out of bounds');
                    if (n + i > t.length) throw new RangeError("Index out of range")
                }

                function _(t, r, e, n, i, o) {
                    if (e + n > t.length) throw new RangeError("Index out of range");
                    if (e < 0) throw new RangeError("Index out of range")
                }

                function x(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || _(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4
                }

                function M(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || _(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8
                }
                r.prototype.slice = function(t, e) {
                    var n = this.length;
                    (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t);
                    var i = this.subarray(t, e);
                    return Object.setPrototypeOf(i, r.prototype), i
                }, r.prototype.readUIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n
                }, r.prototype.readUIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);) n += this[t + --r] * i;
                    return n
                }, r.prototype.readUInt8 = function(t, r) {
                    return t >>>= 0, r || C(t, 1, this.length), this[t]
                }, r.prototype.readUInt16LE = function(t, r) {
                    return t >>>= 0, r || C(t, 2, this.length), this[t] | this[t + 1] << 8
                }, r.prototype.readUInt16BE = function(t, r) {
                    return t >>>= 0, r || C(t, 2, this.length), this[t] << 8 | this[t + 1]
                }, r.prototype.readUInt32LE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
                }, r.prototype.readUInt32BE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
                }, r.prototype.readIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n
                }, r.prototype.readIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || C(t, r, this.length);
                    for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) o += this[t + --n] * i;
                    return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o
                }, r.prototype.readInt8 = function(t, r) {
                    return t >>>= 0, r || C(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                }, r.prototype.readInt16LE = function(t, r) {
                    t >>>= 0, r || C(t, 2, this.length);
                    var e = this[t] | this[t + 1] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt16BE = function(t, r) {
                    t >>>= 0, r || C(t, 2, this.length);
                    var e = this[t + 1] | this[t] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt32LE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
                }, r.prototype.readInt32BE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
                }, r.prototype.readFloatLE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), i.read(this, t, !0, 23, 4)
                }, r.prototype.readFloatBE = function(t, r) {
                    return t >>>= 0, r || C(t, 4, this.length), i.read(this, t, !1, 23, 4)
                }, r.prototype.readDoubleLE = function(t, r) {
                    return t >>>= 0, r || C(t, 8, this.length), i.read(this, t, !0, 52, 8)
                }, r.prototype.readDoubleBE = function(t, r) {
                    return t >>>= 0, r || C(t, 8, this.length), i.read(this, t, !1, 52, 8)
                }, r.prototype.writeUIntLE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || O(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = 1,
                        o = 0;
                    for (this[r] = 255 & t; ++o < e && (i *= 256);) this[r + o] = t / i & 255;
                    return r + e
                }, r.prototype.writeUIntBE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || O(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = e - 1,
                        o = 1;
                    for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);) this[r + i] = t / o & 255;
                    return r + e
                }, r.prototype.writeUInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 1, 255, 0), this[r] = 255 & t, r + 1
                }, r.prototype.writeUInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 65535, 0), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeUInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeUInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t, r + 4
                }, r.prototype.writeUInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeIntLE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        O(this, t, r, e, i - 1, -i)
                    }
                    var o = 0,
                        f = 1,
                        u = 0;
                    for (this[r] = 255 & t; ++o < e && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeIntBE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        O(this, t, r, e, i - 1, -i)
                    }
                    var o = e - 1,
                        f = 1,
                        u = 0;
                    for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
                }, r.prototype.writeInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 32767, -32768), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 2147483647, -2147483648), this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4
                }, r.prototype.writeInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || O(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeFloatLE = function(t, r, e) {
                    return x(this, t, r, !0, e)
                }, r.prototype.writeFloatBE = function(t, r, e) {
                    return x(this, t, r, !1, e)
                }, r.prototype.writeDoubleLE = function(t, r, e) {
                    return M(this, t, r, !0, e)
                }, r.prototype.writeDoubleBE = function(t, r, e) {
                    return M(this, t, r, !1, e)
                }, r.prototype.copy = function(t, e, n, i) {
                    if (!r.isBuffer(t)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0;
                    if (0 === t.length || 0 === this.length) return 0;
                    if (e < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (i < 0) throw new RangeError("sourceEnd out of bounds");
                    i > this.length && (i = this.length), t.length - e < i - n && (i = t.length - e + n);
                    var o = i - n;
                    if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(e, n, i);
                    else if (this === t && n < e && e < i)
                        for (var f = o - 1; f >= 0; --f) t[f + e] = this[f + n];
                    else Uint8Array.prototype.set.call(t, this.subarray(n, i), e);
                    return o
                }, r.prototype.fill = function(t, e, n, i) {
                    if ("string" == typeof t) {
                        if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                        if ("string" == typeof i && !r.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                        if (1 === t.length) {
                            var o = t.charCodeAt(0);
                            ("utf8" === i && o < 128 || "latin1" === i) && (t = o)
                        }
                    } else "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t));
                    if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index");
                    if (n <= e) return this;
                    var f;
                    if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t)
                        for (f = e; f < n; ++f) this[f] = t;
                    else {
                        var u = r.isBuffer(t) ? t : r.from(t, i),
                            s = u.length;
                        if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                        for (f = 0; f < n - e; ++f) this[f + e] = u[f % s]
                    }
                    return this
                };
                var k = /[^+\/0-9A-Za-z-_]/g;

                function P(t, r) {
                    var e;
                    r = r || 1 / 0;
                    for (var n = t.length, i = null, o = [], f = 0; f < n; ++f) {
                        if ((e = t.charCodeAt(f)) > 55295 && e < 57344) {
                            if (!i) {
                                if (e > 56319) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (f + 1 === n) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = e;
                                continue
                            }
                            if (e < 56320) {
                                (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                                continue
                            }
                            e = 65536 + (i - 55296 << 10 | e - 56320)
                        } else i && (r -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, e < 128) {
                            if ((r -= 1) < 0) break;
                            o.push(e)
                        } else if (e < 2048) {
                            if ((r -= 2) < 0) break;
                            o.push(e >> 6 | 192, 63 & e | 128)
                        } else if (e < 65536) {
                            if ((r -= 3) < 0) break;
                            o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                        } else {
                            if (!(e < 1114112)) throw new Error("Invalid code point");
                            if ((r -= 4) < 0) break;
                            o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                        }
                    }
                    return o
                }

                function j(t) {
                    return n.toByteArray(function(t) {
                        if ((t = (t = t.split("=")[0]).trim().replace(k, "")).length < 2) return "";
                        for (; t.length % 4 != 0;) t += "=";
                        return t
                    }(t))
                }

                function N(t, r, e, n) {
                    for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i) r[i + e] = t[i];
                    return i
                }

                function z(t, r) {
                    return t instanceof r || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === r.name
                }

                function D(t) {
                    return t != t
                }
                var F = function() {
                    for (var t = new Array(256), r = 0; r < 16; ++r)
                        for (var e = 16 * r, n = 0; n < 16; ++n) t[e + n] = "0123456789abcdef" [r] + "0123456789abcdef" [n];
                    return t
                }()
            }).call(this, t("buffer").Buffer)
        }, {
            "base64-js": 2,
            buffer: 5,
            ieee754: 3
        }],
        2: [function(t, r, e) {
            "use strict";
            e.byteLength = function(t) {
                var r = h(t),
                    e = r[0],
                    n = r[1];
                return 3 * (e + n) / 4 - n
            }, e.toByteArray = function(t) {
                var r, e, n = h(t),
                    f = n[0],
                    u = n[1],
                    s = new o(function(t, r, e) {
                        return 3 * (r + e) / 4 - e
                    }(0, f, u)),
                    a = 0,
                    p = u > 0 ? f - 4 : f;
                for (e = 0; e < p; e += 4) r = i[t.charCodeAt(e)] << 18 | i[t.charCodeAt(e + 1)] << 12 | i[t.charCodeAt(e + 2)] << 6 | i[t.charCodeAt(e + 3)], s[a++] = r >> 16 & 255, s[a++] = r >> 8 & 255, s[a++] = 255 & r;
                2 === u && (r = i[t.charCodeAt(e)] << 2 | i[t.charCodeAt(e + 1)] >> 4, s[a++] = 255 & r);
                1 === u && (r = i[t.charCodeAt(e)] << 10 | i[t.charCodeAt(e + 1)] << 4 | i[t.charCodeAt(e + 2)] >> 2, s[a++] = r >> 8 & 255, s[a++] = 255 & r);
                return s
            }, e.fromByteArray = function(t) {
                for (var r, e = t.length, i = e % 3, o = [], f = 0, u = e - i; f < u; f += 16383) o.push(a(t, f, f + 16383 > u ? u : f + 16383));
                1 === i ? (r = t[e - 1], o.push(n[r >> 2] + n[r << 4 & 63] + "==")) : 2 === i && (r = (t[e - 2] << 8) + t[e - 1], o.push(n[r >> 10] + n[r >> 4 & 63] + n[r << 2 & 63] + "="));
                return o.join("")
            };
            for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = 0, s = f.length; u < s; ++u) n[u] = f[u], i[f.charCodeAt(u)] = u;

            function h(t) {
                var r = t.length;
                if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var e = t.indexOf("=");
                return -1 === e && (e = r), [e, e === r ? 0 : 4 - e % 4]
            }

            function a(t, r, e) {
                for (var i, o, f = [], u = r; u < e; u += 3) i = (t[u] << 16 & 16711680) + (t[u + 1] << 8 & 65280) + (255 & t[u + 2]), f.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]);
                return f.join("")
            }
            i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
        }, {}],
        3: [function(t, r, e) {
            e.read = function(t, r, e, n, i) {
                var o, f, u = 8 * i - n - 1,
                    s = (1 << u) - 1,
                    h = s >> 1,
                    a = -7,
                    p = e ? i - 1 : 0,
                    c = e ? -1 : 1,
                    l = t[r + p];
                for (p += c, o = l & (1 << -a) - 1, l >>= -a, a += u; a > 0; o = 256 * o + t[r + p], p += c, a -= 8);
                for (f = o & (1 << -a) - 1, o >>= -a, a += n; a > 0; f = 256 * f + t[r + p], p += c, a -= 8);
                if (0 === o) o = 1 - h;
                else {
                    if (o === s) return f ? NaN : 1 / 0 * (l ? -1 : 1);
                    f += Math.pow(2, n), o -= h
                }
                return (l ? -1 : 1) * f * Math.pow(2, o - n)
            }, e.write = function(t, r, e, n, i, o) {
                var f, u, s, h = 8 * o - i - 1,
                    a = (1 << h) - 1,
                    p = a >> 1,
                    c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    l = n ? 0 : o - 1,
                    y = n ? 1 : -1,
                    g = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0;
                for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, f = a) : (f = Math.floor(Math.log(r) / Math.LN2), r * (s = Math.pow(2, -f)) < 1 && (f--, s *= 2), (r += f + p >= 1 ? c / s : c * Math.pow(2, 1 - p)) * s >= 2 && (f++, s /= 2), f + p >= a ? (u = 0, f = a) : f + p >= 1 ? (u = (r * s - 1) * Math.pow(2, i), f += p) : (u = r * Math.pow(2, p - 1) * Math.pow(2, i), f = 0)); i >= 8; t[e + l] = 255 & u, l += y, u /= 256, i -= 8);
                for (f = f << i | u, h += i; h > 0; t[e + l] = 255 & f, l += y, f /= 256, h -= 8);
                t[e + l - y] |= 128 * g
            }
        }, {}],
        4: [function(t, r, e) {
            arguments[4][2][0].apply(e, arguments)
        }, {
            dup: 2
        }],
        5: [function(t, r, e) {
            (function(r) {
                "use strict";
                var n = t("base64-js"),
                    i = t("ieee754");
                e.Buffer = r, e.SlowBuffer = function(t) {
                    +t != t && (t = 0);
                    return r.alloc(+t)
                }, e.INSPECT_MAX_BYTES = 50;
                var o = 2147483647;

                function f(t) {
                    if (t > o) throw new RangeError('The value "' + t + '" is invalid for option "size"');
                    var e = new Uint8Array(t);
                    return e.__proto__ = r.prototype, e
                }

                function r(t, r, e) {
                    if ("number" == typeof t) {
                        if ("string" == typeof r) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return h(t)
                    }
                    return u(t, r, e)
                }

                function u(t, e, n) {
                    if ("string" == typeof t) return function(t, e) {
                        "string" == typeof e && "" !== e || (e = "utf8");
                        if (!r.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
                        var n = 0 | c(t, e),
                            i = f(n),
                            o = i.write(t, e);
                        o !== n && (i = i.slice(0, o));
                        return i
                    }(t, e);
                    if (ArrayBuffer.isView(t)) return a(t);
                    if (null == t) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
                    if (z(t, ArrayBuffer) || t && z(t.buffer, ArrayBuffer)) return function(t, e, n) {
                        if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
                        if (t.byteLength < e + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        var i;
                        i = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, e) : new Uint8Array(t, e, n);
                        return i.__proto__ = r.prototype, i
                    }(t, e, n);
                    if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var i = t.valueOf && t.valueOf();
                    if (null != i && i !== t) return r.from(i, e, n);
                    var o = function(t) {
                        if (r.isBuffer(t)) {
                            var e = 0 | p(t.length),
                                n = f(e);
                            return 0 === n.length ? n : (t.copy(n, 0, 0, e), n)
                        }
                        if (void 0 !== t.length) return "number" != typeof t.length || D(t.length) ? f(0) : a(t);
                        if ("Buffer" === t.type && Array.isArray(t.data)) return a(t.data)
                    }(t);
                    if (o) return o;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return r.from(t[Symbol.toPrimitive]("string"), e, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
                }

                function s(t) {
                    if ("number" != typeof t) throw new TypeError('"size" argument must be of type number');
                    if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"')
                }

                function h(t) {
                    return s(t), f(t < 0 ? 0 : 0 | p(t))
                }

                function a(t) {
                    for (var r = t.length < 0 ? 0 : 0 | p(t.length), e = f(r), n = 0; n < r; n += 1) e[n] = 255 & t[n];
                    return e
                }

                function p(t) {
                    if (t >= o) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
                    return 0 | t
                }

                function c(t, e) {
                    if (r.isBuffer(t)) return t.length;
                    if (ArrayBuffer.isView(t) || z(t, ArrayBuffer)) return t.byteLength;
                    if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
                    var n = t.length,
                        i = arguments.length > 2 && !0 === arguments[2];
                    if (!i && 0 === n) return 0;
                    for (var o = !1;;) switch (e) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return P(t).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return j(t).length;
                        default:
                            if (o) return i ? -1 : P(t).length;
                            e = ("" + e).toLowerCase(), o = !0
                    }
                }

                function l(t, r, e) {
                    var n = t[r];
                    t[r] = t[e], t[e] = n
                }

                function y(t, e, n, i, o) {
                    if (0 === t.length) return -1;
                    if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), D(n = +n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
                        if (o) return -1;
                        n = t.length - 1
                    } else if (n < 0) {
                        if (!o) return -1;
                        n = 0
                    }
                    if ("string" == typeof e && (e = r.from(e, i)), r.isBuffer(e)) return 0 === e.length ? -1 : g(t, e, n, i, o);
                    if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : g(t, [e], n, i, o);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function g(t, r, e, n, i) {
                    var o, f = 1,
                        u = t.length,
                        s = r.length;
                    if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                        if (t.length < 2 || r.length < 2) return -1;
                        f = 2, u /= 2, s /= 2, e /= 2
                    }

                    function h(t, r) {
                        return 1 === f ? t[r] : t.readUInt16BE(r * f)
                    }
                    if (i) {
                        var a = -1;
                        for (o = e; o < u; o++)
                            if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                                if (-1 === a && (a = o), o - a + 1 === s) return a * f
                            } else -1 !== a && (o -= o - a), a = -1
                    } else
                        for (e + s > u && (e = u - s), o = e; o >= 0; o--) {
                            for (var p = !0, c = 0; c < s; c++)
                                if (h(t, o + c) !== h(r, c)) {
                                    p = !1;
                                    break
                                }
                            if (p) return o
                        }
                    return -1
                }

                function w(t, r, e, n) {
                    e = Number(e) || 0;
                    var i = t.length - e;
                    n ? (n = Number(n)) > i && (n = i) : n = i;
                    var o = r.length;
                    n > o / 2 && (n = o / 2);
                    for (var f = 0; f < n; ++f) {
                        var u = parseInt(r.substr(2 * f, 2), 16);
                        if (D(u)) return f;
                        t[e + f] = u
                    }
                    return f
                }

                function d(t, r, e, n) {
                    return N(P(r, t.length - e), t, e, n)
                }

                function v(t, r, e, n) {
                    return N(function(t) {
                        for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
                        return r
                    }(r), t, e, n)
                }

                function b(t, r, e, n) {
                    return v(t, r, e, n)
                }

                function m(t, r, e, n) {
                    return N(j(r), t, e, n)
                }

                function E(t, r, e, n) {
                    return N(function(t, r) {
                        for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f) e = t.charCodeAt(f), n = e >> 8, i = e % 256, o.push(i), o.push(n);
                        return o
                    }(r, t.length - e), t, e, n)
                }

                function B(t, r, e) {
                    return 0 === r && e === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(r, e))
                }

                function A(t, r, e) {
                    e = Math.min(t.length, e);
                    for (var n = [], i = r; i < e;) {
                        var o, f, u, s, h = t[i],
                            a = null,
                            p = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                        if (i + p <= e) switch (p) {
                            case 1:
                                h < 128 && (a = h);
                                break;
                            case 2:
                                128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                                break;
                            case 3:
                                o = t[i + 1], f = t[i + 2], 128 == (192 & o) && 128 == (192 & f) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & f) > 2047 && (s < 55296 || s > 57343) && (a = s);
                                break;
                            case 4:
                                o = t[i + 1], f = t[i + 2], u = t[i + 3], 128 == (192 & o) && 128 == (192 & f) && 128 == (192 & u) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & f) << 6 | 63 & u) > 65535 && s < 1114112 && (a = s)
                        }
                        null === a ? (a = 65533, p = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += p
                    }
                    return function(t) {
                        var r = t.length;
                        if (r <= U) return String.fromCharCode.apply(String, t);
                        var e = "",
                            n = 0;
                        for (; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += U));
                        return e
                    }(n)
                }
                e.kMaxLength = o, r.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var t = new Uint8Array(1);
                        return t.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function() {
                                return 42
                            }
                        }, 42 === t.foo()
                    } catch (t) {
                        return !1
                    }
                }(), r.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(r.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(r.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (r.isBuffer(this)) return this.byteOffset
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && r[Symbol.species] === r && Object.defineProperty(r, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), r.poolSize = 8192, r.from = function(t, r, e) {
                    return u(t, r, e)
                }, r.prototype.__proto__ = Uint8Array.prototype, r.__proto__ = Uint8Array, r.alloc = function(t, r, e) {
                    return function(t, r, e) {
                        return s(t), t <= 0 ? f(t) : void 0 !== r ? "string" == typeof e ? f(t).fill(r, e) : f(t).fill(r) : f(t)
                    }(t, r, e)
                }, r.allocUnsafe = function(t) {
                    return h(t)
                }, r.allocUnsafeSlow = function(t) {
                    return h(t)
                }, r.isBuffer = function(t) {
                    return null != t && !0 === t._isBuffer && t !== r.prototype
                }, r.compare = function(t, e) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), z(e, Uint8Array) && (e = r.from(e, e.offset, e.byteLength)), !r.isBuffer(t) || !r.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (t === e) return 0;
                    for (var n = t.length, i = e.length, o = 0, f = Math.min(n, i); o < f; ++o)
                        if (t[o] !== e[o]) {
                            n = t[o], i = e[o];
                            break
                        }
                    return n < i ? -1 : i < n ? 1 : 0
                }, r.isEncoding = function(t) {
                    switch (String(t).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, r.concat = function(t, e) {
                    if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === t.length) return r.alloc(0);
                    var n;
                    if (void 0 === e)
                        for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                    var i = r.allocUnsafe(e),
                        o = 0;
                    for (n = 0; n < t.length; ++n) {
                        var f = t[n];
                        if (z(f, Uint8Array) && (f = r.from(f)), !r.isBuffer(f)) throw new TypeError('"list" argument must be an Array of Buffers');
                        f.copy(i, o), o += f.length
                    }
                    return i
                }, r.byteLength = c, r.prototype._isBuffer = !0, r.prototype.swap16 = function() {
                    var t = this.length;
                    if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var r = 0; r < t; r += 2) l(this, r, r + 1);
                    return this
                }, r.prototype.swap32 = function() {
                    var t = this.length;
                    if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var r = 0; r < t; r += 4) l(this, r, r + 3), l(this, r + 1, r + 2);
                    return this
                }, r.prototype.swap64 = function() {
                    var t = this.length;
                    if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var r = 0; r < t; r += 8) l(this, r, r + 7), l(this, r + 1, r + 6), l(this, r + 2, r + 5), l(this, r + 3, r + 4);
                    return this
                }, r.prototype.toString = function() {
                    var t = this.length;
                    return 0 === t ? "" : 0 === arguments.length ? A(this, 0, t) : function(t, r, e) {
                        var n = !1;
                        if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
                        if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
                        if ((e >>>= 0) <= (r >>>= 0)) return "";
                        for (t || (t = "utf8");;) switch (t) {
                            case "hex":
                                return S(this, r, e);
                            case "utf8":
                            case "utf-8":
                                return A(this, r, e);
                            case "ascii":
                                return T(this, r, e);
                            case "latin1":
                            case "binary":
                                return I(this, r, e);
                            case "base64":
                                return B(this, r, e);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return L(this, r, e);
                            default:
                                if (n) throw new TypeError("Unknown encoding: " + t);
                                t = (t + "").toLowerCase(), n = !0
                        }
                    }.apply(this, arguments)
                }, r.prototype.toLocaleString = r.prototype.toString, r.prototype.equals = function(t) {
                    if (!r.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                    return this === t || 0 === r.compare(this, t)
                }, r.prototype.inspect = function() {
                    var t = "",
                        r = e.INSPECT_MAX_BYTES;
                    return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"
                }, r.prototype.compare = function(t, e, n, i, o) {
                    if (z(t, Uint8Array) && (t = r.from(t, t.offset, t.byteLength)), !r.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
                    if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === i && (i = 0), void 0 === o && (o = this.length), e < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError("out of range index");
                    if (i >= o && e >= n) return 0;
                    if (i >= o) return -1;
                    if (e >= n) return 1;
                    if (this === t) return 0;
                    for (var f = (o >>>= 0) - (i >>>= 0), u = (n >>>= 0) - (e >>>= 0), s = Math.min(f, u), h = this.slice(i, o), a = t.slice(e, n), p = 0; p < s; ++p)
                        if (h[p] !== a[p]) {
                            f = h[p], u = a[p];
                            break
                        }
                    return f < u ? -1 : u < f ? 1 : 0
                }, r.prototype.includes = function(t, r, e) {
                    return -1 !== this.indexOf(t, r, e)
                }, r.prototype.indexOf = function(t, r, e) {
                    return y(this, t, r, e, !0)
                }, r.prototype.lastIndexOf = function(t, r, e) {
                    return y(this, t, r, e, !1)
                }, r.prototype.write = function(t, r, e, n) {
                    if (void 0 === r) n = "utf8", e = this.length, r = 0;
                    else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
                    else {
                        if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        r >>>= 0, isFinite(e) ? (e >>>= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
                    }
                    var i = this.length - r;
                    if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    n || (n = "utf8");
                    for (var o = !1;;) switch (n) {
                        case "hex":
                            return w(this, t, r, e);
                        case "utf8":
                        case "utf-8":
                            return d(this, t, r, e);
                        case "ascii":
                            return v(this, t, r, e);
                        case "latin1":
                        case "binary":
                            return b(this, t, r, e);
                        case "base64":
                            return m(this, t, r, e);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return E(this, t, r, e);
                        default:
                            if (o) throw new TypeError("Unknown encoding: " + n);
                            n = ("" + n).toLowerCase(), o = !0
                    }
                }, r.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                var U = 4096;

                function T(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
                    return n
                }

                function I(t, r, e) {
                    var n = "";
                    e = Math.min(t.length, e);
                    for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
                    return n
                }

                function S(t, r, e) {
                    var n = t.length;
                    (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
                    for (var i = "", o = r; o < e; ++o) i += k(t[o]);
                    return i
                }

                function L(t, r, e) {
                    for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
                    return i
                }

                function R(t, r, e) {
                    if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                    if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
                }

                function C(t, e, n, i, o, f) {
                    if (!r.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (e > o || e < f) throw new RangeError('"value" argument is out of bounds');
                    if (n + i > t.length) throw new RangeError("Index out of range")
                }

                function O(t, r, e, n, i, o) {
                    if (e + n > t.length) throw new RangeError("Index out of range");
                    if (e < 0) throw new RangeError("Index out of range")
                }

                function _(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || O(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4
                }

                function x(t, r, e, n, o) {
                    return r = +r, e >>>= 0, o || O(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8
                }
                r.prototype.slice = function(t, e) {
                    var n = this.length;
                    (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t);
                    var i = this.subarray(t, e);
                    return i.__proto__ = r.prototype, i
                }, r.prototype.readUIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n
                }, r.prototype.readUIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);) n += this[t + --r] * i;
                    return n
                }, r.prototype.readUInt8 = function(t, r) {
                    return t >>>= 0, r || R(t, 1, this.length), this[t]
                }, r.prototype.readUInt16LE = function(t, r) {
                    return t >>>= 0, r || R(t, 2, this.length), this[t] | this[t + 1] << 8
                }, r.prototype.readUInt16BE = function(t, r) {
                    return t >>>= 0, r || R(t, 2, this.length), this[t] << 8 | this[t + 1]
                }, r.prototype.readUInt32LE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
                }, r.prototype.readUInt32BE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
                }, r.prototype.readIntLE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
                    return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n
                }, r.prototype.readIntBE = function(t, r, e) {
                    t >>>= 0, r >>>= 0, e || R(t, r, this.length);
                    for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) o += this[t + --n] * i;
                    return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o
                }, r.prototype.readInt8 = function(t, r) {
                    return t >>>= 0, r || R(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                }, r.prototype.readInt16LE = function(t, r) {
                    t >>>= 0, r || R(t, 2, this.length);
                    var e = this[t] | this[t + 1] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt16BE = function(t, r) {
                    t >>>= 0, r || R(t, 2, this.length);
                    var e = this[t + 1] | this[t] << 8;
                    return 32768 & e ? 4294901760 | e : e
                }, r.prototype.readInt32LE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
                }, r.prototype.readInt32BE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
                }, r.prototype.readFloatLE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), i.read(this, t, !0, 23, 4)
                }, r.prototype.readFloatBE = function(t, r) {
                    return t >>>= 0, r || R(t, 4, this.length), i.read(this, t, !1, 23, 4)
                }, r.prototype.readDoubleLE = function(t, r) {
                    return t >>>= 0, r || R(t, 8, this.length), i.read(this, t, !0, 52, 8)
                }, r.prototype.readDoubleBE = function(t, r) {
                    return t >>>= 0, r || R(t, 8, this.length), i.read(this, t, !1, 52, 8)
                }, r.prototype.writeUIntLE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = 1,
                        o = 0;
                    for (this[r] = 255 & t; ++o < e && (i *= 256);) this[r + o] = t / i & 255;
                    return r + e
                }, r.prototype.writeUIntBE = function(t, r, e, n) {
                    (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                    var i = e - 1,
                        o = 1;
                    for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);) this[r + i] = t / o & 255;
                    return r + e
                }, r.prototype.writeUInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 1, 255, 0), this[r] = 255 & t, r + 1
                }, r.prototype.writeUInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeUInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeUInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t, r + 4
                }, r.prototype.writeUInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeIntLE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        C(this, t, r, e, i - 1, -i)
                    }
                    var o = 0,
                        f = 1,
                        u = 0;
                    for (this[r] = 255 & t; ++o < e && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeIntBE = function(t, r, e, n) {
                    if (t = +t, r >>>= 0, !n) {
                        var i = Math.pow(2, 8 * e - 1);
                        C(this, t, r, e, i - 1, -i)
                    }
                    var o = e - 1,
                        f = 1,
                        u = 0;
                    for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);) t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255;
                    return r + e
                }, r.prototype.writeInt8 = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
                }, r.prototype.writeInt16LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2
                }, r.prototype.writeInt16BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2
                }, r.prototype.writeInt32LE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4
                }, r.prototype.writeInt32BE = function(t, r, e) {
                    return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4
                }, r.prototype.writeFloatLE = function(t, r, e) {
                    return _(this, t, r, !0, e)
                }, r.prototype.writeFloatBE = function(t, r, e) {
                    return _(this, t, r, !1, e)
                }, r.prototype.writeDoubleLE = function(t, r, e) {
                    return x(this, t, r, !0, e)
                }, r.prototype.writeDoubleBE = function(t, r, e) {
                    return x(this, t, r, !1, e)
                }, r.prototype.copy = function(t, e, n, i) {
                    if (!r.isBuffer(t)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), e || (e = 0), i > 0 && i < n && (i = n), i === n) return 0;
                    if (0 === t.length || 0 === this.length) return 0;
                    if (e < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (i < 0) throw new RangeError("sourceEnd out of bounds");
                    i > this.length && (i = this.length), t.length - e < i - n && (i = t.length - e + n);
                    var o = i - n;
                    if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(e, n, i);
                    else if (this === t && n < e && e < i)
                        for (var f = o - 1; f >= 0; --f) t[f + e] = this[f + n];
                    else Uint8Array.prototype.set.call(t, this.subarray(n, i), e);
                    return o
                }, r.prototype.fill = function(t, e, n, i) {
                    if ("string" == typeof t) {
                        if ("string" == typeof e ? (i = e, e = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                        if ("string" == typeof i && !r.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                        if (1 === t.length) {
                            var o = t.charCodeAt(0);
                            ("utf8" === i && o < 128 || "latin1" === i) && (t = o)
                        }
                    } else "number" == typeof t && (t &= 255);
                    if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index");
                    if (n <= e) return this;
                    var f;
                    if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t)
                        for (f = e; f < n; ++f) this[f] = t;
                    else {
                        var u = r.isBuffer(t) ? t : r.from(t, i),
                            s = u.length;
                        if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                        for (f = 0; f < n - e; ++f) this[f + e] = u[f % s]
                    }
                    return this
                };
                var M = /[^+\/0-9A-Za-z-_]/g;

                function k(t) {
                    return t < 16 ? "0" + t.toString(16) : t.toString(16)
                }

                function P(t, r) {
                    var e;
                    r = r || 1 / 0;
                    for (var n = t.length, i = null, o = [], f = 0; f < n; ++f) {
                        if ((e = t.charCodeAt(f)) > 55295 && e < 57344) {
                            if (!i) {
                                if (e > 56319) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (f + 1 === n) {
                                    (r -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = e;
                                continue
                            }
                            if (e < 56320) {
                                (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                                continue
                            }
                            e = 65536 + (i - 55296 << 10 | e - 56320)
                        } else i && (r -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, e < 128) {
                            if ((r -= 1) < 0) break;
                            o.push(e)
                        } else if (e < 2048) {
                            if ((r -= 2) < 0) break;
                            o.push(e >> 6 | 192, 63 & e | 128)
                        } else if (e < 65536) {
                            if ((r -= 3) < 0) break;
                            o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
                        } else {
                            if (!(e < 1114112)) throw new Error("Invalid code point");
                            if ((r -= 4) < 0) break;
                            o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                        }
                    }
                    return o
                }

                function j(t) {
                    return n.toByteArray(function(t) {
                        if ((t = (t = t.split("=")[0]).trim().replace(M, "")).length < 2) return "";
                        for (; t.length % 4 != 0;) t += "=";
                        return t
                    }(t))
                }

                function N(t, r, e, n) {
                    for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i) r[i + e] = t[i];
                    return i
                }

                function z(t, r) {
                    return t instanceof r || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === r.name
                }

                function D(t) {
                    return t != t
                }
            }).call(this, t("buffer").Buffer)
        }, {
            "base64-js": 4,
            buffer: 5,
            ieee754: 6
        }],
        6: [function(t, r, e) {
            arguments[4][3][0].apply(e, arguments)
        }, {
            dup: 3
        }]
    }, {}, [1])(1)
});
Buffer=buffer.Buffer;

/* Remove any buffer toJSON bindings */
if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
if (!ArrayBuffer['isView']) {
  ArrayBuffer.isView = function(a) {
    return a !== null && typeof(a) === "object" && a['buffer'] instanceof ArrayBuffer;
  }
};
}

BufferInit();

/**
 * Module exports.
 */
function InspectInit() {

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @license MIT (© Joyent)
 */
/* legacy: obj, showHidden, depth, colors*/

function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeNoColor(str, styleType) {
  return str;
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isUndefined(arg) {
  return arg === void 0;
}

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isNull(arg) {
  return arg === null;
}

function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwn(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  try {
    if (ctx.showHidden && Object.getOwnPropertyNames) {
      keys = Object.getOwnPropertyNames(value);
    }
  } catch (e) {
    // ignore
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (Array.isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = { value: void 0 };
  try {
    // ie6 › navigator.toString
    // throws Error: Object doesn't support this property or method
    desc.value = value[key];
  } catch (e) {
    // ignore
  }
  try {
    // ie10 › Object.getOwnPropertyDescriptor(window.location, 'hash')
    // throws TypeError: Object doesn't support this action
    if (Object.getOwnPropertyDescriptor) {
      desc = Object.getOwnPropertyDescriptor(value, key) || desc;
    }
  } catch (e) {
    // ignore
  }
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwn(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
return inspect
}

window.inspect =InspectInit();


var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest');

Utils = {
  addCSS : function (styles) {
    var styleSheet = document.createElement("style")
    styleSheet.type = "text/css"
    styleSheet.innerText = styles
    document.head.appendChild(styleSheet)    
  },
  
  // Analyze JS using esprima
  analyze : function  (code)  {
    var more='';
    try {
      var ast = esprima.parse(code, { tolerant: true, loc:true });
      if (ast.errors && ast.errors.length>0) more = ast.errors[0];
    } catch (e) {
      if (e.lineNumber) more = e+', in line '+e.lineNumber; 
    }
    return more;
  },

  beep : function (duration,volume,frequency,type) {
    if (!Utils.audioCtx) Utils.audioCtx=new(window.AudioContext || window.webkitAudioContext)();
    
    var oscillator = Utils.audioCtx.createOscillator();
    var gainNode = Utils.audioCtx.createGain();
    duration=duration||10;
    volume=volume||100;
    frequency=frequency||1000;
    type=type||'sine';
    oscillator.connect(gainNode);
    gainNode.connect(Utils.audioCtx.destination);

    gainNode.gain.value = volume;
    oscillator.frequency.value = frequency;
    oscillator.type = type;


    oscillator.start();

    setTimeout(
      function() {
        oscillator.stop();
      },
      duration
    );
    
    oscillator.onended = function () {
        Utils.audioCtx.close();
        Utils.audioCtx=null;
    };
  },

  BrowserVersion :(function(){
    if (typeof navigator=='undefined') return {name:'',version:0};
      var ua= navigator.userAgent, tem, 
      M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
      }
      if(M[1]=== 'Chrome'){
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
      }
      M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
      if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
      return {name:M[0],version:M[1]};
    })(),

  /** Change CSS 
   *
   */
  changeCSS: function changeCSS(theClass,element,value) {
     var cssRules;

     for (var S = 0; S < document.styleSheets.length; S++) {
	   try {
	     document.styleSheets[S].insertRule(theClass+' { '+element+': '+value+'; }',
                                            document.styleSheets[S][cssRules].length);
	   } catch(err) {
	     try{
           document.styleSheets[S].addRule(theClass,element+': '+value+';');
	     } catch(err){
		     try{
			   if (document.styleSheets[S]['rules']) {
			     cssRules = 'rules';
			    } else if (document.styleSheets[S]['cssRules']) {
			     cssRules = 'cssRules';
			    } else {
			     //no rules found... browser unknown
			    }

			    for (var R = 0; R < document.styleSheets[S][cssRules].length; R++) {
			      if (document.styleSheets[S][cssRules][R].selectorText == theClass) {
				    if(document.styleSheets[S][cssRules][R].style[element]){
				      document.styleSheets[S][cssRules][R].style[element] = value;
				      break;
				    }
			      }
		        }
		     } catch (err){}
	     }
	   }
    }
  },
  
  copy : function (o) {
    // recursively copy objects
    var _o,p;
    if (Utils.isArray(o)) {
      if (typeof o[0] != 'object') return o.slice();
      else return o.map(function (e) {
            if (typeof e == 'object') return Utils.copy(e);
              else return e;
            });
      
    } else if (Utils.isObject(o)) {
      if (o instanceof Date) return o;
      _o={};
      for(p in o) _o[p]=(typeof o[p]=='object'?Utils.copy(o[p]):o[p]);
      return _o;
    } 
    else if (Utils.isString(o)) 
      return o.slice();
    else return o;
  
  },
  
  empty : function (v) {
    if (v == undefined) return true;
    if (Utils.isString(v)) return v=='';
    if (Utils.isArray(v)) return v.length==0;
    if (Utils.isObject(v)) return Object.keys(v).length==0;
    return false    
  },
  
  equal : function (o1,o2) {
    if (Utils.isArray(o1) && Utils.isArray(o2)) {
      if (o1.length!=o2.length) return false;
      for(var i=0;i<o1.length;i++) if (o1[i]!=o2[i]) return false;
      return true;
    }
    if (Utils.isObject(o1) && Utils.isObject(o2)) {
      var keys = Object.keys(o1);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      var keys = Object.keys(o2);
      for(var i in keys) {
        if (!Utils.equal(o1[keys[i]],o2[keys[i]])) return false;
      }
      return true;
    }
    return o1==o2
  },
  
  eraseCookie:function eraseCookie(name) {   
      document.cookie = name+'=; Max-Age=-99999999;';  
  },



  flatten: function flatten(array) {
      var res=[];
      var len=array.length;
      var i;
      for(i=0;i<len;i++) {
          var element=array[i];
          if (!Utils.isArray(element)) res.push(element);
          else {
              var j;
              var len2=element.length;
              for(j=0;j<len2;j++) {
                  var element2=element[j];
                  res.push(element2);
              }
          }
      }
      return res;
  },

  getCookie:function getCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for(var i=0;i < ca.length;i++) {
          var c = ca[i];
          while (c.charAt(0)==' ') c = c.substring(1,c.length);
          if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
      }
      return Utils.sessionCache[name]; // fallback 
  },

  getCookieObject:function (name,def) {
      var nameEQ = name + "=";
      try {
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
          var c = ca[i];
          while (c.charAt(0)==' ') c = c.substring(1,c.length);
          if (c.indexOf(nameEQ) == 0) return JSONfn.parse(c.substring(nameEQ.length,c.length));
        }
        return def;
      } catch (e) {
      console.log(e)
        return def;
      }
  },

  getOptions : function (text) {
    var tokens=text.split(' ');
    var options={}
    tokens.forEach(function (av) {
      var pl = av.split('=')
      if (pl.length==2) options[pl[0]]=pl[1];
    })
    return options
  },


  hashCode: function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
       h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  },

  info: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^(function[ ]*[a-zA-Z0-9_]*\([^\)]+\))/)[1];
    }
  },
  
  inspect : (typeof inspect!='undefined'?inspect:null),
  isArray: function isArray(o) {
    if (o==_ || o ==null) return false;
    else return typeof o == "array" || (typeof o == "object" && o.constructor === Array);
  },
  isArrayArray: function isArrayArray(o) {
    if (o==_ || o ==null) return false;
    else return Utils.isArray(o) &&
                Utils.isArray(o[0]);
  },
  isBuffer: function isBuffer(o) {
    if (o==_ || o ==null) return false;
    else return o instanceof Buffer;
  },
  isEmpty: function isEmpty(o) {
    for(var prop in o) {
       if (o[prop]!=undefined) return false;
    }
    return true;  
  },
  isError : function (o) {
    return o instanceof Error
  },
  isFunction: function isFunction(o) {
      return typeof o == "function";
  },
  isMatrix: function isMatrix(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o) &&
                 Utils.isArray(o[0])) ||
                (Math.MatrixTA && Math.MatrixTA.isMatrix(o)) ||
                (Math.Matrix && Math.Matrix.isMatrix(o))
                ;
  },
  isObj: function isObj(o) {
      return typeof o == "object";
  },
  isObject: function isObject(o) {
      return typeof o == "object";
  },
  isRegex: function isRegex(o) {
      return o instanceof RegExp;
  },
  isString: function isString(o) {
      return typeof o == "string" || (typeof o == "object" && o.constructor === String);
  },
  isNumber: function isNumber(o) {
      return typeof o == "number" || (typeof o == "object" && o.constructor === Number);
  },
  isBoolean: function isBoolean (o) {
      return typeof o == "boolean"
  },
  isString: function isString(o) {
      return typeof o == "string"
  },
  isStruct: function isStruct(o) {
      return !Utils.isArray(o) && Utils.isObject(o)
  },
  isTypedArray: function isTypedArray(o) {
      return Utils.isObject(o) && o.buffer instanceof ArrayBuffer
  },
  isVector: function isVector(o,noarray) {
    if (o==_ || o ==null) return false;
    else return (!noarray && Utils.isArray(o)) ||
                (Math.VectorTA && Math.VectorTA.isVector(o)) ||
                (Math.Vector && Math.Vector.isVector(o))
                ;
  },

  
  loadFile: function (url,cb) {
    var result,error,_cb=cb;
    if (!_cb) _cb=function (_result,_error) { result=_result; error=_error; }; 
    try {
      // print(url+params)
      var request = new XMLHttpRequest();
      request.open("GET",url, cb);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                _cb(allText);
            } else _cb(null,'GET from '+url+' failed (status)');
        }
      }
      request.onerror = function (err) {
        _cb(null,'GET from '+url+' failed (error)')
      }
      request.send(null);
    } catch (e) {
      _cb(null,e)
    }
    return error||result;
  },

  loadScript: function (filename) {
    var fileref = document.createElement('script');
    fileref.setAttribute("type", "text/javascript");
    fileref.setAttribute("src", filename);
    if (typeof fileref != "undefined")
        document.getElementsByTagName("head")[0].appendChild(fileref)
  },
  
  name: function (o) {
    switch (typeof o) {
      case 'function':
        return o.toString().match(/^function[ ]*([a-zA-Z0-9_]*)\([^\)]+\)/)[1];
    }
  },

  ofCSV : function (source,convert) {
    try {
      Papa.parse(source,{
        skipEmptyLines: true,
        dynamicTyping: true,
        complete: function(results) {
          data=results.data;
          if (convert) { // first line must be header
            header=data.shift();
            data=data.map(function (row) {
              var r={};
              header.forEach(function (col,i) { r[col]=row[i] });
              return r; 
            }) 
          }
        }
      });
      if (data && data[0].length==1) data=data.map(function (row) { return row[0] });
      return data;
    } catch (e) {
      return e;
    }
  },
  
  ofJSON : function (source) {
    return JSONfn.parse(source,{});
  },
  
  /** Convert agent text sources to agent code in JSOB format
   *
   */
  ofString : function (source) {
    var code;
    try {
      // execute script in private context
      eval('code = '+source);
    } catch (e) { console.log(e,source) };
    return code; 
  },

  parseUrl : function (url) {
    if (!url) return {};
    var queryString = url.substring( url.indexOf('?') + 1 );
    if (queryString == url) return {};
    var params = {}, queries, temp, i, l;

    // Split into key/value pairs
    queries = queryString.split("&");

    // Convert the array of strings into an object
    for ( i = 0, l = queries.length; i < l; i++ ) {
        temp = queries[i].split('=');
        if (temp[1]==undefined) temp[1]='true';
        params[temp[0]] = temp[1].replace('%20',' ');
    }

    return params;
  },


  strip: function strip(line) {
    return line.replace(/\"/g,'')
               .replace(/\'/g,'')
  },


  /** Cookie Management
   *
   */
  sessionCache : {},

  setCookie:function setCookie(name,value,days) {
      var expires = "";
      if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days*24*60*60*1000));
          expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
      Utils.sessionCache[name]=value; // fallback if cookies are denied
  },

  setCookieObject:function (name,obj,days) {
      var expires = "";
      var value = JSONfn.stringify(obj);
      if (days) {
          var date = new Date();
          date.setTime(date.getTime() + (days*24*60*60*1000));
          expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
  },
  
  stringToArrayBuffer : function (str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);

    for (var i=0, strLen=str.length; i<strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }

    return buf;
  },

  stringToUint8Array : function (str) {
    var bufView = new Uint8Array(str.length);

    for (var i=0, strLen=str.length; i<strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }

    return bufView;
  },
  
  time : function () { return Date.now() },
  
  /** Convert any object to text source in JSOB format
  *
  */
  toString : function (o) {
    var usebuffer=false;
    var p,i,keys,s='',sep,tokens;
    if (o===null) return 'null';
    else if (Utils.isArray(o)) {
      s='[';sep='';
      for(p in o) {
        s=s+sep+Utils.toString(o[p]);
        sep=',';
      }
      s+=']';
    } else if (o instanceof Buffer) {    
      s='Buffer([';sep='';
      for(i=0;i<o.length;i++) {
        s=s+sep+Utils.toString(o[i]);
        sep=',';
      }
      s+='])';  
    } else if (o instanceof Error) {    
      s='(new Error("'+o.toString()+'"))';
    } else if (Utils.isTypedArray(o)) {    
      s='(new '+Utils.TypedArrayToName(o)+'([';sep='';
      var b=Array.prototype.slice.call(o);
      for(i=0;i<b.length;i++) {
        s=s+sep+String(b[i]);
        sep=',';
      }
      s+=']))';  
    } else if (typeof o == 'object') {
      s='{';sep='';
      keys=Object.keys(o);
      for(i in keys) {
        p=keys[i];
        if (o[p]==undefined) continue;
        s=s+sep+"'"+p+"'"+':'+Utils.toString(o[p]);
        sep=',';
      }
      s+='}';
      if (o.__constructor__) s = '(function () { var o='+s+'; o.__proto__='+o.__constructor__+'.prototype; return o})()';
    } else if (typeof o == 'string')
      s="'"+
            o.toString().replace(/'/g,'\\\'')
                        .replace(/\n/g,'\\n')+
        "'"; 
    else if (typeof o == 'function') {
      s=o.toString(true);   // try minification (true) if supported by platform
      if (tokens=s.match(/function[ ]+([a-zA-Z0-9]+)[ ]*\(\)[ ]*{[^\[]*\[native code\][^}]*}/)) {
        return tokens[1];
      } else return s;
    } else if (o != undefined)
      s=o.toString();
    else s='undefined';
    return s;
  },


  /* TYPED ARRAY */
  typed_arrays : [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ],

  TypedArrayOfName : {
    Int8Array:Int8Array,
    Uint8Array:Uint8Array,
    Int16Array:Int16Array,
    Uint16Array:Uint16Array,
    Int32Array:Int32Array,
    Uint32Array:Uint32Array,
    Float32Array:Float32Array,
    Float64Array:Float64Array  
  },
  TypedArrayToName : function (ftyp) {
        if (ftyp==Int8Array   || ftyp instanceof Int8Array) return 'Int8Array';
        if (ftyp==Uint8Array  || ftyp instanceof Uint8Array) return 'Uint8Array';
        if (ftyp==Int16Array  || ftyp instanceof Int16Array) return 'Int16Array';
        if (ftyp==Uint16Array || ftyp instanceof Uint16Array) return 'Uint16Array';
        if (ftyp==Int32Array  || ftyp instanceof Int32Array) return 'Int32Array';
        if (ftyp==Uint32Array || ftyp instanceof Uint32Array) return 'Uint32Array';
        if (ftyp==Float32Array || ftyp instanceof Float32Array) return 'Float32Array';
        if (ftyp==Float64Array || ftyp instanceof Float64Array) return 'Float64Array';
  },


  uniqueID : function (length) {
    var s='',
        keys=['a','b','c','d','e','f','g','h','i','j','k','l',
              'o','p','q','r','s','t','u','v','w','x','y','z'];
    keys=keys.concat(keys,keys.map(function (k) { return k.toUpperCase() }));
    keys=keys.concat([1,2,3,4,5,6,7,8,9]);
    for(var i=0;i<length;i++) {
      s+= (keys[(Math.random()*keys.length)|0]);
    }
    return s;
  },

  /** request
   *  typeof @options = { url:string, host: string, port:number, path:string, method:"GET"|"PUT", body?:string, headers:{} } 
   *  typeof @callback = function (err, xhr, body)
   */

  request : function (options, callback) {
    var DEFAULT_TIMEOUT = 2000;
    function is_crossDomain(url) {
      var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/


      // jQuery #8138, IE may throw an exception when accessing
      // a field from window.location if document.domain has been set
      var ajaxLocation
      try { ajaxLocation = location.href }
      catch (e) {
        // Use the href attribute of an A element since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
      }

      if (ajaxLocation.match('file:')) return true;

      var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
          , parts = rurl.exec(url.toLowerCase() )

      var result = !!(
        parts &&
        (  parts[1] != ajaxLocParts[1]
        || parts[2] != ajaxLocParts[2]
        || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
        )
      )

      //console.debug('is_crossDomain('+url+') -> ' + result)
      return result
    }

    try {
      var xhr = new XHR(),
          err,
          url = options.url || options.uri || ((options.proto?options.proto:'http')+'://'+options.host+':'+(options.port?options.port:80)+'/'+options.path),
          is_cors = is_crossDomain(url),
          supports_cors = ('withCredentials' in xhr)

      if(is_cors && !supports_cors) {
        err = new Error('Browser does not support cross-origin request: ' + options.uri)
        err.cors = 'unsupported'
        return callback(err, xhr)
      }
      options.headers = options.headers || {};
      options.timeout = options.timeout || DEFAULT_TIMEOUT;
      options.headers = options.headers || {};
      options.body    = options.body || null;

      if(is_cors) xhr.withCredentials = !! options.withCredentials;
      xhr.timeout = options.timeout;

      xhr.onopen = function () {
        for (var key in options.headers)
          xhr.setRequestHeader(key, options.headers[key])      
      }

      xhr.onload = function () {
       if(xhr.status === 0) {
          err = new Error('EREQUEST')
          callback(err, xhr)
       } 
       else callback(null,xhr,xhr.responseText)   
      }

      xhr.ontimeout = function () {
        // XMLHttpRequest timed out. Do something here.
        err = new Error('ETIMEOUT')
        err.duration = options.timeout
        callback(err,xhr, null)
      };

      xhr.onrror = function () {
        // XMLHttpRequest failed. Do something here.
        err = new Error('ESERVER')
        callback(err,xhr, null)
      };

      xhr.onreadystatechange = function () {
        if (xhr.readyState === XHR.DONE) {
          if(xhr.status === 0) {
            err = new Error('ENETWORK')
            callback(err, xhr)
          } 
        }
      };

      switch (options.method) {
        case 'GET':
        case 'get':
          xhr.open('GET', url, true /* async */);
          xhr.send()
          break;
        case 'PUT':
        case 'POST':
        case 'put':
        case 'post':
          xhr.open('POST', url, true /* async */);
          xhr.send(options.body)
          break;
      }
    } catch (e) { _log(options,e);console.log(['xhr error: ',options.host,options.path,e].join(' ')); }
  },
  
  GET: function (url,params,cb,sync) {
    var result;
    // if (sync && !cb) cb=function (_result) { result=_result }; 
    if (url.indexOf('http')!=0) url = 'http://'+url;
    try {
      if (params) {
        var o=params,sep='';
        params='/?';
        for(var p in o) {
          params = params + sep + p + '='+o[p];
          sep='&';
        } 
      } else params='';
      // print(url+params)
      var request = new XMLHttpRequest();
      request.open("GET",url+params, !sync);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                if (allText!='') result=JSONfn.parse(allText);
                else result = new Error('GET data error (empty data)');
                if (cb) cb(result);
            } else {
              result=new Error('GET from '+url+params+' failed (status '+request.status+')');
              if (cb) cb(result)
            }
        }
      }
      request.onerror = function (error) {
        result='Error: GET from '+url+params+' failed: '+error;
        if (cb) cb(result);
      }
      request.send(null);
    } catch (error) {
      result=new Error('GET from '+url+params+' failed: '+error.toString());
      if (cb) cb(result);      
    }
    return result;
  },
  
  POST: function (url,data,cb,sync){
    var result;
    // if (sync && !cb) cb=function (_result) { result=_result }; 
    if (url.indexOf('http')!=0) url = 'http://'+url;
    try {
      var request = new XMLHttpRequest();
      request.open("POST", url, !sync);
      request.onreadystatechange = function () {
        if(request.readyState === 4)
        {
            if(request.status === 200 || request.status == 0)
            {
                var allText = request.responseText;
                try {           
                  if (allText!='') result=JSONfn.parse(allText)
                  else result=new Error('POST data error (empty data)');
                } catch (e) {
                  result = new Error(e.toString());
                }
                if (cb) cb(result);
            } else {
                result = new Error('POST to '+url+' failed (status)');
                if (cb) cb(result);
            }
        }
      }
      request.onerror = function (error) {
        result = new Error('POST to '+url+' failed: '+error);
        if (cb) cb(result)
      }
      request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      request.send(JSONfn.stringify(data));
    } catch (error) {
      result=new Error('POST to '+url+' failed: '+error.toString());
      if (cb) cb(result)
    }
    return result;
  },


  version: '1.5.1'
}

Utils._init = function () {
  Object.addProperty = function (obj,name,fun) {
    if (obj.prototype[name]) return;
    obj.prototype[name]=fun;
    Object.defineProperty(obj.prototype, name, {enumerable: false});
  };

  Object.updateProperty = function (obj,name,fun) {
    obj.prototype[name]=fun;
    Object.defineProperty(obj.prototype, name, {enumerable: false});
  };

  // Array static methods extensions
  if (!Array.create) Array.create = function(length,init) {
        var arr = [], i = length;
        while (i--) {
          arr[i] = init;
        }
        return arr;
    }
    
  if (!Array.matrix) Array.matrix = function (rows,cols,init) {
    if (init==undefined) init=0;
    var mat=[];
    for(var i=0;i<rows;i++) {
      var row=[];
      for(j=0;j<cols;j++) row.push(typeof init == 'function'?init(i,j):init);
      mat.push(row);
    }
    return mat;
  };
  
  // Array prototype extensions
  Object.addProperty(Array,'last',function () { return this[this.length-1] });

  // String static methods extensions
  if (!String.create) String.create = function(size,init) {
        var i, s='';
        init=init||' ';
        for(i=0;i<size;i++) s=s+init;
        return s;
  };
  if (!String.copy) String.copy = function(src) {
        var i,dst='';
        for(i=0;i<src.length;i++) dst=dst+src.charAt(i);
        return dst;
  }; 
  if (!String.get) String.get = function (str,index) {
        return str.charAt(index);
  }
  if (!String.hex) String.hex = function (n,len) {
        // format a hexadecimal number with 'len' figures.
        switch (len) {
            case 2: return (((n>>4) & 0xf).toString(16))+
                            ((n&0xf).toString(16));
            case 4: return (((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 6: return (((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            case 8: return (((n>>28) & 0xf).toString(16)+
                            ((n>>24) & 0xf).toString(16)+
                            ((n>>20) & 0xf).toString(16)+
                            ((n>>16) & 0xf).toString(16)+
                            ((n>>12) & 0xf).toString(16)+
                            ((n>>8) & 0xf).toString(16)+
                            ((n>>4) & 0xf).toString(16)+
                            (n&0xf).toString(16));
            default: return 'format_hex??';
        }
  }; 
  if (!String.set) String.set = function (str,index,char) {
    return str.substr(0, index) + char + str.substr(index+1)
  }
  // String prototype extensions
  Object.addProperty(String,'contains', function (el) {
    return this.includes(el)
  })
  
  Object.addProperty(String, 'hashCode', function (seed) {
    var str=this,seed=seed||0;
    var h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
    h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1>>>0)).toString(16).toUpperCase();
  });
  
  if (typeof assert == 'undefined') assert = function(condmsg) {
    if (condmsg != true) {
        Io.out('** Assertion failed: '+condmsg+' **');
        Io.stacktrace();
        throw Error(condmsg);
    }
  };
}

Utils._init();


/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Vadim Kiryukhin, Stefan Bosse (2020)
 **    $INITIAL:     (C) 2006-2017 Vadim Kiryukhin
 **    $MODIFIED:    by sbosse.
 **    $RCS:         $Id: jsonfn.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.3X
 **
 **    $INFO:
 **
 ** JSONfn - javascript (both node.js and browser) plugin to stringify, 
 **          parse and clone objects with embedded functions in an optional  masked context (mask).
 **        - supported data types: number, boolean, string, array, buffer, typedarray, function, regex
 **
 **     browser:
 **         JSONfn.stringify(obj);
 **         JSONfn.parse(str[, date2obj]);
 **         JSONfn.clone(obj[, date2obj]);
 **
 **     nodejs:
 **       var JSONfn = require('path/to/json-fn');
 **       JSONfn.stringify(obj);
 **       JSONfn.parse(str[, mask]);
 **       JSONfn.clone(obj[, mask]);
 **
 **
 **     @obj      -  Object;
 **     @str      -  String, which is returned by JSONfn.stringify() function; 
 **     @mask     -  Environment Mask (optional)
 **
 **    $ENDOFINFO
 */

var current=null;


function typedarrayTObase64(ta,ftyp) {
  var b,i;
  if (ta.buffer instanceof ArrayBuffer) {
    b=Buffer(ta.buffer);
    if (b.length>0) return b.toString('base64');
  }
  // Fall-back conversion
  switch (ftyp) {
    case Float32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeFloatLE(ta[i],i*4);
      return b.toString('base64');
    case Float64Array: 
      b = Buffer(ta.length*8);
      for(i=0;i<ta.length;i++) b.writeDoubleLE(ta[i],i*8);
      return b.toString('base64');
    case Int16Array: 
      b = Buffer(ta.length*2);
      for(i=0;i<ta.length;i++) b.writeInt16LE(ta[i],i*2);
      return b.toString('base64');
    case Int32Array: 
      b = Buffer(ta.length*4);
      for(i=0;i<ta.length;i++) b.writeInt32LE(ta[i],i*4);
      return b.toString('base64');
  }
  return ta.toString();
}
function base64TOtypedarray(buff,ftyp) {
  var i,ta;
  if (buff.buffer instanceof ArrayBuffer) {
    switch (ftyp) {
      case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
      case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
      case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
      case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
    }
  } else if (typeof Uint8Array.from != 'undefined') {
    switch (ftyp) {
      case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
      case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
      case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
      case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
    }
  } else {
    // Fall-back conversion
    switch (ftyp) {
      case Float32Array: 
        ta=new Float32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readFloatLE(i*4);
        return ta;
      case Float64Array: 
        ta=new Float64Array(buff.length/8);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readDoubleLE(i*8);
        return ta;
      case Int16Array: 
        ta=new Int16Array(buff.length/2);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt16LE(i*2);
        return ta;
      case Int32Array: 
        ta=new Int32Array(buff.length/4);
        for(i=0;i<ta.length;i++) 
          ta[i]=buff.readInt32LE(i*4);
        return ta;
    }
  }
}
(function (exports) {

  exports.stringify = function (obj) {

    return JSON.stringify(obj, function (key, value) {
      if (value instanceof Function || typeof value == 'function')
        return '_PxEnUf_' +Buffer(value.toString(true)).toString('base64');  // try minification (true) if supported
      if (value instanceof Buffer)
        return '_PxEfUb_' +value.toString('base64');
      if (typeof Float64Array != 'undefined' && value instanceof Float64Array)
        return '_PxE6Lf_' + typedarrayTObase64(value,Float64Array);
      if (typeof Float32Array != 'undefined' && value instanceof Float32Array)
        return '_PxE3Lf_' + typedarrayTObase64(value,Float32Array);
      if (typeof Int16Array != 'undefined' && value instanceof Int16Array)
        return '_PxE1Ni_' + typedarrayTObase64(value,Int16Array);
      if (typeof Int32Array != 'undefined' && value instanceof Int32Array)
        return '_PxE3Ni_' + typedarrayTObase64(value,Int32Array);
      if (value instanceof RegExp)
        return '_PxEgEr_' + value;
      
      return value;
    });
  };

  exports.parse = function (str, mask) {
    var code;
    try {
      with (mask||{}) {
        code= JSON.parse(str, function (key, value) {
          var prefix;

          try {
            if (typeof value != 'string') {
              return value;
            }
            if (value.length < 8) {
              return value;
            }
            prefix = value.substring(0, 8);

            if (prefix === '_PxEnUf_') {
              var code = value.slice(8);
              if (code.indexOf('function')==0)  // Backward comp.
                return eval('(' + code + ')');
              else
                return eval('(' + Buffer(code,'base64').toString() + ')');
            }
            if (prefix === '_PxEfUb_')
              return Buffer(value.slice(8),'base64');
            if (prefix === '_PxE6Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float64Array);
            if (prefix === '_PxE3Lf_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Float32Array);
            if (prefix === '_PxE1Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int16Array);
            if (prefix === '_PxE3Ni_')
              return base64TOtypedarray(Buffer(value.slice(8),'base64'),Int32Array);
            if (prefix === '_PxEgEr_')
              return eval(value.slice(8));
           
            return value;
          } catch (e) {
            throw {error:e,value:value};
          }
        });
     };
    } catch (e) {
      throw e.error||e;
    }
   return code;
  };

  exports.clone = function (obj, date2obj) {
    return exports.parse(exports.stringify(obj), date2obj);
  };
  exports.current =function (module) { current=module.current; };

  /* Remove any buffer toJSON bindings */
  if (typeof Buffer != 'undefined' && Buffer.prototype.toJSON) delete Buffer.prototype.toJSON;
  if (typeof buffer == 'object' && buffer.Buffer) delete buffer.Buffer.prototype.toJSON;
  // Alias
  exports.serialize   = exports.stringify;
  exports.deserialize = exports.parse;
  
}(typeof exports === 'undefined' ? (window.JSONfn = {}) : exports));



// A virtual JSON database file system
/* type entry = { kind:'object'|'table'|'db'|'fs'|'file'|'data'|'dir'|'matrix', 
                 data?:buffer|string,  url?:string,
                 name:string, mimetype?:string, meta?:{}, path?:string, }
   type mimetype = 
    'application/octet-stream' |
    'text/plain'
   ..

   SQL (entry='db')
      
   Hierarchical Structuring
   
   type HdFTable = Column {
    id: integer primary key,
    type: integer,
    mimetype: varchar(128),
    createTime: integer,
    lastModTime: integer,
    size: integer,
    name: varchar(512),
    parent: integer,
    meta: varchar (),
    data: blob
   } with Column.fsType = 0:directory,1:file,2:meta,3:table, (4:dataset,5:group)
     
   Meta Data for datasets (YAML format):
    dataspace :
       dimensions : [x,y,..]
    datatype : string | integer | int16 | ..
    attribute1 : ..
   
   type ProjTable = Column {
     id: varchar()|integer,
     type:integer is project or folder,    
     name: varchar(1000),
     description: varchar(1000),
     time: varchar()|integer,
     data: blob|varchar(1000000) is project or folder,
   } with Column.type = 0:directory,1:document
   
   type DocTable = Column {
     id: integer primary key,
     type:integer,
     mimetype: varchar(100),
     description: varchar(65000),
     template: varchar(65000),
     size:integer,
     time:integer,
     content:blob|varchar(1000000)
   } with Column.type = 0:directory,1:document,2:media

  
  Hierarchical DataSet Organisation
  --------------------------------- 
  
  meta data: { datatype:string,dataspace:number [], index?:number, chunk?:[] }
  type DataSetTable = Column {
     id         : integer primary key,
     type       : integer,  --  0:group, 1:direct data, 2:indirect, referenced indexed DataTable
     name       : varchar(),
     time       : integer,
     meta       : varchar(), -- YAML/JSON
     data       : blob|integer|varchar() -- DataTable name or serialized data
   }
   type DataTable = Columns {
     index      : integer primary key,
     type       : integer,  --  1:direct data, 2: indirect data, referenced indexed DataTable
     meta       : varchar(), -- optional, YAML/JSON, for chunks ?
     data       : blob,  
   }
   
  JSON API
  ========
  
  type table = {
    table : key string,
    meta?: {},
    rows : dataset|datagroup|data []
  }
  type dataset = {
    data : key string,
    meta : {},
    dataspace : number [] | [],
    datatype : datatype,
    data : []
  }
  type datagroup = {
    group : key string,
    meta? : {},
    rows : dataset | datagroup [],
  }
  
  type datatype = 'number' | 'float32' | 'float64' | 'int8' | 'int16' | 'int32' | ..
                  'json' | 'string' | 'object'
  type url = string with format "host:port" | "host:port:key1:key2:.." 
*/


DB = {
  // Multiple API views can exist for one physical SQL DB! (sql,sqlfs,sqlproj,sqldoc)
  addDB   : function (path,url,flags) {
    var db;
    var pel = path.split('/'),
        root=DB.store,
        entry;
    if (pel.length==1) entry=path;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[entry]) return new Error('EEXIST');
    if ((!url || url==':memory:') && SQL) {
      db = new SQL.Database();
      root.nodes[entry] = {
        kind  : 'db',
        db    : db,
        name  : entry,
        time  : DB.time(),
        id    : db.db,
        flags : flags||'',
        exec : {
          // TODO
          create: function () {},
          select: function () {},
        }
      }
    } else {
      var db
      if (!flags) db = DB.sql(url);
      else if (flags.indexOf('sqlproj')==0) db = DB.sqlproj(url);
      else if (flags.indexOf('sqlfs')==0)   db = DB.sqlfs(url);
      else if (flags.indexOf('sqldoc')==0)  db = DB.sqldoc(url);
      // Remote SQL DB
      root.nodes[entry] = {
        kind  : 'db',
        name  : entry,
        url   : url,
        time  : DB.time(),
        flags : flags||'',
        exec  : db,
      }
    }
    return root.nodes[entry];
  },
  
  // Add a dataset root table with sqlds API
  addDS : function (path,url,table) {
    var pel = path.split('/'),
        root=DB.store,
        node;
    if (pel.length==1) file=path;
    else {
      node=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[node]) return new Error('EEXIST');
    var db=DB.sqlds(url,table,{});
    // Remote SQL DB
    root.nodes[node] = {
        kind  : 'db',
        name  : node,
        url   : url,
        time  : DB.time(),
        flags : 'sqldataset',
        exec  : db,
      }
    return root.nodes[node];    
  },

  // add JSONfs API (local FS server)
  addFS : function (path,url,flags) {
    var pel = path.split('/'),
        root=DB.store,
        entry;
    if (pel.length==1) entry=path;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[entry]) return new Error('EEXIST');
    // Remote WEX Server
    root.nodes[entry] = {
        kind  : 'fs',
        name  : entry,
        url   : url,
        time  : DB.time(),
        flags : flags||'',
        exec  : DB.wex(url),
    }
    return root.nodes[entry];
  },
  
  addData : function (path,data,meta) {
    var pel = path.split('/'),
        root=DB.store,
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[file]) return new Error('EEXIST');
    root.nodes[file] = {
      kind : 'data',
      data : data,
      size : 0,
      time : DB.time(),
      merta : meta ||{},
      name : file,
    }
    return root.nodes[file];
  },
  
  addFile : function (path,data,mimetype) {
    var pel = path.split('/'),
        root=DB.store,
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
      }
    }
    if (DB.strict && root.nodes[file]) return new Error('EEXIST');
    root.nodes[file] = {
      kind : 'file',
      data : data,
      size : data.length||0,
      time : DB.time(),
      mimetype : mimetype||(typeof data=='string'?'text/plain':'application/javascript'),
      name : file,
    }
    return root.nodes[file];
  },

  // pack generic number arrays into byte buffer (with support for array arrays)  
  array2buffer : function (array,typ,space) {
    var size=array.length,dsize=4;
    typ=typ||'uint32';
    if (!space && Utils.isArray(array[0])) {
      space=[size,array[0].length];
      if (Utils.isArray(array[0][0])) space.push(array[0][0].length);
    }
    if (space) size=space.reduce(function (a,b) { return a*b });
    if (!space) space=[size];
    switch (typ) {
        case 'number': dsize=8; break;
        case 'uint16': dsize=2; break;
        case 'uint32': dsize=4; break;
        case 'int16':  dsize=2; break;
        case 'int32':  dsize=4; break;
        case 'float32': dsize=4; break;
        case 'float64': dsize=8; break;
    }
    var b=Buffer(size*dsize);
    function set(v,off) {
      switch (typ) {
        case 'uint16':  b.writeUInt16LE(v,off); break;
        case 'uint32':  b.writeUInt32LE(v,off); break;
        case 'int16':   b.writeInt16LE(v,off); break;
        case 'int32':   b.writeInt32LE(v,off); break;
        case 'float32': b.writeFloatLE(v,off); break;
        case 'float64': 
        case 'number':
        default:
          b.writeDoubleLE(v,off); break;
      }    
    }
    var v,off=0;
    for(var i=0;i<array.length;i++) {
      switch (space.length) {
        case 1:
          v=array[i];
          set(v,off);
          off += dsize;
          break;
        case 2:
          for (var j=0;j<space[1];j++) {
            v=array[i][j];
            set(v,off);
            off += dsize;    
          }
          break;
        case 3:
          for (var j=0;j<space[1];j++) {
            for (var k=0;k<space[2];k++) {
              v=array[i][j][k];
              set(v,off);
              off += dsize;    
            }
          }
          break;
      }
    }
    return b;
  },
  
  // unpack generic number arrays from buffer (with support for array arrays)
  buffer2array : function (buffer,typ,space) {
    var dsize=4,bsize=(buffer.size||buffer.length),size,length,array=[];
    typ=typ||'uint32';
    if (buffer instanceof Array) return buffer;
    buffer=(buffer instanceof Uint8Array)?Buffer(buffer):buffer;
    if (typ=='number') dsize=8;
    else if (typ.indexOf('64')>0) dsize=8;
    else if (typ.indexOf('32')>0) dsize=4;
    else if (typ.indexOf('16')>0) dsize=2;
    else if (typ.indexOf('8')>0) dsize=1;
    typ=typ.toLowerCase();
    if (space)  size=space.reduce(function (a,b) { return a*b });
    if (!space) space=[bsize/dsize];
    if (size && (size*dsize)!=buffer.length) return new Error('EINVALID');

    function get(off) {
      switch (typ) {
        case 'uint8':   return buffer.readUInt8(off); break;
        case 'uint16':  return buffer.readUInt16LE(off); break;
        case 'uint32':  return buffer.readUInt32LE(off); break;
        case 'int8':    return buffer.readInt8(off); break;
        case 'int16':   return buffer.readInt16LE(off); break;
        case 'int32':   return buffer.readInt32LE(off); break;
        case 'float32': return buffer.readFloatLE(off); break;
        case 'float64': 
        case 'number':
        default:
          return buffer.readDoubleLE(off); break;
      }    
    }
    var v,off=0;
    for(var i=0;i<space[0];i++) {
      switch (space.length) {
        case 1:
          v=get(off);
          array[i]=v;
          off += dsize;
          break;
        case 2:
          array[i]=[];
          for (var j=0;j<space[1];j++) {
            v=get(off);
            array[i][j]=v;
            off += dsize; 
          }
          break;
        case 3:
          array[i]=[];
          for (var j=0;j<space[1];j++) {  
            array[i][j]=[];
            for (var k=0;k<space[2];k++) {
              v=get(off);
              array[i][j][k]=v;
              off += dsize;    
            }
          }
          break;
      }
    }

    return array;
  },

  basename : function (path,extension) {
    if (path[path.length-1]=='/') return '/';
    return extension?
            path.split('/').reverse()[0].replace(RegExp(extension.replace(/\./,'\\.')+'$'),'')
            :
            path.split('/').reverse()[0];
  },
  
  config : {
    // standard default ports
    ports : {
      sqldoc  : 5558, 
      sqlproj : 5550,
    }
  },
  
  delete : function (path,cb) {
    var pel = path.split('/'),
        root=DB.store, base='',
        entry;
    if (pel.length==1) return 0;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry] && root.nodes[entry].kind) {
      delete root.nodes[entry];
      return 1;
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (more.root.flags.contains('sqlproj')) {
            if (more.remains[0]=='projects') more.remains.shift();
            return more.root.exec.delete('/'+more.remains.concat([entry]).join('/'),cb);
          }
          if (more.root.flags.contains('sqldoc')) {
            return more.root.exec.delete('/'+more.remains.concat([entry]).join('/'),cb);
          }
          if (more.remains[0]=='tables') {
            result = root.exec.drop(entry);
            if (!result || result.error) return 0;
            else return 1;
          }
          break;
      }
    }
    return 0;
  },
  
  dirname : function (path) {
    var el=path.split('/');
    el.pop();
    return el.join('/');
  },
  
  error : function (result) {
    try {
      if (typeof result == 'number') return result>=0?false:new Error(result);
      if (!result) return new Error('EIO');
      if (result instanceof Error) return result;
      if (typeof XMLHttpRequestException != 'undefined' &&
          result instanceof XMLHttpRequestException) return new Error(result.message);
      if (typeof result == 'string' && result.indexOf('Error')!=-1) return new Error(result);
      if (result.error) return new Error(result.error);
      if (result.fs) result=result.fs;
      result=result[Object.keys(result)[0]];
      if (!result) return false;
      if (result.error) return new Error(result.error);
      else return false;
    } catch (e) {
      console.log(e,result);
      return e;
    }
  },
  
   
  fok : function (cb) {
    return function (result) { cb(DB.ok(result)) };
  },
  
  init : function () {
    if (typeof SQL != 'undefined') {
      var db = new SQL.Database();
    }
  },
  
  list : function (path,root,cb) {
    var pel = path.split('/'),
        base='',head=path.charAt(0),
        result;
    root=root||DB.store;
    if (pel.length==2 && pel[0]=='' && pel[1]=='')
      return root.nodes;
    else {
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (pel.length==0 && root && root.nodes)
      return root.nodes;
    else if (root) {
      var more = { remains:pel, base:base, root:root };
      if (more.root.kind == 'db') {
        if (more.root.flags.contains('sqlproj')) {
          return more.root.exec.list('/'+more.remains.join('/'),cb);
        }
        if (more.root.flags.contains('sqldoc')) {
          return more.root.exec.list('/'+more.remains.join('/'),cb);
        }
      }
    }
    return new Error('ENOTFOUND');
  },
  
  // Resolve path and return entry descriptor
  // db:          { kind:'dir',name,time,nodes:[] } 
  // sql/tables:  { tables : [], url }  
  // sql:         { kind:'db', name, time, url, exec} 
  // fs:          { name,dir,size,time, nodes?:[] }
  // error:       null|error string
  lookup: function (path,root,cb) {
    var pel = path.split('/'),
        base='',head=path.charAt(0),
        entry, result;
    root=root||DB.store;
    if (pel.length==1) entry=pel[0];
    else if (pel.length==2 && pel[0]=='' && pel[1]=='')
      return root;
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    
    if (pel.length==0 && root && root.nodes)
      return root.nodes[entry];
    else {
      pel.push(entry);
      var more = { remains:pel, base:base, root:root };
      if (more.root.kind == 'db') {
        switch (more.remains[0]) {
          case 'tables':
            if (!more.remains[1]) {
              var tables = more.root.exec.tables();
              return { tables : Utils.isArray(tables)?tables.map(function (name) {
                return {
                  name:name,
                  schema:more.root.exec.schema(name)
                }
              }):tables, url:more.root.url};
            } else if (more.remains.length==2) 
              return more.root.exec.select(more.remains[1],'*'); 
            break;
          case 'projects':
            return more.root.exec.select('ProjTable','*');
          case 'documents':
            return more;
          default:
            if (more.root.flags.contains('sqlproj')) {
              return more.root.exec.lookup('/'+more.remains.join('/'),cb);               
            }
            return more;
        }
      }  
      if (more.root.kind == 'fs' && more.root.exec) {
        if (cb) {
        
        } else {
          result = more.root.exec.lookup('/'+more.remains.join('/'));
          if (Utils.isObject(result) && result.dir) {
            result.nodes = more.root.exec.list('/'+more.remains.join('/'));
            if (result.nodes.files || result.nodes.dirs) 
              result.nodes=result.nodes.dirs.concat(result.nodes.files);
          }
        }
        return result;
      }
    }
    return new Error('ENOTFOUND');
  },
  
  mimeType: function (data) {
    if (typeof data == 'string')
      return data.replace(/[^\x20-\x7E\n\r\t\s]+/g, '').length==data.length?
              'text/plain':'application/octet-stream';
    else {
      for(var i=0;i<data.length;i++) {
        if ((data[i]<0x20 || data[i]>0x7e) && 
            data[i] != 0x0a && 
            data[i] != 0x0d && 
            data[i] != 0x09) return 'application/octet-stream'; 
      }
      return 'text/plain';
    }
  },
  
  
  mkdir : function (path,root,cb) {
    var pel = path.split('/'),
        root=root||DB.store,
        base='',
        entry;
    if (pel[0]=='') pel=pel.slice(1);
    while (pel.length) {
      base += ('/'+pel[0]);
      if (root && root.nodes[pel[0]] && root.nodes[pel[0]].kind != 'dir') {
        root=root.nodes[pel[0]];
        pel=pel.slice(1);
        break;
      } else if (!root.nodes[pel[0]]) root.nodes[pel[0]]={
        kind:'dir',
        time : Date(),
        nodes:{}
      }
      root=root.nodes[pel[0]];
      pel=pel.slice(1);
    }
    if (pel.length==0) return 1;
    
    if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc')) {
            return root.exec.mkdir('/'+more.remains.join('/'),null,cb);
          }
          break;
      }
      return 0;
    } else return 1;

  },
    
  ok : function (result) {
    if (!result) return new Error('ENOTFOUND');
    if (result instanceof Error) return result;
    if (typeof result=='string') return new Error(result);
    if (result.error) return new Error(result.error);
    if (result.fs) result=result.fs;
    result=result[Object.keys(result)[0]];
    if (!result) return new Error('EIO');
    if (result.error) return new Error(result.error);
    else if (result.result) return result.result;
    else return result;
  },
  
  // Read file or document
  // Returns: string|buffer|null 
  read : function (path,mimetype,cb) {
    var pel = path.split('/'),
        root=DB.store,base='',
        entry;
    if (pel.length==1) entry=pel[0];
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else
          break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry]) {
      return root.nodes[entry].data;
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc'))
            return root.exec.read('/'+more.remains.concat([entry]).join('/'),cb);
          if (pel[0]=='tables') {
            return root.exec.select(entry,'*',cb);
          }
          break;
        case 'fs':
          return root.exec.read('/'+more.remains.join('/'),entry,mimetype,cb);
          break;
      }
    }
    return null;
  },
  
  rename : function (path,name) {
    var entry=DB.basename(path),
        parent = DB.lookup(DB.dirname(path));
    if (parent && parent.nodes) {
      var node=parent.nodes[entry];
      if (node) {
        if (node.name) node.name=name;
        delete parent.nodes[entry];
        parent.nodes[name]=node;
        return node;
      }
    }
  },
  
  resolve : function (path) {
    var parts = path.split('/'),
        start = path.charAt(0),
        rparts = [];
    parts.forEach(function (part) {
      if (part=='.') return;
      if (part=='..' && rparts.length) return rparts.pop();
      else if (part=='..') return;
      rparts.push(part);
    });
    return rparts.length==1 && rparts[0]==''?start:rparts.join('/').replace(/\/\//g,'/');
  },
  
  save : function (path) {
    var pel = path.split('/'),
        root=DB.store,base='',
        file;
    if (pel.length==1) file=path;
    else {
      file=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else break;
        pel=pel.slice(1);
      }
    }
    if (pel.length==0 && root && root.nodes) {
      var entry = root.nodes[file];
      if (!entry) return;
      if (entry.kind=='file')
        Common.saveFile(entry.data, entry.name, entry.mimetype);
      else if (entry.kind=='object')
        Common.saveFile(JSONfn.stringify(entry.data), entry.name, 'text/plain');
      else if (entry.kind=='db') {
        var tables = entry.exec.tables();
        var db = {
          tables : {}
        }
        for(var i in tables) {
          db.tables[tables[i]]={}
          db.tables[tables[i]].schema=entry.exec.schema(tables[i]);
          db.tables[tables[i]].rows=entry.exec.select(tables[i],'*');
        }
        Common.saveFile(JSONfn.stringify(db), entry.name, 'text/plain');        
      }
    } else {
    
    }
  },
  
  shortName: function (name,length,cache) {
    var chars = [],off=4;
    name=name.toUpperCase().replace(/\.[a-zA-Z0-9]+$/,'').replace(/[_,\.\~\- \/\°\$\%\!\&]/g,''); 
    if (name.length <= length) {
      chars=name.split('');
    } else {
      for(var i = 0; i < 4; i++)
        chars.push(name[i]);
      for(var i = 4; i < length; i++) {
        off += Math.max(1,((name.length-4)/(length-4))|0);
        chars.push(name[off]);      
      }
    }
    chars=chars.join('');
    var index=0;
    while (cache && cache[chars]) chars=chars.replace(/(..)$/,function (all,c) {
      var digits=index++;
      return String(Math.floor(digits/10))+String(digits%10);
    })
    if (cache) cache[chars]=1;
    return chars;;
  },
  
  store : {
    kind:'dir',
    name:'/',
    flags:'',
    time:Date(),
    nodes:{}
  },
  
  // SQL operations API (generic)
  sql  : function (url) { return {
    // create a new table
    create: function (name,columns,cb) {
      return DB.ok(DB.sqljson(this.url,{
        create: { table: name },
        columns:columns
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    // copy an entire table from this DB to another (dst: sqljson API)
    // Hierarchical tables (e.g., sqlds) must be copied by the respective API (e.g, sqlds.copy)
    copy : function (name,dst,options,cb) {
      options=options||{};
      if (!Utils.isObject(dst)) return new Error('EINVALID');
      if (!cb) {
        var result,stat;
        var schema = this.schema(name);
        if (stat=DB.error(schema)) return stat;
        if (options.overwrite) {
          result = dst.drop(name);
          stat=DB.error(result);
          if (stat) return stat;
        }
        result = dst.create(name,schema);
        stat=DB.error(result);
        if (stat) return stat;
        var rows = this.count(name);
        if (DB.error(rows)) return DB.error(rows);
        rows=DB.ok(rows);
        for (var i=1;i<(rows+1);i++) {
          var data = this.select(name,'*','rowid="'+i+'"');
          if (DB.error(data)) return DB.error(data);
          result=dst.insert(name,DB.ok(data));
          stat=DB.error(result);
          if (options.progress) options.progress(i,rows,DB.ok(result));
          if (stat) return stat;
        }
      }
    },
    count : function (name,count,cb) {
      return DB.ok(DB.sqljson(this.url,{
        select: name,
        count:count||'*'
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    delete: function (name,where,cb) {
      return DB.ok(DB.sqljson(this.url,{
        delete: name,
        where:where
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    do: function (cmd,cb) {

    },
    drop: function (name,cb) {
      return DB.ok(DB.sqljson(this.url,{
        drop: name
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    // returns { changes: number, lastInsertROWID: number, time: number }
    insert: function (name,values,cb) {
      return DB.ok(DB.sqljson(this.url,{
        insert: name,
        values:values
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    select: function (name,columns,where,cb) {
      return DB.ok(DB.sqljson(this.url,{
        select: name,
        columns:columns,
        where:where
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    schema: function (name, cb) {
      var matched;
      var result = DB.ok(DB.sqljson(this.url,{
        schema:  name
      }, cb?DB.fok(function (result) { 
        if (Utils.isError(result)) return cb(result);
        if (typeof result == 'string')
          cb((matched=result.match(/\((.+)\)$/)) && matched[1].split(','))
        else if (Array.isArray(result))
          result.forEach(function (part) { cb((matched=part.match(/\((.+)\)$/)) && matched[1].split(',')) });
        else
          cb(result)}):null,cb!=undefined));
      if (Utils.isError(result)) return result;
      if (typeof result == 'string')
        return (matched=result.match(/\((.+)\)$/)) && matched[1].split(',')
      else if (Array.isArray(result))
        return result.map(function (part) { return (matched=part.match(/\((.+)\)$/)) && matched[1].split(',') });
    },
    tables: function (cb) {
      return DB.ok(DB.sqljson(this.url,{
        tables: {}
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    update: function (name,values,where,cb) {
      return DB.ok(DB.sqljson(this.url,{
        update: name,
        values:values,
        where:where,
      }, cb?DB.fok(cb):null,cb!=undefined))
    },
    url : url,
  }},

   
  // SQLfs API (data file orga)  TODO: new RPC API with micro program code!!!!
  sqlhdfs: function (url) {
    return {
        // append table entry (tables has to be created separately)
        appendTable: function (path,tablename,options,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              appendTable: [path,tablename,options||{}],
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        createFS: function (label,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              createFS: label,
            }
          }, cb?DB.fok(cb):null,cb!=undefined))
        },
        delete : function (path,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              delete: path,
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        // return fs node 
        lookup: function (path,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              lookup: path,
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        mkdir: function (path,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              mkdir: path,
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        read: function (path,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              read: [path],
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        readDir: function (path,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              readDir: path,
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        readFile: function (path,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              readFile: [path],
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        rename: function (path,newname,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              rename: [path,newname],
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        writeFile: function (path,data,mimetype,cb) {
          return DB.ok(DB.sqljson(this.url,{
            hdfs: {
              writeFile: [path,data,mimetype],
            }
          }, cb?DB.fok(cb):null,cb!=undefined))              
        },
        url : url,
    }
  },

  
  // SQLjson RPC client request (with optional access key)
  // format url = "host:port" | "host:port:K1:K2:K3:.."  
  sqljson : function (url,request,callback,async) {
    var tokens = url.split(':');
    if (tokens.length>2) { url = tokens.slice(0,2).join(':'); request.key= tokens.slice(2).join(':'); }
    if (!async && !callback) {
      return Utils.POST(url,request,null,true);
    } else if (callback) {
      return Utils.POST(url,request, function (res) {
        // console.log(res);
        callback(res);
      },!async);
    };
  },
  
  strict:false,
  
  time : function (format) {
    switch (format) {
      case 'milli':
      case 'ms':
        return Date.now();
      case 'YYYYMMDD':
        var today = new Date();
        return (today.getYear()+1900)+
               (today.getMonth()<9?'0'+(today.getMonth()+1):today.getMonth()+1)+
               (today.getDate()<10?'0'+today.getDate():today.getDate())
      case 'YYYYMMDD@HHMM':
        var today = new Date();
        return (today.getYear()+1900)+
               (today.getMonth()<9?'0'+(today.getMonth()+1):today.getMonth()+1)+
               (today.getDate()<10?'0'+(today.getDate()):today.getDate())+
               '@'+
               (today.getHours()<9?'0'+(today.getHours()+1):today.getHours()+1)+
               (today.getMinutes()<10?'0'+(today.getMinutes()):today.getMinutes())              
      default:
        return Date().toString();
    }
  },
  
  timeCompare : function (t1,t2) {
    if (isNaN(Number(t1))) t1=Date.parse(t1);
    if (isNaN(Number(t2))) t2=Date.parse(t2);
    t1=Number(t1); t2=Number(t2);
    return t1<t2?-1:(t1>t2?1:0);
  },
  
  toArray: function (buff,ftyp,dims,layout) {
    var ta = DB.toTypedArray(buff,ftyp);
    if (!layout) layout=123;
    if (!ta) return;
    if (!dims) dims=[ta.length];
    switch (dims.length) {
      case 1: return Array.prototype.slice.call(ta);
      case 2:
        var a=[];
        for(var i=0;i<dims[0];i++) {
          var row=[];
          for(var j=0;j<dims[1];j++) row[j]=ta[i*dims[1]+j];
          a.push(row);
        }
        return a;
    }
  },

  toBuffer : function (a) {
    if (Utils.isBuffer(a)) return a;
    if (Utils.isArray(a)) {
      return DB.array2buffer(a)
    }
    if (Utils.isMatrix(a,true)) {
      if (Utils.isTypedArray(a.data))
        return Buffer(a.data.buffer) // Matrix??
    }
    if (Utils.isVector(a,true)) {
      if (Utils.isTypedArray(a.data))
        return Buffer(a.data.buffer) // Matrix??
    }
  },
  
  toMatrix: function (buff,ftyp,dims,layout) {
    if (!Math.MatrixTA) return new Error('Math.MatrixTA not defined');
    if (!Utils.isFunction(ftyp) || !Utils.isArray(dims)) return;
    var ta = DB.toTypedArray(buff,ftyp);
    return Math.MatrixTA({data:ta,dataspace:dims,dtn:Utils.TypedArrayToName(ftyp),layout:layout});
  },
  
  toTypedArray: function (buff,ftyp) {
    var i,ta;
    if (buff.buffer instanceof ArrayBuffer) {
      switch (ftyp) {
        case Float32Array: return new Float32Array((new Uint8Array(buff)).buffer);
        case Float64Array: return new Float64Array((new Uint8Array(buff)).buffer);
        case Int8Array:    return new Int8Array((new Uint8Array(buff)).buffer);
        case Int16Array:   return new Int16Array((new Uint8Array(buff)).buffer);
        case Int32Array:   return new Int32Array((new Uint8Array(buff)).buffer);
        case Uint8Array:    return new Uint8Array((new Uint8Array(buff)).buffer);
        case Uint16Array:   return new Uint16Array((new Uint8Array(buff)).buffer);
        case Uint32Array:   return new Unt32Array((new Uint8Array(buff)).buffer);
      }
    } else if (typeof Uint8Array.from != 'undefined') {
      switch (ftyp) {
        case Float32Array: return new Float32Array(Uint8Array.from(buff).buffer);
        case Float64Array: return new Float64Array(Uint8Array.from(buff).buffer);
        case Int8Array:    return new Int8Array(Uint8Array.from(buff).buffer);
        case Int16Array:   return new Int16Array(Uint8Array.from(buff).buffer);
        case Int32Array:   return new Int32Array(Uint8Array.from(buff).buffer);
        case Uint8Array:   return new Uint8Array(Uint8Array.from(buff).buffer);
        case Uint16Array:   return new Uint16Array(Uint8Array.from(buff).buffer);
        case Uint32Array:   return new Uint32Array(Uint8Array.from(buff).buffer);
      }
    } else {
      // Fall-back conversion
      switch (ftyp) {
        case Float32Array: 
          ta=new Float32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readFloatLE(i*4);
          return ta;
        case Float64Array: 
          ta=new Float64Array(buff.length/8);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readDoubleLE(i*8);
          return ta;
        case Int8Array: 
          ta=new Int9Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt8(i*2);
          return ta;
        case Int16Array: 
          ta=new Int16Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt16LE(i*2);
          return ta;
        case Int32Array: 
          ta=new Int32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readInt32LE(i*4);
          return ta;
        case Uint8Array: 
          ta=new Uint9Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt8(i*2);
          return ta;
        case Uint16Array: 
          ta=new Uint16Array(buff.length/2);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt16LE(i*2);
          return ta;
        case Uint32Array: 
          ta=new Uint32Array(buff.length/4);
          for(i=0;i<ta.length;i++) 
            ta[i]=buff.readUInt32LE(i*4);
          return ta;
      }
    }
  },

  // Create tree representation of store
  tree : function (root,options) {
    var top={},nodes,root=root||DB.store;

    function add(node,entry) {
      if (node.kind=='dir') {
        var nodes={}
        Object.keys(node.nodes).forEach(function (name) {
              //nodes[name]=DB.tree(root.nodes[entry].nodes[name]);
          // return nodes on opening/construction of sub-tree
          nodes[name]={ _constructor:function () { 
            var _nodes=DB.tree(node.nodes[name]);
            return _nodes;
          }}
        });
        return nodes;
      }
      if (node.kind=='db') { 
        var entry={
          name:node.name,
          kind:node.kind,
          time:node.time,
        }
        if (node.exec && node.exec.tables) {
          // tables = root.nodes[entry].exec.tables();
          entry.tables={ _constructor:function () { 
            try {
              var o={},tables;
              tables = node.exec.tables();
              if (Utils.isArray(tables)) {
                  var coll = node.exec.schema(tables)
                  tables.forEach(function (name,index) {
                    var columns='?',result = coll && coll[index];
                    if (result && result.length) {
                      columns={};
                      result.forEach(function (col) {
                        var tokens = col.split(' ');
                        columns[tokens[0]]=tokens.slice(1).join(' ');
                      })
                    }
                    var rows=node.exec.count?node.exec.count(name):[];
                    o[name]= {
                      name:name,
                      kind:'table',
                      columns:columns,
                      rows:!DB.error(rows)?rows[0]:-1,
                    }
                  });
                }
                return o;
              } catch (e) {console.log(e); return o}
          }} 
        }
        // console.log(node)
        if (node.flags && node.flags.contains('sqlproj')) {
          entry.projects= { _constructor:function () { 
            var o={};
            var rows = node.exec.list('/');
            if (Utils.isArray(rows)) {
              rows.forEach(function (row,index) {
                o[row.name]= { }
              });
            }
            return o;
          }}
        }
        if (node.size != undefined)      entry.size     = node.size;
        if (node.id != undefined)        entry.id       = node.id;
        if (node.mimetype != undefined)  entry.mimetype = node.mimetype;
        if (node.url != undefined)       entry.url      = node.url;
        if (node.async != undefined)     entry.async    = node.async;
        return entry;
      }
      return {
          name:entry,
          kind:node.kind,
          time:node.time,
      }
    }
    if (root.nodes) Object.keys(root.nodes).forEach(function(entry) {
      top[entry]=add(root.nodes[entry],entry);
    }); else top=add(root);
    return top;
  },
  
  types : [
    'application/octet-stream',
    'application/javascript',
    'text/plain',  
  ],
    
  wex : function (url,async) {
    return {
      lookup : function (path,cb) {
        Utils.POST('localhost:11111',{
          cmd:  'lookup',
          path:  path,
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          if (cb) cb(res.reply);
          else result=res.reply;
        },!async)
        return result;
      },
      list : function (dir,cb) {
        var result;
        Utils.POST('localhost:11111',{
          cmd:  'list',
          dir:  dir,
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          var dirs=res.reply.filter(function (entry) { return entry.dir })
                            .sort(function (a,b) { return a.name<b.name?-1:1 }),
              files=res.reply.filter(function (entry) { return !entry.dir })
                             .sort(function (a,b) { return a.name<b.name?-1:1 });
          if (cb) cb({files:files,dirs:dirs});
          else result={files:files,dirs:dirs};
        },!async);
        return result;
      },
      read:  function (dir,entry,mimetype,cb) {
        Utils.POST('localhost:11111',{
          cmd:  'load',
          dir:  dir,
          file: entry,
          mimetype:mimetype||'text',
        },function (res) {
          if (!res || !res.reply) {
            if (cb) cb(res);
            else result=res;
            return;
          }
          if (cb) cb(res.reply);
          else result=res.reply;
        },!async)
        return result;      
      },
      url:url,
    }
  },
  
  write : function (path,data,cb) {
    var pel = path.split('/'),
        root=DB.store,base='',
        entry;
    if (pel.length==1) entry=pel[0];
    else {
      entry=pel.pop();
      if (pel[0]=='') pel=pel.slice(1);
      while (pel.length) {
        base += ('/'+pel[0]);
        if (root.nodes)
          root=root.nodes[pel[0]];
        else
          break;
        pel=pel.slice(1);
      }
    }
    if (root && root.nodes && root.nodes[entry]) {
      root.nodes[entry].data=data;
      return data.length
    } else if (root && root.kind && pel.length) {
      var more = { remains:pel, base:base, root:root };
      switch (root.kind) {
        case 'db':
          if (root.flags.contains('sqldoc'))
            return root.exec.write('/'+more.remains.concat([entry]).join('/'),data,cb);
          break;
      }
    }
    return -1;
  },
  
  version : '1.6.6',
}




Base64=Require('os/base64');
//Buffer=Require('os/buffer').Buffer;
window.DB_BROWSER=DB_BROWSER = Require('plugins/db/db_browser.js');
